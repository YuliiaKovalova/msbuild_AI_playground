diff --git a/Directory.Build.props b/Directory.Build.props
index 21b6d6694f2..ffdf91c5c7d 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -14,8 +14,8 @@
 
   <PropertyGroup>
     <FullFrameworkTFM>net472</FullFrameworkTFM>
-    
-    <!-- 
+
+    <!--
         When updating the version of .NET Core for MSBuild, this property is the 'source of truth'.
         Other locations to update the version number:
           global.json
@@ -43,8 +43,10 @@
   <PropertyGroup>
     <GenerateNeutralResourcesLanguageAttribute>false</GenerateNeutralResourcesLanguageAttribute>
 
-    <!-- NU1603: Microsoft.xunit.netcore.extensions package has dependencies to versions which aren't published, so ignore those warnings
-         NU5105: we're explicitly opting in to semver2, as is most of .NET Core
+    <!--
+        NU1507: ManagePackageVersionsCentrally implies source mapping, which we should consider turning on but it's nontrivial
+        NU1603: Microsoft.xunit.netcore.extensions package has dependencies to versions which aren't published, so ignore those warnings
+        NU5105: we're explicitly opting in to semver2, as is most of .NET Core
         CS1701 and CS1702 are by default ignored by Microsoft.NET.Sdk, but if you define the NoWarn property in Directory.Build.props,
         you don't get those defaults.
         SYSLIB0011: Removing binary formatter will happen as part of a larger .NET-wide effort.
@@ -52,7 +54,7 @@
         RS0016 & RS0017: Roslyn analyzers seem to be bugged, claiming that API's that exist don't and vise-versa: https://github.com/dotnet/msbuild/issues/7903
     -->
 
-    <NoWarn>$(NoWarn);NU1603;NU5105;1701;1702;SYSLIB0011;SYSLIB0037;SYSLIB0044;RS0016;RS0017;</NoWarn>
+    <NoWarn>$(NoWarn);NU1507;NU1603;NU5105;1701;1702;SYSLIB0011;SYSLIB0037;SYSLIB0044;RS0016;RS0017;</NoWarn>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(Configuration)' == 'Debug-MONO'">
@@ -84,11 +86,15 @@
     <DefaultItemExcludes>$(DefaultItemExcludes);*.binlog</DefaultItemExcludes>
 
     <DisableImplicitNuGetFallbackFolder>true</DisableImplicitNuGetFallbackFolder>
+
+    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
+    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
+    <DirectoryPackagesPropsPath>$([MSBuild]::NormalizePath('$(MSBuildThisFileDirectory)', 'eng', 'Packages.props'))</DirectoryPackagesPropsPath>
   </PropertyGroup>
 
   <!-- Enable SDK supplied netanalyzers for all target frameworks -->
   <PropertyGroup>
     <EnableNETAnalyzers>true</EnableNETAnalyzers>
   </PropertyGroup>
-  
+
 </Project>
diff --git a/Directory.Build.targets b/Directory.Build.targets
index 3a0e383282a..b57a232300f 100644
--- a/Directory.Build.targets
+++ b/Directory.Build.targets
@@ -24,10 +24,6 @@
     <EditorConfigFiles Include="$(MSBuildThisFileDirectory)eng/Common.Test.globalconfig" />
   </ItemGroup>
 
-  <PropertyGroup>
-    <CentralPackagesFile>$(MSBuildThisFileDirectory)eng/Packages.props</CentralPackagesFile>
-  </PropertyGroup>
-  <Import Project="Sdk.targets" Sdk="Microsoft.Build.CentralPackageVersions" />
   <Import Project="Sdk.targets" Sdk="Microsoft.DotNet.Arcade.Sdk" />
 
   <Target Name="DeleteDevPackage" AfterTargets="GenerateNuspec">
diff --git a/eng/Packages.props b/eng/Packages.props
index bce1a6ee70a..5623df27263 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -8,29 +8,28 @@
     the list of assemblies redistributed by MSBuild (non-MSBuild assemblies in the .vsix package).
      -->
   <ItemGroup>
-    <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
-    <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
-    <PackageReference Update="Microsoft.CodeAnalysis.Collections" Version="$(MicrosoftCodeAnalysisCollectionsVersion)" />
-    <PackageReference Update="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
-    <PackageReference Update="Microsoft.IO.Redist" Version="$(MicrosoftIORedistVersion)" />
-    <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
-    <PackageReference Update="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
-    <PackageReference Update="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
-    <PackageReference Update="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
-    <PackageReference Update="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
-    <PackageReference Update="System.Memory" Version="$(SystemMemoryVersion)" />
-    <PackageReference Update="System.Net.Http" Version="$(SystemNetHttpVersion)" />
-    <PackageReference Update="System.Reflection.Metadata" Version="$(SystemReflectionMetadataVersion)" />
-    <PackageReference Update="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
-    <PackageReference Update="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
-    <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
-    <PackageReference Update="System.Security.Permissions" Version="$(SystemSecurityPermissionsVersion)" />
-    <PackageReference Update="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
-    <PackageReference Update="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
-    <PackageReference Update="System.Text.Json" Version="$(SystemTextJsonVersion)" />
-    <PackageReference Update="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
-    <PackageReference Update="xunit.assert" Version="$(XUnitVersion)" />
-    <PackageReference Update="xunit.console" Version="$(XUnitVersion)" />
-    <PackageReference Update="xunit.core" Version="$(XUnitVersion)" />
+    <PackageVersion Include="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
+    <PackageVersion Include="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
+    <PackageVersion Include="Microsoft.CodeAnalysis.Collections" Version="$(MicrosoftCodeAnalysisCollectionsVersion)" />
+    <PackageVersion Include="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
+    <PackageVersion Include="Microsoft.IO.Redist" Version="$(MicrosoftIORedistVersion)" />
+    <PackageVersion Include="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
+    <PackageVersion Include="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
+    <PackageVersion Include="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
+    <PackageVersion Include="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
+    <PackageVersion Include="System.Memory" Version="$(SystemMemoryVersion)" />
+    <PackageVersion Include="System.Net.Http" Version="$(SystemNetHttpVersion)" />
+    <PackageVersion Include="System.Reflection.Metadata" Version="$(SystemReflectionMetadataVersion)" />
+    <PackageVersion Include="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
+    <PackageVersion Include="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
+    <PackageVersion Include="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
+    <PackageVersion Include="System.Security.Permissions" Version="$(SystemSecurityPermissionsVersion)" />
+    <PackageVersion Include="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
+    <PackageVersion Include="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
+    <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
+    <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
+    <PackageVersion Include="xunit.assert" Version="$(XUnitVersion)" />
+    <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
+    <PackageVersion Include="xunit.core" Version="$(XUnitVersion)" />
   </ItemGroup>
 </Project>
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index cdd69e6ed40..46cbbad9917 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -10,47 +10,44 @@
   these properties to override package versions if necessary. -->
 
   <ItemGroup>
-    <PackageReference Update="BenchmarkDotNet" Version="0.13.1" />
-    <PackageReference Update="BenchmarkDotNet" Condition="'$(BenchmarkDotNetVersion)' != ''" Version="$(BenchmarkDotNetVersion)" />
+    <PackageVersion Include="BenchmarkDotNet" Version="0.13.1" />
+    <PackageVersion Update="BenchmarkDotNet" Condition="'$(BenchmarkDotNetVersion)' != ''" Version="$(BenchmarkDotNetVersion)" />
 
-    <PackageReference Update="LargeAddressAware" Version="1.0.5" />
-    <PackageReference Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
+    <PackageVersion Include="LargeAddressAware" Version="1.0.5" />
+    <PackageVersion Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
 
-    <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" />
-    <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Condition="'$(MicrosoftVisualStudioSDKEmbedInteropTypesVersion)' != ''" Version="$(MicrosoftVisualStudioSDKEmbedInteropTypesVersion)" />
+    <PackageVersion Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.2.2146" PrivateAssets="All" />
+    <PackageVersion Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(MicrosoftVisualStudioSetupConfigurationInteropVersion)' != ''" Version="$(MicrosoftVisualStudioSetupConfigurationInteropVersion)" PrivateAssets="All" />
 
-    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.2.2146" PrivateAssets="All" />
-    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(MicrosoftVisualStudioSetupConfigurationInteropVersion)' != ''" Version="$(MicrosoftVisualStudioSetupConfigurationInteropVersion)" PrivateAssets="All" />
+    <PackageVersion Include="Microsoft.Win32.Registry" Version="5.0.0" />
+    <PackageVersion Update="Microsoft.Win32.Registry" Condition="'$(MicrosoftWin32RegistryVersion)' != ''" Version="$(MicrosoftWin32RegistryVersion)" />
 
-    <PackageReference Update="Microsoft.Win32.Registry" Version="5.0.0" />
-    <PackageReference Update="Microsoft.Win32.Registry" Condition="'$(MicrosoftWin32RegistryVersion)' != ''" Version="$(MicrosoftWin32RegistryVersion)" />
+    <PackageVersion Include="Newtonsoft.Json" Version="13.0.2" />
+    <PackageVersion Update="Newtonsoft.Json" Condition="'$(NewtonsoftJsonVersion)' != ''" Version="$(NewtonsoftJsonVersion)" />
 
-    <PackageReference Update="Newtonsoft.Json" Version="13.0.2" />
-    <PackageReference Update="Newtonsoft.Json" Condition="'$(NewtonsoftJsonVersion)' != ''" Version="$(NewtonsoftJsonVersion)" />
+    <PackageVersion Include="PdbGit" Version="3.0.41" />
+    <PackageVersion Update="PdbGit" Condition="'$(PdbGitVersion)' != ''" Version="$(PdbGitVersion)" />
 
-    <PackageReference Update="PdbGit" Version="3.0.41" />
-    <PackageReference Update="PdbGit" Condition="'$(PdbGitVersion)' != ''" Version="$(PdbGitVersion)" />
+    <PackageVersion Include="Shouldly" Version="3.0.0" />
+    <PackageVersion Update="Shouldly" Condition="'$(ShouldlyVersion)' != ''" Version="$(ShouldlyVersion)" />
 
-    <PackageReference Update="Shouldly" Version="3.0.0" />
-    <PackageReference Update="Shouldly" Condition="'$(ShouldlyVersion)' != ''" Version="$(ShouldlyVersion)" />
+    <PackageVersion Include="System.CodeDom" Version="7.0.0" />
+    <PackageVersion Update="System.CodeDom" Condition="'$(SystemCodeDomVersion)' != ''" Version="$(SystemCodeDomVersion)" />
 
-    <PackageReference Update="System.CodeDom" Version="7.0.0" />
-    <PackageReference Update="System.CodeDom" Condition="'$(SystemCodeDomVersion)' != ''" Version="$(SystemCodeDomVersion)" />
+    <PackageVersion Include="System.Private.Uri" Version="4.3.2" />
+    <PackageVersion Update="System.Private.Uri" Condition="'$(SystemPrivateUriVersion)' != ''" Version="$(SystemPrivateUriVersion)" />
 
-    <PackageReference Update="System.Private.Uri" Version="4.3.2" />
-    <PackageReference Update="System.Private.Uri" Condition="'$(SystemPrivateUriVersion)' != ''" Version="$(SystemPrivateUriVersion)" />
+    <PackageVersion Include="System.Runtime" Version="4.3.1" />
+    <PackageVersion Update="System.Runtime" Condition="'$(SystemRuntimeVersion)' != ''" Version="$(SystemRuntimeVersion)" />
 
-    <PackageReference Update="System.Runtime" Version="4.3.1" />
-    <PackageReference Update="System.Runtime" Condition="'$(SystemRuntimeVersion)' != ''" Version="$(SystemRuntimeVersion)" />
+    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="7.0.0" />
+    <PackageVersion Update="System.Security.Cryptography.Pkcs" Condition="'$(SystemSecurityCryptographyPkcsVersion)' != ''" Version="$(SystemSecurityCryptographyPkcsVersion)" />
 
-    <PackageReference Update="System.Security.Cryptography.Pkcs" Version="7.0.0" />
-    <PackageReference Update="System.Security.Cryptography.Pkcs" Condition="'$(SystemSecurityCryptographyPkcsVersion)' != ''" Version="$(SystemSecurityCryptographyPkcsVersion)" />
+    <PackageVersion Include="System.Security.Cryptography.Xml" Version="7.0.1" />
+    <PackageVersion Update="System.Security.Cryptography.Xml" Condition="'$(SystemSecurityCryptographyXmlVersion)' != ''" Version="$(SystemSecurityCryptographyXmlVersion)" />
 
-    <PackageReference Update="System.Security.Cryptography.Xml" Version="7.0.1" />
-    <PackageReference Update="System.Security.Cryptography.Xml" Condition="'$(SystemSecurityCryptographyXmlVersion)' != ''" Version="$(SystemSecurityCryptographyXmlVersion)" />
-
-    <PackageReference Update="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
-    <PackageReference Update="System.Security.Cryptography.X509Certificates" Condition="'$(SystemSecurityCryptographyX509CertificatesVersion)' != ''" Version="$(SystemSecurityCryptographyX509CertificatesVersion)" />
+    <PackageVersion Include="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
+    <PackageVersion Update="System.Security.Cryptography.X509Certificates" Condition="'$(SystemSecurityCryptographyX509CertificatesVersion)' != ''" Version="$(SystemSecurityCryptographyX509CertificatesVersion)" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
diff --git a/global.json b/global.json
index 39c8c57a412..c809c9cec27 100644
--- a/global.json
+++ b/global.json
@@ -10,7 +10,6 @@
     "xcopy-msbuild": "17.4.1"
   },
   "msbuild-sdks": {
-    "Microsoft.Build.CentralPackageVersions": "2.0.1",
     "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23060.6"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index f1311c25d5c..a9edfebe54b 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -22,6 +22,7 @@
 using Shouldly;
 using Xunit;
 using Microsoft.Build.Framework;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -883,11 +884,9 @@ public void ItemsEnumerator()
 
 #if FEATURE_SECURITY_PRINCIPAL_WINDOWS
         /// <summary>
-        /// Build a solution file that can't be accessed
+        /// Build a solution file that can't be accessed.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]  // Security classes are not supported on Unix
-
+        [WindowsOnlyFact(additionalMessage: "Security classes are not supported on Unix.")]
         public void SolutionCanNotBeOpened()
         {
             Assert.Throws<InvalidProjectFileException>(() =>
@@ -930,11 +929,9 @@ public void SolutionCanNotBeOpened()
         }
 
         /// <summary>
-        /// Build a project file that can't be accessed
+        /// Build a project file that can't be accessed.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        // FileSecurity class is not supported on Unix
+        [WindowsOnlyFact(additionalMessage: "FileSecurity class is not supported on Unix.")]
         public void ProjectCanNotBeOpened()
         {
             Assert.Throws<InvalidProjectFileException>(() =>
@@ -1005,8 +1002,7 @@ public void SolutionCorrupt()
         /// <summary>
         /// Open lots of projects concurrently to try to trigger problems
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]  // This test is platform specific for Windows
+        [WindowsOnlyFact]
         public void ConcurrentProjectOpenAndCloseThroughProject()
         {
             int iterations = 500;
diff --git a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
index 1005cc140f2..3b4481b3cfb 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
@@ -1096,7 +1096,6 @@ public void DefaultToolsVersion()
 #else
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/276")]
 #endif
-        [Trait("Category", "mono-osx-failing")]
         public void DefaultToolsVersion2()
         {
             if (ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20) != null)
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 293cdb4ff05..406ad017571 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -16,6 +16,7 @@
 using Shouldly;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -703,8 +704,7 @@ public void ExcludeAndIncludeConsideredAsLiteralsWhenFilespecIsIllegal(string pr
             TestIncludeExclude(projectContents, inputFiles, expectedInclude, includeString, excludeString, normalizeSlashes: true);
         }
 
-        [Theory]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyTheory]
         [InlineData(ItemWithIncludeAndExclude,
             @"src/**/*.cs",
             new[]
@@ -793,8 +793,7 @@ public void ProjectGetterResultsInDriveEnumerationException(string unevaluatedIn
         /// Project getter that renames an item to a drive enumerating wildcard that results in a logged warning.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(@"z:\**\*.log")]
         [InlineData(@"z:$(empty)\**\*.log")]
         [InlineData(@"z:\**")]
@@ -807,8 +806,7 @@ public void ProjectGetterResultsInWindowsDriveEnumerationWarning(string unevalua
         }
 
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(@"/**/*.log")]
         [InlineData(@"$(empty)/**/*.log")]
         [InlineData(@"/$(empty)**/*.log")]
@@ -878,8 +876,7 @@ public void ThrowExceptionUponProjectInstanceCreationFromDriveEnumeratingContent
         /// Project instance created from a file that contains a drive enumerating wildcard results in a logged warning on the Windows platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(
             ImportProjectElement,
             @"z:\**\*.targets",
@@ -903,8 +900,7 @@ public void LogWindowsWarningUponProjectInstanceCreationFromDriveEnumeratingCont
         }
 
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(
             ImportProjectElement,
             @"\**\*.targets",
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index d8ed8d18514..67c6e7cba7d 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -975,7 +975,6 @@ public void ChangeGlobalPropertiesPreexisting()
 #else
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/276")]
 #endif
-        [Trait("Category", "mono-osx-failing")]
         public void ChangeGlobalPropertiesInitiallyFromProjectCollection()
         {
             Dictionary<string, string> initial = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
@@ -1243,7 +1242,6 @@ public void GetSubToolsetVersion()
         /// environment
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GetSubToolsetVersion_FromEnvironment()
         {
             string originalVisualStudioVersion = Environment.GetEnvironmentVariable("VisualStudioVersion");
@@ -3855,8 +3853,6 @@ public void ProjectInstanceShouldInitiallyHaveSameEvaluationIdAsTheProjectItCame
         [Fact]
         [Trait("Category", "netcore-osx-failing")] // https://github.com/dotnet/msbuild/issues/2226
         [Trait("Category", "netcore-linux-failing")] // https://github.com/dotnet/msbuild/issues/2226
-        [Trait("Category", "mono-osx-failing")] // https://github.com/dotnet/msbuild/issues/2226
-        [Trait("Category", "mono-linux-failing")] // https://github.com/dotnet/msbuild/issues/2226
         public void ProjectImportedEventFalseCondition()
         {
             using (var env = TestEnvironment.Create(_output))
@@ -3900,8 +3896,6 @@ public void ProjectImportedEventFalseCondition()
         [Fact]
         [Trait("Category", "netcore-osx-failing")] // https://github.com/dotnet/msbuild/issues/2226
         [Trait("Category", "netcore-linux-failing")] // https://github.com/dotnet/msbuild/issues/2226
-        [Trait("Category", "mono-osx-failing")] // https://github.com/dotnet/msbuild/issues/2226
-        [Trait("Category", "mono-linux-failing")] // https://github.com/dotnet/msbuild/issues/2226
         public void ProjectImportedEventNoMatchingFiles()
         {
             using (var env = TestEnvironment.Create(_output))
@@ -4161,8 +4155,6 @@ public void ProjectImportedEventMissingFileNoGlobMatch()
         [Fact]
         [Trait("Category", "netcore-osx-failing")] // https://github.com/dotnet/msbuild/issues/2226
         [Trait("Category", "netcore-linux-failing")] // https://github.com/dotnet/msbuild/issues/2226
-        [Trait("Category", "mono-osx-failing")] // https://github.com/dotnet/msbuild/issues/2226
-        [Trait("Category", "mono-linux-failing")] // https://github.com/dotnet/msbuild/issues/2226
         public void ProjectImportEvent()
         {
             using (var env = TestEnvironment.Create(_output))
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index 3e8f8a63a0e..96bee6d7db8 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -17,6 +17,7 @@
 using Xunit;
 using Shouldly;
 using System.Linq;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -908,8 +909,7 @@ public void ThrowExceptionUponBuildingProjectWithDriveEnumeration(string content
         /// Log warning for drive enumerating wildcards that exist in projects on Windows platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(
             TargetItemWithIncludeAndExclude,
             @"z:$(Microsoft_WindowsAzure_EngSys)\**\*",
@@ -950,8 +950,7 @@ public void LogWindowsWarningUponBuildingProjectWithDriveEnumeration(string cont
         /// Log warning for drive enumerating wildcards that exist in projects on Unix platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(
             TargetWithDefinedPropertyAndItemWithInclude,
             @"$(Microsoft_WindowsAzure_EngSys)**",
@@ -981,8 +980,7 @@ public void LogUnixWarningUponBuildingProjectWithDriveEnumeration(string content
         /// <summary>
         /// Tests target item evaluation resulting in no build failures.
         /// </summary>
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(
             TargetWithDefinedPropertyAndItemWithInclude,
             @"$(Microsoft_WindowsAzure_EngSys)*.cs",
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 51d86b2f804..44cc3c47e4e 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -79,6 +79,7 @@
       <Link>TestData\GlobbingTestData.cs</Link>
     </Compile>
     <Compile Include="..\Shared\ProcessExtensions.cs" />
+    <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
index e7458cf0a26..c0a00cf572e 100644
--- a/src/Build.OM.UnitTests/NugetRestoreTests.cs
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -9,6 +9,7 @@
 using Xunit;
 #endif
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 namespace Microsoft.Build.Engine.OM.UnitTests
 {
@@ -23,8 +24,7 @@ public NugetRestoreTests(ITestOutputHelper output)
         // This NuGet version cannot locate other assemblies when parsing solutions at restore time. This includes localized strings required in debug mode.
         // NuGet version 4.1.0 was somewhat arbitrarily chosen. 3.5 breaks with an unrelated error, and 4.8.2 does not fail when a new dependency is introduced. This is a safe middle point.
 #if !DEBUG
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
-        [Fact]
+        [WindowsFullFrameworkOnlyFact]
         public void TestOldNuget()
         {
             string msbuildExePath = Path.GetDirectoryName(RunnerUtilities.PathToCurrentlyRunningMsBuildExe)!;
diff --git a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
index 8ce02b04836..92362f41ed9 100644
--- a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
@@ -430,7 +430,6 @@ public void VerifyMatchingParametersDontLaunchTaskHost()
         /// parameters that explicitly do not match the current process. 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyNonmatchingUsingTaskParametersLaunchTaskHost()
         {
             ITask createdTask = null;
@@ -464,7 +463,6 @@ public void VerifyNonmatchingUsingTaskParametersLaunchTaskHost()
         /// parameters that explicitly do not match the current process. 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyNonmatchingTaskParametersLaunchTaskHost()
         {
             ITask createdTask = null;
@@ -496,7 +494,6 @@ public void VerifyNonmatchingTaskParametersLaunchTaskHost()
         /// parameters that explicitly do not match the current process. 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyNonmatchingParametersLaunchTaskHost()
         {
             ITask createdTask = null;
@@ -561,7 +558,6 @@ public void VerifyExplicitlyLaunchTaskHost()
         /// explicitly instructed to launch the task host. 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch1()
         {
             ITask createdTask = null;
@@ -595,7 +591,6 @@ public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch1()
         /// explicitly instructed to launch the task host. 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch2()
         {
             ITask createdTask = null;
@@ -629,7 +624,6 @@ public void VerifyExplicitlyLaunchTaskHostEvenIfParametersMatch2()
         /// explicitly instructed to launch the task host. 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifySameFactoryCanGenerateDifferentTaskInstances()
         {
             ITask createdTask = null;
diff --git a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
index 063eb110090..b9d4f98ffcb 100644
--- a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -123,9 +124,7 @@ void TransportDelegate(INodePacket packet)
         /// <summary>
         /// Make sure shutdown will correctly null out the send data delegate
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/282")]
+        [WindowsFullFrameworkOnlyFact("https://github.com/dotnet/msbuild/issues/282")]
         public void TestShutDown()
         {
             SendDataDelegate transportDelegate = new(PacketProcessor);
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index c2d0569cb90..e340aaacdc6 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -2303,7 +2303,6 @@ public void ProjectInstanceLimitedTransferToOOPNode()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void CacheLifetime()
         {
             FileUtilities.ClearCacheDirectory();
@@ -3966,7 +3965,6 @@ public void OutOfProcEvaluationIdsUnique()
         /// Regression test for https://github.com/dotnet/msbuild/issues/3047
         /// </summary>
         [Fact]
-        [SkipOnMono("out-of-proc nodes not working on mono yet")]
         public void MultiProcReentrantProjectWithCallTargetDoesNotFail()
         {
             var a =
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index 3f0b73c8dbb..09c32f3184a 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -417,7 +417,6 @@ public void TestCache()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void WorksCorrectlyWithCurlyBraces()
         {
             string projectBody = ObjectModelHelpers.CleanupFileContents(@"
diff --git a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
index 9ba42506c30..2090f4c4807 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Framework;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -136,8 +137,7 @@ public void TestTranslation()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestTranslationRemoteHostObjects()
         {
diff --git a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
index 25e2ed70e01..3e2a1cb560a 100644
--- a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
@@ -3255,7 +3255,6 @@ public void IncludeCheckOnMetadata2()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void IncludeCheckOnMetadata_3()
         {
             MockLogger logger = new MockLogger();
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 5942f8ab8e4..f0619052e66 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -1021,7 +1021,6 @@ public void LogBuildStarted()
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/437")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void LogBuildStartedCriticalOnly()
         {
             ProcessBuildEventHelper service =
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index a948c97234a..4eb2b6a1307 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -1286,7 +1286,6 @@ public void StopOnFirstFailureandBuildInParallelSingleNode()
         /// Verify stopOnFirstFailure with BuildInParallel override message are correctly logged when there are multiple nodes
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void StopOnFirstFailureandBuildInParallelMultipleNode()
         {
             string project1 = ObjectModelHelpers.CreateTempFileOnDisk(@"
diff --git a/src/Build.UnitTests/BackEnd/OnError_Tests.cs b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
index bdab3015c8c..15ad66ee408 100644
--- a/src/Build.UnitTests/BackEnd/OnError_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
@@ -58,7 +58,6 @@ public void Basic()
         /// Then these items and properties should be visible to the onerror targets.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void FailingTaskStillPublishesOutputs()
         {
             MockLogger l = new MockLogger();
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 09a8655bf48..3b13e37087c 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -527,7 +527,6 @@ public void IllegalFileCharsInItemsOutOfTask()
         /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void NullMetadataOnOutputItems()
         {
             string customTaskPath = Assembly.GetExecutingAssembly().Location;
@@ -552,7 +551,6 @@ public void NullMetadataOnOutputItems()
         /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void NullMetadataOnLegacyOutputItems()
         {
             string customTaskPath = Assembly.GetExecutingAssembly().Location;
@@ -650,7 +648,6 @@ public void NullMetadataOnOutputItems_InlineTask()
         /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/6521")]
-        [Trait("Category", "non-mono-tests")]
         public void NullMetadataOnLegacyOutputItems_InlineTask()
         {
             string projectContents = @"
@@ -706,7 +703,6 @@ public void ValidateDefiningProjectMetadataOnTaskOutputs()
         /// which didn't support the defining project metadata.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ValidateDefiningProjectMetadataOnTaskOutputs_LegacyItems()
         {
             string customTaskPath = Assembly.GetExecutingAssembly().Location;
@@ -718,7 +714,6 @@ public void ValidateDefiningProjectMetadataOnTaskOutputs_LegacyItems()
         /// Tests that putting the RunInSTA attribute on a task causes it to run in the STA thread.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSTAThreadRequired()
         {
             TestSTATask(true, false, false);
@@ -728,7 +723,6 @@ public void TestSTAThreadRequired()
         /// Tests an STA task with an exception
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSTAThreadRequiredWithException()
         {
             TestSTATask(true, false, true);
@@ -738,7 +732,6 @@ public void TestSTAThreadRequiredWithException()
         /// Tests an STA task with failure.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSTAThreadRequiredWithFailure()
         {
             TestSTATask(true, true, false);
@@ -748,7 +741,6 @@ public void TestSTAThreadRequiredWithFailure()
         /// Tests an MTA task.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSTAThreadNotRequired()
         {
             TestSTATask(false, false, false);
@@ -758,7 +750,6 @@ public void TestSTAThreadNotRequired()
         /// Tests an MTA task with an exception.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSTAThreadNotRequiredWithException()
         {
             TestSTATask(false, false, true);
@@ -768,7 +759,6 @@ public void TestSTAThreadNotRequiredWithException()
         /// Tests an MTA task with failure.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSTAThreadNotRequiredWithFailure()
         {
             TestSTATask(false, true, false);
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 6688e687a44..a3226a7df75 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -25,7 +25,6 @@ public TaskHostFactory_Tests(ITestOutputHelper testOutputHelper)
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TaskNodesDieAfterBuild()
         {
             using (TestEnvironment env = TestEnvironment.Create())
diff --git a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
index 1394e76a11b..e1ee00a3515 100644
--- a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
+++ b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -62,9 +63,7 @@ public void FindBuildEnvironmentByEnvironmentVariable()
         /// If MSBUILD_EXE_PATH is explicitly set, we should detect it as a VisualStudio instance even in older scenarios
         /// (for example when the install path is under 15.0).
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void FindVisualStudioEnvironmentByEnvironmentVariable()
         {
             using (var env = new EmptyVSEnviroment())
@@ -90,9 +89,7 @@ public void FindVisualStudioEnvironmentByEnvironmentVariable()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void FindBuildEnvironmentFromCommandLineVisualStudio()
         {
             using (var env = new EmptyVSEnviroment())
@@ -125,9 +122,7 @@ public void FindBuildEnvironmentFromCommandLineStandalone()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void FindBuildEnvironmentFromRunningProcessVisualStudio()
         {
             using (var env = new EmptyVSEnviroment())
@@ -196,9 +191,7 @@ public void FindBuildEnvironmentFromAppContextDirectory()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void FindBuildEnvironmentFromVisualStudioRoot()
         {
             using (var env = new EmptyVSEnviroment())
@@ -215,11 +208,9 @@ public void FindBuildEnvironmentFromVisualStudioRoot()
             }
         }
 
-        [Theory]
+        [WindowsFullFrameworkOnlyTheory(additionalMessage: "No Visual Studio installed for .NET.")]
         [InlineData(MSBuildConstants.CurrentVisualStudioVersion, true)]
         [InlineData("15.0", false)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentDetectsVisualStudioByEnvironment(string visualStudioVersion, bool shouldBeValid)
         {
             using (var env = new EmptyVSEnviroment())
@@ -242,9 +233,7 @@ public void BuildEnvironmentDetectsVisualStudioByEnvironment(string visualStudio
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentDetectsVisualStudioByMSBuildProcess()
         {
             using (var env = new EmptyVSEnviroment())
@@ -257,9 +246,7 @@ public void BuildEnvironmentDetectsVisualStudioByMSBuildProcess()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentDetectsVisualStudioByMSBuildProcessAmd64()
         {
             using (var env = new EmptyVSEnviroment())
@@ -272,9 +259,7 @@ public void BuildEnvironmentDetectsVisualStudioByMSBuildProcessAmd64()
             }
         }
 
-        [Theory]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyTheory(additionalMessage: "No Visual Studio installed for .NET.")]
         [InlineData("17.0", true)]
         [InlineData("17.3", true)]
         [InlineData("16.0", false)]
@@ -325,9 +310,7 @@ public void BuildEnvironmentDetectsRunningTests()
             BuildEnvironmentHelper.Instance.RunningInVisualStudio.ShouldBeFalse();
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentDetectsVisualStudioByProcessName()
         {
             using (var env = new EmptyVSEnviroment())
@@ -340,9 +323,7 @@ public void BuildEnvironmentDetectsVisualStudioByProcessName()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentDetectsVisualStudioByBlendProcess()
         {
             using (var env = new EmptyVSEnviroment())
@@ -355,9 +336,7 @@ public void BuildEnvironmentDetectsVisualStudioByBlendProcess()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentFindsAmd64()
         {
             using (var env = new EmptyVSEnviroment())
@@ -371,9 +350,8 @@ public void BuildEnvironmentFindsAmd64()
             }
         }
 
-        [Fact]
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void BuildEnvironmentFindsAmd64RunningInAmd64NoVS()
         {
             using (var env = new EmptyStandaloneEnviroment(MSBuildExeName, writeFakeFiles: true, includeAmd64Folder: true))
@@ -389,9 +367,8 @@ public void BuildEnvironmentFindsAmd64RunningInAmd64NoVS()
             }
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentFindsAmd64NoVS()
         {
             using (var env = new EmptyStandaloneEnviroment(MSBuildExeName, writeFakeFiles: true, includeAmd64Folder: true))
@@ -405,10 +382,8 @@ public void BuildEnvironmentFindsAmd64NoVS()
             }
         }
 
-        [Fact]
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentFindsAmd64RunningInAmd64()
         {
             using (var env = new EmptyVSEnviroment())
@@ -438,9 +413,7 @@ public void BuildEnvironmentNoneWhenNotAvailable()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentVSFromMSBuildAssembly()
         {
             using (var env = new EmptyVSEnviroment())
@@ -457,9 +430,7 @@ public void BuildEnvironmentVSFromMSBuildAssembly()
             }
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio installed for .NET.")]
         public void BuildEnvironmentVSFromMSBuildAssemblyAmd64()
         {
             using (var env = new EmptyVSEnviroment())
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 622e8c81c88..4f5ba07b009 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -21,6 +21,7 @@
 using Xunit.Abstractions;
 using Microsoft.Build.Execution;
 using System.Runtime.Versioning;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -176,7 +177,6 @@ public void TestEmptyProjectNameForTargetStarted()
         /// started event but there was no target printed out.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestTargetAfterProjectStarted()
         {
             SimulatedConsole sc = new SimulatedConsole();
@@ -321,9 +321,7 @@ public void ErrorMessageWithMultiplePropertiesInMessage(bool includeEvaluationPr
             output.ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + "::Number=2 TargetFramework=netcoreapp2.1]");
         }
 
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/6518")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "Minimal path validation in Core allows expanding path containing quoted slashes.")]
-        [SkipOnMono("Minimal path validation in Mono allows expanding path containing quoted slashes.")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "Minimal path validation in Core allows expanding path containing quoted slashes.", Skip = "https://github.com/dotnet/msbuild/issues/6518")]
         public void TestItemsWithUnexpandableMetadata()
         {
             SimulatedConsole sc = new SimulatedConsole();
@@ -349,7 +347,6 @@ public void TestItemsWithUnexpandableMetadata()
         /// Verify that on minimal verbosity the console logger does not log the target names.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestNoTargetNameOnMinimal()
         {
             SimulatedConsole sc = new SimulatedConsole();
@@ -367,7 +364,6 @@ public void TestNoTargetNameOnMinimal()
         /// Make sure if a target has no messages logged that its started and finished events show up on detailed but not normal.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EmptyTargetsOnDetailedButNotNormal()
         {
             SimulatedConsole sc = new SimulatedConsole();
@@ -412,7 +408,6 @@ public void EmptyTargetsOnDetailedButNotNormal()
         /// Test a number of cases where difference values from showcommandline are used with normal verbosity
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ShowCommandLineWithNormalVerbosity()
         {
             string command = "echo a";
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index a8f04046ca2..74de8fa1a11 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -49,7 +49,6 @@ public void BasicParseFirstProjectLine()
         /// extension of vcproj is seen as invalid.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void ParseFirstProjectLine_VC()
@@ -498,7 +497,6 @@ public void TestVSAndSolutionVersionParsing()
         /// Test ParseEtpProject function.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void ParseNestedEtpProjectMultipleLevel()
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 4e20b2d9617..b6097d1c35a 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -336,7 +336,6 @@ public void AddNewErrorWarningMessageElement()
         /// on the Solution File Format Version.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void EmitToolsVersionAttributeToInMemoryProject9()
@@ -372,7 +371,6 @@ public void EmitToolsVersionAttributeToInMemoryProject9()
         /// on the Solution File Format Version.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void EmitToolsVersionAttributeToInMemoryProject10()
@@ -485,7 +483,6 @@ public void SubToolsetSetBySolutionVersion()
         /// Test to make sure that even if the solution version corresponds to an existing sub-toolset version,
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SolutionBasedSubToolsetVersionOverriddenByEnvironment()
         {
             Environment.SetEnvironmentVariable("VisualStudioVersion", "ABC");
@@ -1208,7 +1205,6 @@ public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionNo
         /// The repro below has one of each case. WebProjects can't build so they are set as SkipNonexistentProjects='Build'
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void Regress751742_SkipNonexistentProjects()
@@ -1611,7 +1607,6 @@ public void TestConfigurationPlatformDefaults2()
         /// Tests the algorithm for choosing default Venus configuration values for solutions
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void TestVenusConfigurationDefaults()
@@ -1642,7 +1637,6 @@ public void TestVenusConfigurationDefaults()
         /// Tests that the correct value for TargetFrameworkVersion gets set when creating Venus solutions
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void VenusSolutionDefaultTargetFrameworkVersion()
@@ -1682,7 +1676,6 @@ public void VenusSolutionDefaultTargetFrameworkVersion()
         /// Tests the algorithm for choosing target framework paths for ResolveAssemblyReferences for Venus
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void TestTargetFrameworkPaths0()
@@ -1708,7 +1701,6 @@ public void TestTargetFrameworkPaths0()
         /// Tests the algorithm for choosing target framework paths for ResolveAssemblyReferences for Venus
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void TestTargetFrameworkPaths1()
@@ -1735,7 +1727,6 @@ public void TestTargetFrameworkPaths1()
         /// Tests the algorithm for choosing target framework paths for ResolveAssemblyReferences for Venus
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void TestTargetFrameworkPaths2()
@@ -1935,7 +1926,6 @@ public void SolutionGeneratorCanEmitSolutions()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void TestSkipInvalidConfigurationsCase()
         {
             string tmpFileName = FileUtilities.GetTemporaryFileName();
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index 2e9ac12c15f..35e2ad09124 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -18,6 +18,7 @@
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using InternalUtilities = Microsoft.Build.Internal.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -87,8 +88,7 @@ public void OverrideTaskPathIsRelative()
             mockLogger.AssertLogContains(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTasksFileFailure", rootedPathMessage));
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void OverrideTaskPathHasInvalidChars()
         {
             ProjectCollection e = new ProjectCollection();
diff --git a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
index 4d3962dfa70..70db749fe92 100644
--- a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
@@ -198,7 +198,6 @@ public void MSBuildToolsetsTest_BasicWithOtherConfigEntries()
         /// name attribute is missing from toolset element 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ToolsVersionTest_NameNotSpecified()
         {
             Assert.Throws<ConfigurationErrorsException>(() =>
@@ -255,7 +254,6 @@ public void ToolsVersionTest_MultipleElementsWithSameName()
         /// empty toolset element 
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ToolsVersionTest_EmptyElement()
         {
             Assert.Throws<ConfigurationErrorsException>(() =>
@@ -323,7 +321,6 @@ public void ToolsVersionTest_SingleElement()
         ///  name attribute is missing
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyTest_NameNotSpecified()
         {
             Assert.Throws<ConfigurationErrorsException>(() =>
@@ -400,7 +397,6 @@ public void PropertyTest_MultipleElementsWithSameName()
         ///  property element is an empty element
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyTest_EmptyElement()
         {
             Assert.Throws<ConfigurationErrorsException>(() =>
diff --git a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
index f37d6c7329c..8e3ebab9914 100644
--- a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
@@ -20,6 +20,7 @@
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 using InternalUtilities = Microsoft.Build.Internal.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -30,7 +31,6 @@ namespace Microsoft.Build.UnitTests.Definition
     /// <summary>
     /// Unit tests for ToolsetReader class and its derived classes
     /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class ToolsetReaderTests : IDisposable
     {
         // The registry key that is passed as the baseKey parameter to the ToolsetRegistryReader class
@@ -92,14 +92,9 @@ private void DeleteTestRegistryKey()
         /// Test to make sure machine.config file has the section registered
         /// and we are picking it up from there.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "The machine.config is only present on Windows.")]
         public void GetToolsetDataFromConfiguration_SectionNotRegisteredInConfigFile()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "The machine.config is only present on Windows"
-            }
-
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
                  <configuration>
                    <configSections>
@@ -131,7 +126,7 @@ public void GetToolsetDataFromConfiguration_SectionNotRegisteredInConfigFile()
         /// <summary>
         /// Tests that the data is correctly populated using function GetToolsetDataFromConfiguration
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_Basic()
         {
             string v2Folder = NativeMethodsShared.IsWindows
@@ -175,7 +170,7 @@ public void GetToolsetDataFromConfiguration_Basic()
         /// <summary>
         /// Relative paths can be used in a config file value
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void RelativePathInValue()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -216,7 +211,7 @@ public void RelativePathInValue()
         /// <summary>
         /// Invalid relative path in msbuildbinpath value
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InvalidRelativePath()
         {
             if (NativeMethodsShared.IsLinux)
@@ -253,7 +248,7 @@ public void InvalidRelativePath()
         /// <summary>
         /// Tests the case where application configuration file is invalid
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_InvalidXmlFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -272,7 +267,7 @@ public void GetToolsetDataFromConfiguration_InvalidXmlFile()
         /// <summary>
         /// Tests the case where application configuration file is invalid
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_InvalidConfigFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -301,7 +296,7 @@ public void GetToolsetDataFromConfiguration_InvalidConfigFile()
         /// <summary>
         /// Tests the case where application configuration file is empty
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_FileEmpty()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -321,7 +316,7 @@ public void GetToolsetDataFromConfiguration_FileEmpty()
         /// Tests the case when ReadConfiguration throws exception
         /// Make sure that we don't eat it and always throw ConfigurationErrorsException
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_ConfigurationExceptionThrown()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -342,7 +337,7 @@ public void GetToolsetDataFromConfiguration_ConfigurationExceptionThrown()
         /// Tests the case when ReadConfiguration throws exception
         /// Make sure that we don't eat it and always throw ConfigurationErrorsException
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_ConfigurationErrorsExceptionThrown()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -362,7 +357,7 @@ public void GetToolsetDataFromConfiguration_ConfigurationErrorsExceptionThrown()
         /// <summary>
         /// Tests the case where default attribute is not specified in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_DefaultAttributeNotSpecified()
         {
             string v2Folder = NativeMethodsShared.IsWindows
@@ -397,7 +392,7 @@ public void GetToolsetDataFromConfiguration_DefaultAttributeNotSpecified()
         /// <summary>
         /// Default toolset has no toolsVersion element definition
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_DefaultToolsetUndefined()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -427,7 +422,7 @@ public void GetToolsetDataFromConfiguration_DefaultToolsetUndefined()
         /// Tests the case where msbuildToolsets is not specified in the config file
         /// Basically in the code we should be checking if config.GetSection("msbuildToolsets") returns a null
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_MSBuildToolsetsNodeNotPresent()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -451,7 +446,7 @@ public void GetToolsetDataFromConfiguration_MSBuildToolsetsNodeNotPresent()
         /// <summary>
         /// Tests that we handle empty MSBuildToolsets element correctly
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_EmptyMSBuildToolsetsNode()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -476,7 +471,7 @@ public void GetToolsetDataFromConfiguration_EmptyMSBuildToolsetsNode()
         /// <summary>
         /// Tests the case where only default ToolsVersion is specified in the application configuration file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_OnlyDefaultSpecified()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -503,7 +498,7 @@ public void GetToolsetDataFromConfiguration_OnlyDefaultSpecified()
         /// <summary>
         /// Tests the case where only one ToolsVersion data is specified in the application configuration file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_OneToolsVersionNode()
         {
             string v2Folder = NativeMethodsShared.IsWindows
@@ -537,7 +532,7 @@ public void GetToolsetDataFromConfiguration_OneToolsVersionNode()
         /// <summary>
         /// Tests the case when an invalid value of ToolsVersion is specified
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_ToolsVersionIsEmptyString()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -570,7 +565,7 @@ public void GetToolsetDataFromConfiguration_ToolsVersionIsEmptyString()
         /// <summary>
         /// If both MSBuildToolsPath and MSBuildBinPath are present, they must match
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_ToolsPathAndBinPathDiffer()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -600,7 +595,7 @@ public void GetToolsetDataFromConfiguration_ToolsPathAndBinPathDiffer()
         /// <summary>
         /// Tests the case when a blank value of PropertyName is specified in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyNameInConfigFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -634,7 +629,7 @@ public void BlankPropertyNameInConfigFile()
         /// <summary>
         /// Tests the case when a blank property name is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyNameInRegistry()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -661,7 +656,7 @@ public void BlankPropertyNameInRegistry()
         /// Tests the case when a blank property name is specified in the registry in a
         /// sub-toolset.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyNameInRegistrySubToolset()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -694,7 +689,7 @@ public void BlankPropertyNameInRegistrySubToolset()
         /// <summary>
         /// Tests the case when a blank property value is specified in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyValueInConfigFile()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -725,7 +720,7 @@ public void BlankPropertyValueInConfigFile()
         /// <summary>
         /// Tests the case when a blank property value is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyValueInRegistry()
         {
             RegistryKey rk = _toolsVersionsRegistryKey.CreateSubKey("2.0");
@@ -749,7 +744,7 @@ public void BlankPropertyValueInRegistry()
         /// <summary>
         /// Tests the case when a blank property value is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyValueInRegistrySubToolset()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"c:\someBinPath" : "/someBinPath";
@@ -783,7 +778,7 @@ public void BlankPropertyValueInRegistrySubToolset()
         /// <summary>
         /// Tests the case when an invalid value of PropertyName is specified in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InvalidPropertyNameInConfigFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -816,7 +811,7 @@ public void InvalidPropertyNameInConfigFile()
         /// <summary>
         /// Tests the case when an invalid value of PropertyName is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InvalidPropertyNameInRegistry()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -842,7 +837,7 @@ public void InvalidPropertyNameInRegistry()
         /// <summary>
         /// Tests the case when an invalid value of PropertyName is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InvalidPropertyNameInRegistrySubToolset()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -872,7 +867,7 @@ public void InvalidPropertyNameInRegistrySubToolset()
         /// <summary>
         /// Tests that empty string is an invalid value for MSBuildBinPath
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString1()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -901,7 +896,7 @@ public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString1()
         /// <summary>
         /// Tests that empty string is a valid property value for an arbitrary property
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString2()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -935,7 +930,7 @@ public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString2()
         /// Note that this comes for free with the current implementation using the
         /// framework api to access section in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_XmlEscapedCharacters()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -972,7 +967,7 @@ public void GetToolsetDataFromConfiguration_XmlEscapedCharacters()
         /// <summary>
         /// Tests the case where registry and config file contains different toolsVersion
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_NoConflict()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -1031,7 +1026,7 @@ public void GetToolsetData_NoConflict()
         /// <summary>
         /// Tests that ToolsetInitialization are respected.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsetInitializationFlagsSetToNone()
         {
             // Set up registry with two tools versions and one property each
@@ -1085,7 +1080,7 @@ public void ToolsetInitializationFlagsSetToNone()
         /// <summary>
         /// Tests that ToolsetInitialization are respected.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsetInitializationFlagsSetToRegistry()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -1132,7 +1127,7 @@ public void ToolsetInitializationFlagsSetToRegistry()
             Assert.Equal(binPath2, values["4.0"].ToolsPath);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ThrowOnNonStringRegistryValueTypes()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1157,7 +1152,7 @@ public void ThrowOnNonStringRegistryValueTypes()
                                                                ToolsetDefinitionLocations.Registry);
             });
         }
-        [Fact]
+        [WindowsOnlyFact]
         public void PropertiesInRegistryCannotReferToOtherPropertiesInRegistry()
         {
             string binPath = NativeMethodsShared.IsWindows ? "c:\\x" : "/x";
@@ -1186,7 +1181,7 @@ public void PropertiesInRegistryCannotReferToOtherPropertiesInRegistry()
             Assert.Equal(binPath, values["2.0"].ToolsPath);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SubToolsetPropertiesInRegistryCannotReferToOtherPropertiesInRegistry()
         {
             RegistryKey rk = _toolsVersionsRegistryKey.CreateSubKey("2.0");
@@ -1216,7 +1211,7 @@ public void SubToolsetPropertiesInRegistryCannotReferToOtherPropertiesInRegistry
             Assert.Equal("c:\\x", values["2.0"].SubToolsets["dogfood"].Properties["p3"].EvaluatedValue);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SubToolsetsCannotDefineMSBuildToolsPath()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1246,7 +1241,7 @@ public void SubToolsetsCannotDefineMSBuildToolsPath()
         /// <summary>
         /// Tests that ToolsetInitialization are respected.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsetInitializationFlagsSetToConfigurationFile()
         {
             string v2Dir = NativeMethodsShared.IsWindows ? "D:\\windows\\Microsoft.NET\\Framework\\v2.0.x86ret" : "/windows/Microsoft.NET/Framework/v2.0.x86ret";
@@ -1301,14 +1296,9 @@ public void ToolsetInitializationFlagsSetToConfigurationFile()
         /// "TaskLocation" is the name of the value.  The name of the value and the preceding "@" may be omitted if
         /// the default value is desired.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Registry access is only supported under Windows.")]
         public void PropertyInConfigurationFileReferencesRegistryLocation()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Registry access is only supported under Windows."
-            }
-
             // Registry Read
             RegistryKey key1 = Registry.CurrentUser.CreateSubKey(@"Software\Vendor\Tools");
             key1.SetValue("TaskLocation", @"somePathToTasks");
@@ -1353,7 +1343,7 @@ public void PropertyInConfigurationFileReferencesRegistryLocation()
             Registry.CurrentUser.DeleteSubKeyTree(@"Software\Vendor");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsPathInRegistryHasInvalidPathChars()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1378,7 +1368,7 @@ public void ToolsPathInRegistryHasInvalidPathChars()
         }
 
 #if FEATURE_SYSTEM_CONFIGURATION
-        [Fact]
+        [WindowsOnlyFact]
         public void SamePropertyDefinedMultipleTimesForSingleToolsVersionInConfigurationFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1410,7 +1400,7 @@ public void SamePropertyDefinedMultipleTimesForSingleToolsVersionInConfiguration
             });
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SamePropertyDifferentCaseDefinedMultipleTimesForSingleToolsVersionInConfigurationFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1443,7 +1433,7 @@ public void SamePropertyDifferentCaseDefinedMultipleTimesForSingleToolsVersionIn
         }
 
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SameToolsVersionDefinedMultipleTimesInConfigurationFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1481,7 +1471,7 @@ public void SameToolsVersionDefinedMultipleTimesInConfigurationFile()
             });
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SameToolsVersionDifferentCaseDefinedMultipleTimesInConfigurationFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1519,7 +1509,7 @@ public void SameToolsVersionDifferentCaseDefinedMultipleTimesInConfigurationFile
             });
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void CannotSetReservedPropertyInConfigFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1550,7 +1540,7 @@ public void CannotSetReservedPropertyInConfigFile()
         }
 #endif
 
-        [Fact]
+        [WindowsOnlyFact]
         public void CannotSetReservedPropertyInRegistry()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1574,7 +1564,7 @@ public void CannotSetReservedPropertyInRegistry()
             });
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void CannotSetReservedPropertyInRegistrySubToolset()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1604,7 +1594,7 @@ public void CannotSetReservedPropertyInRegistrySubToolset()
         /// Properties defined in previously processed toolset definitions should
         /// not affect the evaluation of subsequent toolset definitions.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NoInterferenceBetweenToolsetDefinitions()
         {
             string v20Dir = NativeMethodsShared.IsWindows ? @"D:\20\some\folder\on\disk" : "/20/some/folder/on/disk";
@@ -1659,76 +1649,56 @@ public void NoInterferenceBetweenToolsetDefinitions()
         /// "TaskLocation" is the name of the value.  The name of the value and the preceding "@" may be omitted if
         /// the default value is desired.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Access local machine registry is for Windows only.")]
         public void ConfigFileInvalidRegistryExpression1()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Access local machine registry is for Windows only"
-            }
-
             // No location
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Access local machine registry is for Windows only.")]
         public void ConfigFileInvalidRegistryExpression2()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Access local machine registry is for Windows only"
-            }
-
             // Bogus key expression
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:__bogus__)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Access local machine registry is for Windows only.")]
         public void ConfigFileInvalidRegistryExpression3()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Access local machine registry is for Windows only"
-            }
-
             // No registry location just @
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:@)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression4()
         {
             // Double @
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:HKEY_CURRENT_USER\Software\Vendor\Tools@@TaskLocation)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression5()
         {
             // Trailing @
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:HKEY_CURRENT_USER\Software\Vendor\Tools@TaskLocation@)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression6()
         {
             // Leading @
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:@HKEY_CURRENT_USER\Software\Vendor\Tools@TaskLocation)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Access registry is for Windows only.")]
         public void ConfigFileInvalidRegistryExpression7()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Access registry is for Windows only"
-            }
-
             // Bogus hive
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:BOGUS_HIVE\Software\Vendor\Tools@TaskLocation)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileStringEmptyRegistryExpression1()
         {
             // Regular undefined property beginning with "Registry"
@@ -1736,7 +1706,7 @@ public void ConfigFileStringEmptyRegistryExpression1()
                                           String.Empty);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileStringEmptyRegistryExpression2()
         {
             // Nonexistent key
@@ -1744,7 +1714,7 @@ public void ConfigFileStringEmptyRegistryExpression2()
                                           String.Empty);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileNonPropertyRegistryExpression1()
         {
             // Property not terminated with paren, does not look like property
@@ -1752,7 +1722,7 @@ public void ConfigFileNonPropertyRegistryExpression1()
                                           @"$(Registry:HKEY_CURRENT_USER\Software\Vendor\Tools@TaskLocation");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileNonPropertyRegistryExpression2()
         {
             // Missing colon, looks like regular property (but with invalid property name chars, we will return blank as a result)
@@ -1760,7 +1730,7 @@ public void ConfigFileNonPropertyRegistryExpression2()
                                           String.Empty);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileItemExpressionsDoNotExpandInConfigurationProperties()
         {
             // Expect that item expressions such as '@(SomeItem)' are not evaluated in any way, e.g., they are treated literally
@@ -1768,19 +1738,14 @@ public void ConfigFileItemExpressionsDoNotExpandInConfigurationProperties()
                                           @"@(SomeItem)");
         }
 
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Access local machine registry is for Windows only.")]
         public void RegistryInvalidRegistryExpression1()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Access local machine registry is for Windows only"
-            }
-
             // Bogus key expression
             RegistryInvalidRegistryExpressionHelper("$(Registry:__bogus__)");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void RegistryValidRegistryExpression1()
         {
             // Regular undefined property beginning with "Registry"
@@ -1890,7 +1855,7 @@ private void ConfigFileValidRegistryExpressionHelper(string propertyExpression,
         /// <summary>
         /// Tests the case where application configuration file overrides a value already specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ConflictingPropertyValuesSameCase()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -1935,7 +1900,7 @@ public void GetToolsetData_ConflictingPropertyValuesSameCase()
         /// where that registry value is bogus and would otherwise throw.  However, since the config file also
         /// contains an entry for that toolset, the registry toolset never gets read, and thus never throws.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ConflictingPropertyValuesRegistryThrows()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -1979,7 +1944,7 @@ public void GetToolsetData_ConflictingPropertyValuesRegistryThrows()
         /// well as in the config file for the same tools version.
         /// We should not merge them; we should take the config file ones only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_NoMerging()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -2028,7 +1993,7 @@ public void GetToolsetData_NoMerging()
         /// The absence of the ToolsVersion attribute on the main Project element in a project file means
         /// that the engine's default tools version should be used.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsVersionAttributeNotSpecifiedOnProjectElementAndDefaultVersionSpecifiedInRegistry()
         {
             string oldValue = Environment.GetEnvironmentVariable("MSBUILDLEGACYDEFAULTTOOLSVERSION");
@@ -2070,7 +2035,7 @@ public void ToolsVersionAttributeNotSpecifiedOnProjectElementAndDefaultVersionSp
         /// <summary>
         /// Tests the case when no values are specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_RegistryNotPresent()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somedifferentpath" : "/somedifferentpath";
@@ -2110,7 +2075,7 @@ public void GetToolsetData_RegistryNotPresent()
         /// Note that config file not present is same as config file
         /// with no MSBuildToolsets Section
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ConfigFileNotPresent()
         {
             // Registry Read
@@ -2138,7 +2103,7 @@ public void GetToolsetData_ConfigFileNotPresent()
         /// <summary>
         /// Tests the case where nothing is specified in registry and config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_RegistryAndConfigNotPresent()
         {
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
@@ -2168,7 +2133,7 @@ public void GetToolsetData_RegistryAndConfigNotPresent()
         /// <summary>
         /// Tests the case when reading config file throws an exception
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ReadConfigThrowsException()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -2198,7 +2163,7 @@ public void GetToolsetData_ReadConfigThrowsException()
         /// <summary>
         /// Tests the case where reading from registry throws exception
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ReadRegistryOpenSubKeyThrowsException()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -2242,7 +2207,7 @@ public void GetToolsetData_ReadRegistryOpenSubKeyThrowsException()
         /// Tests that the default ToolsVersion is correctly resolved when specified
         /// in registry and config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultToolsetVersion_SpecifiedInRegistryAndConfigFile()
         {
             // Set up registry with two tools versions and one property each
@@ -2287,7 +2252,7 @@ public void SetDefaultToolsetVersion_SpecifiedInRegistryAndConfigFile()
         /// <summary>
         /// Tests that the default ToolsVersion is correctly resolved when specified in registry only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultToolsetVersion_SpecifiedOnlyInRegistry()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -2330,7 +2295,7 @@ public void SetDefaultToolsetVersion_SpecifiedOnlyInRegistry()
         /// <summary>
         /// Tests that the override task path is correctly resolved when specified in registry only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetOverrideTasks_SpecifiedOnlyInRegistry()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -2380,7 +2345,7 @@ public void SetOverrideTasks_SpecifiedOnlyInRegistry()
         /// <summary>
         /// Tests that the override default toolsversion is correctly resolved when specified in registry only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultOverrideToolsVersion_SpecifiedOnlyInRegistry()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -2427,7 +2392,7 @@ public void SetDefaultOverrideToolsVersion_SpecifiedOnlyInRegistry()
         /// Tests that the default ToolsVersion is correctly resolved
         /// when specified in config file only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultToolsetVersion_SpecifiedOnlyInConfigFile()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -2466,7 +2431,7 @@ public void SetDefaultToolsetVersion_SpecifiedOnlyInConfigFile()
         /// when specified in config file only.
         /// Also, that MSBuildOverrideTasksPath can be overridden.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetOverrideTaskPath_SpecifiedOnlyInConfigFile()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -2507,7 +2472,7 @@ public void SetOverrideTaskPath_SpecifiedOnlyInConfigFile()
         /// Tests that the override default ToolsVersion is correctly resolved
         /// when specified in config file only.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultOverrideToolsVersion_SpecifiedOnlyInConfigFile()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -2545,7 +2510,7 @@ public void SetDefaultOverrideToolsVersion_SpecifiedOnlyInConfigFile()
         /// <summary>
         /// Tests that the default ToolsVersion is correctly resolved when specified nowhere
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultToolsetVersion_SpecifiedNowhere()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -2592,7 +2557,7 @@ public void SetDefaultToolsetVersion_SpecifiedNowhere()
         /// <summary>
         /// Tests that properties are properly expanded when reading them from the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PropertiesInToolsetsFromConfigFileAreExpanded()
         {
             // $(COMPUTERNAME) is just a convenient env var. $(NUMBER_OF_PROCESSORS) isn't defined on Longhorn
@@ -2632,7 +2597,7 @@ public void PropertiesInToolsetsFromConfigFileAreExpanded()
         /// <summary>
         /// Tests that properties in MSBuildToolsPath are properly expanded when reading them from the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PropertiesInToolsetsFromConfigFileAreExpandedInToolsPath()
         {
             string binPathConfig = NativeMethodsShared.IsWindows ?
@@ -2686,7 +2651,7 @@ public void PropertiesInToolsetsFromConfigFileAreExpandedInToolsPath()
         /// Global properties are available, but they cannot be overwritten by other toolset properties, just as they cannot
         /// be overwritten by project file properties.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GlobalPropertiesInToolsetsAreExpandedButAreNotOverwritten()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
diff --git a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
index a39a6b336b0..213b448ec14 100644
--- a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
@@ -10,10 +10,10 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Internal;
-using Microsoft.Build.Shared;
 using Microsoft.Win32;
 
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 
@@ -24,7 +24,6 @@ namespace Microsoft.Build.UnitTests.Definition
     /// <summary>
     /// Unit test for ToolsetRegistryReader class
     /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class ToolsetRegistryReader_Tests : IDisposable
     {
         // The registry key that is passed as the baseKey parameter to the ToolsetRegistryReader class
@@ -79,7 +78,7 @@ private void DeleteTestRegistryKey()
         /// <summary>
         /// If the base key has been deleted, then we just don't get any information (no exception)
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_DeletedKey()
         {
             DeleteTestRegistryKey();
@@ -119,7 +118,7 @@ public void DefaultValuesInRegistryCreatedBySetup()
         /// <summary>
         /// Tests we handle no default toolset specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void DefaultValueInRegistryDoesNotExist()
         {
             ToolsetReader reader = new ToolsetRegistryReader(new ProjectCollection().EnvironmentProperties, new PropertyDictionary<ProjectPropertyInstance>(), new MockRegistryKey(testRegistryPath, "3.5" /* fail to find subkey 3.5 */));
@@ -138,7 +137,7 @@ public void DefaultValueInRegistryDoesNotExist()
         /// <summary>
         /// The base key exists but contains no subkey or values: this is okay
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_NoSubkeyNoValues()
         {
             ToolsetReader reader = GetStandardRegistryReader();
@@ -155,7 +154,7 @@ public void ReadRegistry_NoSubkeyNoValues()
         /// Here we validate that MSBuild does not fail when there are unrecognized values underneath
         /// the ToolsVersion key.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_NoSubkeysOnlyValues()
         {
             _toolsVersionsRegistryKey.SetValue("Name1", "Value1");
@@ -174,7 +173,7 @@ public void ReadRegistry_NoSubkeysOnlyValues()
         /// <summary>
         /// Basekey has only 1 subkey
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_OnlyOneSubkey()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -197,7 +196,7 @@ public void ReadRegistry_OnlyOneSubkey()
         /// <summary>
         /// Basic case
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_Basic()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -227,7 +226,7 @@ public void ReadRegistry_Basic()
         /// <summary>
         /// baseKey contains some non-String data
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_NonStringData()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -256,7 +255,7 @@ public void ReadRegistry_NonStringData()
         ///        SubKey2
         ///        SubKey3
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_HasSubToolsets()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -312,7 +311,7 @@ public void ReadRegistry_HasSubToolsets()
         ///        SubKey1
         ///            SubSubKey1
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_IgnoreSubToolsetSubKeys()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -347,7 +346,7 @@ public void ReadRegistry_IgnoreSubToolsetSubKeys()
         /// selected subtoolset, the subtoolset value overrides -- even if that
         /// value is empty.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_SubToolsetOverridesBaseToolsetEntries()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -387,7 +386,7 @@ public void ReadRegistry_SubToolsetOverridesBaseToolsetEntries()
         /// selected subtoolset, the subtoolset value overrides -- even if that
         /// value is empty.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_UnselectedSubToolsetIsIgnored()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -416,7 +415,7 @@ public void ReadRegistry_UnselectedSubToolsetIsIgnored()
         /// <summary>
         /// Regular case of getting default tools version
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultToolsVersionFromRegistry_Basic()
         {
             _currentVersionRegistryKey.SetValue("DefaultToolsVersion", "tv1");
@@ -435,7 +434,7 @@ public void GetDefaultToolsVersionFromRegistry_Basic()
         /// <summary>
         /// Default value is not set
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultToolsVersionFromRegistry_DefaultValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
@@ -450,7 +449,7 @@ public void GetDefaultToolsVersionFromRegistry_DefaultValueNotSet()
         /// <summary>
         /// "DefaultToolsVersion" has non-String data
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultToolsVersionFromRegistry_NonStringData()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -473,7 +472,7 @@ private ToolsetRegistryReader GetStandardRegistryReader()
         /// <summary>
         /// Regular case of getting overridetaskspath
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetOverrideTasksPathFromRegistry_Basic()
         {
             if (NativeMethodsShared.IsUnixLike)
@@ -495,7 +494,7 @@ public void GetOverrideTasksPathFromRegistry_Basic()
         /// <summary>
         /// OverrideTasksPath is not set
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetOverrideTasksPathFromRegistry_ValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
@@ -510,7 +509,7 @@ public void GetOverrideTasksPathFromRegistry_ValueNotSet()
         /// <summary>
         /// "OverrideTasksPath" has non-String data
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetOverrideTasksPathFromRegistry_NonStringData()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -527,7 +526,7 @@ public void GetOverrideTasksPathFromRegistry_NonStringData()
         /// <summary>
         /// Regular case of getting the default override toolsversion
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultOverrideToolsVersionFromRegistry_Basic()
         {
             _currentVersionRegistryKey.SetValue("DefaultOverrideToolsVersion", "Current");
@@ -544,7 +543,7 @@ public void GetDefaultOverrideToolsVersionFromRegistry_Basic()
         /// <summary>
         /// DefaultOverrideToolsVersion is not set
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultOverrideToolsVersionFromRegistry_ValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
@@ -559,7 +558,7 @@ public void GetDefaultOverrideToolsVersionFromRegistry_ValueNotSet()
         /// <summary>
         /// "DefaultOverrideToolsVersion" has non-String data
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultOverrideToolsVersionFromRegistry_NonStringData()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -573,7 +572,7 @@ public void GetDefaultOverrideToolsVersionFromRegistry_NonStringData()
                 reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
             });
         }
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadToolsets_NoBinPathOrToolsPath()
         {
             RegistryKey key1 = _toolsVersionsRegistryKey.CreateSubKey("tv1");
diff --git a/src/Build.UnitTests/Definition/Toolset_Tests.cs b/src/Build.UnitTests/Definition/Toolset_Tests.cs
index aaaade0b2b2..2bf6e660b37 100644
--- a/src/Build.UnitTests/Definition/Toolset_Tests.cs
+++ b/src/Build.UnitTests/Definition/Toolset_Tests.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -173,8 +174,7 @@ public void TestDefaultSubToolset()
             Assert.Equal("v13.0", t.DefaultSubToolsetVersion);
         }
 
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/4363")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/4363")]
         public void TestDefaultSubToolsetFor40()
         {
             Toolset t = ProjectCollection.GlobalProjectCollection.GetToolset("4.0");
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index 93a4f449f12..97ce42f1f29 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -107,7 +107,6 @@ public void SemicolonInPropertyPassedIntoStringParam()
         /// a string parameter of a task, in this case the Message task.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SemicolonInPropertyPassedIntoStringParam_UsingTaskHost()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
@@ -160,7 +159,6 @@ public void SemicolonInPropertyPassedIntoITaskItemParam()
         /// an ITaskItem[] task parameter.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SemicolonInPropertyPassedIntoITaskItemParam_UsingTaskHost()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(String.Format(@"
@@ -606,7 +604,6 @@ public void ItemTransformContainingSemicolon()
         /// as an escaped percent sign.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ItemTransformContainingSemicolon_InTaskHost()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
@@ -733,7 +730,6 @@ public void EscapedWildcardsShouldNotBeExpanded()
         /// literally, not as a wildcard
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EscapedWildcardsShouldNotBeExpanded_InTaskHost()
         {
             MockLogger logger = new();
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index c58a0dc6ad7..f215d86d9ec 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -20,7 +20,7 @@
 using Microsoft.Build.Shared.FileSystem;
 using Shouldly;
 using Xunit;
-
+using Xunit.NetCore.Extensions;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 
 #nullable disable
@@ -199,7 +199,6 @@ public void VerifyExistsInMemoryProjects()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyConditionsInsideOutsideTargets()
         {
             string testtargets = @"
@@ -2297,7 +2296,6 @@ public void InitialTargetsWithBlanks()
         /// or on a 32-bit machine and "c:\program files (x86)\msbuild" in a 32-bit process on a 64-bit machine.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MSBuildExtensionsPathDefault_Legacy()
         {
             string specialPropertyName = "MSBuildExtensionsPath";
@@ -2411,7 +2409,6 @@ public void MSBuildExtensionsPathWithEnvironmentOverride()
         /// should win over whatever MSBuild thinks the default is.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MSBuildExtensionsPathWithGlobalOverride()
         {
             Project project = new Project(new ProjectCollection());
@@ -2430,7 +2427,6 @@ public void MSBuildExtensionsPathWithGlobalOverride()
         /// We can't test that unless we are on a 64 bit box, but this test will work on either
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MSBuildExtensionsPath32Default()
         {
             // On a 64 bit machine we always want to use the program files x86.  If we are running as a 64 bit process then this variable will be set correctly
@@ -2464,7 +2460,6 @@ public void MSBuildExtensionsPath32Default()
         /// of seeing whether our value wins.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MSBuildExtensionsPath32WithEnvironmentOverride()
         {
             string originalMSBuildExtensionsPath32Value = Environment.GetEnvironmentVariable("MSBuildExtensionsPath32");
@@ -2488,7 +2483,6 @@ public void MSBuildExtensionsPath32WithEnvironmentOverride()
         /// of seeing whether our value wins.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MSBuildExtensionsPath32WithGlobalOverride()
         {
             Project project = new Project(new ProjectCollection());
@@ -2505,7 +2499,6 @@ public void MSBuildExtensionsPath32WithGlobalOverride()
         /// We can't test that unless we are on a 64 bit box, but this test will work on either
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MSBuildExtensionsPath64Default()
         {
             string expected = string.Empty;
@@ -2679,7 +2672,6 @@ public void MSBuildVersion()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void ReservedProjectProperties()
         {
             string file = NativeMethodsShared.IsWindows ? @"c:\foo\bar.csproj" : "/foo/bar.csproj";
@@ -2717,14 +2709,9 @@ public void ReservedProjectPropertiesAtRoot()
         /// <summary>
         /// Test standard reserved properties on UNC at root
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("UNC is only available under Windows.")]
         public void ReservedProjectPropertiesOnUNCRoot()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "UNC is only available under Windows"
-            }
-
             string uncFile = @"\\foo\bar\baz.csproj";
             ProjectRootElement xml = ProjectRootElement.Create(uncFile);
             Project project = new Project(xml);
@@ -2740,14 +2727,9 @@ public void ReservedProjectPropertiesOnUNCRoot()
         /// <summary>
         /// Test standard reserved properties on UNC
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("UNC is only available under Windows.")]
         public void ReservedProjectPropertiesOnUNC()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "UNC is only available under Windows"
-            }
-
             string uncFile = @"\\foo\bar\baz\biz.csproj";
             ProjectRootElement xml = ProjectRootElement.Create(uncFile);
             Project project = new Project(xml);
@@ -2765,7 +2747,6 @@ public void ReservedProjectPropertiesOnUNC()
         /// Verify when a node count is passed through on the project collection that the correct number is used to evaluate the msbuildNodeCount
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyMsBuildNodeCountReservedProperty()
         {
             string content = ObjectModelHelpers.CleanupFileContents(@"
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 82aadfa05a2..c30721a2d59 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -32,6 +32,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared.FileSystem;
 using Shouldly;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -259,7 +260,6 @@ public void ExpandItemVectorFunctionsGetDirectoryNameOfMetadataValueDistinct()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void ExpandItemVectorFunctionsItemSpecModifier()
         {
             ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
@@ -320,7 +320,6 @@ public void ExpandItemVectorFunctionsInvalid2()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void ExpandItemVectorFunctionsChained1()
         {
             ProjectHelpers.CreateEmptyProjectInstance();
@@ -337,7 +336,6 @@ public void ExpandItemVectorFunctionsChained1()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void ExpandItemVectorFunctionsChained2()
         {
             ProjectHelpers.CreateEmptyProjectInstance();
@@ -365,7 +363,6 @@ public void ExpandItemVectorFunctionsChained3()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void ExpandItemVectorFunctionsChainedProject1()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
@@ -590,9 +587,7 @@ public void ExpandItemVectorFunctionsBuiltIn4()
             log.AssertLogContains("[foo;bar]");
         }
 
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/4363")]
+        [LongPathSupportDisabledFact(fullFrameworkOnly: true, additionalMessage: "https://github.com/dotnet/msbuild/issues/4363")]
         public void ExpandItemVectorFunctionsBuiltIn_PathTooLongError()
         {
             string content = @"
@@ -612,15 +607,9 @@ public void ExpandItemVectorFunctionsBuiltIn_PathTooLongError()
             log.AssertLogContains("MSB4198");
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Cannot have invalid characters in file name on Unix.")]
         public void ExpandItemVectorFunctionsBuiltIn_InvalidCharsError()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Cannot have invalid characters in file name on Unix"
-            }
-
             string content = @"
  <Project DefaultTargets=`t`>
 
@@ -644,7 +633,6 @@ public void ExpandItemVectorFunctionsBuiltIn_InvalidCharsError()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void ExpandItemVectorFunctionsItemSpecModifier2()
         {
             ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
@@ -876,8 +864,7 @@ public void ItemIncludeContainsMultipleItemReferences()
         /// <summary>
         /// Bad path when getting metadata through ->Metadata function
         /// </summary>
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [LongPathSupportDisabledFact]
         public void InvalidPathAndMetadataItemFunctionPathTooLong()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectFailure(@"
@@ -897,9 +884,7 @@ public void InvalidPathAndMetadataItemFunctionPathTooLong()
         /// <summary>
         /// Bad path with illegal windows chars when getting metadata through ->Metadata function
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void InvalidPathAndMetadataItemFunctionInvalidWindowsPathChars()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectFailure(@"
@@ -938,8 +923,7 @@ public void InvalidMetadataName()
         /// <summary>
         /// Bad path when getting metadata through ->WithMetadataValue function
         /// </summary>
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [LongPathSupportDisabledFact]
         public void InvalidPathAndMetadataItemFunctionPathTooLong2()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectFailure(@"
@@ -959,9 +943,7 @@ public void InvalidPathAndMetadataItemFunctionPathTooLong2()
         /// <summary>
         /// Bad path with illegal windows chars when getting metadata through ->WithMetadataValue function
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void InvalidPathAndMetadataItemFunctionInvalidWindowsPathChars2()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectFailure(@"
@@ -1000,8 +982,7 @@ public void InvalidMetadataName2()
         /// <summary>
         /// Bad path when getting metadata through ->AnyHaveMetadataValue function
         /// </summary>
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [LongPathSupportDisabledFact]
         public void InvalidPathAndMetadataItemFunctionPathTooLong3()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectFailure(@"
@@ -1021,9 +1002,7 @@ public void InvalidPathAndMetadataItemFunctionPathTooLong3()
         /// <summary>
         /// Bad path with illegal windows chars when getting metadata through ->AnyHaveMetadataValue function
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void InvalidPathAndMetadataItemInvalidWindowsPathChars3()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectFailure(@"
@@ -1039,9 +1018,7 @@ public void InvalidPathAndMetadataItemInvalidWindowsPathChars3()
             logger.AssertLogContains("MSB4023");
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void InvalidPathInDirectMetadata()
         {
             var logger = Helpers.BuildProjectContentUsingBuildManagerExpectResult(
@@ -1057,9 +1034,7 @@ public void InvalidPathInDirectMetadata()
             logger.AssertLogContains("MSB4248");
         }
 
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "new enough dotnet.exe transparently opts into long paths")]
+        [LongPathSupportDisabledFact(fullFrameworkOnly: true, additionalMessage: "new enough dotnet.exe transparently opts into long paths")]
         public void PathTooLongInDirectMetadata()
         {
             var logger = Helpers.BuildProjectContentUsingBuildManagerExpectResult(
@@ -1710,8 +1685,7 @@ public void RegistryPropertyInvalidPrefixError2()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyString()
         {
@@ -1733,8 +1707,7 @@ public void RegistryPropertyString()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyBinary()
         {
@@ -1759,8 +1732,7 @@ public void RegistryPropertyBinary()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyDWord()
         {
@@ -1782,8 +1754,7 @@ public void RegistryPropertyDWord()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyExpandString()
         {
@@ -1806,8 +1777,7 @@ public void RegistryPropertyExpandString()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyQWord()
         {
@@ -1829,8 +1799,7 @@ public void RegistryPropertyQWord()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyMultiString()
         {
@@ -1879,7 +1848,6 @@ public void TestItemSpecModiferEscaping()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestGetPathToReferenceAssembliesAsFunction()
         {
             if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48) == null)
@@ -2212,7 +2180,6 @@ public void PropertyFunctionArrayReturn()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyFunctionDictionaryReturn()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
@@ -2521,8 +2488,7 @@ public void PropertyFunctionConstructor2()
         /// <summary>
         /// Expand property function that is only available when MSBUILDENABLEALLPROPERTYFUNCTIONS=1
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/coreclr/issues/15662")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "https://github.com/dotnet/coreclr/issues/15662")]
         public void PropertyStaticFunctionAllEnabled()
         {
             using (var env = TestEnvironment.Create())
@@ -3228,7 +3194,6 @@ public void PropertyFunctionValueOrDefaultFromEnvironment()
         /// Expand property function that tests for existence of the task host
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyFunctionDoesTaskHostExist()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
@@ -3245,7 +3210,6 @@ public void PropertyFunctionDoesTaskHostExist()
         /// Expand property function that tests for existence of the task host
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyFunctionDoesTaskHostExist_Whitespace()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
@@ -3301,7 +3265,6 @@ public void PropertyFunctionDoesTaskHostExist_Error()
         /// Expand property function that tests for existence of the task host
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyFunctionDoesTaskHostExist_Evaluated()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
@@ -3354,7 +3317,6 @@ public void PropertyFunctionDoesTaskHostExist_NonexistentTaskHost()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyFunctionStaticMethodFileAttributes()
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
@@ -3466,8 +3428,7 @@ public void PropertySimpleSpaced()
             Assert.Equal(String.Empty, result);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegitryValue()
         {
@@ -3491,8 +3452,7 @@ public void PropertyFunctionGetRegitryValue()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegitryValueDefault()
         {
@@ -3516,8 +3476,7 @@ public void PropertyFunctionGetRegitryValueDefault()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegistryValueFromView1()
         {
@@ -3541,8 +3500,7 @@ public void PropertyFunctionGetRegistryValueFromView1()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegistryValueFromView2()
         {
diff --git a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
index b39f50cd243..4e478ab372e 100644
--- a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 
 
@@ -79,10 +80,7 @@ public void AddEntry()
         /// <summary>
         /// Tests that a strong reference is held to a single item
         /// </summary>
-        [Fact]
-        // This test fails on .NET Core and Mono: https://github.com/dotnet/msbuild/issues/282
-        [Trait("Category", "non-mono-tests")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/282")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "This test fails on .NET Core and Mono: https://github.com/dotnet/msbuild/issues/282")]
         public void AddEntryStrongReference()
         {
             string projectPath = NativeMethodsShared.IsUnixLike ? "/foo" : "c:\\foo";
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index 729864e9b1c..06d4883bfed 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -80,7 +80,6 @@ public void BasicNoExistingFile()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void InvalidFile()
         {
             Assert.Throws<LoggerException>(() =>
diff --git a/src/Build.UnitTests/FixPathOnUnix_Tests.cs b/src/Build.UnitTests/FixPathOnUnix_Tests.cs
index e74cfd7b14e..f3f635df854 100644
--- a/src/Build.UnitTests/FixPathOnUnix_Tests.cs
+++ b/src/Build.UnitTests/FixPathOnUnix_Tests.cs
@@ -6,15 +6,15 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
 namespace Microsoft.Build.UnitTests
 {
-    [PlatformSpecific(TestPlatforms.AnyUnix)]
     public class FixPathOnUnixTests
     {
-        [Fact]
+        [UnixOnlyFact]
         public void TestPathFixupInMetadata()
         {
             string buildProjectContents = @"
diff --git a/src/Build.UnitTests/Instance/HostServices_Tests.cs b/src/Build.UnitTests/Instance/HostServices_Tests.cs
index 3a9ebdb07c2..cab5c0b40e1 100644
--- a/src/Build.UnitTests/Instance/HostServices_Tests.cs
+++ b/src/Build.UnitTests/Instance/HostServices_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.UnitTests.BackEnd;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -241,8 +242,7 @@ public void TestContradictoryAffinityCausesException_Any()
         /// <summary>
         /// Test which ensures that setting an Any affinity for a project with a remote host object does not throws.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestNoContradictoryRemoteHostObjectAffinity()
         {
@@ -295,8 +295,7 @@ public void TestNonContraditcoryHostObjectAllowed_Any()
         /// <summary>
         /// Test which ensures the remote host object cannot affect a project which has the Any affinity specifically set.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestRegisterRemoteHostObjectNoAffect_Any2()
         {
@@ -334,8 +333,7 @@ public void TestNonContraditcoryHostObjectAllowed_InProc()
         /// <summary>
         /// Test which ensures the affinity for a project can be changed once the in process host object is registered
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestAffinityChangeAfterRegisterInprocessHostObject()
         {
@@ -444,8 +442,7 @@ public void UnloadedProjectDiscardsHostServices()
         /// <summary>
         /// Tests that register overrides existing reigsted remote host object.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestRegisterOverrideExistingRegisted()
         {
diff --git a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
index a12c2382a58..546c42c9432 100644
--- a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
@@ -340,7 +340,6 @@ public void GetSubToolsetVersion()
         /// environment
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GetSubToolsetVersion_FromEnvironment()
         {
             string originalVisualStudioVersion = Environment.GetEnvironmentVariable("VisualStudioVersion");
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index d017ffbe1cc..05d920b732b 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -76,6 +76,7 @@
     <Compile Include="..\Shared\UnitTests\ResourceUtilities_Tests.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -118,6 +119,9 @@
     <Compile Include="..\Shared\UnitTests\ImmutableDictionary_Tests.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MSBuildRuntimeType)' == 'Full' and '$(MonoBuild)' != 'true'">
       <Link>Collections\ImmutableDictionary_Tests.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\UnitTests\LongPathSupportDisabledFactAttribute.cs">
+      <Link>Shared\LongPathSupportDisabledFactAttribute.cs</Link>
+    </Compile>
 
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index e3233cff927..71fbd6ff54e 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -15,6 +15,7 @@
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -1345,8 +1346,7 @@ public void ProcessGraphBuildSwitch(string[] parameters, GraphBuildOptions expec
         /// Verifies that when the /profileevaluation switch is used with invalid filenames an error is shown.
         /// </summary>
         [MemberData(nameof(GetInvalidFilenames))]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
-        [Theory]
+        [WindowsFullFrameworkOnlyTheory(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void ProcessProfileEvaluationInvalidFilename(string filename)
         {
             bool enableProfiler = false;
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index ea90a86c84e..61f2c68c312 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -42,6 +42,7 @@
     <Compile Include="..\Shared\UnitTests\MockEngine.cs" />
     <Compile Include="..\Shared\UnitTests\MockLogger.cs" />
     <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs" />
+    <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
 
     <EmbeddedResource Include="..\MSBuild\MSBuild\Microsoft.Build.Core.xsd">
diff --git a/src/MSBuild.UnitTests/PerfLog_Tests.cs b/src/MSBuild.UnitTests/PerfLog_Tests.cs
index 0f747122ec8..9927e43e78c 100644
--- a/src/MSBuild.UnitTests/PerfLog_Tests.cs
+++ b/src/MSBuild.UnitTests/PerfLog_Tests.cs
@@ -22,7 +22,6 @@ public PerfLogTests(ITestOutputHelper output)
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")] // Disable on Mono OSX, since Mono doesn't implement EventSource.
         public void TestPerfLogEnabledProducedLogFile()
         {
             using (TestEnvironment testEnv = TestEnvironment.Create(_output))
diff --git a/src/Samples/Directory.Build.props b/src/Samples/Directory.Build.props
index 317ef14a6bb..f04411fb004 100644
--- a/src/Samples/Directory.Build.props
+++ b/src/Samples/Directory.Build.props
@@ -1,17 +1,21 @@
 ﻿<Project>
 
+  <!--This should be before importing parent properties, as it affects the output directory (defined in arcade SDK) -->
   <PropertyGroup>
     <!-- Use Samples subdirectory for samples in output folder -->
     <OutDirName>Samples\$(MSBuildProjectName)</OutDirName>
+  </PropertyGroup>
+
+  <!-- Import parent props -->
+  <Import Project="..\Directory.Build.props"/>
 
+  <PropertyGroup>
     <!-- Don't regulate package versions for samples -->
-    <EnableCentralPackageVersions>false</EnableCentralPackageVersions>
+    <ManagePackageVersionsCentrally>false</ManagePackageVersionsCentrally>
+    <ImportDirectoryPackagesProps>false</ImportDirectoryPackagesProps>
 
     <IsShipping>false</IsShipping>
     <ExcludeFromSourceBuild>true</ExcludeFromSourceBuild>
   </PropertyGroup>
 
-  <!-- Import parent props -->
-  <Import Project="..\Directory.Build.props"/>
-
 </Project>
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index b29b4238e8e..b8c1416aa96 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Shared.FileSystem;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -822,14 +823,9 @@ public void Regress162390()
         * Convert a short local path to a long path.
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameForShortLocalPath()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"D:\LONGDI~1\LONGSU~1\LONGFI~1.TXT",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -859,14 +855,9 @@ public void GetLongFileNameForLongLocalPath()
         * Convert a short UNC path to a long path.
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameForShortUncPath()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"\\server\share\LONGDI~1\LONGSU~1\LONGFI~1.TXT",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -896,14 +887,9 @@ public void GetLongFileNameForLongUncPath()
         * Convert a short relative path to a long path
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameForRelativePath()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"LONGDI~1\LONGSU~1\LONGFI~1.TXT",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -917,14 +903,9 @@ public void GetLongFileNameForRelativePath()
         * Convert a short relative path with a trailing backslash to a long path
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameForRelativePathPreservesTrailingSlash()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"LONGDI~1\LONGSU~1\",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -938,14 +919,9 @@ public void GetLongFileNameForRelativePathPreservesTrailingSlash()
         * Convert a short relative path with doubled embedded backslashes to a long path
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameForRelativePathPreservesExtraSlashes()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"LONGDI~1\\LONGSU~1\\",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -959,14 +935,9 @@ public void GetLongFileNameForRelativePathPreservesExtraSlashes()
         * Only part of the path might be short.
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameForMixedLongAndShort()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"c:\apple\banana\tomato\pomegr~1\orange\",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -981,14 +952,9 @@ public void GetLongFileNameForMixedLongAndShort()
         * as if they were already a long file name.
         *
         */
-        [Fact]
+        [WindowsOnlyFact("Short names are for Windows only.")]
         public void GetLongFileNameWherePartOfThePathDoesntExist()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Short names are for Windows only"
-            }
-
             string longPath = FileMatcher.GetLongPathName(
                 @"c:\apple\banana\tomato\pomegr~1\orange\chocol~1\vanila~1",
                 new FileMatcher.GetFileSystemEntries(FileMatcherTest.GetFileSystemEntries));
@@ -1338,7 +1304,6 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
             }
         }
 
-        [PlatformSpecific(TestPlatforms.Any)]
         [Theory]
         [InlineData(@"\", "**")]
         [InlineData(@"\\", "**")]
@@ -1350,8 +1315,7 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
         public void DriveEnumeratingWildcardIsObservedOnAnyPlatform(string directoryPart, string wildcardPart) =>
             DriveEnumeratingWildcardIsObserved(directoryPart, wildcardPart);
 
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(@"\", "**")]
         [InlineData(@"c:\", "**")]
         [InlineData(@"c:\\", "**")]
@@ -1366,8 +1330,7 @@ public void DriveEnumeratingWildcardIsObservedOnWindows(string directoryPart, st
         private void DriveEnumeratingWildcardIsObserved(string directoryPart, string wildcardPart) =>
             FileMatcher.IsDriveEnumeratingWildcardPattern(directoryPart, wildcardPart).ShouldBeTrue();
 
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(@"\", "**")]
         [InlineData("/", "**/*.cs")]
         [InlineData("/", "**")]
@@ -1415,8 +1378,7 @@ private void DriveEnumeratingWildcardFailsAndReturns(string directoryPart, strin
         }
 
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(@"z:\**")]
         [InlineData(@"z:\\**")]
         [InlineData(@"z:\\\\\\\\**")]
@@ -1453,7 +1415,6 @@ public void DriveEnumeratingWildcardIsLoggedOnWindows(string driveEnumeratingWil
             }
         }
 
-        [PlatformSpecific(TestPlatforms.Any)]
         [Theory]
         [InlineData(@"\", @"*\*.cs")]
         [InlineData(@"\\", @"*\*.cs")]
@@ -1464,8 +1425,7 @@ public void DriveEnumeratingWildcardIsLoggedOnWindows(string driveEnumeratingWil
         public void DriveEnumeratingWildcardIsNotObservedOnAnyPlatform(string directoryPart, string wildcardPart) =>
             DriveEnumeratingWildcardIsNotObserved(directoryPart, wildcardPart);
 
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(@"c:\", "**")]
         [InlineData(@"c:\\", "**")]
         [InlineData(@"c:\\\\\\\\", "**")]
@@ -1899,8 +1859,7 @@ public void GetFileSpecInfoCommon(
                 expectedIsLegalFileSpec);
         }
 
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         // Escape pecial regex characters valid in Windows paths
         [InlineData(
             @"$()+.[^{\?$()+.[^{\$()+.[^{",
@@ -1938,8 +1897,7 @@ public void GetFileSpecInfoWindows(
                 expectedIsLegalFileSpec);
         }
 
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         // Escape regex characters valid in Unix paths
         [InlineData(
             @"$()+.[^{|\?$()+.[^{|\$()+.[^{|",
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index 199b46c85f1..86f2028956c 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -20,7 +21,6 @@ public class FileUtilities_Tests
         /// Exercises FileUtilities.ItemSpecModifiers.GetItemSpecModifier
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void GetItemSpecModifier()
@@ -150,9 +150,7 @@ public void MakeRelativeTests()
         /// <summary>
         /// Exercises FileUtilities.ItemSpecModifiers.GetItemSpecModifier on a bad path.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // On Unix there no invalid file name characters
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void GetItemSpecModifierOnBadPath()
         {
             Assert.Throws<InvalidOperationException>(() =>
@@ -163,9 +161,7 @@ public void GetItemSpecModifierOnBadPath()
         /// <summary>
         /// Exercises FileUtilities.ItemSpecModifiers.GetItemSpecModifier on a bad path.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // On Unix there no invalid file name characters
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void GetItemSpecModifierOnBadPath2()
         {
             Assert.Throws<InvalidOperationException>(() =>
@@ -219,7 +215,6 @@ public void GetFileInfoNoThrowNonexistent()
         /// Exercises FileUtilities.EndsWithSlash
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void EndsWithSlash()
@@ -244,7 +239,6 @@ public void EndsWithSlash()
         /// Exercises FileUtilities.GetDirectory
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void GetDirectoryWithTrailingSlash()
@@ -294,9 +288,7 @@ public void HasExtension_WhenFileNameDoesNotHaveExtension_ReturnsFalse(string fi
             Assert.False(result);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void HasExtension_WhenInvalidFileName_ThrowsArgumentException()
         {
             Assert.Throws<ArgumentException>(() =>
@@ -417,8 +409,7 @@ public void CheckDerivableItemSpecModifiers()
             Assert.False(FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier("recursivedir"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void NormalizePathThatFitsIntoMaxPath()
         {
             string currentDirectory = @"c:\aardvark\aardvark\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890";
@@ -428,9 +419,7 @@ public void NormalizePathThatFitsIntoMaxPath()
             Assert.Equal(fullPath, FileUtilities.NormalizePath(Path.Combine(currentDirectory, filePath)));
         }
 
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/4363")]
+        [LongPathSupportDisabledFact(fullFrameworkOnly: true, additionalMessage: "https://github.com/dotnet/msbuild/issues/4363")]
         public void NormalizePathThatDoesntFitIntoMaxPath()
         {
             Assert.Throws<PathTooLongException>(() =>
@@ -445,8 +434,7 @@ public void NormalizePathThatDoesntFitIntoMaxPath()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetItemSpecModifierRootDirThatFitsIntoMaxPath()
         {
             string currentDirectory = @"c:\aardvark\aardvark\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890";
@@ -474,9 +462,7 @@ public void NormalizePathEmpty()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void NormalizePathBadUNC1()
         {
             Assert.Throws<ArgumentException>(() =>
@@ -485,9 +471,7 @@ public void NormalizePathBadUNC1()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void NormalizePathBadUNC2()
         {
             Assert.Throws<ArgumentException>(() =>
@@ -496,9 +480,7 @@ public void NormalizePathBadUNC2()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void NormalizePathBadUNC3()
         {
             Assert.Throws<ArgumentException>(() =>
@@ -507,15 +489,13 @@ public void NormalizePathBadUNC3()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void NormalizePathGoodUNC()
         {
             Assert.Equal(@"\\localhost\share", FileUtilities.NormalizePath(@"\\localhost\share"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void NormalizePathTooLongWithDots()
         {
             string longPart = new string('x', 300);
@@ -523,8 +503,7 @@ public void NormalizePathTooLongWithDots()
         }
 
 #if FEATURE_LEGACY_GETFULLPATH
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/4205")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/4205")]
         public void NormalizePathBadGlobalroot()
         {
             Assert.Throws<ArgumentException>(() =>
@@ -542,9 +521,7 @@ From Path.cs
         }
 #endif
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
         public void NormalizePathInvalid()
         {
             string filePath = @"c:\aardvark\|||";
@@ -555,8 +532,7 @@ public void NormalizePathInvalid()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void CannotNormalizePathWithNewLineAndSpace()
         {
             string filePath = "\r\n      C:\\work\\sdk3\\artifacts\\tmp\\Debug\\SimpleNamesWi---6143883E\\NETFrameworkLibrary\\bin\\Debug\\net462\\NETFrameworkLibrary.dll\r\n      ";
@@ -595,7 +571,6 @@ public void FileOrDirectoryExistsNoThrow()
         // These tests will need to be redesigned for Linux
 
         [ConditionalFact(nameof(RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241))]
-        [Trait("Category", "mono-osx-failing")]
         public void FileOrDirectoryExistsNoThrowTooLongWithDots()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3)).Length;
@@ -611,7 +586,6 @@ public void FileOrDirectoryExistsNoThrowTooLongWithDots()
         }
 
         [ConditionalFact(nameof(RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241))]
-        [Trait("Category", "mono-osx-failing")]
         public void FileOrDirectoryExistsNoThrowTooLongWithDotsRelative()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3)).Length;
@@ -665,7 +639,6 @@ public void DirectoryExistsNoThrowTooLongWithDots()
         }
 
         [ConditionalFact(nameof(RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241))]
-        [Trait("Category", "mono-osx-failing")]
         public void DirectoryExistsNoThrowTooLongWithDotsRelative()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3)).Length;
@@ -702,7 +675,6 @@ public static bool RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241()
         }
 
         [ConditionalFact(nameof(RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241))]
-        [Trait("Category", "mono-osx-failing")]
         public void FileExistsNoThrowTooLongWithDots()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3) + @"\..\explorer.exe").Length;
@@ -718,7 +690,6 @@ public void FileExistsNoThrowTooLongWithDots()
         }
 
         [ConditionalFact(nameof(RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241))]
-        [Trait("Category", "mono-osx-failing")]
         public void FileExistsNoThrowTooLongWithDotsRelative()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3) + @"\..\explorer.exe").Length;
@@ -746,7 +717,6 @@ public void FileExistsNoThrowTooLongWithDotsRelative()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GetFileInfoNoThrowTooLongWithDots()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3) + @"\..\explorer.exe").Length;
@@ -762,7 +732,6 @@ public void GetFileInfoNoThrowTooLongWithDots()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GetFileInfoNoThrowTooLongWithDotsRelative()
         {
             int length = (Environment.SystemDirectory + @"\" + @"\..\..\..\" + Environment.SystemDirectory.Substring(3) + @"\..\explorer.exe").Length;
@@ -884,7 +853,6 @@ public void GenerateTempFileNameWithExtensionNoPeriod()
         /// Extension is invalid
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void GenerateTempBatchFileWithBadExtension()
@@ -899,7 +867,6 @@ public void GenerateTempBatchFileWithBadExtension()
         /// Directory is invalid
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void GenerateTempBatchFileWithBadDirectory()
@@ -910,8 +877,7 @@ public void GenerateTempBatchFileWithBadDirectory()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void AbsolutePathLooksLikeUnixPathOnUnix()
         {
             var secondSlash = SystemSpecificAbsolutePath.Substring(1).IndexOf(Path.DirectorySeparatorChar) + 1;
@@ -921,8 +887,7 @@ public void AbsolutePathLooksLikeUnixPathOnUnix()
             Assert.True(FileUtilities.LooksLikeUnixFilePath(rootLevelPath));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void PathDoesNotLookLikeUnixPathOnWindows()
         {
             Assert.False(FileUtilities.LooksLikeUnixFilePath(SystemSpecificAbsolutePath));
@@ -930,8 +895,7 @@ public void PathDoesNotLookLikeUnixPathOnWindows()
             Assert.False(FileUtilities.LooksLikeUnixFilePath("/root"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void RelativePathLooksLikeUnixPathOnUnixWithBaseDirectory()
         {
             string filePath = ObjectModelHelpers.CreateFileInTempProjectDirectory("first/second/file.txt", String.Empty);
@@ -961,8 +925,7 @@ public void RelativePathLooksLikeUnixPathOnUnixWithBaseDirectory()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void RelativePathMaybeAdjustFilePathWithBaseDirectory()
         {
             // <tmp_dir>/first/second/file.txt
diff --git a/src/Shared/UnitTests/LongPathSupportDisabledFactAttribute.cs b/src/Shared/UnitTests/LongPathSupportDisabledFactAttribute.cs
new file mode 100644
index 00000000000..7a14d49dd74
--- /dev/null
+++ b/src/Shared/UnitTests/LongPathSupportDisabledFactAttribute.cs
@@ -0,0 +1,41 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+using Xunit;
+using Xunit.NetCore.Extensions;
+
+namespace Microsoft.Build.UnitTests
+{
+    /// <summary>
+    ///  This test should be run only on Windows, and when long path support is enabled.
+    ///  It is possible to conditionally restrict the fact to be run only on full .NET Framework.
+    /// </summary>
+    public class LongPathSupportDisabledFactAttribute : FactAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="LongPathSupportDisabledFactAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        /// <param name="fullFrameworkOnly"><see langword="true"/> if the test can be run only on full framework. The default value is <see langword="false"/>.</param>
+        public LongPathSupportDisabledFactAttribute(string? additionalMessage = null, bool fullFrameworkOnly = false)
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test only runs on Windows and when long path support is disabled.".AppendAdditionalMessage(additionalMessage);
+                return;
+            }
+
+            if (fullFrameworkOnly && !CustomXunitAttributesUtilities.IsBuiltAgainstNetFramework)
+            {
+                this.Skip = "This test only runs on full .NET Framework and when long path support is disabled.".AppendAdditionalMessage(additionalMessage);
+                return;
+            }
+
+            if (!NativeMethodsShared.IsMaxPathLegacyWindows())
+            {
+                this.Skip = "This test only runs when long path support is disabled.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
index e93424bcca7..fc4c92ed88b 100644
--- a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
+++ b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
@@ -5,9 +5,10 @@
 using System.Diagnostics;
 using System.IO;
 using System.Runtime.InteropServices;
-
+using System.Runtime.Versioning;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 
 
@@ -30,14 +31,10 @@ public sealed class NativeMethodsShared_Tests
         /// Verify that getProcAddress works, bug previously was due to a bug in the attributes used to pinvoke the method
         /// when that bug was in play this test would fail.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("No Kernel32.dll except on Windows.")]
+        [SupportedOSPlatform("windows")] // bypass CA1416: Validate platform compatibility
         public void TestGetProcAddress()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "No Kernel32.dll except on Windows"
-            }
-
             IntPtr kernel32Dll = NativeMethodsShared.LoadLibrary("kernel32.dll");
             try
             {
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index 7f6c1016f2e..25e7cb3a50d 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -5,6 +5,7 @@
 
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -93,9 +94,7 @@ public void TestMergeRuntimeValuesAnyAcceptsCurrent()
             mergedRuntime.ShouldBe(XMakeAttributes.GetCurrentMSBuildRuntime());
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp,
-            "Tests whether 'current' merges with 'clr4' which is true only on Framework")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "Tests whether 'current' merges with 'clr4' which is true only on Framework.")]
         public void TestMergeRuntimeValuesCurrentToClr4()
         {
             XMakeAttributes.TryMergeRuntimeValues(
@@ -111,9 +110,7 @@ public void TestMergeRuntimeValuesCurrentToClr4()
             mergedRuntime.ShouldBeNull();
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework,
-            "Tests whether 'current' merges with 'net' which is true only on core")]
+        [DotNetOnlyFact(additionalMessage: "Tests whether 'current' merges with 'net' which is true only on core.")]
         public void TestMergeRuntimeValuesCurrentToCore()
         {
             XMakeAttributes.TryMergeRuntimeValues(
diff --git a/src/StringTools.UnitTests/WeakStringCache_Tests.cs b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
index 75c418f48ca..41990c59396 100644
--- a/src/StringTools.UnitTests/WeakStringCache_Tests.cs
+++ b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
@@ -125,7 +125,6 @@ private void AddStringsWithSameHashCode(int numberOfStrings)
         /// https://www.mono-project.com/docs/advanced/garbage-collector/sgen/#precise-stack-marking
         /// </remarks>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void RetainsStringUntilCollected()
         {
             // Add a string to the cache using a non-inlinable method to make sure it's not reachable from a GC root.
@@ -167,7 +166,6 @@ public void RetainsStringUntilCollected()
         /// https://www.mono-project.com/docs/advanced/garbage-collector/sgen/#precise-stack-marking
         /// </remarks>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void RetainsLastStringWithGivenHashCode()
         {
             // Add 3 strings with the same hash code.
diff --git a/src/Tasks.UnitTests/AspNetCompiler_Tests.cs b/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
index 0b3829c05e4..61b899f3c1a 100644
--- a/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
+++ b/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
@@ -243,7 +243,6 @@ public void AllParameters()
         /// the project files don't exist, but we only care about the events anyway.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestExternalProjectEvents()
         {
             string projectFileContents = @"
diff --git a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
index fc611cfbcda..afea57b3a14 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
@@ -219,7 +219,6 @@ public void VerifyNullPublicKeyspecificVersion()
         /// this was causing the GAC (api's) to crash.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyProcessorArchitectureDoesNotCrash()
         {
             AssemblyNameExtension fusionName = new AssemblyNameExtension("System, PublicKeyToken=b77a5c561934e089, ProcessorArchitecture=MSIL");
@@ -232,7 +231,6 @@ public void VerifyProcessorArchitectureDoesNotCrash()
         /// this was causing the GAC (api's) to crash.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyProcessorArchitectureDoesNotCrashSpecificVersion()
         {
             AssemblyNameExtension fusionName = new AssemblyNameExtension("System, PublicKeyToken=b77a5c561934e089, ProcessorArchitecture=MSIL");
@@ -405,7 +403,6 @@ public void SystemRuntimeDepends_Yes()
 
         // Indirect dependency
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SystemRuntimeDepends_Yes_Indirect()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
diff --git a/src/Tasks.UnitTests/AssemblyDependency/InstalledSDKResolverFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/InstalledSDKResolverFixture.cs
index d502a4a7486..cdacfae192e 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/InstalledSDKResolverFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/InstalledSDKResolverFixture.cs
@@ -53,7 +53,6 @@ public void SDkNameNotInResolvedSDKListButOnSearchPath()
         /// Verify when we are trying to match a name which is the reference assembly directory
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SDkNameMatchInRADirectory()
         {
             ResolveSDKFromRefereneAssemblyLocation("DebugX86SDKWinMD", @"C:\FakeSDK\References\Debug\X86\DebugX86SDKWinMD.Winmd", _output);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 750c73b673e..5dd2309309b 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -18,6 +18,7 @@
 using Xunit.Abstractions;
 using Shouldly;
 using Microsoft.Build.UnitTests.Shared;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -126,7 +127,6 @@ public void VerifyPrimaryReferenceToBadImageDoesNotThrow()
         /// Since copyLocalDependenciesWhenParentReferenceInGac is set to false and the parent of Z is in the GAC
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CopyLocalDependenciesWhenParentReferenceInGacFalseAllParentsInGac()
         {
             // Create the engine.
@@ -202,7 +202,6 @@ public void ValidateFrameworkNameError()
         /// Since copyLocalDependenciesWhenParentReferenceInGac is set to false but one of the parents of Z is not in the GAC and Z is not in the gac we should be copy local
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CopyLocalDependenciesWhenParentReferenceInGacFalseSomeParentsInGac()
         {
             // Create the engine.
@@ -265,7 +264,6 @@ public void TestSetRuntimeVersion()
         /// Since copyLocalDependenciesWhenParentReferenceInGac is set to true and Z is not in the GAC it will be copy local true
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CopyLocalDependenciesWhenParentReferenceInGacTrueAllParentsInGac()
         {
             // Create the engine.
@@ -314,7 +312,6 @@ public void CopyLocalDependenciesWhenParentReferenceInGacTrueAllParentsInGac()
         /// Since copyLocalDependenciesWhenParentReferenceInGac is set to true and Z is not in the GAC it will be copy local true
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CopyLocalDependenciesWhenParentReferenceInGacTrueSomeParentsInGac()
         {
             // Create the engine.
@@ -355,7 +352,6 @@ public void CopyLocalDependenciesWhenParentReferenceInGacTrueSomeParentsInGac()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CopyLocalDependenciesWhenParentReferenceNotInGac()
         {
             // Create the engine.
@@ -392,7 +388,6 @@ public void CopyLocalDependenciesWhenParentReferenceNotInGac()
         /// where it was actually resolved). Sets DoNotCopyLocalIfInGac = true
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CopyLocalLegacyBehavior()
         {
             // Create the engine.
@@ -430,8 +425,6 @@ public void CopyLocalLegacyBehavior()
         /// Very basic test.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void Basic()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -661,7 +654,6 @@ private enum EmbedInteropTypes_Indices
         /// Make sure the imageruntime is correctly returned.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestGetImageRuntimeVersion()
         {
             string imageRuntimeReportedByAsssembly = this.GetType().Assembly.ImageRuntimeVersion;
@@ -1042,7 +1034,6 @@ public void SimulateCreateProjectAgainstWhidbeyWithTrailingSlash()
         /// Invalid candidate assembly files should not crash
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress286699_InvalidCandidateAssemblyFiles()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1063,7 +1054,6 @@ public void Regress286699_InvalidCandidateAssemblyFiles()
         /// Invalid assembly files should not crash
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress286699_InvalidAssemblyFiles()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1104,7 +1094,6 @@ public void Regress286699_InvalidAssembliesParameter()
         /// Target framework path with a newline should not crash.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress286699_InvalidTargetFrameworkDirectory()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -1129,7 +1118,6 @@ public void Regress286699_InvalidTargetFrameworkDirectory()
         /// Invalid search path should not crash.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress286699_InvalidSearchPath()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1200,7 +1188,6 @@ public void NonExistentReference()
         /// that we don't find a strongly named assembly.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void StrongWeakMismatchInDependency()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1247,7 +1234,6 @@ public void DependenciesOfExternallyResolvedReferencesAreNotSearched()
         /// property, then the task should be able to resolve an assembly there.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UseSuppliedHintPath()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -1303,8 +1289,7 @@ public void Regress200872()
         /// <summary>
         /// Do the most basic AssemblyFoldersEx resolve.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExBasic()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1324,8 +1309,7 @@ public void AssemblyFoldersExBasic()
         /// <summary>
         /// Verify that higher alphabetical values for a component are chosen over lower alphabetic values of a component.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExVerifyComponentFolderSorting()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1346,8 +1330,7 @@ public void AssemblyFoldersExVerifyComponentFolderSorting()
         /// If the target framework version provided by the targets file doesn't begin
         /// with the letter "v", we should tolerate it and treat it as if it does.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExTargetFrameworkVersionDoesNotBeginWithV()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1371,8 +1354,7 @@ public void AssemblyFoldersExTargetFrameworkVersionDoesNotBeginWithV()
         /// Expect it not to resolve and get a message on the console
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchDoesNotMatch()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1397,8 +1379,7 @@ public void AssemblyFoldersExProcessorArchDoesNotMatch()
         /// Target MSIL and get an assembly out of the X86 directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchMSILX86()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1420,9 +1401,7 @@ public void AssemblyFoldersExProcessorArchMSILX86()
         /// <summary>
         /// Verify if there is a mismatch between what the project targets and the architecture of the resolved primary reference log a warning.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Trait("Category", "mono-windows-failing")]
+        [WindowsOnlyFact]
         public void VerifyProcessArchitectureMismatchWarning()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1446,9 +1425,7 @@ public void VerifyProcessArchitectureMismatchWarning()
         /// <summary>
         /// Verify if there is a mismatch between what the project targets and the architecture of the resolved primary reference log a warning.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Trait("Category", "mono-windows-failing")]
+        [WindowsOnlyFact]
         public void VerifyProcessArchitectureMismatchWarningDefault()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1471,9 +1448,7 @@ public void VerifyProcessArchitectureMismatchWarningDefault()
         /// <summary>
         /// Verify if there is a mismatch between what the project targets and the architecture of the resolved primary reference log a error.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Trait("Category", "mono-windows-failing")]
+        [WindowsOnlyFact]
         public void VerifyProcessArchitectureMismatchError()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1500,8 +1475,7 @@ public void VerifyProcessArchitectureMismatchError()
         /// Target None and get an assembly out of the X86 directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneX86()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1521,8 +1495,7 @@ public void AssemblyFoldersExProcessorArchNoneX86()
         /// If we are targeting NONE and there are two assemblies with the same name then we want to pick the first one rather than look for an assembly which
         /// has a MSIL architecture or a NONE architecture. NONE means you do not care what architecture is picked.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneMix()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1550,8 +1523,7 @@ public void AssemblyFoldersExProcessorArchNoneMix()
         /// Target MSIL and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchMSILLastFolder()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1576,8 +1548,7 @@ public void AssemblyFoldersExProcessorArchMSILLastFolder()
         /// Target None and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneLastFolder()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1601,8 +1572,7 @@ public void AssemblyFoldersExProcessorArchNoneLastFolder()
         /// Target MSIL and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchX86FirstFolder()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1625,8 +1595,7 @@ public void AssemblyFoldersExProcessorArchX86FirstFolder()
         /// Target X86 and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchX86MSIL()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1648,8 +1617,7 @@ public void AssemblyFoldersExProcessorArchX86MSIL()
         /// Target X86 and get an assembly out of the None directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchX86None()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1671,8 +1639,7 @@ public void AssemblyFoldersExProcessorArchX86None()
         /// Target None and get an assembly out of the None directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneNone()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1693,8 +1660,7 @@ public void AssemblyFoldersExProcessorArchNoneNone()
         /// Target MSIL and get an assembly out of the None directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArcMSILNone()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1715,8 +1681,7 @@ public void AssemblyFoldersExProcessorArcMSILNone()
         /// Target None and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneMSIL()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1738,8 +1703,7 @@ public void AssemblyFoldersExProcessorArchNoneMSIL()
         /// Target MSIL and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchMSILMSIL()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1761,8 +1725,7 @@ public void AssemblyFoldersExProcessorArchMSILMSIL()
         /// Target X86 and get an assembly out of the X86 directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchMatches()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1786,8 +1749,7 @@ public void AssemblyFoldersExProcessorArchMatches()
         /// This means if there are remaining search paths to inspect, we should
         /// carry on and inspect those.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExTargetFrameworkVersionBogusValue()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1808,8 +1770,7 @@ public void AssemblyFoldersExTargetFrameworkVersionBogusValue()
         /// <summary>
         /// Tolerate keys like v2.0.x86chk.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void Regress357227_AssemblyFoldersExAgainstRawDrop()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1829,8 +1790,7 @@ public void Regress357227_AssemblyFoldersExAgainstRawDrop()
         /// <summary>
         /// Matches that exist only in the HKLM hive.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExHKLM()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1849,8 +1809,7 @@ public void AssemblyFoldersExHKLM()
         /// <summary>
         /// Matches that exist in both HKLM and HKCU should favor HKCU
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExHKCUTrumpsHKLM()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -1874,8 +1833,7 @@ public void AssemblyFoldersExHKCUTrumpsHKLM()
         /// <summary>
         /// When matches that have v3.0 (future) and v2.0 (current) versions, the 2.0 version wins.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExFutureTargetNDPVersionsDontMatch()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1894,8 +1852,7 @@ public void AssemblyFoldersExFutureTargetNDPVersionsDontMatch()
         /// <summary>
         /// If there is no v2.0 (current target NDP) match, then v1.0 should match.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExMatchBackVersion()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1914,8 +1871,7 @@ public void AssemblyFoldersExMatchBackVersion()
         /// <summary>
         /// If there is a 2.0 and a 1.0 then match 2.0.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExCurrentTargetVersionTrumpsPastTargetVersion()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1934,8 +1890,7 @@ public void AssemblyFoldersExCurrentTargetVersionTrumpsPastTargetVersion()
         /// <summary>
         /// If a control has a service pack then that wins over the control itself
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExServicePackTrumpsBaseVersion()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1955,8 +1910,7 @@ public void AssemblyFoldersExServicePackTrumpsBaseVersion()
         /// Conditions (OSVersion/Platform) can be passed in SearchPaths to filter the result.
         /// Test MaxOSVersion condition
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExConditionFilterMaxOS()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -1999,8 +1953,7 @@ public void AssemblyFoldersExConditionFilterMaxOS()
         /// Conditions (OSVersion/Platform) can be passed in SearchPaths to filter the result.
         /// Test MinOSVersion condition
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExConditionFilterMinOS()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -2313,8 +2266,7 @@ public void GatherVersions35x86chkDotNet()
         /// Conditions (OSVersion/Platform) can be passed in SearchPaths to filter the result.
         /// Test Platform condition
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExConditionFilterPlatform()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -2986,7 +2938,6 @@ public void ToElementButNoFrom()
         /// then try to resolve directly to that file name and make it a full path.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void RawFileNameRelative()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -3023,7 +2974,6 @@ public void RawFileNameRelative()
         /// then try to resolve the file but make sure it is a full name
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void RelativeDirectoryResolver()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -3059,7 +3009,6 @@ public void RelativeDirectoryResolver()
         /// If a relative file name is passed in through the HintPath then try to resolve directly to that file name and make it a full path.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void HintPathRelative()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -3176,7 +3125,6 @@ public void Regress363340_RawFileNameMissing()
         /// because assemblyName was null and we were comparing the assemblyName from the hintPath to the null assemblyName.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress444793()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -3206,7 +3154,6 @@ public void Regress444793()
         /// then try to resolve directly to that file name.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void RawFileNameDoesntExist()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -3286,7 +3233,6 @@ public void ResolveToGACSpecificVersion()
         /// instead we want to let the assembly be resolved normally so that the GAC and AF checks will work.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ParentAssemblyResolvedFromAForGac()
         {
             var parentReferenceFolders = new List<string>();
@@ -3402,7 +3348,6 @@ public void ResolveBadImageInPrimary()
         /// no reference. We don't want an exception.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ResolveBadImageInSecondary()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4089,7 +4034,6 @@ public void Regress199998()
         /// The user browsed to an .exe, so that's what we should give them.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ExecutableExtensionEXE()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4207,7 +4151,6 @@ public void ExecutableExtensionDefaultDLLFirst()
         /// Without an ExecutableExtension the first assembly out of .dll,.exe wins.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ExecutableExtensionDefaultEXEFirst()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4287,7 +4230,6 @@ public void SimpleNameWithSpecificVersionTrue()
         /// If specific version is false, then we should match the first "A" that we find.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SimpleNameWithSpecificVersionFalse()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4541,7 +4483,6 @@ public void Regress312873_UnresolvedPrimaryWithResolveDependency()
         ///
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress275161_ScatterAssemblies()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4594,7 +4535,6 @@ public void Regress275161_ScatterAssemblies()
         ///
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress317975_LeftoverLowerVersion()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4688,7 +4628,6 @@ public void Regress313086_Part1_MscorlibAsRawFilename()
         ///
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress313086_Part2_MscorlibAsRawFilename()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4748,7 +4687,6 @@ public void Regress284466_DirectoryIntoAssemblyFiles()
         /// If a relative assemblyFile is passed in resolve it as a full path.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void RelativeAssemblyFiles()
         {
             string testPath = Path.Combine(Path.GetTempPath(), @"RelativeAssemblyFiles");
@@ -4915,7 +4853,6 @@ public void Regress269704_MissingRegistryElements()
         /// this reference, especially given the fact that the HintPath was provided in the project file.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress276548_AssemblyNameDifferentThanFusionName()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -4986,7 +4923,6 @@ public void Regress314573_VeryLongPaths()
         /// Need to be robust in the face of assembly names with special characters.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress265003_EscapedCharactersInFusionName()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -5023,7 +4959,6 @@ public void Regress265003_EscapedCharactersInFusionName()
         /// have a hintpath, then go ahead and resolve anyway because we know what the path should be.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress284081_UnescapedCharactersInFusionNameWithHintPath()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -5199,7 +5134,6 @@ public void Regress354669_HintPathWithTrailingSlash()
         ///
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress339786_CrossVersionsWithAppConfig()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -5268,7 +5202,6 @@ public void Regress_DogfoodCLRThrowsFileLoadException()
         /// but became false when Crystal Reports started putting their assemblies in this table.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress407623_RedistListDoesNotImplyPresenceInFrameworks()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -5352,7 +5285,6 @@ public void InvalidCharsInInstalledAssemblyTable()
         ///
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress435487_FxFileResolvedByHintPathShouldByCopyLocal()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -5454,8 +5386,6 @@ public void PartialNameMatchingFromRedist()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void Regress46599_BogusInGACValueForAssemblyInRedistList()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -5507,8 +5437,6 @@ public void Regress46599_BogusInGACValueForAssemblyInRedistList()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void VerifyFrameworkFileMetadataFiles()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -6302,7 +6230,6 @@ public void SubsetListFinderNullSubsetExistsButNotXml()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void IgnoreDefaultInstalledAssemblyTables()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -7211,7 +7138,6 @@ private static void GenerateNewReferences(out Reference enginePrimaryReference,
         /// way to specify a TargetFrameworkSubset is to pass one to the InstalledAssemblySubsetTables property.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void IgnoreDefaultInstalledSubsetTables()
         {
             string redistListPath = CreateGenericRedistList();
@@ -7298,7 +7224,6 @@ private bool GenerateHelperDelegatesAndExecuteTask(ResolveAssemblyReference t, s
         /// is passed in. We expect to use that.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void NoClientSubsetButInstalledSubTables()
         {
             string redistListPath = CreateGenericRedistList();
@@ -7380,7 +7305,6 @@ public void NullFullTargetFrameworkSubsetNames()
         /// Test the case where a non existent subset list path is used and no additional subsets are passed in.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void FakeSubsetListPathsNoAdditionalSubsets()
         {
             string redistListPath = CreateGenericRedistList();
@@ -7590,7 +7514,6 @@ private bool GenerateHelperDelegatesAndExecuteTask(ResolveAssemblyReference t)
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void DoNotAssumeFilesDescribedByRedistListExistOnDisk()
         {
             string redistListPath = CreateGenericRedistList();
@@ -7776,7 +7699,6 @@ public void ByDesignRelatedTo454863_PrimaryReferencesDontResolveToParentFolders(
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress393931_AllowAlternateAssemblyExtensions_Case1()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -7808,7 +7730,6 @@ public void Regress393931_AllowAlternateAssemblyExtensions_Case1()
         /// Allow alternate extension values to be passed in.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress393931_AllowAlternateAssemblyExtensions()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -7837,7 +7758,6 @@ public void Regress393931_AllowAlternateAssemblyExtensions()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SGenDependeicies()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -7881,7 +7801,6 @@ public void SGenDependeicies()
         /// These two project references have different versions. Important: PKT is null.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Regress315619_TwoWeaklyNamedPrimariesIsInsoluble()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -7922,7 +7841,6 @@ public void Regress315619_TwoWeaklyNamedPrimariesIsInsoluble()
         ///
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ForwardRedistRoot()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -8048,7 +7966,6 @@ public void ReverseAssemblyNameExtensionComparer()
         /// Check the Filtering based on Target Framework.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TargetFrameworkFiltering()
         {
             int resultSet = RunTargetFrameworkFilteringTest("3.0");
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
index 7564fe66bff..6e875773019 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
@@ -25,8 +25,6 @@ public Perf(ITestOutputHelper output) : base(output)
         }
 
         [Theory]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         [InlineData(RARSimulationMode.LoadProject, 1)]
         [InlineData(RARSimulationMode.BuildProject, 2)]
         public void AutoUnifyUsesMinimumIO(RARSimulationMode rarSimulationMode, int ioThreshold)
diff --git a/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
index e845e40d540..1f29749f3b3 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
@@ -9,6 +9,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -35,8 +36,7 @@ public SpecificVersionPrimary(ITestOutputHelper output) : base(output)
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void Exists()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -106,7 +106,6 @@ public void Exists()
         /// </list>
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ExistsDifferentName()
         {
             // Create the engine.
@@ -159,7 +158,6 @@ public void ExistsDifferentName()
         ///     perf hit when loading large solutions.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ExistsOldVersionRange()
         {
             // Create the engine.
@@ -212,7 +210,6 @@ public void ExistsOldVersionRange()
         ///     perf hit when loading large solutions.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void HighVersionDoesntExist()
         {
             // Create the engine.
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
index 6c39feba98b..1960dba7a0b 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependency.cs
@@ -44,7 +44,6 @@ public StronglyNamedDependency(ITestOutputHelper output) : base(output)
         /// We automatically unify FX dependencies.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Exists()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
diff --git a/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs b/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
index 9df8866c63a..e7219ac8973 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
@@ -308,7 +308,6 @@ public void Regress313747_FalseSuggestedRedirectsWhenAssembliesDifferOnlyByPkt()
         /// there and there won't be a binding redirect to point it at 2.0.0.0.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void Regress442570_MissingBackVersionShouldWarn()
@@ -388,7 +387,6 @@ public void RedirectsAreSuggestedInExternallyResolvedGraph()
         /// binding redirects.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void Regress387218_UnificationRequiresStrongName()
@@ -432,7 +430,6 @@ public void Regress387218_UnificationRequiresStrongName()
         /// There should be no suggested redirect because assemblies with different cultures cannot unify.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void Regress390219_UnificationRequiresSameCulture()
diff --git a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs
index ba882c518f0..7d92fe9e630 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs
@@ -352,7 +352,6 @@ public void HigherVersionDirect()
         /// which has dependencies set to false.  A regular build or design time build has this set to true so we do the correct check.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void HigherVersionDirectDependenciesFalse()
         {
             MockEngine e = new MockEngine(_output);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs
index 99483aec16d..6435b8cddaa 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs
@@ -128,7 +128,6 @@ public void HigherThanHighestInRedistList()
         /// not warn -- this is a hack until we figure out how to properly deal with .NET assemblies being removed from the framework.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void HigherThanHighestInRedistListForMSBuildAssembly()
         {
             MockEngine e = new MockEngine(_output);
@@ -265,7 +264,6 @@ public void DependenciesHigherThanHighestInRedistList()
         /// not warn -- this is a hack until we figure out how to properly deal with .NET assemblies being removed from the framework.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void DependenciesHigherThanHighestInRedistListForMSBuildAssembly()
         {
             MockEngine e = new MockEngine(_output);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs b/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
index 84859e9d33f..285438b8181 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
@@ -18,7 +18,6 @@ namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
     /// <summary>
     /// Unit tests for the ResolveAssemblyReference task.
     /// </summary>
-    [Trait("Category", "non-mono-tests")]
     public sealed class WinMDTests : ResolveAssemblyReferenceTestFixture
     {
         public WinMDTests(ITestOutputHelper output) : base(output)
diff --git a/src/Tasks.UnitTests/AssignCulture_Tests.cs b/src/Tasks.UnitTests/AssignCulture_Tests.cs
index e6ddc3e2dd3..915bf102943 100644
--- a/src/Tasks.UnitTests/AssignCulture_Tests.cs
+++ b/src/Tasks.UnitTests/AssignCulture_Tests.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -241,8 +242,7 @@ public void SupportAliasedCultures(string culture)
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-        [Theory]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework, "These cultures are not returned via Culture api on net472.")]
+        [DotNetOnlyTheory(additionalMessage: "These cultures are not returned via Culture api on net472.")]
         [InlineData("sh-BA")]
         [InlineData("shi-MA")]
         public void AliasedCultures_SupportedOnNetCore(string culture)
@@ -260,8 +260,7 @@ public void AliasedCultures_SupportedOnNetCore(string culture)
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework, "Pseudoloc is special-cased in .NET relative to Framework.")]
+        [DotNetOnlyFact(additionalMessage: "Pseudoloc is special-cased in .NET relative to Framework.")]
         public void Pseudolocales_CaseInsensitive()
         {
             string culture = "qps-Ploc";
diff --git a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
index 899517b56d0..68ae84b67c6 100644
--- a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
+++ b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
@@ -61,7 +61,6 @@ public void InvalidItemPath()
         /// Test basic function of the AssignLinkMetadata task
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void Basic()
         {
             ITaskItem item = GetParentedTaskItem(_defaultItemSpec);
@@ -88,7 +87,6 @@ public void Basic()
         /// output any items that aren't problematic.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void InvalidItemPathWithOtherValidItem()
         {
             ITaskItem item1 = GetParentedTaskItem(itemSpec: "|||");
diff --git a/src/Tasks.UnitTests/AxImp_Tests.cs b/src/Tasks.UnitTests/AxImp_Tests.cs
index 77a7674dd7d..932661cdbbd 100644
--- a/src/Tasks.UnitTests/AxImp_Tests.cs
+++ b/src/Tasks.UnitTests/AxImp_Tests.cs
@@ -5,6 +5,7 @@
 using Microsoft.Build.Tasks;
 
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -32,7 +33,6 @@ public void ActiveXControlName()
         /// Tests that the assembly being imported is passed to the command line
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ActiveXControlNameWithSpaces()
         {
             var t = new ResolveComReference.AxImp();
@@ -70,14 +70,9 @@ public void GenerateSource()
         /// <summary>
         /// Tests the /nologo switch
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("The /nologo switch is not available on Mono.")]
         public void NoLogo()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "The /nologo switch is not available on Mono"
-            }
-
             var t = new ResolveComReference.AxImp();
 
             Assert.False(t.NoLogo); // "NoLogo should be false by default"
diff --git a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
index 9d33db3278f..da0e6a9097a 100644
--- a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
+++ b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Runtime.Hosting;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -40,14 +41,9 @@ public void DelaySign()
         /// <summary>
         /// Tests the /keycontainer: switch
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("Key container is not supported, except under Windows.")]
         public void KeyContainer()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Key container is not supported, except under Windows"
-            }
-
             var t = new ResolveComReference.TlbImp();
             t.TypeLibName = "FakeTlb.tlb";
             string badParameterValue = "badKeyContainer";
@@ -267,14 +263,9 @@ public void ToolPath()
         /// Tests that strong name sign-related parameters are validated properly, causing the task
         /// to fail if they are incorrectly set up.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("Key container is not supported, except under Windows.")]
         public void TaskFailsWhenImproperlySigned()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "Key container is not supported, except under Windows"
-            }
-
             var t = new ResolveComReference.TlbImp();
             t.TypeLibName = "Blah.tlb";
             string tempKeyContainer = null;
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
index 538e51342f3..4837636b510 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
@@ -199,7 +199,6 @@ public void RuntimeException()
         /// Verify we get an error if a the languages attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EmptyLanguage()
         {
             string projectFileContents = @"
@@ -228,7 +227,6 @@ public void EmptyLanguage()
         /// Verify we get an error if a the Type attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EmptyType()
         {
             string projectFileContents = @"
@@ -257,7 +255,6 @@ public void EmptyType()
         /// Verify we get an error if a the source attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EmptySource()
         {
             string projectFileContents = @"
@@ -286,7 +283,6 @@ public void EmptySource()
         /// Verify we get an error if a reference is missing an include attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EmptyReferenceInclude()
         {
             string projectFileContents = @"
@@ -316,7 +312,6 @@ public void EmptyReferenceInclude()
         /// Verify we get an error if a Using statement is missing an namespace attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EmptyUsingNamespace()
         {
             string projectFileContents = @"
@@ -374,7 +369,6 @@ public void ReferenceNotPath()
         /// Verify we get an error a reference has strange chars
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ReferenceInvalidChars()
         {
             string projectFileContents = @"
@@ -404,7 +398,6 @@ public void ReferenceInvalidChars()
         /// Verify we get an error if a using has invalid chars
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UsingInvalidChars()
         {
             string projectFileContents = @"
@@ -462,7 +455,6 @@ public void SourcesInvalidFile()
         /// Verify we get an error if a the code element is missing
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MissingCodeElement()
         {
             string projectFileContents = @"
@@ -683,7 +675,6 @@ public void BuildTaskSimpleCodeFactoryTestExtraReferenceCS()
         /// jscript .net works
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MethodImplementationJScriptNet()
         {
             if (!CodeDomProvider.IsDefinedLanguage("js"))
@@ -879,7 +870,6 @@ public bool Execute()
         /// Verify we get an error if a the Type attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MultipleCodeElements()
         {
             string projectFileContents = @"
@@ -911,7 +901,6 @@ public void MultipleCodeElements()
         /// Verify we get an error if a the Type attribute is set but it is empty
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ReferenceNestedInCode()
         {
             string projectFileContents = @"
@@ -945,7 +934,6 @@ public void ReferenceNestedInCode()
         /// Verify we get an error if there is an unknown element in the task tag
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UnknownElementInTask()
         {
             string projectFileContents = @"
@@ -1057,7 +1045,6 @@ public override bool Execute()
         /// See https://github.com/dotnet/msbuild/issues/328 for details.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void BuildTaskSimpleCodeFactoryTempDirectoryDoesntExist()
         {
             string projectFileContents = @"
diff --git a/src/Tasks.UnitTests/ComReference_Tests.cs b/src/Tasks.UnitTests/ComReference_Tests.cs
index 09a21f0bb38..d30c3552c9f 100644
--- a/src/Tasks.UnitTests/ComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ComReference_Tests.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -39,14 +40,9 @@ private static bool FileExistsMock(string filepath)
             return ExistingFilesDictionary.ContainsKey(filepath);
         }
 
-        [Fact]
+        [WindowsOnlyFact("COM is only found on Windows.")]
         public void TestStripTypeLibNumber()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "COM is only found on Windows"
-            }
-
             Assert.Null(ComReference.StripTypeLibNumberFromPath(null, new FileExists(FileExistsMock)));
             Assert.Equal("", ComReference.StripTypeLibNumberFromPath("", new FileExists(FileExistsMock)));
             Assert.Equal(@"C:\test\typelib1.dll", ComReference.StripTypeLibNumberFromPath(@"C:\test\typelib1.dll", new FileExists(FileExistsMock)));
diff --git a/src/Tasks.UnitTests/CombinePath_Tests.cs b/src/Tasks.UnitTests/CombinePath_Tests.cs
index cee148bb2c5..a719717e07e 100644
--- a/src/Tasks.UnitTests/CombinePath_Tests.cs
+++ b/src/Tasks.UnitTests/CombinePath_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -203,9 +204,7 @@ public void BlankPath()
         /// <summary>
         /// Specified paths contain invalid characters.  Task should continue processing remaining items.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // No invalid characters on Unix
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No invalid characters on Unix.")]
         public void InvalidPath()
         {
             CombinePath t = new CombinePath();
diff --git a/src/Tasks.UnitTests/CommandLineGenerator_Tests.cs b/src/Tasks.UnitTests/CommandLineGenerator_Tests.cs
index 3e7b7c32d9d..e359b2c289b 100644
--- a/src/Tasks.UnitTests/CommandLineGenerator_Tests.cs
+++ b/src/Tasks.UnitTests/CommandLineGenerator_Tests.cs
@@ -98,8 +98,6 @@ public sealed class CommandLineGenerator_Tests
         /// Tests a command line generated from all of the specified switch values.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void BasicCommandLine()
         {
             CommandLineGenerator generator = CreateGenerator();
@@ -111,8 +109,6 @@ public void BasicCommandLine()
         /// Tests a command line generated from a specific template
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void TemplatedCommandLine()
         {
             CommandLineGenerator generator = CreateGenerator();
@@ -125,8 +121,6 @@ public void TemplatedCommandLine()
         /// Tests a command line generated from a specific template is not case sensitive on the parameter names.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void TemplateParametersAreCaseInsensitive()
         {
             CommandLineGenerator generator = CreateGenerator();
diff --git a/src/Tasks.UnitTests/ConvertToAbsolutePath_Tests.cs b/src/Tasks.UnitTests/ConvertToAbsolutePath_Tests.cs
index 73c43d16a92..fd15e069f96 100644
--- a/src/Tasks.UnitTests/ConvertToAbsolutePath_Tests.cs
+++ b/src/Tasks.UnitTests/ConvertToAbsolutePath_Tests.cs
@@ -20,7 +20,6 @@ public sealed class ConvertToAbsolutePath_Tests
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void RelativePath()
         {
             string fileName = ObjectModelHelpers.CreateFileInTempProjectDirectory("file.temp", "foo");
@@ -53,7 +52,6 @@ public void RelativePath()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void RelativePathWithEscaping()
         {
             string fileName = ObjectModelHelpers.CreateFileInTempProjectDirectory("file%3A.temp", "foo");
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 49a635d1385..eac251335ed 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -19,6 +19,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -131,7 +132,6 @@ public void DontCopyOverSameFile()
         /// Unless ignore readonly attributes is set, we should not copy over readonly files.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void DoNotNormallyCopyOverReadOnlyFile()
@@ -194,7 +194,6 @@ public void DoNotNormallyCopyOverReadOnlyFile()
         /// OverwriteReadOnlyFiles is false
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void CopyOverReadOnlyFileEnvironmentOverride()
@@ -260,7 +259,6 @@ public void CopyOverReadOnlyFileEnvironmentOverride()
         /// If MSBUILDALWAYSRETRY is set, keep retrying the copy.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void AlwaysRetryCopyEnvironmentOverride()
@@ -332,7 +330,6 @@ public void AlwaysRetryCopyEnvironmentOverride()
         /// Unless ignore readonly attributes is set, we should not copy over readonly files.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void CopyOverReadOnlyFileParameterIsSet()
@@ -651,16 +648,9 @@ public void DoCopyOverNonExistentFile()
         /// <summary>
         /// Make sure we do not retry when the source file has a misplaced colon
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Colon is special only on Windows.")]
         public void DoNotRetryCopyNotSupportedException()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                // Colon is special only on Windows
-                return;
-            }
-
             string sourceFile = FileUtilities.GetTemporaryFile();
             string destinationFile = "foobar:";
 
@@ -790,7 +780,6 @@ public void DoNotRetryCopyWhenSourceIsFolder()
         /// Most important case is when destination is locked
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void DoRetryWhenDestinationLocked()
@@ -1019,9 +1008,7 @@ internal class CopyMonitor
         /// CopiedFiles should only include files that were successfully copied
         /// (or skipped), not files for which there was an error.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "Under Unix all filenames are valid and this test is not useful"
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. Under Unix all filenames are valid and this test is not useful.")]
         public void OutputsOnlyIncludeSuccessfulCopies()
         {
             string temp = Path.GetTempPath();
@@ -1177,8 +1164,7 @@ public void CopyFileOnItself()
         /// Copying a file on top of itself should be a success (no-op) whether
         /// or not skipUnchangedFiles is true or false. Variation with different casing/relativeness.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "File names under Unix are case-sensitive and this test is not useful"
+        [WindowsOnlyFact(additionalMessage: "File names under Unix are case-sensitive and this test is not useful.")]
         public void CopyFileOnItself2()
         {
             string currdir = Directory.GetCurrentDirectory();
@@ -1229,7 +1215,6 @@ public void CopyFileOnItself2()
         /// or not skipUnchangedFiles is true or false. Variation with a second copy failure.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void CopyFileOnItselfAndFailACopy()
@@ -1613,8 +1598,7 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
         /// If the destination path is too long, the task should not bubble up
         /// the System.IO.PathTooLongException
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
@@ -1657,8 +1641,7 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
         /// If the source path is too long, the task should not bubble up
         /// the System.IO.PathTooLongException
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
         {
             const string sourceFile = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
@@ -1936,7 +1919,6 @@ public void TooFewRetriesThrows()
             engine.AssertLogContains("MSB3027");
         }
 
-        [PlatformSpecific(TestPlatforms.Windows)]
         internal virtual void ErrorIfLinkFailedCheck()
         {
             using (var env = TestEnvironment.Create())
@@ -2189,8 +2171,7 @@ public void CopyToDestinationFolderWithHardLinkCheck()
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // SMB share paths only work on Windows
+        [WindowsOnlyFact(additionalMessage: "SMB share paths only work on Windows.")]
         public void CopyToDestinationFolderWithHardLinkFallbackNetwork()
         {
             // Workaround: For some reason when this test runs with all other tests we are getting
@@ -2295,8 +2276,7 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // Only Windows has a (small) link limit, and this tests for an HRESULT
+        [WindowsOnlyFact(additionalMessage: "Only Windows has a (small) link limit, and this tests for an HRESULT.")]
         public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
         {
             // Workaround: For some reason when this test runs with all other tests we are getting
@@ -2382,7 +2362,7 @@ public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
             }
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         internal override void ErrorIfLinkFailedCheck()
         {
             base.ErrorIfLinkFailedCheck();
@@ -2463,7 +2443,7 @@ public void CopyToDestinationFolderWithSymbolicLinkCheck()
             }
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         internal override void ErrorIfLinkFailedCheck()
         {
             base.ErrorIfLinkFailedCheck();
diff --git a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
index 25daf87a34e..ab9c9fbc182 100644
--- a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
@@ -56,7 +56,6 @@ public void Basic()
 #else
         [Fact]
 #endif
-        [Trait("Category", "mono-osx-failing")]
         public void Regress172107()
         {
             // Can't embed the 'Ã' directly because the string is Unicode already and the Unicode<-->ANSI transform
@@ -102,7 +101,6 @@ public void Regress172107()
 #else
         [Fact]
 #endif
-        [Trait("Category", "mono-osx-failing")]
         public void Regress249540()
         {
             // Special character is 'Ä' in UTF8: 0xC3 84
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index 44ac891a76d..c9edcec199b 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -13,6 +13,7 @@
 using Xunit;
 using Xunit.Abstractions;
 using Shouldly;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -313,8 +314,7 @@ public void WildcardDriveEnumerationTaskItemLogsError(string itemSpec)
         /// Logs warning when encountering wildcard drive enumeration during task item creation on Windows platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(@"z:\**")]
         [InlineData(@"z:\**\*.log")]
         [InlineData(@"z:\\\\**\*.log")]
@@ -327,8 +327,7 @@ public void LogWindowsWarningUponCreateItemExecution(string itemSpec)
         /// Logs warning when encountering wildcard drive enumeration during task item creation on Unix platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(@"\**")]
         [InlineData(@"\**\*.log")]
         public void LogUnixWarningUponCreateItemExecution(string itemSpec)
@@ -393,8 +392,7 @@ public void ThrowExceptionUponItemCreationWithDriveEnumeration(string content, s
         /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Windows platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(
             CreateItemWithInclude,
             @"z:\**")]
@@ -421,8 +419,7 @@ public void LogWindowsWarningUponItemCreationWithDriveEnumeration(string content
         /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Unix platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(
             CreateItemWithInclude,
             @"\**")]
diff --git a/src/Tasks.UnitTests/Delete_Tests.cs b/src/Tasks.UnitTests/Delete_Tests.cs
index b752d309728..d404c63246f 100644
--- a/src/Tasks.UnitTests/Delete_Tests.cs
+++ b/src/Tasks.UnitTests/Delete_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -41,8 +42,7 @@ public void AttributeForwarding()
         /// <summary>
         /// Retry Delete. Specify windows since readonly not working on others
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void DeleteWithRetries()
         {
             string source = FileUtilities.GetTemporaryFile();
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 5c78ff468a7..52e2c3e4bcf 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -15,6 +15,7 @@
 using Xunit.Abstractions;
 using System.Collections.Generic;
 using Microsoft.Build.Evaluation;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -51,7 +52,6 @@ private ExecWrapper PrepareExecWrapper(string command)
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void EscapeSpecifiedCharactersInPathToGeneratedBatchFile()
@@ -74,7 +74,6 @@ public void EscapeSpecifiedCharactersInPathToGeneratedBatchFile()
         /// lying around.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void NoTempFileLeaks()
         {
             using (var testEnvironment = TestEnvironment.Create())
@@ -168,8 +167,7 @@ public void TimeoutFailsEvenWhenExitCodeIsIgnored()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void WindowsNewLineCharactersInCommandOnUnix()
         {
             var exec = PrepareExec("echo hello\r\n\r\n");
@@ -246,8 +244,7 @@ public void NonUNCWorkingDirectoryUsed()
             ((MockEngine)exec.BuildEngine).AssertLogContains("[" + working + "]");
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]   // UNC is Windows-Only
+        [WindowsOnlyFact(additionalMessage: "UNC is Windows-Only.")]
         public void UNCWorkingDirectoryUsed()
         {
             Exec exec = PrepareExec("echo [%cd%]");
@@ -475,10 +472,9 @@ public void ExecTaskUtf8AlwaysWithAnsi()
         /// Exec task will NOT use UTF8 when UTF8 Never is specified and non-ANSI characters are in the Command
         /// <remarks>Exec task will fail as the cmd processor will not be able to run the command.</remarks>
         /// </summary>
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData("Never")]
         [InlineData("System")]
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void ExecTaskUtf8NeverWithNonAnsi(string useUtf8)
         {
             RunExec(true, EncodingUtilities.CurrentSystemOemEncoding.EncodingName, useUtf8, false);
@@ -903,8 +899,7 @@ public void ConsoleToMSBuild()
         /// Test the CanEncode method with and without ANSI characters to determine if they can be encoded 
         /// in the current system encoding.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void CanEncodeTest()
         {
             var defaultEncoding = EncodingUtilities.CurrentSystemOemEncoding;
@@ -968,7 +963,6 @@ echo line 3"" />
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void EndToEndMultilineExec_EscapeSpecialCharacters()
diff --git a/src/Tasks.UnitTests/FileStateTests.cs b/src/Tasks.UnitTests/FileStateTests.cs
index da2d3ab4266..1048fc95358 100644
--- a/src/Tasks.UnitTests/FileStateTests.cs
+++ b/src/Tasks.UnitTests/FileStateTests.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -36,17 +37,14 @@ public void BadTooLongCtorOK()
             new FileState(new String('x', 5000));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // On Unix there no invalid file name characters
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. On Unix there is no invalid file name characters.")]
         public void BadChars()
         {
             var state = new FileState("|");
             Assert.Throws<ArgumentException>(() => { var time = state.LastWriteTime; });
         }
 
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsMaxPathLegacyWindows))]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [LongPathSupportDisabledFact]
         public void BadTooLongLastWriteTime()
         {
             Helpers.VerifyAssertThrowsSameWay(
@@ -229,7 +227,6 @@ public void NameReset()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void LastWriteTimeReset()
         {
             string file = null;
@@ -256,7 +253,6 @@ public void LastWriteTimeReset()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void LastWriteTimeUtcReset()
         {
             string file = null;
@@ -285,7 +281,6 @@ public void LastWriteTimeUtcReset()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void LengthReset()
         {
             string file = null;
@@ -341,7 +336,6 @@ public void ExistsButDirectory()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ReadOnlyOnDirectory()
         {
             Assert.Equal(new FileInfo(Path.GetTempPath()).IsReadOnly, new FileState(Path.GetTempPath()).IsReadOnly);
diff --git a/src/Tasks.UnitTests/FindUnderPath_Tests.cs b/src/Tasks.UnitTests/FindUnderPath_Tests.cs
index 62cba40c5fd..ce0be31a183 100644
--- a/src/Tasks.UnitTests/FindUnderPath_Tests.cs
+++ b/src/Tasks.UnitTests/FindUnderPath_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 
 
@@ -35,9 +36,7 @@ public void BasicFilter()
             Assert.Equal(FileUtilities.FixFilePath(@"C:\SomeoneElsesProject\File2.txt"), t.OutOfPath[0].ItemSpec);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // On Unix there no invalid file name characters
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. On Unix there is no invalid file name characters.")]
         public void InvalidFile()
         {
             FindUnderPath t = new FindUnderPath();
@@ -53,9 +52,7 @@ public void InvalidFile()
             // Don't crash
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // On Unix there no invalid file name characters
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. On Unix there is no invalid file name characters.")]
         public void InvalidPath()
         {
             FindUnderPath t = new FindUnderPath();
@@ -97,7 +94,6 @@ private static void RunTask(FindUnderPath t, out FileInfo testFile, out bool suc
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyFullPath()
         {
             FindUnderPath t = new FindUnderPath();
@@ -120,7 +116,6 @@ public void VerifyFullPath()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyFullPathNegative()
         {
             FindUnderPath t = new FindUnderPath();
diff --git a/src/Tasks.UnitTests/FormatUrl_Tests.cs b/src/Tasks.UnitTests/FormatUrl_Tests.cs
index de622591d23..5260d22e642 100644
--- a/src/Tasks.UnitTests/FormatUrl_Tests.cs
+++ b/src/Tasks.UnitTests/FormatUrl_Tests.cs
@@ -7,6 +7,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -66,8 +67,7 @@ public void NoInputTest()
         /// From the documentation, Path.GetFullPath(" ") should throw an ArgumentException, but it doesn't on macOS and Linux
         /// where whitespace characters are valid characters for filenames.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void WhitespaceTestOnUnix()
         {
             var t = new FormatUrl();
@@ -81,8 +81,7 @@ public void WhitespaceTestOnUnix()
         /// <summary>
         /// The URL to format is white space.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void WhitespaceTestOnWindows()
         {
             var t = new FormatUrl();
@@ -139,8 +138,7 @@ public void LocalRelativePathTest()
         /// <summary>
         /// The URL to format is a *nix-style (macOS, Linux) local absolute file path.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void LocalUnixAbsolutePathTest()
         {
             var t = new FormatUrl();
@@ -154,8 +152,7 @@ public void LocalUnixAbsolutePathTest()
         /// <summary>
         /// The URL to format is a Windows-style local absolute file path.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void LocalWindowsAbsolutePathTest()
         {
             var t = new FormatUrl();
diff --git a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
index fc0e1104856..8f07ce0c623 100644
--- a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
+++ b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
@@ -42,7 +42,6 @@ public void Dispose()
         /// - The only goal for <see cref="GenerateBindingRedirects"/> task is to add specified redirects to the output app.config.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TargetAppConfigShouldContainsBindingRedirects()
         {
             // Arrange
@@ -68,7 +67,6 @@ public void TargetAppConfigShouldContainsBindingRedirects()
         /// - The only goal for <see cref="GenerateBindingRedirects"/> task is to add specified redirects to the output app.config.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TargetAppConfigShouldContainsBindingRedirectsFromAppConfig()
         {
             // Arrange
@@ -103,7 +101,6 @@ public void TargetAppConfigShouldContainsBindingRedirectsFromAppConfig()
         ///   should respect that.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GenerateBindingRedirectsFromTwoDependentAssemblySections()
         {
             // Arrange
@@ -163,7 +160,6 @@ public void GenerateBindingRedirectsFromTwoDependentAssemblySections()
         ///   But due to MSDN documentation, dependentAssembly could have only probing element without any other elements inside.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void AppConfigWithProbingPathAndWithoutDependentAssemblyShouldNotProduceWarningsBug1161241()
         {
             // Arrange
@@ -191,7 +187,6 @@ public void AppConfigWithProbingPathAndWithoutDependentAssemblyShouldNotProduceW
         ///   But due to MSDN documentation, dependentAssembly could have only probing element without any other elements inside.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void AppConfigWithEmptyAssemblyBindingShouldNotProduceWarnings()
         {
             // Arrange
@@ -217,7 +212,6 @@ public void AppConfigWithEmptyAssemblyBindingShouldNotProduceWarnings()
         /// - Due to app.config xsd schema this is a valid configuration.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void DependentAssemblySectionWithoutBindingRedirectShouldNotProduceWarnings()
         {
             // Arrange
diff --git a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
index 0763674cfd8..f4c311c11ce 100644
--- a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
+++ b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Shared;
 using Xunit;
 using Microsoft.Build.Tasks;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -148,8 +149,7 @@ private static string MakeFakeSDKStructure2()
 
     /// <summary>
     /// Test the GetInstalledSDKLocations task
-    /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
+    /// </summary>W
     public class GetInstalledSDKLocationsTestFixture : IClassFixture<FakeSDKStructure>
     {
         private readonly string _fakeSDKStructureRoot;
@@ -165,7 +165,7 @@ public GetInstalledSDKLocationsTestFixture(FakeSDKStructure fakeSDKStructure)
         /// <summary>
         /// Make sure we get a ArgumentException if null is passed into the target platform version.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NullTargetPlatformVersion()
         {
             Assert.Throws<ArgumentNullException>(() =>
@@ -179,7 +179,7 @@ public void NullTargetPlatformVersion()
         /// <summary>
         /// Make sure we get a ArgumentException if null is passed into the target platform version.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NullTargetPlatformIdentifier()
         {
             Assert.Throws<ArgumentNullException>(() =>
@@ -193,7 +193,7 @@ public void NullTargetPlatformIdentifier()
         /// <summary>
         /// Make sure we get an error message if an empty platform identifier is passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptyTargetPlatformIdentifier()
         {
             MockEngine engine = new MockEngine();
@@ -211,7 +211,7 @@ public void EmptyTargetPlatformIdentifier()
         /// <summary>
         /// Make sure we get an error message if an empty platform Version is passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptyTargetPlatformVersion()
         {
             MockEngine engine = new MockEngine();
@@ -230,7 +230,7 @@ public void EmptyTargetPlatformVersion()
         /// <summary>
         /// Make sure we get an error message if an empty platform Version is passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BadTargetPlatformVersion()
         {
             MockEngine engine = new MockEngine();
@@ -249,7 +249,7 @@ public void BadTargetPlatformVersion()
         /// <summary>
         /// Make sure we get an Warning if no SDKs were found.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NoSDKsFound()
         {
             MockEngine engine = new MockEngine();
@@ -267,7 +267,7 @@ public void NoSDKsFound()
         /// <summary>
         /// Get a good set of SDKS installed on the machine from the fake SDK location.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetSDKVersions()
         {
             try
@@ -314,7 +314,7 @@ public void GetSDKVersions()
         /// <summary>
         /// Get a good set of SDKS installed on the machine from the fake SDK location.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetGoodSDKs()
         {
             try
@@ -388,7 +388,7 @@ public void GetGoodSDKs()
         /// <summary>
         /// Get a good set of SDKS installed on the machine from the fake SDK location.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetGoodSDKs2()
         {
             try
diff --git a/src/Tasks.UnitTests/GetSDKReference_Tests.cs b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
index cd5316b3e03..851300230cd 100644
--- a/src/Tasks.UnitTests/GetSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
@@ -14,6 +13,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -180,7 +180,6 @@ private static string CreateFakeSDKReferenceAssemblyDirectory2(out string sdkDir
     /// <summary>
     /// Test the expansion of sdk reference assemblies.
     /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class GetSDKReferenceFilesTestFixture : IDisposable, IClassFixture<FakeSdkStructure>
     {
         private readonly ITestOutputHelper _output;
@@ -223,7 +222,7 @@ public void Dispose()
         /// <summary>
         /// Make sure there are no outputs if no resolved sdk files are passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PassReferenceWithNoReferenceDirectory()
         {
             var engine = new MockEngine(_output);
@@ -253,8 +252,7 @@ public void PassReferenceWithNoReferenceDirectory()
         /// <summary>
         /// Make sure we get the correct folder list when asking for it.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void GetSDKReferenceFolders()
         {
             var getReferenceFolders = new GetSDKFolders(ToolLocationHelper.GetSDKReferenceFolders);
@@ -263,7 +261,7 @@ public void GetSDKReferenceFolders()
             VerifySDKFolders(getReferenceFolders, getReferenceFolders2, "References", _sdkDirectory);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyGetSdkReferenceTranslator()
         {
             Dictionary<string, GetSDKReferenceFiles.SdkReferenceInfo> pathToReferenceMetadata = new();
@@ -321,8 +319,7 @@ private static void VerifySDKFolders(GetSDKFolders singleParamDelegate, GetSDKFo
         /// <summary>
         /// Make sure we get the correct folder list when asking for it.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void GetSDKRedistFolders()
         {
             var getRedistFolders = new GetSDKFolders(ToolLocationHelper.GetSDKRedistFolders);
@@ -334,8 +331,7 @@ public void GetSDKRedistFolders()
         /// <summary>
         /// Make sure we get the correct folder list when asking for it.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void GetSDKDesignTimeFolders()
         {
             var getDesignTimeFolders = new GetSDKFolders(ToolLocationHelper.GetSDKDesignTimeFolders);
@@ -347,7 +343,7 @@ public void GetSDKDesignTimeFolders()
         /// <summary>
         /// Make sure there are no outputs if an sdk which does not exist is passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PassNoSDKReferences()
         {
             var engine = new MockEngine(_output);
@@ -365,7 +361,7 @@ public void PassNoSDKReferences()
         /// <summary>
         /// Make sure there are no outputs if expand sdks is not true.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PassReferenceWithExpandFalse()
         {
             var engine = new MockEngine(_output);
@@ -390,7 +386,7 @@ public void PassReferenceWithExpandFalse()
         /// <summary>
         /// Make sure there are no redist outputs if CopyRedist is false
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PassReferenceWithCopyRedistFalse()
         {
             var engine = new MockEngine(_output);
@@ -416,8 +412,7 @@ public void PassReferenceWithCopyRedistFalse()
         /// <summary>
         /// Verify we get the correct set of reference assemblies and copy local files when the CopyLocal flag is true
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void GetReferenceAssembliesWhenExpandTrueCopyLocalTrue()
         {
             var engine = new MockEngine(_output);
@@ -482,8 +477,7 @@ public void GetReferenceAssembliesWhenExpandTrueCopyLocalTrue()
         /// <summary>
         /// Verify reference is not processed by GetSDKReferenceFiles when "ReferenceOnly" metadata is set.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyNoCopyWhenReferenceOnlyIsTrue()
         {
             var engine = new MockEngine(_output);
@@ -539,9 +533,7 @@ public void VerifyNoCopyWhenReferenceOnlyIsTrue()
         /// <summary>
         /// Verify we get the correct set of reference assemblies and copy local files when the CopyLocal flag is false
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
+        [WindowsOnlyFact]
         public void GetReferenceAssembliesWhenExpandTrueCopyLocalFalse()
         {
             var engine = new MockEngine(_output);
@@ -596,7 +588,7 @@ public void GetReferenceAssembliesWhenExpandTrueCopyLocalFalse()
         /// Verify that different cache files are created and used correctly for assemblies with the same identity but with files in different directories
         /// Also verifies that when
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyCacheFileNames()
         {
             var engine = new MockEngine(_output);
@@ -662,8 +654,7 @@ public void VerifyCacheFileNames()
         /// Verify the correct reference files are found and that by default we do log the reference files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyReferencesLogged()
         {
             var engine = new MockEngine(_output);
@@ -711,8 +702,7 @@ public void VerifyReferencesLogged()
         /// Verify the correct reference files are found and that by default we do log the reference files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyReferencesLoggedFilterOutWinmd()
         {
             var engine = new MockEngine(_output);
@@ -757,8 +747,7 @@ public void VerifyReferencesLoggedFilterOutWinmd()
         /// <summary>
         /// Verify we log an error if no configuration is on the sdk reference
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogErrorWhenNoConfiguration()
         {
             var engine = new MockEngine(_output);
@@ -781,8 +770,7 @@ public void LogErrorWhenNoConfiguration()
         /// <summary>
         /// Verify we log an error if no configuration is on the sdk reference
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogErrorWhenNoArchitecture()
         {
             var engine = new MockEngine(_output);
@@ -807,8 +795,7 @@ public void LogErrorWhenNoArchitecture()
         /// Verify the correct reference files are found and that by default we do log the reference files
         /// added.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyReferencesLoggedAmd64()
         {
             var engine = new MockEngine(_output);
@@ -859,8 +846,7 @@ public void VerifyReferencesLoggedAmd64()
         /// Verify the correct reference files are found and that by default we do log the reference files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyReferencesLoggedX64()
         {
             var engine = new MockEngine(_output);
@@ -911,8 +897,7 @@ public void VerifyReferencesLoggedX64()
         /// <summary>
         /// Verify the correct reference files are found and that if we do not want to log them we can set a property to do so.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyLogReferencesFalse()
         {
             var engine = new MockEngine(_output);
@@ -947,8 +932,7 @@ public void VerifyLogReferencesFalse()
         /// Verify the correct redist files are found and that by default we do not log the redist files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyRedistFilesLogRedistFalse()
         {
             var engine = new MockEngine(_output);
@@ -1013,8 +997,7 @@ public void VerifyRedistFilesLogRedistFalse()
         /// Verify the correct redist files are found and that by default we do not log the redist files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyRedistFilesLogRedistTrue()
         {
             var engine = new MockEngine(_output);
@@ -1045,8 +1028,7 @@ public void VerifyRedistFilesLogRedistTrue()
         /// Verify the correct redist files are found and that by default we do not log the redist files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyRedistFilesLogRedistTrueX64()
         {
             var engine = new MockEngine(_output);
@@ -1078,8 +1060,7 @@ public void VerifyRedistFilesLogRedistTrueX64()
         /// Verify the correct redist files are found and that by default we do not log the redist files
         /// added.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void VerifyRedistFilesLogRedistTrueAmd64()
         {
             var engine = new MockEngine(_output);
@@ -1110,8 +1091,7 @@ public void VerifyRedistFilesLogRedistTrueAmd64()
         /// <summary>
         /// Make sure by default conflicts between references are logged as a comment if they are within the sdk itself
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogNoWarningForReferenceConflictWithinSDK()
         {
             var engine = new MockEngine(_output);
@@ -1139,8 +1119,7 @@ public void LogNoWarningForReferenceConflictWithinSDK()
         /// <summary>
         /// Make sure that if the LogReferenceConflictsWithinSDKAsWarning is set log a warning for conflicts within an SDK for references.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogWarningForReferenceConflictWithinSDK()
         {
             var engine = new MockEngine(_output);
@@ -1169,8 +1148,7 @@ public void LogWarningForReferenceConflictWithinSDK()
         /// <summary>
         /// Make sure by default conflicts between references are logged as a comment if they are within the sdk itself
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogNoWarningForRedistConflictWithinSDK()
         {
             var engine = new MockEngine(_output);
@@ -1197,8 +1175,7 @@ public void LogNoWarningForRedistConflictWithinSDK()
         /// <summary>
         /// Make sure that if the LogRedistConflictsWithinSDKAsWarning is set log a warning for conflicts within an SDK for redist files.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogWarningForRedistConflictWithinSDK()
         {
             var engine = new MockEngine(_output);
@@ -1226,8 +1203,7 @@ public void LogWarningForRedistConflictWithinSDK()
         /// <summary>
         /// Verify if there are conflicts between references or redist files between sdks that we log a warning by default.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogReferenceAndRedistConflictBetweenSdks()
         {
             var engine = new MockEngine(_output);
@@ -1272,8 +1248,7 @@ public void LogReferenceAndRedistConflictBetweenSdks()
         /// <summary>
         /// If a user create a target path that causes a conflict between two sdks then we want to warn
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogReferenceAndRedistConflictBetweenSdksDueToCustomTargetPath()
         {
             var engine = new MockEngine(_output);
@@ -1315,8 +1290,7 @@ public void LogReferenceAndRedistConflictBetweenSdksDueToCustomTargetPath()
         /// <summary>
         /// Verify if there are conflicts between references or redist files between sdks that we do not log a warning if a certain property (LogxxxConflictBetweenSDKsAsWarning is set to false.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void LogReferenceAndRedistConflictBetweenSdksNowarning()
         {
             var engine = new MockEngine(_output);
@@ -1362,8 +1336,7 @@ public void LogReferenceAndRedistConflictBetweenSdksNowarning()
         /// <summary>
         /// If there are conflicting redist files between two sdks but their target paths are different then we should copy both to the appx
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void TwoSDKSConflictRedistButDifferentTargetPaths()
         {
             var engine = new MockEngine(_output);
diff --git a/src/Tasks.UnitTests/HintPathResolver_Tests.cs b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
index eb80da45cf8..a62b711cf18 100644
--- a/src/Tasks.UnitTests/HintPathResolver_Tests.cs
+++ b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
@@ -8,6 +8,7 @@
 using System.Collections.Generic;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -36,8 +37,7 @@ public void CanResolveHintPath()
             result.ShouldBe(true);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void CanResolveLongNonNormalizedHintPath()
         {
             var tempfolder = _env.DefaultTestDirectory.CreateDirectory("tempfolder_for_CanResolveLongHintPath");
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index eb267ef08e7..f8dcf89bbfe 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -391,7 +391,6 @@ public void LogErrorWhenBuildingVCProj()
 #else
         [Fact]
 #endif
-        [Trait("Category", "mono-osx-failing")]
         public void PropertyOverridesContainSemicolon()
         {
             ObjectModelHelpers.DeleteTempProjectDirectory();
diff --git a/src/Tasks.UnitTests/MakeDir_Tests.cs b/src/Tasks.UnitTests/MakeDir_Tests.cs
index b05bd654604..2eb1c473196 100644
--- a/src/Tasks.UnitTests/MakeDir_Tests.cs
+++ b/src/Tasks.UnitTests/MakeDir_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -59,8 +60,7 @@ public void AttributeForwarding()
         /// Check that if we fail to create a folder, we don't pass
         /// through the input.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "Under Unix all filenames are valid and this test is not useful"
+        [WindowsOnlyFact(additionalMessage: "Under Unix all filenames are valid and this test is not useful.")]
         public void SomeInputsFailToCreate()
         {
             string temp = Path.GetTempPath();
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 3acd8c56824..e8e1b49e6ba 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -57,7 +57,12 @@
       <Link>TestEnvironment.cs</Link>
     </Compile>
     <Compile Include="..\Shared\ProcessExtensions.cs" />
+    <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
+    
+    <Compile Include="..\Shared\UnitTests\LongPathSupportDisabledFactAttribute.cs">
+      <Link>Shared\LongPathSupportDisabledFactAttribute.cs</Link>
+    </Compile>
 
     <EmbeddedResource Include="SampleResx" />
     <EmbeddedResource Include="AssemblyDependency\CacheFileSamples\Microsoft.VisualStudio.LanguageServices.Implementation.csprojAssemblyReference.cache" />
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index d76e34bd350..eff307187e2 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -413,8 +414,7 @@ public void MoveOverExistingFileOverwriteReadOnlyOverWriteReadOnlyFilesTrue()
         /// MovedFiles should only include files that were successfully moved 
         /// (or skipped), not files for which there was an error.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "Under Unix all filenames are valid and this test is not useful"
+        [WindowsOnlyFact(additionalMessage: "Under Unix all filenames are valid and this test is not useful.")]
         public void OutputsOnlyIncludeSuccessfulMoves()
         {
             string temp = Path.GetTempPath();
@@ -493,8 +493,7 @@ public void OutputsOnlyIncludeSuccessfulMoves()
         /// <summary>
         /// Moving a locked file will fail
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "File locking Unix differs significantly from Windows"
+        [WindowsOnlyFact(additionalMessage: "File locking Unix differs significantly from Windows.")]
         public void MoveLockedFile()
         {
             string file = null;
@@ -588,8 +587,7 @@ public void SourceFileIsDirectory()
         /// Moving a file on top of itself should be a success (no-op).
         /// Variation with different casing/relativeness.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "File names under Unix are case-sensitive and this test is not useful"
+        [WindowsOnlyFact(additionalMessage: "File names under Unix are case-sensitive and this test is not useful.")]
         public void MoveFileOnItself2()
         {
             string currdir = Directory.GetCurrentDirectory();
@@ -781,8 +779,7 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
         /// If the destination path is too long, the task should not bubble up
         /// the System.IO.PathTooLongException 
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
@@ -818,8 +815,7 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
         /// If the source path is too long, the task should not bubble up
         /// the System.IO.PathTooLongException 
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
         {
             string sourceFile = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
diff --git a/src/Tasks.UnitTests/OutputPathTests.cs b/src/Tasks.UnitTests/OutputPathTests.cs
index ddfd43951b7..af1d3902804 100644
--- a/src/Tasks.UnitTests/OutputPathTests.cs
+++ b/src/Tasks.UnitTests/OutputPathTests.cs
@@ -12,6 +12,7 @@
 
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -151,7 +152,7 @@ public void BothBaseOutputPathAndOutputPathWereSpecified()
         /// <summary>
         /// Test for [MSBuild]::NormalizePath and [MSBuild]::NormalizeDirectory returning current directory instead of current Project directory.
         /// </summary>
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsWindows), Skip = "Skipping this test for now until we have a consensus about this issue.")]
+        [WindowsOnlyFact(Skip = "Skipping this test for now until we have a consensus about this issue.")]
         public void MSBuildNormalizePathShouldReturnProjectDirectory()
         {
             // Arrange
diff --git a/src/Tasks.UnitTests/PortableTasks_Tests.cs b/src/Tasks.UnitTests/PortableTasks_Tests.cs
index 38457261232..e409d1f61bd 100644
--- a/src/Tasks.UnitTests/PortableTasks_Tests.cs
+++ b/src/Tasks.UnitTests/PortableTasks_Tests.cs
@@ -9,6 +9,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -29,9 +30,7 @@ public PortableTasks_Tests(ITestOutputHelper outputHelper)
             _outputHelper = outputHelper;
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "No Visual Studio install for .NET.")]
         public void TestDesktopMSBuildShouldRunPortableTask()
         {
             RunMSBuildOnProjectWithPortableTaskAndAssertOutput(true);
diff --git a/src/Tasks.UnitTests/RegressionTests.cs b/src/Tasks.UnitTests/RegressionTests.cs
index 6ca6b081557..a92f5e148dc 100644
--- a/src/Tasks.UnitTests/RegressionTests.cs
+++ b/src/Tasks.UnitTests/RegressionTests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.UnitTests;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -51,7 +52,7 @@ public void OverrideBaseIntermediateOutputPathSucceeds()
         /// <summary>
         /// Tests fix for https://github.com/dotnet/msbuild/issues/1479.
         /// </summary>
-        [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsWindows))]
+        [WindowsOnlyFact]
         public void AssemblyAttributesLocation()
         {
             var expectedCompileItems = "a.cs;" + Path.Combine("obj", "Debug", ".NETFramework,Version=v4.8.AssemblyAttributes.cs");
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 0768fb9ea36..afc8048fea0 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -475,7 +475,6 @@ public void DelaySignWithoutEitherKeyFileOrKeyContainer()
         /// Test if assemblies located in the gac get their CopyLocal attribute set to False
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CheckSetCopyLocalToFalseOnEmbedInteropTypesAssemblies()
         {
             string gacPath = @"C:\windows\gac";
@@ -564,7 +563,6 @@ public void CheckSetCopyLocalToFalseOnEmbedInteropTypesAssemblies()
         /// Test if assemblies located in the gac get their CopyLocal attribute set to False
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CheckSetCopyLocalToFalseOnGacAssemblies()
         {
             string gacPath = @"C:\windows\gac";
diff --git a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
index 9948b29d469..3cf283c5a6b 100644
--- a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
@@ -125,7 +125,6 @@ private void TestResolveHelper(string itemSpec, string projectGuid, string packa
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestResolve()
         {
             // empty pre-generated string
@@ -209,7 +208,6 @@ private void TestUnresolvedReferencesHelper(ArrayList projectRefs, Hashtable pre
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestManagedCheck()
         {
             Hashtable unresolvedOutputs = null;
@@ -239,7 +237,6 @@ public void TestManagedCheck()
         /// Verifies that the UnresolvedProjectReferences output parameter is populated correctly.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestUnresolvedReferences()
         {
             ArrayList projectRefs = new ArrayList();
diff --git a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
index 8fd537d5c4f..d9a11b3e2d1 100644
--- a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
@@ -8,20 +8,17 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
-
-
-
 using SDKReference = Microsoft.Build.Tasks.ResolveSDKReference.SDKReference;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Xunit;
+using Xunit.NetCore.Extensions;
 using Shouldly;
 
 #nullable disable
 
 namespace Microsoft.Build.UnitTests.ResolveSDKReference_Tests
 {
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class ResolveSDKReferenceTestFixture
     {
         private Microsoft.Build.UnitTests.MockEngine.GetStringDelegate _resourceDelegate = new Microsoft.Build.UnitTests.MockEngine.GetStringDelegate(AssemblyResources.GetString);
@@ -35,7 +32,7 @@ public class ResolveSDKReferenceTestFixture
         /// <summary>
         /// Make sure that SDK reference which should be good are parsed correctly.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ParseItemSpecGood()
         {
             TestGoodSDKReferenceIncludes(new TaskItem("Cat, Version=8.0"), "Cat", "8.0");
@@ -51,7 +48,7 @@ public void ParseItemSpecGood()
         /// <summary>
         /// Make sure ones which are incorrect and log the correct error.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ParseItemSpecBadNames()
         {
             // These should all be bad the format must be   <SDKName>, Version=<SDKVersion>.
@@ -72,7 +69,7 @@ public void ParseItemSpecBadNames()
         /// <summary>
         /// Make sure ones which are incorrect and log the correct error.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ParseDependsOnString()
         {
             Assert.Empty(ResolveSDKReference.ParseDependsOnSDK(null));
@@ -93,7 +90,7 @@ public void ParseDependsOnString()
         /// <summary>
         /// Make sure ones which are incorrect and log the correct error.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetUnResolvedDependentSDKs()
         {
             HashSet<SDKReference> resolvedSDKsEmpty = new HashSet<SDKReference>();
@@ -121,7 +118,7 @@ public void GetUnResolvedDependentSDKs()
             Assert.Equal("\"baz, Version=2.0\"", result[1]);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyBuildWarningForESDKWithoutMaxPlatformVersionOnBlueOrAbove()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "TestMaxPlatformVersionWithTargetFrameworkVersion");
@@ -312,7 +309,7 @@ public void VerifyBuildWarningForESDKWithoutMaxPlatformVersionOnBlueOrAbove()
         /// <summary>
         /// Verify "RuntimeReferenceOnly" equals to "true" is set for specified references
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyAddMetadataToReferences()
         {
             MockEngine engine = new MockEngine();
@@ -354,7 +351,7 @@ public void VerifyAddMetadataToReferences()
         /// <summary>
         /// Make sure ones which are incorrect and log the correct warning.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyUnResolvedSDKMessage()
         {
             MockEngine engine = new MockEngine();
@@ -429,7 +426,7 @@ public void VerifyUnResolvedSDKMessage()
         /// <summary>
         /// Verify if the DependsOn metadata is set on the reference item and that dependency is not resolved then cause the warning to happen.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyDependencyWarningFromMetadata()
         {
             // Create the engine.
@@ -460,7 +457,7 @@ public void VerifyDependencyWarningFromMetadata()
         /// <summary>
         /// Verify we get the correct dependson warning
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyDependsOnWarningFromManifest()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "VerifyDependsOnWarningFromManifest");
@@ -527,7 +524,7 @@ public void VerifyDependsOnWarningFromManifest()
         /// <summary>
         /// Make sure the equals works on the SDKReference.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void TestSDkReferenceEquals()
         {
             ITaskItem dummyItem = new TaskItem();
@@ -575,7 +572,7 @@ private static void TestBadSDKReferenceIncludes(ITaskItem referenceInclude)
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:true Target:msil Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit1()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit1");
@@ -630,7 +627,7 @@ public void Prefer32bit1()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:false Target:AnyCPU Expect: error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit2()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit2");
@@ -688,7 +685,7 @@ public void Prefer32bit2()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:false Target:x86 Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit3()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit3");
@@ -743,7 +740,7 @@ public void Prefer32bit3()
         /// <summary>
         /// Project: Prefer32bit false  Manifest:SupportPrefer32Bit:false Target:msil Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit4()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit4");
@@ -798,7 +795,7 @@ public void Prefer32bit4()
         /// <summary>
         /// Project: Prefer32bit false  Manifest:SupportPrefer32Bit:false Target:x86 Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit5()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit5");
@@ -853,7 +850,7 @@ public void Prefer32bit5()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:FOO Target:msil Expect: error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit6()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit6");
@@ -910,7 +907,7 @@ public void Prefer32bit6()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:empty Target:msil Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit7()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit7");
@@ -965,7 +962,7 @@ public void Prefer32bit7()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:missing Target:msil Expect: No Error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit8()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit8");
@@ -1019,7 +1016,7 @@ public void Prefer32bit8()
         /// <summary>
         /// Project: Prefer32bit false  Manifest:SupportPrefer32Bit:true Target:msil Expect: No Error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit9()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit9");
@@ -1075,7 +1072,7 @@ public void Prefer32bit9()
         /// Resolve from an SDK which exists and is not a framework SDK. This means there is no frameworkIdentity or APPXLocation.
         /// Also since no configuration or architecture were passed in we expect the defaults.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ResolveFromNonFrameworkNoManifest()
         {
             // Create the engine.
@@ -1112,7 +1109,7 @@ public void ResolveFromNonFrameworkNoManifest()
         /// Resolve from an SDK which exists and is not a framework SDK. This means there is no frameworkIdentity or APPXLocation.
         /// Also since no configuration or architecture were passed in we expect the defaults.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ResolveFromNonFrameworkPassInConfigAndArch()
         {
             // Create the engine.
@@ -1150,7 +1147,7 @@ public void ResolveFromNonFrameworkPassInConfigAndArch()
         /// Resolve from an SDK which exists and is not a framework SDK. This means there is no frameworkIdentity or APPXLocation.
         /// Also since no configuration or architecture were passed in we expect the defaults.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ResolveFromNonFrameworkPassInConfigAndArchOverrideByMetadata()
         {
             // Create the engine.
@@ -1191,7 +1188,7 @@ public void ResolveFromNonFrameworkPassInConfigAndArchOverrideByMetadata()
         /// <summary>
         /// When duplicate references are passed in we only want the first one.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void DuplicateSDKReferences()
         {
             // Create the engine.
@@ -1227,7 +1224,7 @@ public void DuplicateSDKReferences()
         /// Verify that if references have SDKName metadata on them that matches a resolved SDK then that SDK should
         /// not have its reference assemblies expanded.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void DoNotExpandSDKsWhichAreAlsoTargetedByReferences()
         {
             // Create the engine.
@@ -1299,7 +1296,7 @@ public void DoNotExpandSDKsWhichAreAlsoTargetedByReferences()
         /// <summary>
         /// When InstalledSDK is empty we should log a message and succeed.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InstalledSDKEmpty()
         {
             // Create the engine.
@@ -1323,7 +1320,7 @@ public void InstalledSDKEmpty()
         /// <summary>
         /// Lets have a mix of install sdk items, some are good, some are bad (missing item spec) others are bad (missing SDKName)
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MixOfInstalledSDKItemsGoodDuplicateAndBad()
         {
             // Create the engine.
@@ -1373,7 +1370,7 @@ public void MixOfInstalledSDKItemsGoodDuplicateAndBad()
         /// <summary>
         /// Make sure when no sdks are resolved there are no problems and that the names of the sdks which were not resolved are logged.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NOSDKResolved()
         {
             // Create the engine.
@@ -1401,7 +1398,7 @@ public void NOSDKResolved()
         /// When there is a mix of resolved and unresolved SDKs make sure that the resolved ones are correctly found
         /// and the unresolved ones are logged.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MixOfResolvedAndUnResolved()
         {
             // Create the engine.
@@ -1432,7 +1429,7 @@ public void MixOfResolvedAndUnResolved()
         /// <summary>
         /// When a null is passed into the SDKReferences property make sure we get the correct exception out.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NullSDKReferences()
         {
             Assert.Throws<ArgumentNullException>(() =>
@@ -1448,7 +1445,7 @@ public void NullSDKReferences()
         /// <summary>
         /// When a null is passed into the set of InstalledSDKS property make sure we get the correct exception out.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NullInstalledSDKs()
         {
             Assert.Throws<ArgumentNullException>(() =>
@@ -1465,7 +1462,7 @@ public void NullInstalledSDKs()
         /// <summary>
         /// If no SDKReferences are passed in then we should get nothing out.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptySDKReferencesList()
         {
             // Create the engine.
@@ -1489,7 +1486,7 @@ public void EmptySDKReferencesList()
         /// When we find the SDKManifest it may be poorly formatted. If that happens we need to log the error
         /// and not resolve the SDK. We also add a good one as well to make sure resolution continues.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SDKFoundButBadlyFormattedSDKManifestWarnings()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SDKFoundButBadlyFormattedSDKManifestWarnings");
@@ -1548,8 +1545,7 @@ public void SDKFoundButBadlyFormattedSDKManifestWarnings()
         /// When we find the SDKManifest it may be poorly formatted. If that happens we need to log the error
         /// and not resolve the SDK. We also add a good one as well to make sure resolution continues.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
+        [WindowsOnlyFact]
         public void SDKFoundButBadlyFormattedSDKManifestErrors()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SDKFoundButBadlyFormattedSDKManifestErrors");
@@ -1600,7 +1596,7 @@ public void SDKFoundButBadlyFormattedSDKManifestErrors()
             }
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void TestMaxPlatformVersionWithTargetFrameworkVersion()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "TestMaxPlatformVersionWithTargetFrameworkVersion");
@@ -1706,7 +1702,7 @@ public void TestMaxPlatformVersionWithTargetFrameworkVersion()
         /// <summary>
         /// Test the case where the manifest attributes are empty.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptySDKManifestAttributes()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "EmptySDKManifestAttributes");
@@ -1791,7 +1787,7 @@ public void EmptySDKManifestAttributes()
         /// <summary>
         /// Test the case where we override ALL of the manifest properties with ones on the metadata
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void OverrideManifestAttributes()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "OverrideManifestAttributes");
@@ -1889,7 +1885,7 @@ public void OverrideManifestAttributes()
         /// <summary>
         /// Test the case where we Have a good manifest that had framework and appx locations that exactly match the targeted sdk configuration and architecture.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GoodManifestMatchingConfigAndArch()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GoodManifestMatchingConfigAndArch");
@@ -1962,7 +1958,7 @@ public void GoodManifestMatchingConfigAndArch()
         /// <summary>
         /// Test the case where we Have a good manifest that had framework and appx locations that only match the targeted sdk configuration.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GoodManifestMatchingConfigOnly()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GoodManifestMatchingConfigOnly");
@@ -2031,7 +2027,7 @@ public void GoodManifestMatchingConfigOnly()
         /// <summary>
         /// TVerify that when a platform identity is found that we do not copy the references or redist
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NoCopyOnPlatformIdentityFound()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "NoCopyOnPlatformIdentityFound");
@@ -2098,7 +2094,7 @@ public void NoCopyOnPlatformIdentityFound()
         /// Test the case where we Have a good manifest that had framework and appx locations that does not match any of the config arch combinations but does match
         /// and entry name simply FrameworkIdentity or APPX
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GoodManifestMatchingBaseNameOnly()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GoodManifestMatchingConfigOnly");
@@ -2172,7 +2168,7 @@ public void GoodManifestMatchingBaseNameOnly()
         /// <summary>
         /// Test the case where we only have the arm APPX and it can be found
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ManifestOnlyHasArmLocation()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ManifestOnlyHasArmLocation");
@@ -2240,7 +2236,7 @@ public void ManifestOnlyHasArmLocation()
         /// <summary>
         /// Test the case where we have a number of locations and arm APPX and can be found
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ManifestArmLocationWithOthers()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ManifestArmLocationWithOthers");
@@ -2311,7 +2307,7 @@ public void ManifestArmLocationWithOthers()
         /// Test the case where there are framework identity attributes but none of the match and there is no base FrameworkIdentity, the
         /// same is true for APPX.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MatchNoNamesButNamesExistWarning()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "MatchNoNamesButNamesExistWarning");
@@ -2383,7 +2379,7 @@ public void MatchNoNamesButNamesExistWarning()
         /// Test the case where there are framework identity attributes but none of the match and there is no base FrameworkIdentity, the
         /// same is true for APPX.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MatchNoNamesButNamesExistError()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "MatchNoNamesButNamesExistError");
@@ -2452,7 +2448,7 @@ public void MatchNoNamesButNamesExistError()
         /// <summary>
         /// Test the case where there is a single supported architecture and the project targets that architecture
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SingleSupportedArchitectureMatchesProject()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SingleSupportedArchitectureMatchesProject");
@@ -2525,7 +2521,7 @@ public void SingleSupportedArchitectureMatchesProject()
         /// <summary>
         /// Test the case where the productfamily is set in the manifest and not as metadata on the reference item.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ProductFamilySetInManifest()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ProductFamilySetInManifest");
@@ -2590,7 +2586,7 @@ public void ProductFamilySetInManifest()
         /// <summary>
         /// Test the case where the productfamily is set in the manifest and as metadata on the reference item. Expect the metadata to win.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ProductFamilySetInManifestAndMetadata()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ProductFamilySetInManifestAndMetadata");
@@ -2657,7 +2653,7 @@ public void ProductFamilySetInManifestAndMetadata()
         /// <summary>
         /// Test the case where the SupportsMultipleVersions is NOT in the manifest or on metadata
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SupportsMultipleVersionsNotInManifest()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SupportsMultipleVersionsNotInManifest");
@@ -2721,7 +2717,7 @@ public void SupportsMultipleVersionsNotInManifest()
         /// <summary>
         /// Test the case where metadata on the item is bad, we should then read from the manifest.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SupportsMultipleVersionsBadMetadata()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SupportsMultipleVersionsBadMetadata");
@@ -2789,7 +2785,7 @@ public void SupportsMultipleVersionsBadMetadata()
         /// <summary>
         /// Test the case where there are conflicts between sdks of the same product family
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConflictsBetweenSameProductFamilySameName()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ConflictsBetweenSameProductFamilySameName");
@@ -2887,7 +2883,7 @@ public void ConflictsBetweenSameProductFamilySameName()
         /// <summary>
         /// Test the case where there are conflicts between sdks of the same product family
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConflictsBetweenSameProductFamilyDiffName()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ConflictsBetweenSameProductFamilyDiffName");
@@ -2985,7 +2981,7 @@ public void ConflictsBetweenSameProductFamilyDiffName()
         /// <summary>
         /// Test the case where there are conflicts between sdks of the same product family
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConflictsBetweenMIXPFAndName()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ConflictsBetweenSameProductFamilyDiffName");
@@ -3098,7 +3094,7 @@ public void ConflictsBetweenMIXPFAndName()
         /// <summary>
         /// Test the case where there are conflicts between sdks of the same SDK Name
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConflictsBetweenSameSDKName()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ConflictsBetweenSameSDKName");
@@ -3196,7 +3192,7 @@ public void ConflictsBetweenSameSDKName()
         /// <summary>
         /// Test the case where metadata on the item is bad, we should then read from the manifest.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SupportsMultipleVersionsReadManifest()
         {
             SupportsMultipleVersionsVerifyManifestReading("Error");
@@ -3278,7 +3274,7 @@ private void SupportsMultipleVersionsVerifyManifestReading(string manifestEntry)
         /// <summary>
         /// Test the case where the supportedArchitectures are empty
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptyArchitectures()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "OverrideManifestWithMetadata");
@@ -3355,7 +3351,7 @@ public void EmptyArchitectures()
         /// <summary>
         /// Test the case where the metadata on the reference overrides what is in the manifest but it does not match what is being targeted
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void OverrideManifestWithMetadataButMetadataDoesNotMatch()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "OverrideManifestWithMetadataButMetadataDoesNotMatch");
@@ -3421,7 +3417,7 @@ public void OverrideManifestWithMetadataButMetadataDoesNotMatch()
         /// <summary>
         /// Test the case where the metadata on the reference overrides what is in the manifest
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void OverrideManifestWithMetadata()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "OverrideManifestWithMetadata");
@@ -3499,7 +3495,7 @@ public void OverrideManifestWithMetadata()
         /// <summary>
         /// Test the case where there is a single supported architecture and the project does not target that architecture
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SingleSupportedArchitectureDoesNotMatchProject()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SingleSupportedArchitectureDoesNotMatchProject");
@@ -3563,7 +3559,7 @@ public void SingleSupportedArchitectureDoesNotMatchProject()
         /// <summary>
         /// Test the case where there is are multiple supported architecture and the project targets one of those architectures
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MultipleSupportedArchitectureMatchesProject()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "MultipleSupportedArchitectureMatchesProject");
@@ -3635,7 +3631,7 @@ public void MultipleSupportedArchitectureMatchesProject()
         /// <summary>
         /// Test the case where there is are multiple supported architecture and the project does not match one of those architectures
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MultipleSupportedArchitectureDoesNotMatchProject()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "MultipleSupportedArchitectureMatchesProject");
@@ -3701,11 +3697,9 @@ public void MultipleSupportedArchitectureDoesNotMatchProject()
     /// <summary>
     /// Test the output groups which will be used to generate the recipe fileGatherSDKOutputGroups
     /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class GatherSDKOutputGroupsTestFixture
     {
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void GatherSDKOutputGroupsTargetArchitectureExists()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GatherSDKOutputGroupsWithFramework");
@@ -3848,8 +3842,7 @@ public void GatherSDKOutputGroupsTargetArchitectureExists()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void GatherSDKOutputGroupsTargetArchitectureExists2()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GatherSDKOutputGroupsWithFramework");
@@ -3993,8 +3986,7 @@ public void GatherSDKOutputGroupsTargetArchitectureExists2()
         }
 
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void GatherSDKOutputGroupsTargetArchitectureDoesNotExists()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GatherSDKOutputGroupsTargetArchitectureDoesNotExists");
@@ -4103,8 +4095,7 @@ public void GatherSDKOutputGroupsTargetArchitectureDoesNotExists()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void CheckDefaultingOfTargetConfigAndArchitecture()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "CheckDefaultingOfTargetConfigAndArchitecture");
@@ -4201,8 +4192,7 @@ public void CheckDefaultingOfTargetConfigAndArchitecture()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyPlatformAliasesWork()
         {
             // This verifies that UAP is an alias for windows, so verifying the target platforms align. Other parts of the reference don't matter here.
@@ -4224,8 +4214,7 @@ public void VerifyPlatformAliasesWork()
             reference.TargetPlatform.ShouldBe("UAP");
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void CheckAttributesFromManifestArePassedToResolvedAssemblies()
         {
             /* \Microsoft SDKs\Windows\v8.0\ExtensionSDKs */
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index f2c6b9d0524..4a2dcdac485 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Shared;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 using System.IO;
 using System.Threading;
 using Shouldly;
@@ -17,8 +18,6 @@
 
 namespace Microsoft.Build.UnitTests.GenerateResource_Tests.OutOfProc
 {
-    [Trait("Category", "mono-osx-failing")]
-    [Trait("Category", "mono-windows-failing")]
     public sealed class RequiredTransformations
     {
         private readonly ITestOutputHelper _output;
@@ -491,7 +490,6 @@ public void AllowLinkedNoGenerate()
         ///  Allow the task to skip processing based on having nothing out of date
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void NothingOutOfDate()
         {
             string resxFile = null;
@@ -571,8 +569,6 @@ public void NothingOutOfDate()
         /// </summary>
         /// <remarks>System dll is not locked because it forces a new app domain</remarks>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void NothingOutOfDateExceptReference()
         {
             string resxFile = null;
@@ -973,7 +969,6 @@ public void StronglyTypedResourcesUpToDate()
         /// STR class file is out of date, but resources are up to date. Should still generate it.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void StronglyTypedResourcesOutOfDate()
         {
             string resxFile = null;
@@ -1245,7 +1240,6 @@ public void StronglyTypedResourcesWithoutNamespaceOrClassOrFilename()
         ///  STR with resource namespace yields proper output, message (CS)
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void STRWithResourcesNamespaceCS()
         {
             Utilities.STRNamespaceTestHelper("CSharp", "MyResourcesNamespace", null, _output);
@@ -1273,7 +1267,6 @@ public void STRWithResourcesNamespaceAndSTRNamespaceCS()
         ///  STR with resource namespace and STR namespace yields proper output, message (CS)
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void STRWithResourcesNamespaceAndSTRNamespaceVB()
         {
             Utilities.STRNamespaceTestHelper("VB", "MyResourcesNamespace", "MySTClassNamespace", _output);
@@ -1293,7 +1286,6 @@ public TransformationErrors(ITestOutputHelper output)
         ///  Text input failures, no name, no '=', 'strings' token, invalid token, invalid escape
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TextToResourcesBadFormat()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -1359,8 +1351,6 @@ public void TextToResourcesBadFormat()
         ///  Cause failures in ResXResourceReader
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void FailedResXReader()
         {
             string resxFile1 = null;
@@ -1427,8 +1417,6 @@ public void FailedResXReader()
         ///  Cause failures in ResXResourceReader, different codepath
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void FailedResXReaderWithAllOutputResourcesSpecified()
         {
             string resxFile1 = null;
@@ -1502,7 +1490,6 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
         ///  Duplicate resource names
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void DuplicateResourceNames()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -1528,7 +1515,6 @@ public void DuplicateResourceNames()
         ///  Non-string resource with text output
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UnsupportedTextType()
         {
             string bitmap = Utilities.CreateWorldsSmallestBitmap();
@@ -1596,7 +1582,6 @@ public void InvalidStateFile()
         ///  Cause failures in ResourceReader
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void FailedResourceReader()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -1630,7 +1615,6 @@ public void FailedResourceReader()
         ///  Invalid STR Class name
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void FailedSTRProperty()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -1818,8 +1802,6 @@ public void OutputFilesNotSpecified()
         ///  FilesWritten contains OutputResources + StateFile
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void FilesWrittenSet()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -1860,8 +1842,6 @@ public void FilesWrittenSet()
         ///  Resource transformation fails on 3rd of 4 inputs, inputs 1 & 2 & 4 are in outputs and fileswritten.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void OutputFilesPartialInputs()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -1928,8 +1908,6 @@ public void OutputFilesPartialInputs()
         ///  STR class name derived from output file transformation
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void StronglyTypedClassName()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -1971,8 +1949,6 @@ public void StronglyTypedClassName()
         ///  STR class file name derived from class name transformation
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void StronglyTypedFileName()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -2081,7 +2057,6 @@ public void ReferencesToBadAssemblies()
         ///  Source item not found
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SourceItemMissing()
         {
             string txtFile = null;
@@ -2123,9 +2098,7 @@ public void SourceItemMissing()
         /// <summary>
         ///  Non-existent StateFile yields message
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-windows-failing")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void StateFileUnwritable()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -2165,7 +2138,6 @@ public void StateFileUnwritable()
         ///  Bad file extension on input
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void InputFileExtension()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -2199,7 +2171,6 @@ public void InputFileExtension()
         ///  Bad file extension on output
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void OutputFileExtension()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -2265,7 +2236,6 @@ public void SourcesMatchesOutputResources()
         ///  Invalid StronglyTypedLanguage yields CodeDOM exception
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UnknownStronglyTypedLanguage()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
@@ -2349,8 +2319,6 @@ public void StronglyTypedResourceWithMoreThanOneInputResourceFile()
         ///  STR class name derived from output file transformation
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void BadStronglyTypedFilename()
         {
             string txtFile = null;
@@ -2506,7 +2474,6 @@ public void StronglyTypedResourceFilenameWithoutLanguage()
         /// Verify that passing a STR language with more than 1 sources errors
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void StronglyTypedResourceFileIsExistingDirectory()
         {
             string dir = null;
@@ -2602,7 +2569,6 @@ public References(ITestOutputHelper output)
         [Fact]
         // FIXME: mono: looks for csc.exe
         // https://github.com/dotnet/msbuild/issues/677
-        [Trait("Category", "mono-osx-failing")]
         public void DontLockP2PReferenceWhenResolvingSystemTypes()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -2780,7 +2746,6 @@ public class Class1
         [Fact]
         // FIXME: mono: looks for csc.exe
         // https://github.com/dotnet/msbuild/issues/677
-        [Trait("Category", "mono-osx-failing")]
         public void ReferencedAssemblySpecifiedUsingRelativePath()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 1a62accb608..b63883cf855 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -16,13 +16,12 @@
 using Xunit.Abstractions;
 using System.Collections.Generic;
 using System.Text.RegularExpressions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
 namespace Microsoft.Build.UnitTests.GenerateResource_Tests.InProc
 {
-    [Trait("Category", "mono-osx-failing")]
-    [Trait("Category", "mono-windows-failing")]
     public sealed class RequiredTransformations : IDisposable
     {
         private readonly TestEnvironment _env;
@@ -1523,8 +1522,7 @@ public void StronglyTypedResourcesWithoutNamespaceOrClassOrFilename()
         /// <remarks>
         /// Regression test for legacy-codepath-resources case of https://github.com/dotnet/msbuild/issues/4582
         /// </remarks>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/dotnet/msbuild/issues/2272")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "https://github.com/dotnet/msbuild/issues/2272")]
         public void StronglyTypedResourcesEmitTypeIntoClass()
         {
             string bitmap = Utilities.CreateWorldsSmallestBitmap();
@@ -1946,8 +1944,7 @@ public void InvalidStateFile()
         /// <summary>
         ///  Cause failures in ResourceReader
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core MSBuild doesn't try to read binary input resources")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core MSBuild doesn't try to read binary input resources.")]
         public void FailedResourceReader()
         {
             GenerateResource t = Utilities.CreateTask(_output);
@@ -1976,10 +1973,9 @@ public void FailedResourceReader()
             }
         }
 
-        [Theory]
+        [DotNetOnlyTheory(additionalMessage: "This error is .NET Core only.")]
         [InlineData(".resources")]
         [InlineData(".dll")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework, "This error is .NET Core only")]
         public void ResourceReaderRejectsNonCoreCompatFormats(string inputExtension)
         {
             using var env = TestEnvironment.Create(_output);
@@ -2037,9 +2033,7 @@ public void FailedSTRProperty()
         /// <summary>
         /// Reference passed in that can't be loaded should error
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp,
-            reason: ".NET Core MSBuild doesn't load refs so it pushes this failure to runtime")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core MSBuild doesn't load refs so it pushes this failure to runtime.")]
         public void InvalidReference()
         {
             string txtFile = null;
@@ -2319,8 +2313,7 @@ public void OutputFilesPartialInputs()
         ///  STR class name derived from output file transformation
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
+
         public void StronglyTypedClassName()
         {
             GenerateResource t = Utilities.CreateTask(_output);
@@ -2366,8 +2359,6 @@ public void StronglyTypedClassName()
         ///  STR class file name derived from class name transformation
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void StronglyTypedFileName()
         {
             GenerateResource t = Utilities.CreateTask(_output);
@@ -2520,8 +2511,7 @@ public void SourceItemMissing()
         /// <summary>
         ///  Read-only StateFile yields message
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void StateFileUnwritable()
         {
             GenerateResource t = Utilities.CreateTask(_output);
@@ -2657,7 +2647,6 @@ public void SourcesMatchesOutputResources()
         ///  Invalid StronglyTypedLanguage yields CodeDOM exception
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UnknownStronglyTypedLanguage()
         {
             GenerateResource t = Utilities.CreateTask(_output);
@@ -2942,9 +2931,7 @@ public void StronglyTypedResourceFileIsExistingDirectory()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
         public void Regress25163_OutputResourcesContainsInvalidPathCharacters()
         {
             string resourcesFile = null;
@@ -2982,9 +2969,7 @@ public References(ITestOutputHelper output)
             _output = output;
         }
 
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "Linked resources not supported on Core: https://github.com/dotnet/msbuild/issues/4094")]
-        [SkipOnMono("https://github.com/dotnet/msbuild/issues/677")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "Linked resources not supported on Core: https://github.com/dotnet/msbuild/issues/4094")]
         public void DontLockP2PReferenceWhenResolvingSystemTypes()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -3160,9 +3145,7 @@ public class Class1
         /// which fails (LoadFile requires an absolute path).  The fix was to use
         /// Assembly.LoadFrom instead.
         /// </summary>
-        [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "Linked resources not supported on Core: https://github.com/dotnet/msbuild/issues/4094")]
-        [SkipOnMono("https://github.com/dotnet/msbuild/issues/677")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "Linked resources not supported on Core: https://github.com/dotnet/msbuild/issues/4094")]
         public void ReferencedAssemblySpecifiedUsingRelativePath()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
index 35138733840..6b99bca8e7d 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
@@ -25,7 +25,6 @@ public class ResGen_Tests
         ///  - Verify that OutputFiles defaults appropriately
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void InputFiles()
         {
             ResGen t = new ResGen();
@@ -87,7 +86,6 @@ public void InputFiles()
         ///  - Verify that if OutputFiles are set explicitly, they map and show up on the command line as expected
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void OutputFiles()
         {
             ResGen t = new ResGen();
@@ -164,7 +162,6 @@ public void OutputFiles()
         /// Tests ResGen's /publicClass switch
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PublicClass()
         {
             ResGen t = new ResGen();
@@ -185,7 +182,6 @@ public void PublicClass()
         /// Tests the /r: parameter (passing in reference assemblies)
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void References()
         {
             ResGen t = new ResGen();
@@ -469,7 +465,6 @@ public void ToolPath()
         /// Tests ResGen's /useSourcePath switch
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void UseSourcePath()
         {
             ResGen t = new ResGen();
diff --git a/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs b/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs
index a381e987783..0fd3095dd12 100644
--- a/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs
+++ b/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using Microsoft.Build.Tasks;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -181,14 +182,9 @@ public void GeneratePathToToolX86DoesNotExistAnywhere()
         /// <summary>
         /// Test the case where there are illegal chars in the sdktoolspath and Path.combine has a problem.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("No invalid path characters under Unix.")]
         public void VerifyErrorWithIllegalChars()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "No invalid path characters under Unix"
-            }
-
             string toolPath = SdkToolsPathUtility.GeneratePathToTool(_mockExists.MockFileDoesNotExist, ProcessorArchitecture.X86, "./?><;)(*&^%$#@!", _toolName, _log, true);
             Assert.Null(toolPath);
             _mockEngine.AssertLogContains("MSB3666");
diff --git a/src/Tasks.UnitTests/TlbImp_Tests.cs b/src/Tasks.UnitTests/TlbImp_Tests.cs
index da394bbb651..0827599cb35 100644
--- a/src/Tasks.UnitTests/TlbImp_Tests.cs
+++ b/src/Tasks.UnitTests/TlbImp_Tests.cs
@@ -68,7 +68,6 @@ public void TypeLibName()
         /// Tests that the assembly being imported is passed to the command line
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TypeLibNameWithSpaces()
         {
             var t = new ResolveComReference.TlbImp();
diff --git a/src/Tasks.UnitTests/Unzip_Tests.cs b/src/Tasks.UnitTests/Unzip_Tests.cs
index 3e74d5ef77c..26de13ddc87 100644
--- a/src/Tasks.UnitTests/Unzip_Tests.cs
+++ b/src/Tasks.UnitTests/Unzip_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -110,8 +111,7 @@ public void CanUnzip_ExplicitDirectoryEntries()
             }
         }
 
-        [PlatformSpecific(TestPlatforms.Windows)] // Can't figure out how to make CreateDirectory throw on non-Windows
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Can't figure out how to make CreateDirectory throw on non-Windows.")]
         public void LogsErrorIfDirectoryCannotBeCreated()
         {
             Unzip unzip = new Unzip
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index 962dd1ec0a4..2d52b6f8855 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -10,6 +10,7 @@
 using System.Linq;
 using System.Runtime.InteropServices;
 using Shouldly;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -24,7 +25,6 @@ public class WriteCodeFragment_Tests
         /// Need an available language
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void InvalidLanguage()
         {
             WriteCodeFragment task = new WriteCodeFragment();
@@ -194,8 +194,7 @@ public void InvalidFilePath()
         /// <summary>
         /// Bad directory path
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "No invalid characters on Unix"
+        [WindowsOnlyFact(additionalMessage: "No invalid characters on Unix.")]
         public void InvalidDirectoryPath()
         {
             WriteCodeFragment task = new WriteCodeFragment();
@@ -247,7 +246,6 @@ public void OneAttributeNoParams()
         /// Test with the VB language
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void OneAttributeNoParamsVb()
         {
             WriteCodeFragment task = new WriteCodeFragment();
@@ -493,7 +491,6 @@ public void MultilineAttributeCSharp()
         /// Multi line argument values should cause a verbatim string to be used
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void MultilineAttributeVB()
         {
             var lines = new[] { "line 1", "line 2", "line 3" };
@@ -632,7 +629,6 @@ public void OneAttributePositionalAndNamedParams()
         /// These can also be combined with named params.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void OneAttributePositionalAndNamedParamsVisualBasic()
         {
             WriteCodeFragment task = new WriteCodeFragment();
diff --git a/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs b/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs
index c8f2f37161a..cefb96e614a 100644
--- a/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs
+++ b/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs
@@ -29,7 +29,6 @@ public GeneratedTask()
         /// Test to see whether all of the correct boolean switches are appended.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestDefaultFlags()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -41,7 +40,6 @@ public void TestDefaultFlags()
         /// This test case leaves the default flags the way they are
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestReversibleFlagsWithDefaults()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -55,7 +53,6 @@ public void TestReversibleFlagsWithDefaults()
         /// This test case explicitly sets the ComplexReversible to be false
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestReversibleFlagsWithoutDefaults()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -69,7 +66,6 @@ public void TestReversibleFlagsWithoutDefaults()
         /// Tests to make sure enums are working well.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestBasicString()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -79,7 +75,6 @@ public void TestBasicString()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestDynamicEnum()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -92,7 +87,6 @@ public void TestDynamicEnum()
         /// Tests the basic string array type
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestBasicStringArray()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -107,7 +101,6 @@ public void TestBasicStringArray()
         /// Tests the basic string array type, with an array that contains multiple values.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestBasicStringArray_MultipleValues()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -124,7 +117,6 @@ public void TestBasicStringArray_MultipleValues()
         /// Tests to see whether the integer appears correctly on the command line
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestInteger()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -138,7 +130,6 @@ public void TestInteger()
         /// Tests the (full) functionality of a reversible property
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestComplexReversible()
         {
             // When flag is set to false
@@ -155,7 +146,6 @@ public void TestComplexReversible()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestComplexString()
         {
             // check to see that the resulting value is good
@@ -169,7 +159,6 @@ public void TestComplexString()
         /// Tests the functionality of a string type property
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestComplexStringArray()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -180,7 +169,6 @@ public void TestComplexStringArray()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestComplexIntegerLessThanMin()
         {
             Assert.Throws<InvalidOperationException>(() =>
@@ -191,7 +179,6 @@ public void TestComplexIntegerLessThanMin()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestComplexIntegerGreaterThanMax()
         {
             Assert.Throws<InvalidOperationException>(() =>
@@ -203,7 +190,6 @@ public void TestComplexIntegerGreaterThanMax()
             });
         }
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestComplexIntegerWithinRange()
         {
             object fakeTaskInstance = CreateFakeTask();
@@ -248,7 +234,6 @@ public class ProjectFileTests
         /// Tests that when a call to a XamlDataDrivenTask fails, the commandline is reported in the error message.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CommandLineErrorsReportFullCommandlineAmpersandTemp()
         {
             string projectFile = @"
@@ -305,7 +290,6 @@ public void CommandLineErrorsReportFullCommandlineAmpersandTemp()
         /// Tests that when a call to a XamlDataDrivenTask fails, the commandline is reported in the error message.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void CommandLineErrorsReportFullCommandline()
         {
             string projectFile = @"
@@ -342,7 +326,6 @@ public void CommandLineErrorsReportFullCommandline()
         /// Tests that when a call to a XamlDataDrivenTask fails, the commandline is reported in the error message.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void SquareBracketEscaping()
         {
             string projectFile = @"
diff --git a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
index a2ae014d062..cdcee567020 100644
--- a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
@@ -25,7 +25,6 @@ namespace Microsoft.Build.UnitTests.XamlTaskFactory_Tests
     /// The text fixture to unit test the task generator.
     /// Creates a new TaskGenerator object and tests the various methods
     /// </summary>
-    [Trait("Category", "mono-osx-failing")]
     public sealed class LoadAndParseTests
     {
         /// <summary>
@@ -450,7 +449,6 @@ public class CompilationTests
         /// Code must be compilable on its own.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestGenerateCodeToStream()
         {
             string xmlContents = @"<ProjectSchemaDefinitions xmlns=`clr-namespace:Microsoft.Build.Framework.XamlTypes;assembly=Microsoft.Build.Framework` xmlns:x=`http://schemas.microsoft.com/winfx/2006/xaml` xmlns:sys=`clr-namespace:System;assembly=mscorlib` xmlns:impl=`clr-namespace:Microsoft.VisualStudio.Project.Contracts.Implementation;assembly=Microsoft.VisualStudio.Project.Contracts.Implementation`>
@@ -503,7 +501,6 @@ public void TestGenerateCodeToStream()
         /// Tests to make sure the file generated compiles
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestGenerateToFile()
         {
             string xml = @"<ProjectSchemaDefinitions xmlns=`clr-namespace:Microsoft.Build.Framework.XamlTypes;assembly=Microsoft.Build.Framework` xmlns:x=`http://schemas.microsoft.com/winfx/2006/xaml` xmlns:sys=`clr-namespace:System;assembly=mscorlib` xmlns:impl=`clr-namespace:Microsoft.VisualStudio.Project.Contracts.Implementation;assembly=Microsoft.VisualStudio.Project.Contracts.Implementation`>
@@ -565,7 +562,6 @@ public void TestGenerateToFile()
     #endregion
 
     #region Tests Generated code based on one xml file
-    [Trait("Category", "mono-osx-failing")]
     public sealed class GeneratedTaskTests
     {
         private Assembly _fakeTaskDll;
diff --git a/src/Tasks.UnitTests/XmlPoke_Tests.cs b/src/Tasks.UnitTests/XmlPoke_Tests.cs
index fba347fb692..d78bbcad622 100644
--- a/src/Tasks.UnitTests/XmlPoke_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPoke_Tests.cs
@@ -60,7 +60,6 @@ public void PokeWithNamespace()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PokeNoNamespace()
         {
             const string query = "//variable/@Name";
@@ -271,7 +270,6 @@ public void MissingNamespaceParameters()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void PokeElement()
         {
             const string query = "//variable/.";
diff --git a/src/UnitTests.Shared/EnvironmentProvider.cs b/src/UnitTests.Shared/EnvironmentProvider.cs
new file mode 100644
index 00000000000..4ca3c276867
--- /dev/null
+++ b/src/UnitTests.Shared/EnvironmentProvider.cs
@@ -0,0 +1,137 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+#if !NET6_0_OR_GREATER
+using System.Diagnostics;
+#endif
+using System.IO;
+using System.Linq;
+using System.Runtime.InteropServices;
+
+namespace Microsoft.Build.UnitTests.Shared
+{
+    public class EnvironmentProvider
+    {
+        private static class Constants
+        {
+            public const string DotNet = "dotnet";
+            public const string Path = "PATH";
+            public const string DotnetMsbuildSdkResolverCliDir = "DOTNET_MSBUILD_SDK_RESOLVER_CLI_DIR";
+            public static readonly bool RunningOnWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
+            public static readonly string ExeSuffix = RunningOnWindows ? ".exe" : string.Empty;
+        }
+
+        private IEnumerable<string>? _searchPaths;
+
+        private readonly Func<string, string?> _getEnvironmentVariable;
+        private readonly Func<string?> _getCurrentProcessPath;
+
+        public EnvironmentProvider(Func<string, string?> getEnvironmentVariable)
+            : this(getEnvironmentVariable, GetCurrentProcessPath)
+        { }
+
+        public EnvironmentProvider(Func<string, string?> getEnvironmentVariable, Func<string?> getCurrentProcessPath)
+        {
+            _getEnvironmentVariable = getEnvironmentVariable;
+            _getCurrentProcessPath = getCurrentProcessPath;
+        }
+
+        private IEnumerable<string> SearchPaths
+        {
+            get
+            {
+                if (_searchPaths == null)
+                {
+                    var searchPaths = new List<string>();
+
+                    searchPaths.AddRange(
+                        (_getEnvironmentVariable(Constants.Path) ?? string.Empty)
+                        .Split(new char[] { Path.PathSeparator }, options: StringSplitOptions.RemoveEmptyEntries)
+                        .Select(p => p.Trim('"')));
+
+                    _searchPaths = searchPaths;
+                }
+
+                return _searchPaths;
+            }
+        }
+
+        public string? GetCommandPath(string commandName)
+        {
+            var commandNameWithExtension = commandName + Constants.ExeSuffix;
+            var commandPath = SearchPaths
+                .Where(p => !Path.GetInvalidPathChars().Any(p.Contains))
+                .Select(p => Path.Combine(p, commandNameWithExtension))
+                .FirstOrDefault(File.Exists);
+
+            return commandPath;
+        }
+
+        public string? GetDotnetExePath()
+        {
+            string? environmentOverride = _getEnvironmentVariable(Constants.DotnetMsbuildSdkResolverCliDir);
+            if (!string.IsNullOrEmpty(environmentOverride))
+            {
+                return Path.Combine(environmentOverride, Constants.DotNet + Constants.ExeSuffix);
+            }
+
+            string? dotnetExe = _getCurrentProcessPath();
+
+            if (string.IsNullOrEmpty(dotnetExe) || !Path.GetFileNameWithoutExtension(dotnetExe)
+                    .Equals(Constants.DotNet, StringComparison.InvariantCultureIgnoreCase))
+            {
+                string? dotnetExeFromPath = GetCommandPath(Constants.DotNet);
+#if NET
+                if (dotnetExeFromPath != null && !Constants.RunningOnWindows)
+                {
+                    // on Linux the 'dotnet' command from PATH is a symlink so we need to
+                    // resolve it to get the actual path to the binary
+                    FileInfo fi = new FileInfo(dotnetExeFromPath);
+                    while (fi.LinkTarget != null)
+                    {
+                        dotnetExeFromPath = fi.LinkTarget;
+                        fi = new FileInfo(dotnetExeFromPath);
+                    }
+                }
+#endif
+                if (!string.IsNullOrWhiteSpace(dotnetExeFromPath))
+                {
+                    dotnetExe = dotnetExeFromPath;
+                }
+            }
+
+            return dotnetExe;
+        }
+
+        public static string? GetDotnetExePath(Func<string, string?>? getEnvironmentVariable = null)
+        {
+            if (getEnvironmentVariable == null)
+            {
+                getEnvironmentVariable = Environment.GetEnvironmentVariable;
+            }
+            var environmentProvider = new EnvironmentProvider(getEnvironmentVariable);
+            return environmentProvider.GetDotnetExePath();
+        }
+
+        public static string? GetDotnetExePath(Func<string, string?> getEnvironmentVariable, Func<string?> getCurrentProcessPath)
+        {
+            getEnvironmentVariable ??= Environment.GetEnvironmentVariable;
+            getCurrentProcessPath ??= GetCurrentProcessPath;
+            var environmentProvider = new EnvironmentProvider(getEnvironmentVariable, getCurrentProcessPath);
+            return environmentProvider.GetDotnetExePath();
+        }
+
+        private static string? GetCurrentProcessPath()
+        {
+            string? currentProcessPath;
+#if NET6_0_OR_GREATER
+            currentProcessPath = Environment.ProcessPath;
+#else
+            currentProcessPath = Process.GetCurrentProcess().MainModule.FileName;
+#endif
+            return currentProcessPath;
+        }
+    }
+}
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 78b694d815d..4e60b742a8d 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -13,6 +13,9 @@ namespace Microsoft.Build.UnitTests.Shared
     public static class RunnerUtilities
     {
         public static string PathToCurrentlyRunningMsBuildExe => BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
+#if !FEATURE_RUN_EXE_IN_TESTS
+        private static readonly string s_dotnetExePath = EnvironmentProvider.GetDotnetExePath();
+#endif
 
         /// <summary>
         /// Invoke the currently running msbuild and return the stdout, stderr, and process exit status.
@@ -32,7 +35,7 @@ public static string ExecMSBuild(string pathToMsBuildExe, string msbuildParamete
 #if FEATURE_RUN_EXE_IN_TESTS
             var pathToExecutable = pathToMsBuildExe;
 #else
-            var pathToExecutable = ResolveRuntimeExecutableName();
+            var pathToExecutable = s_dotnetExePath;
             msbuildParameters = FileUtilities.EnsureDoubleQuotes(pathToMsBuildExe) + " " + msbuildParameters;
 #endif
 
@@ -55,20 +58,6 @@ private static void AdjustForShellExecution(ref string pathToExecutable, ref str
             }
         }
 
-#if !FEATURE_RUN_EXE_IN_TESTS
-        /// <summary>
-        /// Resolve the platform specific path to the runtime executable that msbuild.exe needs to be run in (unix-mono, {unix, windows}-corerun).
-        /// </summary>
-        private static string ResolveRuntimeExecutableName()
-        {
-            // Run the child process with the same host as the currently-running process.
-            using (Process currentProcess = Process.GetCurrentProcess())
-            {
-                return currentProcess.MainModule.FileName;
-            }
-        }
-#endif
-
         /// <summary>
         /// Run the process and get stdout and stderr
         /// </summary>
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index f774fdfc69e..2c81395c138 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #pragma warning disable 0219
 
@@ -227,14 +228,9 @@ public void NonexistentRequestDirectory()
             from.GetMetadata(FileUtilities.ItemSpecModifiers.Directory).ShouldBe(NativeMethodsShared.IsWindows ? @"subdir\" : "subdir/");
         }
 
-        [Fact]
+        [WindowsOnlyFact("UNC is not implemented except under Windows.")]
         public void NonexistentRequestDirectoryUNC()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "UNC is not implemented except under Windows"
-            }
-
             TaskItem from = new TaskItem();
             from.ItemSpec = @"\\local\share\subdir\Monkey.txt";
             from.GetMetadata(FileUtilities.ItemSpecModifiers.Directory).ShouldBe(@"subdir\");
@@ -333,8 +329,6 @@ public void SetNullMetadataValue()
         /// Test that task items can be successfully constructed based on a task item from another appdomain.  
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "mono-windows-failing")]
         public void RemoteTaskItem()
         {
             AppDomain appDomain = null;
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index 8c961c597f1..f4e18fa61b7 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -23,6 +23,7 @@
 using SharedDotNetFrameworkArchitecture = Microsoft.Build.Shared.DotNetFrameworkArchitecture;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -68,8 +69,7 @@ public void GetApiContractReferencesHandlesNonExistingLocation()
             returnValue.Length.ShouldBe(0);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetApiContractReferencesFindsWinMDs()
         {
             string tempDirectory = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
@@ -93,8 +93,7 @@ public void GetApiContractReferencesFindsWinMDs()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetApiContractReferencesFindsVersionedWinMDs()
         {
             string tempDirectory = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
@@ -117,8 +116,7 @@ public void GetApiContractReferencesFindsVersionedWinMDs()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetWinBlueSDKLocation()
         {
             string sdkRootPath = ToolLocationHelper.GetPlatformSDKLocation("Windows", "8.1");
@@ -127,8 +125,7 @@ public void GetWinBlueSDKLocation()
             returnValue.ShouldBe(sdkRootPath);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetWinBlueContentFolderPath()
         {
             string sdkRootPath = ToolLocationHelper.GetPlatformSDKLocation("Windows", "8.1");
@@ -137,8 +134,7 @@ public void GetWinBlueContentFolderPath()
             returnValue.ShouldBe(Path.Combine(sdkRootPath, @"DesignTime\CommonConfiguration\Neutral"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetSDKRootLocation()
         {
             string expectedValue = ToolLocationHelper.GetPlatformSDKLocation("Windows", "10.0");
@@ -151,11 +147,10 @@ public void GetSDKRootLocation()
         }
 
 #if RUNTIME_TYPE_NETCORE
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1250")]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/1250")]
 #else
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/2569")]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/2569")]
 #endif
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void GetUnversionedSDKUnionMetadataLocation()
         {
             string sdkRootPath = ToolLocationHelper.GetPlatformSDKLocation("Windows", "10.0");
@@ -165,8 +160,7 @@ public void GetUnversionedSDKUnionMetadataLocation()
             returnValue.ShouldBe(Path.Combine(sdkRootPath, "UnionMetadata"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetVersionedSDKUnionMetadataLocation()
         {
             // Create manifest file
@@ -533,8 +527,7 @@ public void FindFrameworksPathRunningThisTest()
          *
          * Search for a whidbey when whidbey is the current version.
          */
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void FindFrameworksPathRunningUnderWhidbey()
         {
             string path = FrameworkLocationHelper.FindDotNetFrameworkPath(
@@ -551,8 +544,7 @@ public void FindFrameworksPathRunningUnderWhidbey()
         *
         * Search for a whidbey when orcas is the current version.
         */
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void FindFrameworksPathRunningUnderOrcas()
         {
             string path = FrameworkLocationHelper.FindDotNetFrameworkPath(
@@ -569,8 +561,7 @@ public void FindFrameworksPathRunningUnderOrcas()
         *
         * Search for a whidbey when orcas is the current version.
         */
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void FindFrameworksPathRunningUnderEverett()
         {
             string path = FrameworkLocationHelper.FindDotNetFrameworkPath(
@@ -626,7 +617,6 @@ public void FindPathForEverettThatIsntProperlyInstalled()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         public void ExerciseMiscToolLocationHelperMethods()
@@ -687,7 +677,6 @@ public void ExerciseMiscToolLocationHelperMethods()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TestGetPathToBuildToolsFile()
         {
             string net20Path = ToolLocationHelper.GetPathToDotNetFrameworkFile("MSBuild.exe", TargetDotNetFrameworkVersion.Version20);
@@ -710,7 +699,6 @@ public void TestGetPathToBuildToolsFile()
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/722")]
 #else
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
 #endif
         public void TestGetPathToBuildToolsFile_32Bit()
         {
@@ -907,11 +895,10 @@ public void TestGetDotNetFrameworkSdkInstallKeyValue()
         }
 
 #if FEATURE_REGISTRY_SDKS
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/995")]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/995")]
 #else
-        [Fact(Skip = "Registry SDKs not supported")]
+        [WindowsOnlyFact(Skip = "Registry SDKs not supported")]
 #endif
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void GetPathToDotNetFrameworkSdk()
         {
             // Test out of range .net version.
@@ -990,8 +977,7 @@ public void GetPathToDotNetFrameworkSdk()
 
 #pragma warning disable 618 //The test below tests a deprecated API. We disable the warning for obsolete methods for this particular test
 #if FEATURE_WIN32_REGISTRY
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetPathToWindowsSdk()
         {
             // Test out of range .net version.
@@ -1134,7 +1120,6 @@ public void VerifyToolsetAndToolLocationHelperAgree()
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyToolsetAndToolLocationHelperAgreeWhenVisualStudioVersionIsEmpty()
         {
             string projectContents = @"
@@ -1176,7 +1161,6 @@ public void VerifyToolsetAndToolLocationHelperAgreeWhenVisualStudioVersionIsEmpt
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyToolsetAndToolLocationHelperAgreeWhenVisualStudioVersionIs10()
         {
             string projectContents = @"
@@ -1219,8 +1203,7 @@ public void VerifyToolsetAndToolLocationHelperAgreeWhenVisualStudioVersionIs10()
             success.ShouldBeTrue(); // "Build Failed.  See Std Out for details."
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyToolsetAndToolLocationHelperAgreeWhenVisualStudioVersionIs11()
         {
             string projectContents = @"
@@ -1358,9 +1341,7 @@ public void GenerateReferencAssemblyInvalidIdentifier()
         /// Make sure if the moniker and the root make a too long path that an InvalidOperationException is raised
         /// which indicates there was a problem generating the reference assembly path.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void GenerateReferencAssemblyPathTooLong()
         {
             Should.Throw<InvalidOperationException>(() =>
@@ -1388,7 +1369,6 @@ public void GenerateReferencAssemblyPathTooLong()
         /// do not have anything to chain with.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ChainReferenceAssembliesRedistExistsNoRedistList()
         {
             string path = ToolLocationHelper.ChainReferenceAssemblyPath(@"PathDoesNotExistSoICannotChain");
@@ -1632,9 +1612,7 @@ public void ChainReferenceAssembliesRedistInvalidPathChars()
         /// <summary>
         /// Make sure we get the correct exception when the xml file points to an included framework which has invalid path chars.
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void ChainReferenceAssembliesRedistPathTooLong()
         {
             Should.Throw<InvalidOperationException>(() =>
@@ -1937,7 +1915,6 @@ public void GetPathToReferenceAssembliesDefaultLocationNullFrameworkName()
         /// place, which means it just looks for a folder starting with v4.0 in the right spot for any higher version.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GetPathToReferenceAssembliesDefaultLocation48()
         {
             if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48) != null)
@@ -1971,8 +1948,7 @@ public void GetPathToReferenceAssembliesDefaultLocation99()
         /// <summary>
         /// Make sure we choose the correct path for program files based on the operating system
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void TestGenerateProgramFiles32()
         {
             Environment.SpecialFolder folder = Environment.Is64BitOperatingSystem ? Environment.SpecialFolder.ProgramFilesX86 : Environment.SpecialFolder.ProgramFiles;
@@ -1987,8 +1963,7 @@ public void TestGenerateProgramFiles32()
         /// <summary>
         /// Verify we get the correct reference assembly path out of the framework location helper
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "No ProgramFiles known location outside Windows"
+        [WindowsOnlyFact(additionalMessage: "No ProgramFiles known location outside Windows.")]
         public void TestGeneratedReferenceAssemblyPath()
         {
             string programFiles32 = FrameworkLocationHelper.GenerateProgramFiles32();
@@ -2209,7 +2184,6 @@ public void GetPathToStandardLibraries64Bit35()
         /// We expect to always get the same path which is returned by GetPathToReferenceAssemblies.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void GetPathToStandardLibraries64Bit40()
         {
             IList<string> referencePaths = ToolLocationHelper.GetPathToReferenceAssemblies(new FrameworkNameVersioning(".NETFramework", new Version("4.0")));
@@ -2476,8 +2450,7 @@ public void GetAssemblyFoldersExInfoTestNullTargetRuntimeVersion()
         /// <summary>
         /// Verify we can get a list of directories out of the public API.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetAssemblyFoldersExInfoTest()
         {
             SetupAssemblyFoldersExTestConditionRegistryKey();
@@ -3113,9 +3086,7 @@ public void TestGetExtensionSDKLocation()
         /// Verify we do not get any resolved paths when we pass in a root which is too long
         ///
         /// </summary>
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
+        [WindowsFullFrameworkOnlyFact]
         public void ResolveFromDirectoryPathTooLong()
         {
             Should.Throw<PathTooLongException>(() =>
@@ -3135,9 +3106,7 @@ public void ResolveFromDirectoryPathTooLong()
         /// <summary>
         /// Verify we get no resolved paths when we pass in a root with invalid chars
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // No invalid characters on Unix
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486")]
+        [WindowsFullFrameworkOnlyFact(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486. No invalid characters on Unix.")]
         public void ResolveFromDirectoryInvalidChar()
         {
             var targetPlatform = new Dictionary<TargetPlatformSDK, TargetPlatformSDK>();
@@ -3175,8 +3144,7 @@ public void VerifySDKManifestWithNullOrEmptyParameter()
         /// Verify SDKManifest defaults values for MaxPlatformVersion, MinOSVersion, MaxOSVersion when these are not
         /// present in the manifest and the SDK is a framework extension SDK
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyFrameworkSdkWithOldManifest()
         {
             string tmpRootDirectory = Path.GetTempPath();
@@ -3732,7 +3700,6 @@ public void VerifyGetInstalledSDKLocations2()
         /// Setup some fake entries in the registry and verify we get the correct sdk from there.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyGetInstalledSDKLocations3()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "VerifyGetInstalledSDKLocations3");
@@ -3835,7 +3802,6 @@ public void VerifyGetInstalledSDKLocations3()
         /// get the expected set out.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ResolveSDKFromDirectory()
         {
             var paths = new List<string> { _fakeStructureRoot, _fakeStructureRoot2 };
@@ -3907,14 +3873,9 @@ public void ResolveSDKFromDirectory()
         /// Verify based on a fake directory structure with some good directories and some invalid ones at each level that we
         /// get the expected set out.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact("No registry unless under Windows.")]
         public void ResolveSDKFromRegistry()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                return; // "No registry unless under Windows"
-            }
-
             var targetPlatforms = new Dictionary<TargetPlatformSDK, TargetPlatformSDK>();
 
             ToolLocationHelper.GatherSDKsFromRegistryImpl(targetPlatforms, "Software\\Microsoft\\MicrosoftSDks", RegistryView.Registry32, RegistryHive.CurrentUser, getRegistrySubKeyNames, getRegistrySubKeyDefaultValue, _openBaseKey, File.Exists);
@@ -3962,7 +3923,6 @@ public void ResolveSDKFromRegistry()
         /// and make sure we get the expected results.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ResolveSDKFromRegistryAndDisk()
         {
             var targetPlatforms = new Dictionary<TargetPlatformSDK, TargetPlatformSDK>();
@@ -4147,15 +4107,13 @@ public void GetALLTargetPlatformSDKs()
         /// <summary>
         /// Verify that the list of platforms is empty if we ask for an sdk that is not installed.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void VerifyGetFoldersInVSInstalls_Unix()
         {
             ToolLocationHelper.GetFoldersInVSInstalls(null, null, "relativePath").Count().ShouldBe(0);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyFindRootFolderWhereAllFilesExist()
         {
             // create directories and files in them
@@ -4195,7 +4153,6 @@ public void VerifyFindRootFolderWhereAllFilesExist()
         /// Verify that the GetPlatformSDKPropsFileLocation method can be correctly called for pre-OneCore SDKs during evaluation time as a msbuild function.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyGetPreOneCoreSDKPropsLocation()
         {
             // This is the mockup layout for SDKs before One Core SDK.
@@ -4271,7 +4228,6 @@ public void VerifyGetPreOneCoreSDKPropsLocation()
         /// Verify that the GetPlatformSDKPropsFileLocation method can be correctly called for OneCore SDK during evaluation time as a msbuild function.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void VerifyGetOneCoreSDKPropsLocation()
         {
             // This is the mockup layout for One Core SDK.
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index b36c5d2ba11..c8f9fe6e4a0 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -203,7 +203,6 @@ public void HandleExecutionErrorsWhenToolDoesntLogError()
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void HandleExecutionErrorsWhenToolLogsError()
         {
             using (MyTool t = new MyTool())
@@ -340,7 +339,6 @@ public void ToolExeWinsOverToolName()
         /// of the regular tool name
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void ToolExeIsFoundOnToolPath()
         {
             string shellName = NativeMethodsShared.IsWindows ? "cmd.exe" : "sh";
@@ -390,7 +388,6 @@ public void TaskNotFoundOnPath()
         /// Task is found on path.
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void TaskFoundOnPath()
         {
             using (MyTool t = new MyTool())
@@ -510,7 +507,6 @@ public void ToolTaskCanChangeCanonicalErrorFormat()
         /// Passing env vars through the tooltask public property
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EnvironmentVariablesToToolTask()
         {
             MyTool task = new MyTool();
@@ -542,7 +538,6 @@ public void EnvironmentVariablesToToolTask()
         /// Equals sign in value
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EnvironmentVariablesToToolTaskEqualsSign()
         {
             MyTool task = new MyTool();
@@ -603,7 +598,6 @@ public void EnvironmentVariablesToToolTaskInvalid3()
         /// Not set should not wipe out other env vars
         /// </summary>
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
         public void EnvironmentVariablesToToolTaskNotSet()
         {
             MyTool task = new MyTool();
diff --git a/src/Xunit.NetCore.Extensions/CustomXunitAttributesUtilities.cs b/src/Xunit.NetCore.Extensions/CustomXunitAttributesUtilities.cs
new file mode 100644
index 00000000000..5be9624189f
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/CustomXunitAttributesUtilities.cs
@@ -0,0 +1,21 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Xunit.NetCore.Extensions
+{
+    public static class CustomXunitAttributesUtilities
+    {
+#if NETFRAMEWORK
+        public static bool IsBuiltAgainstDotNet => false;
+
+        public static bool IsBuiltAgainstNetFramework => true;
+#elif NET
+        public static bool IsBuiltAgainstDotNet => true;
+
+        public static bool IsBuiltAgainstNetFramework => false;
+#endif
+
+        public static string AppendAdditionalMessage(this string message, string? additionalMessage)
+            => !string.IsNullOrWhiteSpace(additionalMessage) ? $"{message} {additionalMessage}" : message;
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/DotNetOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/DotNetOnlyFactAttribute.cs
new file mode 100644
index 00000000000..b1b0fb8baa4
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/DotNetOnlyFactAttribute.cs
@@ -0,0 +1,23 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    ///  This test should be run only on .NET (or .NET Core).
+    /// </summary>
+    public class DotNetOnlyFactAttribute : FactAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="DotNetOnlyFactAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public DotNetOnlyFactAttribute(string? additionalMessage = null)
+        {
+            if (!CustomXunitAttributesUtilities.IsBuiltAgainstDotNet)
+            {
+                this.Skip = "This test only runs on .NET.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/DotNetOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/DotNetOnlyTheoryAttribute.cs
new file mode 100644
index 00000000000..b6ee768534b
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/DotNetOnlyTheoryAttribute.cs
@@ -0,0 +1,23 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    ///  This test should be run only on .NET (or .NET Core).
+    /// </summary>
+    public class DotNetOnlyTheoryAttribute : TheoryAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="DotNetOnlyTheoryAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public DotNetOnlyTheoryAttribute(string? additionalMessage = null)
+        {
+            if (!CustomXunitAttributesUtilities.IsBuiltAgainstDotNet)
+            {
+                this.Skip = "This test only runs on .NET.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs
new file mode 100644
index 00000000000..f3878ef0de3
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs
@@ -0,0 +1,25 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    /// This test should be run only on Unix (Linux, OSX platforms).
+    /// </summary>
+    public class UnixOnlyFactAttribute : FactAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="UnixOnlyFactAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public UnixOnlyFactAttribute(string? additionalMessage = null)
+        {
+            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test requires Unix to run.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs
new file mode 100644
index 00000000000..f0a1769882e
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs
@@ -0,0 +1,25 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    /// This test should be run only on Unix (Linux, OSX platforms).
+    /// </summary>
+    public class UnixOnlyTheoryAttribute : TheoryAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="UnixOnlyTheoryAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public UnixOnlyTheoryAttribute(string? additionalMessage = null)
+        {
+            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test requires Unix to run.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyFactAttribute.cs
new file mode 100644
index 00000000000..4caa40a3198
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyFactAttribute.cs
@@ -0,0 +1,30 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    ///  This test should be run only on Windows on full .NET Framework.
+    /// </summary>
+    public class WindowsFullFrameworkOnlyFactAttribute : FactAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="WindowsFullFrameworkOnlyFactAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public WindowsFullFrameworkOnlyFactAttribute(string? additionalMessage = null)
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test only runs on Windows on full framework.".AppendAdditionalMessage(additionalMessage);
+                return;
+            }
+            if (!CustomXunitAttributesUtilities.IsBuiltAgainstNetFramework)
+            {
+                this.Skip = "This test only runs on full framework.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyTheoryAttribute.cs
new file mode 100644
index 00000000000..952bf0d7250
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyTheoryAttribute.cs
@@ -0,0 +1,31 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    ///  This test should be run only on Windows on full .NET Framework.
+    /// </summary>
+    public class WindowsFullFrameworkOnlyTheoryAttribute : TheoryAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="WindowsFullFrameworkOnlyTheoryAttribute"/> class.
+        /// Creates the attribute.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public WindowsFullFrameworkOnlyTheoryAttribute(string? additionalMessage = null)
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test only runs on Windows on full framework.".AppendAdditionalMessage(additionalMessage);
+                return;
+            }
+            if (!CustomXunitAttributesUtilities.IsBuiltAgainstNetFramework)
+            {
+                this.Skip = "This test only runs on full framework.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs
new file mode 100644
index 00000000000..72f2378ad02
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs
@@ -0,0 +1,25 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    /// This test should be run only on Windows.
+    /// </summary>
+    public class WindowsOnlyFactAttribute : FactAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="WindowsOnlyFactAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public WindowsOnlyFactAttribute(string? additionalMessage = null)
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test requires Windows to run.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs
new file mode 100644
index 00000000000..dfc2be0b220
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs
@@ -0,0 +1,25 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    /// This test should be run only on Windows.
+    /// </summary>
+    public class WindowsOnlyTheoryAttribute : TheoryAttribute
+    {
+        /// <summary>
+        /// Initializes a new instance of the <see cref="WindowsOnlyTheoryAttribute"/> class.
+        /// </summary>
+        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
+        public WindowsOnlyTheoryAttribute(string? additionalMessage = null)
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test requires Windows to run.".AppendAdditionalMessage(additionalMessage);
+            }
+        }
+    }
+}
