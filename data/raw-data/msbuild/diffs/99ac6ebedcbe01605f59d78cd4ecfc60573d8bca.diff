diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index 6bb58a189b1..26100d3ab06 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -4,8 +4,8 @@ Param(
   [string] $destination,
   [ValidateSet('Debug','Release')]
   [string] $configuration = "Debug",
-  [ValidateSet('Core','Desktop')]
-  [string] $runtime = "Desktop"
+  [ValidateSet('Core','Desktop', 'Detect', 'Full')]
+  [string] $runtime = "Detect"
 )
 
 Set-StrictMode -Version "Latest"
@@ -50,6 +50,20 @@ $BackupFolder = New-Item (Join-Path $destination -ChildPath "Backup-$(Get-Date -
 Write-Verbose "Copying $configuration MSBuild to $destination"
 Write-Host "Existing MSBuild assemblies backed up to $BackupFolder"
 
+if ($runtime -eq "Detect") {
+    if ($destination -like "*dotnet*sdk*") {
+        $runtime = "Core"
+        Write-Host "Detected path that looks like an sdk. Writing .NET Core assemblies."
+    }
+    else {
+        $runtime = "Desktop"
+        Write-Host "Detected path that does not look like an sdk. Writing .NET Framework assemblies."
+    }
+}
+else if ($runtime -eq "Full") {
+    $runtime = "Desktop"
+}
+
 if ($runtime -eq "Desktop") {
     $targetFramework = "net472"
 } else {
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
index 481da772e2f..7f390cdf98c 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// <summary>
     /// A task used for testing the TaskExecutionHost, which reports what the TaskExecutionHost does to it.
     /// </summary>
-    internal class TaskBuilderTestTask : IGeneratedTask
+    public class TaskBuilderTestTask : IGeneratedTask
     {
         /// <summary>
         /// The task host.
@@ -84,7 +84,7 @@ public bool BoolParam
             set
             {
                 _boolOutput = value;
-                _testTaskHost.ParameterSet("BoolParam", value);
+                _testTaskHost?.ParameterSet("BoolParam", value);
             }
         }
 
@@ -96,7 +96,7 @@ public bool[] BoolArrayParam
             set
             {
                 _boolArrayOutput = value;
-                _testTaskHost.ParameterSet("BoolArrayParam", value);
+                _testTaskHost?.ParameterSet("BoolArrayParam", value);
             }
         }
 
@@ -108,7 +108,7 @@ public int IntParam
             set
             {
                 _intOutput = value;
-                _testTaskHost.ParameterSet("IntParam", value);
+                _testTaskHost?.ParameterSet("IntParam", value);
             }
         }
 
@@ -120,7 +120,7 @@ public int[] IntArrayParam
             set
             {
                 _intArrayOutput = value;
-                _testTaskHost.ParameterSet("IntArrayParam", value);
+                _testTaskHost?.ParameterSet("IntArrayParam", value);
             }
         }
 
@@ -132,7 +132,7 @@ public string StringParam
             set
             {
                 _stringOutput = value;
-                _testTaskHost.ParameterSet("StringParam", value);
+                _testTaskHost?.ParameterSet("StringParam", value);
             }
         }
 
@@ -144,7 +144,7 @@ public string[] StringArrayParam
             set
             {
                 _stringArrayOutput = value;
-                _testTaskHost.ParameterSet("StringArrayParam", value);
+                _testTaskHost?.ParameterSet("StringArrayParam", value);
             }
         }
 
@@ -156,7 +156,7 @@ public ITaskItem ItemParam
             set
             {
                 _itemOutput = value;
-                _testTaskHost.ParameterSet("ItemParam", value);
+                _testTaskHost?.ParameterSet("ItemParam", value);
             }
         }
 
@@ -168,7 +168,7 @@ public ITaskItem[] ItemArrayParam
             set
             {
                 _itemArrayOutput = value;
-                _testTaskHost.ParameterSet("ItemArrayParam", value);
+                _testTaskHost?.ParameterSet("ItemArrayParam", value);
             }
         }
 
@@ -181,7 +181,7 @@ public bool ExecuteReturnParam
             set
             {
                 _executeReturnValue = value;
-                _testTaskHost.ParameterSet("ExecuteReturnParam", value);
+                _testTaskHost?.ParameterSet("ExecuteReturnParam", value);
             }
         }
 
@@ -193,7 +193,7 @@ public bool BoolOutput
         {
             get
             {
-                _testTaskHost.OutputRead("BoolOutput", _boolOutput);
+                _testTaskHost?.OutputRead("BoolOutput", _boolOutput);
                 return _boolOutput;
             }
         }
@@ -206,7 +206,7 @@ public bool[] BoolArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("BoolArrayOutput", _boolArrayOutput);
+                _testTaskHost?.OutputRead("BoolArrayOutput", _boolArrayOutput);
                 return _boolArrayOutput;
             }
         }
@@ -219,7 +219,7 @@ public int IntOutput
         {
             get
             {
-                _testTaskHost.OutputRead("IntOutput", _intOutput);
+                _testTaskHost?.OutputRead("IntOutput", _intOutput);
                 return _intOutput;
             }
         }
@@ -232,7 +232,7 @@ public int[] IntArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("IntArrayOutput", _intArrayOutput);
+                _testTaskHost?.OutputRead("IntArrayOutput", _intArrayOutput);
                 return _intArrayOutput;
             }
         }
@@ -245,7 +245,7 @@ public string StringOutput
         {
             get
             {
-                _testTaskHost.OutputRead("StringOutput", _stringOutput);
+                _testTaskHost?.OutputRead("StringOutput", _stringOutput);
                 return _stringOutput;
             }
         }
@@ -258,7 +258,7 @@ public string EmptyStringOutput
         {
             get
             {
-                _testTaskHost.OutputRead("EmptyStringOutput", null);
+                _testTaskHost?.OutputRead("EmptyStringOutput", null);
                 return String.Empty;
             }
         }
@@ -271,7 +271,7 @@ public string[] EmptyStringArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("EmptyStringArrayOutput", null);
+                _testTaskHost?.OutputRead("EmptyStringArrayOutput", null);
                 return Array.Empty<string>();
             }
         }
@@ -284,7 +284,7 @@ public string NullStringOutput
         {
             get
             {
-                _testTaskHost.OutputRead("NullStringOutput", null);
+                _testTaskHost?.OutputRead("NullStringOutput", null);
                 return null;
             }
         }
@@ -297,7 +297,7 @@ public ITaskItem NullITaskItemOutput
         {
             get
             {
-                _testTaskHost.OutputRead("NullITaskItemOutput", null);
+                _testTaskHost?.OutputRead("NullITaskItemOutput", null);
                 return null;
             }
         }
@@ -310,7 +310,7 @@ public string[] NullStringArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("NullStringArrayOutput", null);
+                _testTaskHost?.OutputRead("NullStringArrayOutput", null);
                 return null;
             }
         }
@@ -323,7 +323,7 @@ public ITaskItem[] NullITaskItemArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("NullITaskItemArrayOutput", null);
+                _testTaskHost?.OutputRead("NullITaskItemArrayOutput", null);
                 return null;
             }
         }
@@ -336,7 +336,7 @@ public string[] StringArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("StringArrayOutput", _stringArrayOutput);
+                _testTaskHost?.OutputRead("StringArrayOutput", _stringArrayOutput);
                 return _stringArrayOutput;
             }
         }
@@ -349,7 +349,7 @@ public ITaskItem ItemOutput
         {
             get
             {
-                _testTaskHost.OutputRead("ItemOutput", _itemOutput);
+                _testTaskHost?.OutputRead("ItemOutput", _itemOutput);
                 return _itemOutput;
             }
         }
@@ -362,7 +362,7 @@ public ITaskItem[] ItemArrayOutput
         {
             get
             {
-                _testTaskHost.OutputRead("ItemArrayOutput", _itemArrayOutput);
+                _testTaskHost?.OutputRead("ItemArrayOutput", _itemArrayOutput);
                 return _itemArrayOutput;
             }
         }
@@ -375,52 +375,13 @@ public ITaskItem[] ItemArrayNullOutput
         {
             get
             {
-                _testTaskHost.OutputRead("ItemArrayNullOutput", _itemArrayOutput);
+                _testTaskHost?.OutputRead("ItemArrayNullOutput", _itemArrayOutput);
                 return null;
             }
         }
 
-        /// <summary>
-        /// An object output
-        /// </summary>
         [Output]
-        public object ObjectOutput
-        {
-            get
-            {
-                object output = new object();
-                _testTaskHost.OutputRead("ObjectOutput", output);
-                return output;
-            }
-        }
-
-        /// <summary>
-        /// An object array output
-        /// </summary>
-        [Output]
-        public object[] ObjectArrayOutput
-        {
-            get
-            {
-                object[] output = new object[] { new object(), new object() };
-                _testTaskHost.OutputRead("ObjectArrayOutput", output);
-                return output;
-            }
-        }
-
-        /// <summary>
-        /// An arraylist output
-        /// </summary>
-        [Output]
-        public ArrayList ArrayListOutput
-        {
-            get
-            {
-                ArrayList output = new ArrayList();
-                _testTaskHost.OutputRead("ArrayListOutput", output);
-                return output;
-            }
-        }
+        public TargetBuiltReason EnumOutput => TargetBuiltReason.BeforeTargets;
 
         #region ITask Members
 
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 4ee43919d09..69c142d7712 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -1,11 +1,14 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 using System;
 using System.Diagnostics;
 using Microsoft.Build.Execution;
 using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.BackEnd;
+
 using Shouldly;
 using Xunit;
+using Xunit.Abstractions;
 
 #nullable disable
 
@@ -13,6 +16,13 @@ namespace Microsoft.Build.Engine.UnitTests.BackEnd
 {
     public sealed class TaskHostFactory_Tests
     {
+        ITestOutputHelper _output;
+
+        public TaskHostFactory_Tests(ITestOutputHelper testOutputHelper)
+        {
+            _output = testOutputHelper;
+        }
+
         [Fact]
         [Trait("Category", "mono-osx-failing")]
         public void TaskNodesDieAfterBuild()
@@ -47,5 +57,38 @@ public void TaskNodesDieAfterBuild()
                 }
             }
         }
+
+        [Fact]
+        public void VariousParameterTypesCanBeTransmittedToAndRecievedFromTaskHost()
+        {
+            using TestEnvironment env = TestEnvironment.Create(_output);
+
+            string projectContents = $@"
+<Project>
+    <UsingTask TaskName=""{nameof(TaskBuilderTestTask)}"" AssemblyFile=""{typeof(TaskBuilderTestTask).Assembly.Location}"" TaskFactory=""TaskHostFactory"" />
+    <Target Name='{nameof(VariousParameterTypesCanBeTransmittedToAndRecievedFromTaskHost)}'>
+        <{nameof(TaskBuilderTestTask)}
+            ExecuteReturnParam=""true""
+            BoolParam=""true""
+            BoolArrayParam=""false;true;false""
+            IntParam=""314""
+            IntArrayParam=""42;67;98""
+            StringParam=""stringParamInput""
+            StringArrayParam=""stringArrayParamInput1;stringArrayParamInput2;stringArrayParamInput3"">
+
+            <Output PropertyName=""BoolOutput"" TaskParameter=""BoolOutput"" />
+            <Output PropertyName=""BoolArrayOutput"" TaskParameter=""BoolArrayOutput"" />
+            <Output PropertyName=""IntOutput"" TaskParameter=""IntOutput"" />
+            <Output PropertyName=""IntArrayOutput"" TaskParameter=""IntArrayOutput"" />
+            <Output PropertyName=""EnumOutput"" TaskParameter=""EnumOutput"" />
+            <Output PropertyName=""StringOutput"" TaskParameter=""StringOutput"" />
+            <Output PropertyName=""StringArrayOutput"" TaskParameter=""StringArrayOutput"" />
+        </{nameof(TaskBuilderTestTask)}>
+    </Target>
+</Project>";
+            TransientTestProjectWithFiles project = env.CreateTestProjectWithFiles(projectContents);
+            ProjectInstance projectInstance = new(project.ProjectFile);
+            projectInstance.Build(new[] { new MockLogger(env.Output) }).ShouldBeTrue();
+            }
     }
 }
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 06324b51b52..0c3c65b0f20 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -7,6 +7,7 @@
 using System.Linq;
 using System.Net;
 using System.Threading;
+using System.Threading.Tasks;
 using System.Xml;
 
 using Microsoft.Build.Collections;
@@ -4243,7 +4244,7 @@ public void VerifyDTDProcessingIsDisabled()
         /// If DTD processing is disabled, the server should not receive any connection request.
         /// </summary>
         [Fact]
-        public void VerifyDTDProcessingIsDisabled2()
+        public async void VerifyDTDProcessingIsDisabled2()
         {
             string projectContents = ObjectModelHelpers.CleanupFileContents(@"<?xml version=""1.0"" encoding=""utf-8""?>
                                 <!DOCTYPE Project [
@@ -4258,9 +4259,9 @@ public void VerifyDTDProcessingIsDisabled2()
                                     </Target>
                                 </Project>");
 
-            string projectDirectory = Path.Combine(Path.GetTempPath(), "VerifyDTDProcessingIsDisabled");
+            string projectDirectory = Path.Combine(Path.GetTempPath(), "VerifyDTDProcessingIsDisabled2");
 
-            Thread t = new Thread(HttpServerThread);
+            Thread t = new(HttpServerThread);
             t.IsBackground = true;
             t.Start();
 
@@ -4268,7 +4269,7 @@ public void VerifyDTDProcessingIsDisabled2()
             {
                 if (Directory.Exists(projectDirectory))
                 {
-                    FileUtilities.DeleteWithoutTrailingBackslash(projectDirectory, true /* recursive delete */);
+                    FileUtilities.DeleteWithoutTrailingBackslash(projectDirectory, recursive: true);
                 }
 
                 Directory.CreateDirectory(projectDirectory);
@@ -4277,18 +4278,20 @@ public void VerifyDTDProcessingIsDisabled2()
 
                 File.WriteAllText(projectFilename, projectContents);
 
-                Project project = new Project(projectFilename);
+                Project project = new(projectFilename);
 
-                MockLogger logger = new MockLogger();
+                MockLogger logger = new();
                 project.Build(logger);
             }
             finally
             {
-                Thread.Sleep(500);
+                await Task.Delay(500);
+                t.IsAlive.ShouldBeTrue();
+                t.Abort();
+                await Task.Delay(500);
 
                 // Expect server to be alive and hung up unless a request originating from DTD processing was sent
                 _httpListenerThreadException.ShouldBeNull();
-                t.IsAlive.ShouldBeTrue();
             }
         }
 #endif
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index dbf59ff40a9..458c6956422 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -1666,34 +1666,41 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                         // Cannot have a null or empty name for the type after expansion.
                         ProjectErrorUtilities.VerifyThrowInvalidProject
                         (
-                        !String.IsNullOrEmpty(expandedType),
-                        parameter.ParameterTypeLocation,
-                        "InvalidEvaluatedAttributeValue",
-                        expandedType,
-                        parameter.ParameterType,
-                        XMakeAttributes.parameterType,
-                        XMakeElements.usingTaskParameter
+                            !String.IsNullOrEmpty(expandedType),
+                            parameter.ParameterTypeLocation,
+                            "InvalidEvaluatedAttributeValue",
+                            expandedType,
+                            parameter.ParameterType,
+                            XMakeAttributes.parameterType,
+                            XMakeElements.usingTaskParameter
                         );
 
-                        // Try and get the type directly 
-                        Type paramType = Type.GetType(expandedType);
-
-                        // The type could not be got directly try and see if the type can be found by appending the FrameworkAssemblyName to it.
-                        if (paramType == null)
+                        Type paramType;
+                        if (expandedType.StartsWith("Microsoft.Build.Framework.", StringComparison.OrdinalIgnoreCase) && !expandedType.Contains(","))
                         {
-                            paramType = Type.GetType(expandedType + "," + typeof(ITaskItem).GetTypeInfo().Assembly.FullName, false /* don't throw on error */, true /* case-insensitive */);
+                            // This is workaround for internal bug https://devdiv.visualstudio.com/DevDiv/_workitems/edit/1448821
+                            // Visual Studio can load different version of Microsoft.Build.Framework.dll and non fully classified type could be resolved from it 
+                            // which cause InvalidProjectFileException with "UnsupportedTaskParameterTypeError" message.
+                            // Another way to address this is to load types from compiled assembly - that would be more robust solution but also much more complex and risky code changes.
+                            paramType = Type.GetType(expandedType + "," + typeof(ITaskItem).GetTypeInfo().Assembly.FullName, false /* don't throw on error */, true /* case-insensitive */) ??
+                                        Type.GetType(expandedType);
+                        }
+                        else
+                        {
+                            paramType = Type.GetType(expandedType) ??
+                                        Type.GetType(expandedType + "," + typeof(ITaskItem).GetTypeInfo().Assembly.FullName, false /* don't throw on error */, true /* case-insensitive */);
+                        }
 
-                            ProjectErrorUtilities.VerifyThrowInvalidProject
-                            (
-                             paramType != null,
-                             parameter.ParameterTypeLocation,
-                             "InvalidEvaluatedAttributeValue",
-                             expandedType,
-                             parameter.ParameterType,
-                             XMakeAttributes.parameterType,
+                        ProjectErrorUtilities.VerifyThrowInvalidProject
+                        (
+                            paramType != null,
+                            parameter.ParameterTypeLocation,
+                            "InvalidEvaluatedAttributeValue",
+                            expandedType,
+                            parameter.ParameterType,
+                            XMakeAttributes.parameterType,
                             XMakeElements.usingTaskParameter
-                            );
-                        }
+                        );
 
                         bool output;
                         string expandedOutput = expander.ExpandIntoStringLeaveEscaped(parameter.Output, expanderOptions, parameter.OutputLocation);
@@ -1702,19 +1709,19 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                         {
                             ProjectErrorUtilities.ThrowInvalidProject
                             (
-                             parameter.OutputLocation,
-                             "InvalidEvaluatedAttributeValue",
-                             expandedOutput,
-                             parameter.Output,
-                             XMakeAttributes.output,
-                             XMakeElements.usingTaskParameter
+                                parameter.OutputLocation,
+                                "InvalidEvaluatedAttributeValue",
+                                expandedOutput,
+                                parameter.Output,
+                                XMakeAttributes.output,
+                                XMakeElements.usingTaskParameter
                             );
                         }
 
                         if (
                             (!output && (!TaskParameterTypeVerifier.IsValidInputParameter(paramType))) ||
                             (output && !TaskParameterTypeVerifier.IsValidOutputParameter(paramType))
-                           )
+                        )
                         {
                             ProjectErrorUtilities.ThrowInvalidProject
                             (
@@ -1723,7 +1730,7 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                                 paramType.FullName,
                                 parameter.ParameterType,
                                 parameter.Name
-                             );
+                            );
                         }
 
                         bool required;
@@ -1733,12 +1740,12 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                         {
                             ProjectErrorUtilities.ThrowInvalidProject
                             (
-                             parameter.RequiredLocation,
-                             "InvalidEvaluatedAttributeValue",
-                             expandedRequired,
-                             parameter.Required,
-                             XMakeAttributes.required,
-                             XMakeElements.usingTaskParameter
+                                parameter.RequiredLocation,
+                                "InvalidEvaluatedAttributeValue",
+                                expandedRequired,
+                                parameter.Required,
+                                XMakeAttributes.required,
+                                XMakeElements.usingTaskParameter
                             );
                         }
 
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index b1540445884..73888fa88a0 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -149,6 +149,26 @@ public void Translate(ref int value)
                 value = _reader.ReadInt32();
             }
 
+            /// <summary>
+            /// Translates an <see langword="int"/> array.
+            /// </summary>
+            /// <param name="array">The array to be translated.</param>
+            public void Translate(ref int[] array)
+            {
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                array = new int[count];
+
+                for (int i = 0; i < count; i++)
+                {
+                    array[i] = _reader.ReadInt32();
+                }
+            }
+
             /// <summary>
             /// Translates a long.
             /// </summary>
@@ -811,6 +831,26 @@ public void Translate(ref int value)
                 _writer.Write(value);
             }
 
+            /// <summary>
+            /// Translates an <see langword="int"/> array.
+            /// </summary>
+            /// <param name="array">The array to be translated.</param>
+            public void Translate(ref int[] array)
+            {
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = array.Length;
+                _writer.Write(count);
+
+                for (int i = 0; i < count; i++)
+                {
+                    _writer.Write(array[i]);
+                }
+            }
+
             /// <summary>
             /// Translates a long.
             /// </summary>
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index 61dc02cc3a0..42274c2da1d 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -128,6 +128,12 @@ BinaryWriter Writer
         /// <param name="value">The value to be translated.</param>
         void Translate(ref int value);
 
+        /// <summary>
+        /// Translates an <see langword="int"/> array.
+        /// </summary>
+        /// <param name="array">The array to be translated.</param>
+        void Translate(ref int[] array);
+
         /// <summary>
         /// Translates a long.
         /// </summary>
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 515500a98b0..c7e900625b8 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Globalization;
 using System.Linq;
 using System.Reflection;
 using System.Security;
@@ -16,7 +17,7 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// Type of parameter, used to figure out how to serialize it. 
+    /// Type of parameter, used to figure out how to serialize it.
     /// </summary>
     internal enum TaskParameterType
     {
@@ -35,18 +36,28 @@ internal enum TaskParameterType
         /// </summary>
         StringArray,
 
+        /// <summary>
+        /// Parameter is <c>true</c> or <c>false</c>.
+        /// </summary>
+        Bool,
+
+        /// <summary>
+        /// Parameter is an <see langword="int"/>.
+        /// </summary>
+        Int,
+
         /// <summary>
         /// Parameter is a value type.  Note:  Must be serializable
         /// </summary>
         ValueType,
 
         /// <summary>
-        /// Parameter is an array of value types.  Note:  Must be serializable. 
+        /// Parameter is an array of value types.  Note:  Must be serializable.
         /// </summary>
         ValueTypeArray,
 
         /// <summary>
-        /// Parameter is an ITaskItem 
+        /// Parameter is an ITaskItem
         /// </summary>
         ITaskItem,
 
@@ -56,15 +67,15 @@ internal enum TaskParameterType
         ITaskItemArray,
 
         /// <summary>
-        /// An invalid parameter -- the value of this parameter contains the exception 
-        /// that is thrown when trying to access it. 
+        /// An invalid parameter -- the value of this parameter contains the exception
+        /// that is thrown when trying to access it.
         /// </summary>
         Invalid
     }
 
     /// <summary>
-    /// Wrapper for task parameters, to allow proper serialization even 
-    /// in cases where the parameter is not .NET serializable. 
+    /// Wrapper for task parameters, to allow proper serialization even
+    /// in cases where the parameter is not .NET serializable.
     /// </summary>
     internal class TaskParameter :
 #if FEATURE_APPDOMAIN
@@ -103,11 +114,12 @@ public TaskParameter(object wrappedParameter)
                 return;
             }
 
-            // It's not null or invalid, so it should be a valid parameter type. 
+            // It's not null or invalid, so it should be a valid parameter type.
             ErrorUtilities.VerifyThrow
                 (
                     TaskParameterTypeVerifier.IsValidInputParameter(wrappedParameterType) || TaskParameterTypeVerifier.IsValidOutputParameter(wrappedParameterType),
-                    "How did we manage to get a task parameter that isn't a valid parameter type?"
+                    "How did we manage to get a task parameter of type {0} that isn't a valid parameter type?",
+                    wrappedParameterType
                 );
 
             if (wrappedParameterType.IsArray)
@@ -156,6 +168,28 @@ public TaskParameter(object wrappedParameter)
                     _parameterType = TaskParameterType.ITaskItem;
                     _wrappedParameter = CreateNewTaskItemFrom((ITaskItem)wrappedParameter);
                 }
+                // Preserve enums as strings: the enum type itself may not
+                // be loaded on the other side of the serialization, but
+                // we would convert to string anyway after pulling the
+                // task output into a property or item.
+                else if (wrappedParameterType.IsEnum)
+                {
+                    _parameterType = TaskParameterType.String;
+                    _wrappedParameter = (string)Convert.ChangeType(wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+                }
+                    // Also stringify known common value types, to avoid calling
+                    // TranslateDotNet when they'll just be stringified on the
+                    // output side
+                else if (wrappedParameterType == typeof(bool))
+                {
+                    _parameterType = TaskParameterType.Bool;
+                    _wrappedParameter = wrappedParameter;
+                }
+                else if (wrappedParameterType == typeof(int))
+                {
+                    _parameterType = TaskParameterType.Int;
+                    _wrappedParameter = wrappedParameter;
+                }
                 else if (wrappedParameterType.GetTypeInfo().IsValueType)
                 {
                     _parameterType = TaskParameterType.ValueType;
@@ -196,7 +230,7 @@ public object WrappedParameter
         }
 
         /// <summary>
-        /// TaskParameter's ToString should just pass through to whatever it's wrapping. 
+        /// TaskParameter's ToString should just pass through to whatever it's wrapping.
         /// </summary>
         public override string ToString()
         {
@@ -204,7 +238,7 @@ public override string ToString()
         }
 
         /// <summary>
-        /// Serialize / deserialize this item. 
+        /// Serialize / deserialize this item.
         /// </summary>
         public void Translate(ITranslator translator)
         {
@@ -225,6 +259,24 @@ public void Translate(ITranslator translator)
                     translator.Translate(ref stringArrayParam);
                     _wrappedParameter = stringArrayParam;
                     break;
+                case TaskParameterType.Bool:
+                    bool boolParam = _wrappedParameter switch
+                    {
+                        bool hadValue => hadValue,
+                        _ => default,
+                    };
+                    translator.Translate(ref boolParam);
+                    _wrappedParameter = boolParam;
+                    break;
+                case TaskParameterType.Int:
+                    int intParam = _wrappedParameter switch
+                    {
+                        int hadValue => hadValue,
+                        _ => default,
+                    };
+                    translator.Translate(ref intParam);
+                    _wrappedParameter = intParam;
+                    break;
                 case TaskParameterType.ValueType:
                 case TaskParameterType.ValueTypeArray:
                     translator.TranslateDotNet(ref _wrappedParameter);
@@ -270,7 +322,7 @@ internal static TaskParameter FactoryForDeserialization(ITranslator translator)
         }
 
         /// <summary>
-        /// Creates a new ITaskItem with the contents of the old one. 
+        /// Creates a new ITaskItem with the contents of the old one.
         /// </summary>
         private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom)
         {
@@ -296,10 +348,10 @@ private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom)
             }
             else
             {
-                // If we don't have ITaskItem2 to fall back on, we have to make do with the fact that 
-                // CloneCustomMetadata, GetMetadata, & ItemSpec returns unescaped values, and 
-                // TaskParameterTaskItem's constructor expects escaped values, so escaping them all 
-                // is the closest approximation to correct we can get.  
+                // If we don't have ITaskItem2 to fall back on, we have to make do with the fact that
+                // CloneCustomMetadata, GetMetadata, & ItemSpec returns unescaped values, and
+                // TaskParameterTaskItem's constructor expects escaped values, so escaping them all
+                // is the closest approximation to correct we can get.
                 escapedItemSpec = EscapingUtilities.Escape(copyFrom.ItemSpec);
 
                 escapedDefiningProject = EscapingUtilities.EscapeWithCaching(copyFrom.GetMetadata(FileUtilities.ItemSpecModifiers.DefiningProjectFullPath));
@@ -321,7 +373,7 @@ private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom)
         }
 
         /// <summary>
-        /// Serialize / deserialize this item. 
+        /// Serialize / deserialize this item.
         /// </summary>
         private void TranslateITaskItemArray(ITranslator translator)
         {
@@ -358,7 +410,7 @@ private void TranslateITaskItemArray(ITranslator translator)
         }
 
         /// <summary>
-        /// Serialize / deserialize this item. 
+        /// Serialize / deserialize this item.
         /// </summary>
         private void TranslateITaskItem(ITranslator translator)
         {
@@ -402,8 +454,8 @@ private void WriteITaskItem(ITranslator translator, ITaskItem wrappedItem)
             }
             else
             {
-                // We know that the ITaskItem constructor expects an escaped string, and that ITaskItem.ItemSpec 
-                // is expected to be unescaped, so make sure we give the constructor what it wants. 
+                // We know that the ITaskItem constructor expects an escaped string, and that ITaskItem.ItemSpec
+                // is expected to be unescaped, so make sure we give the constructor what it wants.
                 escapedItemSpec = EscapingUtilities.Escape(wrappedItem.ItemSpec);
                 escapedDefiningProject = EscapingUtilities.EscapeWithCaching(wrappedItem.GetMetadata(FileUtilities.ItemSpecModifiers.DefiningProjectFullPath));
                 wrappedMetadata = wrappedItem.CloneCustomMetadata();
@@ -486,7 +538,7 @@ private bool TranslateNullable<T>(ITranslator translator, T value)
         }
 
         /// <summary>
-        /// Super simple ITaskItem derivative that we can use as a container for read items.  
+        /// Super simple ITaskItem derivative that we can use as a container for read items.
         /// </summary>
         private class TaskParameterTaskItem :
 #if FEATURE_APPDOMAIN
@@ -499,7 +551,7 @@ private class TaskParameterTaskItem :
 #endif
         {
             /// <summary>
-            /// The item spec 
+            /// The item spec
             /// </summary>
             private string _escapedItemSpec = null;
 
@@ -740,7 +792,7 @@ string ITaskItem2.GetMetadataValueEscaped(string metadataName)
             }
 
             /// <summary>
-            /// Sets the exact metadata value given to the metadata name requested. 
+            /// Sets the exact metadata value given to the metadata name requested.
             /// </summary>
             void ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue)
             {
@@ -748,7 +800,7 @@ void ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValu
             }
 
             /// <summary>
-            /// Returns a dictionary containing all metadata and their escaped forms.  
+            /// Returns a dictionary containing all metadata and their escaped forms.
             /// </summary>
             IDictionary ITaskItem2.CloneCustomMetadataEscaped()
             {
diff --git a/src/Shared/UnitTests/TaskParameter_Tests.cs b/src/Shared/UnitTests/TaskParameter_Tests.cs
index d726a685700..9fdb8aa1c8d 100644
--- a/src/Shared/UnitTests/TaskParameter_Tests.cs
+++ b/src/Shared/UnitTests/TaskParameter_Tests.cs
@@ -89,25 +89,25 @@ public void StringArrayParameter()
         /// Verifies that construction and serialization with a value type (integer) parameter is OK.
         /// </summary>
         [Fact]
-        public void ValueTypeParameter()
+        public void IntParameter()
         {
             TaskParameter t = new TaskParameter(1);
 
             Assert.Equal(1, t.WrappedParameter);
-            Assert.Equal(TaskParameterType.ValueType, t.ParameterType);
+            Assert.Equal(TaskParameterType.Int, t.ParameterType);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
             Assert.Equal(1, t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.ValueType, t2.ParameterType);
+            Assert.Equal(TaskParameterType.Int, t2.ParameterType);
         }
 
         /// <summary>
         /// Verifies that construction and serialization with a parameter that is an array of value types (ints) is OK.
         /// </summary>
         [Fact]
-        public void ValueTypeArrayParameter()
+        public void IntArrayParameter()
         {
             TaskParameter t = new TaskParameter(new int[] { 2, 15 });
 
@@ -131,6 +131,69 @@ public void ValueTypeArrayParameter()
             Assert.Equal(15, wrappedParameter2[1]);
         }
 
+        enum TestEnumForParameter
+        {
+            Something,
+            SomethingElse
+        }
+
+        [Fact]
+        public void EnumParameter()
+        {
+            TaskParameter t = new TaskParameter(TestEnumForParameter.SomethingElse);
+
+            Assert.Equal("SomethingElse", t.WrappedParameter);
+            Assert.Equal(TaskParameterType.String, t.ParameterType);
+
+            ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
+            TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            Assert.Equal("SomethingElse", t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.String, t2.ParameterType);
+        }
+
+        [Fact]
+        public void BoolParameter()
+        {
+            TaskParameter t = new TaskParameter(true);
+
+            Assert.Equal(true, t.WrappedParameter);
+            Assert.Equal(TaskParameterType.Bool, t.ParameterType);
+
+            ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
+            TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            Assert.Equal(true, t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.Bool, t2.ParameterType);
+        }
+
+        /// <summary>
+        /// Verifies that construction and serialization with a parameter that is an array of value types (ints) is OK.
+        /// </summary>
+        [Fact]
+        public void BoolArrayParameter()
+        {
+            TaskParameter t = new TaskParameter(new bool[] { false, true });
+
+            Assert.Equal(TaskParameterType.ValueTypeArray, t.ParameterType);
+
+            bool[] wrappedParameter = t.WrappedParameter as bool[];
+            Assert.NotNull(wrappedParameter);
+            Assert.Equal(2, wrappedParameter.Length);
+            Assert.False(wrappedParameter[0]);
+            Assert.True(wrappedParameter[1]);
+
+            ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
+            TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            Assert.Equal(TaskParameterType.ValueTypeArray, t2.ParameterType);
+
+            bool[] wrappedParameter2 = Assert.IsType<bool[]>(t2.WrappedParameter);
+            Assert.Equal(2, wrappedParameter2.Length);
+            Assert.False(wrappedParameter2[0]);
+            Assert.True(wrappedParameter2[1]);
+        }
+
         /// <summary>
         /// Verifies that construction and serialization with an ITaskItem parameter is OK.
         /// </summary>
