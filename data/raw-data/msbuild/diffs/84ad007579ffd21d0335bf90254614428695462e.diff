diff --git a/eng/Packages.props b/eng/Packages.props
index 97f340790f5..91058315eaa 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -2,7 +2,7 @@
   <ItemGroup>
     <PackageReference Update="BenchmarkDotNet" Version="0.12.1" />
     <PackageReference Update="jnm2.ReferenceAssemblies.net35" Version="1.0.1" />
-    <PackageReference Update="LargeAddressAware" Version="1.0.3" />
+    <PackageReference Update="LargeAddressAware" Version="1.0.5" />
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.DotNet.GenAPI" Version="2.1.0-prerelease-02404-02" />
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index 1318a437f92..00db63a067d 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -38,7 +38,7 @@ protected BuildEventArgs(string message, string helpKeyword, string senderName,
         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } }
         public virtual string Message { get { throw null; } protected set { } }
-        protected System.DateTime RawTimestamp { get { throw null; } set { } }
+        protected internal System.DateTime RawTimestamp { get { throw null; } set { } }
         public string SenderName { get { throw null; } }
         public int ThreadId { get { throw null; } }
         public System.DateTime Timestamp { get { throw null; } }
@@ -258,6 +258,10 @@ public partial interface IEventSource3 : Microsoft.Build.Framework.IEventSource,
         void IncludeEvaluationProfiles();
         void IncludeTaskInputs();
     }
+    public partial interface IEventSource4 : Microsoft.Build.Framework.IEventSource, Microsoft.Build.Framework.IEventSource2, Microsoft.Build.Framework.IEventSource3
+    {
+        void IncludeEvaluationPropertiesAndItems();
+    }
     public partial interface IForwardingLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
     {
         Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get; set; }
@@ -387,8 +391,11 @@ public sealed partial class ProjectEvaluationFinishedEventArgs : Microsoft.Build
     {
         public ProjectEvaluationFinishedEventArgs() { }
         public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) { }
+        public System.Collections.IEnumerable GlobalProperties { get { throw null; } set { } }
+        public System.Collections.IEnumerable Items { get { throw null; } set { } }
         public Microsoft.Build.Framework.Profiler.ProfilerResult? ProfilerResult { get { throw null; } set { } }
         public string ProjectFile { get { throw null; } set { } }
+        public System.Collections.IEnumerable Properties { get { throw null; } set { } }
     }
     public partial class ProjectEvaluationStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index 9d3b8a4e277..7b0fbb39d15 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -38,7 +38,7 @@ protected BuildEventArgs(string message, string helpKeyword, string senderName,
         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } }
         public virtual string Message { get { throw null; } protected set { } }
-        protected System.DateTime RawTimestamp { get { throw null; } set { } }
+        protected internal System.DateTime RawTimestamp { get { throw null; } set { } }
         public string SenderName { get { throw null; } }
         public int ThreadId { get { throw null; } }
         public System.DateTime Timestamp { get { throw null; } }
@@ -258,6 +258,10 @@ public partial interface IEventSource3 : Microsoft.Build.Framework.IEventSource,
         void IncludeEvaluationProfiles();
         void IncludeTaskInputs();
     }
+    public partial interface IEventSource4 : Microsoft.Build.Framework.IEventSource, Microsoft.Build.Framework.IEventSource2, Microsoft.Build.Framework.IEventSource3
+    {
+        void IncludeEvaluationPropertiesAndItems();
+    }
     public partial interface IForwardingLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
     {
         Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get; set; }
@@ -386,8 +390,11 @@ public sealed partial class ProjectEvaluationFinishedEventArgs : Microsoft.Build
     {
         public ProjectEvaluationFinishedEventArgs() { }
         public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) { }
+        public System.Collections.IEnumerable GlobalProperties { get { throw null; } set { } }
+        public System.Collections.IEnumerable Items { get { throw null; } set { } }
         public Microsoft.Build.Framework.Profiler.ProfilerResult? ProfilerResult { get { throw null; } set { } }
         public string ProjectFile { get { throw null; } set { } }
+        public System.Collections.IEnumerable Properties { get { throw null; } set { } }
     }
     public partial class ProjectEvaluationStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
diff --git a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
index 4491f300e5c..e435979d2b2 100644
--- a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
@@ -227,6 +227,7 @@ public partial class MuxLogger : Microsoft.Build.Framework.ILogger, Microsoft.Bu
         public MuxLogger() { }
         public bool IncludeEvaluationMetaprojects { get { throw null; } set { } }
         public bool IncludeEvaluationProfiles { get { throw null; } set { } }
+        public bool IncludeEvaluationPropertiesAndItems { get { throw null; } set { } }
         public bool IncludeTaskInputs { get { throw null; } set { } }
         public string Parameters { get { throw null; } set { } }
         public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
diff --git a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
index f0ad18e1545..d77c4295057 100644
--- a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
@@ -72,6 +72,7 @@ public partial class MuxLogger : Microsoft.Build.Framework.ILogger, Microsoft.Bu
         public MuxLogger() { }
         public bool IncludeEvaluationMetaprojects { get { throw null; } set { } }
         public bool IncludeEvaluationProfiles { get { throw null; } set { } }
+        public bool IncludeEvaluationPropertiesAndItems { get { throw null; } set { } }
         public bool IncludeTaskInputs { get { throw null; } set { } }
         public string Parameters { get { throw null; } set { } }
         public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index 5409a6f3822..4b1857121e1 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
@@ -203,6 +204,16 @@ public bool IncludeEvaluationProfile
             set { }
         }
 
+        /// <summary>
+        /// Log properties and items on ProjectEvaluationFinishedEventArgs
+        /// instead of ProjectStartedEventArgs.
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems
+        {
+            get => false;
+            set { }
+        }
+
         /// <summary>
         /// Should task events include task inputs?
         /// </summary>
@@ -459,7 +470,13 @@ public void LogProjectEvaluationStarted(BuildEventContext eventContext, string p
         /// <summary>
         /// Logs a project evaluation finished event
         /// </summary>
-        public void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile)
+        public void LogProjectEvaluationFinished(
+            BuildEventContext projectEvaluationEventContext,
+            string projectFile,
+            IEnumerable globalProperties,
+            IEnumerable properties,
+            IEnumerable items,
+            ProfilerResult? profilerResult)
         {
         }
 
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 3e860fc7d5f..a3137f5b399 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
@@ -32,6 +33,7 @@ public void LogMessageConstructorNullBuildEvent()
             }
            );
         }
+
         /// <summary>
         /// Verify when creating a LogMessagePacket
         /// that the correct Event Type is set.
@@ -53,6 +55,8 @@ public void VerifyEventType()
             ProjectStartedEventArgs projectStarted = new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null);
             ProjectFinishedEventArgs projectFinished = new ProjectFinishedEventArgs("message", "help", "ProjectFile", true);
             ExternalProjectStartedEventArgs externalStartedEvent = new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames");
+            ProjectEvaluationStartedEventArgs evaluationStarted = new ProjectEvaluationStartedEventArgs();
+            ProjectEvaluationFinishedEventArgs evaluationFinished = new ProjectEvaluationFinishedEventArgs();
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -67,16 +71,87 @@ public void VerifyEventType()
             VerifyLoggingPacket(targetFinished, LoggingEventType.TargetFinishedEvent);
             VerifyLoggingPacket(projectStarted, LoggingEventType.ProjectStartedEvent);
             VerifyLoggingPacket(projectFinished, LoggingEventType.ProjectFinishedEvent);
+            VerifyLoggingPacket(evaluationStarted, LoggingEventType.ProjectEvaluationStartedEvent);
+            VerifyLoggingPacket(evaluationFinished, LoggingEventType.ProjectEvaluationFinishedEvent);
             VerifyLoggingPacket(externalStartedEvent, LoggingEventType.CustomEvent);
         }
 
-        private static TaskParameterEventArgs CreateTaskParameter()
+        private static BuildEventContext CreateBuildEventContext()
+        {
+            return new BuildEventContext(1, 2, 3, 4, 5, 6, 7);
+        }
+
+        private static ProjectEvaluationStartedEventArgs CreateProjectEvaluationStarted()
+        {
+            string projectFile = "test.csproj";
+            var result = new ProjectEvaluationStartedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationStarted"),
+                projectFile)
+            {
+                ProjectFile = projectFile
+            };
+            result.BuildEventContext = CreateBuildEventContext();
+
+            return result;
+        }
+
+        private static ProjectEvaluationFinishedEventArgs CreateProjectEvaluationFinished()
+        {
+            string projectFile = "test.csproj";
+            var result = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"),
+                projectFile)
+            {
+                ProjectFile = projectFile,
+                GlobalProperties = CreateProperties(),
+                Properties = CreateProperties(),
+                Items = new ArrayList
+                {
+                    new DictionaryEntry("Compile", new TaskItemData("a", null)),
+                    new DictionaryEntry("Compile", new TaskItemData("b", CreateStringDictionary())),
+                    new DictionaryEntry("Reference", new TaskItemData("c", CreateStringDictionary())),
+                }
+            };
+            result.BuildEventContext = CreateBuildEventContext();
+
+            return result;
+        }
+
+        private static IEnumerable CreateProperties()
+        {
+            return new ArrayList
+            {
+                new DictionaryEntry("a", "b"),
+                new DictionaryEntry("c", "d")
+            };
+        }
+
+        private static Dictionary<string, string> CreateStringDictionary()
+        {
+            return new Dictionary<string, string>
+            {
+                { "a", "b" },
+                { "c", "d" }
+            };
+        }
+
+        private static TaskItemData[] CreateTaskItems()
         {
             var items = new TaskItemData[]
             {
                 new TaskItemData("ItemSpec1", null),
-                new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
+                new TaskItemData("ItemSpec1", CreateStringDictionary()),
+                new TaskItemData("ItemSpec2", Enumerable.Range(1, 3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
             };
+            return items;
+        }
+
+        private static TaskParameterEventArgs CreateTaskParameter()
+        {
+            // touch ItemGroupLoggingHelper to ensure static constructor runs
+            _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
+
+            var items = CreateTaskItems();
             var result = new TaskParameterEventArgs(
                 TaskParameterMessageKind.TaskInput,
                 "ItemName",
@@ -88,6 +163,9 @@ private static TaskParameterEventArgs CreateTaskParameter()
             Assert.Equal(@"Task Parameter:
     ItemName=
         ItemSpec1
+        ItemSpec1
+                a=b
+                c=d
         ItemSpec2
                 1=1value
                 2=2value
@@ -127,7 +205,9 @@ public void TestTranslation()
                     new TargetFinishedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile", true, targetOutputs),
                     new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null),
                     new ProjectFinishedEventArgs("message", "help", "ProjectFile", true),
-                    new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames")
+                    new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames"),
+                    CreateProjectEvaluationStarted(),
+                    CreateProjectEvaluationFinished()
                 };
 
                 foreach (BuildEventArgs arg in testArgs)
@@ -283,6 +363,32 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     // Assert.AreEqual(leftProjectStarted.Properties, rightProjectStarted.Properties);
                     break;
 
+                case LoggingEventType.ProjectEvaluationStartedEvent:
+                    ProjectEvaluationStartedEventArgs leftEvaluationStarted = left.NodeBuildEvent.Value.Value as ProjectEvaluationStartedEventArgs;
+                    ProjectEvaluationStartedEventArgs rightEvaluationStarted = right.NodeBuildEvent.Value.Value as ProjectEvaluationStartedEventArgs;
+                    Assert.NotNull(leftEvaluationStarted);
+                    Assert.NotNull(rightEvaluationStarted);
+                    Assert.Equal(leftEvaluationStarted.ProjectFile, rightEvaluationStarted.ProjectFile);
+                    break;
+
+                case LoggingEventType.ProjectEvaluationFinishedEvent:
+                    ProjectEvaluationFinishedEventArgs leftEvaluationFinished = left.NodeBuildEvent.Value.Value as ProjectEvaluationFinishedEventArgs;
+                    ProjectEvaluationFinishedEventArgs rightEvaluationFinished = right.NodeBuildEvent.Value.Value as ProjectEvaluationFinishedEventArgs;
+                    Assert.NotNull(leftEvaluationFinished);
+                    Assert.NotNull(rightEvaluationFinished);
+                    Assert.Equal(leftEvaluationFinished.ProjectFile, rightEvaluationFinished.ProjectFile);
+                    Assert.Equal(leftEvaluationFinished.ProfilerResult, rightEvaluationFinished.ProfilerResult);
+                    Assert.Equal(
+                        TranslationHelpers.GetPropertiesString(leftEvaluationFinished.GlobalProperties),
+                        TranslationHelpers.GetPropertiesString(rightEvaluationFinished.GlobalProperties));
+                    Assert.Equal(
+                        TranslationHelpers.GetPropertiesString(leftEvaluationFinished.Properties),
+                        TranslationHelpers.GetPropertiesString(rightEvaluationFinished.Properties));
+                    Assert.Equal(
+                        TranslationHelpers.GetMultiItemsString(leftEvaluationFinished.Items),
+                        TranslationHelpers.GetMultiItemsString(rightEvaluationFinished.Items));
+                    break;
+
                 case LoggingEventType.TargetFinishedEvent:
                     TargetFinishedEventArgs leftTargetFinished = left.NodeBuildEvent.Value.Value as TargetFinishedEventArgs;
                     TargetFinishedEventArgs rightTargetFinished = right.NodeBuildEvent.Value.Value as TargetFinishedEventArgs;
@@ -292,6 +398,8 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftTargetFinished.Succeeded, rightTargetFinished.Succeeded);
                     Assert.Equal(leftTargetFinished.TargetFile, rightTargetFinished.TargetFile);
                     Assert.Equal(leftTargetFinished.TargetName, rightTargetFinished.TargetName);
+                    //TODO: target output translation is a special case and is done in TranslateTargetFinishedEvent
+                    //Assert.Equal(leftTargetFinished.TargetOutputs, rightTargetFinished.TargetOutputs);
                     break;
 
                 case LoggingEventType.TargetStartedEvent:
diff --git a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
index aaf86e1ad25..a4f5a3c09e5 100644
--- a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
+++ b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
@@ -2,10 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
 using System.IO;
+using System.Text;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -104,5 +107,64 @@ internal static bool CompareExceptions(Exception left, Exception right)
 
             return CompareExceptions(left.InnerException, right.InnerException);
         }
+
+        internal static string GetPropertiesString(IEnumerable properties)
+        {
+            var dictionary = properties
+                .OfType<DictionaryEntry>()
+                .ToDictionary(
+                    (Func<DictionaryEntry, string>)(d => d.Key.ToString()),
+                    (Func<DictionaryEntry, string>)(d => d.Value.ToString()));
+            return ToString(dictionary);
+        }
+
+        internal static string GetMultiItemsString(IEnumerable items)
+        {
+            var list = items
+                .OfType<DictionaryEntry>()
+                .Select(i => i.Key.ToString() + GetTaskItemString(i.Value));
+            var text = string.Join("\n", list);
+            return text;
+        }
+
+        internal static string GetItemsString(IEnumerable items)
+        {
+            var list = items
+                .OfType<object>()
+                .Select(i => GetTaskItemString(i));
+            var text = string.Join("\n", list);
+            return text;
+        }
+
+        internal static string GetTaskItemString(object item)
+        {
+            var sb = new StringBuilder();
+
+            if (item is ITaskItem taskItem)
+            {
+                sb.Append(taskItem.ItemSpec);
+                foreach (string name in taskItem.MetadataNames)
+                {
+                    var value = taskItem.GetMetadata(name);
+                    sb.Append($";{name}={value}");
+                }
+            }
+            else
+            {
+                sb.Append(Convert.ToString(item));
+            }
+
+            return sb.ToString();
+        }
+
+        internal static string ToString(IDictionary<string, string> dictionary)
+        {
+            if (dictionary == null)
+            {
+                return "null";
+            }
+
+            return string.Join(";", dictionary.Select(kvp => kvp.Key + "=" + kvp.Value));
+        }
     }
 }
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index a2874d96c06..16b4cb0e035 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -8,6 +8,8 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Logging;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -34,7 +36,7 @@ public void RoundtripBuildStartedEventArgs()
                     { "SampleName", "SampleValue" }
                 });
             Roundtrip(args,
-                e => ToString(e.BuildEnvironment),
+                e => TranslationHelpers.ToString(e.BuildEnvironment),
                 e => e.HelpKeyword,
                 e => e.ThreadId.ToString(),
                 e => e.SenderName);
@@ -73,37 +75,19 @@ public void RoundtripProjectStartedEventArgs()
 
             Roundtrip<ProjectStartedEventArgs>(args,
                 e => ToString(e.BuildEventContext),
-                e => ToString(e.GlobalProperties),
-                e => GetItemsString(e.Items),
+                e => TranslationHelpers.GetPropertiesString(e.GlobalProperties),
+                e => TranslationHelpers.GetMultiItemsString(e.Items),
                 e => e.Message,
                 e => ToString(e.ParentProjectBuildEventContext),
                 e => e.ProjectFile,
                 e => e.ProjectId.ToString(),
-                e => ToString(e.Properties.OfType<DictionaryEntry>().ToDictionary((Func<DictionaryEntry, string>)(d => d.Key.ToString()), (Func<DictionaryEntry, string>)(d => d.Value.ToString()))),
+                e => TranslationHelpers.GetPropertiesString(e.Properties),
                 e => e.TargetNames,
                 e => e.ThreadId.ToString(),
                 e => e.Timestamp.ToString(),
                 e => e.ToolsVersion);
         }
 
-        private string GetItemsString(IEnumerable items)
-        {
-            return ToString(items.OfType<DictionaryEntry>().ToDictionary(d => d.Key.ToString(), d => GetTaskItemString((ITaskItem)d.Value)));
-        }
-
-        private string GetTaskItemString(ITaskItem taskItem)
-        {
-            var sb = new StringBuilder();
-            sb.Append(taskItem.ItemSpec);
-            foreach (string name in taskItem.MetadataNames)
-            {
-                var value = taskItem.GetMetadata(name);
-                sb.Append($";{name}={value}");
-            }
-
-            return sb.ToString();
-        }
-
         [Fact]
         public void RoundtripProjectFinishedEventArgs()
         {
@@ -331,7 +315,7 @@ public void RoundtripTaskCommandLineEventArgs()
         [Fact]
         public void RoundtripTaskParameterEventArgs()
         {
-            var items = new TaskItemData[]
+            var items = new ITaskItem[]
             {
                 new TaskItemData("ItemSpec1", null),
                 new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
@@ -342,16 +326,19 @@ public void RoundtripTaskParameterEventArgs()
                 e => e.Kind.ToString(),
                 e => e.ItemType,
                 e => e.LogItemMetadata.ToString(),
-                e => GetItemsString(e.Items));
+                e => TranslationHelpers.GetItemsString(e.Items));
         }
 
         [Fact]
         public void RoundtripProjectEvaluationStartedEventArgs()
         {
-            var args = new ProjectEvaluationStartedEventArgs("Message")
+            var projectFile = @"C:\foo\bar.proj";
+            var args = new ProjectEvaluationStartedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationStarted"),
+                projectFile)
             {
                 BuildEventContext = BuildEventContext.Invalid,
-                ProjectFile = @"C:\foo\bar.proj",
+                ProjectFile = projectFile,
             };
 
             Roundtrip(args,
@@ -362,21 +349,33 @@ public void RoundtripProjectEvaluationStartedEventArgs()
         [Fact]
         public void RoundtripProjectEvaluationFinishedEventArgs()
         {
-            var args = new ProjectEvaluationFinishedEventArgs("Message")
+            var projectFile = @"C:\foo\bar.proj";
+            var args = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"),
+                projectFile)
             {
                 BuildEventContext = BuildEventContext.Invalid,
                 ProjectFile = @"C:\foo\bar.proj",
+                GlobalProperties = new Dictionary<string, string>() { { "GlobalKey", "GlobalValue" } },
+                Properties = new List<DictionaryEntry>() { new DictionaryEntry("Key", "Value") },
+                Items = new List<DictionaryEntry>() { new DictionaryEntry("Key", new MyTaskItem() { ItemSpec = "TestItemSpec" }) }
             };
 
             Roundtrip(args,
                 e => e.Message,
-                e => e.ProjectFile);
+                e => e.ProjectFile,
+                e => TranslationHelpers.GetPropertiesString(e.GlobalProperties),
+                e => TranslationHelpers.GetPropertiesString(e.Properties),
+                e => TranslationHelpers.GetMultiItemsString(e.Items));
         }
 
         [Fact]
         public void RoundtripProjectEvaluationFinishedEventArgsWithProfileData()
         {
-            var args = new ProjectEvaluationFinishedEventArgs("Message")
+            var projectFile = @"C:\foo\bar.proj";
+            var args = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"),
+                projectFile)
             {
                 BuildEventContext = BuildEventContext.Invalid,
                 ProjectFile = @"C:\foo\bar.proj",
@@ -560,16 +559,6 @@ private string ToString(BuildEventContext context)
             return $"{context.BuildRequestId} {context.NodeId} {context.ProjectContextId} {context.ProjectInstanceId} {context.SubmissionId} {context.TargetId} {context.TaskId}";
         }
 
-        private string ToString(IDictionary<string, string> dictionary)
-        {
-            if (dictionary == null)
-            {
-                return "null";
-            }
-
-            return string.Join(";", dictionary.Select(kvp => kvp.Key + "=" + kvp.Value));
-        }
-
         private string ToString(IEnumerable<ITaskItem> items)
         {
             return string.Join(";", items.Select(i => ToString(i)));
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 0457c2005f2..31c8209404d 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -254,7 +254,6 @@ public void ErrorMessage()
 
             pc.Collection.RegisterLogger(logger);
 
-
             var p = pc.Collection.LoadProject(project.ProjectFile);
 
             BuildManager.DefaultBuildManager.Build(
@@ -266,13 +265,20 @@ public void ErrorMessage()
             sc.ToString().ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + ":: Number=2]");
         }
 
-        [Fact]
-        public void ErrorMessageWithMultiplePropertiesInMessage()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ErrorMessageWithMultiplePropertiesInMessage(bool includeEvaluationPropertiesAndItems)
         {
             using var env = TestEnvironment.Create(_output);
 
             var pc = env.CreateProjectCollection();
 
+            if (includeEvaluationPropertiesAndItems)
+            {
+                pc.Collection.LoggingService.IncludeEvaluationPropertiesAndItems = true;
+            }
+
             var project = env.CreateTestProjectWithFiles(@"
          <Project>
             <PropertyGroup>
@@ -300,7 +306,6 @@ public void ErrorMessageWithMultiplePropertiesInMessage()
 
             pc.Collection.RegisterLogger(logger);
 
-
             var p = pc.Collection.LoadProject(project.ProjectFile);
 
             BuildManager.DefaultBuildManager.Build(
@@ -308,8 +313,9 @@ public void ErrorMessageWithMultiplePropertiesInMessage()
                 new BuildRequestData(p.CreateProjectInstance(), new[] { "Spawn" }));
 
             p.Build().ShouldBeFalse();
-            sc.ToString().ShouldContain("source_of_error : error : Hello from project 1 [" + project.ProjectFile + ":: Number=1 TargetFramework=netcoreapp2.1]");
-            sc.ToString().ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + ":: Number=2 TargetFramework=netcoreapp2.1]");
+            string output = sc.ToString();
+            output.ShouldContain("source_of_error : error : Hello from project 1 [" + project.ProjectFile + ":: Number=1 TargetFramework=netcoreapp2.1]");
+            output.ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + ":: Number=2 TargetFramework=netcoreapp2.1]");
         }
 
         [Fact]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 559d426e357..f11fec9e489 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2578,7 +2578,11 @@ private NodeConfiguration GetNodeConfiguration()
 #if FEATURE_APPDOMAIN
                 , AppDomain.CurrentDomain.SetupInformation
 #endif
-                , new LoggingNodeConfiguration(loggingService.IncludeEvaluationMetaprojects, loggingService.IncludeEvaluationProfile, loggingService.IncludeTaskInputs)
+                , new LoggingNodeConfiguration(
+                    loggingService.IncludeEvaluationMetaprojects,
+                    loggingService.IncludeEvaluationProfile,
+                    loggingService.IncludeEvaluationPropertiesAndItems,
+                    loggingService.IncludeTaskInputs)
                 );
             }
 
diff --git a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
index b2fb277ba84..db2e6aecb4f 100644
--- a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
@@ -1,8 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections;
+using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd.Components.Logging
@@ -31,10 +34,10 @@ public void LogProjectEvaluationStarted()
         /// <summary>
         /// Log that the project has finished
         /// </summary>
-        internal void LogProjectEvaluationFinished()
+        internal void LogProjectEvaluationFinished(IEnumerable globalProperties, IEnumerable properties, IEnumerable items, ProfilerResult? profilerResult)
         {
             ErrorUtilities.VerifyThrow(IsValid, "invalid");
-            LoggingService.LogProjectEvaluationFinished(BuildEventContext, _projectFile);
+            LoggingService.LogProjectEvaluationFinished(BuildEventContext, _projectFile, globalProperties, properties, items, profilerResult);
             IsValid = false;
         }
     }
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 4c321e4a15c..97b7512d14e 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -18,7 +18,7 @@ internal sealed class EventSourceSink :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        IEventSource3, IBuildEventSink
+        IEventSource4, IBuildEventSink
     {
         #region Events
 
@@ -138,7 +138,6 @@ public bool IncludeEvaluationMetaprojects
             private set;
         }
 
-
         /// <summary>
         /// Should evaluation events include profiling information?
         /// </summary>
@@ -157,6 +156,16 @@ public bool IncludeTaskInputs
             private set;
         }
 
+        /// <summary>
+        /// Determines whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems
+        {
+            get;
+            private set;
+        }
+
         #endregion
 
         #region Methods
@@ -180,6 +189,15 @@ void IEventSource3.IncludeTaskInputs()
 
         #endregion
 
+        #region IEventSource4 Methods
+
+        void IEventSource4.IncludeEvaluationPropertiesAndItems()
+        {
+            IncludeEvaluationPropertiesAndItems = true;
+        }
+
+        #endregion
+
         #region IEventSink Methods
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index eebb06bea2a..ef3db37b022 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
@@ -187,6 +188,16 @@ bool IncludeEvaluationProfile
             set;
         }
 
+        /// <summary>
+        /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>?
+        /// </summary>
+        bool IncludeEvaluationPropertiesAndItems
+        {
+            get;
+            set;
+        }
+
         /// <summary>
         /// Should task events include task inputs?
         /// </summary>
@@ -427,8 +438,18 @@ bool IncludeTaskInputs
         /// </summary>
         /// <param name="projectEvaluationEventContext">Event context for the project.</param>
         /// <param name="projectFile">Project file being built</param>
+        /// <param name="globalProperties">Global properties used for the evaluation.</param>
+        /// <param name="properties">Properties produced by the evaluation.</param>
+        /// <param name="items">Items produced by the evaluation.</param>
+        /// <param name="profilerResult">Profiler results if evaluation profiling was enabled.</param>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
-        void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile);
+        void LogProjectEvaluationFinished(
+            BuildEventContext projectEvaluationEventContext,
+            string projectFile,
+            IEnumerable globalProperties,
+            IEnumerable properties,
+            IEnumerable items,
+            ProfilerResult? profilerResult);
 
         /// <summary>
         /// Log that a project has started
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index c86ac786792..a96a169fb18 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -196,6 +196,12 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// </summary>
         private bool? _includeEvaluationProfile;
 
+        /// <summary>
+        /// Whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>.
+        /// </summary>
+        private bool? _includeEvaluationPropertiesAndItems;
+
         /// <summary>
         /// Whether to include task inputs in task events.
         /// </summary>
@@ -502,6 +508,16 @@ public bool IncludeTaskInputs
             set => _includeTaskInputs = value;
         }
 
+        /// <summary>
+        /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>?
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems
+        {
+            get => _includeEvaluationPropertiesAndItems ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationPropertiesAndItems);
+            set => _includeEvaluationPropertiesAndItems = value;
+        }
+
         /// <summary>
         /// Determines if the specified submission has logged an errors.
         /// </summary>
@@ -1154,7 +1170,11 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
                 {
                     ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectStartedEventArgs.ProjectId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
                     BuildRequestConfiguration buildRequestConfiguration = _configCache.Value[projectStartedEventArgs.ProjectId];
-                    s_projectStartedEventArgsGlobalProperties.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.GlobalProperties.ToDictionary(), null);
+                    if (!IncludeEvaluationPropertiesAndItems)
+                    {
+                        s_projectStartedEventArgsGlobalProperties.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.GlobalProperties.ToDictionary(), null);
+                    }
+
                     s_projectStartedEventArgsToolsVersion.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.ToolsVersion, null);
                 }
             }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index d7c7cf13ad6..6dcf39925d2 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
@@ -513,8 +514,18 @@ public void LogProjectEvaluationStarted(BuildEventContext projectEvaluationEvent
         /// </summary>
         /// <param name="projectEvaluationEventContext">Event context for the project.</param>
         /// <param name="projectFile">Project file being built</param>
+        /// <param name="globalProperties">Global properties used for the evaluation.</param>
+        /// <param name="properties">Properties produced by the evaluation.</param>
+        /// <param name="items">Items produced by the evaluation.</param>
+        /// <param name="profilerResult">Profiler results if evaluation profiling was enabled.</param>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
-        public void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile)
+        public void LogProjectEvaluationFinished(
+            BuildEventContext projectEvaluationEventContext,
+            string projectFile,
+            IEnumerable globalProperties,
+            IEnumerable properties,
+            IEnumerable items,
+            ProfilerResult? profilerResult)
         {
             lock (_lockObject)
             {
@@ -524,7 +535,11 @@ public void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEven
                     new ProjectEvaluationFinishedEventArgs(ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile)
                     {
                         BuildEventContext = projectEvaluationEventContext,
-                        ProjectFile = projectFile
+                        ProjectFile = projectFile,
+                        ProfilerResult = profilerResult,
+                        GlobalProperties = globalProperties,
+                        Properties = properties,
+                        Items = items
                     };
                 ProcessLoggingEvent(buildEvent);
             }
@@ -579,17 +594,24 @@ public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventConte
 
                 ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectInstanceId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
                 var buildRequestConfiguration = _configCache.Value[projectInstanceId];
-                ProjectStartedEventArgs buildEvent = new ProjectStartedEventArgs
+
+                IDictionary<string, string> globalProperties = null;
+                if (!IncludeEvaluationPropertiesAndItems)
+                {
+                    globalProperties = buildRequestConfiguration.GlobalProperties.ToDictionary();
+                }
+
+                var buildEvent = new ProjectStartedEventArgs
                     (
                         projectInstanceId,
                         message,
-                        null,       // no help keyword
+                        helpKeyword: null,
                         projectFile,
                         targetNames,
                         properties,
                         items,
                         parentBuildEventContext,
-                        buildRequestConfiguration.GlobalProperties.ToDictionary(),
+                        globalProperties,
                         buildRequestConfiguration.ToolsVersion
                     );
                 buildEvent.BuildEventContext = projectBuildEventContext;
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index be1a86b0229..846c0b3a643 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Shared;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
@@ -85,7 +86,9 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
             string[] propertiesToSerialize = LoggingService.PropertiesToSerialize;
 
             // If we are only logging critical events lets not pass back the items or properties
-            if (!LoggingService.OnlyLogCriticalEvents && (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
+            if (!LoggingService.OnlyLogCriticalEvents &&
+                !LoggingService.IncludeEvaluationPropertiesAndItems &&
+                (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
             {
                 if (projectProperties != null)
                 {
@@ -101,7 +104,10 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
                 items = new ProjectItemInstanceEnumeratorProxy(projectItemsEnumerator);
             }
 
-            if (projectProperties != null && propertiesToSerialize?.Length > 0 && !LoggingService.SerializeAllProperties)
+            if (projectProperties != null &&
+                !LoggingService.IncludeEvaluationPropertiesAndItems &&
+                propertiesToSerialize?.Length > 0 &&
+                !LoggingService.SerializeAllProperties)
             {
                 PropertyDictionary<ProjectPropertyInstance> projectPropertiesToSerialize = new PropertyDictionary<ProjectPropertyInstance>();
                 foreach (string propertyToGet in propertiesToSerialize)
diff --git a/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs b/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
index 9578394e043..2c7a47703c0 100644
--- a/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
@@ -11,22 +11,27 @@ internal sealed class LoggingNodeConfiguration : ITranslatable
     {
         private bool _includeEvaluationMetaprojects;
         private bool _includeEvaluationProfiles;
+        private bool _includeEvaluationPropertiesAndItems;
         private bool _includeTaskInputs;
 
         public bool IncludeEvaluationMetaprojects => _includeEvaluationMetaprojects;
-
         public bool IncludeEvaluationProfiles => _includeEvaluationProfiles;
-
+        public bool IncludeEvaluationPropertiesAndItems => _includeEvaluationPropertiesAndItems;
         public bool IncludeTaskInputs => _includeTaskInputs;
 
         public LoggingNodeConfiguration()
         {
         }
 
-        public LoggingNodeConfiguration(bool includeEvaluationMetaprojects, bool includeEvaluationProfiles, bool includeTaskInputs)
+        public LoggingNodeConfiguration(
+            bool includeEvaluationMetaprojects,
+            bool includeEvaluationProfiles,
+            bool includeEvaluationPropertiesAndItems,
+            bool includeTaskInputs)
         {
             _includeEvaluationMetaprojects = includeEvaluationMetaprojects;
             _includeEvaluationProfiles = includeEvaluationProfiles;
+            _includeEvaluationPropertiesAndItems = includeEvaluationPropertiesAndItems;
             _includeTaskInputs = includeTaskInputs;
         }
 
@@ -34,6 +39,7 @@ void ITranslatable.Translate(ITranslator translator)
         {
             translator.Translate(ref _includeEvaluationMetaprojects);
             translator.Translate(ref _includeEvaluationProfiles);
+            translator.Translate(ref _includeEvaluationPropertiesAndItems);
             translator.Translate(ref _includeTaskInputs);
         }
     }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index d70930c1493..80e36648f23 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -742,6 +742,7 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
             {
                 _loggingService.IncludeEvaluationMetaprojects = true;
             }
+
             if (configuration.LoggingNodeConfiguration.IncludeEvaluationProfiles)
             {
                 _loggingService.IncludeEvaluationProfile = true;
@@ -752,6 +753,11 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
                 _loggingService.IncludeTaskInputs = true;
             }
 
+            if (configuration.LoggingNodeConfiguration.IncludeEvaluationPropertiesAndItems)
+            {
+                _loggingService.IncludeEvaluationPropertiesAndItems = true;
+            }
+
             try
             {
                 // If there are no node loggers to initialize dont do anything
diff --git a/src/Build/Collections/ArrayDictionary.cs b/src/Build/Collections/ArrayDictionary.cs
index 9cdf1d7a0e1..01e883f6058 100644
--- a/src/Build/Collections/ArrayDictionary.cs
+++ b/src/Build/Collections/ArrayDictionary.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Collections
     /// </summary>
     /// <typeparam name="TKey">Type of keys</typeparam>
     /// <typeparam name="TValue">Type of values</typeparam>
-    internal class ArrayDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary
+    internal class ArrayDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary, IReadOnlyDictionary<TKey, TValue>
     {
         private TKey[] keys;
         private TValue[] values;
@@ -65,6 +65,10 @@ object IDictionary.this[object key]
 
         public ICollection<TKey> Keys => keys;
 
+        IEnumerable<TKey> IReadOnlyDictionary<TKey, TValue>.Keys => keys;
+
+        IEnumerable<TValue> IReadOnlyDictionary<TKey, TValue>.Values => values;
+
         ICollection IDictionary.Keys => keys;
 
         public ICollection<TValue> Values => values;
diff --git a/src/Build/Collections/ItemDictionary.cs b/src/Build/Collections/ItemDictionary.cs
index 84efd27c913..b0e1ab517ef 100644
--- a/src/Build/Collections/ItemDictionary.cs
+++ b/src/Build/Collections/ItemDictionary.cs
@@ -167,6 +167,30 @@ IEnumerator IEnumerable.GetEnumerator()
             return _itemLists.GetEnumerator();
         }
 
+        /// <summary>
+        /// Enumerates item lists per each item type under the lock.
+        /// </summary>
+        /// <param name="itemTypeCallback">
+        /// A delegate that accepts the item type string and a list of items of that type.
+        /// Will be called for each item type in the list.
+        /// </param>
+        internal void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
+        {
+            lock (_itemLists)
+            {
+                foreach (var itemTypeBucket in _itemLists)
+                {
+                    if (itemTypeBucket.Value == null || itemTypeBucket.Value.Count == 0)
+                    {
+                        // skip empty markers
+                        continue;
+                    }
+
+                    itemTypeCallback(itemTypeBucket.Key, itemTypeBucket.Value);
+                }
+            }
+        }
+
         #region ItemDictionary<T> Members
 
         /// <summary>
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index e3c17b24fae..e1929f7ca58 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -492,22 +492,33 @@ internal void RemoveProperties(IEnumerable<T> other)
 
         /// <summary>
         /// Helper to convert into a read-only dictionary of string, string.
+        /// TODO: for performance, consider switching to returning IDictionary
+        /// and returning ArrayDictionary if lookup of results is not needed.
         /// </summary>
         internal Dictionary<string, string> ToDictionary()
         {
-            Dictionary<string, string> dictionary;
-
             lock (_properties)
             {
-                dictionary = new Dictionary<string, string>(_properties.Count, MSBuildNameIgnoreCaseComparer.Default);
+                var dictionary = new Dictionary<string, string>(_properties.Count, MSBuildNameIgnoreCaseComparer.Default);
 
                 foreach (T property in this)
                 {
                     dictionary[property.Key] = property.EscapedValue;
                 }
+
+                return dictionary;
             }
+        }
 
-            return dictionary;
+        internal void Enumerate(Action<string, string> keyValueCallback)
+        {
+            lock (_properties)
+            {
+                foreach (var kvp in _properties)
+                {
+                    keyValueCallback(kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));
+                }
+            }
         }
     }
 }
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 451a26ef506..07519d583ba 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -1794,7 +1794,7 @@ public ProjectAddedToProjectCollectionEventArgs(ProjectRootElement element)
         /// The ReusableLogger wraps a logger and allows it to be used for both design-time and build-time.  It internally swaps
         /// between the design-time and build-time event sources in response to Initialize and Shutdown events.
         /// </summary>
-        internal class ReusableLogger : INodeLogger, IEventSource3
+        internal class ReusableLogger : INodeLogger, IEventSource4
         {
             /// <summary>
             /// The logger we are wrapping.
@@ -1892,6 +1892,8 @@ internal class ReusableLogger : INodeLogger, IEventSource3
 
             private bool _includeTaskInputs;
 
+            private bool _includeEvaluationPropertiesAndItems;
+
             /// <summary>
             /// Constructor.
             /// </summary>
@@ -2031,6 +2033,22 @@ public void IncludeTaskInputs()
 
                 _includeTaskInputs = true;
             }
+
+            public void IncludeEvaluationPropertiesAndItems()
+            {
+                if (_buildTimeEventSource is IEventSource4 buildEventSource4)
+                {
+                    buildEventSource4.IncludeEvaluationPropertiesAndItems();
+                }
+
+                if (_designTimeEventSource is IEventSource4 designTimeEventSource4)
+                {
+                    designTimeEventSource4.IncludeEvaluationPropertiesAndItems();
+                }
+
+                _includeEvaluationPropertiesAndItems = true;
+            }
+
             #endregion
 
             #region ILogger Members
@@ -2163,6 +2181,7 @@ private void RegisterForEvents(IEventSource eventSource)
                     {
                         eventSource3.IncludeEvaluationMetaprojects();
                     }
+
                     if (_includeEvaluationProfiles)
                     {
                         eventSource3.IncludeEvaluationProfiles();
@@ -2173,6 +2192,14 @@ private void RegisterForEvents(IEventSource eventSource)
                         eventSource3.IncludeTaskInputs();
                     }
                 }
+
+                if (eventSource is IEventSource4 eventSource4)
+                {
+                    if (_includeEvaluationPropertiesAndItems)
+                    {
+                        eventSource4.IncludeEvaluationPropertiesAndItems();
+                    }
+                }
             }
 
             /// <summary>
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index f9126e6c61f..22107d15fcc 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using ObjectModel = System.Collections.ObjectModel;
@@ -777,12 +778,23 @@ private void Evaluate()
             }
 
             ErrorUtilities.VerifyThrow(_evaluationProfiler.IsEmpty(), "Evaluation profiler stack is not empty.");
-            _evaluationLoggingContext.LogBuildEvent(new ProjectEvaluationFinishedEventArgs(ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile)
+
+            IEnumerable globalProperties = null;
+            IEnumerable properties = null;
+            IEnumerable items = null;
+
+            if (this._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
             {
-                BuildEventContext = _evaluationLoggingContext.BuildEventContext,
-                ProjectFile = projectFile,
-                ProfilerResult = _evaluationProfiler.ProfiledResult
-            });
+                if (_data.GlobalPropertiesDictionary.Count > 0)
+                {
+                    globalProperties = _data.GlobalPropertiesDictionary;
+                }
+
+                properties = _data.Properties;
+                items = _data.Items;
+            }
+
+            _evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, _evaluationProfiler.ProfiledResult);
         }
 
         private void CollectProjectCachePlugins()
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index f9ef8388e3b..e29d3346621 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -1052,7 +1052,7 @@ ISet<string> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, Projec
         }
 
         /// <summary>
-        /// Gets the global properties
+        /// Gets the properties
         /// </summary>
         PropertyDictionary<ProjectPropertyInstance> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Properties
         {
@@ -1062,7 +1062,7 @@ PropertyDictionary<ProjectPropertyInstance> IEvaluatorData<ProjectPropertyInstan
         }
 
         /// <summary>
-        /// Gets the global properties
+        /// Gets the item definitions
         /// </summary>
         IEnumerable<ProjectItemDefinitionInstance> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.ItemDefinitionsEnumerable
         {
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index aad71143328..1768e7b3145 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -527,10 +527,9 @@ internal List<DictionaryEntry> ExtractPropertyList(IEnumerable properties)
         {
             // Gather a sorted list of all the properties.
             var list = new List<DictionaryEntry>(properties.FastCountOrZero());
-            foreach (DictionaryEntry prop in properties)
-            {
-                list.Add(prop);
-            }
+
+            Internal.Utilities.EnumerateProperties(properties, kvp => list.Add(new DictionaryEntry(kvp.Key, kvp.Value)));
+
             list.Sort(new DictionaryEntryKeyComparer());
             return list;
         }
@@ -620,18 +619,19 @@ internal SortedList ExtractItemList(IEnumerable items)
             // Use a SortedList instead of an ArrayList (because we need to lookup fast)
             // and instead of a Hashtable (because we need to sort it)
             SortedList itemTypes = new SortedList(CaseInsensitiveComparer.Default);
-            foreach (DictionaryEntry item in items)
+
+            Internal.Utilities.EnumerateItems(items, item =>
             {
-                // Create a new list for this itemtype, if we haven't already
-                if (itemTypes[(string)item.Key] == null)
+                string key = (string)item.Key;
+                var bucket = itemTypes[key] as ArrayList;
+                if (bucket == null)
                 {
-                    itemTypes[(string)item.Key] = new ArrayList();
+                    bucket = new ArrayList();
+                    itemTypes[key] = bucket;
                 }
 
-                // Add the item to the list for its itemtype
-                ArrayList itemsOfAType = (ArrayList)itemTypes[(string)item.Key];
-                itemsOfAType.Add(item.Value);
-            }
+                bucket.Add(item.Value);
+            });
 
             return itemTypes;
         }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 5274f54ab3a..c9515e817f5 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -43,7 +43,9 @@ public sealed class BinaryLogger : ILogger
         //                        where a list used to be written in-place
         // version 11:
         //   - new record kind: TaskParameterEventArgs
-        internal const int FileFormatVersion = 11;
+        // version 12:
+        //   - add GlobalProperties, Properties and Items on ProjectEvaluationFinished
+        internal const int FileFormatVersion = 12;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
@@ -103,6 +105,7 @@ public void Initialize(IEventSource eventSource)
             Environment.SetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING", "true");
             Environment.SetEnvironmentVariable("MSBUILDLOGIMPORTS", "1");
             Traits.Instance.EscapeHatches.LogProjectImports = true;
+            bool logPropertiesAndItemsAfterEvaluation = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;
 
             ProcessParameters();
 
@@ -135,6 +138,11 @@ public void Initialize(IEventSource eventSource)
                 {
                     eventSource3.IncludeEvaluationMetaprojects();
                 }
+
+                if (logPropertiesAndItemsAfterEvaluation && eventSource is IEventSource4 eventSource4)
+                {
+                    eventSource4.IncludeEvaluationPropertiesAndItems();
+                }
             }
             catch (Exception e)
             {
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index f9af8eed299..d6675d9eb7b 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -343,7 +343,9 @@ private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
             var fields = ReadBuildEventArgsFields();
             var projectFile = ReadDeduplicatedString();
 
-            var e = new ProjectEvaluationStartedEventArgs(fields.Message)
+            var e = new ProjectEvaluationStartedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationStarted"),
+                projectFile)
             {
                 ProjectFile = projectFile
             };
@@ -356,12 +358,30 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
             var fields = ReadBuildEventArgsFields();
             var projectFile = ReadDeduplicatedString();
 
-            var e = new ProjectEvaluationFinishedEventArgs(fields.Message)
+            var e = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"),
+                projectFile)
             {
                 ProjectFile = projectFile
             };
             SetCommonFields(e, fields);
 
+            if (fileFormatVersion >= 12)
+            {
+                IEnumerable globalProperties = null;
+                if (ReadBoolean())
+                {
+                    globalProperties = ReadStringDictionary();
+                }
+
+                var propertyList = ReadPropertyList();
+                var itemList = ReadProjectItems();
+
+                e.GlobalProperties = globalProperties;
+                e.Properties = propertyList;
+                e.Items = itemList;
+            }
+
             // ProfilerResult was introduced in version 5
             if (fileFormatVersion > 4)
             {
@@ -451,7 +471,7 @@ private BuildEventArgs ReadTargetStartedEventArgs()
             var targetFile = ReadOptionalString();
             var parentTarget = ReadOptionalString();
             // BuildReason was introduced in version 4
-            var buildReason = fileFormatVersion > 3 ? (TargetBuiltReason) ReadInt32() : TargetBuiltReason.None;
+            var buildReason = fileFormatVersion > 3 ? (TargetBuiltReason)ReadInt32() : TargetBuiltReason.None;
 
             var e = new TargetStartedEventArgs(
                 fields.Message,
@@ -617,15 +637,15 @@ private BuildEventArgs ReadTaskParameterEventArgs()
             ReadInt32();
 
             var kind = (TaskParameterMessageKind)ReadInt32();
-            var itemName = ReadDeduplicatedString();
+            var itemType = ReadDeduplicatedString();
             var items = ReadTaskItemList() as IList;
 
             var e = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
                 fields.BuildEventContext,
                 kind,
-                itemName,
+                itemType,
                 items,
-                true,
+                logItemMetadata: true,
                 fields.Timestamp);
             e.ProjectFile = fields.ProjectFile;
             return e;
@@ -845,23 +865,25 @@ private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields
 
             if ((fields.Flags & BuildEventArgsFieldFlags.Timestamp) != 0)
             {
-                buildEventArgsFieldTimestamp.SetValue(buildEventArgs, fields.Timestamp);
+                buildEventArgs.RawTimestamp = fields.Timestamp;
             }
         }
 
-        private ArrayList ReadPropertyList()
+        private IEnumerable ReadPropertyList()
         {
             var properties = ReadStringDictionary();
-            if (properties == null)
+            if (properties == null || properties.Count == 0)
             {
                 return null;
             }
 
-            var list = new ArrayList();
+            int count = properties.Count;
+            var list = new DictionaryEntry[count];
+            int i = 0;
             foreach (var property in properties)
             {
-                var entry = new DictionaryEntry(property.Key, property.Value);
-                list.Add(entry);
+                list[i] = new DictionaryEntry(property.Key, property.Value);
+                i++;
             }
 
             return list;
@@ -942,13 +964,7 @@ private ITaskItem ReadTaskItem()
 
         private IEnumerable ReadProjectItems()
         {
-            int count = ReadInt32();
-            if (count == 0)
-            {
-                return null;
-            }
-
-            List<DictionaryEntry> list;
+            IList<DictionaryEntry> list;
 
             // starting with format version 10 project items are grouped by name
             // so we only have to write the name once, and then the count of items
@@ -956,26 +972,68 @@ private IEnumerable ReadProjectItems()
             // old style flat list where the name is duplicated for each item.
             if (fileFormatVersion < 10)
             {
-                list = new List<DictionaryEntry>(count);
+                int count = ReadInt32();
+                if (count == 0)
+                {
+                    return null;
+                }
+
+                list = new DictionaryEntry[count];
                 for (int i = 0; i < count; i++)
                 {
                     string itemName = ReadString();
                     ITaskItem item = ReadTaskItem();
-                    list.Add(new DictionaryEntry(itemName, item));
+                    list[i] = new DictionaryEntry(itemName, item);
                 }
             }
-            else
+            else if (fileFormatVersion < 12)
             {
+                int count = ReadInt32();
+                if (count == 0)
+                {
+                    return null;
+                }
+
                 list = new List<DictionaryEntry>();
                 for (int i = 0; i < count; i++)
                 {
-                    string itemName = ReadDeduplicatedString();
+                    string itemType = ReadDeduplicatedString();
+                    var items = ReadTaskItemList();
+                    if (items != null)
+                    {
+                        foreach (var item in items)
+                        {
+                            list.Add(new DictionaryEntry(itemType, item));
+                        }
+                    }
+                }
+            }
+            else
+            {
+                list = new List<DictionaryEntry>();
+
+                while (true)
+                {
+                    string itemType = ReadDeduplicatedString();
+                    if (string.IsNullOrEmpty(itemType))
+                    {
+                        break;
+                    }
+
                     var items = ReadTaskItemList();
-                    foreach (var item in items)
+                    if (items != null)
                     {
-                        list.Add(new DictionaryEntry(itemName, item));
+                        foreach (var item in items)
+                        {
+                            list.Add(new DictionaryEntry(itemType, item));
+                        }
                     }
                 }
+
+                if (list.Count == 0)
+                {
+                    list = null;
+                }
             }
 
             return list;
@@ -989,12 +1047,12 @@ private IEnumerable ReadTaskItemList()
                 return null;
             }
 
-            var list = new List<ITaskItem>(count);
+            var list = new ITaskItem[count];
 
             for (int i = 0; i < count; i++)
             {
                 ITaskItem item = ReadTaskItem();
-                list.Add(item);
+                list[i] = item;
             }
 
             return list;
@@ -1109,7 +1167,7 @@ private EvaluationLocation ReadEvaluationLocation()
             var hasLine = ReadBoolean();
             if (hasLine)
             {
-                line = ReadInt32(); 
+                line = ReadInt32();
             }
 
             // Id and parent Id were introduced in version 6
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 1acc641650b..5774a80a27f 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -8,6 +8,8 @@
 using System.IO;
 using System.Linq;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -218,7 +220,7 @@ private void Write(BuildFinishedEventArgs e)
         private void Write(ProjectEvaluationStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.ProjectEvaluationStarted);
-            WriteBuildEventArgsFields(e);
+            WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.ProjectFile);
         }
 
@@ -226,15 +228,30 @@ private void Write(ProjectEvaluationFinishedEventArgs e)
         {
             Write(BinaryLogRecordKind.ProjectEvaluationFinished);
 
-            WriteBuildEventArgsFields(e);
+            WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.ProjectFile);
 
-            Write(e.ProfilerResult.HasValue);
-            if (e.ProfilerResult.HasValue)
+            if (e.GlobalProperties == null)
             {
-                Write(e.ProfilerResult.Value.ProfiledLocations.Count);
+                Write(false);
+            }
+            else
+            {
+                Write(true);
+                WriteProperties(e.GlobalProperties);
+            }
+
+            WriteProperties(e.Properties);
 
-                foreach (var item in e.ProfilerResult.Value.ProfiledLocations)
+            WriteProjectItems(e.Items);
+
+            var result = e.ProfilerResult;
+            Write(result.HasValue);
+            if (result.HasValue)
+            {
+                Write(result.Value.ProfiledLocations.Count);
+
+                foreach (var item in result.Value.ProfiledLocations)
                 {
                     Write(item.Key);
                     Write(item.Value);
@@ -664,7 +681,9 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
             return flags;
         }
 
+        // Both of these are used simultaneously so can't just have a single list
         private readonly List<object> reusableItemsList = new List<object>();
+        private readonly List<object> reusableProjectItemList = new List<object>();
 
         private void WriteTaskItemList(IEnumerable items, bool writeMetadata = true)
         {
@@ -736,18 +755,71 @@ private void WriteProjectItems(IEnumerable items)
                 return;
             }
 
-            var groups = items
-                .OfType<DictionaryEntry>()
-                .GroupBy(entry => entry.Key as string, entry => entry.Value as ITaskItem)
-                .Where(group => !string.IsNullOrEmpty(group.Key))
-                .ToArray();
+            if (items is ItemDictionary<ProjectItemInstance> itemInstanceDictionary)
+            {
+                // If we have access to the live data from evaluation, it exposes a special method
+                // to iterate the data structure under a lock and return results grouped by item type.
+                // There's no need to allocate or call GroupBy this way.
+                itemInstanceDictionary.EnumerateItemsPerType((itemType, itemList) =>
+                {
+                    WriteDeduplicatedString(itemType);
+                    WriteTaskItemList(itemList);
+                });
 
-            Write(groups.Length);
+                // signal the end
+                Write(0);
+            }
+            // not sure when this can get hit, but best to be safe and support this
+            else if (items is ItemDictionary<ProjectItem> itemDictionary)
+            {
+                itemDictionary.EnumerateItemsPerType((itemType, itemList) =>
+                {
+                    WriteDeduplicatedString(itemType);
+                    WriteTaskItemList(itemList);
+                });
 
-            foreach (var group in groups)
+                // signal the end
+                Write(0);
+            }
+            else
             {
-                WriteDeduplicatedString(group.Key);
-                WriteTaskItemList(group);
+                string currentItemType = null;
+
+                // Write out a sequence of items for each item type while avoiding GroupBy
+                // and associated allocations. We rely on the fact that items of each type
+                // are contiguous. For each item type, write the item type name and the list
+                // of items. Write 0 at the end (which would correspond to item type null).
+                // This is how the reader will know how to stop. We can't write out the
+                // count of item types at the beginning because we don't know how many there
+                // will be (we'd have to enumerate twice to calculate that). This scheme
+                // allows us to stream in a single pass with no allocations for intermediate
+                // results.
+                Internal.Utilities.EnumerateItems(items, dictionaryEntry =>
+                {
+                    string key = (string)dictionaryEntry.Key;
+
+                    // boundary between item types
+                    if (currentItemType != null && currentItemType != key)
+                    {
+                        WriteDeduplicatedString(currentItemType);
+                        WriteTaskItemList(reusableProjectItemList);
+                        reusableProjectItemList.Clear();
+                    }
+
+                    reusableProjectItemList.Add(dictionaryEntry.Value);
+                    currentItemType = key;
+                });
+
+                // write out the last item type
+                if (reusableProjectItemList.Count > 0)
+                {
+                    WriteDeduplicatedString(currentItemType);
+                    WriteTaskItemList(reusableProjectItemList);
+                    reusableProjectItemList.Clear();
+                }
+
+                // signal the end
+                Write(0);
             }
         }
 
@@ -787,22 +859,7 @@ private void WriteProperties(IEnumerable properties)
                 return;
             }
 
-            // there are no guarantees that the properties iterator won't change, so 
-            // take a snapshot and work with the readonly copy
-            var propertiesArray = properties.OfType<DictionaryEntry>().ToArray();
-
-            for (int i = 0; i < propertiesArray.Length; i++)
-            {
-                DictionaryEntry entry = propertiesArray[i];
-                if (entry.Key is string key && entry.Value is string value)
-                {
-                    nameValueListBuffer.Add(new KeyValuePair<string, string>(key, value));
-                }
-                else
-                {
-                    nameValueListBuffer.Add(new KeyValuePair<string, string>(string.Empty, string.Empty));
-                }
-            }
+            Internal.Utilities.EnumerateProperties(properties, kvp => nameValueListBuffer.Add(kvp));
 
             WriteNameValueList();
 
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index bae76905916..edcbe439efe 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -6,13 +6,14 @@
 using System.Collections;
 using System.Globalization;
 using System.Collections.Generic;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using ColorSetter = Microsoft.Build.Logging.ColorSetter;
 using ColorResetter = Microsoft.Build.Logging.ColorResetter;
 using WriteHandler = Microsoft.Build.Logging.WriteHandler;
-using Microsoft.Build.Exceptions;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
@@ -527,6 +528,7 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 {
                     DisplayDeferredProjectStartedEvent(e.BuildEventContext);
                 }
+
                 if (e.Properties != null)
                 {
                     WriteProperties(e, e.Properties);
@@ -538,30 +540,50 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 }
             }
 
-            if (e.BuildEventContext == null || e.Items == null)
+            ReadProjectConfigurationDescription(e.BuildEventContext, e.Items);
+        }
+
+        private void ReadProjectConfigurationDescription(BuildEventContext buildEventContext, IEnumerable items)
+        {
+            if (buildEventContext == null || items == null)
             {
                 return;
             }
 
             // node and project context ids for the propertyOutputMap key.
-            int nodeID = e.BuildEventContext.NodeId;
-            int projectContextId = e.BuildEventContext.ProjectContextId;
+            int nodeID = buildEventContext.NodeId;
+            int projectContextId = buildEventContext.ProjectContextId;
 
-            // Create the value to be added to the propertyOutputMap.
-            using var projectConfigurationDescription = new ReuseableStringBuilder();
+            ReuseableStringBuilder projectConfigurationDescription = null;
 
-            foreach (DictionaryEntry item in e.Items)
+            Internal.Utilities.EnumerateItems(items, item =>
             {
-                ITaskItem itemVal = (ITaskItem)item.Value;
                 // Determine if the LogOutputProperties item has been used.
                 if (string.Equals((string)item.Key, ItemMetadataNames.ProjectConfigurationDescription, StringComparison.OrdinalIgnoreCase))
                 {
+                    if (projectConfigurationDescription == null)
+                    {
+                        projectConfigurationDescription = new ReuseableStringBuilder();
+                    }
+
+                    string itemSpec = item.Value switch
+                    {
+                        IItem iitem => iitem.EvaluatedInclude, // ProjectItem
+                        ITaskItem taskItem => taskItem.ItemSpec, // ProjectItemInstance
+                        _ => throw new NotSupportedException(Convert.ToString(item.Value))
+                    };
+
                     // Add the item value to the string to be printed in error/warning messages.
-                    projectConfigurationDescription.Append(" ").Append(itemVal.ItemSpec);
+                    projectConfigurationDescription.Append(" ").Append(itemSpec);
                 }
-            }
+            });
+
             // Add the finished dictionary to propertyOutputMap.
-            propertyOutputMap.Add((nodeID, projectContextId), projectConfigurationDescription.ToString());
+            if (projectConfigurationDescription != null)
+            {
+                propertyOutputMap.Add((nodeID, projectContextId), projectConfigurationDescription.ToString());
+                (projectConfigurationDescription as IDisposable)?.Dispose();
+            }
         }
 
         /// <summary>
@@ -1117,25 +1139,36 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
 
         public override void StatusEventHandler(object sender, BuildStatusEventArgs e)
         {
-            if (showPerfSummary)
+            if (e is ProjectEvaluationStartedEventArgs projectEvaluationStarted)
             {
-                ProjectEvaluationStartedEventArgs projectEvaluationStarted = e as ProjectEvaluationStartedEventArgs;
-
-                if (projectEvaluationStarted != null)
+                if (showPerfSummary)
                 {
                     MPPerformanceCounter counter = GetPerformanceCounter(projectEvaluationStarted.ProjectFile, ref projectEvaluationPerformanceCounters);
                     counter.AddEventStarted(null, e.BuildEventContext, e.Timestamp, s_compareContextNodeId);
-
-                    return;
                 }
-
-                ProjectEvaluationFinishedEventArgs projectEvaluationFinished = e as ProjectEvaluationFinishedEventArgs;
-
-                if (projectEvaluationFinished != null)
+            }
+            else if (e is ProjectEvaluationFinishedEventArgs projectEvaluationFinished)
+            {
+                if (showPerfSummary)
                 {
                     MPPerformanceCounter counter = GetPerformanceCounter(projectEvaluationFinished.ProjectFile, ref projectEvaluationPerformanceCounters);
                     counter.AddEventFinished(null, e.BuildEventContext, e.Timestamp);
                 }
+
+                if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
+                {
+                    if (projectEvaluationFinished.Properties != null)
+                    {
+                        WriteProperties(projectEvaluationFinished, projectEvaluationFinished.Properties);
+                    }
+
+                    if (projectEvaluationFinished.Items != null)
+                    {
+                        WriteItems(projectEvaluationFinished, projectEvaluationFinished.Items);
+                    }
+                }
+
+                ReadProjectConfigurationDescription(projectEvaluationFinished.BuildEventContext, projectEvaluationFinished.Items);
             }
         }
 
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 50dd953d5e3..c47c5ed976d 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -571,25 +571,36 @@ public override void CustomEventHandler(object sender, CustomBuildEventArgs e)
 
         public override void StatusEventHandler(object sender, BuildStatusEventArgs e)
         {
-            if (showPerfSummary)
+            if (e is ProjectEvaluationStartedEventArgs projectEvaluationStarted)
             {
-                ProjectEvaluationStartedEventArgs projectEvaluationStarted = e as ProjectEvaluationStartedEventArgs;
-
-                if (projectEvaluationStarted != null)
+                if (showPerfSummary)
                 {
                     PerformanceCounter counter = GetPerformanceCounter(projectEvaluationStarted.ProjectFile, ref projectEvaluationPerformanceCounters);
                     counter.InScope = true;
-
-                    return;
                 }
-
-                ProjectEvaluationFinishedEventArgs projectEvaluationFinished = e as ProjectEvaluationFinishedEventArgs;
-
-                if (projectEvaluationFinished != null)
+            }
+            else if (e is ProjectEvaluationFinishedEventArgs projectEvaluationFinished)
+            {
+                if (showPerfSummary)
                 {
                     PerformanceCounter counter = GetPerformanceCounter(projectEvaluationFinished.ProjectFile, ref projectEvaluationPerformanceCounters);
                     counter.InScope = false;
                 }
+
+                if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
+                {
+                    if (projectEvaluationFinished.Properties != null)
+                    {
+                        var propertyList = ExtractPropertyList(projectEvaluationFinished.Properties);
+                        WriteProperties(propertyList);
+                    }
+
+                    if (projectEvaluationFinished.Items != null)
+                    {
+                        SortedList itemList = ExtractItemList(projectEvaluationFinished.Items);
+                        WriteItems(itemList);
+                    }
+                }
             }
         }
 
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index 6aae23a460e..325dc50740a 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -2,14 +2,16 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Xml;
+using System.Diagnostics;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
+using System.Xml;
 
 using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using Toolset = Microsoft.Build.Evaluation.Toolset;
@@ -613,5 +615,116 @@ public static T[] ToArray<T>(this IEnumerator<T> enumerator)
         {
             return enumerator.ToEnumerable().ToArray();
         }
+
+        public static void EnumerateProperties(IEnumerable properties, Action<KeyValuePair<string, string>> callback)
+        {
+            if (properties == null)
+            {
+                return;
+            }
+
+            if (properties is PropertyDictionary<ProjectPropertyInstance> propertyInstanceDictionary)
+            {
+                propertyInstanceDictionary.Enumerate((key, value) =>
+                {
+                    callback(new KeyValuePair<string, string>(key, value));
+                });
+            }
+            else if (properties is PropertyDictionary<ProjectProperty> propertyDictionary)
+            {
+                propertyDictionary.Enumerate((key, value) =>
+                {
+                    callback(new KeyValuePair<string, string>(key, value));
+                });
+            }
+            else
+            {
+                foreach (var item in properties)
+                {
+                    if (item is IProperty property && !string.IsNullOrEmpty(property.Name))
+                    {
+                        callback(new KeyValuePair<string, string>(property.Name, property.EvaluatedValue ?? string.Empty));
+                    }
+                    else if (item is DictionaryEntry dictionaryEntry && dictionaryEntry.Key is string key && !string.IsNullOrEmpty(key))
+                    {
+                        callback(new KeyValuePair<string, string>(key, dictionaryEntry.Value as string ?? string.Empty));
+                    }
+                    else if (item is KeyValuePair<string, string> kvp)
+                    {
+                        callback(kvp);
+                    }
+                    else
+                    {
+                        if (item == null)
+                        {
+                            Debug.Fail($"In {nameof(EnumerateProperties)}(): Unexpected: property is null");
+                        }
+                        else
+                        {
+                            Debug.Fail($"In {nameof(EnumerateProperties)}(): Unexpected property {item} of type {item?.GetType().ToString()}");
+                        }
+                    }
+                }
+            }
+        }
+
+        public static void EnumerateItems(IEnumerable items, Action<DictionaryEntry> callback)
+        {
+            if (items is ItemDictionary<ProjectItemInstance> projectItemInstanceDictionary)
+            {
+                projectItemInstanceDictionary.EnumerateItemsPerType((itemType, itemList) =>
+                {
+                    foreach (var item in itemList)
+                    {
+                        callback(new DictionaryEntry(itemType, item));
+                    }
+                });
+            }
+            else if (items is ItemDictionary<ProjectItem> projectItemDictionary)
+            {
+                projectItemDictionary.EnumerateItemsPerType((itemType, itemList) =>
+                {
+                    foreach (var item in itemList)
+                    {
+                        callback(new DictionaryEntry(itemType, item));
+                    }
+                });
+            }
+            else
+            {
+                foreach (var item in items)
+                {
+                    string itemType = default;
+                    object itemValue = null;
+
+                    if (item is IItem iitem)
+                    {
+                        itemType = iitem.Key;
+                        itemValue = iitem;
+                    }
+                    else if (item is DictionaryEntry dictionaryEntry)
+                    {
+                        itemType = dictionaryEntry.Key as string;
+                        itemValue = dictionaryEntry.Value;
+                    }
+                    else
+                    {
+                        if (item == null)
+                        {
+                            Debug.Fail($"In {nameof(EnumerateItems)}(): Unexpected: {nameof(item)} is null");
+                        }
+                        else
+                        {
+                            Debug.Fail($"In {nameof(EnumerateItems)}(): Unexpected {nameof(item)} {item} of type {item?.GetType().ToString()}");
+                        }
+                    }
+
+                    if (!String.IsNullOrEmpty(itemType))
+                    {
+                        callback(new DictionaryEntry(itemType, itemValue));
+                    }
+                }
+            }
+        }
     }
 }
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index 58dc81f838a..06e71865122 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -116,7 +116,7 @@ public DateTime Timestamp
         /// Used for serialization. Avoids the side effects of calling the
         /// <see cref="Timestamp"/> getter.
         /// </summary>
-        protected DateTime RawTimestamp
+        protected internal DateTime RawTimestamp
         {
             get => timestamp;
             set => timestamp = value;
diff --git a/src/Framework/IEventSource4.cs b/src/Framework/IEventSource4.cs
new file mode 100644
index 00000000000..3b6cc009be4
--- /dev/null
+++ b/src/Framework/IEventSource4.cs
@@ -0,0 +1,19 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// This interface defines the events raised by the build engine.
+    /// Loggers use this interface to subscribe to the events they
+    /// are interested in receiving.
+    /// </summary>
+    public interface IEventSource4 : IEventSource3
+    {
+        /// <summary>
+        /// Determines whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>.
+        /// </summary>
+        void IncludeEvaluationPropertiesAndItems();
+    }
+}
diff --git a/src/Framework/ProjectEvaluationFinishedEventArgs.cs b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
index 1d900b49c03..88073ecf3ac 100644
--- a/src/Framework/ProjectEvaluationFinishedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using Microsoft.Build.Framework.Profiler;
 
 namespace Microsoft.Build.Framework
@@ -23,7 +24,7 @@ public ProjectEvaluationFinishedEventArgs()
         /// Initializes a new instance of the ProjectEvaluationFinishedEventArgs class.
         /// </summary>
         public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs)
-            : base(message, null, null, DateTime.UtcNow, messageArgs)
+            : base(message, helpKeyword: null, senderName: null, DateTime.UtcNow, messageArgs)
         {
         }
 
@@ -32,12 +33,27 @@ public ProjectEvaluationFinishedEventArgs(string message, params object[] messag
         /// </summary>
         public string ProjectFile { get; set; }
 
+        /// <summary>
+        /// Global properties used during this evaluation.
+        /// </summary>
+        public IEnumerable GlobalProperties { get; set; }
+
+        /// <summary>
+        /// Final set of properties produced by this evaluation.
+        /// </summary>
+        public IEnumerable Properties { get; set; }
+
+        /// <summary>
+        /// Final set of items produced by this evaluation.
+        /// </summary>
+        public IEnumerable Items { get; set; }
+
         /// <summary>
         /// The result of profiling a project.
         /// </summary>
         /// <remarks>
         /// Null if profiling is not turned on
         /// </remarks>
-        public ProfilerResult? ProfilerResult { get; set; } 
+        public ProfilerResult? ProfilerResult { get; set; }
     }
 }
diff --git a/src/Framework/ProjectEvaluationStartedEventArgs.cs b/src/Framework/ProjectEvaluationStartedEventArgs.cs
index 80332d2c4f4..14100183747 100644
--- a/src/Framework/ProjectEvaluationStartedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationStartedEventArgs.cs
@@ -22,7 +22,7 @@ public ProjectEvaluationStartedEventArgs()
         /// Initializes a new instance of the ProjectEvaluationStartedEventArgs class.
         /// </summary>
         public ProjectEvaluationStartedEventArgs(string message, params object[] messageArgs)
-            : base(message, null, null, DateTime.UtcNow, messageArgs)
+            : base(message, helpKeyword: null, senderName: null, DateTime.UtcNow, messageArgs)
         {
         }
 
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index af98f64d8bc..912ca4f12ef 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -40,6 +40,7 @@
     <AddAppConfigToBuildOutputs>false</AddAppConfigToBuildOutputs>
 
     <DebugType Condition="'$(Platform)' == 'x64'">full</DebugType><!-- Setting DebugType here goes hand in hand with eng\AfterSigning.targets. This is to prompt the x64 build to produce a 'full' .pdb that's `more compatible` then 'portable' and 'embedded' .pdbs. This doesn't get set on 32 bit architecture, which will default to 'embedded' and 'pdb2pdb' will convert those as needed. See https://github.com/microsoft/msbuild/pull/5070 for context. -->
+    <DefineConstants>$(DefineConstants);MSBUILDENTRYPOINTEXE</DefineConstants>
   </PropertyGroup>
 
   <PropertyGroup>
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index ab68c229c04..449f54c4dd2 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -2,12 +2,21 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Reflection;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Framework;
+
+#if !TASKHOST
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework.Profiler;
+using Microsoft.Build.Execution;
+#endif
+
 #if FEATURE_APPDOMAIN
 using TaskEngineAssemblyResolver = Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver;
 #endif
@@ -95,6 +104,16 @@ internal enum LoggingEventType : int
         /// Event is a TaskParameterEventArgs
         /// </summary>
         TaskParameterEvent = 13,
+
+        /// <summary>
+        /// Event is a ProjectEvaluationStartedEventArgs
+        /// </summary>
+        ProjectEvaluationStartedEvent = 14,
+
+        /// <summary>
+        /// Event is a ProjectEvaluationFinishedEventArgs
+        /// </summary>
+        ProjectEvaluationFinishedEvent = 15
     }
     #endregion
 
@@ -296,6 +315,17 @@ internal void WriteToStream(ITranslator translator)
                 translator.Translate(ref packetVersion);
 
                 bool eventCanSerializeItself = methodInfo != null;
+
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+                if (_buildEvent is ProjectEvaluationStartedEventArgs ||
+                    _buildEvent is ProjectEvaluationFinishedEventArgs)
+                {
+                    // switch to serialization methods that we provide in this file
+                    // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
+                    eventCanSerializeItself = false;
+                }
+#endif
+
                 translator.Translate(ref eventCanSerializeItself);
 
                 if (eventCanSerializeItself)
@@ -464,40 +494,27 @@ private static Delegate CreateDelegateRobust(Type type, Object firstArgument, Me
         /// </summary>
         private BuildEventArgs GetBuildEventArgFromId()
         {
-            switch (_eventType)
+            return _eventType switch
             {
-                case LoggingEventType.BuildErrorEvent:
-                    return new BuildErrorEventArgs(null, null, null, -1, -1, -1, -1, null, null, null);
-                case LoggingEventType.BuildFinishedEvent:
-                    return new BuildFinishedEventArgs(null, null, false);
-                case LoggingEventType.BuildMessageEvent:
-                    return new BuildMessageEventArgs(null, null, null, MessageImportance.Normal);
-                case LoggingEventType.BuildStartedEvent:
-                    return new BuildStartedEventArgs(null, null);
-                case LoggingEventType.BuildWarningEvent:
-                    return new BuildWarningEventArgs(null, null, null, -1, -1, -1, -1, null, null, null);
-                case LoggingEventType.ProjectFinishedEvent:
-                    return new ProjectFinishedEventArgs(null, null, null, false);
-                case LoggingEventType.ProjectStartedEvent:
-                    return new ProjectStartedEventArgs(null, null, null, null, null, null);
-                case LoggingEventType.TargetStartedEvent:
-                    return new TargetStartedEventArgs(null, null, null, null, null);
-                case LoggingEventType.TargetFinishedEvent:
-                    return new TargetFinishedEventArgs(null, null, null, null, null, false);
-                case LoggingEventType.TaskStartedEvent:
-                    return new TaskStartedEventArgs(null, null, null, null, null);
-                case LoggingEventType.TaskFinishedEvent:
-                    return new TaskFinishedEventArgs(null, null, null, null, null, false);
-                case LoggingEventType.TaskCommandLineEvent:
-                    return new TaskCommandLineEventArgs(null, null, MessageImportance.Normal);
+                LoggingEventType.BuildErrorEvent => new BuildErrorEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),
+                LoggingEventType.BuildFinishedEvent => new BuildFinishedEventArgs(null, null, false),
+                LoggingEventType.BuildMessageEvent => new BuildMessageEventArgs(null, null, null, MessageImportance.Normal),
+                LoggingEventType.BuildStartedEvent => new BuildStartedEventArgs(null, null),
+                LoggingEventType.BuildWarningEvent => new BuildWarningEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),
+                LoggingEventType.ProjectFinishedEvent => new ProjectFinishedEventArgs(null, null, null, false),
+                LoggingEventType.ProjectStartedEvent => new ProjectStartedEventArgs(null, null, null, null, null, null),
+                LoggingEventType.TargetStartedEvent => new TargetStartedEventArgs(null, null, null, null, null),
+                LoggingEventType.TargetFinishedEvent => new TargetFinishedEventArgs(null, null, null, null, null, false),
+                LoggingEventType.TaskStartedEvent => new TaskStartedEventArgs(null, null, null, null, null),
+                LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
+                LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
-                case LoggingEventType.TaskParameterEvent:
-                    return new TaskParameterEventArgs(0, null, null, true, default);
+                LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
+                LoggingEventType.ProjectEvaluationStartedEvent => new ProjectEvaluationStartedEventArgs(),
+                LoggingEventType.ProjectEvaluationFinishedEvent => new ProjectEvaluationFinishedEventArgs(),
 #endif
-                default:
-                    ErrorUtilities.VerifyThrow(false, "Should not get to the default of GetBuildEventArgFromId ID: " + _eventType);
-                    return null;
-            }
+                _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
+            };
         }
 
         /// <summary>
@@ -532,6 +549,16 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.ProjectStartedEvent;
             }
+#if !TASKHOST
+            else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))
+            {
+                return LoggingEventType.ProjectEvaluationFinishedEvent;
+            }
+            else if (eventType == typeof(ProjectEvaluationStartedEventArgs))
+            {
+                return LoggingEventType.ProjectEvaluationStartedEvent;
+            }
+#endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
                 return LoggingEventType.TargetStartedEvent;
@@ -576,6 +603,19 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
         /// </summary>
         private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType eventType, ITranslator translator)
         {
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+            if (eventType == LoggingEventType.ProjectEvaluationStartedEvent)
+            {
+                WriteProjectEvaluationStartedEventToStream((ProjectEvaluationStartedEventArgs)buildEvent, translator);
+                return;
+            }
+            else if (eventType == LoggingEventType.ProjectEvaluationFinishedEvent)
+            {
+                WriteProjectEvaluationFinishedEventToStream((ProjectEvaluationFinishedEventArgs)buildEvent, translator);
+                return;
+            }
+#endif
+
             string message = buildEvent.Message;
             string helpKeyword = buildEvent.HelpKeyword;
             string senderName = buildEvent.SenderName;
@@ -715,6 +755,207 @@ private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEv
             translator.TranslateEnum(ref importance, (int)importance);
         }
 
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+        private void WriteProjectEvaluationStartedEventToStream(ProjectEvaluationStartedEventArgs args, ITranslator translator)
+        {
+            WriteEvaluationEvent(args, args.ProjectFile, args.RawTimestamp, translator);
+        }
+
+        private void WriteProjectEvaluationFinishedEventToStream(ProjectEvaluationFinishedEventArgs args, ITranslator translator)
+        {
+            WriteEvaluationEvent(args, args.ProjectFile, args.RawTimestamp, translator);
+
+            WriteProperties(args.GlobalProperties, translator);
+            WriteProperties(args.Properties, translator);
+            WriteItems(args.Items, translator);
+            WriteProfileResult(args.ProfilerResult, translator);
+        }
+
+        private static void WriteEvaluationEvent(BuildStatusEventArgs args, string projectFile, DateTime timestamp, ITranslator translator)
+        {
+            var buildEventContext = args.BuildEventContext;
+            translator.Translate(ref buildEventContext);
+            translator.Translate(ref timestamp);
+            translator.Translate(ref projectFile);
+        }
+
+        private void WriteProfileResult(ProfilerResult? result, ITranslator translator)
+        {
+            bool hasValue = result.HasValue;
+            translator.Translate(ref hasValue);
+            if (hasValue)
+            {
+                var value = result.Value;
+                var count = value.ProfiledLocations.Count;
+                translator.Translate(ref count);
+
+                foreach (var item in value.ProfiledLocations)
+                {
+                    WriteEvaluationLocation(translator, item.Key);
+                    WriteProfiledLocation(translator, item.Value);
+                }
+            }
+        }
+
+        private void WriteEvaluationLocation(ITranslator translator, EvaluationLocation evaluationLocation)
+        {
+            string elementName = evaluationLocation.ElementName;
+            string elementDescription = evaluationLocation.ElementDescription;
+            string evaluationPassDescription = evaluationLocation.EvaluationPassDescription;
+            string file = evaluationLocation.File;
+            int kind = (int)evaluationLocation.Kind;
+            int evaluationPass = (int)evaluationLocation.EvaluationPass;
+            bool lineHasValue = evaluationLocation.Line.HasValue;
+            int line = lineHasValue ? evaluationLocation.Line.Value : 0;
+            long id = evaluationLocation.Id;
+            bool parentIdHasValue = evaluationLocation.ParentId.HasValue;
+            long parentId = parentIdHasValue ? evaluationLocation.ParentId.Value : 0;
+
+            translator.Translate(ref elementName);
+            translator.Translate(ref elementDescription);
+            translator.Translate(ref evaluationPassDescription);
+            translator.Translate(ref file);
+
+            translator.Translate(ref kind);
+            translator.Translate(ref evaluationPass);
+
+            translator.Translate(ref lineHasValue);
+            if (lineHasValue)
+            {
+                translator.Translate(ref line);
+            }
+
+            translator.Translate(ref id);
+            translator.Translate(ref parentIdHasValue);
+            if (parentIdHasValue)
+            {
+                translator.Translate(ref parentId);
+            }
+        }
+
+        private void WriteProfiledLocation(ITranslator translator, ProfiledLocation profiledLocation)
+        {
+            int numberOfHits = profiledLocation.NumberOfHits;
+            TimeSpan exclusiveTime = profiledLocation.ExclusiveTime;
+            TimeSpan inclusiveTime = profiledLocation.InclusiveTime;
+            translator.Translate(ref numberOfHits);
+            translator.Translate(ref exclusiveTime);
+            translator.Translate(ref inclusiveTime);
+        }
+
+        [ThreadStatic]
+        private static List<KeyValuePair<string, string>> reusablePropertyList;
+
+        [ThreadStatic]
+        private static List<(string itemType, object item)> reusableItemList;
+
+        private void WriteProperties(IEnumerable properties, ITranslator translator)
+        {
+            var writer = translator.Writer;
+            if (properties == null)
+            {
+                writer.Write((byte)0);
+                return;
+            }
+
+            if (reusablePropertyList == null)
+            {
+                reusablePropertyList = new List<KeyValuePair<string, string>>();
+            }
+
+            // it is expensive to access a ThreadStatic field every time
+            var list = reusablePropertyList;
+
+            Internal.Utilities.EnumerateProperties(properties, kvp => list.Add(kvp));
+
+            BinaryWriterExtensions.Write7BitEncodedInt(writer, list.Count);
+
+            foreach (var item in list)
+            {
+                writer.Write(item.Key);
+                writer.Write(item.Value);
+            }
+
+            list.Clear();
+        }
+
+        private void WriteItems(IEnumerable items, ITranslator translator)
+        {
+            var writer = translator.Writer;
+            if (items == null)
+            {
+                writer.Write((byte)0);
+                return;
+            }
+
+            if (reusableItemList == null)
+            {
+                reusableItemList = new List<(string itemType, object item)>();
+            }
+
+            var list = reusableItemList;
+
+            Internal.Utilities.EnumerateItems(items, dictionaryEntry =>
+            {
+                list.Add((dictionaryEntry.Key as string, dictionaryEntry.Value));
+            });
+
+            BinaryWriterExtensions.Write7BitEncodedInt(writer, list.Count);
+
+            foreach (var kvp in list)
+            {
+                writer.Write(kvp.itemType);
+                if (kvp.item is ITaskItem taskItem)
+                {
+                    writer.Write(taskItem.ItemSpec);
+                    WriteMetadata(taskItem, writer);
+                }
+                else
+                {
+                    writer.Write(kvp.item?.ToString() ?? "");
+                    writer.Write((byte)0);
+                }
+            }
+
+            list.Clear();
+        }
+
+        private void WriteMetadata(object metadataContainer, BinaryWriter writer)
+        {
+            if (metadataContainer is ITaskItem taskItem)
+            {
+                var metadata = taskItem.EnumerateMetadata();
+
+                if (reusablePropertyList == null)
+                {
+                    reusablePropertyList = new List<KeyValuePair<string, string>>();
+                }
+
+                // it is expensive to access a ThreadStatic field every time
+                var list = reusablePropertyList;
+
+                foreach (var item in metadata)
+                {
+                    list.Add(item);
+                }
+
+                BinaryWriterExtensions.Write7BitEncodedInt(writer, list.Count);
+                foreach (var kvp in list)
+                {
+                    writer.Write(kvp.Key ?? string.Empty);
+                    writer.Write(kvp.Value ?? string.Empty);
+                }
+
+                list.Clear();
+            }
+            else
+            {
+                writer.Write((byte)0);
+            }
+        }
+
+#endif
+
         #endregion
 
         #region Reads from Stream
@@ -725,6 +966,17 @@ private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEv
         /// </summary>
         private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslator translator)
         {
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+            if (eventType == LoggingEventType.ProjectEvaluationStartedEvent)
+            {
+                return ReadProjectEvaluationStartedEventFromStream(translator);
+            }
+            else if (eventType == LoggingEventType.ProjectEvaluationFinishedEvent)
+            {
+                return ReadProjectEvaluationFinishedEventFromStream(translator);
+            }
+#endif
+
             string message = null;
             string helpKeyword = null;
             string senderName = null;
@@ -921,6 +1173,213 @@ private BuildMessageEventArgs ReadBuildMessageEventFromStream(ITranslator transl
             return buildEvent;
         }
 
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+        private ProjectEvaluationStartedEventArgs ReadProjectEvaluationStartedEventFromStream(ITranslator translator)
+        {
+            var (buildEventContext, timestamp, projectFile) = ReadEvaluationEvent(translator);
+
+            var args = new ProjectEvaluationStartedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationStarted"), projectFile);
+
+            args.BuildEventContext = buildEventContext;
+            args.RawTimestamp = timestamp;
+            args.ProjectFile = projectFile;
+
+            return args;
+        }
+
+        private ProjectEvaluationFinishedEventArgs ReadProjectEvaluationFinishedEventFromStream(ITranslator translator)
+        {
+            var (buildEventContext, timestamp, projectFile) = ReadEvaluationEvent(translator);
+
+            var args = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile);
+
+            args.BuildEventContext = buildEventContext;
+            args.RawTimestamp = timestamp;
+            args.ProjectFile = projectFile;
+
+            args.GlobalProperties = ReadProperties(translator);
+            args.Properties = ReadProperties(translator);
+            args.Items = ReadItems(translator);
+            args.ProfilerResult = ReadProfileResult(translator);
+
+            return args;
+        }
+
+        private (BuildEventContext buildEventContext, DateTime timestamp, string projectFile)
+            ReadEvaluationEvent(ITranslator translator)
+        {
+            BuildEventContext buildEventContext = null;
+            translator.Translate(ref buildEventContext);
+
+            DateTime timestamp = default;
+            translator.Translate(ref timestamp);
+
+            string projectFile = null;
+            translator.Translate(ref projectFile);
+
+            return (buildEventContext, timestamp, projectFile);
+        }
+
+        private IEnumerable ReadProperties(ITranslator translator)
+        {
+            var reader = translator.Reader;
+            int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
+            if (count == 0)
+            {
+                return Array.Empty<DictionaryEntry>();
+            }
+
+            var list = new ArrayList(count);
+            for (int i = 0; i < count; i++)
+            {
+                string key = reader.ReadString();
+                string value = reader.ReadString();
+                var entry = new DictionaryEntry(key, value);
+                list.Add(entry);
+            }
+
+            return list;
+        }
+
+        private IEnumerable ReadItems(ITranslator translator)
+        {
+            var reader = translator.Reader;
+
+            int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
+            if (count == 0)
+            {
+                return Array.Empty<DictionaryEntry>();
+            }
+
+            var list = new ArrayList(count);
+            for (int i = 0; i < count; i++)
+            {
+                string itemType = reader.ReadString();
+                string evaluatedValue = reader.ReadString();
+                var metadata = ReadMetadata(reader);
+                var taskItemData = new TaskItemData(evaluatedValue, metadata);
+                var entry = new DictionaryEntry(itemType, taskItemData);
+                list.Add(entry);
+            }
+
+            return list;
+        }
+
+        private IDictionary<string, string> ReadMetadata(BinaryReader reader)
+        {
+            int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
+            if (count == 0)
+            {
+                return null;
+            }
+
+            var list = ArrayDictionary<string, string>.Create(count);
+            for (int i = 0; i < count; i++)
+            {
+                string key = reader.ReadString();
+                string value = reader.ReadString();
+                list.Add(key, value);
+            }
+
+            return list;
+        }
+
+        private ProfilerResult? ReadProfileResult(ITranslator translator)
+        {
+            bool hasValue = false;
+            translator.Translate(ref hasValue);
+            if (!hasValue)
+            {
+                return null;
+            }
+
+            int count = 0;
+            translator.Translate(ref count);
+
+            var dictionary = new ArrayDictionary<EvaluationLocation, ProfiledLocation>(count);
+
+            for (int i = 0; i < count; i++)
+            {
+                var evaluationLocation = ReadEvaluationLocation(translator);
+                var profiledLocation = ReadProfiledLocation(translator);
+                dictionary.Add(evaluationLocation, profiledLocation);
+            }
+
+            var result = new ProfilerResult(dictionary);
+            return result;
+        }
+
+        private EvaluationLocation ReadEvaluationLocation(ITranslator translator)
+        {
+            string elementName = default;
+            string elementDescription = default;
+            string evaluationPassDescription = default;
+            string file = default;
+            int kind = default;
+            int evaluationPass = default;
+            bool lineHasValue = default;
+            int line = default;
+            long id = default;
+            bool parentIdHasValue = default;
+            long parentId = default;
+
+            translator.Translate(ref elementName);
+            translator.Translate(ref elementDescription);
+            translator.Translate(ref evaluationPassDescription);
+            translator.Translate(ref file);
+
+            translator.Translate(ref kind);
+            translator.Translate(ref evaluationPass);
+
+            translator.Translate(ref lineHasValue);
+            if (lineHasValue)
+            {
+                translator.Translate(ref line);
+            }
+
+            translator.Translate(ref id);
+            translator.Translate(ref parentIdHasValue);
+            if (parentIdHasValue)
+            {
+                translator.Translate(ref parentId);
+            }
+
+            var evaluationLocation = new EvaluationLocation(
+                id,
+                parentIdHasValue ? parentId : null,
+                (EvaluationPass)evaluationPass,
+                evaluationPassDescription,
+                file,
+                lineHasValue ? line : null,
+                elementName,
+                elementDescription,
+                (EvaluationLocationKind)kind);
+
+            return evaluationLocation;
+        }
+
+        private ProfiledLocation ReadProfiledLocation(ITranslator translator)
+        {
+            int numberOfHits = default;
+            TimeSpan exclusiveTime = default;
+            TimeSpan inclusiveTime = default;
+
+            translator.Translate(ref numberOfHits);
+            translator.Translate(ref exclusiveTime);
+            translator.Translate(ref inclusiveTime);
+
+            var profiledLocation = new ProfiledLocation(
+                inclusiveTime,
+                exclusiveTime,
+                numberOfHits);
+
+            return profiledLocation;
+        }
+
+#endif
+
         #endregion
 
         #endregion
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 7aa78f0bbeb..09cca604107 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -175,6 +175,32 @@ public bool LogTaskInputs
             }
         }
 
+        private bool? _logPropertiesAndItemsAfterEvaluation;
+        private bool _logPropertiesAndItemsAfterEvaluationInitialized = false;
+        public bool? LogPropertiesAndItemsAfterEvaluation
+        {
+            get
+            {
+                if (!_logPropertiesAndItemsAfterEvaluationInitialized)
+                {
+                    _logPropertiesAndItemsAfterEvaluationInitialized = true;
+                    var variable = Environment.GetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION");
+                    if (!string.IsNullOrEmpty(variable))
+                    {
+                        _logPropertiesAndItemsAfterEvaluation = variable == "1" || string.Equals(variable, "true", StringComparison.OrdinalIgnoreCase);
+                    }
+                }
+
+                return _logPropertiesAndItemsAfterEvaluation;
+            }
+
+            set
+            {
+                _logPropertiesAndItemsAfterEvaluationInitialized = true;
+                _logPropertiesAndItemsAfterEvaluation = value;
+            }
+        }
+
         /// <summary>
         /// Read information only once per file per ResolveAssemblyReference invocation.
         /// </summary>
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 819fff3bf65..fdb9263ac2e 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -130,6 +130,12 @@ public MuxLogger()
         /// </summary>
         public bool IncludeTaskInputs { get; set; }
 
+        /// <summary>
+        /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>?
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems { get; set; }
+
         /// <summary>
         /// Initialize the logger.
         /// </summary>
@@ -159,6 +165,7 @@ public void Initialize(IEventSource eventSource, int maxNodeCount)
                 {
                     eventSource3.IncludeEvaluationMetaprojects();
                 }
+
                 if (IncludeEvaluationProfiles)
                 {
                     eventSource3.IncludeEvaluationProfiles();
@@ -169,6 +176,14 @@ public void Initialize(IEventSource eventSource, int maxNodeCount)
                     eventSource3.IncludeTaskInputs();
                 }
             }
+
+            if (_eventSourceForBuild is IEventSource4 eventSource4)
+            {
+                if (IncludeEvaluationPropertiesAndItems)
+                {
+                    eventSource4.IncludeEvaluationPropertiesAndItems();
+                }
+            }
         }
 
         /// <summary>
