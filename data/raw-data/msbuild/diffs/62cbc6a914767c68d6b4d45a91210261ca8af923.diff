diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 97ee0796fef..a7d05ac32c9 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -54,13 +54,13 @@
       <Sha>bc3233146e1fcd393ed471d5005333c83363e0fe</Sha>
       <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.7.0-rc.106">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.7.0-rc.111">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>4b6a87bfe90d247f961eba41d63dbf418a56fdcc</Sha>
+      <Sha>13f2b6af6e9864711e815cfbffd7aa5015c52cec</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.7.0-3.23324.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.7.0-3.23329.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>d0f4099ffa7f8ff31fd397a4a96f404e1cd7dfc7</Sha>
+      <Sha>b2bd4936daed91d4efd10c71177f7766823e615c</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23313.5">
diff --git a/eng/Versions.props b/eng/Versions.props
index fa8dc8ab18e..496e4e47684 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -51,8 +51,8 @@
     <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23313.5</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.7.0-3.23324.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.7.0-rc.106</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.7.0-3.23329.1</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.7.0-rc.111</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.0</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index ac2409c2a04..030c6db60c3 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -2839,6 +2839,290 @@ public void PropertyFunctionRuntimeInformation(string propertyFunction, string e
             Assert.Equal(expectedExpansion, result);
         }
 
+        [Theory]
+        [InlineData("windows")]
+        [InlineData("linux")]
+        [InlineData("macos")]
+        [InlineData("osx")]
+        public void IsOSPlatform(string platform)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsOSPlatform('{platform}'))";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsOSPlatform(platform);
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsOSPlatform(platform);
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData("windows", 4, 0, 0, 0)]
+        [InlineData("windows", 999, 0, 0, 0)]
+        [InlineData("linux", 0, 0, 0, 0)]
+        [InlineData("macos", 10, 15, 0, 0)]
+        [InlineData("macos", 999, 0, 0, 0)]
+        [InlineData("osx", 0, 0, 0, 0)]
+        public void IsOSPlatformVersionAtLeast(string platform, int major, int minor, int build, int revision)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsOSPlatformVersionAtLeast('{platform}', {major}, {minor}, {build}, {revision}))";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsOSPlatformVersionAtLeast(platform, major, minor, build, revision);
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsOSPlatformVersionAtLeast(platform, major, minor, build, revision);
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsLinux()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsLinux())";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsLinux();
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsLinux();
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsFreeBSD()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsFreeBSD())";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = System.OperatingSystem.IsFreeBSD();
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsFreeBSD();
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0, 0)]
+        [InlineData(999, 0, 0, 0)]
+        public void IsFreeBSDVersionAtLeast(int major, int minor, int build, int revision)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsFreeBSDVersionAtLeast({major}, {minor}, {build}, {revision}))";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsFreeBSDVersionAtLeast(major, minor, build, revision);
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsFreeBSDVersionAtLeast(major, minor, build, revision);
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsMacOS()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsMacOS())";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsMacOS();
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsMacOS();
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0)]
+        [InlineData(10, 15, 0)]
+        [InlineData(999, 0, 0)]
+        public void IsMacOSVersionAtLeast(int major, int minor, int build)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsMacOSVersionAtLeast({major}, {minor}, {build}))";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsMacOSVersionAtLeast(major, minor, build);
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsMacOSVersionAtLeast(major, minor, build);
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsWindows()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsWindows())";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsWindows();
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsWindows();
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0, 0)]
+        [InlineData(4, 0, 0, 0)]
+        [InlineData(999, 0, 0, 0)]
+        public void IsWindowsVersionAtLeast(int major, int minor, int build, int revision)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsWindowsVersionAtLeast({major}, {minor}, {build}, {revision}))";
+            bool result = false;
+#if NET5_0_OR_GREATER
+            result = OperatingSystem.IsWindowsVersionAtLeast(major, minor, build, revision);
+#else
+            result = Microsoft.Build.Framework.OperatingSystem.IsWindowsVersionAtLeast(major, minor, build, revision);
+#endif
+            string expected = result ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+#if NET5_0_OR_GREATER
+
+        [Fact]
+        public void IsAndroid()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsAndroid())";
+
+            string expected = OperatingSystem.IsAndroid() ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0, 0)]
+        [InlineData(999, 0, 0, 0)]
+        public void IsAndroidVersionAtLeast(int major, int minor, int build, int revision)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsAndroidVersionAtLeast({major}, {minor}, {build}, {revision}))";
+            string expected = OperatingSystem.IsAndroidVersionAtLeast(major, minor, build, revision) ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsIOS()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsIOS())";
+
+            string expected = OperatingSystem.IsIOS() ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0)]
+        [InlineData(16, 5, 1)]
+        [InlineData(999, 0, 0)]
+        public void IsIOSVersionAtLeast(int major, int minor, int build)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsIOSVersionAtLeast({major}, {minor}, {build}))";
+            string expected = OperatingSystem.IsIOSVersionAtLeast(major, minor, build) ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsMacCatalyst()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsMacCatalyst())";
+
+            string expected = OperatingSystem.IsMacCatalyst() ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0)]
+        [InlineData(999, 0, 0)]
+        public void IsMacCatalystVersionAtLeast(int major, int minor, int build)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsMacCatalystVersionAtLeast({major}, {minor}, {build}))";
+            string expected = OperatingSystem.IsMacCatalystVersionAtLeast(major, minor, build) ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsTvOS()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsTvOS())";
+
+            string expected = OperatingSystem.IsTvOS() ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0)]
+        [InlineData(16, 5, 0)]
+        [InlineData(999, 0, 0)]
+        public void IsTvOSVersionAtLeast(int major, int minor, int build)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsTvOSVersionAtLeast({major}, {minor}, {build}))";
+            string expected = OperatingSystem.IsTvOSVersionAtLeast(major, minor, build) ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Fact]
+        public void IsWatchOS()
+        {
+            const string propertyFunction = "$([System.OperatingSystem]::IsWatchOS())";
+
+            string expected = OperatingSystem.IsWatchOS() ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+        [Theory]
+        [InlineData(0, 0, 0)]
+        [InlineData(9, 5, 2)]
+        [InlineData(999, 0, 0)]
+        public void IsWatchOSVersionAtLeast(int major, int minor, int build)
+        {
+            string propertyFunction = $"$([System.OperatingSystem]::IsWatchOSVersionAtLeast({major}, {minor}, {build}))";
+            string expected = OperatingSystem.IsWatchOSVersionAtLeast(major, minor, build) ? "True" : "False";
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            expander.ExpandIntoStringLeaveEscaped(propertyFunction, ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe(expected);
+        }
+
+#endif
+
         [Theory]
         [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('x', 1))", "3")]
         [InlineData("AString", "x12x456789x11", "$(AString.IndexOf('x45', 1))", "3")]
diff --git a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
index 0f9f1858b52..7e03b6cfd3e 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
@@ -157,11 +157,14 @@ private void CurrentDomainOnAssemblyLoad(object? sender, AssemblyLoadEventArgs a
                 : $"{_appDomain.Id}|{_appDomain.FriendlyName}";
 
 
-            AssemblyLoadBuildEventArgs buildArgs = new(_context, _initiator, assemblyName, assemblyPath, mvid, appDomainDescriptor)
+            AssemblyLoadBuildEventArgs buildArgs = new(_context, _initiator, assemblyName, assemblyPath, mvid, appDomainDescriptor);
+
+            // Fix #8816 - when LoggingContext does not have BuildEventContext it is unable to log anything
+            if (_loggingContext?.BuildEventContext != null)
             {
-                BuildEventContext = _loggingContext?.BuildEventContext ?? BuildEventContext.Invalid
-            };
-            _loggingContext?.LogBuildEvent(buildArgs);
+                buildArgs.BuildEventContext = _loggingContext.BuildEventContext;
+                _loggingContext.LogBuildEvent(buildArgs);
+            }
             _loggingService?.LogBuildEvent(buildArgs);
         }
 
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index eeedd7c4c1b..8380f9cd3b9 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -14,12 +14,10 @@
 
 /*
     ==================================================================================================================
-    MSBUILD COMMENT:
 
-    Ripped off from Hashset.cs with the following changes:
+    This is the standard Hashset with the following changes:
 
     * class renamed
-    * unnecessary methods and attributes if-deffed out (code retained to help windiff, but indented)
     * require T implements IKeyed, and accept IKeyed directly where necessary
     * all constructors require a comparer -- an IEqualityComparer<IKeyed> -- to avoid mistakes
     * change Contains to give you back the found entry, rather than a boolean
@@ -28,11 +26,7 @@
     * constructor that allows the collection to be read-only
     * implement IDictionary<string, T>
     * some convenience methods taking 'string' as overloads of methods taking IKeyed
-    
-    Other than this it is modified absolutely minimally to make it easy to diff with the originals (in the Originals folder) 
-    to verify that no errors were introduced, and make it easier to possibly pick up any future bug fixes to the original. 
-    The care taken to minimally modify this means that it is not necessary to carefully code review this complex class, 
-    nor unit test it directly.
+
     ==================================================================================================================
 */
 
@@ -90,10 +84,7 @@ internal class RetrievableEntryHashSet<T> : ICollection<T>,
     {
         // store lower 31 bits of hash code
         private const int Lower31BitMask = 0x7FFFFFFF;
-#if NEVER
-        // cutoff point, above which we won't do stackallocs. This corresponds to 100 integers.
-        private const int StackAllocThreshold = 100;
-#endif
+
         // when constructing a hashset from an existing collection, it may contain duplicates, 
         // so this is used as the max acceptable excess ratio of capacity to count. Note that
         // this is only used on the ctor and not to automatically shrink if the hashset has, e.g,
@@ -637,360 +628,6 @@ public void UnionWith(IEnumerable<T> other)
             }
         }
 
-#if NEVER
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Takes the intersection of this set with other. Modifies this set.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes: 
-                                                                                                                                                        /// We get better perf if other is a hashset using same equality comparer, because we 
-                                                                                                                                                        /// get constant contains check in other. Resulting cost is O(n1) to iterate over this.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// If we can't go above route, iterate over the other and mark intersection by checking
-                                                                                                                                                        /// contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Attempts to return early based on counts alone, using the property that the 
-                                                                                                                                                        /// intersection of anything with the empty set is the empty set.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other">enumerable with items to add </param>
-                                                                                                                                                        public void IntersectWith(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // intersection of anything with empty set is empty set, so return if count is 0
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            // if other is empty, intersection is empty set; remove all elements and we're done
-                                                                                                                                                            // can only figure this out if implements ICollection<T>. (IEnumerable<T> has no count)
-                                                                                                                                                            ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                            if (otherAsCollection != null) {
-                                                                                                                                                                if (otherAsCollection.Count == 0) {
-                                                                                                                                                                    Clear();
-                                                                                                                                                                    return;
-                                                                                                                                                                }
-
-                                                                                                                                                                RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                                // faster if other is a hashset using same equality comparer; so check 
-                                                                                                                                                                // that other is a hashset using the same equality comparer.
-                                                                                                                                                                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                    IntersectWithHashSetWithSameEC(otherAsSet);
-                                                                                                                                                                    return;
-                                                                                                                                                                }
-                                                                                                                                                            }
-
-                                                                                                                                                            IntersectWithEnumerable(other);
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Remove items in other from this set. Modifies this set.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other">enumerable with items to remove</param>
-                                                                                                                                                        public void ExceptWith(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // this is already the enpty set; return
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            // special case if other is this; a set minus itself is the empty set
-                                                                                                                                                            if (other == this) {
-                                                                                                                                                                Clear();
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            // remove every element in other from this
-                                                                                                                                                            foreach (T element in other) {
-                                                                                                                                                                Remove(element);
-                                                                                                                                                            }
-                                                                                                                                                        }
-
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Takes symmetric difference (XOR) with other and this set. Modifies this set.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other">enumerable with items to XOR</param>
-                                                                                                                                                        public void SymmetricExceptWith(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // if set is empty, then symmetric difference is other
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                UnionWith(other);
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            // special case this; the symmetric difference of a set with itself is the empty set
-                                                                                                                                                            if (other == this) {
-                                                                                                                                                                Clear();
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                            // If other is a HashSet, it has unique elements according to its equality comparer,
-                                                                                                                                                            // but if they're using different equality comparers, then assumption of uniqueness
-                                                                                                                                                            // will fail. So first check if other is a hashset using the same equality comparer;
-                                                                                                                                                            // symmetric except is a lot faster and avoids bit array allocations if we can assume
-                                                                                                                                                            // uniqueness
-                                                                                                                                                            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                SymmetricExceptWithUniqueHashSet(otherAsSet);
-                                                                                                                                                            }
-                                                                                                                                                            else {
-                                                                                                                                                                SymmetricExceptWithEnumerable(other);
-                                                                                                                                                            }
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this is a subset of other.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes:
-                                                                                                                                                        /// The following properties are used up-front to avoid element-wise checks:
-                                                                                                                                                        /// 1. If this is the empty set, then it's a subset of anything, including the empty set
-                                                                                                                                                        /// 2. If other has unique elements according to this equality comparer, and this has more
-                                                                                                                                                        /// elements than other, then it can't be a subset.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Furthermore, if other is a hashset using the same equality comparer, we can use a 
-                                                                                                                                                        /// faster element-wise check.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if this is a subset of other; false if not</returns>
-                                                                                                                                                        public bool IsSubsetOf(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // The empty set is a subset of any set
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return true;
-                                                                                                                                                            }
-
-                                                                                                                                                            RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                            // faster if other has unique elements according to this equality comparer; so check 
-                                                                                                                                                            // that other is a hashset using the same equality comparer.
-                                                                                                                                                            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                // if this has more elements then it can't be a subset
-                                                                                                                                                                if (m_count > otherAsSet.Count) {
-                                                                                                                                                                    return false;
-                                                                                                                                                                }
-
-                                                                                                                                                                // already checked that we're using same equality comparer. simply check that 
-                                                                                                                                                                // each element in this is contained in other.
-                                                                                                                                                                return IsSubsetOfHashSetWithSameEC(otherAsSet);
-                                                                                                                                                            }
-                                                                                                                                                            else {
-                                                                                                                                                                ElementCount result = CheckUniqueAndUnfoundElements(other, false);
-                                                                                                                                                                return (result.uniqueCount == m_count && result.unfoundCount >= 0);
-                                                                                                                                                            }
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this is a proper subset of other (i.e. strictly contained in)
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes:
-                                                                                                                                                        /// The following properties are used up-front to avoid element-wise checks:
-                                                                                                                                                        /// 1. If this is the empty set, then it's a proper subset of a set that contains at least
-                                                                                                                                                        /// one element, but it's not a proper subset of the empty set.
-                                                                                                                                                        /// 2. If other has unique elements according to this equality comparer, and this has >=
-                                                                                                                                                        /// the number of elements in other, then this can't be a proper subset.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Furthermore, if other is a hashset using the same equality comparer, we can use a 
-                                                                                                                                                        /// faster element-wise check.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if this is a proper subset of other; false if not</returns>
-                                                                                                                                                        public bool IsProperSubsetOf(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                            if (otherAsCollection != null) {
-                                                                                                                                                                // the empty set is a proper subset of anything but the empty set
-                                                                                                                                                                if (m_count == 0) {
-                                                                                                                                                                    return otherAsCollection.Count > 0;
-                                                                                                                                                                }
-                                                                                                                                                                RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                                // faster if other is a hashset (and we're using same equality comparer)
-                                                                                                                                                                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                    if (m_count >= otherAsSet.Count) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                    // this has strictly less than number of items in other, so the following
-                                                                                                                                                                    // check suffices for proper subset.
-                                                                                                                                                                    return IsSubsetOfHashSetWithSameEC(otherAsSet);
-                                                                                                                                                                }
-                                                                                                                                                            }
-
-                                                                                                                                                            ElementCount result = CheckUniqueAndUnfoundElements(other, false);
-                                                                                                                                                            return (result.uniqueCount == m_count && result.unfoundCount > 0);
-
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this is a superset of other
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes:
-                                                                                                                                                        /// The following properties are used up-front to avoid element-wise checks:
-                                                                                                                                                        /// 1. If other has no elements (it's the empty set), then this is a superset, even if this
-                                                                                                                                                        /// is also the empty set.
-                                                                                                                                                        /// 2. If other has unique elements according to this equality comparer, and this has less 
-                                                                                                                                                        /// than the number of elements in other, then this can't be a superset
-                                                                                                                                                        /// 
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if this is a superset of other; false if not</returns>
-                                                                                                                                                        public bool IsSupersetOf(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // try to fall out early based on counts
-                                                                                                                                                            ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                            if (otherAsCollection != null) {
-                                                                                                                                                                // if other is the empty set then this is a superset
-                                                                                                                                                                if (otherAsCollection.Count == 0) {
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                                RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                                // try to compare based on counts alone if other is a hashset with
-                                                                                                                                                                // same equality comparer
-                                                                                                                                                                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                    if (otherAsSet.Count > m_count) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                }
-                                                                                                                                                            }
-
-                                                                                                                                                            return ContainsAllElements(other);
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this is a proper superset of other (i.e. other strictly contained in this)
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes: 
-                                                                                                                                                        /// This is slightly more complicated than above because we have to keep track if there
-                                                                                                                                                        /// was at least one element not contained in other.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// The following properties are used up-front to avoid element-wise checks:
-                                                                                                                                                        /// 1. If this is the empty set, then it can't be a proper superset of any set, even if 
-                                                                                                                                                        /// other is the empty set.
-                                                                                                                                                        /// 2. If other is an empty set and this contains at least 1 element, then this is a proper
-                                                                                                                                                        /// superset.
-                                                                                                                                                        /// 3. If other has unique elements according to this equality comparer, and other's count
-                                                                                                                                                        /// is greater than or equal to this count, then this can't be a proper superset
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Furthermore, if other has unique elements according to this equality comparer, we can
-                                                                                                                                                        /// use a faster element-wise check.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if this is a proper superset of other; false if not</returns>
-                                                                                                                                                        public bool IsProperSupersetOf(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // the empty set isn't a proper superset of any set.
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return false;
-                                                                                                                                                            }
-
-                                                                                                                                                            ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                            if (otherAsCollection != null) {
-                                                                                                                                                                // if other is the empty set then this is a superset
-                                                                                                                                                                if (otherAsCollection.Count == 0) {
-                                                                                                                                                                    // note that this has at least one element, based on above check
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                                RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                                // faster if other is a hashset with the same equality comparer
-                                                                                                                                                                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                    if (otherAsSet.Count >= m_count) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                    // now perform element check
-                                                                                                                                                                    return ContainsAllElements(otherAsSet);
-                                                                                                                                                                }
-                                                                                                                                                            }
-                                                                                                                                                            // couldn't fall out in the above cases; do it the long way
-                                                                                                                                                            ElementCount result = CheckUniqueAndUnfoundElements(other, true);
-                                                                                                                                                            return (result.uniqueCount < m_count && result.unfoundCount == 0);
-
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this set overlaps other (i.e. they share at least one item)
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if these have at least one common element; false if disjoint</returns>
-                                                                                                                                                        public bool Overlaps(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return false;
-                                                                                                                                                            }
-
-                                                                                                                                                            foreach (T element in other) {
-                                                                                                                                                                if (Contains(element)) {
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                            }
-                                                                                                                                                            return false;
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this and other contain the same elements. This is set equality: 
-                                                                                                                                                        /// duplicates and order are ignored
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns></returns>
-                                                                                                                                                        public bool SetEquals(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                            // faster if other is a hashset and we're using same equality comparer
-                                                                                                                                                            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                // attempt to return early: since both contain unique elements, if they have 
-                                                                                                                                                                // different counts, then they can't be equal
-                                                                                                                                                                if (m_count != otherAsSet.Count) {
-                                                                                                                                                                    return false;
-                                                                                                                                                                }
-
-                                                                                                                                                                // already confirmed that the sets have the same number of distinct elements, so if
-                                                                                                                                                                // one is a superset of the other then they must be equal
-                                                                                                                                                                return ContainsAllElements(otherAsSet);
-                                                                                                                                                            }
-                                                                                                                                                            else {
-                                                                                                                                                                ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                                if (otherAsCollection != null) {
-                                                                                                                                                                    // if this count is 0 but other contains at least one element, they can't be equal
-                                                                                                                                                                    if (m_count == 0 && otherAsCollection.Count > 0) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                }
-                                                                                                                                                                ElementCount result = CheckUniqueAndUnfoundElements(other, true);
-                                                                                                                                                                return (result.uniqueCount == m_count && result.unfoundCount == 0);
-                                                                                                                                                            }
-                                                                                                                                                        }
-#endif
-
         // Copy all elements into array starting at zero based index specified
         [SuppressMessage("Microsoft.Usage", "CA2208:InstantiateArgumentExceptionsCorrectly", Justification = "Decently informative for an exception that will probably never actually see the light of day")]
         void ICollection<KeyValuePair<string, T>>.CopyTo(KeyValuePair<string, T>[] array, int index)
@@ -1050,46 +687,6 @@ public void CopyTo(T[] array, int arrayIndex, int count)
             }
         }
 
-#if NEVER
-                                                                                                                                                    /// <summary>
-                                                                                                                                                    /// Remove elements that match specified predicate. Returns the number of elements removed
-                                                                                                                                                    /// </summary>
-                                                                                                                                                    /// <param name="match"></param>
-                                                                                                                                                    /// <returns></returns>
-                                                                                                                                                    public int RemoveWhere(Predicate<T> match) {
-                                                                                                                                                        if (match == null) {
-                                                                                                                                                            throw new ArgumentNullException("match");
-                                                                                                                                                        }
-                                                                                                                                                        Contract.EndContractBlock();
-
-                                                                                                                                                        int numRemoved = 0;
-                                                                                                                                                        for (int i = 0; i < m_lastIndex; i++) {
-                                                                                                                                                            if (m_slots[i].hashCode >= 0) {
-                                                                                                                                                                // cache value in case delegate removes it
-                                                                                                                                                                T value = m_slots[i].value;
-                                                                                                                                                                if (match(value)) {
-                                                                                                                                                                    // check again that remove actually removed it
-                                                                                                                                                                    if (Remove(value)) {
-                                                                                                                                                                        numRemoved++;
-                                                                                                                                                                    }
-                                                                                                                                                                }
-                                                                                                                                                            }
-                                                                                                                                                        }
-                                                                                                                                                        return numRemoved;
-                                                                                                                                                    }
-
-        /// <summary>
-        /// Gets the IEqualityComparer that is used to determine equality of keys for 
-        /// the HashSet.
-        /// </summary>
-        public IEqualityComparer<IKeyed> Comparer
-        {
-            get
-            {
-                return _comparer;
-            }
-        }
-#endif
         /// <summary>
         /// Sets the capacity of this list to the size of the list (rounded up to nearest prime),
         /// unless count is 0, in which case we release references.
@@ -1149,18 +746,6 @@ public void TrimExcess()
             }
         }
 
-#if NEVER
-#if !SILVERLIGHT || FEATURE_NETCORE
-                                                                                                                                                    /// <summary>
-                                                                                                                                                    /// Used for deep equality of HashSet testing
-                                                                                                                                                    /// </summary>
-                                                                                                                                                    /// <returns></returns>
-                                                                                                                                                    public static IEqualityComparer<RetrievableEntryHashSet<T>> CreateSetComparer() {
-                                                                                                                                                        return new HashSetEqualityComparer<T>();
-                                                                                                                                                    }
-#endif
-#endif
-
         #endregion
 
         #region Helper methods
@@ -1301,338 +886,7 @@ internal bool EntriesAreReferenceEquals(RetrievableEntryHashSet<T> other)
             return true;
         }
 
-#if NEVER
-                                                                                                                                                                        /// <summary>
-                                                                                                                                                                        /// Checks if this contains of other's elements. Iterates over other's elements and 
-                                                                                                                                                                        /// returns false as soon as it finds an element in other that's not in this.
-                                                                                                                                                                        /// Used by SupersetOf, ProperSupersetOf, and SetEquals.
-                                                                                                                                                                        /// </summary>
-                                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                                        /// <returns></returns>
-                                                                                                                                                                        private bool ContainsAllElements(IEnumerable<T> other) {
-                                                                                                                                                                            foreach (T element in other) {
-                                                                                                                                                                                if (!Contains(element)) {
-                                                                                                                                                                                    return false;
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-                                                                                                                                                                            return true;
-                                                                                                                                                                        }
-
-                                                                                                                                                                        /// <summary>
-                                                                                                                                                                        /// Implementation Notes:
-                                                                                                                                                                        /// If other is a hashset and is using same equality comparer, then checking subset is 
-                                                                                                                                                                        /// faster. Simply check that each element in this is in other.
-                                                                                                                                                                        /// 
-                                                                                                                                                                        /// Note: if other doesn't use same equality comparer, then Contains check is invalid,
-                                                                                                                                                                        /// which is why callers must take are of this.
-                                                                                                                                                                        /// 
-                                                                                                                                                                        /// If callers are concerned about whether this is a proper subset, they take care of that.
-                                                                                                                                                                        ///
-                                                                                                                                                                        /// </summary>
-                                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                                        /// <returns></returns>
-                                                                                                                                                                        private bool IsSubsetOfHashSetWithSameEC(RetrievableEntryHashSet<T> other) {
-
-                                                                                                                                                                            foreach (T item in this) {
-                                                                                                                                                                                if (!other.Contains(item)) {
-                                                                                                                                                                                    return false;
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-                                                                                                                                                                            return true;
-                                                                                                                                                                        }
-
-                                                                                                                                                                        /// <summary>
-                                                                                                                                                                        /// If other is a hashset that uses same equality comparer, intersect is much faster 
-                                                                                                                                                                        /// because we can use other's Contains
-                                                                                                                                                                        /// </summary>
-                                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                                        private void IntersectWithHashSetWithSameEC(RetrievableEntryHashSet<T> other) {
-                                                                                                                                                                            for (int i = 0; i < m_lastIndex; i++) {
-                                                                                                                                                                                if (m_slots[i].hashCode >= 0) {
-                                                                                                                                                                                    T item = m_slots[i].value;
-                                                                                                                                                                                    if (!other.Contains(item)) {
-                                                                                                                                                                                        Remove(item);
-                                                                                                                                                                                    }
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-
-                                                                                                                                                                        /// <summary>
-                                                                                                                                                                        /// Iterate over other. If contained in this, mark an element in bit array corresponding to
-                                                                                                                                                                        /// its position in m_slots. If anything is unmarked (in bit array), remove it.
-                                                                                                                                                                        /// 
-                                                                                                                                                                        /// This attempts to allocate on the stack, if below StackAllocThreshold.
-                                                                                                                                                                        /// </summary>
-                                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                                        [System.Security.SecuritySafeCritical]
-                                                                                                                                                                        private unsafe void IntersectWithEnumerable(IEnumerable<T> other) {
-                                                                                                                                                                            Debug.Assert(m_buckets != null, "m_buckets shouldn't be null; callers should check first");
-
-                                                                                                                                                                            // keep track of current last index; don't want to move past the end of our bit array
-                                                                                                                                                                            // (could happen if another thread is modifying the collection)
-                                                                                                                                                                            int originalLastIndex = m_lastIndex;
-                                                                                                                                                                            int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-                                                                                                                                                                            BitHelper bitHelper;
-                                                                                                                                                                            if (intArrayLength <= StackAllocThreshold) {
-                                                                                                                                                                                int* bitArrayPtr = stackalloc int[intArrayLength];
-                                                                                                                                                                                bitHelper = new BitHelper(bitArrayPtr, intArrayLength);
-                                                                                                                                                                            }
-                                                                                                                                                                            else {
-                                                                                                                                                                                int[] bitArray = new int[intArrayLength];
-                                                                                                                                                                                bitHelper = new BitHelper(bitArray, intArrayLength);
-                                                                                                                                                                            }
-
-                                                                                                                                                                            // mark if contains: find index of in slots array and mark corresponding element in bit array
-                                                                                                                                                                            foreach (T item in other) {
-                                                                                                                                                                                int index = InternalIndexOf(item);
-                                                                                                                                                                                if (index >= 0) {
-                                                                                                                                                                                    bitHelper.MarkBit(index);
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-
-                                                                                                                                                                            // if anything unmarked, remove it. Perf can be optimized here if BitHelper had a 
-                                                                                                                                                                            // FindFirstUnmarked method.
-                                                                                                                                                                            for (int i = 0; i < originalLastIndex; i++) {
-                                                                                                                                                                                if (m_slots[i].hashCode >= 0 && !bitHelper.IsMarked(i)) {
-                                                                                                                                                                                    Remove(m_slots[i].value);
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-
-                                                                                                                                                                    /// <summary>
-                                                                                                                                                                    /// Used internally by set operations which have to rely on bit array marking. This is like
-                                                                                                                                                                    /// Contains but returns index in slots array. 
-                                                                                                                                                                    /// </summary>
-                                                                                                                                                                    /// <param name="item"></param>
-                                                                                                                                                                    /// <returns></returns>
-                                                                                                                                                                    private int InternalIndexOf(T item) {
-                                                                                                                                                                        Debug.Assert(m_buckets != null, "m_buckets was null; callers should check first");
-
-                                                                                                                                                                        int hashCode = InternalGetHashCode(item);
-                                                                                                                                                                        for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                                                                                                                                                                            if ((m_slots[i].hashCode) == hashCode && m_comparer.Equals(m_slots[i].value, item)) {
-                                                                                                                                                                                return i;
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                        // wasn't found
-                                                                                                                                                                        return -1;
-                                                                                                                                                                    }
-
-                                                                                                                                                                /// <summary>
-                                                                                                                                                                /// if other is a set, we can assume it doesn't have duplicate elements, so use this
-                                                                                                                                                                /// technique: if can't remove, then it wasn't present in this set, so add.
-                                                                                                                                                                /// 
-                                                                                                                                                                /// As with other methods, callers take care of ensuring that other is a hashset using the
-                                                                                                                                                                /// same equality comparer.
-                                                                                                                                                                /// </summary>
-                                                                                                                                                                /// <param name="other"></param>
-                                                                                                                                                                private void SymmetricExceptWithUniqueHashSet(RetrievableEntryHashSet<T> other) {
-                                                                                                                                                                    foreach (T item in other) {
-                                                                                                                                                                        if (!Remove(item)) {
-                                                                                                                                                                            AddEvenIfPresent(item);
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                }
-
-                                                                                                                                                                /// <summary>
-                                                                                                                                                                /// Implementation notes:
-                                                                                                                                                                /// 
-                                                                                                                                                                /// Used for symmetric except when other isn't a HashSet. This is more tedious because 
-                                                                                                                                                                /// other may contain duplicates. HashSet technique could fail in these situations:
-                                                                                                                                                                /// 1. Other has a duplicate that's not in this: HashSet technique would add then 
-                                                                                                                                                                /// remove it.
-                                                                                                                                                                /// 2. Other has a duplicate that's in this: HashSet technique would remove then add it
-                                                                                                                                                                /// back.
-                                                                                                                                                                /// In general, its presence would be toggled each time it appears in other. 
-                                                                                                                                                                /// 
-                                                                                                                                                                /// This technique uses bit marking to indicate whether to add/remove the item. If already
-                                                                                                                                                                /// present in collection, it will get marked for deletion. If added from other, it will
-                                                                                                                                                                /// get marked as something not to remove.
-                                                                                                                                                                ///
-                                                                                                                                                                /// </summary>
-                                                                                                                                                                /// <param name="other"></param>
-                                                                                                                                                                [System.Security.SecuritySafeCritical]
-                                                                                                                                                                private unsafe void SymmetricExceptWithEnumerable(IEnumerable<T> other) {
-                                                                                                                                                                    int originalLastIndex = m_lastIndex;
-                                                                                                                                                                    int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-                                                                                                                                                                    BitHelper itemsToRemove;
-                                                                                                                                                                    BitHelper itemsAddedFromOther;
-                                                                                                                                                                    if (intArrayLength <= StackAllocThreshold / 2) {
-                                                                                                                                                                        int* itemsToRemovePtr = stackalloc int[intArrayLength];
-                                                                                                                                                                        itemsToRemove = new BitHelper(itemsToRemovePtr, intArrayLength);
-
-                                                                                                                                                                        int* itemsAddedFromOtherPtr = stackalloc int[intArrayLength];
-                                                                                                                                                                        itemsAddedFromOther = new BitHelper(itemsAddedFromOtherPtr, intArrayLength);
-                                                                                                                                                                    }
-                                                                                                                                                                    else {
-                                                                                                                                                                        int[] itemsToRemoveArray = new int[intArrayLength];
-                                                                                                                                                                        itemsToRemove = new BitHelper(itemsToRemoveArray, intArrayLength);
-
-                                                                                                                                                                        int[] itemsAddedFromOtherArray = new int[intArrayLength];
-                                                                                                                                                                        itemsAddedFromOther = new BitHelper(itemsAddedFromOtherArray, intArrayLength);
-                                                                                                                                                                    }
-
-                                                                                                                                                                    foreach (T item in other) {
-                                                                                                                                                                        int location = 0;
-                                                                                                                                                                        bool added = AddOrGetLocation(item, out location);
-                                                                                                                                                                        if (added) {
-                                                                                                                                                                            // wasn't already present in collection; flag it as something not to remove
-                                                                                                                                                                            // *NOTE* if location is out of range, we should ignore. BitHelper will
-                                                                                                                                                                            // detect that it's out of bounds and not try to mark it. But it's 
-                                                                                                                                                                            // expected that location could be out of bounds because adding the item
-                                                                                                                                                                            // will increase m_lastIndex as soon as all the free spots are filled.
-                                                                                                                                                                            itemsAddedFromOther.MarkBit(location);
-                                                                                                                                                                        }
-                                                                                                                                                                        else {
-                                                                                                                                                                            // already there...if not added from other, mark for remove. 
-                                                                                                                                                                            // *NOTE* Even though BitHelper will check that location is in range, we want 
-                                                                                                                                                                            // to check here. There's no point in checking items beyond originalLastIndex
-                                                                                                                                                                            // because they could not have been in the original collection
-                                                                                                                                                                            if (location < originalLastIndex && !itemsAddedFromOther.IsMarked(location)) {
-                                                                                                                                                                                itemsToRemove.MarkBit(location);
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-
-                                                                                                                                                                    // if anything marked, remove it
-                                                                                                                                                                    for (int i = 0; i < originalLastIndex; i++) {
-                                                                                                                                                                        if (itemsToRemove.IsMarked(i)) {
-                                                                                                                                                                            Remove(m_slots[i].value);
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                }
-
-                                                                                                                                                                /// <summary>
-                                                                                                                                                                /// Add if not already in hashset. Returns an out param indicating index where added. This 
-                                                                                                                                                                /// is used by SymmetricExcept because it needs to know the following things:
-                                                                                                                                                                /// - whether the item was already present in the collection or added from other
-                                                                                                                                                                /// - where it's located (if already present, it will get marked for removal, otherwise
-                                                                                                                                                                /// marked for keeping)
-                                                                                                                                                                /// </summary>
-                                                                                                                                                                /// <param name="value"></param>
-                                                                                                                                                                /// <param name="location"></param>
-                                                                                                                                                                /// <returns></returns>
-                                                                                                                                                                private bool AddOrGetLocation(T value, out int location) {
-                                                                                                                                                                    Debug.Assert(m_buckets != null, "m_buckets is null, callers should have checked");
-
-                                                                                                                                                                    int hashCode = InternalGetHashCode(value);
-                                                                                                                                                                    int bucket = hashCode % m_buckets.Length;
-                                                                                                                                                                    for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                                                                                                                                                                        if (m_slots[i].hashCode == hashCode && m_comparer.Equals(m_slots[i].value, value)) {
-                                                                                                                                                                            location = i;
-                                                                                                                                                                            return false; //already present
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                    int index;
-                                                                                                                                                                    if (m_freeList >= 0) {
-                                                                                                                                                                        index = m_freeList;
-                                                                                                                                                                        m_freeList = m_slots[index].next;
-                                                                                                                                                                    }
-                                                                                                                                                                    else {
-                                                                                                                                                                        if (m_lastIndex == m_slots.Length) {
-                                                                                                                                                                            IncreaseCapacity();
-                                                                                                                                                                            // this will change during resize
-                                                                                                                                                                            bucket = hashCode % m_buckets.Length;
-                                                                                                                                                                        }
-                                                                                                                                                                        index = m_lastIndex;
-                                                                                                                                                                        m_lastIndex++;
-                                                                                                                                                                    }
-                                                                                                                                                                    m_slots[index].hashCode = hashCode;
-                                                                                                                                                                    m_slots[index].value = value;
-                                                                                                                                                                    m_slots[index].next = m_buckets[bucket] - 1;
-                                                                                                                                                                    m_buckets[bucket] = index + 1;
-                                                                                                                                                                    m_count++;
-                                                                                                                                                                    m_version++;
-                                                                                                                                                                    location = index;
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-
-                                                                                                                                                                /// <summary>
-                                                                                                                                                                /// Determines counts that can be used to determine equality, subset, and superset. This
-                                                                                                                                                                /// is only used when other is an IEnumerable and not a HashSet. If other is a HashSet
-                                                                                                                                                                /// these properties can be checked faster without use of marking because we can assume 
-                                                                                                                                                                /// other has no duplicates.
-                                                                                                                                                                /// 
-                                                                                                                                                                /// The following count checks are performed by callers:
-                                                                                                                                                                /// 1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = m_count; i.e. everything 
-                                                                                                                                                                /// in other is in this and everything in this is in other
-                                                                                                                                                                /// 2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = m_count; i.e. other may
-                                                                                                                                                                /// have elements not in this and everything in this is in other
-                                                                                                                                                                /// 3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = m_count; i.e
-                                                                                                                                                                /// other must have at least one element not in this and everything in this is in other
-                                                                                                                                                                /// 4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
-                                                                                                                                                                /// than m_count; i.e. everything in other was in this and this had at least one element
-                                                                                                                                                                /// not contained in other.
-                                                                                                                                                                /// 
-                                                                                                                                                                /// An earlier implementation used delegates to perform these checks rather than returning
-                                                                                                                                                                /// an ElementCount struct; however this was changed due to the perf overhead of delegates.
-                                                                                                                                                                /// </summary>
-                                                                                                                                                                /// <param name="other"></param>
-                                                                                                                                                                /// <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
-                                                                                                                                                                /// because unfoundCount must be 0.</param>
-                                                                                                                                                                /// <returns></returns>
-                                                                                                                                                                [System.Security.SecuritySafeCritical]
-                                                                                                                                                                private unsafe ElementCount CheckUniqueAndUnfoundElements(IEnumerable<T> other, bool returnIfUnfound) {
-                                                                                                                                                                    ElementCount result;
-
-                                                                                                                                                                    // need special case in case this has no elements. 
-                                                                                                                                                                    if (m_count == 0) {
-                                                                                                                                                                        int numElementsInOther = 0;
-                                                                                                                                                                        foreach (T item in other) {
-                                                                                                                                                                            numElementsInOther++;
-                                                                                                                                                                            // break right away, all we want to know is whether other has 0 or 1 elements
-                                                                                                                                                                            break;
-                                                                                                                                                                        }
-                                                                                                                                                                        result.uniqueCount = 0;
-                                                                                                                                                                        result.unfoundCount = numElementsInOther;
-                                                                                                                                                                        return result;
-                                                                                                                                                                    }
-
-
-                                                                                                                                                                    Debug.Assert((m_buckets != null) && (m_count > 0), "m_buckets was null but count greater than 0");
-
-                                                                                                                                                                    int originalLastIndex = m_lastIndex;
-                                                                                                                                                                    int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-                                                                                                                                                                    BitHelper bitHelper;
-                                                                                                                                                                    if (intArrayLength <= StackAllocThreshold) {
-                                                                                                                                                                        int* bitArrayPtr = stackalloc int[intArrayLength];
-                                                                                                                                                                        bitHelper = new BitHelper(bitArrayPtr, intArrayLength);
-                                                                                                                                                                    }
-                                                                                                                                                                    else {
-                                                                                                                                                                        int[] bitArray = new int[intArrayLength];
-                                                                                                                                                                        bitHelper = new BitHelper(bitArray, intArrayLength);
-                                                                                                                                                                    }
-
-                                                                                                                                                                    // count of items in other not found in this
-                                                                                                                                                                    int unfoundCount = 0;
-                                                                                                                                                                    // count of unique items in other found in this
-                                                                                                                                                                    int uniqueFoundCount = 0;
-
-                                                                                                                                                                    foreach (T item in other) {
-                                                                                                                                                                        int index = InternalIndexOf(item);
-                                                                                                                                                                        if (index >= 0) {
-                                                                                                                                                                            if (!bitHelper.IsMarked(index)) {
-                                                                                                                                                                                // item hasn't been seen yet
-                                                                                                                                                                                bitHelper.MarkBit(index);
-                                                                                                                                                                                uniqueFoundCount++;
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                        else {
-                                                                                                                                                                            unfoundCount++;
-                                                                                                                                                                            if (returnIfUnfound) {
-                                                                                                                                                                                break;
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-
-                                                                                                                                                                    result.uniqueCount = uniqueFoundCount;
-                                                                                                                                                                    result.unfoundCount = unfoundCount;
-                                                                                                                                                                    return result;
-                                                                                                                                                                }
-#endif
+
         /// <summary>
         /// Copies this to an array. Used for DebugView
         /// </summary>
@@ -1644,71 +898,6 @@ internal T[] ToArray()
             return newArray;
         }
 
-#if NEVER
-                                                                                                                                                            /// <summary>
-                                                                                                                                                            /// Internal method used for HashSetEqualityComparer. Compares set1 and set2 according 
-                                                                                                                                                            /// to specified comparer.
-                                                                                                                                                            /// 
-                                                                                                                                                            /// Because items are hashed according to a specific equality comparer, we have to resort
-                                                                                                                                                            /// to n^2 search if they're using different equality comparers.
-                                                                                                                                                            /// </summary>
-                                                                                                                                                            /// <param name="set1"></param>
-                                                                                                                                                            /// <param name="set2"></param>
-                                                                                                                                                            /// <param name="comparer"></param>
-                                                                                                                                                            /// <returns></returns>
-                                                                                                                                                            internal static bool HashSetEquals(RetrievableEntryHashSet<T> set1, RetrievableEntryHashSet<T> set2, IEqualityComparer<T> comparer) {
-                                                                                                                                                                // handle null cases first
-                                                                                                                                                                if (set1 == null) {
-                                                                                                                                                                    return (set2 == null);
-                                                                                                                                                                }
-                                                                                                                                                                else if (set2 == null) {
-                                                                                                                                                                    // set1 != null
-                                                                                                                                                                    return false;
-                                                                                                                                                                }
-
-                                                                                                                                                                // all comparers are the same; this is faster
-                                                                                                                                                                if (AreEqualityComparersEqual(set1, set2)) {
-                                                                                                                                                                    if (set1.Count != set2.Count) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                    // suffices to check subset
-                                                                                                                                                                    foreach (T item in set2) {
-                                                                                                                                                                        if (!set1.Contains(item)) {
-                                                                                                                                                                            return false;
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                                else {  // n^2 search because items are hashed according to their respective ECs
-                                                                                                                                                                    foreach (T set2Item in set2) {
-                                                                                                                                                                        bool found = false;
-                                                                                                                                                                        foreach (T set1Item in set1) {
-                                                                                                                                                                            if (comparer.Equals(set2Item, set1Item)) {
-                                                                                                                                                                                found = true;
-                                                                                                                                                                                break;
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                        if (!found) {
-                                                                                                                                                                            return false;
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                            }
-
-                                                                                                                                                            /// <summary>
-                                                                                                                                                            /// Checks if equality comparers are equal. This is used for algorithms that can
-                                                                                                                                                            /// speed up if it knows the other item has unique elements. I.e. if they're using 
-                                                                                                                                                            /// different equality comparers, then uniqueness assumption between sets break.
-                                                                                                                                                            /// </summary>
-                                                                                                                                                            /// <param name="set1"></param>
-                                                                                                                                                            /// <param name="set2"></param>
-                                                                                                                                                            /// <returns></returns>
-                                                                                                                                                            private static bool AreEqualityComparersEqual(RetrievableEntryHashSet<T> set1, RetrievableEntryHashSet<T> set2) {
-                                                                                                                                                                return set1.Comparer.Equals(set2.Comparer);
-        }
-#endif
-
         private int InternalGetHashCode(string item, int index, int length)
         {
             // No need to check for null 'item' as we own all comparers
diff --git a/src/Build/Collections/RetrievableEntryHashSet/Originals/BitHelper.cs b/src/Build/Collections/RetrievableEntryHashSet/Originals/BitHelper.cs
deleted file mode 100644
index bfd9c45d47c..00000000000
--- a/src/Build/Collections/RetrievableEntryHashSet/Originals/BitHelper.cs
+++ /dev/null
@@ -1,140 +0,0 @@
-﻿using System;
-using System.Collections;
-using System.Text;
-
-#nullable disable
-
-namespace System.Collections.Generic {
-
-    /// <summary>
-    /// ABOUT:
-    /// Helps with operations that rely on bit marking to indicate whether an item in the 
-    /// collection should be added, removed, visited already, etc. 
-    /// 
-    /// BitHelper doesn't allocate the array; you must pass in an array or ints allocated on the 
-    /// stack or heap. ToIntArrayLength() tells you the int array size you must allocate. 
-    /// 
-    /// USAGE:
-    /// Suppose you need to represent a bit array of length (i.e. logical bit array length)
-    /// BIT_ARRAY_LENGTH. Then this is the suggested way to instantiate BitHelper:
-    /// ***************************************************************************
-    /// int intArrayLength = BitHelper.ToIntArrayLength(BIT_ARRAY_LENGTH);
-    /// BitHelper bitHelper;
-    /// if (intArrayLength less than stack alloc threshold)
-    ///     int* m_arrayPtr = stackalloc int[intArrayLength];
-    ///     bitHelper = new BitHelper(m_arrayPtr, intArrayLength);
-    /// else
-    ///     int[] m_arrayPtr = new int[intArrayLength];
-    ///     bitHelper = new BitHelper(m_arrayPtr, intArrayLength);
-    /// ***************************************************************************
-    /// 
-    /// IMPORTANT:
-    /// The second ctor args, length, should be specified as the length of the int array, not
-    /// the logical bit array. Because length is used for bounds checking into the int array,
-    /// it's especially important to get this correct for the stackalloc version. See the code 
-    /// samples above; this is the value gotten from ToIntArrayLength(). 
-    /// 
-    /// The length ctor argument is the only exception; for other methods -- MarkBit and 
-    /// IsMarked -- pass in values as indices into the logical bit array, and it will be mapped
-    /// to the position within the array of ints.
-    /// 
-    /// FUTURE OPTIMIZATIONS:
-    /// A method such as FindFirstMarked/Unmarked Bit would be useful for callers that operate 
-    /// on a bit array and then need to loop over it. In particular, if it avoided visiting 
-    /// every bit, it would allow good perf improvements when the bit array is sparse.
-    /// </summary>
-    unsafe internal class BitHelper {   // should not be serialized
-
-        private const byte MarkedBitFlag = 1;
-        private const byte IntSize = 32;
-
-        // m_length of underlying int array (not logical bit array)
-        private int m_length;
-        
-        // ptr to stack alloc'd array of ints
-        [System.Security.SecurityCritical]
-        private int* m_arrayPtr;
-
-        // array of ints
-        private int[] m_array;
-
-        // whether to operate on stack alloc'd or heap alloc'd array 
-        private bool useStackAlloc;
-
-        /// <summary>
-        /// Instantiates a BitHelper with a heap alloc'd array of ints
-        /// </summary>
-        /// <param name="bitArray">int array to hold bits</param>
-        /// <param name="length">length of int array</param>
-        [System.Security.SecurityCritical]
-        internal BitHelper(int* bitArrayPtr, int length) {
-            this.m_arrayPtr = bitArrayPtr;
-            this.m_length = length;
-            useStackAlloc = true;
-        }
-
-        /// <summary>
-        /// Instantiates a BitHelper with a heap alloc'd array of ints
-        /// </summary>
-        /// <param name="bitArray">int array to hold bits</param>
-        /// <param name="length">length of int array</param>
-        internal BitHelper(int[] bitArray, int length) {
-            this.m_array = bitArray;
-            this.m_length = length;
-        }
-
-        /// <summary>
-        /// Mark bit at specified position
-        /// </summary>
-        /// <param name="bitPosition"></param>
-        [System.Security.SecuritySafeCritical]
-        internal unsafe void MarkBit(int bitPosition) {
-            if (useStackAlloc) {
-                int bitArrayIndex = bitPosition / IntSize;
-                if (bitArrayIndex < m_length && bitArrayIndex >= 0) {
-                    m_arrayPtr[bitArrayIndex] |= (MarkedBitFlag << (bitPosition % IntSize));
-                }
-            }
-            else {
-                int bitArrayIndex = bitPosition / IntSize;
-                if (bitArrayIndex < m_length && bitArrayIndex >= 0) {
-                    m_array[bitArrayIndex] |= (MarkedBitFlag << (bitPosition % IntSize));
-                }
-            }
-        }
-
-        /// <summary>
-        /// Is bit at specified position marked?
-        /// </summary>
-        /// <param name="bitPosition"></param>
-        /// <returns></returns>
-        [System.Security.SecuritySafeCritical]
-        internal unsafe bool IsMarked(int bitPosition) {
-            if (useStackAlloc) {
-                int bitArrayIndex = bitPosition / IntSize;
-                if (bitArrayIndex < m_length && bitArrayIndex >= 0) {
-                    return ((m_arrayPtr[bitArrayIndex] & (MarkedBitFlag << (bitPosition % IntSize))) != 0);
-                }
-                return false;
-            }
-            else {
-                int bitArrayIndex = bitPosition / IntSize;
-                if (bitArrayIndex < m_length && bitArrayIndex >= 0) {
-                    return ((m_array[bitArrayIndex] & (MarkedBitFlag << (bitPosition % IntSize))) != 0);
-                }
-                return false;
-            }
-        }
-
-        /// <summary>
-        /// How many ints must be allocated to represent n bits. Returns (n+31)/32, but 
-        /// avoids overflow
-        /// </summary>
-        /// <param name="n"></param>
-        /// <returns></returns>
-        internal static int ToIntArrayLength(int n) {
-            return n > 0 ? ((n - 1) / IntSize + 1) : 0;
-        }
-
-    }
-}
diff --git a/src/Build/Collections/RetrievableEntryHashSet/Originals/HashHelpers.cs b/src/Build/Collections/RetrievableEntryHashSet/Originals/HashHelpers.cs
deleted file mode 100644
index b637621ae4a..00000000000
--- a/src/Build/Collections/RetrievableEntryHashSet/Originals/HashHelpers.cs
+++ /dev/null
@@ -1,88 +0,0 @@
-﻿using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-#if !SILVERLIGHT
-using System.Runtime.ConstrainedExecution;
-#endif
-using System.Text;
-
-#nullable disable
-
-namespace System.Collections.Generic {
-
-    /// <summary>
-    /// Duplicated because internal to mscorlib
-    /// </summary>
-    internal static class HashHelpers {
-        // Table of prime numbers to use as hash table sizes. 
-        // The entry used for capacity is the smallest prime number in this array
-        // that is larger than twice the previous capacity. 
-
-        internal static readonly int[] primes = {
-            3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521, 631, 761, 919,
-            1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591,
-            17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363, 156437,
-            187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403, 968897, 1162687, 1395263,
-            1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559, 5999471, 7199369};
-
-#if !SILVERLIGHT
-        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
-#endif
-        internal static bool IsPrime(int candidate) {
-            if ((candidate & 1) != 0) {
-                int limit = (int)Math.Sqrt(candidate);
-                for (int divisor = 3; divisor <= limit; divisor += 2) {
-                    if ((candidate % divisor) == 0) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-            return (candidate == 2);
-        }
-
-#if !SILVERLIGHT
-        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
-#endif
-        internal static int GetPrime(int min) {
-            Debug.Assert(min >= 0, "min less than zero; handle overflow checking before calling HashHelpers");
-
-            for (int i = 0; i < primes.Length; i++) {
-                int prime = primes[i];
-                if (prime >= min) {
-                    return prime;
-                }
-            }
-
-            // Outside of our predefined table. Compute the hard way. 
-            for (int i = (min | 1); i < Int32.MaxValue; i += 2) {
-                if (IsPrime(i)) {
-                    return i;
-                }
-            }
-            return min;
-        }
-
-        internal static int GetMinPrime() {
-            return primes[0];
-        }
-
-        // Returns size of hashtable to grow to.
-        internal static int ExpandPrime(int oldSize)
-        {
-            int newSize = 2 * oldSize;
-
-            // Allow the hashtables to grow to maximum possible size (~2G elements) before encoutering capacity overflow.
-            // Note that this check works even when _items.Length overflowed thanks to the (uint) cast
-            if ((uint)newSize > MaxPrimeArrayLength)
-                return MaxPrimeArrayLength;
-
-            return GetPrime(newSize);
-        }
-
-        // This is the maximum prime smaller than Array.MaxArrayLength
-        internal const int MaxPrimeArrayLength = 0x7FEFFFFD;
-    }
-
-}
diff --git a/src/Build/Collections/RetrievableEntryHashSet/Originals/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/Originals/HashSet.cs
deleted file mode 100644
index 41c90e2f090..00000000000
--- a/src/Build/Collections/RetrievableEntryHashSet/Originals/HashSet.cs
+++ /dev/null
@@ -1,1453 +0,0 @@
-﻿using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Diagnostics.Contracts;
-using System.Security.Permissions;
-using System.Text;
-using System.Diagnostics.CodeAnalysis;
-using System.Security;
-
-#nullable disable
-
-namespace System.Collections.Generic {
-
-    /// <summary>
-    /// Implementation notes:
-    /// This uses an array-based implementation similar to Dictionary<T>, using a buckets array
-    /// to map hash values to the Slots array. Items in the Slots array that hash to the same value
-    /// are chained together through the "next" indices. 
-    /// 
-    /// The capacity is always prime; so during resizing, the capacity is chosen as the next prime
-    /// greater than double the last capacity. 
-    /// 
-    /// The underlying data structures are lazily initialized. Because of the observation that, 
-    /// in practice, hashtables tend to contain only a few elements, the initial capacity is
-    /// set very small (3 elements) unless the ctor with a collection is used.
-    /// 
-    /// The +/- 1 modifications in methods that add, check for containment, etc allow us to 
-    /// distinguish a hash code of 0 from an uninitialized bucket. This saves us from having to 
-    /// reset each bucket to -1 when resizing. See Contains, for example.
-    /// 
-    /// Set methods such as UnionWith, IntersectWith, ExceptWith, and SymmetricExceptWith modify
-    /// this set.
-    /// 
-    /// Some operations can perform faster if we can assume "other" contains unique elements
-    /// according to this equality comparer. The only times this is efficient to check is if
-    /// other is a hashset. Note that checking that it's a hashset alone doesn't suffice; we
-    /// also have to check that the hashset is using the same equality comparer. If other 
-    /// has a different equality comparer, it will have unique elements according to its own
-    /// equality comparer, but not necessarily according to ours. Therefore, to go these 
-    /// optimized routes we check that other is a hashset using the same equality comparer.
-    /// 
-    /// A HashSet with no elements has the properties of the empty set. (See IsSubset, etc. for 
-    /// special empty set checks.)
-    /// 
-    /// A couple of methods have a special case if other is this (e.g. SymmetricExceptWith). 
-    /// If we didn't have these checks, we could be iterating over the set and modifying at
-    /// the same time. 
-    /// </summary>
-    /// <typeparam name="T"></typeparam>
-    [DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView<>))]
-    [DebuggerDisplay("Count = {Count}")]
-    [SuppressMessage("Microsoft.Naming","CA1710:IdentifiersShouldHaveCorrectSuffix", Justification="By design")]
-    [Serializable()]
-    [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
-    public class HashSet<T> : ICollection<T>, ISerializable, IDeserializationCallback, ISet<T>
-    {
-
-        // store lower 31 bits of hash code
-        private const int Lower31BitMask = 0x7FFFFFFF;
-        // cutoff point, above which we won't do stackallocs. This corresponds to 100 integers.
-        private const int StackAllocThreshold = 100;
-        // when constructing a hashset from an existing collection, it may contain duplicates, 
-        // so this is used as the max acceptable excess ratio of capacity to count. Note that
-        // this is only used on the ctor and not to automatically shrink if the hashset has, e.g,
-        // a lot of adds followed by removes. Users must explicitly shrink by calling TrimExcess.
-        // This is set to 3 because capacity is acceptable as 2x rounded up to nearest prime.
-        private const int ShrinkThreshold = 3;
-
-#if !SILVERLIGHT
-        // constants for serialization
-        private const String CapacityName = "Capacity";
-        private const String ElementsName = "Elements";
-        private const String ComparerName = "Comparer";
-        private const String VersionName = "Version";
-#endif
-
-        private int[] m_buckets;
-        private Slot[] m_slots;
-        private int m_count;
-        private int m_lastIndex;
-        private int m_freeList;
-        private IEqualityComparer<T> m_comparer;
-        private int m_version;
-
-#if !SILVERLIGHT
-        // temporary variable needed during deserialization
-        private SerializationInfo m_siInfo;
-#endif
-
-        #region Constructors
-
-        public HashSet()
-            : this(EqualityComparer<T>.Default) { }
-
-        public HashSet(IEqualityComparer<T> comparer) {
-            if (comparer == null) {
-                comparer = EqualityComparer<T>.Default;
-            }
-
-            this.m_comparer = comparer;
-            m_lastIndex = 0;
-            m_count = 0;
-            m_freeList = -1;
-            m_version = 0;
-        }
-
-        public HashSet(IEnumerable<T> collection)
-            : this(collection, EqualityComparer<T>.Default) { }
-
-        /// <summary>
-        /// Implementation Notes:
-        /// Since resizes are relatively expensive (require rehashing), this attempts to minimize 
-        /// the need to resize by setting the initial capacity based on size of collection. 
-        /// </summary>
-        /// <param name="collection"></param>
-        /// <param name="comparer"></param>
-        public HashSet(IEnumerable<T> collection, IEqualityComparer<T> comparer)
-            : this(comparer) {
-            if (collection == null) {
-                throw new ArgumentNullException("collection");
-            }
-            Contract.EndContractBlock();
-
-            // to avoid excess resizes, first set size based on collection's count. Collection
-            // may contain duplicates, so call TrimExcess if resulting hashset is larger than
-            // threshold
-            int suggestedCapacity = 0;
-            ICollection<T> coll = collection as ICollection<T>;
-            if (coll != null) {
-                suggestedCapacity = coll.Count;
-            }
-            Initialize(suggestedCapacity);
-
-            this.UnionWith(collection);
-            if ((m_count == 0 && m_slots.Length > HashHelpers.GetMinPrime()) ||
-                (m_count > 0 && m_slots.Length / m_count > ShrinkThreshold)) {
-                TrimExcess();
-            }
-        }
-
-#if !SILVERLIGHT
-        protected HashSet(SerializationInfo info, StreamingContext context) {
-            // We can't do anything with the keys and values until the entire graph has been 
-            // deserialized and we have a reasonable estimate that GetHashCode is not going to 
-            // fail.  For the time being, we'll just cache this.  The graph is not valid until 
-            // OnDeserialization has been called.
-            m_siInfo = info;
-        }
-#endif
-
-        #endregion
-
-        #region ICollection<T> methods
-
-        /// <summary>
-        /// Add item to this hashset. This is the explicit implementation of the ICollection<T>
-        /// interface. The other Add method returns bool indicating whether item was added.
-        /// </summary>
-        /// <param name="item">item to add</param>
-        void ICollection<T>.Add(T item) {
-            AddIfNotPresent(item);
-        }
-
-        /// <summary>
-        /// Remove all items from this set. This clears the elements but not the underlying 
-        /// buckets and slots array. Follow this call by TrimExcess to release these.
-        /// </summary>
-        public void Clear() {
-            if (m_lastIndex > 0) {
-                Debug.Assert(m_buckets != null, "m_buckets was null but m_lastIndex > 0");
-
-                // clear the elements so that the gc can reclaim the references.
-                // clear only up to m_lastIndex for m_slots 
-                Array.Clear(m_slots, 0, m_lastIndex);
-                Array.Clear(m_buckets, 0, m_buckets.Length);
-                m_lastIndex = 0;
-                m_count = 0;
-                m_freeList = -1;
-            }
-            m_version++;
-        }
-
-        /// <summary>
-        /// Checks if this hashset contains the item
-        /// </summary>
-        /// <param name="item">item to check for containment</param>
-        /// <returns>true if item contained; false if not</returns>
-        public bool Contains(T item) {
-            if (m_buckets != null) {
-                int hashCode = InternalGetHashCode(item);
-                // see note at "HashSet" level describing why "- 1" appears in for loop
-                for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                    if (m_slots[i].hashCode == hashCode && m_comparer.Equals(m_slots[i].value, item)) {
-                        return true;
-                    }
-                }
-            }
-            // either m_buckets is null or wasn't found
-            return false;
-        }
-
-        /// <summary>
-        /// Copy items in this hashset to array, starting at arrayIndex
-        /// </summary>
-        /// <param name="array">array to add items to</param>
-        /// <param name="arrayIndex">index to start at</param>
-        public void CopyTo(T[] array, int arrayIndex) {
-            CopyTo(array, arrayIndex, m_count);
-        }
-
-        /// <summary>
-        /// Remove item from this hashset
-        /// </summary>
-        /// <param name="item">item to remove</param>
-        /// <returns>true if removed; false if not (i.e. if the item wasn't in the HashSet)</returns>
-        public bool Remove(T item) {
-            if (m_buckets != null) {
-                int hashCode = InternalGetHashCode(item);
-                int bucket = hashCode % m_buckets.Length;
-                int last = -1;
-                for (int i = m_buckets[bucket] - 1; i >= 0; last = i, i = m_slots[i].next) {
-                    if (m_slots[i].hashCode == hashCode && m_comparer.Equals(m_slots[i].value, item)) {
-                        if (last < 0) {
-                            // first iteration; update buckets
-                            m_buckets[bucket] = m_slots[i].next + 1;
-                        }
-                        else {
-                            // subsequent iterations; update 'next' pointers
-                            m_slots[last].next = m_slots[i].next;
-                        }
-                        m_slots[i].hashCode = -1;
-                        m_slots[i].value = default(T);
-                        m_slots[i].next = m_freeList;
-
-                        m_count--;
-                        m_version++;
-                        if (m_count == 0) {
-                            m_lastIndex = 0;
-                            m_freeList = -1;
-                        }
-                        else {
-                            m_freeList = i;
-                        }
-                        return true;
-                    }
-                }
-            }
-            // either m_buckets is null or wasn't found
-            return false;
-        }
-
-        /// <summary>
-        /// Number of elements in this hashset
-        /// </summary>
-        public int Count {
-            get { return m_count; }
-        }
-
-        /// <summary>
-        /// Whether this is readonly
-        /// </summary>
-        bool ICollection<T>.IsReadOnly {
-            get { return false; }
-        }
-
-        #endregion
-
-        #region IEnumerable methods
-
-        public Enumerator GetEnumerator() {
-            return new Enumerator(this);
-        }
-
-        IEnumerator<T> IEnumerable<T>.GetEnumerator() {
-            return new Enumerator(this);
-        }
-
-        IEnumerator IEnumerable.GetEnumerator() {
-            return new Enumerator(this);
-        }
-
-        #endregion
-
-        #region ISerializable methods
-
-#if !SILVERLIGHT
-        [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
-        [SecurityCritical]
-        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {
-            if (info == null) {
-                throw new ArgumentNullException("info");
-            }
-
-            // need to serialize version to avoid problems with serializing while enumerating
-            info.AddValue(VersionName, m_version);
-            info.AddValue(ComparerName, m_comparer, typeof(IEqualityComparer<T>));
-            info.AddValue(CapacityName, m_buckets == null ? 0 : m_buckets.Length);
-            if (m_buckets != null) {
-                T[] array = new T[m_count];
-                CopyTo(array);
-                info.AddValue(ElementsName, array, typeof(T[]));
-            }
-        }
-#endif
-        #endregion
-
-        #region IDeserializationCallback methods
-
-#if !SILVERLIGHT
-        public virtual void OnDeserialization(Object sender) {
-
-            if (m_siInfo == null) {
-                // It might be necessary to call OnDeserialization from a container if the 
-                // container object also implements OnDeserialization. However, remoting will 
-                // call OnDeserialization again. We can return immediately if this function is 
-                // called twice. Note we set m_siInfo to null at the end of this method.
-                return;
-            }
-
-            int capacity = m_siInfo.GetInt32(CapacityName);
-            m_comparer = (IEqualityComparer<T>)m_siInfo.GetValue(ComparerName, typeof(IEqualityComparer<T>));
-            m_freeList = -1;
-
-            if (capacity != 0) {
-                m_buckets = new int[capacity];
-                m_slots = new Slot[capacity];
-
-                T[] array = (T[])m_siInfo.GetValue(ElementsName, typeof(T[]));
-
-                if (array == null) {
-                    throw new SerializationException(SR.GetString(SR.Serialization_MissingKeys));
-                }
-
-                // there are no resizes here because we already set capacity above
-                for (int i = 0; i < array.Length; i++) {
-                    AddIfNotPresent(array[i]);
-                }
-            }
-            else {
-                m_buckets = null;
-            }
-
-            m_version = m_siInfo.GetInt32(VersionName);
-            m_siInfo = null;
-        }
-#endif
-
-        #endregion
-
-        #region HashSet methods
-
-        /// <summary>
-        /// Add item to this HashSet. Returns bool indicating whether item was added (won't be 
-        /// added if already present)
-        /// </summary>
-        /// <param name="item"></param>
-        /// <returns>true if added, false if already present</returns>
-        public bool Add(T item) {
-            return AddIfNotPresent(item);
-        }
-
-        /// <summary>
-        /// Take the union of this HashSet with other. Modifies this set.
-        /// 
-        /// Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
-        /// multiple resizes ended up not being useful in practice; quickly gets to the 
-        /// point where it's a wasteful check.
-        /// </summary>
-        /// <param name="other">enumerable with items to add</param>
-        public void UnionWith(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            foreach (T item in other) {
-                AddIfNotPresent(item);
-            }
-        }
-
-        /// <summary>
-        /// Takes the intersection of this set with other. Modifies this set.
-        /// 
-        /// Implementation Notes: 
-        /// We get better perf if other is a hashset using same equality comparer, because we 
-        /// get constant contains check in other. Resulting cost is O(n1) to iterate over this.
-        /// 
-        /// If we can't go above route, iterate over the other and mark intersection by checking
-        /// contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
-        /// 
-        /// Attempts to return early based on counts alone, using the property that the 
-        /// intersection of anything with the empty set is the empty set.
-        /// </summary>
-        /// <param name="other">enumerable with items to add </param>
-        public void IntersectWith(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            // intersection of anything with empty set is empty set, so return if count is 0
-            if (m_count == 0) {
-                return;
-            }
-
-            // if other is empty, intersection is empty set; remove all elements and we're done
-            // can only figure this out if implements ICollection<T>. (IEnumerable<T> has no count)
-            ICollection<T> otherAsCollection = other as ICollection<T>;
-            if (otherAsCollection != null) {
-                if (otherAsCollection.Count == 0) {
-                    Clear();
-                    return;
-                }
-
-                HashSet<T> otherAsSet = other as HashSet<T>;
-                // faster if other is a hashset using same equality comparer; so check 
-                // that other is a hashset using the same equality comparer.
-                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                    IntersectWithHashSetWithSameEC(otherAsSet);
-                    return;
-                }
-            }
-
-            IntersectWithEnumerable(other);
-        }
-
-        /// <summary>
-        /// Remove items in other from this set. Modifies this set.
-        /// </summary>
-        /// <param name="other">enumerable with items to remove</param>
-        public void ExceptWith(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            // this is already the enpty set; return
-            if (m_count == 0) {
-                return;
-            }
-
-            // special case if other is this; a set minus itself is the empty set
-            if (other == this) {
-                Clear();
-                return;
-            }
-
-            // remove every element in other from this
-            foreach (T element in other) {
-                Remove(element);
-            }
-        }
-
-        /// <summary>
-        /// Takes symmetric difference (XOR) with other and this set. Modifies this set.
-        /// </summary>
-        /// <param name="other">enumerable with items to XOR</param>
-        public void SymmetricExceptWith(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            // if set is empty, then symmetric difference is other
-            if (m_count == 0) {
-                UnionWith(other);
-                return;
-            }
-
-            // special case this; the symmetric difference of a set with itself is the empty set
-            if (other == this) {
-                Clear();
-                return;
-            }
-
-            HashSet<T> otherAsSet = other as HashSet<T>;
-            // If other is a HashSet, it has unique elements according to its equality comparer,
-            // but if they're using different equality comparers, then assumption of uniqueness
-            // will fail. So first check if other is a hashset using the same equality comparer;
-            // symmetric except is a lot faster and avoids bit array allocations if we can assume
-            // uniqueness
-            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                SymmetricExceptWithUniqueHashSet(otherAsSet);
-            }
-            else {
-                SymmetricExceptWithEnumerable(other);
-            }
-        }
-
-        /// <summary>
-        /// Checks if this is a subset of other.
-        /// 
-        /// Implementation Notes:
-        /// The following properties are used up-front to avoid element-wise checks:
-        /// 1. If this is the empty set, then it's a subset of anything, including the empty set
-        /// 2. If other has unique elements according to this equality comparer, and this has more
-        /// elements than other, then it can't be a subset.
-        /// 
-        /// Furthermore, if other is a hashset using the same equality comparer, we can use a 
-        /// faster element-wise check.
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns>true if this is a subset of other; false if not</returns>
-        public bool IsSubsetOf(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            // The empty set is a subset of any set
-            if (m_count == 0) {
-                return true;
-            }
-
-            HashSet<T> otherAsSet = other as HashSet<T>;
-            // faster if other has unique elements according to this equality comparer; so check 
-            // that other is a hashset using the same equality comparer.
-            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                // if this has more elements then it can't be a subset
-                if (m_count > otherAsSet.Count) {
-                    return false;
-                }
-
-                // already checked that we're using same equality comparer. simply check that 
-                // each element in this is contained in other.
-                return IsSubsetOfHashSetWithSameEC(otherAsSet);
-            }
-            else {
-                ElementCount result = CheckUniqueAndUnfoundElements(other, false);
-                return (result.uniqueCount == m_count && result.unfoundCount >= 0);
-            }
-        }
-
-        /// <summary>
-        /// Checks if this is a proper subset of other (i.e. strictly contained in)
-        /// 
-        /// Implementation Notes:
-        /// The following properties are used up-front to avoid element-wise checks:
-        /// 1. If this is the empty set, then it's a proper subset of a set that contains at least
-        /// one element, but it's not a proper subset of the empty set.
-        /// 2. If other has unique elements according to this equality comparer, and this has >=
-        /// the number of elements in other, then this can't be a proper subset.
-        /// 
-        /// Furthermore, if other is a hashset using the same equality comparer, we can use a 
-        /// faster element-wise check.
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns>true if this is a proper subset of other; false if not</returns>
-        public bool IsProperSubsetOf(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            ICollection<T> otherAsCollection = other as ICollection<T>;
-            if (otherAsCollection != null) {
-                // the empty set is a proper subset of anything but the empty set
-                if (m_count == 0) {
-                    return otherAsCollection.Count > 0;
-                }
-                HashSet<T> otherAsSet = other as HashSet<T>;
-                // faster if other is a hashset (and we're using same equality comparer)
-                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                    if (m_count >= otherAsSet.Count) {
-                        return false;
-                    }
-                    // this has strictly less than number of items in other, so the following
-                    // check suffices for proper subset.
-                    return IsSubsetOfHashSetWithSameEC(otherAsSet);
-                }
-            }
-
-            ElementCount result = CheckUniqueAndUnfoundElements(other, false);
-            return (result.uniqueCount == m_count && result.unfoundCount > 0);
-
-        }
-
-        /// <summary>
-        /// Checks if this is a superset of other
-        /// 
-        /// Implementation Notes:
-        /// The following properties are used up-front to avoid element-wise checks:
-        /// 1. If other has no elements (it's the empty set), then this is a superset, even if this
-        /// is also the empty set.
-        /// 2. If other has unique elements according to this equality comparer, and this has less 
-        /// than the number of elements in other, then this can't be a superset
-        /// 
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns>true if this is a superset of other; false if not</returns>
-        public bool IsSupersetOf(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            // try to fall out early based on counts
-            ICollection<T> otherAsCollection = other as ICollection<T>;
-            if (otherAsCollection != null) {
-                // if other is the empty set then this is a superset
-                if (otherAsCollection.Count == 0) {
-                    return true;
-                }
-                HashSet<T> otherAsSet = other as HashSet<T>;
-                // try to compare based on counts alone if other is a hashset with
-                // same equality comparer
-                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                    if (otherAsSet.Count > m_count) {
-                        return false;
-                    }
-                }
-            }
-
-            return ContainsAllElements(other);
-        }
-
-        /// <summary>
-        /// Checks if this is a proper superset of other (i.e. other strictly contained in this)
-        /// 
-        /// Implementation Notes: 
-        /// This is slightly more complicated than above because we have to keep track if there
-        /// was at least one element not contained in other.
-        /// 
-        /// The following properties are used up-front to avoid element-wise checks:
-        /// 1. If this is the empty set, then it can't be a proper superset of any set, even if 
-        /// other is the empty set.
-        /// 2. If other is an empty set and this contains at least 1 element, then this is a proper
-        /// superset.
-        /// 3. If other has unique elements according to this equality comparer, and other's count
-        /// is greater than or equal to this count, then this can't be a proper superset
-        /// 
-        /// Furthermore, if other has unique elements according to this equality comparer, we can
-        /// use a faster element-wise check.
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns>true if this is a proper superset of other; false if not</returns>
-        public bool IsProperSupersetOf(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            // the empty set isn't a proper superset of any set.
-            if (m_count == 0) {
-                return false;
-            }
-
-            ICollection<T> otherAsCollection = other as ICollection<T>;
-            if (otherAsCollection != null) {
-                // if other is the empty set then this is a superset
-                if (otherAsCollection.Count == 0) {
-                    // note that this has at least one element, based on above check
-                    return true;
-                }
-                HashSet<T> otherAsSet = other as HashSet<T>;
-                // faster if other is a hashset with the same equality comparer
-                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                    if (otherAsSet.Count >= m_count) {
-                        return false;
-                    }
-                    // now perform element check
-                    return ContainsAllElements(otherAsSet);
-                }
-            }
-            // couldn't fall out in the above cases; do it the long way
-            ElementCount result = CheckUniqueAndUnfoundElements(other, true);
-            return (result.uniqueCount < m_count && result.unfoundCount == 0);
-
-        }
-
-        /// <summary>
-        /// Checks if this set overlaps other (i.e. they share at least one item)
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns>true if these have at least one common element; false if disjoint</returns>
-        public bool Overlaps(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            if (m_count == 0) {
-                return false;
-            }
-
-            foreach (T element in other) {
-                if (Contains(element)) {
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        /// <summary>
-        /// Checks if this and other contain the same elements. This is set equality: 
-        /// duplicates and order are ignored
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns></returns>
-        public bool SetEquals(IEnumerable<T> other) {
-            if (other == null) {
-                throw new ArgumentNullException("other");
-            }
-            Contract.EndContractBlock();
-
-            HashSet<T> otherAsSet = other as HashSet<T>;
-            // faster if other is a hashset and we're using same equality comparer
-            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                // attempt to return early: since both contain unique elements, if they have 
-                // different counts, then they can't be equal
-                if (m_count != otherAsSet.Count) {
-                    return false;
-                }
-
-                // already confirmed that the sets have the same number of distinct elements, so if
-                // one is a superset of the other then they must be equal
-                return ContainsAllElements(otherAsSet);
-            }
-            else {
-                ICollection<T> otherAsCollection = other as ICollection<T>;
-                if (otherAsCollection != null) {
-                    // if this count is 0 but other contains at least one element, they can't be equal
-                    if (m_count == 0 && otherAsCollection.Count > 0) {
-                        return false;
-                    }
-                }
-                ElementCount result = CheckUniqueAndUnfoundElements(other, true);
-                return (result.uniqueCount == m_count && result.unfoundCount == 0);
-            }
-        }
-
-        public void CopyTo(T[] array) { CopyTo(array, 0, m_count); }
-
-        public void CopyTo(T[] array, int arrayIndex, int count) {
-            if (array == null) {
-                throw new ArgumentNullException("array");
-            }
-            Contract.EndContractBlock();
-
-            // check array index valid index into array
-            if (arrayIndex < 0) {
-                throw new ArgumentOutOfRangeException("arrayIndex", SR.GetString(SR.ArgumentOutOfRange_NeedNonNegNum));
-            }
-
-            // also throw if count less than 0
-            if (count < 0) {
-                throw new ArgumentOutOfRangeException("count", SR.GetString(SR.ArgumentOutOfRange_NeedNonNegNum));
-            }
-
-            // will array, starting at arrayIndex, be able to hold elements? Note: not
-            // checking arrayIndex >= array.Length (consistency with list of allowing
-            // count of 0; subsequent check takes care of the rest)
-            if (arrayIndex > array.Length || count > array.Length - arrayIndex) {
-                throw new ArgumentException(SR.GetString(SR.Arg_ArrayPlusOffTooSmall));
-            }
-
-            int numCopied = 0;
-            for (int i = 0; i < m_lastIndex && numCopied < count; i++) {
-                if (m_slots[i].hashCode >= 0) {
-                    array[arrayIndex + numCopied] = m_slots[i].value;
-                    numCopied++;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Remove elements that match specified predicate. Returns the number of elements removed
-        /// </summary>
-        /// <param name="match"></param>
-        /// <returns></returns>
-        public int RemoveWhere(Predicate<T> match) {
-            if (match == null) {
-                throw new ArgumentNullException("match");
-            }
-            Contract.EndContractBlock();
-
-            int numRemoved = 0;
-            for (int i = 0; i < m_lastIndex; i++) {
-                if (m_slots[i].hashCode >= 0) {
-                    // cache value in case delegate removes it
-                    T value = m_slots[i].value;
-                    if (match(value)) {
-                        // check again that remove actually removed it
-                        if (Remove(value)) {
-                            numRemoved++;
-                        }
-                    }
-                }
-            }
-            return numRemoved;
-        }
-
-        /// <summary>
-        /// Gets the IEqualityComparer that is used to determine equality of keys for 
-        /// the HashSet.
-        /// </summary>
-        public IEqualityComparer<T> Comparer {
-            get {
-                return m_comparer;
-            }
-        }
-
-        /// <summary>
-        /// Sets the capacity of this list to the size of the list (rounded up to nearest prime),
-        /// unless count is 0, in which case we release references.
-        /// 
-        /// This method can be used to minimize a list's memory overhead once it is known that no
-        /// new elements will be added to the list. To completely clear a list and release all 
-        /// memory referenced by the list, execute the following statements:
-        /// 
-        /// list.Clear();
-        /// list.TrimExcess(); 
-        /// </summary>
-        public void TrimExcess() {
-            Debug.Assert(m_count >= 0, "m_count is negative");
-
-            if (m_count == 0) {
-                // if count is zero, clear references
-                m_buckets = null;
-                m_slots = null;
-                m_version++;
-            }
-            else {
-                Debug.Assert(m_buckets != null, "m_buckets was null but m_count > 0");
-
-                // similar to IncreaseCapacity but moves down elements in case add/remove/etc
-                // caused fragmentation
-                int newSize = HashHelpers.GetPrime(m_count);
-                Slot[] newSlots = new Slot[newSize];
-                int[] newBuckets = new int[newSize];
-
-                // move down slots and rehash at the same time. newIndex keeps track of current 
-                // position in newSlots array
-                int newIndex = 0;
-                for (int i = 0; i < m_lastIndex; i++) {
-                    if (m_slots[i].hashCode >= 0) {
-                        newSlots[newIndex] = m_slots[i];
-
-                        // rehash
-                        int bucket = newSlots[newIndex].hashCode % newSize;
-                        newSlots[newIndex].next = newBuckets[bucket] - 1;
-                        newBuckets[bucket] = newIndex + 1;
-
-                        newIndex++;
-                    }
-                }
-
-                Debug.Assert(newSlots.Length <= m_slots.Length, "capacity increased after TrimExcess");
-
-                m_lastIndex = newIndex;
-                m_slots = newSlots;
-                m_buckets = newBuckets;
-                m_freeList = -1;
-            }
-        }
-
-#if !SILVERLIGHT || FEATURE_NETCORE
-        /// <summary>
-        /// Used for deep equality of HashSet testing
-        /// </summary>
-        /// <returns></returns>
-        public static IEqualityComparer<HashSet<T>> CreateSetComparer() {
-            return new HashSetEqualityComparer<T>();
-        }
-#endif
-
-        #endregion
-
-        #region Helper methods
-
-        /// <summary>
-        /// Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
-        /// greater than or equal to capacity.
-        /// </summary>
-        /// <param name="capacity"></param>
-        private void Initialize(int capacity) {
-            Debug.Assert(m_buckets == null, "Initialize was called but m_buckets was non-null");
-
-            int size = HashHelpers.GetPrime(capacity);
-
-            m_buckets = new int[size];
-            m_slots = new Slot[size];
-        }
-
-        /// <summary>
-        /// Expand to new capacity. New capacity is next prime greater than or equal to suggested 
-        /// size. This is called when the underlying array is filled. This performs no 
-        /// defragmentation, allowing faster execution; note that this is reasonable since 
-        /// AddIfNotPresent attempts to insert new elements in re-opened spots.
-        /// </summary>
-        /// <param name="sizeSuggestion"></param>
-        private void IncreaseCapacity() {
-            Debug.Assert(m_buckets != null, "IncreaseCapacity called on a set with no elements");
-
-            int newSize = HashHelpers.ExpandPrime(m_count);
-            if (newSize <= m_count) {
-                throw new ArgumentException(SR.GetString(SR.Arg_HSCapacityOverflow));
-            }
-
-            // Able to increase capacity; copy elements to larger array and rehash
-            Slot[] newSlots = new Slot[newSize];
-            if (m_slots != null) {
-                Array.Copy(m_slots, 0, newSlots, 0, m_lastIndex);
-            }
-
-            int[] newBuckets = new int[newSize];
-            for (int i = 0; i < m_lastIndex; i++) {
-                int bucket = newSlots[i].hashCode % newSize;
-                newSlots[i].next = newBuckets[bucket] - 1;
-                newBuckets[bucket] = i + 1;
-            }
-            m_slots = newSlots;
-            m_buckets = newBuckets;
-
-        }
-
-        /// <summary>
-        /// Adds value to HashSet if not contained already
-        /// Returns true if added and false if already present
-        /// </summary>
-        /// <param name="value">value to find</param>
-        /// <returns></returns>
-        private bool AddIfNotPresent(T value) {
-            if (m_buckets == null) {
-                Initialize(0);
-            }
-
-            int hashCode = InternalGetHashCode(value);
-            int bucket = hashCode % m_buckets.Length;
-            for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                if (m_slots[i].hashCode == hashCode && m_comparer.Equals(m_slots[i].value, value)) {
-                    return false;
-                }
-            }
-            int index;
-            if (m_freeList >= 0) {
-                index = m_freeList;
-                m_freeList = m_slots[index].next;
-            }
-            else {
-                if (m_lastIndex == m_slots.Length) {
-                    IncreaseCapacity();
-                    // this will change during resize
-                    bucket = hashCode % m_buckets.Length;
-                }
-                index = m_lastIndex;
-                m_lastIndex++;
-            }
-            m_slots[index].hashCode = hashCode;
-            m_slots[index].value = value;
-            m_slots[index].next = m_buckets[bucket] - 1;
-            m_buckets[bucket] = index + 1;
-            m_count++;
-            m_version++;
-            return true;
-        }
-
-        /// <summary>
-        /// Checks if this contains of other's elements. Iterates over other's elements and 
-        /// returns false as soon as it finds an element in other that's not in this.
-        /// Used by SupersetOf, ProperSupersetOf, and SetEquals.
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns></returns>
-        private bool ContainsAllElements(IEnumerable<T> other) {
-            foreach (T element in other) {
-                if (!Contains(element)) {
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        /// <summary>
-        /// Implementation Notes:
-        /// If other is a hashset and is using same equality comparer, then checking subset is 
-        /// faster. Simply check that each element in this is in other.
-        /// 
-        /// Note: if other doesn't use same equality comparer, then Contains check is invalid,
-        /// which is why callers must take are of this.
-        /// 
-        /// If callers are concerned about whether this is a proper subset, they take care of that.
-        ///
-        /// </summary>
-        /// <param name="other"></param>
-        /// <returns></returns>
-        private bool IsSubsetOfHashSetWithSameEC(HashSet<T> other) {
-
-            foreach (T item in this) {
-                if (!other.Contains(item)) {
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        /// <summary>
-        /// If other is a hashset that uses same equality comparer, intersect is much faster 
-        /// because we can use other's Contains
-        /// </summary>
-        /// <param name="other"></param>
-        private void IntersectWithHashSetWithSameEC(HashSet<T> other) {
-            for (int i = 0; i < m_lastIndex; i++) {
-                if (m_slots[i].hashCode >= 0) {
-                    T item = m_slots[i].value;
-                    if (!other.Contains(item)) {
-                        Remove(item);
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Iterate over other. If contained in this, mark an element in bit array corresponding to
-        /// its position in m_slots. If anything is unmarked (in bit array), remove it.
-        /// 
-        /// This attempts to allocate on the stack, if below StackAllocThreshold.
-        /// </summary>
-        /// <param name="other"></param>
-        [System.Security.SecuritySafeCritical]
-        private unsafe void IntersectWithEnumerable(IEnumerable<T> other) {
-            Debug.Assert(m_buckets != null, "m_buckets shouldn't be null; callers should check first");
-
-            // keep track of current last index; don't want to move past the end of our bit array
-            // (could happen if another thread is modifying the collection)
-            int originalLastIndex = m_lastIndex;
-            int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-            BitHelper bitHelper;
-            if (intArrayLength <= StackAllocThreshold) {
-                int* bitArrayPtr = stackalloc int[intArrayLength];
-                bitHelper = new BitHelper(bitArrayPtr, intArrayLength);
-            }
-            else {
-                int[] bitArray = new int[intArrayLength];
-                bitHelper = new BitHelper(bitArray, intArrayLength);
-            }
-
-            // mark if contains: find index of in slots array and mark corresponding element in bit array
-            foreach (T item in other) {
-                int index = InternalIndexOf(item);
-                if (index >= 0) {
-                    bitHelper.MarkBit(index);
-                }
-            }
-
-            // if anything unmarked, remove it. Perf can be optimized here if BitHelper had a 
-            // FindFirstUnmarked method.
-            for (int i = 0; i < originalLastIndex; i++) {
-                if (m_slots[i].hashCode >= 0 && !bitHelper.IsMarked(i)) {
-                    Remove(m_slots[i].value);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Used internally by set operations which have to rely on bit array marking. This is like
-        /// Contains but returns index in slots array. 
-        /// </summary>
-        /// <param name="item"></param>
-        /// <returns></returns>
-        private int InternalIndexOf(T item) {
-            Debug.Assert(m_buckets != null, "m_buckets was null; callers should check first");
-
-            int hashCode = InternalGetHashCode(item);
-            for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                if ((m_slots[i].hashCode) == hashCode && m_comparer.Equals(m_slots[i].value, item)) {
-                    return i;
-                }
-            }
-            // wasn't found
-            return -1;
-        }
-
-        /// <summary>
-        /// if other is a set, we can assume it doesn't have duplicate elements, so use this
-        /// technique: if can't remove, then it wasn't present in this set, so add.
-        /// 
-        /// As with other methods, callers take care of ensuring that other is a hashset using the
-        /// same equality comparer.
-        /// </summary>
-        /// <param name="other"></param>
-        private void SymmetricExceptWithUniqueHashSet(HashSet<T> other) {
-            foreach (T item in other) {
-                if (!Remove(item)) {
-                    AddIfNotPresent(item);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Implementation notes:
-        /// 
-        /// Used for symmetric except when other isn't a HashSet. This is more tedious because 
-        /// other may contain duplicates. HashSet technique could fail in these situations:
-        /// 1. Other has a duplicate that's not in this: HashSet technique would add then 
-        /// remove it.
-        /// 2. Other has a duplicate that's in this: HashSet technique would remove then add it
-        /// back.
-        /// In general, its presence would be toggled each time it appears in other. 
-        /// 
-        /// This technique uses bit marking to indicate whether to add/remove the item. If already
-        /// present in collection, it will get marked for deletion. If added from other, it will
-        /// get marked as something not to remove.
-        ///
-        /// </summary>
-        /// <param name="other"></param>
-        [System.Security.SecuritySafeCritical]
-        private unsafe void SymmetricExceptWithEnumerable(IEnumerable<T> other) {
-            int originalLastIndex = m_lastIndex;
-            int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-            BitHelper itemsToRemove;
-            BitHelper itemsAddedFromOther;
-            if (intArrayLength <= StackAllocThreshold / 2) {
-                int* itemsToRemovePtr = stackalloc int[intArrayLength];
-                itemsToRemove = new BitHelper(itemsToRemovePtr, intArrayLength);
-
-                int* itemsAddedFromOtherPtr = stackalloc int[intArrayLength];
-                itemsAddedFromOther = new BitHelper(itemsAddedFromOtherPtr, intArrayLength);
-            }
-            else {
-                int[] itemsToRemoveArray = new int[intArrayLength];
-                itemsToRemove = new BitHelper(itemsToRemoveArray, intArrayLength);
-
-                int[] itemsAddedFromOtherArray = new int[intArrayLength];
-                itemsAddedFromOther = new BitHelper(itemsAddedFromOtherArray, intArrayLength);
-            }
-
-            foreach (T item in other) {
-                int location = 0;
-                bool added = AddOrGetLocation(item, out location);
-                if (added) {
-                    // wasn't already present in collection; flag it as something not to remove
-                    // *NOTE* if location is out of range, we should ignore. BitHelper will
-                    // detect that it's out of bounds and not try to mark it. But it's 
-                    // expected that location could be out of bounds because adding the item
-                    // will increase m_lastIndex as soon as all the free spots are filled.
-                    itemsAddedFromOther.MarkBit(location);
-                }
-                else {
-                    // already there...if not added from other, mark for remove. 
-                    // *NOTE* Even though BitHelper will check that location is in range, we want 
-                    // to check here. There's no point in checking items beyond originalLastIndex
-                    // because they could not have been in the original collection
-                    if (location < originalLastIndex && !itemsAddedFromOther.IsMarked(location)) {
-                        itemsToRemove.MarkBit(location);
-                    }
-                }
-            }
-
-            // if anything marked, remove it
-            for (int i = 0; i < originalLastIndex; i++) {
-                if (itemsToRemove.IsMarked(i)) {
-                    Remove(m_slots[i].value);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Add if not already in hashset. Returns an out param indicating index where added. This 
-        /// is used by SymmetricExcept because it needs to know the following things:
-        /// - whether the item was already present in the collection or added from other
-        /// - where it's located (if already present, it will get marked for removal, otherwise
-        /// marked for keeping)
-        /// </summary>
-        /// <param name="value"></param>
-        /// <param name="location"></param>
-        /// <returns></returns>
-        private bool AddOrGetLocation(T value, out int location) {
-            Debug.Assert(m_buckets != null, "m_buckets is null, callers should have checked");
-
-            int hashCode = InternalGetHashCode(value);
-            int bucket = hashCode % m_buckets.Length;
-            for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                if (m_slots[i].hashCode == hashCode && m_comparer.Equals(m_slots[i].value, value)) {
-                    location = i;
-                    return false; //already present
-                }
-            }
-            int index;
-            if (m_freeList >= 0) {
-                index = m_freeList;
-                m_freeList = m_slots[index].next;
-            }
-            else {
-                if (m_lastIndex == m_slots.Length) {
-                    IncreaseCapacity();
-                    // this will change during resize
-                    bucket = hashCode % m_buckets.Length;
-                }
-                index = m_lastIndex;
-                m_lastIndex++;
-            }
-            m_slots[index].hashCode = hashCode;
-            m_slots[index].value = value;
-            m_slots[index].next = m_buckets[bucket] - 1;
-            m_buckets[bucket] = index + 1;
-            m_count++;
-            m_version++;
-            location = index;
-            return true;
-        }
-
-        /// <summary>
-        /// Determines counts that can be used to determine equality, subset, and superset. This
-        /// is only used when other is an IEnumerable and not a HashSet. If other is a HashSet
-        /// these properties can be checked faster without use of marking because we can assume 
-        /// other has no duplicates.
-        /// 
-        /// The following count checks are performed by callers:
-        /// 1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = m_count; i.e. everything 
-        /// in other is in this and everything in this is in other
-        /// 2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = m_count; i.e. other may
-        /// have elements not in this and everything in this is in other
-        /// 3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = m_count; i.e
-        /// other must have at least one element not in this and everything in this is in other
-        /// 4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
-        /// than m_count; i.e. everything in other was in this and this had at least one element
-        /// not contained in other.
-        /// 
-        /// An earlier implementation used delegates to perform these checks rather than returning
-        /// an ElementCount struct; however this was changed due to the perf overhead of delegates.
-        /// </summary>
-        /// <param name="other"></param>
-        /// <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
-        /// because unfoundCount must be 0.</param>
-        /// <returns></returns>
-        [System.Security.SecuritySafeCritical]
-        private unsafe ElementCount CheckUniqueAndUnfoundElements(IEnumerable<T> other, bool returnIfUnfound) {
-            ElementCount result;
-
-            // need special case in case this has no elements. 
-            if (m_count == 0) {
-                int numElementsInOther = 0;
-                foreach (T item in other) {
-                    numElementsInOther++;
-                    // break right away, all we want to know is whether other has 0 or 1 elements
-                    break;
-                }
-                result.uniqueCount = 0;
-                result.unfoundCount = numElementsInOther;
-                return result;
-            }
-
-
-            Debug.Assert((m_buckets != null) && (m_count > 0), "m_buckets was null but count greater than 0");
-
-            int originalLastIndex = m_lastIndex;
-            int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-            BitHelper bitHelper;
-            if (intArrayLength <= StackAllocThreshold) {
-                int* bitArrayPtr = stackalloc int[intArrayLength];
-                bitHelper = new BitHelper(bitArrayPtr, intArrayLength);
-            }
-            else {
-                int[] bitArray = new int[intArrayLength];
-                bitHelper = new BitHelper(bitArray, intArrayLength);
-            }
-
-            // count of items in other not found in this
-            int unfoundCount = 0;
-            // count of unique items in other found in this
-            int uniqueFoundCount = 0;
-
-            foreach (T item in other) {
-                int index = InternalIndexOf(item);
-                if (index >= 0) {
-                    if (!bitHelper.IsMarked(index)) {
-                        // item hasn't been seen yet
-                        bitHelper.MarkBit(index);
-                        uniqueFoundCount++;
-                    }
-                }
-                else {
-                    unfoundCount++;
-                    if (returnIfUnfound) {
-                        break;
-                    }
-                }
-            }
-
-            result.uniqueCount = uniqueFoundCount;
-            result.unfoundCount = unfoundCount;
-            return result;
-        }
-
-        /// <summary>
-        /// Copies this to an array. Used for DebugView
-        /// </summary>
-        /// <returns></returns>
-        internal T[] ToArray() {
-            T[] newArray = new T[Count];
-            CopyTo(newArray);
-            return newArray;
-        }
-
-        /// <summary>
-        /// Internal method used for HashSetEqualityComparer. Compares set1 and set2 according 
-        /// to specified comparer.
-        /// 
-        /// Because items are hashed according to a specific equality comparer, we have to resort
-        /// to n^2 search if they're using different equality comparers.
-        /// </summary>
-        /// <param name="set1"></param>
-        /// <param name="set2"></param>
-        /// <param name="comparer"></param>
-        /// <returns></returns>
-        internal static bool HashSetEquals(HashSet<T> set1, HashSet<T> set2, IEqualityComparer<T> comparer) {
-            // handle null cases first
-            if (set1 == null) {
-                return (set2 == null);
-            }
-            else if (set2 == null) {
-                // set1 != null
-                return false;
-            }
-
-            // all comparers are the same; this is faster
-            if (AreEqualityComparersEqual(set1, set2)) {
-                if (set1.Count != set2.Count) {
-                    return false;
-                }
-                // suffices to check subset
-                foreach (T item in set2) {
-                    if (!set1.Contains(item)) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-            else {  // n^2 search because items are hashed according to their respective ECs
-                foreach (T set2Item in set2) {
-                    bool found = false;
-                    foreach (T set1Item in set1) {
-                        if (comparer.Equals(set2Item, set1Item)) {
-                            found = true;
-                            break;
-                        }
-                    }
-                    if (!found) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-        }
-
-        /// <summary>
-        /// Checks if equality comparers are equal. This is used for algorithms that can
-        /// speed up if it knows the other item has unique elements. I.e. if they're using 
-        /// different equality comparers, then uniqueness assumption between sets break.
-        /// </summary>
-        /// <param name="set1"></param>
-        /// <param name="set2"></param>
-        /// <returns></returns>
-        private static bool AreEqualityComparersEqual(HashSet<T> set1, HashSet<T> set2) {
-            return set1.Comparer.Equals(set2.Comparer);
-        }
-
-        /// <summary>
-        /// Workaround Comparers that throw ArgumentNullException for GetHashCode(null).
-        /// </summary>
-        /// <param name="item"></param>
-        /// <returns>hash code</returns>
-        private int InternalGetHashCode(T item) {
-            if (item == null) {
-                return 0;
-            } 
-            return m_comparer.GetHashCode(item) & Lower31BitMask;
-        }
-
-        #endregion
-
-        // used for set checking operations (using enumerables) that rely on counting
-        internal struct ElementCount {
-            internal int uniqueCount;
-            internal int unfoundCount;
-        }
-
-        internal struct Slot {
-            internal int hashCode;      // Lower 31 bits of hash code, -1 if unused
-            internal T value;
-            internal int next;          // Index of next entry, -1 if last
-        }
-
-#if !SILVERLIGHT
-        [Serializable()]
-        [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
-#endif
-        public struct Enumerator : IEnumerator<T>, System.Collections.IEnumerator {
-            private HashSet<T> set;
-            private int index;
-            private int version;
-            private T current;
-
-            internal Enumerator(HashSet<T> set) {
-                this.set = set;
-                index = 0;
-                version = set.m_version;
-                current = default(T);
-            }
-
-            public void Dispose() {
-            }
-
-            public bool MoveNext() {
-                if (version != set.m_version) {
-                    throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
-                }
-
-                while (index < set.m_lastIndex) {
-                    if (set.m_slots[index].hashCode >= 0) {
-                        current = set.m_slots[index].value;
-                        index++;
-                        return true;
-                    }
-                    index++;
-                }
-                index = set.m_lastIndex + 1;
-                current = default(T);
-                return false;
-            }
-
-            public T Current {
-                get {
-                    return current;
-                }
-            }
-
-            Object System.Collections.IEnumerator.Current {
-                get {
-                    if (index == 0 || index == set.m_lastIndex + 1) {
-                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumOpCantHappen));
-                    }
-                    return Current;
-                }
-            }
-
-            void System.Collections.IEnumerator.Reset() {
-                if (version != set.m_version) {
-                    throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
-                }
-
-                index = 0;
-                current = default(T);
-            }
-        }
-    }
-
-}
diff --git a/src/Build/Collections/RetrievableEntryHashSet/Originals/HashSetDebugView.cs b/src/Build/Collections/RetrievableEntryHashSet/Originals/HashSetDebugView.cs
deleted file mode 100644
index 5fd5651ac32..00000000000
--- a/src/Build/Collections/RetrievableEntryHashSet/Originals/HashSetDebugView.cs
+++ /dev/null
@@ -1,34 +0,0 @@
-﻿using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Text;
-
-#nullable disable
-
-namespace System.Collections.Generic {
-
-    /// <summary>
-    /// Debug view for HashSet
-    /// </summary>
-    /// <typeparam name="T"></typeparam>
-    internal class HashSetDebugView<T> {
-        private HashSet<T> set;
-
-        public HashSetDebugView(HashSet<T> set) {
-            if (set == null) {
-                throw new ArgumentNullException("set");
-            }
-
-            this.set = set;
-        }
-
-        [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
-        public T[] Items {
-            get {
-                return set.ToArray();
-            }
-        }
-    }
-
-}
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 4bc5866687c..a04f3c9c0ad 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1495,7 +1495,11 @@ public override int GetHashCode()
                 // This is ignore case to ensure that task items whose item specs differ only by
                 // casing still have the same hash code, since this is used to determine if we have duplicates when
                 // we do duplicate removal.
-                return StringComparer.OrdinalIgnoreCase.GetHashCode(ItemSpec);
+                //
+                // Ideally this would also hash in something like the metadata count. However this requires calculation,
+                // because local and inherited metadata are equally considered during equality comparison, and the
+                // former may mask some of the latter.
+                return StringComparer.OrdinalIgnoreCase.GetHashCode(_includeEscaped);
             }
 
             /// <summary>
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 1bc5e67a847..8d731ef70f9 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -799,8 +799,4 @@
       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>
     </EmbeddedResource>
   </ItemGroup>
-
-  <ItemGroup>
-    <Compile Remove="Collections\RetrievableEntryHashSet\Originals\*" />
-  </ItemGroup>
 </Project>
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index 2436979d94f..ed2e16683ba 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -365,6 +365,15 @@ private static void InitializeAvailableMethods()
                         availableStaticMethods.TryAdd("Microsoft.Build.Utilities.ToolLocationHelper", new Tuple<string, Type>("Microsoft.Build.Utilities.ToolLocationHelper, Microsoft.Build.Utilities.Core, Version=" + MSBuildConstants.CurrentAssemblyVersion + ", Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", null));
                         availableStaticMethods.TryAdd("System.Runtime.InteropServices.RuntimeInformation", runtimeInformationType);
                         availableStaticMethods.TryAdd("System.Runtime.InteropServices.OSPlatform", osPlatformType);
+#if NET5_0_OR_GREATER
+                        var operatingSystemType = new Tuple<string, Type>(null, typeof(OperatingSystem));
+                        availableStaticMethods.TryAdd("System.OperatingSystem", operatingSystemType);
+#else
+                        // Add alternate type for System.OperatingSystem static methods which aren't available on .NET Framework.
+                        var operatingSystemType = new Tuple<string, Type>("Microsoft.Build.Framework.OperatingSystem, Microsoft.Build.Framework, Version=" + MSBuildConstants.CurrentAssemblyVersion + ", Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", null);
+                        availableStaticMethods.TryAdd("System.OperatingSystem", operatingSystemType);
+                        availableStaticMethods.TryAdd("Microsoft.Build.Framework.OperatingSystem", operatingSystemType);
+#endif
 
                         s_availableStaticMethods = availableStaticMethods;
                     }
diff --git a/src/Framework.UnitTests/OperatingSystem_Tests.cs b/src/Framework.UnitTests/OperatingSystem_Tests.cs
new file mode 100644
index 00000000000..4fbaf7af615
--- /dev/null
+++ b/src/Framework.UnitTests/OperatingSystem_Tests.cs
@@ -0,0 +1,57 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Shouldly;
+
+using Xunit;
+using Xunit.NetCore.Extensions;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class OperatingSystem_Tests
+    {
+#if !NET5_0_OR_GREATER
+        [WindowsFullFrameworkOnlyTheory]
+        [InlineData("windows", true)]
+        [InlineData("linux", false)]
+        [InlineData("macOS", false)]
+        public void IsOSPlatform(string platform, bool expected)
+        {
+            Microsoft.Build.Framework.OperatingSystem.IsOSPlatform(platform).ShouldBe(expected);
+        }
+
+        [WindowsFullFrameworkOnlyTheory]
+        [InlineData("windows", 4, true)]
+        [InlineData("windows", 999, false)]
+        [InlineData("linux", 0, false)]
+        [InlineData("macOS", 0, false)]
+        public void IsOSPlatformVersionAtLeast(string platform, int major, bool expected)
+        {
+            Microsoft.Build.Framework.OperatingSystem.IsOSPlatformVersionAtLeast(platform, major).ShouldBe(expected);
+        }
+
+        [WindowsFullFrameworkOnlyFact]
+        public void IsWindows()
+        {
+            Microsoft.Build.Framework.OperatingSystem.IsWindows().ShouldBeTrue();
+        }
+
+        [WindowsFullFrameworkOnlyFact]
+        public void IsWindowsVersionAtLeast()
+        {
+            Microsoft.Build.Framework.OperatingSystem.IsWindowsVersionAtLeast(4).ShouldBeTrue();
+            Microsoft.Build.Framework.OperatingSystem.IsWindowsVersionAtLeast(999).ShouldBeFalse();
+        }
+
+        [WindowsFullFrameworkOnlyFact]
+        public void IsOtherThanWindows()
+        {
+            Microsoft.Build.Framework.OperatingSystem.IsFreeBSD().ShouldBeFalse();
+            Microsoft.Build.Framework.OperatingSystem.IsFreeBSDVersionAtLeast(0).ShouldBeFalse();
+            Microsoft.Build.Framework.OperatingSystem.IsLinux().ShouldBeFalse();
+            Microsoft.Build.Framework.OperatingSystem.IsMacOS().ShouldBeFalse();
+            Microsoft.Build.Framework.OperatingSystem.IsMacOSVersionAtLeast(0).ShouldBeFalse();
+        }
+#endif
+    }
+}
diff --git a/src/Framework/OperatingSystem.cs b/src/Framework/OperatingSystem.cs
new file mode 100644
index 00000000000..883ec55b924
--- /dev/null
+++ b/src/Framework/OperatingSystem.cs
@@ -0,0 +1,64 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if !NET5_0_OR_GREATER
+
+using System;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// System.OperatingSystem static methods were added in net5.0.
+    /// This class creates stand-in methods for net472 builds.
+    /// Assumes only Windows is supported.
+    /// </summary>
+    internal static class OperatingSystem
+    {
+        public static bool IsOSPlatform(string platform)
+        {
+            return platform?.Equals("WINDOWS", StringComparison.OrdinalIgnoreCase) ?? throw new ArgumentNullException(nameof(platform));
+        }
+
+        public static bool IsOSPlatformVersionAtLeast(string platform, int major, int minor = 0, int build = 0, int revision = 0)
+            => IsOSPlatform(platform) && IsOSVersionAtLeast(major, minor, build, revision);
+
+        public static bool IsLinux() => false;
+
+        public static bool IsFreeBSD() => false;
+
+        public static bool IsFreeBSDVersionAtLeast(int major, int minor = 0, int build = 0, int revision = 0) => false;
+
+        public static bool IsMacOS() => false;
+
+        public static bool IsMacOSVersionAtLeast(int major, int minor = 0, int build = 0) => false;
+
+        public static bool IsWindows() => true;
+
+        public static bool IsWindowsVersionAtLeast(int major, int minor = 0, int build = 0, int revision = 0)
+            => IsWindows() && IsOSVersionAtLeast(major, minor, build, revision);
+
+        private static bool IsOSVersionAtLeast(int major, int minor, int build, int revision)
+        {
+            Version current = Environment.OSVersion.Version;
+
+            if (current.Major != major)
+            {
+                return current.Major > major;
+            }
+
+            if (current.Minor != minor)
+            {
+                return current.Minor > minor;
+            }
+
+            if (current.Build != build)
+            {
+                return current.Build > build;
+            }
+
+            return current.Revision >= revision;
+        }
+    }
+}
+#endif
+
