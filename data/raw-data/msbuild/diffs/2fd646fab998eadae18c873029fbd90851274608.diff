diff --git a/.editorconfig b/.editorconfig
index 7b0f1419bb8..01161a81aa6 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -1,4 +1,4 @@
-# editorconfig.org
+ï»¿# editorconfig.org
 
 # top-most EditorConfig file
 root = true
@@ -163,6 +163,9 @@ dotnet_code_quality.ca2208.api_surface = public
 # CA1852: Seal internal types
 dotnet_diagnostic.ca1852.severity = warning
 
+# CA2000: Dispose objects before losing scope
+dotnet_diagnostic.ca2000.severity = error
+
 # RS0037: Enable tracking of nullability of reference types in the declared API
 # Our API is not annotated but new classes get nullable enabled so disable this.
 # We'd be happy if everything was annotated and this could be removed.
@@ -409,3 +412,6 @@ dotnet_diagnostic.IDE0290.severity = suggestion
 dotnet_diagnostic.IDE0300.severity = suggestion
 dotnet_diagnostic.IDE0301.severity = suggestion
 dotnet_diagnostic.IDE0305.severity = suggestion
+
+# Temporarily disable SA1010 "Opening square brackets should not be preceded by a space" until https://github.com/DotNetAnalyzers/StyleCopAnalyzers/issues/3687 is fixed
+dotnet_diagnostic.SA1010.severity = none
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 12768a44440..daf200ae88e 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -4,7 +4,43 @@ trigger:
 - vs*
 
 jobs:
+- job: CheckVersionBumpOnReleaseBranches
+  displayName: "Check Version Bump On Release Branches"
+  steps:
+  - powershell: |
+      $versionsFile = "eng/Versions.props"
+      $changedFiles = git diff --name-only HEAD HEAD~1
+      $changedVersionsFile = $changedFiles | Where-Object { $_ -eq $versionsFile }
+      $isInitialCommit = $false
+      $isVersionBumped = $false
+      if ($changedVersionsFile -ne $null) {
+        $difference = git diff HEAD~1 $versionsFile
+        $changedContent = $difference -join " "
+        # 'DotNetFinalVersionKind' is expected to be added only during the initial setup of the release branch
+        $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix> \+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>.*<DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
+        $isInitialCommit = $changedContent -match $initialCommitPattern
+        $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.* \+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
+        if (!($isInitialCommit) -and ($changedContent -match $pattern)) {
+          try {
+            $previousPatch = [Convert]::ToInt32($Matches.previous)
+            $currentPatch = [Convert]::ToInt32($Matches.current)
+            if ($currentPatch -gt $previousPatch) {
+              $isVersionBumped = $true
+            }
+          } catch {
+            Write-Host "An error occurred during conversion: $_"
+          }
+        }
+      }
+
+      if (!($isInitialCommit -or $isVersionBumped)) {
+        throw "Hello! I noticed that you're targeting one of our servicing branches. You need to increase the revision version number (the last part) of 'VersionPrefix' in eng/Versions.props."
+      }
+    condition: startsWith(variables['System.PullRequest.TargetBranch'], 'vs')
+    displayName: "Check if patch version is bumped up"
+
 - job: IfOnlyDocumentionChanged
+  dependsOn: CheckVersionBumpOnReleaseBranches
   displayName: "Check whether Test Results need to be executed"
   steps:
   - powershell: |
diff --git a/MSBuild.sln b/MSBuild.sln
index 5c8326406f6..d1daf054f9e 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -80,6 +80,8 @@ Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild.VSSetup.Arm64", "sr
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.UnitTests.Shared", "src\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj", "{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}"
 EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.BuildCheck.UnitTests", "src\BuildCheck.UnitTests\Microsoft.Build.BuildCheck.UnitTests.csproj", "{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -864,6 +866,30 @@ Global
 		{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}.Release|x64.Build.0 = Release|x64
 		{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}.Release|x86.ActiveCfg = Release|Any CPU
 		{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}.Release|x86.Build.0 = Release|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|ARM64.ActiveCfg = Debug|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|ARM64.Build.0 = Debug|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|x64.ActiveCfg = Debug|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|x64.Build.0 = Debug|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|x86.Build.0 = Debug|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|ARM64.Build.0 = MachineIndependent|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|Any CPU.Build.0 = Release|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|ARM64.ActiveCfg = Release|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|ARM64.Build.0 = Release|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x64.ActiveCfg = Release|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x64.Build.0 = Release|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x86.ActiveCfg = Release|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x86.Build.0 = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/README.md b/README.md
index bb357a2ad6d..f770f459200 100644
--- a/README.md
+++ b/README.md
@@ -2,7 +2,7 @@
 
 The Microsoft Build Engine is a platform for building applications. This engine, also known as MSBuild, provides an XML schema for a project file that controls how the build platform processes and builds software. Visual Studio uses MSBuild, but MSBuild can run without Visual Studio. By invoking msbuild.exe on your project or solution file, you can orchestrate and build products in environments where Visual Studio isn't installed.
 
-For more information on MSBuild, see the [MSBuild documentation](https://docs.microsoft.com/visualstudio/msbuild/msbuild) on docs.microsoft.com.
+For more information on MSBuild, see the [MSBuild documentation](https://learn.microsoft.com/visualstudio/msbuild/msbuild) on learn.microsoft.com.
 
 The [changelog](documentation/Changelog.md) has detailed information about changes made in different releases.
 
@@ -15,12 +15,12 @@ For the full supported experience, you will need to have Visual Studio 2022 or h
 To get started on **Visual Studio 2022**:
 
 1. [Install Visual Studio 2022](https://www.visualstudio.com/vs/).  Select the following Workloads:
-  - .NET desktop development
-  - .NET Core cross-platform development
+   - .NET desktop development
+   - .NET Core cross-platform development
 2. Ensure [long path support](https://learn.microsoft.com/windows/win32/fileio/maximum-file-path-limitation?tabs=registry#enable-long-paths-in-windows-10-version-1607-and-later) is enabled at the Windows level.
 3. Open a `Developer Command Prompt for VS 2022` prompt.
 4. Clone the source code: `git clone https://github.com/dotnet/msbuild`
-  - You may have to [download Git](https://git-scm.com/downloads) first.
+   - You may have to [download Git](https://git-scm.com/downloads) first.
 5. Run `.\build.cmd` from the root of the repo to build the code. This also restores packages needed to open the projects in Visual Studio.
 6. Open `MSBuild.sln` or `MSBuild.Dev.slnf` in Visual Studio 2022.
 
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 000d4675069..7744d96a090 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -26,6 +26,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 ### 17.12
 - [Log TaskParameterEvent for scalar parameters](https://github.com/dotnet/msbuild/pull/9908)
 - [Convert.ToString during a property evaluation uses the InvariantCulture for all types](https://github.com/dotnet/msbuild/pull/9874)
+- [Fix oversharing of build results in ResultsCache](https://github.com/dotnet/msbuild/pull/9987)
 
 ### 17.10
 - [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
diff --git a/documentation/wiki/MSBuild-Tips-&-Tricks.md b/documentation/wiki/MSBuild-Tips-&-Tricks.md
index 17b137ae33d..9dc4d33b44c 100644
--- a/documentation/wiki/MSBuild-Tips-&-Tricks.md
+++ b/documentation/wiki/MSBuild-Tips-&-Tricks.md
@@ -120,3 +120,41 @@ The above explanations are only half the truth, though.
 * The `Directory.*.props`, `Directory.*.targets` et. al. also offer ways to extend your build. They are fairly well-known and documented:
   * [`Directory.Build.props` and `Directory.Build.targets`](https://learn.microsoft.com/visualstudio/msbuild/customize-by-directory)
   * [`Directory.Solution.props` and `Directory.Solution.targets`](https://learn.microsoft.com/visualstudio/msbuild/customize-solution-build) as well as `before.{solutionname}.sln.targets` and `after.{solutionname}.sln.targets` can be used to inject properties, item definitions, items and targets into your build
+
+
+## Using quotes in MSBuild properties
+There are times when MSBuild needs to be invoked with property arguments using the `/p:propertyName=propertyValue` syntax. However, the way of achieving the proper result can vary depending on the shell used to run the MSBuild (PowerShell, PowerShell Core, Command Prompt, etc.). 
+
+When the property value contains quotes (`"`), it may be handled differently depending on the interpreting shell.
+
+Let's explore the ways to pass property values that contain special symbols like `"`:
+
+Example project: 
+```
+<Project>
+  <Target Name="PrintPropertyValue">
+      <Message Text="Property value = ($(propertyValue))" Importance="high" />
+  </Target>
+</Project>
+```
+
+- CMD:
+  ```
+  msbuild.exe filename.proj /p:propertyValue="Hello, \"World!\""
+  ```
+
+  For more details about parsing in CMD and usage of special characters, please visit [this page](https://learn.microsoft.com/windows-server/administration/windows-commands/cmd)
+
+- Windows PowerShell:
+  ```
+  msbuild.exe filename.proj /p:propertyValue="Hello, \`"World!\`""
+  ```
+
+  For more details about parsing in Windows PowerShell 5.1 and usage of special characters, please visit [this page](https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_parsing?view=powershell-5.1)
+
+- PowerShell Core:
+  ```
+  msbuild.exe filename.proj /p:propertyValue="Hello, `"World!`""
+  ```
+
+  For more details about parsing in PowerShell (7.4 and higher) and usage of special characters, please visit [this page](https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_parsing?view=powershell-7.4)
\ No newline at end of file
diff --git a/eng/BootStrapMsBuild.props b/eng/BootStrapMsBuild.props
new file mode 100644
index 00000000000..858cf76ac54
--- /dev/null
+++ b/eng/BootStrapMsBuild.props
@@ -0,0 +1,21 @@
+<Project>
+
+  <!--
+  Construct a location of MSBuild bootstrap folder - to be used for deployment and for tests
+   relying on bootstrapped MSBuild
+   -->
+
+  <PropertyGroup>
+    <BootstrapDestination>$(ArtifactsBinDir)bootstrap\</BootstrapDestination>
+    <BootstrapDestination Condition="'$(Platform)' == 'x64' or '$(Platform)' == 'arm64'">$(BootstrapDestination)$(Platform)\</BootstrapDestination>
+    <BootstrapDestination>$(BootstrapDestination)$(TargetFramework.ToLowerInvariant())\MSBuild\</BootstrapDestination>
+  </PropertyGroup>
+  
+  <PropertyGroup Condition="$(TargetFramework.StartsWith('net4'))">
+    <BootstrapBinaryDestination>$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin</BootstrapBinaryDestination>
+  </PropertyGroup>
+  
+  <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
+    <BootstrapBinaryDestination>$(BootstrapDestination)</BootstrapBinaryDestination>
+  </PropertyGroup>
+</Project>
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMsBuild.targets
similarity index 97%
rename from eng/BootStrapMSBuild.targets
rename to eng/BootStrapMsBuild.targets
index 3aafd190c94..07531f6633b 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMsBuild.targets
@@ -7,15 +7,14 @@
    -->
 
   <PropertyGroup>
-    <BootstrapDestination>$(ArtifactsBinDir)bootstrap\</BootstrapDestination>
-    <BootstrapDestination Condition="'$(Platform)' == 'x64' or '$(Platform)' == 'arm64'">$(BootstrapDestination)$(Platform)\</BootstrapDestination>
-    <BootstrapDestination>$(BootstrapDestination)$(TargetFramework.ToLowerInvariant())\MSBuild\</BootstrapDestination>
-
     <BootstrapDependsOn Condition="$(TargetFramework.StartsWith('net4'))">BootstrapFull</BootstrapDependsOn>
     <BootstrapDependsOn Condition="!$(TargetFramework.StartsWith('net4'))">BootstrapNetCore</BootstrapDependsOn>
 
     <!-- Needed to ensure that RuntimeTargetsCopyLocalItems is populated for full framework -->
     <DisableRuntimeTargets>false</DisableRuntimeTargets>
+
+    <!-- Disable build acceleration for this non-standard project. The Bootstrap target must run after any of the dependencies changes.  -->
+    <AccelerateBuildsInVisualStudio>false</AccelerateBuildsInVisualStudio>
   </PropertyGroup>
 
   <Target Name="Bootstrap" DependsOnTargets="$(BootstrapDependsOn)"
diff --git a/eng/Common.globalconfig b/eng/Common.globalconfig
index dd47c3b3336..57c789f0371 100644
--- a/eng/Common.globalconfig
+++ b/eng/Common.globalconfig
@@ -321,9 +321,6 @@ dotnet_diagnostic.CA1837.severity = suggestion
 # Avoid 'StringBuilder' parameters for P/Invokes
 dotnet_diagnostic.CA1838.severity = warning
 
-# Dispose objects before losing scope
-dotnet_diagnostic.CA2000.severity = none
-
 # Do not lock on objects with weak identity
 dotnet_diagnostic.CA2002.severity = none
 
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index da3091ab2b6..bab7c907f04 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -91,9 +91,9 @@
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>fb50d1a45ed10b39b5f335bc3a4bdcaea9b951cf</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24202.15">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24216.12">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>cbca41cad4e21c29548e9e57d7135740b6f78df9</Sha>
+      <Sha>3af0081a6e811b78d37c62e479914f7f4cfb0d1a</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24204.3">
diff --git a/eng/Versions.props b/eng/Versions.props
index b92fc40650c..939fba9aa49 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -51,7 +51,7 @@
     <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24204.3</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24202.15</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24216.12</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.10.0-preview.2.97</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index 71cbf493110..b6e3c089135 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -115,13 +115,12 @@ try {
 
   # When using bootstrapped MSBuild:
   # - Turn off node reuse (so that bootstrapped MSBuild processes don't stay running and lock files)
-  # - Do run tests
-  # - Don't try to create a bootstrap deployment
+  # - Create bootstrap environment as it's required when also running tests
   if ($onlyDocChanged) {
     & $PSScriptRoot\Common\Build.ps1 -restore -build -ci /p:CreateBootstrap=false /nr:false @properties
   }
   else {
-    & $PSScriptRoot\Common\Build.ps1 -restore -build -test -ci /p:CreateBootstrap=false /nr:false @properties
+    & $PSScriptRoot\Common\Build.ps1 -restore -build -test -ci /p:CreateBootstrap=true /nr:false @properties
   }
 
   exit $lastExitCode
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index 06d4ba46e21..8edd377ec73 100755
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -80,11 +80,10 @@ export DOTNET_HOST_PATH="$_InitializeDotNetCli/dotnet"
 
 # When using bootstrapped MSBuild:
 # - Turn off node reuse (so that bootstrapped MSBuild processes don't stay running and lock files)
-# - Do run tests
-# - Don't try to create a bootstrap deployment
+# - Create bootstrap environment as it's required when also running tests
 if [ $onlyDocChanged = 0 ]
 then
-    . "$ScriptRoot/common/build.sh" --restore --build --test --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=false $properties $extra_properties
+    . "$ScriptRoot/common/build.sh" --restore --build --test --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=true $properties $extra_properties
 
 else
     . "$ScriptRoot/common/build.sh" --restore --build --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=false $properties $extra_properties
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index b098ccc9e3a..665f96765b1 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -37,6 +37,9 @@
     <PackageVersion Include="Shouldly" Version="4.2.1" />
     <PackageVersion Update="Shouldly" Condition="'$(ShouldlyVersion)' != ''" Version="$(ShouldlyVersion)" />
 
+    <PackageVersion Include="FakeItEasy" Version="8.1.0" />
+    <PackageVersion Update="FakeItEasy" Condition="'$(FakeItEasyVersion)' != ''" Version="$(FakeItEasyVersion)" />
+
     <PackageVersion Include="System.CodeDom" Version="8.0.0" />
     <PackageVersion Update="System.CodeDom" Condition="'$(SystemCodeDomVersion)' != ''" Version="$(SystemCodeDomVersion)" />
 
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 5cd20e9d57a..6a31254da54 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using System.Reflection;
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
@@ -1089,7 +1090,7 @@ public void TaskStartedNullBuildEventContext()
             Assert.Throws<InternalErrorException>(() =>
             {
                 ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
-                service.LogTaskStarted(null, "MyTask", "ProjectFile", "ProjectFileOfTask");
+                service.LogTaskStarted(taskBuildEventContext: null, "MyTask", "ProjectFile", "ProjectFileOfTask", taskAssemblyLocation: null);
             });
         }
 
@@ -1443,14 +1444,15 @@ private void TestProjectFinishedEvent(string projectFile, bool success)
         private void TestTaskStartedEvent(string taskName, string projectFile, string projectFileOfTask)
         {
             string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("TaskStarted", taskName);
+            string taskAssemblyLocation = Assembly.GetExecutingAssembly().Location;
 
             ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
-            service.LogTaskStarted(s_buildEventContext, taskName, projectFile, projectFileOfTask);
-            VerifyTaskStartedEvent(taskName, projectFile, projectFileOfTask, message, service);
+            service.LogTaskStarted(s_buildEventContext, taskName, projectFile, projectFileOfTask, taskAssemblyLocation);
+            VerifyTaskStartedEvent(taskName, projectFile, projectFileOfTask, message, service, taskAssemblyLocation);
 
             service.ResetProcessedBuildEvent();
             service.OnlyLogCriticalEvents = true;
-            service.LogTaskStarted(s_buildEventContext, taskName, projectFile, projectFileOfTask);
+            service.LogTaskStarted(s_buildEventContext, taskName, projectFile, projectFileOfTask, taskAssemblyLocation);
             Assert.Null(service.ProcessedBuildEvent);
         }
 
@@ -1631,7 +1633,7 @@ private void VerifyTaskFinishedEvent(string taskName, string projectFile, string
         /// <param name="projectFileOfTask">ProjectFileOfTask to create the comparison event with.</param>
         /// <param name="message">Message to create the comparison event with.</param>
         /// <param name="service">LoggingService mock object which overrides ProcessBuildEvent and can provide a ProcessedBuildEvent (the event which would have been sent to the loggers)</param>
-        private void VerifyTaskStartedEvent(string taskName, string projectFile, string projectFileOfTask, string message, ProcessBuildEventHelper service)
+        private void VerifyTaskStartedEvent(string taskName, string projectFile, string projectFileOfTask, string message, ProcessBuildEventHelper service, string taskAssemblyLocation)
         {
             TaskStartedEventArgs taskEvent = new TaskStartedEventArgs(
                  message,
@@ -1639,7 +1641,8 @@ private void VerifyTaskStartedEvent(string taskName, string projectFile, string
                   projectFile,
                   projectFileOfTask,
                   taskName,
-                  service.ProcessedBuildEvent.Timestamp);
+                  service.ProcessedBuildEvent.Timestamp,
+                  taskAssemblyLocation);
             taskEvent.BuildEventContext = s_buildEventContext;
             Assert.True(((TaskStartedEventArgs)service.ProcessedBuildEvent).IsEquivalent(taskEvent));
         }
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index 4b8f3b07286..920e49b51e1 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -5,6 +5,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Engine.UnitTests.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -61,6 +62,8 @@ internal sealed class MockHost : MockLoggingService, IBuildComponentHost, IBuild
 
         private ISdkResolverService _sdkResolverService;
 
+        private IBuildCheckManagerProvider _buildCheckManagerProvider;
+
         #region SystemParameterFields
 
         #endregion;
@@ -126,6 +129,9 @@ public MockHost(BuildParameters buildParameters, ConfigCache overrideConfigCache
 
             _sdkResolverService = new MockSdkResolverService();
             ((IBuildComponent)_sdkResolverService).InitializeComponent(this);
+
+            _buildCheckManagerProvider = new NullBuildCheckManagerProvider();
+            ((IBuildComponent)_buildCheckManagerProvider).InitializeComponent(this);
         }
 
         /// <summary>
@@ -194,6 +200,7 @@ public IBuildComponent GetComponent(BuildComponentType type)
                 BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
                 BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
                 BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                BuildComponentType.BuildCheckManagerProvider => (IBuildComponent)_buildCheckManagerProvider,
                 _ => throw new ArgumentException("Unexpected type " + type),
             };
         }
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index b3ceffe4bd5..a62b03686d4 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -573,7 +573,8 @@ public void LogTargetFinished(BuildEventContext targetBuildEventContext, string
         /// <param name="taskName">The name of the task</param>
         /// <param name="projectFile">The project file</param>
         /// <param name="projectFileOfTaskNode">The project file containing the task node.</param>
-        public void LogTaskStarted(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode)
+        /// <param name="taskAssemblyLocation">>The location of the assembly containing the implementation of the task.</param>
+        public void LogTaskStarted(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, string taskAssemblyLocation)
         {
         }
 
@@ -584,8 +585,9 @@ public void LogTaskStarted(BuildEventContext targetBuildEventContext, string tas
         /// <param name="taskName">The name of the task</param>
         /// <param name="projectFile">The project file</param>
         /// <param name="projectFileOfTaskNode">The project file containing the task node.</param>
+        /// <param name="taskAssemblyLocation">>The location of the assembly containing the implementation of the task.</param>
         /// <returns>The task logging context</returns>
-        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column)
+        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column, string taskAssemblyLocation)
         {
             return new BuildEventContext(0, 0, 0, 0);
         }
diff --git a/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs b/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
index 0e83218dce7..4f35fa823fe 100644
--- a/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
@@ -18,7 +18,7 @@ public async Task EmitConsoleMessages()
         {
             StringBuilder sb = new StringBuilder();
 
-            using (TextWriter writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text)))
+            using (var writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text)))
             {
                 writer.WriteLine("Line 1");
                 await Task.Delay(80); // should be somehow bigger than `RedirectConsoleWriter` flush period - see its constructor
diff --git a/src/Build.UnitTests/BackEnd/RequestedProjectState_Tests.cs b/src/Build.UnitTests/BackEnd/RequestedProjectState_Tests.cs
new file mode 100644
index 00000000000..034b3d1594a
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/RequestedProjectState_Tests.cs
@@ -0,0 +1,208 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using FluentAssertions;
+using Microsoft.Build.Execution;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.UnitTests.BackEnd
+{
+    public class RequestedProjectState_Tests
+    {
+        [Fact]
+        public void DeepCloneEmpty()
+        {
+            RequestedProjectState state = new();
+            RequestedProjectState clone = state.DeepClone();
+
+            clone.PropertyFilters.Should().BeNull();
+            clone.ItemFilters.Should().BeNull();
+        }
+
+        [Fact]
+        public void DeepCloneProperties()
+        {
+            List<string> properties = ["prop1", "prop2"];
+            RequestedProjectState state = new()
+            {
+                PropertyFilters = properties,
+            };
+            RequestedProjectState clone = state.DeepClone();
+
+            clone.PropertyFilters.Should().BeEquivalentTo(properties);
+            clone.ItemFilters.Should().BeNull();
+
+            // Mutating the original instance is not reflected in the clone.
+            properties.Add("prop3");
+            clone.PropertyFilters.Count.Should().NotBe(properties.Count);
+        }
+
+        [Fact]
+        public void DeepCloneItemsNoMetadata()
+        {
+            Dictionary<string, List<string>> items = new()
+            {
+                { "item1", null! },
+                { "item2", null! },
+            };
+            RequestedProjectState state = new()
+            {
+                ItemFilters = items,
+            };
+            RequestedProjectState clone = state.DeepClone();
+
+            clone.PropertyFilters.Should().BeNull();
+            clone.ItemFilters.Should().BeEquivalentTo(items);
+
+            // Mutating the original instance is not reflected in the clone.
+            items.Add("item3", null!);
+            clone.ItemFilters.Count.Should().NotBe(items.Count);
+        }
+
+        [Fact]
+        public void DeepCloneItemsWithMetadata()
+        {
+            Dictionary<string, List<string>> items = new()
+            {
+                { "item1", ["metadatum1", "metadatum2"] },
+                { "item2", ["metadatum3"] },
+            };
+            RequestedProjectState state = new()
+            {
+                ItemFilters = items,
+            };
+            RequestedProjectState clone = state.DeepClone();
+
+            clone.PropertyFilters.Should().BeNull();
+            clone.ItemFilters.Should().BeEquivalentTo(items);
+
+            // Mutating the original instance is not reflected in the clone.
+            items["item2"].Add("metadatum4");
+            clone.ItemFilters["item2"].Count.Should().NotBe(items["item2"].Count);
+        }
+
+        [Fact]
+        public void IsSubsetOfEmpty()
+        {
+            RequestedProjectState state1 = new();
+            RequestedProjectState state2 = new();
+
+            // Empty instances are subsets of each other.
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeTrue();
+
+            state1.PropertyFilters = ["prop1"];
+            state1.ItemFilters = new Dictionary<string, List<string>>()
+            {
+                { "item1", null! },
+            };
+
+            // Non-empty instance is a subset of empty instance but not the other way round.
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+        }
+
+        [Fact]
+        public void IsSubsetOfProperties()
+        {
+            RequestedProjectState state1 = new()
+            {
+                PropertyFilters = ["prop1"],
+            };
+            RequestedProjectState state2 = new()
+            {
+                PropertyFilters = ["prop1", "prop2"],
+            };
+
+            // "prop1" is a subset of "prop1", "prop2".
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+
+            state1.PropertyFilters.Add("prop3");
+
+            // Disjoint sets are not subsets of each other.
+            state1.IsSubsetOf(state2).Should().BeFalse();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+
+            state1.PropertyFilters.Clear();
+
+            // Empty props is a subset of anything.
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+        }
+
+        [Fact]
+        public void IsSubsetOfItemsNoMetadata()
+        {
+            RequestedProjectState state1 = new()
+            {
+                ItemFilters = new Dictionary<string, List<string>>()
+                {
+                    { "item1", null! },
+                },
+            };
+            RequestedProjectState state2 = new()
+            {
+                ItemFilters = new Dictionary<string, List<string>>()
+                {
+                    { "item1", null! },
+                    { "item2", null! },
+                },
+            };
+
+            // "item1" is a subset of "item1", "item2".
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+
+            state1.ItemFilters.Add("item3", null!);
+
+            // Disjoint sets are not subsets of each other.
+            state1.IsSubsetOf(state2).Should().BeFalse();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+
+            state1.ItemFilters.Clear();
+
+            // Empty items is a subset of anything.
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+        }
+
+        [Fact]
+        public void IsSubsetOfItemsWithMetadata()
+        {
+            RequestedProjectState state1 = new()
+            {
+                ItemFilters = new Dictionary<string, List<string>>()
+                {
+                    { "item1", ["metadatum1"] },
+                },
+            };
+            RequestedProjectState state2 = new()
+            {
+                ItemFilters = new Dictionary<string, List<string>>()
+                {
+                    { "item1", null! },
+                },
+            };
+
+            // "item1" with "metadatum1" is a subset of "item1" with no metadata filter.
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+
+            state2.ItemFilters["item1"] = ["metadatum2"];
+
+            // Disjoint metadata filters are not subsets of each other.
+            state1.IsSubsetOf(state2).Should().BeFalse();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+
+            state1.ItemFilters["item1"] = [];
+
+            // Empty metadata filter is a subset of any other metadata filter.
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
index d832aa878b3..ac421399121 100644
--- a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
@@ -3,8 +3,12 @@
 
 using System;
 using System.Collections.Generic;
+using System.IO;
 using System.Linq;
+using System.Xml;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
@@ -188,6 +192,153 @@ public void TestRetrieveSubsetTargetsFromResult()
             Assert.Equal(BuildResultCode.Success, response.Results.OverallResult);
         }
 
+        [Fact]
+        public void TestCacheOnDifferentBuildFlagsPerRequest_ProvideProjectStateAfterBuild()
+        {
+            string targetName = "testTarget1";
+            int submissionId = 1;
+            int nodeRequestId = 0;
+            int configurationId = 1;
+
+            BuildRequest requestWithNoBuildDataFlags = new BuildRequest(
+               submissionId,
+               nodeRequestId,
+               configurationId,
+               new string[1] { targetName } /* escapedTargets */,
+               null /* hostServices */,
+               BuildEventContext.Invalid /* parentBuildEventContext */,
+               null /* parentRequest */,
+               BuildRequestDataFlags.None);
+
+            BuildRequest requestWithProjectStateFlag = new BuildRequest(
+               submissionId,
+               nodeRequestId,
+               configurationId,
+               new string[1] { targetName } /* escapedTargets */,
+               null /* hostServices */,
+               BuildEventContext.Invalid /* parentBuildEventContext */,
+               null /* parentRequest */,
+               BuildRequestDataFlags.ProvideProjectStateAfterBuild);
+
+            BuildRequest requestWithNoBuildDataFlags2 = new BuildRequest(
+               submissionId,
+               nodeRequestId,
+               configurationId,
+               new string[1] { targetName } /* escapedTargets */,
+               null /* hostServices */,
+               BuildEventContext.Invalid /* parentBuildEventContext */,
+               null /* parentRequest */,
+               BuildRequestDataFlags.None);
+
+            BuildResult resultForRequestWithNoBuildDataFlags = new(requestWithNoBuildDataFlags);
+            resultForRequestWithNoBuildDataFlags.AddResultsForTarget(targetName, BuildResultUtilities.GetEmptySucceedingTargetResult());
+            ResultsCache cache = new();
+            cache.AddResult(resultForRequestWithNoBuildDataFlags);
+
+            ResultsCacheResponse cacheResponseForRequestWithNoBuildDataFlags = cache.SatisfyRequest(
+               requestWithNoBuildDataFlags,
+               new List<string>(),
+               new List<string>(new string[] { targetName }),
+               skippedResultsDoNotCauseCacheMiss: false);
+
+            ResultsCacheResponse cachedResponseForProjectState = cache.SatisfyRequest(
+               requestWithProjectStateFlag,
+               new List<string>(),
+               new List<string>(new string[] { targetName }),
+               skippedResultsDoNotCauseCacheMiss: false);
+
+            ResultsCacheResponse cacheResponseForNoBuildDataFlags2 = cache.SatisfyRequest(
+               requestWithNoBuildDataFlags2,
+               new List<string>(),
+               new List<string>(new string[] { targetName }),
+               skippedResultsDoNotCauseCacheMiss: false);
+
+            Assert.Equal(ResultsCacheResponseType.Satisfied, cacheResponseForRequestWithNoBuildDataFlags.Type);
+
+            // Because ProvideProjectStateAfterBuildFlag was provided as a part of BuildRequest
+            Assert.Equal(ResultsCacheResponseType.NotSatisfied, cachedResponseForProjectState.Type);
+
+            Assert.Equal(ResultsCacheResponseType.Satisfied, cacheResponseForNoBuildDataFlags2.Type);
+        }
+
+        [Fact]
+        public void TestCacheOnDifferentBuildFlagsPerRequest_ProvideSubsetOfStateAfterBuild()
+        {
+            string targetName = "testTarget1";
+            int submissionId = 1;
+            int nodeRequestId = 0;
+            int configurationId = 1;
+
+            RequestedProjectState requestedProjectState1 = new()
+            {
+                PropertyFilters = ["property1", "property2"],
+            };
+            BuildRequest requestWithSubsetFlag1 = new BuildRequest(
+                submissionId,
+                nodeRequestId,
+                configurationId,
+                new string[1] { targetName } /* escapedTargets */,
+                null /* hostServices */,
+                BuildEventContext.Invalid /* parentBuildEventContext */,
+                null /* parentRequest */,
+                BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild,
+                requestedProjectState1);
+
+            RequestedProjectState requestedProjectState2 = new()
+            {
+                PropertyFilters = ["property1"],
+            };
+            BuildRequest requestWithSubsetFlag2 = new BuildRequest(
+                submissionId,
+                nodeRequestId,
+                configurationId,
+                new string[1] { targetName } /* escapedTargets */,
+                null /* hostServices */,
+                BuildEventContext.Invalid /* parentBuildEventContext */,
+                null /* parentRequest */,
+                BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild,
+                requestedProjectState2);
+
+            BuildResult resultForRequestWithSubsetFlag1 = new(requestWithSubsetFlag1);
+            resultForRequestWithSubsetFlag1.AddResultsForTarget(targetName, BuildResultUtilities.GetEmptySucceedingTargetResult());
+
+            using TextReader textReader = new StringReader(@"
+              <Project>
+                <PropertyGroup>
+                  <property1>Value1</property1>
+                  <property2>Value2</property2>
+                </PropertyGroup>
+              </Project>
+            ");
+            using XmlReader xmlReader = XmlReader.Create(textReader);
+            resultForRequestWithSubsetFlag1.ProjectStateAfterBuild = new ProjectInstance(ProjectRootElement.Create(xmlReader)).FilteredCopy(requestedProjectState1);
+
+            ResultsCache cache = new();
+            cache.AddResult(resultForRequestWithSubsetFlag1);
+
+            ResultsCacheResponse cachedResponseWithSubsetFlag1 = cache.SatisfyRequest(
+                requestWithSubsetFlag1,
+                new List<string>(),
+                new List<string>(new string[] { targetName }),
+                skippedResultsDoNotCauseCacheMiss: false);
+
+            ResultsCacheResponse cachedResponseWithSubsetFlag2 = cache.SatisfyRequest(
+                requestWithSubsetFlag2,
+                new List<string>(),
+                new List<string>(new string[] { targetName }),
+                skippedResultsDoNotCauseCacheMiss: false);
+
+            // We used the same filter that was used for the ProjectInstance in the cache -> cache hit.
+            Assert.Equal(ResultsCacheResponseType.Satisfied, cachedResponseWithSubsetFlag1.Type);
+            Assert.Equal("Value1", cachedResponseWithSubsetFlag1.Results.ProjectStateAfterBuild.GetPropertyValue("property1"));
+            Assert.Equal("Value2", cachedResponseWithSubsetFlag1.Results.ProjectStateAfterBuild.GetPropertyValue("property2"));
+
+            // We used a filter that's a subset of the one used for the ProjectInstance in the cache -> cache hit.
+            Assert.Equal(ResultsCacheResponseType.Satisfied, cachedResponseWithSubsetFlag2.Type);
+            Assert.Equal("Value1", cachedResponseWithSubsetFlag2.Results.ProjectStateAfterBuild.GetPropertyValue("property1"));
+            Assert.Equal("", cachedResponseWithSubsetFlag2.Results.ProjectStateAfterBuild.GetPropertyValue("property2"));
+        }
+
         [Fact]
         public void TestClearResultsCache()
         {
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index b1516503006..ba22e2beed0 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -46,7 +46,7 @@ public class TaskExecutionHost_Tests : ITestTaskHost, IBuildEngine2, IDisposable
         /// <summary>
         /// The task execution host
         /// </summary>
-        private ITaskExecutionHost _host;
+        private TaskExecutionHost _host;
 
         /// <summary>
         /// The mock logging service
@@ -1245,7 +1245,7 @@ private void InitializeHost(bool throwOnExecute)
 #else
             AssemblyLoadInfo loadInfo = AssemblyLoadInfo.Create(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).GetTypeInfo().FullName, null);
 #endif
-            LoadedType loadedType = new LoadedType(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory), loadInfo, typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).GetTypeInfo().Assembly, typeof(ITaskItem));
+            LoadedType loadedType = new LoadedType(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory), loadInfo, typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).Assembly, typeof(ITaskItem));
 
             TaskBuilderTestTask.TaskBuilderTestTaskFactory taskFactory = new TaskBuilderTestTask.TaskBuilderTestTaskFactory();
             taskFactory.ThrowOnExecute = throwOnExecute;
@@ -1266,7 +1266,7 @@ private void InitializeHost(bool throwOnExecute)
                 CancellationToken.None);
 
             ProjectTaskInstance taskInstance = project.Targets["foo"].Tasks.First();
-            TaskLoggingContext talc = tlc.LogTaskBatchStarted(".", taskInstance);
+            TaskLoggingContext talc = tlc.LogTaskBatchStarted(".", taskInstance, typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).Assembly.GetName().FullName);
 
             ItemDictionary<ProjectItemInstance> itemsByName = new ItemDictionary<ProjectItemInstance>();
 
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index ccd837ef921..43fa2696859 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -8,12 +8,14 @@
 using System.Linq;
 using System.Reflection;
 using System.Text;
+using FakeItEasy;
 using FluentAssertions;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
@@ -637,6 +639,61 @@ public void SuppressCommandOutputForNonDiagVerbosity()
             }
         }
 
+        [Theory]
+        // Wildcard - new scenario
+        [InlineData("mylog-{}-foo", "mylog-xxxxx-foo.binlog")]
+        [InlineData("mylog-{}-foo-{}", "mylog-xxxxx-foo-xxxxx.binlog")]
+        [InlineData("\"mylog-{}-foo\"", "mylog-xxxxx-foo.binlog")]
+        [InlineData("foo\\bar\\mylog-{}-foo.binlog", "foo\\bar\\mylog-xxxxx-foo.binlog")]
+        [InlineData("ProjectImports=None;LogFile=mylog-{}-foo", "mylog-xxxxx-foo.binlog")]
+        // No wildcard - pre-existing scenarios
+        [InlineData("mylog-foo.binlog", "mylog-foo.binlog")]
+        [InlineData("\"mylog-foo.binlog\"", "mylog-foo.binlog")]
+        [InlineData("foo\\bar\\mylog-foo.binlog", "foo\\bar\\mylog-foo.binlog")]
+        [InlineData("ProjectImports=None;LogFile=mylog-foo.binlog", "mylog-foo.binlog")]
+        public void BinlogFileNameParameterParsing(string parameters, string expectedBinlogFile)
+        {
+            var binaryLogger = new BinaryLogger
+            {
+                Parameters = parameters
+            };
+            string random = "xxxxx";
+            binaryLogger.PathParameterExpander = _ => random;
+
+            var eventSource = A.Fake<IEventSource>();
+
+            binaryLogger.Initialize(eventSource);
+            string expectedLog = Path.GetFullPath(expectedBinlogFile);
+            binaryLogger.FilePath.Should().BeEquivalentTo(expectedLog);
+            binaryLogger.Shutdown();
+            File.Exists(binaryLogger.FilePath).ShouldBeTrue();
+            FileUtilities.DeleteNoThrow(binaryLogger.FilePath);
+
+            // We need to create the file to satisfy the invariant set by the ctor of this testclass
+            File.Create(_logFile);
+        }
+
+        [Fact]
+        public void BinlogFileNameWildcardGeneration()
+        {
+            var binaryLogger = new BinaryLogger
+            {
+                Parameters = "{}"
+            };
+
+            var eventSource = A.Fake<IEventSource>();
+
+            binaryLogger.Initialize(eventSource);
+            binaryLogger.FilePath.Should().EndWith(".binlog");
+            binaryLogger.FilePath.Length.ShouldBeGreaterThan(10);
+            binaryLogger.Shutdown();
+            File.Exists(binaryLogger.FilePath).ShouldBeTrue();
+            FileUtilities.DeleteNoThrow(binaryLogger.FilePath);
+
+            // We need to create the file to satisfy the invariant set by the ctor of this testclass
+            File.Create(_logFile);
+        }
+
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 46170961e81..cb60a9f2d42 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -191,7 +191,9 @@ public void RoundtripTaskStartedEventArgs()
                 null,
                 projectFile: "C:\\project.proj",
                 taskFile: "C:\\common.targets",
-                taskName: "Csc");
+                taskName: "Csc",
+                DateTime.Now,
+                "TaskAssemblyLocation");
             args.LineNumber = 42;
             args.ColumnNumber = 999;
 
@@ -200,7 +202,8 @@ public void RoundtripTaskStartedEventArgs()
                 e => e.TaskFile,
                 e => e.TaskName,
                 e => e.LineNumber.ToString(),
-                e => e.ColumnNumber.ToString());
+                e => e.ColumnNumber.ToString(),
+                e => e.TaskAssemblyLocation);
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 2306910aabc..6ab7a893816 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -2299,6 +2299,50 @@ public void CustomTargetNamesAreInInMetaproj()
             Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase)));
         }
 
+        /// <summary>
+        /// Verifies that disambiguated target names are used when a project name matches a standard solution entry point.
+        /// </summary>
+        [Fact]
+        public void DisambiguatedTargetNamesAreInInMetaproj()
+        {
+            foreach(string projectName in ProjectInSolution.projectNamesToDisambiguate)
+            {
+                SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(
+                $$"""
+                    Microsoft Visual Studio Solution File, Format Version 14.00
+                    # Visual Studio 2015
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "{{projectName}}", "{{projectName}}.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Release|Any CPU = Release|Any CPU
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+                        EndGlobalSection
+                    EndGlobal
+                """);
+
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), null);
+
+                foreach (string targetName in ProjectInSolution.projectNamesToDisambiguate)
+                {
+                    // The entry point still exists normally.
+                    Assert.True(instances[0].Targets.ContainsKey(targetName));
+
+                    // The traversal target should be disambiguated with a "Solution:" prefix.
+                    // Note: The default targets are used instead of "Build".
+                    string traversalTargetName = targetName.Equals("Build", StringComparison.OrdinalIgnoreCase)
+                        ? $"Solution:{projectName}"
+                        : $"Solution:{projectName}:{targetName}";
+                    Assert.True(instances[0].Targets.ContainsKey(traversalTargetName));
+                }
+            }
+        }
+
         /// <summary>
         /// Verifies that illegal user target names (the ones already used internally) don't crash the SolutionProjectGenerator
         /// </summary>
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 4af483bd8e8..31dea1590f8 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -12,9 +12,12 @@
 using System.Threading;
 using System.Xml;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -23,7 +26,6 @@
 using Microsoft.Win32;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using ProjectHelpers = Microsoft.Build.UnitTests.BackEnd.ProjectHelpers;
 using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
@@ -4380,6 +4382,18 @@ public void PropertyFunctionCheckFeatureAvailability(string featureName, string
             Assert.Equal(availability, result);
         }
 
+        [Theory]
+        [InlineData("\u3407\ud840\udc60\ud86a\ude30\ud86e\udc0a\ud86e\udda0\ud879\udeae\u2fd5\u0023", 0, 3, "\u3407\ud840\udc60\ud86a\ude30")]
+        [InlineData("\u3407\ud840\udc60\ud86a\ude30\ud86e\udc0a\ud86e\udda0\ud879\udeae\u2fd5\u0023", 2, 5, "\ud86a\ude30\ud86e\udc0a\ud86e\udda0\ud879\udeae\u2fd5")]
+        public void SubstringByTextElements(string featureName, int start, int length, string expected)
+        {
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), FileSystems.Default);
+
+            var result = expander.ExpandIntoStringLeaveEscaped($"$([MSBuild]::SubstringByTextElements({featureName}, {start}, {length}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+
+            Assert.Equal(expected, result);
+        }
+
         [Fact]
         public void PropertyFunctionIntrinsicFunctionGetCurrentToolsDirectory()
         {
@@ -5055,5 +5069,27 @@ private static bool ICUModeAvailable()
             int version = bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
             return version != 0 && version == sortVersion.FullVersion;
         }
+
+        [Fact]
+        public void PropertyFunctionRegisterAnalyzer()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var logger = new MockLogger();
+                ILoggingService loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+                loggingService.RegisterLogger(logger);
+                var loggingContext = new MockLoggingContext(
+                    loggingService,
+                    new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0, 0));
+                var dummyAssemblyFile = env.CreateFile(env.CreateFolder(), "test.dll");
+
+                var result = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), FileSystems.Default)
+                    .ExpandIntoStringLeaveEscaped($"$([MSBuild]::RegisterAnalyzer({dummyAssemblyFile.Path}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance, loggingContext);
+
+                result.ShouldBe(Boolean.TrueString);
+                _ = logger.AllBuildEvents.Select(be => be.ShouldBeOfType<BuildCheckAcquisitionEventArgs>());
+                logger.AllBuildEvents.Count.ShouldBe(1);
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 26729eee551..5cc0de97d2c 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -9,6 +9,7 @@
 using System.Text.RegularExpressions;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -107,10 +108,11 @@ public void ConstructWithSingleNodeWithProjectInstanceFactory()
                     (projectPath, globalProperties, projectCollection) =>
                     {
                         factoryCalled = true;
-                        return ProjectGraph.DefaultProjectInstanceFactory(
+                        return ProjectGraph.StaticProjectInstanceFactory(
                             projectPath,
                             globalProperties,
-                            projectCollection);
+                            projectCollection,
+                            EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated));
                     });
                 projectGraph.ProjectNodes.Count.ShouldBe(1);
                 projectGraph.ProjectNodes.First().ProjectInstance.FullPath.ShouldBe(entryProject.Path);
@@ -2808,6 +2810,119 @@ public void MultitargettingTargetsWithBuildProjectReferencesFalse()
             }
         }
 
+        [Theory]
+        // Built-in targets
+        [InlineData(new string[0], new[] { "Project1Default" }, new[] { "Project2Default" })]
+        [InlineData(new[] { "Build" }, new[] { "Project1Default" }, new[] { "Project2Default" })]
+        [InlineData(new[] { "Rebuild" }, new[] { "Rebuild" }, new[] { "Rebuild" })]
+        [InlineData(new[] { "Clean" }, new[] { "Clean" }, new[] { "Clean" })]
+        [InlineData(new[] { "Publish" }, new[] { "Publish" }, new[] { "Publish" })]
+        // Traversal targets
+        [InlineData(new[] { "Project1" }, new[] { "Project1Default" }, new string[0])]
+        [InlineData(new[] { "Project2" }, new string[0], new[] { "Project2Default" })]
+        [InlineData(new[] { "Project1", "Project2" }, new[] { "Project1Default" }, new[] { "Project2Default" })]
+        [InlineData(new[] { "Project1:Rebuild" }, new[] { "Rebuild" }, new string[0])]
+        [InlineData(new[] { "Project2:Rebuild" }, new string[0], new[] { "Rebuild" })]
+        [InlineData(new[] { "Project1:Rebuild", "Project2:Clean" }, new[] { "Rebuild" }, new[] { "Clean" })]
+        [InlineData(new[] { "CustomTarget" }, new[] { "CustomTarget" }, new[] { "CustomTarget" })]
+        [InlineData(new[] { "Project1:CustomTarget" }, new[] { "CustomTarget" }, new string[0])]
+        [InlineData(new[] { "Project2:CustomTarget" }, new string[0], new[] { "CustomTarget" })]
+        [InlineData(new[] { "Project1:CustomTarget", "Project2:CustomTarget" }, new[] { "CustomTarget" }, new[] { "CustomTarget" })]
+        public void GetTargetListsWithSolution(string[] entryTargets, string[] expectedProject1Targets, string[] expectedProject2Targets)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                const string ExtraContent = """
+                    <Target Name="CustomTarget" />
+                    """;
+                TransientTestFile project1File = CreateProjectFile(env: env, projectNumber: 1, defaultTargets: "Project1Default", extraContent: ExtraContent);
+                TransientTestFile project2File = CreateProjectFile(env: env, projectNumber: 2, defaultTargets: "Project2Default", extraContent: ExtraContent);
+
+                string solutionFileContents = $$"""
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 17
+                    VisualStudioVersion = 17.0.31903.59
+                    MinimumVisualStudioVersion = 17.0.31903.59
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project1", "{{project1File.Path}}", "{8761499A-7280-43C4-A32F-7F41C47CA6DF}"
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project2", "{{project2File.Path}}", "{2022C11A-1405-4983-BEC2-3A8B0233108F}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|x64 = Debug|x64
+                            Release|x64 = Release|x64
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.ActiveCfg = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.Build.0 = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.ActiveCfg = Release|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.Build.0 = Release|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.ActiveCfg = Debug|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.Build.0 = Debug|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.ActiveCfg = Release|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.Build.0 = Release|x64
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                    EndGlobal
+                    """;
+                TransientTestFile slnFile = env.CreateFile(@"Solution.sln", solutionFileContents);
+                SolutionFile solutionFile = SolutionFile.Parse(slnFile.Path);
+
+                ProjectGraph projectGraph = new(slnFile.Path);
+                ProjectGraphNode project1Node = GetFirstNodeWithProjectNumber(projectGraph, 1);
+                ProjectGraphNode project2Node = GetFirstNodeWithProjectNumber(projectGraph, 2);
+
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(entryTargets);
+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
+                targetLists[project1Node].ShouldBe(expectedProject1Targets);
+                targetLists[project2Node].ShouldBe(expectedProject2Targets);
+            }
+        }
+
+        [Theory]
+        [InlineData("Project1:Build")]
+        [InlineData("Project1:")]
+        public void GetTargetListsWithSolutionInvalidTargets(string entryTarget)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                TransientTestFile project1File = CreateProjectFile(env: env, projectNumber: 1);
+                string solutionFileContents = $$"""
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 17
+                    VisualStudioVersion = 17.0.31903.59
+                    MinimumVisualStudioVersion = 17.0.31903.59
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project1", "{{project1File.Path}}", "{8761499A-7280-43C4-A32F-7F41C47CA6DF}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|x64 = Debug|x64
+                            Release|x64 = Release|x64
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.ActiveCfg = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.Build.0 = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.ActiveCfg = Release|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.Build.0 = Release|x64
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                    EndGlobal
+                    """;
+                TransientTestFile slnFile = env.CreateFile(@"Solution.sln", solutionFileContents);
+                SolutionFile solutionFile = SolutionFile.Parse(slnFile.Path);
+
+                ProjectGraph projectGraph = new(slnFile.Path);
+
+                var getTargetListsFunc = (() => projectGraph.GetTargetLists([entryTarget]));
+                InvalidProjectFileException exception = getTargetListsFunc.ShouldThrow<InvalidProjectFileException>();
+                exception.Message.ShouldContain($"The target \"{entryTarget}\" does not exist in the project.");
+            }
+        }
+
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index b9c1cefc88c..a5f9ba12a47 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -19,6 +19,7 @@
     <PackageReference Include="FluentAssertions" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="Shouldly" />
+    <PackageReference Include="FakeItEasy" />
     <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
     <PackageReference Include="NuGet.Frameworks">
diff --git a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
index 6266cb6e4c7..fae6fbcbeb6 100644
--- a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
+++ b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
@@ -28,10 +28,6 @@ public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)
     {
         _env = TestEnvironment.Create(output);
 
-        // Ignore environment variables that may have been set by the environment where the tests are running.
-        _env.SetEnvironmentVariable("MSBUILDLIVELOGGER", null);
-        _env.SetEnvironmentVariable("MSBUILDTERMINALLOGGER", null);
-
         TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);
         TransientTestFile projectFile = _env.CreateFile(logFolder, "myProj.proj", $"""
             <Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Hello">
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index 6e57337863d..b4dbc09c40a 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -19,10 +19,12 @@
 #endif
 [assembly: InternalsVisibleTo("Microsoft.Build.Framework.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+[assembly: InternalsVisibleTo("Microsoft.Build.BuildCheck.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.UnitTests.Shared, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.Cop, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+[assembly: InternalsVisibleTo("Microsoft.Build.BuildCheck.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 // DO NOT expose Internals to "Microsoft.Build.UnitTests.OM.OrcasCompatibility" as this assembly is supposed to only see public interface
 
 // This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly,
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 33fba22ca1e..ec86b218112 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -21,10 +21,13 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.BuildCheck.Logging;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Experimental;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
@@ -1962,11 +1965,10 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
 
                 // Non-graph builds verify this in RequestBuilder, but for graph builds we need to disambiguate
                 // between entry nodes and other nodes in the graph since only entry nodes should error. Just do
-                // the verification expicitly before the build even starts.
+                // the verification explicitly before the build even starts.
                 foreach (ProjectGraphNode entryPointNode in projectGraph.EntryPointNodes)
                 {
-                    ImmutableList<string> targetList = targetsPerNode[entryPointNode];
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(targetList.Count > 0, entryPointNode.ProjectInstance.ProjectFileLocation, "NoTargetSpecified");
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(entryPointNode.ProjectInstance.Targets.Count > 0, entryPointNode.ProjectInstance.ProjectFileLocation, "NoTargetSpecified");
                 }
 
                 resultsPerNode = BuildGraph(projectGraph, targetsPerNode, submission.BuildRequestData);
@@ -2004,7 +2006,7 @@ private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
             IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetsPerNode,
             GraphBuildRequestData graphBuildRequestData)
         {
-            var waitHandle = new AutoResetEvent(true);
+            using var waitHandle = new AutoResetEvent(true);
             var graphBuildStateLock = new object();
 
             var blockedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes);
@@ -2952,7 +2954,12 @@ private void OnProjectStarted(object sender, ProjectStartedEventArgs e)
         /// <summary>
         /// Creates a logging service around the specified set of loggers.
         /// </summary>
-        private ILoggingService CreateLoggingService(IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> forwardingLoggers, ISet<string> warningsAsErrors, ISet<string> warningsNotAsErrors, ISet<string> warningsAsMessages)
+        private ILoggingService CreateLoggingService(
+            IEnumerable<ILogger> loggers,
+            IEnumerable<ForwardingLoggerRecord> forwardingLoggers,
+            ISet<string> warningsAsErrors,
+            ISet<string> warningsNotAsErrors,
+            ISet<string> warningsAsMessages)
         {
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
@@ -2976,6 +2983,18 @@ private ILoggingService CreateLoggingService(IEnumerable<ILogger> loggers, IEnum
             loggingService.WarningsNotAsErrors = warningsNotAsErrors;
             loggingService.WarningsAsMessages = warningsAsMessages;
 
+            if (_buildParameters.IsBuildCheckEnabled)
+            {
+                var buildCheckManagerProvider =
+                    ((IBuildComponentHost)this).GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider;
+                buildCheckManagerProvider!.Instance.SetDataSource(BuildCheckDataSource.EventArgs);
+
+                loggers = (loggers ?? Enumerable.Empty<ILogger>()).Concat(new[]
+                {
+                    new BuildCheckConnectorLogger(new AnalyzerLoggingContextFactory(loggingService), buildCheckManagerProvider.Instance)
+                });
+            }
+
             try
             {
                 if (loggers != null)
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 582532e5795..826fbadef56 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -10,6 +10,8 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
@@ -207,6 +209,8 @@ public class BuildParameters : ITranslatable
 
         private bool _question;
 
+        private bool _isBuildCheckEnabled;
+
         /// <summary>
         /// The settings used to load the project under build
         /// </summary>
@@ -309,6 +313,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             DiscardBuildResults = other.DiscardBuildResults;
             LowPriority = other.LowPriority;
             Question = other.Question;
+            IsBuildCheckEnabled = other.IsBuildCheckEnabled;
             ProjectCacheDescriptor = other.ProjectCacheDescriptor;
         }
 
@@ -834,6 +839,15 @@ public bool Question
             set => _question = value;
         }
 
+        /// <summary>
+        /// Gets or sets an indication of build analysis enablement.
+        /// </summary>
+        public bool IsBuildCheckEnabled
+        {
+            get => _isBuildCheckEnabled;
+            set => _isBuildCheckEnabled = value;
+        }
+
         /// <summary>
         /// Gets or sets the project cache description to use for all <see cref="BuildSubmission"/> or <see cref="GraphBuildSubmission"/>
         /// in addition to any potential project caches described in each project.
@@ -898,6 +912,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.TranslateEnum(ref _projectLoadSettings, (int)_projectLoadSettings);
             translator.Translate(ref _interactive);
             translator.Translate(ref _question);
+            translator.Translate(ref _isBuildCheckEnabled);
             translator.TranslateEnum(ref _projectIsolationMode, (int)_projectIsolationMode);
             translator.Translate(ref _reportFileAccesses);
 
diff --git a/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs b/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
index 5670a61e3f1..33dc9fe2cc4 100644
--- a/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
+++ b/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd;
@@ -82,6 +83,7 @@ internal int MainThreadSubmissionId
         /// Given a submission ID, assign it "start" and "finish" events to track its use of
         /// the legacy thread.
         /// </summary>
+        [SuppressMessage("Microsoft.Dispose", "CA2000:Dispose objects before losing scope", Justification = "The events are disposed in UnregisterSubmissionForLegacyThread")]
         internal void RegisterSubmissionForLegacyThread(int submissionId)
         {
             lock (_legacyThreadingEventsLock)
@@ -104,6 +106,10 @@ internal void UnregisterSubmissionForLegacyThread(int submissionId)
             {
                 ErrorUtilities.VerifyThrow(_legacyThreadingEventsById.ContainsKey(submissionId), "Submission {0} should have been previously registered with LegacyThreadingData", submissionId);
 
+                // Dispose the events
+                _legacyThreadingEventsById[submissionId].Item1?.Dispose();
+                _legacyThreadingEventsById[submissionId].Item2?.Dispose();
+
                 _legacyThreadingEventsById.Remove(submissionId);
             }
         }
diff --git a/src/Build/BackEnd/BuildManager/RequestedProjectState.cs b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
index d195131a51c..fa324777269 100644
--- a/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
+++ b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using Microsoft.Build.BackEnd;
 
 #nullable disable
@@ -35,6 +36,94 @@ public IDictionary<string, List<string>> ItemFilters
             set => _itemFilters = value;
         }
 
+        /// <summary>
+        /// Creates a deep copy of this instance.
+        /// </summary>
+        internal RequestedProjectState DeepClone()
+        {
+            RequestedProjectState result = new RequestedProjectState();
+            if (PropertyFilters is not null)
+            {
+                result.PropertyFilters = new List<string>(PropertyFilters);
+            }
+            if (ItemFilters is not null)
+            {
+                result.ItemFilters = ItemFilters.ToDictionary(
+                    kvp => kvp.Key,
+                    kvp => kvp.Value == null ? null : new List<string>(kvp.Value));
+            }
+            return result;
+        }
+
+        /// <summary>
+        /// Returns true if this instance contains all property and item filters present in another instance.
+        /// </summary>
+        /// <param name="another">The instance to compare against.</param>
+        /// <returns>True if this instance is equivalent or a strict subset of <paramref name="another"/>.</returns>
+        internal bool IsSubsetOf(RequestedProjectState another)
+        {
+            if (PropertyFilters is null)
+            {
+                if (another.PropertyFilters is not null)
+                {
+                    // The instance to compare against has filtered props and we need everything -> not a subset.
+                    return false;
+                }
+            }
+            else if (another.PropertyFilters is not null)
+            {
+                HashSet<string> anotherPropertyFilters = new HashSet<string>(another.PropertyFilters);
+                foreach (string propertyFilter in PropertyFilters)
+                {
+                    if (!anotherPropertyFilters.Contains(propertyFilter))
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            if (ItemFilters is null)
+            {
+                if (another.ItemFilters is not null)
+                {
+                    // The instance to compare against has filtered items and we need everything -> not a subset.
+                    return false;
+                }
+            }
+            else if (another.ItemFilters is not null)
+            {
+                foreach (KeyValuePair<string, List<string>> kvp in ItemFilters)
+                {
+                    if (!another.ItemFilters.TryGetValue(kvp.Key, out List<string> metadata))
+                    {
+                        // The instance to compare against doesn't have this item -> not a subset.
+                        return false;
+                    }
+                    if (kvp.Value is null)
+                    {
+                        if (metadata is not null)
+                        {
+                            // The instance to compare against has filtered metadata for this item and we need everything - not a subset.
+                            return false;
+                        }
+                    }
+                    else if (metadata is not null)
+                    {
+                        HashSet<string> anotherMetadata = new HashSet<string>(metadata);
+                        foreach (string metadatum in kvp.Value)
+                        {
+                            if (!anotherMetadata.Contains(metadatum))
+                            {
+                                return false;
+                            }
+                        }
+                    }
+                }
+            }
+
+            return true;
+        }
+
         void ITranslatable.Translate(ITranslator translator)
         {
             translator.Translate(ref _propertyFilters);
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index 70a4bf0aeef..abcb6c22fb0 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -4,6 +4,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Components.Caching;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Shared;
 
@@ -76,6 +77,8 @@ public void RegisterDefaultFactories()
             // NodeEndpoint,
             _componentEntriesByType[BuildComponentType.LoggingService] = new BuildComponentEntry(BuildComponentType.LoggingService, null);
             _componentEntriesByType[BuildComponentType.RequestBuilder] = new BuildComponentEntry(BuildComponentType.RequestBuilder, RequestBuilder.CreateComponent, CreationPattern.CreateAlways);
+            // This conditionally registers real or no-op implementation based on BuildParameters
+            _componentEntriesByType[BuildComponentType.BuildCheckManagerProvider] = new BuildComponentEntry(BuildComponentType.BuildCheckManagerProvider, BuildCheckManagerProvider.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.TargetBuilder] = new BuildComponentEntry(BuildComponentType.TargetBuilder, TargetBuilder.CreateComponent, CreationPattern.CreateAlways);
             _componentEntriesByType[BuildComponentType.TaskBuilder] = new BuildComponentEntry(BuildComponentType.TaskBuilder, TaskBuilder.CreateComponent, CreationPattern.CreateAlways);
             _componentEntriesByType[BuildComponentType.RegisteredTaskObjectCache] = new BuildComponentEntry(BuildComponentType.RegisteredTaskObjectCache, RegisteredTaskObjectCache.CreateComponent, CreationPattern.Singleton);
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 297ac265e0e..7e72bd3a159 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -10,6 +10,7 @@
 using System.Threading;
 using System.Threading.Tasks.Dataflow;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -281,6 +282,9 @@ public void CleanupForBuild()
                         TraceEngine("CFB: Rethrowing shutdown exceptions");
                         throw new AggregateException(deactivateExceptions);
                     }
+
+                    var buildCheckManager = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance;
+                    buildCheckManager.FinalizeProcessing(_nodeLoggingContext);
                 },
                 isLastTask: true);
 
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 0823f86cffe..34480ff2142 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -18,6 +18,14 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal class ResultsCache : IResultsCache
     {
+        /// <summary>
+        /// The presence of any of these flags affects build result for the specified request. Not included are ProvideProjectStateAfterBuild
+        /// and ProvideSubsetOfStateAfterBuild which require additional checks.
+        /// </summary>
+        private const BuildRequestDataFlags FlagsAffectingBuildResults =
+            BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports
+            | BuildRequestDataFlags.FailOnUnresolvedSdk;
+
         /// <summary>
         /// The table of all build results.  This table is indexed by configuration id and
         /// contains BuildResult objects which have all of the target information.
@@ -140,10 +148,11 @@ public BuildResult GetResultsForConfiguration(int configurationId)
 
         /// <summary>
         /// Attempts to satisfy the request from the cache.  The request can be satisfied only if:
-        /// 1. All specified targets in the request have successful results in the cache or if the sequence of target results
+        /// 1. The passed BuildRequestDataFlags and RequestedProjectStateFilter are compatible with the result data.
+        /// 2. All specified targets in the request have successful results in the cache or if the sequence of target results
         ///    includes 0 or more successful targets followed by at least one failed target.
-        /// 2. All initial targets in the configuration for the request have non-skipped results in the cache.
-        /// 3. If there are no specified targets, then all default targets in the request must have non-skipped results
+        /// 3. All initial targets in the configuration for the request have non-skipped results in the cache.
+        /// 4. If there are no specified targets, then all default targets in the request must have non-skipped results
         ///    in the cache.
         /// </summary>
         /// <param name="request">The request whose results we should return.</param>
@@ -163,47 +172,53 @@ public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> co
             {
                 if (_resultsByConfiguration.TryGetValue(request.ConfigurationId, out BuildResult allResults))
                 {
-                    // Check for targets explicitly specified.
-                    bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, response.ExplicitTargetsToBuild, skippedResultsDoNotCauseCacheMiss);
+                    bool buildDataFlagsSatisfied = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
+                        ? AreBuildResultFlagsCompatible(request, allResults) : true;
 
-                    if (explicitTargetsSatisfied)
+                    if (buildDataFlagsSatisfied)
                     {
-                        // All of the explicit targets, if any, have been satisfied
-                        response.Type = ResultsCacheResponseType.Satisfied;
+                        // Check for targets explicitly specified.
+                        bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, response.ExplicitTargetsToBuild, skippedResultsDoNotCauseCacheMiss);
 
-                        // Check for the initial targets.  If we don't know what the initial targets are, we assume they are not satisfied.
-                        if (configInitialTargets == null || !CheckResults(allResults, configInitialTargets, null, skippedResultsDoNotCauseCacheMiss))
+                        if (explicitTargetsSatisfied)
                         {
-                            response.Type = ResultsCacheResponseType.NotSatisfied;
-                        }
+                            // All of the explicit targets, if any, have been satisfied
+                            response.Type = ResultsCacheResponseType.Satisfied;
 
-                        // We could still be missing implicit targets, so check those...
-                        if (request.Targets.Count == 0)
-                        {
-                            // Check for the default target, if necessary.  If we don't know what the default targets are, we
-                            // assume they are not satisfied.
-                            if (configDefaultTargets == null || !CheckResults(allResults, configDefaultTargets, null, skippedResultsDoNotCauseCacheMiss))
+                            // Check for the initial targets.  If we don't know what the initial targets are, we assume they are not satisfied.
+                            if (configInitialTargets == null || !CheckResults(allResults, configInitialTargets, null, skippedResultsDoNotCauseCacheMiss))
                             {
                                 response.Type = ResultsCacheResponseType.NotSatisfied;
                             }
-                        }
-
-                        // Now report those results requested, if they are satisfied.
-                        if (response.Type == ResultsCacheResponseType.Satisfied)
-                        {
-                            List<string> targetsToAddResultsFor = new List<string>(configInitialTargets);
 
-                            // Now report either the explicit targets or the default targets
-                            if (request.Targets.Count > 0)
+                            // We could still be missing implicit targets, so check those...
+                            if (request.Targets.Count == 0)
                             {
-                                targetsToAddResultsFor.AddRange(request.Targets);
+                                // Check for the default target, if necessary.  If we don't know what the default targets are, we
+                                // assume they are not satisfied.
+                                if (configDefaultTargets == null || !CheckResults(allResults, configDefaultTargets, null, skippedResultsDoNotCauseCacheMiss))
+                                {
+                                    response.Type = ResultsCacheResponseType.NotSatisfied;
+                                }
                             }
-                            else
+
+                            // Now report those results requested, if they are satisfied.
+                            if (response.Type == ResultsCacheResponseType.Satisfied)
                             {
-                                targetsToAddResultsFor.AddRange(configDefaultTargets);
+                                List<string> targetsToAddResultsFor = new List<string>(configInitialTargets);
+
+                                // Now report either the explicit targets or the default targets
+                                if (request.Targets.Count > 0)
+                                {
+                                    targetsToAddResultsFor.AddRange(request.Targets);
+                                }
+                                else
+                                {
+                                    targetsToAddResultsFor.AddRange(configDefaultTargets);
+                                }
+
+                                response.Results = new BuildResult(request, allResults, targetsToAddResultsFor.ToArray(), null);
                             }
-
-                            response.Results = new BuildResult(request, allResults, targetsToAddResultsFor.ToArray(), null);
                         }
                     }
                 }
@@ -328,6 +343,56 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS
             return returnValue;
         }
 
+        /// <summary>
+        /// Returns true if the flags and project state filter of the given build request are compatible with the given build result.
+        /// </summary>
+        /// <param name="buildRequest">The current build request.</param>
+        /// <param name="buildResult">The candidate build result.</param>
+        /// <returns>True if the flags and project state filter of the build request is compatible with the build result.</returns>
+        private static bool AreBuildResultFlagsCompatible(BuildRequest buildRequest, BuildResult buildResult)
+        {
+            BuildRequestDataFlags buildRequestDataFlags = buildRequest.BuildRequestDataFlags;
+            BuildRequestDataFlags buildResultDataFlags = buildResult.BuildRequestDataFlags;
+
+            if ((buildRequestDataFlags & FlagsAffectingBuildResults) != (buildResultDataFlags & FlagsAffectingBuildResults))
+            {
+                // Mismatch in flags that can affect build results -> not compatible.
+                return false;
+            }
+
+            if (HasProvideProjectStateAfterBuild(buildRequestDataFlags))
+            {
+                // If full state is requested, we must have full state in the result.
+                return HasProvideProjectStateAfterBuild(buildResultDataFlags);
+            }
+
+            if (HasProvideSubsetOfStateAfterBuild(buildRequestDataFlags))
+            {
+                // If partial state is requested, we must have full or partial-and-compatible state in the result.
+                if (HasProvideProjectStateAfterBuild(buildResultDataFlags))
+                {
+                    return true;
+                }
+                if (!HasProvideSubsetOfStateAfterBuild(buildResultDataFlags))
+                {
+                    return false;
+                }
+
+                // Verify that the requested subset is compatible with the result.
+                return buildRequest.RequestedProjectState is not null &&
+                    buildResult.ProjectStateAfterBuild?.RequestedProjectStateFilter is not null &&
+                    buildRequest.RequestedProjectState.IsSubsetOf(buildResult.ProjectStateAfterBuild.RequestedProjectStateFilter);
+            }
+
+            return true;
+
+            static bool HasProvideProjectStateAfterBuild(BuildRequestDataFlags flags)
+                => (flags & BuildRequestDataFlags.ProvideProjectStateAfterBuild) == BuildRequestDataFlags.ProvideProjectStateAfterBuild;
+
+            static bool HasProvideSubsetOfStateAfterBuild(BuildRequestDataFlags flags)
+                => (flags & BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild) == BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;
+        }
+
         public IEnumerator<BuildResult> GetEnumerator()
         {
             return _resultsByConfiguration.Values.GetEnumerator();
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index 5ae9d947906..8b2ded4d251 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -142,6 +142,11 @@ internal enum BuildComponentType
         /// The component which launches new MSBuild nodes.
         /// </summary>
         NodeLauncher,
+
+        /// <summary>
+        /// The Build Analyzer Manager.
+        /// </summary>
+        BuildCheckManagerProvider,
     }
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
index 31223745d8b..d9cb65d4b93 100644
--- a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
@@ -12,14 +12,14 @@
 namespace Microsoft.Build.BackEnd.Components.Logging
 {
     /// <summary>
-    ///     Logging context and helpers for evaluation logging
+    ///     Logging context and helpers for evaluation logging.
     /// </summary>
     internal class EvaluationLoggingContext : LoggingContext
     {
         private readonly string _projectFile;
 
-        public EvaluationLoggingContext(ILoggingService loggingService, BuildEventContext buildEventContext, string projectFile) :
-            base(
+        public EvaluationLoggingContext(ILoggingService loggingService, BuildEventContext buildEventContext, string projectFile)
+            : base(
                 loggingService,
                 loggingService.CreateEvaluationBuildEventContext(buildEventContext.NodeId, buildEventContext.SubmissionId))
         {
@@ -33,8 +33,12 @@ public void LogProjectEvaluationStarted()
         }
 
         /// <summary>
-        /// Log that the project has finished
+        /// Logs that the project evaluation has finished.
         /// </summary>
+        /// <param name="globalProperties">Global properties used in the project evaluation.</param>
+        /// <param name="properties">Properties used in the project evaluation.</param>
+        /// <param name="items">Items used in the project evaluation.</param>
+        /// <param name="profilerResult">Parameter contains the profiler result of the project evaluation.</param>
         internal void LogProjectEvaluationFinished(IEnumerable globalProperties, IEnumerable properties, IEnumerable items, ProfilerResult? profilerResult)
         {
             ErrorUtilities.VerifyThrow(IsValid, "invalid");
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 340dfafc495..308e26cae4d 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -98,6 +100,11 @@ internal sealed class EventSourceSink :
         /// This event is raised to log telemetry.
         /// </summary>
         public event TelemetryEventHandler TelemetryLogged;
+
+        /// <summary>
+        /// This event is raised to log BuildCheck events.
+        /// </summary>
+        internal event BuildCheckEventHandler BuildCheckEventRaised;
         #endregion
 
         #region Properties
@@ -263,6 +270,10 @@ public void Consume(BuildEventArgs buildEvent)
                 case TelemetryEventArgs telemetryEvent:
                     RaiseTelemetryEvent(null, telemetryEvent);
                     break;
+                case BuildCheckEventArgs buildCheckEvent:
+                    RaiseBuildCheckEvent(null, buildCheckEvent);
+                    break;
+
                 default:
                     ErrorUtilities.ThrowInternalError("Unknown event args type.");
                     break;
@@ -300,6 +311,7 @@ internal void UnregisterAllEventHandlers()
             StatusEventRaised = null;
             AnyEventRaised = null;
             TelemetryLogged = null;
+            BuildCheckEventRaised = null;
         }
 
         #endregion
@@ -848,6 +860,40 @@ private void RaiseStatusEvent(object sender, BuildStatusEventArgs buildEvent)
             RaiseAnyEvent(sender, buildEvent);
         }
 
+        private void RaiseBuildCheckEvent(object sender, BuildCheckEventArgs buildEvent)
+        {
+            if (BuildCheckEventRaised != null)
+            {
+                try
+                {
+                    BuildCheckEventRaised(sender, buildEvent);
+                }
+                catch (LoggerException)
+                {
+                    // if a logger has failed politely, abort immediately
+                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
+                    // if a fellow logger is throwing in an event handler.
+                    this.UnregisterAllEventHandlers();
+                    throw;
+                }
+                catch (Exception exception)
+                {
+                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
+                    // if a fellow logger is throwing in an event handler.
+                    this.UnregisterAllEventHandlers();
+
+                    if (ExceptionHandling.IsCriticalException(exception))
+                    {
+                        throw;
+                    }
+
+                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
+                }
+            }
+
+            RaiseAnyEvent(sender, buildEvent);
+        }
+
         /// <summary>
         /// Raises a catch-all build event to all registered loggers.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 6d4973bc223..3e44402a61e 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -570,7 +570,8 @@ BuildEventContext LogProjectStarted(
         /// <param name="taskName">The name of the task</param>
         /// <param name="projectFile">The project file which is being built</param>
         /// <param name="projectFileOfTaskNode">The file in which the task is defined - typically a .targets file</param>
-        void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
+        /// <param name="taskAssemblyLocation">>The location of the assembly containing the implementation of the task.</param>
+        void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, string taskAssemblyLocation);
 
         /// <summary>
         /// Log that a task is about to start
@@ -581,8 +582,9 @@ BuildEventContext LogProjectStarted(
         /// <param name="projectFileOfTaskNode">The file in which the task is defined - typically a .targets file</param>
         /// <param name="line">The line number in the file where the task invocation is located.</param>
         /// <param name="column">The column number in the file where the task invocation is located.</param>
+        /// <param name="taskAssemblyLocation">>The location of the assembly containing the implementation of the task.</param>
         /// <returns>The task build event context</returns>
-        BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column);
+        BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column, string taskAssemblyLocation);
 
         /// <summary>
         /// Log that a task has just completed
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 9ef9a58f17b..547554d06d8 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -688,8 +688,9 @@ public void LogTargetFinished(BuildEventContext targetBuildEventContext, string
         /// <param name="taskName">Task Name</param>
         /// <param name="projectFile">Project file being built</param>
         /// <param name="projectFileOfTaskNode">Project file which contains the task</param>
+        /// <param name="taskAssemblyLocation">>The location of the assembly containing the implementation of the task.</param>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
-        public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode)
+        public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, string taskAssemblyLocation)
         {
             ErrorUtilities.VerifyThrow(taskBuildEventContext != null, "targetBuildEventContext is null");
             if (!OnlyLogCriticalEvents)
@@ -699,7 +700,8 @@ public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskN
                         helpKeyword: null,
                         projectFile,
                         projectFileOfTaskNode,
-                        taskName);
+                        taskName,
+                        taskAssemblyLocation);
                 buildEvent.BuildEventContext = taskBuildEventContext;
                 ProcessLoggingEvent(buildEvent);
             }
@@ -714,9 +716,10 @@ public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskN
         /// <param name="projectFileOfTaskNode">Project file which contains the task</param>
         /// <param name="line">The line number in the file where the task invocation is located.</param>
         /// <param name="column">The column number in the file where the task invocation is located.</param>
+        /// <param name="taskAssemblyLocation">>The location of the assembly containing the implementation of the task.</param>
         /// <returns>The build event context for the task.</returns>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
-        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column)
+        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column, string taskAssemblyLocation)
         {
             ErrorUtilities.VerifyThrow(targetBuildEventContext != null, "targetBuildEventContext is null");
             BuildEventContext taskBuildEventContext = new BuildEventContext(
@@ -734,7 +737,8 @@ public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventConte
                         helpKeyword: null,
                         projectFile,
                         projectFileOfTaskNode,
-                        taskName);
+                        taskName,
+                        taskAssemblyLocation);
                 buildEvent.BuildEventContext = taskBuildEventContext;
                 buildEvent.LineNumber = line;
                 buildEvent.ColumnNumber = column;
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index 3d9a25df6cc..af37bd0f690 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -108,11 +108,11 @@ internal void LogTargetBatchFinished(string projectFullPath, bool success, IEnum
         /// <summary>
         /// Log that a task is about to start
         /// </summary>
-        internal TaskLoggingContext LogTaskBatchStarted(string projectFullPath, ProjectTargetInstanceChild task)
+        internal TaskLoggingContext LogTaskBatchStarted(string projectFullPath, ProjectTargetInstanceChild task, string taskAssemblyLocation)
         {
             ErrorUtilities.VerifyThrow(IsValid, "Should be valid");
 
-            return new TaskLoggingContext(this, projectFullPath, task);
+            return new TaskLoggingContext(this, projectFullPath, task, taskAssemblyLocation);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
index 2728ed5592e..f962f3da74d 100644
--- a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
@@ -34,7 +34,7 @@ internal class TaskLoggingContext : BuildLoggingContext
         /// <summary>
         /// Constructs a task logging context from a parent target context and a task node.
         /// </summary>
-        internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string projectFullPath, ProjectTargetInstanceChild task)
+        internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string projectFullPath, ProjectTargetInstanceChild task, string taskAssemblyLocation)
             : base(targetLoggingContext)
         {
             _targetLoggingContext = targetLoggingContext;
@@ -72,7 +72,8 @@ internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string pr
                 projectFullPath,
                 task.Location.File,
                 task.Location.Line,
-                task.Location.Column);
+                task.Location.Column,
+                taskAssemblyLocation);
             this.IsValid = true;
         }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 0214e3f4150..1a4693ba685 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -10,11 +10,13 @@
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -1102,6 +1104,11 @@ private async Task<BuildResult> BuildProject()
         {
             ErrorUtilities.VerifyThrow(_targetBuilder != null, "Target builder is null");
 
+            // We consider this the entrypoint for the project build for purposes of BuildCheck processing 
+
+            var buildCheckManager = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance;
+            buildCheckManager.SetDataSource(BuildCheckDataSource.BuildExecution);
+
             // Make sure it is null before loading the configuration into the request, because if there is a problem
             // we do not wand to have an invalid projectLoggingContext floating around. Also if this is null the error will be
             // logged with the node logging context
@@ -1114,6 +1121,11 @@ private async Task<BuildResult> BuildProject()
                 // Load the project
                 if (!_requestEntry.RequestConfiguration.IsLoaded)
                 {
+                    buildCheckManager.StartProjectEvaluation(
+                        BuildCheckDataSource.BuildExecution,
+                        _requestEntry.Request.ParentBuildEventContext,
+                        _requestEntry.RequestConfiguration.ProjectFullPath);
+
                     _requestEntry.RequestConfiguration.LoadProjectIntoConfiguration(
                         _componentHost,
                         RequestEntry.Request.BuildRequestDataFlags,
@@ -1132,62 +1144,90 @@ private async Task<BuildResult> BuildProject()
 
                 throw;
             }
+            finally
+            {
+                buildCheckManager.EndProjectEvaluation(
+                    BuildCheckDataSource.BuildExecution,
+                    _requestEntry.Request.ParentBuildEventContext);
+            }
 
             _projectLoggingContext = _nodeLoggingContext.LogProjectStarted(_requestEntry);
+            buildCheckManager.StartProjectRequest(
+                BuildCheckDataSource.BuildExecution,
+                _requestEntry.Request.ParentBuildEventContext);
 
-            // Now that the project has started, parse a few known properties which indicate warning codes to treat as errors or messages
-            //
-            ConfigureWarningsAsErrorsAndMessages();
+            try
+            {
+                // Now that the project has started, parse a few known properties which indicate warning codes to treat as errors or messages
+                ConfigureWarningsAsErrorsAndMessages();
 
-            // Make sure to extract known immutable folders from properties and register them for fast up-to-date check
-            ConfigureKnownImmutableFolders();
+                // Make sure to extract known immutable folders from properties and register them for fast up-to-date check
+                ConfigureKnownImmutableFolders();
 
-            // See comment on Microsoft.Build.Internal.Utilities.GenerateToolsVersionToUse
-            _requestEntry.RequestConfiguration.RetrieveFromCache();
-            if (_requestEntry.RequestConfiguration.Project.UsingDifferentToolsVersionFromProjectFile)
-            {
-                _projectLoggingContext.LogComment(MessageImportance.Low, "UsingDifferentToolsVersionFromProjectFile", _requestEntry.RequestConfiguration.Project.OriginalProjectToolsVersion, _requestEntry.RequestConfiguration.Project.ToolsVersion);
-            }
+                // See comment on Microsoft.Build.Internal.Utilities.GenerateToolsVersionToUse
+                _requestEntry.RequestConfiguration.RetrieveFromCache();
+                if (_requestEntry.RequestConfiguration.Project.UsingDifferentToolsVersionFromProjectFile)
+                {
+                    _projectLoggingContext.LogComment(MessageImportance.Low,
+                        "UsingDifferentToolsVersionFromProjectFile",
+                        _requestEntry.RequestConfiguration.Project.OriginalProjectToolsVersion,
+                        _requestEntry.RequestConfiguration.Project.ToolsVersion);
+                }
 
-            _requestEntry.Request.BuildEventContext = _projectLoggingContext.BuildEventContext;
+                _requestEntry.Request.BuildEventContext = _projectLoggingContext.BuildEventContext;
 
-            // Determine the set of targets we need to build
-            string[] allTargets = _requestEntry.RequestConfiguration.GetTargetsUsedToBuildRequest(_requestEntry.Request).ToArray();
+                // Determine the set of targets we need to build
+                string[] allTargets = _requestEntry.RequestConfiguration
+                    .GetTargetsUsedToBuildRequest(_requestEntry.Request).ToArray();
 
-            ProjectErrorUtilities.VerifyThrowInvalidProject(allTargets.Length > 0, _requestEntry.RequestConfiguration.Project.ProjectFileLocation, "NoTargetSpecified");
+                ProjectErrorUtilities.VerifyThrowInvalidProject(allTargets.Length > 0,
+                    _requestEntry.RequestConfiguration.Project.ProjectFileLocation, "NoTargetSpecified");
 
-            // Set the current directory to that required by the project.
-            SetProjectCurrentDirectory();
+                // Set the current directory to that required by the project.
+                SetProjectCurrentDirectory();
 
-            // Transfer results and state from the previous node, if necessary.
-            // In order for the check for target completeness for this project to be valid, all of the target results from the project must be present
-            // in the results cache.  It is possible that this project has been moved from its original node and when it was its results did not come
-            // with it.  This would be signified by the ResultsNode value in the configuration pointing to a different node than the current one.  In that
-            // case we will need to request those results be moved from their original node to this one.
-            if ((_requestEntry.RequestConfiguration.ResultsNodeId != Scheduler.InvalidNodeId) &&
-                (_requestEntry.RequestConfiguration.ResultsNodeId != _componentHost.BuildParameters.NodeId))
-            {
-                // This indicates to the system that we will block waiting for a results transfer.  We will block here until those results become available.
-                await BlockOnTargetInProgress(Microsoft.Build.BackEnd.BuildRequest.InvalidGlobalRequestId, null);
+                // Transfer results and state from the previous node, if necessary.
+                // In order for the check for target completeness for this project to be valid, all of the target results from the project must be present
+                // in the results cache.  It is possible that this project has been moved from its original node and when it was its results did not come
+                // with it.  This would be signified by the ResultsNode value in the configuration pointing to a different node than the current one.  In that
+                // case we will need to request those results be moved from their original node to this one.
+                if ((_requestEntry.RequestConfiguration.ResultsNodeId != Scheduler.InvalidNodeId) &&
+                    (_requestEntry.RequestConfiguration.ResultsNodeId != _componentHost.BuildParameters.NodeId))
+                {
+                    // This indicates to the system that we will block waiting for a results transfer.  We will block here until those results become available.
+                    await BlockOnTargetInProgress(Microsoft.Build.BackEnd.BuildRequest.InvalidGlobalRequestId, null);
+
+                    // All of the results should now be on this node.
+                    ErrorUtilities.VerifyThrow(
+                        _requestEntry.RequestConfiguration.ResultsNodeId == _componentHost.BuildParameters.NodeId,
+                        "Results for configuration {0} were not retrieved from node {1}",
+                        _requestEntry.RequestConfiguration.ConfigurationId,
+                        _requestEntry.RequestConfiguration.ResultsNodeId);
+                }
 
-                // All of the results should now be on this node.
-                ErrorUtilities.VerifyThrow(_requestEntry.RequestConfiguration.ResultsNodeId == _componentHost.BuildParameters.NodeId, "Results for configuration {0} were not retrieved from node {1}", _requestEntry.RequestConfiguration.ConfigurationId, _requestEntry.RequestConfiguration.ResultsNodeId);
-            }
+                // Build the targets
+                BuildResult result = await _targetBuilder.BuildTargets(_projectLoggingContext, _requestEntry, this,
+                    allTargets, _requestEntry.RequestConfiguration.BaseLookup, _cancellationTokenSource.Token);
 
-            // Build the targets
-            BuildResult result = await _targetBuilder.BuildTargets(_projectLoggingContext, _requestEntry, this, allTargets, _requestEntry.RequestConfiguration.BaseLookup, _cancellationTokenSource.Token);
+                result = _requestEntry.Request.ProxyTargets == null
+                    ? result
+                    : CopyTargetResultsFromProxyTargetsToRealTargets(result);
 
-            result = _requestEntry.Request.ProxyTargets == null
-                ? result
-                : CopyTargetResultsFromProxyTargetsToRealTargets(result);
+                if (MSBuildEventSource.Log.IsEnabled())
+                {
+                    MSBuildEventSource.Log.BuildProjectStop(_requestEntry.RequestConfiguration.ProjectFullPath,
+                        string.Join(", ", allTargets));
+                }
 
-            if (MSBuildEventSource.Log.IsEnabled())
+                return result;
+            }
+            finally
             {
-                MSBuildEventSource.Log.BuildProjectStop(_requestEntry.RequestConfiguration.ProjectFullPath, string.Join(", ", allTargets));
+                buildCheckManager.EndProjectRequest(
+                    BuildCheckDataSource.BuildExecution,
+                    _requestEntry.Request.ParentBuildEventContext);
             }
 
-            return result;
-
             BuildResult CopyTargetResultsFromProxyTargetsToRealTargets(BuildResult resultFromTargetBuilder)
             {
                 var proxyTargetMapping = _requestEntry.Request.ProxyTargets.ProxyTargetToRealTargetMap;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index b4d621fce8d..485ee854f73 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -115,7 +115,7 @@ internal class TaskBuilder : ITaskBuilder, IBuildComponent
         /// <summary>
         /// The task execution host for in-proc tasks.
         /// </summary>
-        private ITaskExecutionHost _taskExecutionHost;
+        private TaskExecutionHost _taskExecutionHost;
 
         /// <summary>
         /// The object used to synchronize access to the task execution host.
@@ -423,10 +423,12 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 {
                     // We need to find the task before logging the task started event so that the using task statement comes before the task started event
                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);
-                    TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);
+                    (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) = _taskExecutionHost.FindTask(taskIdentityParameters);
+                    string taskAssemblyLocation = taskFactoryWrapper?.TaskFactoryLoadedType?.Path;
+
                     if (requirements != null)
                     {
-                        TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
+                        TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance, taskAssemblyLocation);
                         MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
                         _buildRequestEntry.Request.CurrentTaskContext = taskLoggingContext.BuildEventContext;
 
@@ -652,7 +654,7 @@ private async Task<WorkUnitResult> InitializeAndExecuteTask(TaskLoggingContext t
                 ProjectErrorUtilities.ThrowInvalidProject(_targetChildInstance.Location, "TaskDeclarationOrUsageError", _taskNode.Name);
             }
 
-            using var assemblyLoadsTracker = AssemblyLoadsTracker.StartTracking(taskLoggingContext, AssemblyLoadingContext.TaskRun, (_taskExecutionHost as TaskExecutionHost)?.TaskInstance?.GetType());
+            using var assemblyLoadsTracker = AssemblyLoadsTracker.StartTracking(taskLoggingContext, AssemblyLoadingContext.TaskRun, _taskExecutionHost?.TaskInstance?.GetType());
 
             try
             {
@@ -734,7 +736,7 @@ private void UpdateContinueOnError(ItemBucket bucket, TaskHost taskHost)
         /// <param name="bucket">The batching bucket</param>
         /// <param name="howToExecuteTask">The task execution mode</param>
         /// <returns>The result of running the task.</returns>
-        private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask)
+        private async Task<WorkUnitResult> ExecuteInstantiatedTask(TaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask)
         {
             UpdateContinueOnError(bucket, taskHost);
 
@@ -754,20 +756,13 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                 Exception taskException = null;
 
                 // If this is the MSBuild task, we need to execute it's special internal method.
-                TaskExecutionHost host = taskExecutionHost as TaskExecutionHost;
-                Type taskType = host.TaskInstance.GetType();
-
                 try
                 {
-                    if (taskType == typeof(MSBuild))
+                    if (taskExecutionHost.TaskInstance is MSBuild msbuildTask)
                     {
-                        MSBuild msbuildTask = host.TaskInstance as MSBuild;
-
-                        ErrorUtilities.VerifyThrow(msbuildTask != null, "Unexpected MSBuild internal task.");
-
                         var undeclaredProjects = GetUndeclaredProjects(msbuildTask);
 
-                        if (undeclaredProjects != null && undeclaredProjects.Count != 0)
+                        if (undeclaredProjects?.Count > 0)
                         {
                             _continueOnError = ContinueOnError.ErrorAndStop;
 
@@ -799,9 +794,8 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                             }
                         }
                     }
-                    else if (taskType == typeof(CallTarget))
+                    else if (taskExecutionHost.TaskInstance is CallTarget callTargetTask)
                     {
-                        CallTarget callTargetTask = host.TaskInstance as CallTarget;
                         taskResult = await callTargetTask.ExecuteInternal();
                     }
                     else
@@ -951,7 +945,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                 // When a task fails it must log an error. If a task fails to do so,
                 // that is logged as an error. MSBuild tasks are an exception because
                 // errors are not logged directly from them, but the tasks spawned by them.
-                IBuildEngine be = host.TaskInstance.BuildEngine;
+                IBuildEngine be = taskExecutionHost.TaskInstance.BuildEngine;
                 if (taskReturned // if the task returned
                     && !taskResult // and it returned false
                     && !taskLoggingContext.HasLoggedErrors // and it didn't log any errors
@@ -1072,7 +1066,7 @@ private List<string> GetUndeclaredProjects(MSBuild msbuildTask)
         /// <param name="howToExecuteTask">The task execution mode</param>
         /// <param name="bucket">The bucket to which the task execution belongs.</param>
         /// <returns>true, if successful</returns>
-        private bool GatherTaskOutputs(ITaskExecutionHost taskExecutionHost, TaskExecutionMode howToExecuteTask, ItemBucket bucket)
+        private bool GatherTaskOutputs(TaskExecutionHost taskExecutionHost, TaskExecutionMode howToExecuteTask, ItemBucket bucket)
         {
             bool gatheredTaskOutputsSuccessfully = true;
 
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index 6b2715903e7..4f9e62b9343 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -4,6 +4,9 @@
 using System;
 using System.Collections.Concurrent;
 using System.IO;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd;
@@ -430,28 +433,115 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)
             _shutdownReason = _cancelRequested ? NodeEngineShutdownReason.BuildComplete : NodeEngineShutdownReason.BuildCompleteReuse;
             _shutdownEvent.Set();
         }
-        internal sealed class RedirectConsoleWriter : StringWriter
+
+        internal sealed class RedirectConsoleWriter : TextWriter
         {
             private readonly Action<string> _writeCallback;
             private readonly Timer _timer;
             private readonly TextWriter _syncWriter;
 
+            private readonly StringWriter _internalWriter;
+
             private RedirectConsoleWriter(Action<string> writeCallback)
             {
                 _writeCallback = writeCallback;
-                _syncWriter = Synchronized(this);
+                _internalWriter = new StringWriter();
+                _syncWriter = Synchronized(_internalWriter);
                 _timer = new Timer(TimerCallback, null, 0, 40);
             }
 
+            public override Encoding Encoding => _internalWriter.Encoding;
+
             public static TextWriter Create(Action<string> writeCallback)
             {
-                RedirectConsoleWriter writer = new(writeCallback);
-                return writer._syncWriter;
+                RedirectConsoleWriter writer = new RedirectConsoleWriter(writeCallback);
+
+                return writer;
             }
 
+            public override void Flush()
+            {
+                var sb = _internalWriter.GetStringBuilder();
+                string captured = sb.ToString();
+                sb.Clear();
+
+                _writeCallback(captured);
+                _internalWriter.Flush();
+            }
+
+            public override void Write(char value) => _syncWriter.Write(value);
+
+            public override void Write(char[]? buffer) => _syncWriter.Write(buffer);
+
+            public override void Write(char[] buffer, int index, int count) => _syncWriter.Write(buffer, index, count);
+
+            public override void Write(bool value) => _syncWriter.Write(value);
+
+            public override void Write(int value) => _syncWriter.Write(value);
+
+            public override void Write(uint value) => _syncWriter.Write(value);
+
+            public override void Write(long value) => _syncWriter.Write(value);
+
+            public override void Write(ulong value) => _syncWriter.Write(value);
+ 
+            public override void Write(float value) => _syncWriter.Write(value);
+
+            public override void Write(double value) => _syncWriter.Write(value);
+
+            public override void Write(decimal value) => _syncWriter.Write(value);
+
+            public override void Write(string? value) => _syncWriter.Write(value);
+
+            public override void Write(object? value) => _syncWriter.Write(value);
+
+            public override void Write(string format, object? arg0) => _syncWriter.Write(format, arg0);
+
+            public override void Write(string format, object? arg0, object? arg1) => _syncWriter.Write(format, arg0, arg1);
+
+            public override void Write(string format, object? arg0, object? arg1, object? arg2) => _syncWriter.Write(format, arg0, arg1, arg2);
+
+            public override void Write(string format, params object?[] arg) => _syncWriter.WriteLine(format, arg);
+
+            public override void WriteLine() => _syncWriter.WriteLine();
+
+            public override void WriteLine(char value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(decimal value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(char[]? buffer) => _syncWriter.WriteLine(buffer);
+
+            public override void WriteLine(char[] buffer, int index, int count) => _syncWriter.WriteLine(buffer, index, count);
+
+            public override void WriteLine(bool value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(int value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(uint value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(long value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(ulong value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(float value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(double value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(string? value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(object? value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(string format, object? arg0) => _syncWriter.WriteLine(format, arg0);
+
+            public override void WriteLine(string format, object? arg0, object? arg1) => _syncWriter.WriteLine(format, arg0, arg1);
+
+            public override void WriteLine(string format, object? arg0, object? arg1, object? arg2) => _syncWriter.WriteLine(format, arg0, arg1, arg2);
+
+            public override void WriteLine(string format, params object?[] arg) => _syncWriter.WriteLine(format, arg);
+
             private void TimerCallback(object? state)
             {
-                if (GetStringBuilder().Length > 0)
+                if (_internalWriter.GetStringBuilder().Length > 0)
                 {
                     _syncWriter.Flush();
                 }
@@ -463,20 +553,11 @@ protected override void Dispose(bool disposing)
                 {
                     _timer.Dispose();
                     Flush();
+                    _internalWriter?.Dispose();
                 }
 
                 base.Dispose(disposing);
             }
-
-            public override void Flush()
-            {
-                var sb = GetStringBuilder();
-                var captured = sb.ToString();
-                sb.Clear();
-                _writeCallback(captured);
-
-                base.Flush();
-            }
         }
     }
 }
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index 428eea19656..8951500b8d6 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -119,6 +119,11 @@ private BuildRequest(
             _nodeRequestId = nodeRequestId;
             _buildRequestDataFlags = buildRequestDataFlags;
             _requestedProjectState = requestedProjectState;
+
+            if (_requestedProjectState != null)
+            {
+                _buildRequestDataFlags |= BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;
+            }
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index eda42874f86..c5ef050807f 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -475,6 +475,7 @@ internal void LoadProjectIntoConfiguration(
                 {
                     projectLoadSettings |= ProjectLoadSettings.FailOnUnresolvedSdk;
                 }
+
                 return new ProjectInstance(
                     ProjectFullPath,
                     globalProperties,
@@ -698,9 +699,21 @@ public void CacheIfPossible()
                 {
                     if (IsCacheable)
                     {
-                        using ITranslator translator = GetConfigurationTranslator(TranslationDirection.WriteToStream);
+                        string cacheFile = GetCacheFile();
+                        try
+                        {
+                            Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));
+                            using Stream stream = File.Create(cacheFile);
+                            using ITranslator translator = GetConfigurationTranslator(TranslationDirection.WriteToStream, stream);
+
+                            _project.Cache(translator);
+                        }
+                        catch (Exception e) when (e is DirectoryNotFoundException or UnauthorizedAccessException)
+                        {
+                            ErrorUtilities.ThrowInvalidOperation("CacheFileInaccessible", cacheFile, e);
+                            throw;
+                        }
 
-                        _project.Cache(translator);
                         _baseLookup = null;
 
                         IsCached = true;
@@ -726,9 +739,19 @@ public void RetrieveFromCache()
                     return;
                 }
 
-                using ITranslator translator = GetConfigurationTranslator(TranslationDirection.ReadFromStream);
+                string cacheFile = GetCacheFile();
+                try
+                {
+                    using Stream stream = File.OpenRead(cacheFile);
+                    using ITranslator translator = GetConfigurationTranslator(TranslationDirection.ReadFromStream, stream);
 
-                _project.RetrieveFromCache(translator);
+                    _project.RetrieveFromCache(translator);
+                }
+                catch (Exception e) when (e is DirectoryNotFoundException or UnauthorizedAccessException)
+                {
+                    ErrorUtilities.ThrowInvalidOperation("CacheFileInaccessible", cacheFile, e);
+                    throw;
+                }
 
                 IsCached = false;
             }
@@ -939,6 +962,7 @@ internal void ApplyTransferredState(ProjectInstance instance)
         internal string GetCacheFile()
         {
             string filename = Path.Combine(FileUtilities.GetCacheDirectory(), String.Format(CultureInfo.InvariantCulture, "Configuration{0}.cache", _configId));
+
             return filename;
         }
 
@@ -1024,27 +1048,10 @@ private static string ResolveToolsVersion(BuildRequestData data, string defaultT
         /// <summary>
         /// Gets the translator for this configuration.
         /// </summary>
-        private ITranslator GetConfigurationTranslator(TranslationDirection direction)
-        {
-            string cacheFile = GetCacheFile();
-            try
-            {
-                if (direction == TranslationDirection.WriteToStream)
-                {
-                    Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));
-                    return BinaryTranslator.GetWriteTranslator(File.Create(cacheFile));
-                }
-                else
-                {
+        private ITranslator GetConfigurationTranslator(TranslationDirection direction, Stream stream) =>
+            direction == TranslationDirection.WriteToStream
+                    ? BinaryTranslator.GetWriteTranslator(stream)
                     // Not using sharedReadBuffer because this is not a memory stream and so the buffer won't be used anyway.
-                    return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), InterningBinaryReader.PoolingBuffer);
-                }
-            }
-            catch (Exception e) when (e is DirectoryNotFoundException || e is UnauthorizedAccessException)
-            {
-                ErrorUtilities.ThrowInvalidOperation("CacheFileInaccessible", cacheFile, e);
-                throw;
-            }
-        }
+                    : BinaryTranslator.GetReadTranslator(stream, InterningBinaryReader.PoolingBuffer);
     }
 }
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 68aa197381f..208fa2e7b9a 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -116,6 +116,11 @@ public class BuildResult : INodePacket, IBuildResults
         /// </summary>
         private ProjectInstance _projectStateAfterBuild;
 
+        /// <summary>
+        /// The flags provide additional control over the build results and may affect the cached value.
+        /// </summary>
+        private BuildRequestDataFlags _buildRequestDataFlags;
+
         private string _schedulerInducedError;
 
         private HashSet<string> _projectTargets;
@@ -172,6 +177,8 @@ internal BuildResult(BuildResult existingResults, string[] targetNames)
             _requestException = existingResults._requestException;
             _resultsByTarget = CreateTargetResultDictionaryWithContents(existingResults, targetNames);
             _baseOverallResult = existingResults.OverallResult == BuildResultCode.Success;
+            _buildRequestDataFlags = existingResults._buildRequestDataFlags;
+            _projectStateAfterBuild = existingResults._projectStateAfterBuild;
 
             _circularDependency = existingResults._circularDependency;
         }
@@ -204,6 +211,7 @@ internal BuildResult(BuildRequest request, BuildResult existingResults, string[]
             _nodeRequestId = request.NodeRequestId;
             _circularDependency = false;
             _baseOverallResult = true;
+            _buildRequestDataFlags = request.BuildRequestDataFlags;
 
             if (existingResults == null)
             {
@@ -214,6 +222,10 @@ internal BuildResult(BuildRequest request, BuildResult existingResults, string[]
             {
                 _requestException = exception ?? existingResults._requestException;
                 _resultsByTarget = targetNames == null ? existingResults._resultsByTarget : CreateTargetResultDictionaryWithContents(existingResults, targetNames);
+                if (request.RequestedProjectState != null)
+                {
+                    _projectStateAfterBuild = existingResults._projectStateAfterBuild?.FilteredCopy(request.RequestedProjectState);
+                }
             }
         }
 
@@ -380,6 +392,12 @@ public ProjectInstance ProjectStateAfterBuild
             set => _projectStateAfterBuild = value;
         }
 
+        /// <summary>
+        /// Gets the flags that were used in the build request to which these results are associated.
+        /// See <see cref="Execution.BuildRequestDataFlags"/> for examples of the available flags.
+        /// </summary>
+        public BuildRequestDataFlags BuildRequestDataFlags => _buildRequestDataFlags;
+
         /// <summary>
         /// Returns the node packet type.
         /// </summary>
@@ -581,6 +599,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _savedCurrentDirectory);
             translator.Translate(ref _schedulerInducedError);
             translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);
+            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index d435d1c3606..5418d5aee52 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -245,15 +245,23 @@ internal void CacheItems(int configId, string targetName)
                     return;
                 }
 
-                using ITranslator translator = GetResultsCacheTranslator(configId, targetName, TranslationDirection.WriteToStream);
+                string cacheFile = GetCacheFile(configId, targetName);
+                Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));
 
-                // If the translator is null, it means these results were cached once before.  Since target results are immutable once they
-                // have been created, there is no point in writing them again.
-                if (translator != null)
+                // If the file doesn't already exists, then we haven't cached this once before. We need to cache it again since it could have changed.
+                if (!FileSystems.Default.FileExists(cacheFile))
                 {
-                    TranslateItems(translator);
-                    _items = null;
-                    _cacheInfo = new CacheInfo(configId, targetName);
+                    using Stream stream = File.Create(cacheFile);
+                    using ITranslator translator = GetResultsCacheTranslator(TranslationDirection.WriteToStream, stream);
+
+                    // If the translator is null, it means these results were cached once before.  Since target results are immutable once they
+                    // have been created, there is no point in writing them again.
+                    if (translator != null)
+                    {
+                        TranslateItems(translator);
+                        _items = null;
+                        _cacheInfo = new CacheInfo(configId, targetName);
+                    }
                 }
             }
         }
@@ -279,7 +287,9 @@ private void RetrieveItemsFromCache()
             {
                 if (_items == null)
                 {
-                    using ITranslator translator = GetResultsCacheTranslator(_cacheInfo.ConfigId, _cacheInfo.TargetName, TranslationDirection.ReadFromStream);
+                    string cacheFile = GetCacheFile(_cacheInfo.ConfigId, _cacheInfo.TargetName);
+                    using Stream stream = File.OpenRead(cacheFile);
+                    using ITranslator translator = GetResultsCacheTranslator(TranslationDirection.ReadFromStream, stream);
 
                     TranslateItems(translator);
                     _cacheInfo = new CacheInfo();
@@ -339,25 +349,10 @@ private void TranslateItems(ITranslator translator)
         /// <summary>
         /// Gets the translator for this configuration.
         /// </summary>
-        private static ITranslator GetResultsCacheTranslator(int configId, string targetToCache, TranslationDirection direction)
-        {
-            string cacheFile = GetCacheFile(configId, targetToCache);
-            if (direction == TranslationDirection.WriteToStream)
-            {
-                Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));
-                if (FileSystems.Default.FileExists(cacheFile))
-                {
-                    // If the file already exists, then we have cached this once before.  No need to cache it again since it cannot have changed.
-                    return null;
-                }
-
-                return BinaryTranslator.GetWriteTranslator(File.Create(cacheFile));
-            }
-            else
-            {
-                return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), InterningBinaryReader.PoolingBuffer);
-            }
-        }
+        private static ITranslator GetResultsCacheTranslator(TranslationDirection direction, Stream stream) =>
+            direction == TranslationDirection.WriteToStream
+                    ? BinaryTranslator.GetWriteTranslator(stream)
+                    : BinaryTranslator.GetReadTranslator(stream, InterningBinaryReader.PoolingBuffer);
 
         /// <summary>
         /// Information about where the cache for the items in this result are stored.
diff --git a/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
deleted file mode 100644
index 60dfee13d2c..00000000000
--- a/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
+++ /dev/null
@@ -1,111 +0,0 @@
-ï»¿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Threading;
-using Microsoft.Build.Execution;
-using Microsoft.Build.Framework;
-using ElementLocation = Microsoft.Build.Construction.ElementLocation;
-using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
-using TaskLoggingContext = Microsoft.Build.BackEnd.Logging.TaskLoggingContext;
-
-#nullable disable
-
-namespace Microsoft.Build.BackEnd
-{
-    /// <summary>
-    /// Flags requrned by ITaskExecutionHost.FindTask().
-    /// </summary>
-    [Flags]
-    internal enum TaskRequirements
-    {
-        /// <summary>
-        /// The task was not found.
-        /// </summary>
-        None = 0,
-
-        /// <summary>
-        /// The task must be executed on an STA thread.
-        /// </summary>
-        RequireSTAThread = 0x01,
-
-        /// <summary>
-        /// The task must be executed in a separate AppDomain.
-        /// </summary>
-        RequireSeparateAppDomain = 0x02
-    }
-
-    /// <summary>
-    /// This interface represents the host for task execution.  When used in the in-proc scenario, these method calls essentially
-    /// are pass-throughs to just set some member variables and call methods directly on the task and associated objects.
-    /// In the out-of-proc/AppDomain-isolated case, the object implementing these methods may break apart the information
-    /// in the parameters to be consumed by the IContract representing the remote object through MAF.
-    ///
-    /// REFACTOR - Eliminate this interface.
-    /// </summary>
-    internal interface ITaskExecutionHost
-    {
-        /// <summary>
-        /// The associated project.
-        /// </summary>
-        ProjectInstance ProjectInstance
-        {
-            get;
-        }
-
-        /// <summary>
-        /// Flag to determine whether or not to log task inputs.
-        /// </summary>
-        bool LogTaskInputs { get; }
-
-        /// <summary>
-        /// Initialize the host with the objects required to communicate with the host process.
-        /// </summary>
-        void InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext loggingContext, ProjectInstance projectInstance, string taskName, ElementLocation taskLocation, ITaskHost taskHost, bool continueOnError,
-#if FEATURE_APPDOMAIN
-            AppDomainSetup appDomainSetup,
-#endif
-            bool isOutOfProc, CancellationToken cancellationToken);
-
-        /// <summary>
-        /// Ask the task host to find its task in the registry and get it ready for initializing the batch
-        /// </summary>
-        /// <returns>The task requirements if the task is found, null otherwise.</returns>
-        TaskRequirements? FindTask(IDictionary<string, string> taskIdentityParameters);
-
-        /// <summary>
-        /// Initializes for running a particular batch
-        /// </summary>
-        /// <returns>True if the task is instantiated, false otherwise.</returns>
-        bool InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary<string, string> taskIdentityParameters);
-
-        /// <summary>
-        /// Sets a task parameter using an unevaluated value, which will be expanded by the batch bucket.
-        /// </summary>
-        bool SetTaskParameters(IDictionary<string, (string, ElementLocation)> parameters);
-
-        /// <summary>
-        /// Gets all of the outputs and stores them in the batch bucket.
-        /// </summary>
-        bool GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName);
-
-        /// <summary>
-        /// Signal that we are done with this bucket.
-        /// </summary>
-        void CleanupForBatch();
-
-        /// <summary>
-        /// Signal that we are done with this task.
-        /// </summary>
-        void CleanupForTask();
-
-        /// <summary>
-        /// Executes the task.
-        /// </summary>
-        /// <returns>
-        /// True if execution succeeded, false otherwise.
-        /// </returns>
-        bool Execute();
-    }
-}
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 8296519a5b0..fdff89eb618 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -29,12 +29,34 @@
 
 namespace Microsoft.Build.BackEnd
 {
+    /// <summary>
+    /// Flags returned by TaskExecutionHost.FindTask().
+    /// </summary>
+    [Flags]
+    internal enum TaskRequirements
+    {
+        /// <summary>
+        /// The task was not found.
+        /// </summary>
+        None = 0,
+
+        /// <summary>
+        /// The task must be executed on an STA thread.
+        /// </summary>
+        RequireSTAThread = 0x01,
+
+        /// <summary>
+        /// The task must be executed in a separate AppDomain.
+        /// </summary>
+        RequireSeparateAppDomain = 0x02
+    }
+
     /// <summary>
     /// The TaskExecutionHost is responsible for instantiating tasks, setting their parameters and gathering outputs using
     /// reflection, and executing the task in the appropriate context.The TaskExecutionHost does not deal with any part of the task declaration or
     /// XML.
     /// </summary>
-    internal class TaskExecutionHost : ITaskExecutionHost, IDisposable
+    internal class TaskExecutionHost : IDisposable
     {
         /// <summary>
         /// Time interval in miliseconds to wait between receiving a cancelation signal and emitting the first warning that a non-cancelable task has not finished
@@ -178,7 +200,7 @@ internal TaskExecutionHost()
         /// <summary>
         /// The associated project.
         /// </summary>
-        ProjectInstance ITaskExecutionHost.ProjectInstance => _projectInstance;
+        public ProjectInstance ProjectInstance => _projectInstance;
 
         /// <summary>
         /// Gets the task instance
@@ -220,7 +242,7 @@ public virtual void Dispose()
         /// <summary>
         /// Initialize to run a specific task.
         /// </summary>
-        void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext loggingContext, ProjectInstance projectInstance, string taskName, ElementLocation taskLocation, ITaskHost taskHost, bool continueOnError,
+        public void InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext loggingContext, ProjectInstance projectInstance, string taskName, ElementLocation taskLocation, ITaskHost taskHost, bool continueOnError,
 #if FEATURE_APPDOMAIN
             AppDomainSetup appDomainSetup,
 #endif
@@ -243,17 +265,14 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
         /// <summary>
         /// Ask the task host to find its task in the registry and get it ready for initializing the batch
         /// </summary>
-        /// <returns>True if the task is found in the task registry false if otherwise.</returns>
-        TaskRequirements? ITaskExecutionHost.FindTask(IDictionary<string, string> taskIdentityParameters)
+        /// <returns>The task requirements and task factory wrapper if the task is found, (null, null) otherwise.</returns>
+        public (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) FindTask(IDictionary<string, string> taskIdentityParameters)
         {
-            if (_taskFactoryWrapper == null)
-            {
-                _taskFactoryWrapper = FindTaskInRegistry(taskIdentityParameters);
-            }
+            _taskFactoryWrapper ??= FindTaskInRegistry(taskIdentityParameters);
 
-            if (_taskFactoryWrapper == null)
+            if (_taskFactoryWrapper is null)
             {
-                return null;
+                return (null, null);
             }
 
             TaskRequirements requirements = TaskRequirements.None;
@@ -272,13 +291,13 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
                 _remotedTaskItems = new List<TaskItem>();
             }
 
-            return requirements;
+            return (requirements, _taskFactoryWrapper);
         }
 
         /// <summary>
         /// Initialize to run a specific batch of the current task.
         /// </summary>
-        bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary<string, string> taskIdentityParameters)
+        public bool InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary<string, string> taskIdentityParameters)
         {
             ErrorUtilities.VerifyThrowArgumentNull(loggingContext, nameof(loggingContext));
             ErrorUtilities.VerifyThrowArgumentNull(batchBucket, nameof(batchBucket));
@@ -313,6 +332,13 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It
                 return false;
             }
 
+            string realTaskAssemblyLoaction = TaskInstance.GetType().Assembly.Location;
+            if (!string.IsNullOrWhiteSpace(realTaskAssemblyLoaction) &&
+                realTaskAssemblyLoaction != _taskFactoryWrapper.TaskFactoryLoadedType.Path)
+            {
+                _taskLoggingContext.LogComment(MessageImportance.Normal, "TaskAssemblyLocationMismatch", realTaskAssemblyLoaction, _taskFactoryWrapper.TaskFactoryLoadedType.Path);
+            }
+
             TaskInstance.BuildEngine = _buildEngine;
             TaskInstance.HostObject = _taskHost;
 
@@ -324,7 +350,7 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It
         /// </summary>
         /// <param name="parameters">The name/value pairs for the parameters.</param>
         /// <returns>True if the parameters were set correctly, false otherwise.</returns>
-        bool ITaskExecutionHost.SetTaskParameters(IDictionary<string, (string, ElementLocation)> parameters)
+        public bool SetTaskParameters(IDictionary<string, (string, ElementLocation)> parameters)
         {
             ErrorUtilities.VerifyThrowArgumentNull(parameters, nameof(parameters));
 
@@ -395,7 +421,7 @@ bool ITaskExecutionHost.SetTaskParameters(IDictionary<string, (string, ElementLo
         /// Retrieve the outputs from the task.
         /// </summary>
         /// <returns>True of the outputs were gathered successfully, false otherwise.</returns>
-        bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName)
+        public bool GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName)
         {
             ErrorUtilities.VerifyThrow(_taskFactoryWrapper != null, "Need a taskFactoryWrapper to retrieve outputs from.");
 
@@ -500,7 +526,7 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
         /// <summary>
         /// Cleans up after running a batch.
         /// </summary>
-        void ITaskExecutionHost.CleanupForBatch()
+        public void CleanupForBatch()
         {
             try
             {
@@ -518,7 +544,7 @@ void ITaskExecutionHost.CleanupForBatch()
         /// <summary>
         /// Cleans up after running the task.
         /// </summary>
-        void ITaskExecutionHost.CleanupForTask()
+        public void CleanupForTask()
         {
 #if FEATURE_APPDOMAIN
             if (_resolver != null)
@@ -541,7 +567,7 @@ void ITaskExecutionHost.CleanupForTask()
         /// <summary>
         /// Executes the task.
         /// </summary>
-        bool ITaskExecutionHost.Execute()
+        public bool Execute()
         {
             // If cancel is called before we get here, we simply don't execute and return failure.  If cancel is called after this check
             // the task needs to be able to handle the possibility that Cancel has been called before the task has done anything meaningful,
@@ -923,17 +949,11 @@ private ITask InstantiateTask(IDictionary<string, string> taskIdentityParameters
                 else
                 {
                     TaskFactoryLoggingHost loggingHost = new TaskFactoryLoggingHost(_buildEngine.IsRunningMultipleNodes, _taskLocation, _taskLoggingContext);
-                    ITaskFactory2 taskFactory2 = _taskFactoryWrapper.TaskFactory as ITaskFactory2;
                     try
                     {
-                        if (taskFactory2 == null)
-                        {
-                            task = _taskFactoryWrapper.TaskFactory.CreateTask(loggingHost);
-                        }
-                        else
-                        {
-                            task = taskFactory2.CreateTask(loggingHost, taskIdentityParameters);
-                        }
+                        task = _taskFactoryWrapper.TaskFactory is ITaskFactory2 taskFactory2 ?
+                            taskFactory2.CreateTask(loggingHost, taskIdentityParameters) :
+                            _taskFactoryWrapper.TaskFactory.CreateTask(loggingHost);
                     }
                     finally
                     {
diff --git a/src/Build/BuildCheck/API/BuildAnalyzer.cs b/src/Build/BuildCheck/API/BuildAnalyzer.cs
new file mode 100644
index 00000000000..f249dc98cc5
--- /dev/null
+++ b/src/Build/BuildCheck/API/BuildAnalyzer.cs
@@ -0,0 +1,48 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using Microsoft.Build.BuildCheck.Infrastructure;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Base class for build analyzers.
+/// Same base will be used for custom and built-in analyzers.
+/// <see cref="BuildAnalyzer"/> is a unit of build analysis execution, but it can contain multiple rules - each representing a distinct violation.
+/// </summary>
+public abstract class BuildAnalyzer : IDisposable
+{
+    /// <summary>
+    /// Friendly name of the analyzer.
+    /// Should be unique - as it will be used in the tracing stats, infrastructure error messages, etc.
+    /// </summary>
+    public abstract string FriendlyName { get; }
+
+    /// <summary>
+    /// Single or multiple rules supported by the analyzer.
+    /// </summary>
+    public abstract IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; }
+
+    /// <summary>
+    /// Optional initialization of the analyzer.
+    /// </summary>
+    /// <param name="configurationContext">
+    /// Custom data (not recognized by the infrastructure) passed from .editorconfig
+    /// Currently the custom data has to be identical for all rules in the analyzer and all projects.
+    /// </param>
+    public abstract void Initialize(ConfigurationContext configurationContext);
+
+    /// <summary>
+    /// Used by the implementors to subscribe to data and events they are interested in.
+    /// </summary>
+    /// <param name="registrationContext">
+    /// The context that enables subscriptions for data pumping from the infrastructure.
+    /// </param>
+    public abstract void RegisterActions(IBuildCheckRegistrationContext registrationContext);
+
+    public virtual void Dispose()
+    { }
+}
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
new file mode 100644
index 00000000000..4940db20fd1
--- /dev/null
+++ b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
@@ -0,0 +1,45 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Configuration for a build analyzer.
+/// Default values can be specified by the Analyzer in code.
+/// Users can overwrite the defaults by explicit settings in the .editorconfig file.
+/// Each rule can have its own configuration, which can differ per each project.
+/// The <see cref="EvaluationAnalysisScope"/> setting must be same for all rules in the same analyzer (but can differ between projects)
+/// </summary>
+public class BuildAnalyzerConfiguration
+{
+    // Defaults to be used if any configuration property is not specified neither as default
+    //  nor in the editorconfig configuration file.
+    public static BuildAnalyzerConfiguration Default { get; } = new()
+    {
+        EvaluationAnalysisScope = BuildCheck.EvaluationAnalysisScope.ProjectOnly,
+        Severity = BuildAnalyzerResultSeverity.Info,
+        IsEnabled = false,
+    };
+
+    public static BuildAnalyzerConfiguration Null { get; } = new();
+
+    /// <summary>
+    /// This applies only to specific events, that can distinguish whether they are directly inferred from
+    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from analysis.
+    ///
+    /// If not supported by the data source - then the setting is ignored
+    /// </summary>
+    public EvaluationAnalysisScope? EvaluationAnalysisScope { get; internal init; }
+
+    /// <summary>
+    /// The severity of the result for the rule.
+    /// </summary>
+    public BuildAnalyzerResultSeverity? Severity { get; internal init; }
+
+    /// <summary>
+    /// Whether the analyzer rule is enabled.
+    /// If all rules within the analyzer are not enabled, it will not be run.
+    /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.
+    /// </summary>
+    public bool? IsEnabled { get; internal init; }
+}
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs b/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
new file mode 100644
index 00000000000..412a014be06
--- /dev/null
+++ b/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
@@ -0,0 +1,14 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// The severity of reported result (or preconfigured or user configured severity for a rule).
+/// </summary>
+public enum BuildAnalyzerResultSeverity
+{
+    Info,
+    Warning,
+    Error,
+}
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs b/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
new file mode 100644
index 00000000000..8b43dad4999
--- /dev/null
+++ b/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
@@ -0,0 +1,55 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Represents a rule that is a unit of build analysis.
+/// <see cref="BuildAnalyzer"/> is a unit of executing the analysis, but it can be discovering multiple distinct violation types,
+///  for this reason a single <see cref="BuildAnalyzer"/> can expose multiple <see cref="BuildAnalyzerRule"/>s.
+/// </summary>
+public class BuildAnalyzerRule
+{
+    public BuildAnalyzerRule(string id, string title, string description, string messageFormat,
+        BuildAnalyzerConfiguration defaultConfiguration)
+    {
+        Id = id;
+        Title = title;
+        Description = description;
+        MessageFormat = messageFormat;
+        DefaultConfiguration = defaultConfiguration;
+    }
+
+    /// <summary>
+    /// The identification of the rule.
+    ///
+    /// Some background on ids:
+    ///  * https://github.com/dotnet/roslyn-analyzers/blob/main/src/Utilities/Compiler/DiagnosticCategoryAndIdRanges.txt
+    ///  * https://github.com/dotnet/roslyn/issues/40351
+    ///
+    /// Quick suggestion now - let's force external ids to start with 'X', for ours - avoid 'MSB'
+    ///  maybe - BT - build static/styling; BA - build authoring; BE - build execution/environment; BC - build configuration
+    /// </summary>
+    public string Id { get; }
+
+    /// <summary>
+    /// The descriptive short summary of the rule.
+    /// </summary>
+    public string Title { get; }
+
+    /// <summary>
+    /// More detailed description of the violation the rule can be reporting (with possible suggestions).
+    /// </summary>
+    public string Description { get; }
+
+    /// <summary>
+    /// Message format that will be used by the actual reports (<see cref="BuildCheckResult"/>) - those will just supply the actual arguments.
+    /// </summary>
+    public string MessageFormat { get; }
+
+    /// <summary>
+    /// The default configuration - overridable by the user via .editorconfig.
+    /// If no user specified configuration is provided, this default will be used.
+    /// </summary>
+    public BuildAnalyzerConfiguration DefaultConfiguration { get; }
+}
diff --git a/src/Build/BuildCheck/API/BuildCheckResult.cs b/src/Build/BuildCheck/API/BuildCheckResult.cs
new file mode 100644
index 00000000000..03a69e02939
--- /dev/null
+++ b/src/Build/BuildCheck/API/BuildCheckResult.cs
@@ -0,0 +1,56 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Representation of a single report of a single finding from a BuildAnalyzer
+/// Each rule has upfront known message format - so only the concrete arguments are added
+/// Optionally a location is attached - in the near future we might need to support multiple locations
+///  (for 2 cases - a) grouped result for multiple occurrences; b) a single report for a finding resulting from combination of multiple locations)
+/// </summary>
+public sealed class BuildCheckResult : IBuildCheckResult
+{
+    public static BuildCheckResult Create(BuildAnalyzerRule rule, ElementLocation location, params string[] messageArgs)
+    {
+        return new BuildCheckResult(rule, location, messageArgs);
+    }
+
+    public BuildCheckResult(BuildAnalyzerRule buildAnalyzerRule, ElementLocation location, string[] messageArgs)
+    {
+        BuildAnalyzerRule = buildAnalyzerRule;
+        Location = location;
+        MessageArgs = messageArgs;
+    }
+
+    internal BuildEventArgs ToEventArgs(BuildAnalyzerResultSeverity severity)
+        => severity switch
+        {
+            BuildAnalyzerResultSeverity.Info => new BuildCheckResultMessage(this),
+            BuildAnalyzerResultSeverity.Warning => new BuildCheckResultWarning(this),
+            BuildAnalyzerResultSeverity.Error => new BuildCheckResultError(this),
+            _ => throw new ArgumentOutOfRangeException(nameof(severity), severity, null),
+        };
+
+    public BuildAnalyzerRule BuildAnalyzerRule { get; }
+
+    /// <summary>
+    /// Optional location of the finding (in near future we might need to support multiple locations).
+    /// </summary>
+    public ElementLocation Location { get; }
+
+    public string LocationString => Location.LocationString;
+
+    public string[] MessageArgs { get; }
+    public string MessageFormat => BuildAnalyzerRule.MessageFormat;
+
+    public string FormatMessage() =>
+        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}{BuildAnalyzerRule.Id}: {string.Format(BuildAnalyzerRule.MessageFormat, MessageArgs)}";
+
+    private string? _message;
+}
diff --git a/src/Build/BuildCheck/API/ConfigurationContext.cs b/src/Build/BuildCheck/API/ConfigurationContext.cs
new file mode 100644
index 00000000000..49dcdcfafec
--- /dev/null
+++ b/src/Build/BuildCheck/API/ConfigurationContext.cs
@@ -0,0 +1,40 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.BuildCheck.Infrastructure;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Holder of an optional configuration from .editorconfig file (not recognized by the infrastructure)
+/// </summary>
+public class ConfigurationContext
+{
+    private ConfigurationContext(CustomConfigurationData[] customConfigurationData)
+    {
+        CustomConfigurationData = customConfigurationData;
+    }
+
+    internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData)
+    {
+        if (!customConfigurationData.Any(BuildCheck.CustomConfigurationData.NotNull))
+        {
+            return Null;
+        }
+
+        return new ConfigurationContext(
+            customConfigurationData
+                .Where(BuildCheck.CustomConfigurationData.NotNull)
+                .ToArray());
+    }
+
+    internal static ConfigurationContext Null { get; } = new(Array.Empty<CustomConfigurationData>());
+
+    /// <summary>
+    /// Custom configuration data - per each rule that has some specified.
+    /// </summary>
+    public IReadOnlyList<CustomConfigurationData> CustomConfigurationData { get; init; }
+}
diff --git a/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs b/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs
new file mode 100644
index 00000000000..39781649359
--- /dev/null
+++ b/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs
@@ -0,0 +1,33 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// For datasource events that can differentiate from where exactly they originate - e.g.
+///  For a condition string or AST - was that directly in hte analyzed project or imported?
+///
+/// Ignored by infrastructure if the current datasource doesn't support this level of setting.
+/// </summary>
+public enum EvaluationAnalysisScope
+{
+    /// <summary>
+    /// Only the data from currently analyzed project will be sent to the analyzer. Imports will be discarded.
+    /// </summary>
+    ProjectOnly,
+
+    /// <summary>
+    /// Only the data from currently analyzed project and imports from files under the entry project or solution will be sent to the analyzer. Other imports will be discarded.
+    /// </summary>
+    ProjectWithImportsFromCurrentWorkTree,
+
+    /// <summary>
+    /// Imports from SDKs will not be sent to the analyzer. Other imports will be sent.
+    /// </summary>
+    ProjectWithImportsWithoutSdks,
+
+    /// <summary>
+    /// All data will be sent to the analyzer.
+    /// </summary>
+    ProjectWithAllImports,
+}
diff --git a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
new file mode 100644
index 00000000000..04cdf5aa87f
--- /dev/null
+++ b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
@@ -0,0 +1,12 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+public interface IBuildCheckRegistrationContext
+{
+    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction);
+    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction);
+}
diff --git a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs b/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
new file mode 100644
index 00000000000..125dc27458e
--- /dev/null
+++ b/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
@@ -0,0 +1,27 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Acquisition;
+
+// https://github.com/dotnet/msbuild/issues/9633
+// Acquisition
+//  define the data that will be passed to the acquisition module (and remoted if needed)
+internal class AnalyzerAcquisitionData(string assemblyPath)
+{
+    public string AssemblyPath { get; init; } = assemblyPath;
+}
+
+internal static class AnalyzerAcquisitionDataExtensions
+{
+    public static AnalyzerAcquisitionData ToAnalyzerAcquisitionData(this BuildCheckAcquisitionEventArgs eventArgs) =>
+        new(eventArgs.AcquisitionPath);
+
+    public static BuildCheckAcquisitionEventArgs ToBuildEventArgs(this AnalyzerAcquisitionData data) => new(data.AssemblyPath);
+}
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
new file mode 100644
index 00000000000..1d2ff00841e
--- /dev/null
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -0,0 +1,76 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.BuildCheck.Acquisition;
+
+internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
+{
+    private readonly ILoggingService _loggingService;
+
+    internal BuildCheckAcquisitionModule(ILoggingService loggingService) => _loggingService = loggingService;
+
+#if FEATURE_ASSEMBLYLOADCONTEXT
+    /// <summary>
+    /// AssemblyContextLoader used to load DLLs outside of msbuild.exe directory.
+    /// </summary>
+    private static readonly CoreClrAssemblyLoader s_coreClrAssemblyLoader = new();
+#endif
+
+    /// <summary>
+    /// Creates a list of factory delegates for building analyzer rules instances from a given assembly path.
+    /// </summary>
+    public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, BuildEventContext buildEventContext)
+    {
+        var analyzersFactories = new List<BuildAnalyzerFactory>();
+
+        try
+        {
+            Assembly? assembly = null;
+#if FEATURE_ASSEMBLYLOADCONTEXT
+            assembly = s_coreClrAssemblyLoader.LoadFromPath(analyzerAcquisitionData.AssemblyPath);
+#else
+            assembly = Assembly.LoadFrom(analyzerAcquisitionData.AssemblyPath);
+#endif
+
+            IEnumerable<Type> analyzerTypes = assembly.GetExportedTypes().Where(t => typeof(BuildAnalyzer).IsAssignableFrom(t));
+
+            foreach (Type analyzerType in analyzerTypes)
+            {
+                if (Activator.CreateInstance(analyzerType) is BuildAnalyzer instance)
+                {
+                    analyzersFactories.Add(() => instance);
+                }
+                else
+                {
+                    throw new InvalidOperationException($"Failed to create an instance of type {analyzerType.FullName} as BuildAnalyzer.");
+                }
+            }
+        }
+        catch (ReflectionTypeLoadException ex)
+        {
+            if (ex.LoaderExceptions.Length != 0)
+            {
+                foreach (Exception? loaderException in ex.LoaderExceptions)
+                {
+                    _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerFailedRuleLoading", loaderException?.Message);
+                }
+            }
+        }
+        catch (Exception ex)
+        {
+            _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerFailedRuleLoading", ex?.Message);
+        }
+
+        return analyzersFactories;
+    }
+}
diff --git a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
new file mode 100644
index 00000000000..e86dc7d0c4a
--- /dev/null
+++ b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
@@ -0,0 +1,16 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.BuildCheck.Acquisition;
+
+internal interface IBuildCheckAcquisitionModule
+{
+    /// <summary>
+    /// Creates a list of factory delegates for building analyzer rules instances from a given assembly path.
+    /// </summary>
+    List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, BuildEventContext buildEventContext);
+}
diff --git a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs b/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
new file mode 100644
index 00000000000..174fb305b83
--- /dev/null
+++ b/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
@@ -0,0 +1,93 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Analyzers;
+
+internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
+{
+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0101", "ConflictingOutputPath",
+        "Two projects should not share their OutputPath nor IntermediateOutputPath locations",
+        "Projects {0} and {1} have conflicting output paths: {2}.",
+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+
+    public override string FriendlyName => "MSBuild.SharedOutputPathAnalyzer";
+
+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } =[SupportedRule];
+
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        /* This is it - no custom configuration */
+    }
+
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+    {
+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+    }
+
+    private readonly Dictionary<string, string> _projectsPerOutputPath = new(StringComparer.CurrentCultureIgnoreCase);
+    private readonly HashSet<string> _projects = new(StringComparer.CurrentCultureIgnoreCase);
+
+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    {
+        if (!_projects.Add(context.Data.ProjectFilePath))
+        {
+            return;
+        }
+
+        string? binPath, objPath;
+
+        context.Data.EvaluatedProperties.TryGetValue("OutputPath", out binPath);
+        context.Data.EvaluatedProperties.TryGetValue("IntermediateOutputPath", out objPath);
+
+        string? absoluteBinPath = CheckAndAddFullOutputPath(binPath, context);
+        if (
+            !string.IsNullOrEmpty(objPath) && !string.IsNullOrEmpty(absoluteBinPath) &&
+            !objPath.Equals(binPath, StringComparison.CurrentCultureIgnoreCase)
+            && !objPath.Equals(absoluteBinPath, StringComparison.CurrentCultureIgnoreCase)
+        )
+        {
+            CheckAndAddFullOutputPath(objPath, context);
+        }
+    }
+
+    private string? CheckAndAddFullOutputPath(string? path, BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    {
+        if (string.IsNullOrEmpty(path))
+        {
+            return path;
+        }
+
+        string projectPath = context.Data.ProjectFilePath;
+
+        if (!Path.IsPathRooted(path))
+        {
+            path = Path.Combine(Path.GetDirectoryName(projectPath)!, path);
+        }
+
+        if (_projectsPerOutputPath.TryGetValue(path!, out string? conflictingProject))
+        {
+            context.ReportResult(BuildCheckResult.Create(
+                SupportedRule,
+                // Populating precise location tracked via https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=58661732
+                ElementLocation.EmptyLocation,
+                Path.GetFileName(projectPath),
+                Path.GetFileName(conflictingProject),
+                path!));
+        }
+        else
+        {
+            _projectsPerOutputPath[path!] = projectPath;
+        }
+
+        return path;
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
new file mode 100644
index 00000000000..c2c36c813f9
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
@@ -0,0 +1,34 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+/// <summary>
+/// Counterpart type for BuildAnalyzerConfiguration - with all properties non-nullable
+/// </summary>
+internal sealed class BuildAnalyzerConfigurationInternal
+{
+    public BuildAnalyzerConfigurationInternal(string ruleId, EvaluationAnalysisScope evaluationAnalysisScope, BuildAnalyzerResultSeverity severity, bool isEnabled)
+    {
+        RuleId = ruleId;
+        EvaluationAnalysisScope = evaluationAnalysisScope;
+        Severity = severity;
+        IsEnabled = isEnabled;
+    }
+
+    public string RuleId { get; }
+    public EvaluationAnalysisScope EvaluationAnalysisScope { get; }
+    public BuildAnalyzerResultSeverity Severity { get; }
+    public bool IsEnabled { get; }
+
+    // Intentionally not checking the RuleId
+    //  as for analyzers with multiple rules, we can squash config to a single one,
+    //  if the ruleId is the only thing differing.
+    public bool IsSameConfigurationAs(BuildAnalyzerConfigurationInternal? other) =>
+        other != null &&
+        Severity == other.Severity &&
+        IsEnabled == other.IsEnabled &&
+        EvaluationAnalysisScope == other.EvaluationAnalysisScope;
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
new file mode 100644
index 00000000000..06e0aaa2439
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
@@ -0,0 +1,75 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+/// <summary>
+/// A wrapping, enriching class for BuildAnalyzer - so that we have additional data and functionality.
+/// </summary>
+internal sealed class BuildAnalyzerWrapper
+{
+    private readonly Stopwatch _stopwatch = new Stopwatch();
+
+    public BuildAnalyzerWrapper(BuildAnalyzer buildAnalyzer)
+    {
+        BuildAnalyzer = buildAnalyzer;
+    }
+
+    internal BuildAnalyzer BuildAnalyzer { get; }
+    private bool _isInitialized = false;
+
+    // Let's optimize for the scenario where users have a single .editorconfig file that applies to the whole solution.
+    // In such case - configuration will be same for all projects. So we do not need to store it per project in a collection.
+    internal BuildAnalyzerConfigurationInternal? CommonConfig { get; private set; }
+
+    // start new project
+    internal void StartNewProject(
+        string fullProjectPath,
+        IReadOnlyList<BuildAnalyzerConfigurationInternal> userConfigs)
+    {
+        if (!_isInitialized)
+        {
+            _isInitialized = true;
+            CommonConfig = userConfigs[0];
+
+            if (userConfigs.Count == 1)
+            {
+                return;
+            }
+        }
+
+        // The Common configuration is not common anymore - let's nullify it and we will need to fetch configuration per project.
+        if (CommonConfig == null || !userConfigs.All(t => t.IsSameConfigurationAs(CommonConfig)))
+        {
+            CommonConfig = null;
+        }
+    }
+
+    // to be used on eval node (BuildCheckDataSource.BuildExecution)
+    internal void Uninitialize()
+    {
+        _isInitialized = false;
+    }
+
+    internal TimeSpan Elapsed => _stopwatch.Elapsed;
+
+    internal void ClearStats() => _stopwatch.Reset();
+
+    internal CleanupScope StartSpan()
+    {
+        _stopwatch.Start();
+        return new CleanupScope(_stopwatch.Stop);
+    }
+
+    internal readonly struct CleanupScope(Action disposeAction) : IDisposable
+    {
+        public void Dispose() => disposeAction();
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
new file mode 100644
index 00000000000..9995aef71b3
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -0,0 +1,137 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+/// <summary>
+/// A manager of the runs of the analyzers - deciding based on configuration of what to run and what to postfilter.
+/// </summary>
+internal sealed class BuildCheckCentralContext
+{
+    private record CallbackRegistry(
+        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>>)> EvaluatedPropertiesActions,
+        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ParsedItemsAnalysisData>>)> ParsedItemsActions)
+    {
+        public CallbackRegistry() : this([],[]) { }
+    }
+
+    // In a future we can have callbacks per project as well
+    private readonly CallbackRegistry _globalCallbacks = new();
+
+    // This we can potentially use to subscribe for receiving evaluated props in the
+    //  build event args. However - this needs to be done early on, when analyzers might not be known yet
+    internal bool HasEvaluatedPropertiesActions => _globalCallbacks.EvaluatedPropertiesActions.Any();
+    internal bool HasParsedItemsActions => _globalCallbacks.ParsedItemsActions.Any();
+
+    internal void RegisterEvaluatedPropertiesAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
+        // Here we might want to communicate to node that props need to be sent.
+        //  (it was being communicated via MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION)
+        => RegisterAction(analyzer, evaluatedPropertiesAction, _globalCallbacks.EvaluatedPropertiesActions);
+
+    internal void RegisterParsedItemsAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
+        => RegisterAction(analyzer, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
+
+    private void RegisterAction<T>(
+        BuildAnalyzerWrapper wrappedAnalyzer,
+        Action<BuildCheckDataContext<T>> handler,
+        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> handlersRegistry)
+        where T : AnalysisData
+    {
+        void WrappedHandler(BuildCheckDataContext<T> context)
+        {
+            using var _ = wrappedAnalyzer.StartSpan();
+            handler(context);
+        }
+
+        lock (handlersRegistry)
+        {
+            handlersRegistry.Add((wrappedAnalyzer, WrappedHandler));
+        }
+    }
+
+    internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
+    {
+        _globalCallbacks.EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == analyzer);
+        _globalCallbacks.ParsedItemsActions.RemoveAll(a => a.Item1 == analyzer);
+    }
+
+    internal void RunEvaluatedPropertiesActions(
+        EvaluatedPropertiesAnalysisData evaluatedPropertiesAnalysisData,
+        LoggingContext loggingContext,
+        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult>
+            resultHandler)
+        => RunRegisteredActions(_globalCallbacks.EvaluatedPropertiesActions, evaluatedPropertiesAnalysisData,
+            loggingContext, resultHandler);
+
+    internal void RunParsedItemsActions(
+        ParsedItemsAnalysisData parsedItemsAnalysisData,
+        LoggingContext loggingContext,
+        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult>
+            resultHandler)
+        => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsAnalysisData,
+            loggingContext, resultHandler);
+
+    private void RunRegisteredActions<T>(
+        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
+        T analysisData,
+        LoggingContext loggingContext,
+        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult> resultHandler)
+    where T : AnalysisData
+    {
+        string projectFullPath = analysisData.ProjectFilePath;
+
+        // Alternatively we might want to actually do this all in serial, but asynchronously (blocking queue)
+        Parallel.ForEach(
+            registeredCallbacks,
+            new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount },
+            /* (BuildAnalyzerWrapper2, Action<BuildAnalysisContext<T>>) */
+            analyzerCallback =>
+            {
+                // Tracing - https://github.com/dotnet/msbuild/issues/9629 - we might want to account this entire block
+                //  to the relevant analyzer (with only the currently accounted part as being the 'core-execution' subspan)
+
+                BuildAnalyzerConfigurationInternal? commonConfig = analyzerCallback.Item1.CommonConfig;
+                BuildAnalyzerConfigurationInternal[] configPerRule;
+
+                if (commonConfig != null)
+                {
+                    if (!commonConfig.IsEnabled)
+                    {
+                        return;
+                    }
+
+                    configPerRule = new[] { commonConfig };
+                }
+                else
+                {
+                    configPerRule =
+                        ConfigurationProvider.GetMergedConfigurations(projectFullPath,
+                            analyzerCallback.Item1.BuildAnalyzer);
+                    if (configPerRule.All(c => !c.IsEnabled))
+                    {
+                        return;
+                    }
+                }
+
+                // Here we might want to check the configPerRule[0].EvaluationAnalysisScope - if the input data supports that
+                // The decision and implementation depends on the outcome of the investigation tracked in:
+                // https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57851137
+
+                BuildCheckDataContext<T> context = new BuildCheckDataContext<T>(
+                    analyzerCallback.Item1,
+                    loggingContext,
+                    configPerRule,
+                    resultHandler,
+                    analysisData);
+
+                analyzerCallback.Item2(context);
+            });
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
new file mode 100644
index 00000000000..29a0a8acf50
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
@@ -0,0 +1,21 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal sealed class BuildCheckConfigurationException : Exception
+{
+    /// <summary>
+    /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.
+    /// This exception usually leads to defuncting the particular analyzer for the rest of the build (even if issue occured with a single project).
+    /// </summary>
+    public BuildCheckConfigurationException(string message) : base(message)
+    {
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
new file mode 100644
index 00000000000..361c30c4200
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -0,0 +1,108 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+using static Microsoft.Build.BuildCheck.Infrastructure.BuildCheckManagerProvider;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal sealed class BuildCheckConnectorLogger : ILogger
+{
+    private readonly Dictionary<Type, Action<BuildEventArgs>> _eventHandlers;
+    private readonly IBuildCheckManager _buildCheckManager;
+    private readonly IBuildAnalysisLoggingContextFactory _loggingContextFactory;
+
+    internal BuildCheckConnectorLogger(
+        IBuildAnalysisLoggingContextFactory loggingContextFactory,
+        IBuildCheckManager buildCheckManager)
+    {
+        _buildCheckManager = buildCheckManager;
+        _loggingContextFactory = loggingContextFactory;
+        _eventHandlers = GetBuildEventHandlers();
+    }
+
+    public LoggerVerbosity Verbosity { get; set; }
+
+    public string? Parameters { get; set; }
+
+    public void Initialize(IEventSource eventSource)
+    {
+        eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+        eventSource.BuildFinished += EventSource_BuildFinished;
+
+        if (eventSource is IEventSource4 eventSource4)
+        {
+            eventSource4.IncludeEvaluationPropertiesAndItems();
+        }
+    }
+
+    public void Shutdown()
+    {
+    }
+
+    private void HandleProjectEvaluationFinishedEvent(ProjectEvaluationFinishedEventArgs eventArgs)
+    {
+        if (!IsMetaProjFile(eventArgs.ProjectFile))
+        {
+            _buildCheckManager.ProcessEvaluationFinishedEventArgs(
+                _loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!),
+                eventArgs);
+
+            _buildCheckManager.EndProjectEvaluation(BuildCheckDataSource.EventArgs, eventArgs.BuildEventContext!);
+        }
+    }
+
+    private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventArgs eventArgs)
+    {
+        if (!IsMetaProjFile(eventArgs.ProjectFile))
+        {
+            _buildCheckManager.StartProjectEvaluation(BuildCheckDataSource.EventArgs, eventArgs.BuildEventContext!, eventArgs.ProjectFile!);
+        }
+    }
+
+    private bool IsMetaProjFile(string? projectFile) => !string.IsNullOrEmpty(projectFile) && projectFile!.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase);
+
+    private void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
+    {
+        if (_eventHandlers.TryGetValue(e.GetType(), out Action<BuildEventArgs>? handler))
+        {
+            handler(e);
+        }
+    }
+
+    private readonly Dictionary<string, TimeSpan> _stats = new Dictionary<string, TimeSpan>();
+
+    private void EventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
+    {
+        _stats.Merge(_buildCheckManager.CreateTracingStats(), (span1, span2) => span1 + span2);
+        string msg = string.Join(Environment.NewLine, _stats.Select(a => a.Key + ": " + a.Value));
+
+        BuildEventContext buildEventContext = e.BuildEventContext
+            ?? new BuildEventContext(
+                BuildEventContext.InvalidNodeId,
+                BuildEventContext.InvalidTargetId,
+                BuildEventContext.InvalidProjectContextId,
+                BuildEventContext.InvalidTaskId);
+
+        LoggingContext loggingContext = _loggingContextFactory.CreateLoggingContext(buildEventContext);
+
+        // Tracing: https://github.com/dotnet/msbuild/issues/9629
+        loggingContext.LogCommentFromText(MessageImportance.High, msg);
+    }
+
+    private Dictionary<Type, Action<BuildEventArgs>> GetBuildEventHandlers() => new()
+    {
+        { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs) e) },
+        { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs) e) },
+        { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
+        { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => _buildCheckManager.EndProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
+        { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => _stats.Merge(((BuildCheckTracingEventArgs)e).TracingData, (span1, span2) => span1 + span2) },
+        { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => _buildCheckManager.ProcessAnalyzerAcquisition(((BuildCheckAcquisitionEventArgs)e).ToAnalyzerAcquisitionData(), e.BuildEventContext!) },
+    };
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
new file mode 100644
index 00000000000..19a4e3d6967
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
@@ -0,0 +1,21 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Threading;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal sealed class BuildCheckRegistrationContext(BuildAnalyzerWrapper analyzerWrapper, BuildCheckCentralContext buildCheckCentralContext) : IBuildCheckRegistrationContext
+{
+    public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
+    {
+        buildCheckCentralContext.RegisterEvaluatedPropertiesAction(analyzerWrapper, evaluatedPropertiesAction);
+    }
+
+    public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
+    {
+        buildCheckCentralContext.RegisterParsedItemsAction(analyzerWrapper, parsedItemsAction);
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
new file mode 100644
index 00000000000..33985a81707
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -0,0 +1,391 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.BuildCheck.Analyzers;
+using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal delegate BuildAnalyzer BuildAnalyzerFactory();
+internal delegate BuildAnalyzerWrapper BuildAnalyzerWrapperFactory(ConfigurationContext configurationContext);
+
+/// <summary>
+/// The central manager for the BuildCheck - this is the integration point with MSBuild infrastructure.
+/// </summary>
+internal sealed class BuildCheckManagerProvider : IBuildCheckManagerProvider
+{
+    private static IBuildCheckManager? s_globalInstance;
+
+    internal static IBuildCheckManager GlobalInstance => s_globalInstance ?? throw new InvalidOperationException("BuildCheckManagerProvider not initialized");
+
+    public IBuildCheckManager Instance => GlobalInstance;
+
+    internal static IBuildComponent CreateComponent(BuildComponentType type)
+    {
+        ErrorUtilities.VerifyThrow(type == BuildComponentType.BuildCheckManagerProvider, "Cannot create components of type {0}", type);
+        return new BuildCheckManagerProvider();
+    }
+
+    public void InitializeComponent(IBuildComponentHost host)
+    {
+        ErrorUtilities.VerifyThrow(host != null, "BuildComponentHost was null");
+
+        if (s_globalInstance == null)
+        {
+            IBuildCheckManager instance;
+            if (host!.BuildParameters.IsBuildCheckEnabled)
+            {
+                instance = new BuildCheckManager(host.LoggingService);
+            }
+            else
+            {
+                instance = new NullBuildCheckManager();
+            }
+
+            // We are fine with the possibility of double creation here - as the construction is cheap
+            //  and without side effects and the actual backing field is effectively immutable after the first assignment.
+            Interlocked.CompareExchange(ref s_globalInstance, instance, null);
+        }
+    }
+
+    public void ShutdownComponent() => GlobalInstance.Shutdown();
+
+    internal sealed class BuildCheckManager : IBuildCheckManager
+    {
+        private readonly TracingReporter _tracingReporter = new TracingReporter();
+        private readonly BuildCheckCentralContext _buildCheckCentralContext = new();
+        private readonly ILoggingService _loggingService;
+        private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry;
+        private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
+        private readonly BuildEventsProcessor _buildEventsProcessor;
+        private readonly IBuildCheckAcquisitionModule _acquisitionModule;
+
+        internal BuildCheckManager(ILoggingService loggingService)
+        {
+            _analyzersRegistry = new List<BuildAnalyzerFactoryContext>();
+            _acquisitionModule = new BuildCheckAcquisitionModule(loggingService);
+            _loggingService = loggingService;
+            _buildEventsProcessor = new(_buildCheckCentralContext);
+        }
+
+        private bool IsInProcNode => _enabledDataSources[(int)BuildCheckDataSource.EventArgs] &&
+                                     _enabledDataSources[(int)BuildCheckDataSource.BuildExecution];
+
+        /// <summary>
+        /// Notifies the manager that the data source will be used -
+        ///   so it should register the built-in analyzers for the source if it hasn't been done yet.
+        /// </summary>
+        /// <param name="buildCheckDataSource"></param>
+        public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
+        {
+            if (!_enabledDataSources[(int)buildCheckDataSource])
+            {
+                _enabledDataSources[(int)buildCheckDataSource] = true;
+                RegisterBuiltInAnalyzers(buildCheckDataSource);
+            }
+        }
+
+        public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext)
+        {
+            if (IsInProcNode)
+            {
+                var analyzersFactories = _acquisitionModule.CreateBuildAnalyzerFactories(acquisitionData, buildEventContext);
+                if (analyzersFactories.Count != 0)
+                {
+                    RegisterCustomAnalyzer(BuildCheckDataSource.EventArgs, analyzersFactories, buildEventContext);
+                }
+                else
+                {
+                    _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerFailedAcquisition", acquisitionData.AssemblyPath);
+                }
+            }
+            else
+            {
+                BuildCheckAcquisitionEventArgs eventArgs = acquisitionData.ToBuildEventArgs();
+                eventArgs.BuildEventContext = buildEventContext;
+
+                _loggingService.LogBuildEvent(eventArgs);
+            }
+        }
+
+        private static T Construct<T>() where T : new() => new();
+
+        private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][] s_builtInFactoriesPerDataSource =
+        [
+            // BuildCheckDataSource.EventArgs
+            [
+                ([SharedOutputPathAnalyzer.SupportedRule.Id], SharedOutputPathAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathAnalyzer>)
+            ],
+            // BuildCheckDataSource.Execution
+            []
+        ];
+
+        private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
+        {
+            _analyzersRegistry.AddRange(
+                s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
+                    .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+        }
+
+        /// <summary>
+        /// To be used by acquisition module.
+        /// Registers the custom analyzers, the construction of analyzers is deferred until the first using project is encountered.
+        /// </summary>
+        internal void RegisterCustomAnalyzers(
+            BuildCheckDataSource buildCheckDataSource,
+            IEnumerable<BuildAnalyzerFactory> factories,
+            string[] ruleIds,
+            bool defaultEnablement)
+        {
+            if (_enabledDataSources[(int)buildCheckDataSource])
+            {
+                foreach (BuildAnalyzerFactory factory in factories)
+                {
+                    _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(factory, ruleIds, defaultEnablement));
+                }
+            }
+        }
+
+        /// <summary>
+        /// To be used by acquisition module
+        /// Registers the custom analyzer, the construction of analyzer is needed during registration.
+        /// </summary>
+        /// <param name="buildCheckDataSource">Represents different data sources used in build check operations.</param>
+        /// <param name="factories">A collection of build analyzer factories for rules instantiation.</param>
+        /// <param name="buildEventContext">The context of the build event.</param>
+        internal void RegisterCustomAnalyzer(
+            BuildCheckDataSource buildCheckDataSource,
+            IEnumerable<BuildAnalyzerFactory> factories,
+            BuildEventContext buildEventContext)
+        {
+            if (_enabledDataSources[(int)buildCheckDataSource])
+            {
+                foreach (var factory in factories)
+                {
+                    var instance = factory();
+                    _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(
+                        factory,
+                        instance.SupportedRules.Select(r => r.Id).ToArray(),
+                        instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
+                    _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
+                }     
+            }
+        }
+
+        private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryContext, string projectFullPath, BuildEventContext buildEventContext)
+        {
+            // For custom analyzers - it should run only on projects where referenced
+            //  (otherwise error out - https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57849480)
+            //  on others it should work similarly as disabling them.
+            // Disabled analyzer should not only post-filter results - it shouldn't even see the data 
+
+            BuildAnalyzerWrapper wrapper;
+            BuildAnalyzerConfigurationInternal[] configurations;
+            if (analyzerFactoryContext.MaterializedAnalyzer == null)
+            {
+                BuildAnalyzerConfiguration[] userConfigs =
+                    ConfigurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+
+                if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
+                {
+                    // the analyzer was not yet instantiated nor mounted - so nothing to do here now.
+                    return;
+                }
+
+                CustomConfigurationData[] customConfigData =
+                    ConfigurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+
+                ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData);
+
+                wrapper = analyzerFactoryContext.Factory(configurationContext);
+                analyzerFactoryContext.MaterializedAnalyzer = wrapper;
+                BuildAnalyzer analyzer = wrapper.BuildAnalyzer;
+
+                // This is to facilitate possible perf improvement for custom analyzers - as we might want to
+                //  avoid loading the assembly and type just to check if it's supported.
+                // If we expose a way to declare the enablement status and rule ids during registration (e.g. via
+                //  optional arguments of the intrinsic property function) - we can then avoid loading it.
+                // But once loaded - we should verify that the declared enablement status and rule ids match the actual ones.
+                if (
+                    analyzer.SupportedRules.Count != analyzerFactoryContext.RuleIds.Length
+                    ||
+                    !analyzer.SupportedRules.Select(r => r.Id)
+                        .SequenceEqual(analyzerFactoryContext.RuleIds, StringComparer.CurrentCultureIgnoreCase)
+                )
+                {
+                    throw new BuildCheckConfigurationException(
+                        $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
+                }
+
+                configurations = ConfigurationProvider.GetMergedConfigurations(userConfigs, analyzer);
+
+                // technically all analyzers rules could be disabled, but that would mean
+                // that the provided 'IsEnabledByDefault' value wasn't correct - the only
+                // price to be paid in that case is slight performance cost.
+
+                // Create the wrapper and register to central context
+                wrapper.StartNewProject(projectFullPath, configurations);
+                var wrappedContext = new BuildCheckRegistrationContext(wrapper, _buildCheckCentralContext);
+                analyzer.RegisterActions(wrappedContext);
+            }
+            else
+            {
+                wrapper = analyzerFactoryContext.MaterializedAnalyzer;
+
+                configurations = ConfigurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
+
+                ConfigurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
+                    analyzerFactoryContext.RuleIds[0]);
+
+                // Update the wrapper
+                wrapper.StartNewProject(projectFullPath, configurations);
+            }
+
+            if (configurations.GroupBy(c => c.EvaluationAnalysisScope).Count() > 1)
+            {
+                throw new BuildCheckConfigurationException(
+                    string.Format("All rules for a single analyzer should have the same EvaluationAnalysisScope for a single project (violating rules: [{0}], project: {1})",
+                        analyzerFactoryContext.RuleIds.ToCsvString(),
+                        projectFullPath));
+            }
+        }
+
+        private void SetupAnalyzersForNewProject(string projectFullPath, BuildEventContext buildEventContext)
+        {
+            // Only add analyzers here
+            // On an execution node - we might remove and dispose the analyzers once project is done
+
+            // If it's already constructed - just control the custom settings do not differ
+
+            List<BuildAnalyzerFactoryContext> analyzersToRemove = new();
+            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            {
+                try
+                {
+                    SetupSingleAnalyzer(analyzerFactoryContext, projectFullPath, buildEventContext);
+                }
+                catch (BuildCheckConfigurationException e)
+                {
+                    _loggingService.LogErrorFromText(buildEventContext, null, null, null,
+                        new BuildEventFileInfo(projectFullPath),
+                        e.Message);
+                    analyzersToRemove.Add(analyzerFactoryContext);
+                }
+            }
+
+            analyzersToRemove.ForEach(c =>
+            {
+                _analyzersRegistry.Remove(c);
+                _loggingService.LogCommentFromText(buildEventContext, MessageImportance.High, $"Dismounting analyzer '{c.FriendlyName}'");
+            });
+            foreach (var analyzerToRemove in analyzersToRemove.Select(a => a.MaterializedAnalyzer).Where(a => a != null))
+            {
+                _buildCheckCentralContext.DeregisterAnalyzer(analyzerToRemove!);
+                _tracingReporter.AddStats(analyzerToRemove!.BuildAnalyzer.FriendlyName, analyzerToRemove.Elapsed);
+                analyzerToRemove.BuildAnalyzer.Dispose();
+            }
+        }
+
+        public void ProcessEvaluationFinishedEventArgs(
+            AnalyzerLoggingContext buildAnalysisContext,
+            ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
+            => _buildEventsProcessor
+                .ProcessEvaluationFinishedEventArgs(buildAnalysisContext, evaluationFinishedEventArgs);
+
+        // Tracing: https://github.com/dotnet/msbuild/issues/9629
+        public Dictionary<string, TimeSpan> CreateTracingStats()
+        {
+            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            {
+                if (analyzerFactoryContext.MaterializedAnalyzer != null)
+                {
+                    _tracingReporter.AddStats(analyzerFactoryContext.FriendlyName,
+                        analyzerFactoryContext.MaterializedAnalyzer.Elapsed);
+                    analyzerFactoryContext.MaterializedAnalyzer.ClearStats();
+                }
+            }
+
+            return _tracingReporter.TracingStats;
+        }
+
+        public void FinalizeProcessing(LoggingContext loggingContext)
+        {
+            if (IsInProcNode)
+            {
+                // We do not want to send tracing stats from in-proc node
+                return;
+            }
+
+            BuildCheckTracingEventArgs eventArgs =
+                new(CreateTracingStats()) { BuildEventContext = loggingContext.BuildEventContext };
+            loggingContext.LogBuildEvent(eventArgs);
+        }
+
+        public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext,
+            string fullPath)
+        {
+            if (buildCheckDataSource == BuildCheckDataSource.EventArgs && IsInProcNode)
+            {
+                // Skipping this event - as it was already handled by the in-proc node.
+                // This is because in-proc node has the BuildEventArgs source and BuildExecution source
+                //  both in a single manager. The project started is first encountered by the execution before the EventArg is sent
+                return;
+            }
+
+            SetupAnalyzersForNewProject(fullPath, buildEventContext);
+        }
+
+        /*
+         *
+         * Following methods are for future use (should we decide to approach in-execution analysis)
+         *
+         */
+
+
+        public void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        {
+        }
+
+        public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        {
+        }
+
+        public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        {
+        }
+
+        public void Shutdown()
+        { /* Too late here for any communication to the main node or for logging anything */ }
+
+        private class BuildAnalyzerFactoryContext(
+            BuildAnalyzerFactory factory,
+            string[] ruleIds,
+            bool isEnabledByDefault)
+        {
+            public BuildAnalyzerWrapperFactory Factory { get; init; } = configContext =>
+            {
+                BuildAnalyzer ba = factory();
+                ba.Initialize(configContext);
+                return new BuildAnalyzerWrapper(ba);
+            };
+
+            public BuildAnalyzerWrapper? MaterializedAnalyzer { get; set; }
+
+            public string[] RuleIds { get; init; } = ruleIds;
+
+            public bool IsEnabledByDefault { get; init; } = isEnabledByDefault;
+
+            public string FriendlyName => MaterializedAnalyzer?.BuildAnalyzer.FriendlyName ?? factory().FriendlyName;
+        }
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
new file mode 100644
index 00000000000..9514f0a7ca0
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -0,0 +1,86 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Diagnostics;
+using System.Diagnostics.Tracing;
+using System.IO;
+using System.Linq;
+using System.Runtime.ConstrainedExecution;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Components.Caching;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Analyzers;
+using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal class BuildEventsProcessor(BuildCheckCentralContext buildCheckCentralContext)
+{
+    private readonly SimpleProjectRootElementCache _cache = new SimpleProjectRootElementCache();
+    private readonly BuildCheckCentralContext _buildCheckCentralContext = buildCheckCentralContext;
+
+    // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
+    internal void ProcessEvaluationFinishedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
+    {
+        Dictionary<string, string> propertiesLookup = new Dictionary<string, string>();
+        Internal.Utilities.EnumerateProperties(evaluationFinishedEventArgs.Properties, propertiesLookup,
+            static (dict, kvp) => dict.Add(kvp.Key, kvp.Value));
+
+        EvaluatedPropertiesAnalysisData analysisData =
+            new(evaluationFinishedEventArgs.ProjectFile!, propertiesLookup);
+
+        _buildCheckCentralContext.RunEvaluatedPropertiesActions(analysisData, buildAnalysisContext, ReportResult);
+
+        if (_buildCheckCentralContext.HasParsedItemsActions)
+        {
+            ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(
+                evaluationFinishedEventArgs.ProjectFile!, /*unused*/
+                null, /*unused*/null, _cache, false /*Not explicitly loaded - unused*/);
+
+            ParsedItemsAnalysisData itemsAnalysisData = new(evaluationFinishedEventArgs.ProjectFile!,
+                new ItemsHolder(xml.Items, xml.ItemGroups));
+
+            _buildCheckCentralContext.RunParsedItemsActions(itemsAnalysisData, buildAnalysisContext, ReportResult);
+        }
+    }
+
+    private static void ReportResult(
+        BuildAnalyzerWrapper analyzerWrapper,
+        LoggingContext loggingContext,
+        BuildAnalyzerConfigurationInternal[] configPerRule,
+        BuildCheckResult result)
+    {
+        if (!analyzerWrapper.BuildAnalyzer.SupportedRules.Contains(result.BuildAnalyzerRule))
+        {
+            loggingContext.LogErrorFromText(null, null, null,
+                BuildEventFileInfo.Empty,
+                $"The analyzer '{analyzerWrapper.BuildAnalyzer.FriendlyName}' reported a result for a rule '{result.BuildAnalyzerRule.Id}' that it does not support.");
+            return;
+        }
+
+        BuildAnalyzerConfigurationInternal config = configPerRule.Length == 1
+            ? configPerRule[0]
+            : configPerRule.First(r =>
+                r.RuleId.Equals(result.BuildAnalyzerRule.Id, StringComparison.CurrentCultureIgnoreCase));
+
+        if (!config.IsEnabled)
+        {
+            return;
+        }
+
+        BuildEventArgs eventArgs = result.ToEventArgs(config.Severity);
+        eventArgs.BuildEventContext = loggingContext.BuildEventContext;
+        loggingContext.LogBuildEvent(eventArgs);
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
new file mode 100644
index 00000000000..67c2155500e
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -0,0 +1,206 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.Json.Serialization;
+using System.Text.Json;
+using Microsoft.Build.Experimental.BuildCheck;
+using System.Configuration;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+
+// Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)
+// Tracked via: https://github.com/dotnet/msbuild/issues/9828
+internal static class ConfigurationProvider
+{
+    // We might want to have a mechanism for removing unneeded configurations
+    //  (disabled rules and analyzers that need to run in different node)
+    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();
+
+    // This is just a testing implementation for quicker unblock of testing.
+    // Real implementation will use .editorconfig file.
+    // Sample json:
+    /////*lang=json,strict*/
+    ////"""
+    ////    {
+    ////        "ABC123": {
+    ////            "IsEnabled": true,
+    ////            "Severity": "Info"
+    ////        },
+    ////        "COND0543": {
+    ////            "IsEnabled": false,
+    ////            "Severity": "Error",
+    ////    		"EvaluationAnalysisScope": "AnalyzedProjectOnly",
+    ////    		"CustomSwitch": "QWERTY"
+    ////        },
+    ////        "BLA": {
+    ////            "IsEnabled": false
+    ////        }
+    ////    }
+    ////    """
+    //
+    // Plus there will need to be a mechanism of distinguishing different configs in different folders
+    //  - e.g. - what to do if we analyze two projects (not sharing output path) and they have different .editorconfig files?
+    private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration()
+    {
+        const string configFileName = "editorconfig.json";
+        string configPath = configFileName;
+
+        if (!File.Exists(configPath))
+        {
+            // This is just a dummy implementation for testing purposes
+            var dir = Environment.CurrentDirectory;
+            configPath = Path.Combine(dir, configFileName);
+
+            if (!File.Exists(configPath))
+            {
+                return new Dictionary<string, BuildAnalyzerConfiguration>();
+            }
+        }
+
+        var json = File.ReadAllText(configPath);
+        var DeserializationOptions = new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() } };
+        return JsonSerializer.Deserialize<Dictionary<string, BuildAnalyzerConfiguration>>(json, DeserializationOptions) ??
+               new Dictionary<string, BuildAnalyzerConfiguration>();
+    }
+
+    /// <summary>
+    /// Gets the user specified unrecognized configuration for the given analyzer rule.
+    /// 
+    /// The configuration module should as well check that CustomConfigurationData
+    ///  for a particular rule is equal across the whole build (for all projects)  - otherwise it should error out.
+    /// This should apply to all rules for which the configuration is fetched.
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <param name="ruleId"></param>
+    /// <returns></returns>
+    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)
+    {
+        return CustomConfigurationData.Null;
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <param name="ruleId"></param>
+    /// <throws><see cref="BuildCheckConfigurationException"/> If CustomConfigurationData differs in a build for a same ruleId</throws>
+    /// <returns></returns>
+    public static void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
+    {
+        // TBD
+    }
+
+    public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+        string projectFullPath,
+        BuildAnalyzer analyzer)
+        => FillConfiguration(projectFullPath, analyzer.SupportedRules, GetMergedConfiguration);
+
+    public static BuildAnalyzerConfiguration[] GetUserConfigurations(
+        string projectFullPath,
+        IReadOnlyList<string> ruleIds)
+        => FillConfiguration(projectFullPath, ruleIds, GetUserConfiguration);
+
+    public static CustomConfigurationData[] GetCustomConfigurations(
+        string projectFullPath,
+        IReadOnlyList<string> ruleIds)
+        => FillConfiguration(projectFullPath, ruleIds, GetCustomConfiguration);
+
+    public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+        BuildAnalyzerConfiguration[] userConfigs,
+        BuildAnalyzer analyzer)
+    {
+        var configurations = new BuildAnalyzerConfigurationInternal[userConfigs.Length];
+
+        for (int idx = 0; idx < userConfigs.Length; idx++)
+        {
+            configurations[idx] = ConfigurationProvider.MergeConfiguration(
+                analyzer.SupportedRules[idx].Id,
+                analyzer.SupportedRules[idx].DefaultConfiguration,
+                userConfigs[idx]);
+        }
+
+        return configurations;
+    }
+
+    private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPath, IReadOnlyList<TRule> ruleIds, Func<string, TRule, TConfig> configurationProvider)
+    {
+        TConfig[] configurations = new TConfig[ruleIds.Count];
+        for (int i = 0; i < ruleIds.Count; i++)
+        {
+            configurations[i] = configurationProvider(projectFullPath, ruleIds[i]);
+        }
+
+        return configurations;
+    }
+
+    /// <summary>
+    /// Gets effective user specified (or default) configuration for the given analyzer rule.
+    /// The configuration values CAN be null upon this operation.
+    /// 
+    /// The configuration module should as well check that BuildAnalyzerConfigurationInternal.EvaluationAnalysisScope
+    ///  for all rules is equal - otherwise it should error out.
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <param name="ruleId"></param>
+    /// <returns></returns>
+    public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
+    {
+        if (!_editorConfig.TryGetValue(ruleId, out BuildAnalyzerConfiguration? editorConfig))
+        {
+            editorConfig = BuildAnalyzerConfiguration.Null;
+        }
+
+        return editorConfig;
+    }
+
+    /// <summary>
+    /// Gets effective configuration for the given analyzer rule.
+    /// The configuration values are guaranteed to be non-null upon this merge operation.
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <param name="analyzerRule"></param>
+    /// <returns></returns>
+    public static BuildAnalyzerConfigurationInternal GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
+        => GetMergedConfiguration(projectFullPath, analyzerRule.Id, analyzerRule.DefaultConfiguration);
+
+    public static BuildAnalyzerConfigurationInternal MergeConfiguration(
+        string ruleId,
+        BuildAnalyzerConfiguration defaultConfig,
+        BuildAnalyzerConfiguration editorConfig)
+        => new BuildAnalyzerConfigurationInternal(
+            ruleId: ruleId,
+            evaluationAnalysisScope: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationAnalysisScope),
+            isEnabled: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.IsEnabled),
+            severity: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.Severity));
+
+    private static BuildAnalyzerConfigurationInternal GetMergedConfiguration(
+        string projectFullPath,
+        string ruleId,
+        BuildAnalyzerConfiguration defaultConfig)
+        => MergeConfiguration(ruleId, defaultConfig, GetUserConfiguration(projectFullPath, ruleId));
+
+    private static T GetConfigValue<T>(
+        BuildAnalyzerConfiguration editorConfigValue,
+        BuildAnalyzerConfiguration defaultValue,
+        Func<BuildAnalyzerConfiguration, T?> propertyGetter) where T : struct
+        => propertyGetter(editorConfigValue) ??
+           propertyGetter(defaultValue) ??
+           EnsureNonNull(propertyGetter(BuildAnalyzerConfiguration.Default));
+
+    private static T EnsureNonNull<T>(T? value) where T : struct
+    {
+        if (value is null)
+        {
+            throw new InvalidOperationException("Value is null");
+        }
+
+        return value.Value;
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
new file mode 100644
index 00000000000..d200d48ee66
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
@@ -0,0 +1,64 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Holder for the key-value pairs of unstructured data from .editorconfig file,
+///  that were attribute to a particular rule, but were not recognized by the infrastructure.
+/// The configuration data that is recognized by the infrastructure is passed as <see cref="BuildAnalyzerConfiguration"/>.
+/// </summary>
+/// <param name="ruleId"></param>
+public class CustomConfigurationData(string ruleId)
+{
+    public static CustomConfigurationData Null { get; } = new(string.Empty);
+
+    public static bool NotNull(CustomConfigurationData data) => !Null.Equals(data);
+
+    /// <summary>
+    /// Identifier of the rule that the configuration data is for.
+    /// </summary>
+    public string RuleId { get; init; } = ruleId;
+
+    /// <summary>
+    /// Key-value pairs of unstructured data from .editorconfig file.
+    /// E.g. if in editorconfig file we'd have:
+    /// [*.csrpoj]
+    /// build_analyzer.microsoft.BC0101.name_of_targets_to_restrict = "Build,CoreCompile,ResolveAssemblyReferences"
+    ///
+    /// the ConfigurationData would be:
+    /// "name_of_targets_to_restrict" -> "Build,CoreCompile,ResolveAssemblyReferences"
+    /// </summary>
+    public IReadOnlyDictionary<string, string>? ConfigurationData { get; init; }
+
+    public override bool Equals(object? obj)
+    {
+        if (ReferenceEquals(null, obj))
+        {
+            return false;
+        }
+
+        if (ReferenceEquals(this, obj))
+        {
+            return true;
+        }
+
+        if (obj.GetType() != this.GetType())
+        {
+            return false;
+        }
+
+        return Equals((CustomConfigurationData)obj);
+    }
+
+    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);
+
+    public override int GetHashCode() => (ConfigurationData != null ? ConfigurationData.GetHashCode() : 0);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
new file mode 100644
index 00000000000..331502e95e0
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -0,0 +1,64 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Enumerates the different data sources used in build check operations.
+/// </summary>
+internal enum BuildCheckDataSource
+{
+    /// <summary>
+    /// The data source is based on event arguments.
+    /// </summary>
+    EventArgs,
+
+    /// <summary>
+    /// The data source is based on build execution.
+    /// </summary>
+    BuildExecution,
+
+    /// <summary>
+    /// Represents the total number of values in the enum, used for indexing purposes.
+    /// </summary>
+    ValuesCount = BuildExecution + 1,
+}
+
+/// <summary>
+/// The central manager for the BuildCheck - this is the integration point with MSBuild infrastructure.
+/// </summary>
+internal interface IBuildCheckManager
+{
+    void ProcessEvaluationFinishedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs);
+
+    void SetDataSource(BuildCheckDataSource buildCheckDataSource);
+
+    void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext);
+
+    Dictionary<string, TimeSpan> CreateTracingStats();
+
+    void FinalizeProcessing(LoggingContext loggingContext);
+
+    // All those to be called from RequestBuilder,
+    //  but as well from the ConnectorLogger - as even if interleaved, it gives the info
+    //  to manager about what analyzers need to be materialized and configuration fetched.
+    // No unloading of analyzers is yet considered - once loaded it stays for whole build.
+    void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext, string fullPath);
+
+    void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
+
+    void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
+
+    void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
+
+    void Shutdown();
+}
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs
new file mode 100644
index 00000000000..6b8bdea6080
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs
@@ -0,0 +1,17 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal interface IBuildCheckManagerProvider : IBuildComponent
+{
+    IBuildCheckManager Instance { get; }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
new file mode 100644
index 00000000000..45ed260d425
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -0,0 +1,63 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal class NullBuildCheckManager : IBuildCheckManager
+{
+    public void Shutdown()
+    {
+    }
+
+    public void ProcessEvaluationFinishedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs)
+    {
+    }
+
+    public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
+    {
+    }
+
+    public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext) 
+    {
+    }
+
+    public Dictionary<string, TimeSpan> CreateTracingStats() => throw new NotImplementedException();
+
+    public void FinalizeProcessing(LoggingContext loggingContext)
+    {
+    }
+
+    public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext, string fullPath)
+    {
+    }
+
+    public void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    {
+    }
+
+    public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    {
+    }
+
+    public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    {
+    }
+
+    public void YieldProject(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    {
+    }
+
+    public void ResumeProject(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    {
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs
new file mode 100644
index 00000000000..c6dcbd84f8d
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs
@@ -0,0 +1,20 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal class NullBuildCheckManagerProvider : IBuildCheckManagerProvider
+{
+    public IBuildCheckManager Instance { get; } = new NullBuildCheckManager();
+
+    public void InitializeComponent(IBuildComponentHost host) { }
+    public void ShutdownComponent() { }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
new file mode 100644
index 00000000000..2d6d850737b
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
@@ -0,0 +1,27 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal class TracingReporter
+{
+    internal Dictionary<string, TimeSpan> TracingStats { get; } = new();
+
+    public void AddStats(string name, TimeSpan subtotal)
+    {
+        if (TracingStats.TryGetValue(name, out TimeSpan existing))
+        {
+            TracingStats[name] = existing + subtotal;
+        }
+        else
+        {
+            TracingStats[name] = subtotal;
+        }
+    }
+}
diff --git a/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs b/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs
new file mode 100644
index 00000000000..1b3eb9cb4bb
--- /dev/null
+++ b/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs
@@ -0,0 +1,22 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.BuildCheck.Logging;
+
+internal class AnalyzerLoggingContext : LoggingContext
+{
+    public AnalyzerLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
+        : base(loggingService, eventContext)
+    {
+        IsValid = true;
+    }
+
+    public AnalyzerLoggingContext(LoggingContext baseContext) : base(baseContext)
+    {
+        IsValid = true;
+    }
+}
diff --git a/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs b/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs
new file mode 100644
index 00000000000..3b1e035aed9
--- /dev/null
+++ b/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs
@@ -0,0 +1,14 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.BuildCheck.Logging;
+
+internal class AnalyzerLoggingContextFactory(ILoggingService loggingService) : IBuildAnalysisLoggingContextFactory
+{
+    public AnalyzerLoggingContext CreateLoggingContext(BuildEventContext eventContext) =>
+        new AnalyzerLoggingContext(loggingService, eventContext);
+}
diff --git a/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs b/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs
new file mode 100644
index 00000000000..e5188703ff7
--- /dev/null
+++ b/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs
@@ -0,0 +1,12 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+internal interface IBuildAnalysisLoggingContextFactory
+{
+    AnalyzerLoggingContext CreateLoggingContext(BuildEventContext eventContext);
+}
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
new file mode 100644
index 00000000000..d0738fe6b71
--- /dev/null
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -0,0 +1,64 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Base for a data passed from infrastructure to build analyzers.
+/// </summary>
+/// <param name="projectFilePath">Currently build project.</param>
+public abstract class AnalysisData(string projectFilePath)
+{
+    /// <summary>
+    /// Full path to the project file being built.
+    /// </summary>
+    public string ProjectFilePath { get; } = projectFilePath;
+}
+
+/// <summary>
+/// Data passed from infrastructure to build analyzers.
+/// </summary>
+/// <typeparam name="T">The type of the actual data for analysis.</typeparam>
+public class BuildCheckDataContext<T> where T : AnalysisData
+{
+    private readonly BuildAnalyzerWrapper _analyzerWrapper;
+    private readonly LoggingContext _loggingContext;
+    private readonly BuildAnalyzerConfigurationInternal[] _configPerRule;
+    private readonly Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult> _resultHandler;
+
+    internal BuildCheckDataContext(
+        BuildAnalyzerWrapper analyzerWrapper,
+        LoggingContext loggingContext,
+        BuildAnalyzerConfigurationInternal[] configPerRule,
+        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult> resultHandler,
+        T data)
+    {
+        _analyzerWrapper = analyzerWrapper;
+        _loggingContext = loggingContext;
+        _configPerRule = configPerRule;
+        _resultHandler = resultHandler;
+        Data = data;
+    }
+
+    /// <summary>
+    /// Method for reporting the result of the build analyzer rule.
+    /// </summary>
+    /// <param name="result"></param>
+    public void ReportResult(BuildCheckResult result)
+        => _resultHandler(_analyzerWrapper, _loggingContext, _configPerRule, result);
+
+    /// <summary>
+    /// Data to be analyzed.
+    /// </summary>
+    public T Data { get; }
+}
diff --git a/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs b/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
new file mode 100644
index 00000000000..f3a336a41ec
--- /dev/null
+++ b/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
@@ -0,0 +1,20 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Logging;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// BuildCheck OM data representing the evaluated properties of a project.
+/// </summary>
+public class EvaluatedPropertiesAnalysisData : AnalysisData
+{
+    internal EvaluatedPropertiesAnalysisData(
+        string projectFilePath,
+        IReadOnlyDictionary<string, string> evaluatedProperties) :
+        base(projectFilePath) => EvaluatedProperties = evaluatedProperties;
+
+    public IReadOnlyDictionary<string, string> EvaluatedProperties { get; }
+}
diff --git a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs b/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
new file mode 100644
index 00000000000..a6b34446258
--- /dev/null
+++ b/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
@@ -0,0 +1,55 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Extension methods for <see cref="ProjectItemElement"/>.
+/// </summary>
+public static class ItemTypeExtensions
+{
+    public static IEnumerable<ProjectItemElement> GetItemsOfType(this IEnumerable<ProjectItemElement> items,
+        string itemType)
+    {
+        return items.Where(i =>
+            MSBuildNameIgnoreCaseComparer.Default.Equals(i.ItemType, itemType));
+    }
+}
+
+/// <summary>
+/// Holder for evaluated items and item groups.
+/// </summary>
+/// <param name="items"></param>
+/// <param name="itemGroups"></param>
+public class ItemsHolder(IEnumerable<ProjectItemElement> items, IEnumerable<ProjectItemGroupElement> itemGroups)
+{
+    public IEnumerable<ProjectItemElement> Items { get; } = items;
+    public IEnumerable<ProjectItemGroupElement> ItemGroups { get; } = itemGroups;
+
+    public IEnumerable<ProjectItemElement> GetItemsOfType(string itemType)
+    {
+        return Items.GetItemsOfType(itemType);
+    }
+}
+
+/// <summary>
+/// BuildCheck OM data representing the evaluated items of a project.
+/// </summary>
+public class ParsedItemsAnalysisData : AnalysisData
+{
+    internal ParsedItemsAnalysisData(
+        string projectFilePath,
+        ItemsHolder itemsHolder) :
+        base(projectFilePath) => ItemsHolder = itemsHolder;
+
+    public ItemsHolder ItemsHolder { get; }
+}
diff --git a/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs b/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
new file mode 100644
index 00000000000..96efc8ff2fd
--- /dev/null
+++ b/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
@@ -0,0 +1,51 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+internal static class EnumerableExtensions
+{
+    /// <summary>
+    /// Concatenates items of input sequence into csv string.
+    /// </summary>
+    /// <typeparam name="T"></typeparam>
+    /// <param name="source">Sequence to be turned into csv string.</param>
+    /// <param name="useSpace">Indicates whether space should be inserted between commas and following items.</param>
+    /// <returns>Csv string.</returns>
+    public static string ToCsvString<T>(this IEnumerable<T>? source, bool useSpace = true)
+    {
+        return source == null ? "<NULL>" : string.Join(useSpace ? ", " : ",", source);
+    }
+
+    /// <summary>
+    /// Adds a content of given dictionary to current dictionary.
+    /// </summary>
+    /// <typeparam name="TKey"></typeparam>
+    /// <typeparam name="TValue"></typeparam>
+    /// <param name="dict">Dictionary to receive another values.</param>
+    /// <param name="another">Dictionary to be merged into current.</param>
+    /// <param name="mergeValues">Way of resolving keys conflicts.</param>
+    public static void Merge<TKey, TValue>(
+        this IDictionary<TKey, TValue> dict,
+        IReadOnlyDictionary<TKey, TValue> another,
+        Func<TValue, TValue, TValue> mergeValues)
+    {
+        foreach (var pair in another)
+        {
+            if (!dict.TryGetValue(pair.Key, out TValue? value))
+            {
+                dict[pair.Key] = pair.Value;
+            }
+            else
+            {
+                dict[pair.Key] = mergeValues(value, pair.Value);
+            }
+        }
+    }
+}
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 2dd2bb89a95..c9bf42b48b2 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -80,7 +80,7 @@ public string LocationString
         /// It is to be used for the project location when the project has not been given a name.
         /// In that case, it exists, but can't have a specific location.
         /// </summary>
-        internal static ElementLocation EmptyLocation
+        public static ElementLocation EmptyLocation
         {
             get { return s_emptyElementLocation; }
         }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 780d58db6b1..85447378533 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -163,7 +163,7 @@ internal class Evaluator<P, I, M, D>
         private readonly ProjectRootElementCacheBase _projectRootElementCache;
 
         /// <summary>
-        /// The logging context to be used and piped down throughout evaluation
+        /// The logging context to be used and piped down throughout evaluation.
         /// </summary>
         private EvaluationLoggingContext _evaluationLoggingContext;
 
@@ -242,7 +242,7 @@ private Evaluator(
             // Create containers for the evaluation results
             data.InitializeForEvaluation(toolsetProvider, _evaluationContext);
 
-            _expander = new Expander<P, I>(data, data, _evaluationContext);
+            _expander = new Expander<P, I>(data, data, _evaluationContext, _evaluationLoggingContext);
 
             // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.
             _expander.WarnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index c8c3d32f072..ffbdbb5e855 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -311,6 +311,8 @@ private void FlushFirstValueIfNeeded()
 
         private readonly IFileSystem _fileSystem;
 
+        private readonly LoggingContext _loggingContext;
+
         /// <summary>
         /// Non-null if the expander was constructed for evaluation.
         /// </summary>
@@ -350,6 +352,7 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFile
         }
 
         /// <summary>
+        /// Initializes a new instance of the <see cref="Expander{P, I}"/> class.
         /// Creates an expander passing it some properties and items to use, and the evaluation context.
         /// Either or both may be null.
         /// </summary>
@@ -359,6 +362,21 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, Evalu
             _items = items;
         }
 
+        /// <summary>
+        /// Initializes a new instance of the <see cref="Expander{P, I}"/> class with the specified property provider, item provider, evaluation context, and logging context.
+        /// </summary>
+        /// <param name="properties">The property provider supplying properties for expansion.</param>
+        /// <param name="items">The item provider supplying items for expansion.</param>
+        /// <param name="evaluationContext">The evaluation context used during expansion.</param>
+        /// <param name="loggingContext">The logging context used for logging or emmitting events during expansion.</param>
+        /// <exception cref="ArgumentNullException">Thrown when either <paramref name="properties"/> or <paramref name="evaluationContext"/> is null.</exception>
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext, LoggingContext loggingContext)
+            : this(properties, evaluationContext)
+        {
+            _items = items;
+            _loggingContext = loggingContext;
+        }
+
         /// <summary>
         /// Creates an expander passing it some properties, items, and/or metadata to use.
         /// Any or all may be null.
@@ -1253,7 +1271,8 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                                 options,
                                 elementLocation,
                                 usedUninitializedProperties,
-                                fileSystem);
+                                fileSystem,
+                                loggingContext);
                         }
                         else // This is a regular property
                         {
@@ -1301,7 +1320,8 @@ internal static object ExpandPropertyBody(
                 ExpanderOptions options,
                 IElementLocation elementLocation,
                 UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem)
+                IFileSystem fileSystem,
+                LoggingContext loggingContext)
             {
                 Function<T> function = null;
                 string propertyName = propertyBody;
@@ -1332,7 +1352,8 @@ internal static object ExpandPropertyBody(
                             elementLocation,
                             propertyValue,
                             usedUninitializedProperties,
-                            fileSystem);
+                            fileSystem,
+                            loggingContext);
 
                         // We may not have been able to parse out a function
                         if (function != null)
@@ -1371,7 +1392,8 @@ internal static object ExpandPropertyBody(
                                 options,
                                 elementLocation,
                                 usedUninitializedProperties,
-                                fileSystem);
+                                fileSystem,
+                                loggingContext);
                         }
                     }
                     else
@@ -2734,7 +2756,8 @@ internal static IEnumerable<KeyValuePair<string, S>> ExecuteStringFunction(
                             BindingFlags.Public | BindingFlags.InvokeMethod,
                             string.Empty,
                             expander.UsedUninitializedProperties,
-                            expander._fileSystem);
+                            expander._fileSystem,
+                            expander._loggingContext);
 
                         object result = function.Execute(item.Key, expander._properties, ExpanderOptions.ExpandAll, elementLocation);
 
@@ -3159,6 +3182,8 @@ private struct FunctionBuilder<T>
 
             public IFileSystem FileSystem { get; set; }
 
+            public LoggingContext LoggingContext { get; set; }
+
             /// <summary>
             /// List of properties which have been used but have not been initialized yet.
             /// </summary>
@@ -3175,7 +3200,8 @@ internal readonly Function<T> Build()
                     BindingFlags,
                     Remainder,
                     UsedUninitializedProperties,
-                    FileSystem);
+                    FileSystem,
+                    LoggingContext);
             }
         }
 
@@ -3195,22 +3221,22 @@ internal class Function<T>
             /// <summary>
             /// The name of the function.
             /// </summary>
-            private string _methodMethodName;
+            private readonly string _methodMethodName;
 
             /// <summary>
             /// The arguments for the function.
             /// </summary>
-            private string[] _arguments;
+            private readonly string[] _arguments;
 
             /// <summary>
             /// The expression that this function is part of.
             /// </summary>
-            private string _expression;
+            private readonly string _expression;
 
             /// <summary>
             /// The property name that this function is applied on.
             /// </summary>
-            private string _receiver;
+            private readonly string _receiver;
 
             /// <summary>
             /// The binding flags that will be used during invocation of this function.
@@ -3220,14 +3246,16 @@ internal class Function<T>
             /// <summary>
             /// The remainder of the body once the function and arguments have been extracted.
             /// </summary>
-            private string _remainder;
+            private readonly string _remainder;
 
             /// <summary>
             /// List of properties which have been used but have not been initialized yet.
             /// </summary>
-            private UsedUninitializedProperties _usedUninitializedProperties;
+            private readonly UsedUninitializedProperties _usedUninitializedProperties;
+
+            private readonly IFileSystem _fileSystem;
 
-            private IFileSystem _fileSystem;
+            private readonly LoggingContext _loggingContext;
 
             /// <summary>
             /// Construct a function that will be executed during property evaluation.
@@ -3241,7 +3269,8 @@ internal Function(
                 BindingFlags bindingFlags,
                 string remainder,
                 UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem)
+                IFileSystem fileSystem,
+                LoggingContext loggingContext)
             {
                 _methodMethodName = methodName;
                 if (arguments == null)
@@ -3260,6 +3289,7 @@ internal Function(
                 _remainder = remainder;
                 _usedUninitializedProperties = usedUninitializedProperties;
                 _fileSystem = fileSystem;
+                _loggingContext = loggingContext;
             }
 
             /// <summary>
@@ -3282,10 +3312,11 @@ internal static Function<T> ExtractPropertyFunction(
                 IElementLocation elementLocation,
                 object propertyValue,
                 UsedUninitializedProperties usedUnInitializedProperties,
-                IFileSystem fileSystem)
+                IFileSystem fileSystem,
+                LoggingContext loggingContext)
             {
                 // Used to aggregate all the components needed for a Function
-                FunctionBuilder<T> functionBuilder = new FunctionBuilder<T> { FileSystem = fileSystem };
+                FunctionBuilder<T> functionBuilder = new FunctionBuilder<T> { FileSystem = fileSystem, LoggingContext = loggingContext };
 
                 // By default the expression root is the whole function expression
                 ReadOnlySpan<char> expressionRoot = expressionFunction == null ? ReadOnlySpan<char>.Empty : expressionFunction.AsSpan();
@@ -3591,7 +3622,8 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                         options,
                         elementLocation,
                         _usedUninitializedProperties,
-                        _fileSystem);
+                        _fileSystem,
+                        _loggingContext);
                 }
 
                 // Exceptions coming from the actual function called are wrapped in a TargetInvocationException
@@ -3885,6 +3917,16 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                     }
                     else if (_receiverType == typeof(IntrinsicFunctions))
                     {
+                        if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RegisterAnalyzer), StringComparison.OrdinalIgnoreCase))
+                        {
+                            ErrorUtilities.VerifyThrow(_loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterAnalyzer)} can not be invoked.");
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.RegisterAnalyzer(arg0, _loggingContext);
+                                return true;
+                            }
+                        }
+
                         if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.EnsureTrailingSlash), StringComparison.OrdinalIgnoreCase))
                         {
                             if (TryGetArg(args, out string arg0))
@@ -4187,6 +4229,14 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.SubstringByTextElements), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out string arg0, out int arg1, out int arg2))
+                            {
+                                returnVal = IntrinsicFunctions.SubstringByTextElements(arg0, arg1, arg2);
+                                return true;
+                            }
+                        }
                         else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.CheckFeatureAvailability), StringComparison.OrdinalIgnoreCase))
                         {
                             if (TryGetArg(args, out string arg0))
@@ -4518,6 +4568,32 @@ private bool TryGetArgs(object[] args, out string arg0, out string arg1)
                 return false;
             }
 
+            private static bool TryGetArgs(object[] args, out string arg0, out int arg1, out int arg2)
+            {
+                arg0 = null;
+                arg1 = 0;
+                arg2 = 0;
+
+                if (args.Length != 3)
+                {
+                    return false;
+                }
+
+                var value1 = args[1] as string;
+                var value2 = args[2] as string;
+                arg0 = args[0] as string;
+                if (value1 != null &&
+                    value2 != null &&
+                    arg0 != null &&
+                    int.TryParse(value1, out arg1) &&
+                    int.TryParse(value2, out arg2))
+                {
+                    return true;
+                }
+
+                return false;
+            }
+
             private static bool TryGetArg(object[] args, out int arg0)
             {
                 if (args.Length != 1)
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 6f8c5ed00f6..611b8af238d 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -9,7 +9,9 @@
 using System.Runtime.Versioning;
 using System.Text;
 using System.Text.RegularExpressions;
-
+using System.Globalization;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -27,7 +29,7 @@ namespace Microsoft.Build.Evaluation
 {
     /// <summary>
     /// The Intrinsic class provides static methods that can be accessed from MSBuild's
-    /// property functions using $([MSBuild]::Function(x,y))
+    /// property functions using $([MSBuild]::Function(x,y)).
     /// </summary>
     internal static class IntrinsicFunctions
     {
@@ -291,6 +293,7 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
                         return string.Empty;
                     }
 
+#pragma warning disable CA2000 // Dispose objects before losing scope is false positive here.
                     using (RegistryKey key = GetBaseKeyFromKeyName(keyName, view, out string subKeyName))
                     {
                         if (key != null)
@@ -311,6 +314,7 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
                             }
                         }
                     }
+#pragma warning restore CA2000 // Dispose objects before losing scope
                 }
             }
 
@@ -446,12 +450,13 @@ internal static object StableStringHash(string toHash, StringHashingAlgorithm al
 
         private static string CalculateSha256(string toHash)
         {
-            var sha = System.Security.Cryptography.SHA256.Create();
+            using var sha = System.Security.Cryptography.SHA256.Create();
             var hashResult = new StringBuilder();
             foreach (byte theByte in sha.ComputeHash(Encoding.UTF8.GetBytes(toHash)))
             {
                 hashResult.Append(theByte.ToString("x2"));
             }
+
             return hashResult.ToString();
         }
 
@@ -624,6 +629,12 @@ internal static bool AreFeaturesEnabled(Version wave)
             return ChangeWaves.AreFeaturesEnabled(wave);
         }
 
+        internal static string SubstringByTextElements(string input, int start, int length)
+        {
+            StringInfo stringInfo = new StringInfo(input);
+            return stringInfo.SubstringByTextElements(start, length);
+        }
+
         internal static string CheckFeatureAvailability(string featureName)
         {
             return Features.CheckFeatureAvailability(featureName).ToString();
@@ -664,9 +675,21 @@ public static string GetMSBuildExtensionsPath()
             return BuildEnvironmentHelper.Instance.MSBuildExtensionsPath;
         }
 
-        public static bool IsRunningFromVisualStudio()
+        public static bool IsRunningFromVisualStudio() => BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio;
+
+        public static bool RegisterAnalyzer(string pathToAssembly, LoggingContext loggingContext)
         {
-            return BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio;
+            pathToAssembly = FileUtilities.GetFullPathNoThrow(pathToAssembly);
+            if (File.Exists(pathToAssembly))
+            {
+                loggingContext.LogBuildEvent(new BuildCheckAcquisitionEventArgs(pathToAssembly));
+
+                return true;
+            }
+
+            loggingContext.LogComment(MessageImportance.Low, "CustomAnalyzerAssemblyNotExist", pathToAssembly);
+
+            return false;
         }
 
         #region Debug only intrinsics
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index 9dfd281b165..d40ea3145fa 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
+using System.Diagnostics.CodeAnalysis;
 using System.Linq;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
@@ -33,6 +34,7 @@ public IncludeOperation(IncludeOperationBuilder builder, LazyItemEvaluator<P, I,
                 _metadata = builder.Metadata.ToImmutable();
             }
 
+            [SuppressMessage("Microsoft.Dispose", "CA2000:Dispose objects before losing scope", Justification = "_lazyEvaluator._evaluationProfiler has own dipose logic.")]
             protected override ImmutableArray<I> SelectItems(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
                 ImmutableArray<I>.Builder? itemsToAdd = null;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 485162b1638..6bf5b325d63 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -45,7 +45,7 @@ protected LazyItemOperation(OperationBuilder builder, LazyItemEvaluator<P, I, M,
 
                 _evaluatorData = new EvaluatorData(_lazyEvaluator._outerEvaluatorData, _referencedItemLists);
                 _itemFactory = new ItemFactoryWrapper(_itemElement, _lazyEvaluator._itemFactory);
-                _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, _lazyEvaluator.EvaluationContext);
+                _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, _lazyEvaluator.EvaluationContext, _lazyEvaluator._loggingContext);
 
                 _itemSpec.Expander = _expander;
             }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index bd34997b839..bb298ee7662 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -46,12 +46,13 @@ internal partial class LazyItemEvaluator<P, I, M, D>
         protected EvaluationContext EvaluationContext { get; }
 
         protected IFileSystem FileSystem => EvaluationContext.FileSystem;
+
         protected FileMatcher FileMatcher => EvaluationContext.FileMatcher;
 
         public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> itemFactory, LoggingContext loggingContext, EvaluationProfiler evaluationProfiler, EvaluationContext evaluationContext)
         {
             _outerEvaluatorData = data;
-            _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext);
+            _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext, loggingContext);
             _evaluatorData = new EvaluatorData(_outerEvaluatorData, _itemLists);
             _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext);
             _itemFactory = itemFactory;
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index dabd4276bc6..311392df81f 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -38,6 +38,8 @@ internal class GraphBuilder
 
         public GraphEdges Edges { get; private set; }
 
+        public SolutionFile Solution { get; private set; }
+
         private readonly List<ConfigurationMetadata> _entryPointConfigurationMetadata;
 
         private readonly ParallelWorkSet<ConfigurationMetadata, ParsedProject> _graphWorkSet;
@@ -269,43 +271,43 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                 solutionGlobalPropertiesBuilder.AddRange(solutionEntryPoint.GlobalProperties);
             }
 
-            var solution = SolutionFile.Parse(solutionEntryPoint.ProjectFile);
+            Solution = SolutionFile.Parse(solutionEntryPoint.ProjectFile);
 
-            if (solution.SolutionParserWarnings.Count != 0 || solution.SolutionParserErrorCodes.Count != 0)
+            if (Solution.SolutionParserWarnings.Count != 0 || Solution.SolutionParserErrorCodes.Count != 0)
             {
                 throw new InvalidProjectFileException(
                     ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                         "StaticGraphSolutionLoaderEncounteredSolutionWarningsAndErrors",
                         solutionEntryPoint.ProjectFile,
-                        string.Join(";", solution.SolutionParserWarnings),
-                        string.Join(";", solution.SolutionParserErrorCodes)));
+                        string.Join(";", Solution.SolutionParserWarnings),
+                        string.Join(";", Solution.SolutionParserErrorCodes)));
             }
 
             // Mimic behavior of SolutionProjectGenerator
-            SolutionConfigurationInSolution currentSolutionConfiguration = SelectSolutionConfiguration(solution, solutionEntryPoint.GlobalProperties);
+            SolutionConfigurationInSolution currentSolutionConfiguration = SelectSolutionConfiguration(Solution, solutionEntryPoint.GlobalProperties);
             solutionGlobalPropertiesBuilder["Configuration"] = currentSolutionConfiguration.ConfigurationName;
             solutionGlobalPropertiesBuilder["Platform"] = currentSolutionConfiguration.PlatformName;
 
-            string solutionConfigurationXml = SolutionProjectGenerator.GetSolutionConfiguration(solution, currentSolutionConfiguration);
+            string solutionConfigurationXml = SolutionProjectGenerator.GetSolutionConfiguration(Solution, currentSolutionConfiguration);
             solutionGlobalPropertiesBuilder["CurrentSolutionConfigurationContents"] = solutionConfigurationXml;
             solutionGlobalPropertiesBuilder["BuildingSolutionFile"] = "true";
 
-            string solutionDirectoryName = solution.SolutionFileDirectory;
+            string solutionDirectoryName = Solution.SolutionFileDirectory;
             if (!solutionDirectoryName.EndsWith(Path.DirectorySeparatorChar.ToString(), StringComparison.Ordinal))
             {
                 solutionDirectoryName += Path.DirectorySeparatorChar;
             }
 
             solutionGlobalPropertiesBuilder["SolutionDir"] = EscapingUtilities.Escape(solutionDirectoryName);
-            solutionGlobalPropertiesBuilder["SolutionExt"] = EscapingUtilities.Escape(Path.GetExtension(solution.FullPath));
-            solutionGlobalPropertiesBuilder["SolutionFileName"] = EscapingUtilities.Escape(Path.GetFileName(solution.FullPath));
-            solutionGlobalPropertiesBuilder["SolutionName"] = EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(solution.FullPath));
-            solutionGlobalPropertiesBuilder[SolutionProjectGenerator.SolutionPathPropertyName] = EscapingUtilities.Escape(Path.Combine(solution.SolutionFileDirectory, Path.GetFileName(solution.FullPath)));
+            solutionGlobalPropertiesBuilder["SolutionExt"] = EscapingUtilities.Escape(Path.GetExtension(Solution.FullPath));
+            solutionGlobalPropertiesBuilder["SolutionFileName"] = EscapingUtilities.Escape(Path.GetFileName(Solution.FullPath));
+            solutionGlobalPropertiesBuilder["SolutionName"] = EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(Solution.FullPath));
+            solutionGlobalPropertiesBuilder[SolutionProjectGenerator.SolutionPathPropertyName] = EscapingUtilities.Escape(Path.Combine(Solution.SolutionFileDirectory, Path.GetFileName(Solution.FullPath)));
 
             // Project configurations are reused heavily, so cache the global properties for each
             Dictionary<string, ImmutableDictionary<string, string>> globalPropertiesForProjectConfiguration = new(StringComparer.OrdinalIgnoreCase);
 
-            IReadOnlyList<ProjectInSolution> projectsInSolution = solution.ProjectsInOrder;
+            IReadOnlyList<ProjectInSolution> projectsInSolution = Solution.ProjectsInOrder;
             List<ProjectGraphEntryPoint> newEntryPoints = new(projectsInSolution.Count);
             Dictionary<string, IReadOnlyCollection<string>> solutionDependencies = new();
 
@@ -318,7 +320,7 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
 
                 ProjectConfigurationInSolution projectConfiguration = SelectProjectConfiguration(currentSolutionConfiguration, project.ProjectConfigurations);
 
-                if (!SolutionProjectGenerator.WouldProjectBuild(solution, currentSolutionConfiguration.FullName, project, projectConfiguration))
+                if (!SolutionProjectGenerator.WouldProjectBuild(Solution, currentSolutionConfiguration.FullName, project, projectConfiguration))
                 {
                     continue;
                 }
@@ -341,11 +343,11 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                     List<string> solutionDependenciesForProject = new(project.Dependencies.Count);
                     foreach (string dependencyProjectGuid in project.Dependencies)
                     {
-                        if (!solution.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
+                        if (!Solution.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
                         {
                             ProjectFileErrorUtilities.ThrowInvalidProjectFile(
                                 "SubCategoryForSolutionParsingErrors",
-                                new BuildEventFileInfo(solution.FullPath),
+                                new BuildEventFileInfo(Solution.FullPath),
                                 "SolutionParseProjectDepNotFoundError",
                                 project.ProjectGuid,
                                 dependencyProjectGuid);
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index c9b55477667..4df1c7e3ea7 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -10,7 +10,10 @@
 using System.Linq;
 using System.Text;
 using System.Threading;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
@@ -56,10 +59,14 @@ public delegate ProjectInstance ProjectInstanceFactoryFunc(
 
         private readonly Lazy<IReadOnlyCollection<ProjectGraphNode>> _projectNodesTopologicallySorted;
 
+        private readonly EvaluationContext _evaluationContext = null;
+
         private GraphBuilder.GraphEdges Edges { get; }
 
         internal GraphBuilder.GraphEdges TestOnly_Edges => Edges;
 
+        internal SolutionFile Solution { get; }
+
         public GraphConstructionMetrics ConstructionMetrics { get; private set; }
 
         /// <summary>
@@ -418,7 +425,11 @@ public ProjectGraph(
 
             var measurementInfo = BeginMeasurement();
 
-            projectInstanceFactory ??= DefaultProjectInstanceFactory;
+            if (projectInstanceFactory is null)
+            {
+                _evaluationContext = EvaluationContext.Create(EvaluationContext.SharingPolicy.Shared);
+                projectInstanceFactory = DefaultProjectInstanceFactory;
+            }
 
             var graphBuilder = new GraphBuilder(
                 entryPoints,
@@ -433,6 +444,7 @@ public ProjectGraph(
             GraphRoots = graphBuilder.RootNodes;
             ProjectNodes = graphBuilder.ProjectNodes;
             Edges = graphBuilder.Edges;
+            Solution = graphBuilder.Solution;
 
             _projectNodesTopologicallySorted = new Lazy<IReadOnlyCollection<ProjectGraphNode>>(() => TopologicalSort(GraphRoots, ProjectNodes));
 
@@ -604,14 +616,92 @@ public IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> GetTargetLis
             var encounteredEdges = new HashSet<ProjectGraphBuildRequest>();
             var edgesToVisit = new Queue<ProjectGraphBuildRequest>();
 
-            foreach (ProjectGraphNode entryPointNode in EntryPointNodes)
+            if (entryProjectTargets == null || entryProjectTargets.Count == 0)
             {
-                var entryTargets = entryProjectTargets == null || entryProjectTargets.Count == 0
-                    ? ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets)
-                    : ImmutableList.CreateRange(entryProjectTargets);
-                var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);
-                encounteredEdges.Add(entryEdge);
-                edgesToVisit.Enqueue(entryEdge);
+                // If no targets were specified, use every project's default targets.
+                foreach (ProjectGraphNode entryPointNode in EntryPointNodes)
+                {
+                    var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);
+                    var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);
+                    encounteredEdges.Add(entryEdge);
+                    edgesToVisit.Enqueue(entryEdge);
+                }
+            }
+            else
+            {
+                foreach (string targetName in entryProjectTargets)
+                {
+                    // Special-case the "Build" target. The solution's metaproj invokes each project's default targets
+                    if (targetName.Equals("Build", StringComparison.OrdinalIgnoreCase))
+                    {
+                        foreach (ProjectGraphNode entryPointNode in EntryPointNodes)
+                        {
+                            var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);
+                            var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);
+                            encounteredEdges.Add(entryEdge);
+                            edgesToVisit.Enqueue(entryEdge);
+                        }
+
+                        continue;
+                    }
+
+                    bool isSolutionTraversalTarget = false;
+                    if (Solution != null)
+                    {
+                        foreach (ProjectInSolution project in Solution.ProjectsInOrder)
+                        {
+                            if (!SolutionFile.IsBuildableProject(project))
+                            {
+                                continue;
+                            }
+
+                            string baseProjectName = ProjectInSolution.DisambiguateProjectTargetName(project.GetUniqueProjectName());
+
+                            // Solutions generate target names to build individual projects. Map these to "real" targets on the relevant projects.
+                            // This logic should match SolutionProjectGenerator's behavior, particularly EvaluateAndAddProjects's calls to AddTraversalTargetForProject.
+                            if (MSBuildNameIgnoreCaseComparer.Default.Equals(targetName, baseProjectName))
+                            {
+                                // Build a specific project with its default targets.
+                                ProjectGraphNode node = GetNodeForProject(project);
+                                ProjectGraphBuildRequest entryEdge = new(node, ImmutableList.CreateRange(node.ProjectInstance.DefaultTargets));
+                                encounteredEdges.Add(entryEdge);
+                                edgesToVisit.Enqueue(entryEdge);
+                                isSolutionTraversalTarget = true;
+                            }
+                            else if (targetName.StartsWith($"{baseProjectName}:", StringComparison.OrdinalIgnoreCase))
+                            {
+                                // Build a specific project with the specified target
+                                string projectTargetName = targetName.Substring(baseProjectName.Length + 1);
+
+                                // Special-case "Project:" and "Project:Build". SolutionProjectGenerator does not generate a target for those, so should error with MSB4057
+                                ProjectErrorUtilities.VerifyThrowInvalidProject(
+                                    projectTargetName.Length > 0 && !projectTargetName.Equals("Build", StringComparison.OrdinalIgnoreCase),
+                                    ElementLocation.Create(Solution.FullPath),
+                                    "TargetDoesNotExist",
+                                    targetName);
+
+                                ProjectGraphNode node = GetNodeForProject(project);
+                                ProjectGraphBuildRequest entryEdge = new(node,[projectTargetName]);
+                                encounteredEdges.Add(entryEdge);
+                                edgesToVisit.Enqueue(entryEdge);
+                                isSolutionTraversalTarget = true;
+                            }
+
+                            // For solutions, there should only be exactly one entry node per project file
+                            ProjectGraphNode GetNodeForProject(ProjectInSolution project) => EntryPointNodes.First(node => string.Equals(node.ProjectInstance.FullPath, project.AbsolutePath));
+                        }
+                    }
+
+                    if (!isSolutionTraversalTarget)
+                    {
+                        foreach (ProjectGraphNode entryPointNode in EntryPointNodes)
+                        {
+                            ProjectGraphBuildRequest entryEdge = new(entryPointNode,[targetName]);
+                            encounteredEdges.Add(entryEdge);
+                            edgesToVisit.Enqueue(entryEdge);
+                        }
+                    }
+                }
             }
 
             // Traverse the entire graph, visiting each edge once.
@@ -742,16 +832,33 @@ private static ImmutableList<string> ExpandDefaultTargets(ImmutableList<string>
             return targets;
         }
 
-        internal static ProjectInstance DefaultProjectInstanceFactory(
+        internal ProjectInstance DefaultProjectInstanceFactory(
             string projectPath,
             Dictionary<string, string> globalProperties,
             ProjectCollection projectCollection)
+        {
+            Debug.Assert(_evaluationContext is not null);
+
+            return StaticProjectInstanceFactory(
+                                projectPath,
+                                globalProperties,
+                                projectCollection,
+                                _evaluationContext);
+        }
+
+        internal static ProjectInstance StaticProjectInstanceFactory(
+            string projectPath,
+            Dictionary<string, string> globalProperties,
+            ProjectCollection projectCollection,
+            EvaluationContext evaluationContext)
         {
             return new ProjectInstance(
                 projectPath,
                 globalProperties,
                 MSBuildConstants.CurrentToolsVersion,
-                projectCollection);
+                subToolsetVersion: null,
+                projectCollection,
+                evaluationContext);
         }
 
         private struct ProjectGraphBuildRequest : IEquatable<ProjectGraphBuildRequest>
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index fe63676c1d2..32a408a5ca4 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -185,6 +185,12 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         private bool _translateEntireState;
         private int _evaluationId = BuildEventContext.InvalidEvaluationId;
 
+        /// <summary>
+        /// The property and item filter used when creating this instance, or null if this is not a filtered copy
+        /// of another ProjectInstance. <seealso cref="ProjectInstance(ProjectInstance, bool, RequestedProjectState)"/>
+        /// </summary>
+        private RequestedProjectState _requestedProjectStateFilter;
+
         /// <summary>
         /// Creates a ProjectInstance directly.
         /// No intermediate Project object is created.
@@ -248,6 +254,23 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         {
         }
 
+        /// <summary>
+        /// Creates a ProjectInstance directly.
+        /// No intermediate Project object is created.
+        /// This is ideal if the project is simply going to be built, and not displayed or edited.
+        /// </summary>
+        /// <param name="projectFile">The path to the project file.</param>
+        /// <param name="globalProperties">The global properties to use.</param>
+        /// <param name="toolsVersion">The tools version. May be <see langword="null"/>.</param>
+        /// <param name="subToolsetVersion">The sub-toolset version, used in tandem with <paramref name="toolsVersion"/> to determine the set of toolset properties. May be <see langword="null"/>.</param>
+        /// <param name="projectCollection">Project collection</param>
+        /// <param name="context">Context to evaluate inside, potentially sharing caches with other evaluations.</param>
+        /// <param name="interactive">Indicates if loading the project is allowed to interact with the user.</param>
+        internal ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, EvaluationContext context, bool interactive = false)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: context, directoryCacheFactory: null, interactive: interactive)
+        {
+        }
+
         /// <summary>
         /// Creates a ProjectInstance directly.
         /// No intermediate Project object is created.
@@ -679,6 +702,7 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
             _isImmutable = isImmutable;
             _evaluationId = that.EvaluationId;
             _translateEntireState = that._translateEntireState;
+            _requestedProjectStateFilter = filter?.DeepClone();
 
             if (filter == null)
             {
@@ -1115,6 +1139,12 @@ public bool IsImmutable
             get { return _isImmutable; }
         }
 
+        /// <summary>
+        /// The property and item filter used when creating this instance, or null if this is not a filtered copy
+        /// of another ProjectInstance. <seealso cref="ProjectInstance(ProjectInstance, bool, RequestedProjectState)"/>
+        /// </summary>
+        internal RequestedProjectState RequestedProjectStateFilter => _requestedProjectStateFilter;
+
         /// <summary>
         /// Task classes and locations known to this project.
         /// This is the project-specific task registry, which is consulted before
@@ -2228,6 +2258,7 @@ internal void TranslateMinimalState(ITranslator translator)
         {
             translator.TranslateDictionary(ref _globalProperties, ProjectPropertyInstance.FactoryForDeserialization);
             translator.TranslateDictionary(ref _properties, ProjectPropertyInstance.FactoryForDeserialization);
+            translator.Translate(ref _requestedProjectStateFilter);
             translator.Translate(ref _isImmutable);
             TranslateItems(translator);
         }
@@ -2768,14 +2799,26 @@ private static ProjectInstance[] GenerateSolutionWrapperUsingOldOM(
                 }
             }
 
-            XmlReaderSettings xrs = new XmlReaderSettings();
-            xrs.DtdProcessing = DtdProcessing.Ignore;
+            XmlReaderSettings xrs = new XmlReaderSettings
+            {
+                DtdProcessing = DtdProcessing.Ignore
+            };
 
-            ProjectRootElement projectRootElement = new ProjectRootElement(XmlReader.Create(new StringReader(wrapperProjectXml), xrs), projectRootElementCache, isExplicitlyLoaded,
-                preserveFormatting: false);
-            projectRootElement.DirectoryPath = Path.GetDirectoryName(projectFile);
-            ProjectInstance instance = new ProjectInstance(projectRootElement, globalProperties, toolsVersion, buildParameters, loggingService, projectBuildEventContext, sdkResolverService, submissionId);
-            return new ProjectInstance[] { instance };
+            StringReader sr = new StringReader(wrapperProjectXml);
+            using (XmlReader xmlReader = XmlReader.Create(sr, xrs))
+            {
+                ProjectRootElement projectRootElement = new(
+                    xmlReader,
+                    projectRootElementCache,
+                    isExplicitlyLoaded,
+                    preserveFormatting: false)
+                {
+                    DirectoryPath = Path.GetDirectoryName(projectFile)
+                };
+                ProjectInstance instance = new(projectRootElement, globalProperties, toolsVersion, buildParameters, loggingService, projectBuildEventContext, sdkResolverService, submissionId);
+
+                return new[] { instance };
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 54de65d1d05..a7b005a1925 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -69,6 +69,8 @@ public sealed class BinaryLogger : ILogger
         //   - Adding serialized events lengths - to support forward compatible reading
         // version 19:
         //   - GeneratedFileUsedEventArgs exposed for brief period of time (so let's continue with 20)
+        // version 20:
+        //   - TaskStartedEventArgs: Added TaskAssemblyLocation property
 
         // This should be never changed.
         // The minimum version of the binary log reader that can read log of above version.
@@ -76,7 +78,7 @@ public sealed class BinaryLogger : ILogger
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 18;
+        internal const int FileFormatVersion = 20;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
@@ -119,7 +121,7 @@ public enum ProjectImportsCollectionMode
         /// </summary>
         public ProjectImportsCollectionMode CollectProjectImports { get; set; } = ProjectImportsCollectionMode.Embed;
 
-        private string FilePath { get; set; }
+        internal string FilePath { get; private set; }
 
         /// <summary> Gets or sets the verbosity level.</summary>
         /// <remarks>
@@ -133,6 +135,15 @@ public enum ProjectImportsCollectionMode
         /// </summary>
         public string Parameters { get; set; }
 
+        /// <summary>
+        /// Optional expander of wildcard(s) within the LogFile path parameter of a binlog <see cref="Parameters"/>.
+        /// Wildcards can be used in the LogFile parameter in a form for curly brackets ('{}', '{[param]}').
+        /// Currently, the only supported wildcard is '{}', the optional parameters within the curly brackets
+        ///  are not currently supported, however the string parameter to the <see cref="PathParameterExpander"/> func
+        /// is reserved for this purpose.
+        /// </summary>
+        internal Func<string, string> PathParameterExpander { private get; set; } = ExpandPathParameter;
+
         /// <summary>
         /// Initializes the logger by subscribing to events of the specified event source and embedded content source.
         /// </summary>
@@ -415,15 +426,9 @@ private void ProcessParameters(out bool omitInitialInfo)
                 {
                     omitInitialInfo = true;
                 }
-                else if (parameter.EndsWith(".binlog", StringComparison.OrdinalIgnoreCase))
+                else if (TryInterpretPathParameter(parameter, out string filePath))
                 {
-                    FilePath = parameter;
-                    if (FilePath.StartsWith("LogFile=", StringComparison.OrdinalIgnoreCase))
-                    {
-                        FilePath = FilePath.Substring("LogFile=".Length);
-                    }
-
-                    FilePath = FilePath.Trim('"');
+                    FilePath = filePath;
                 }
                 else
                 {
@@ -449,5 +454,47 @@ private void ProcessParameters(out bool omitInitialInfo)
                 throw new LoggerException(message, e, errorCode, helpKeyword);
             }
         }
+
+        private bool TryInterpretPathParameter(string parameter, out string filePath)
+        {
+            bool hasPathPrefix = parameter.StartsWith("LogFile=", StringComparison.OrdinalIgnoreCase);
+
+            if (hasPathPrefix)
+            {
+                parameter = parameter.Substring("LogFile=".Length);
+            }
+
+            parameter = parameter.Trim('"');
+
+            bool isWildcard = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12) && parameter.Contains("{}");
+            bool hasProperExtension = parameter.EndsWith(".binlog", StringComparison.OrdinalIgnoreCase);
+            filePath = parameter;
+
+            if (!isWildcard)
+            {
+                return hasProperExtension;
+            }
+
+            filePath = parameter.Replace("{}", GetUniqueStamp(), StringComparison.Ordinal);
+
+            if (!hasProperExtension)
+            {
+                filePath += ".binlog";
+            }
+            return true;
+        }
+
+        private string GetUniqueStamp()
+            => (PathParameterExpander ?? ExpandPathParameter)(string.Empty);
+
+        private static string ExpandPathParameter(string parameters)
+            => $"{DateTime.UtcNow.ToString("yyyyMMdd-HHmmss")}--{ProcessId}--{StringUtils.GenerateRandomString(6)}";
+
+        private static int ProcessId
+#if NET
+            => Environment.ProcessId;
+#else
+            => System.Diagnostics.Process.GetCurrentProcess().Id;
+#endif
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 2c49c17c8a7..03ce7bed76c 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -20,7 +20,7 @@
 namespace Microsoft.Build.Logging
 {
     /// <summary>
-    /// Deserializes and returns BuildEventArgs-derived objects from a BinaryReader
+    /// Deserializes and returns BuildEventArgs-derived objects from a BinaryReader.
     /// </summary>
     public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposable
     {
@@ -186,7 +186,6 @@ internal RawRecord ReadRaw()
             Stream stream = _binaryReader.BaseStream.Slice(serializedEventLength);
 
             _lastSubStream = stream as SubStream;
-
             _recordNumber += 1;
 
             return new(recordKind, stream);
@@ -806,6 +805,7 @@ private BuildEventArgs ReadTaskStartedEventArgs()
             var taskName = ReadOptionalString();
             var projectFile = ReadOptionalString();
             var taskFile = ReadOptionalString();
+            var taskAssemblyLocation = _fileFormatVersion > 19 ? ReadOptionalString() : null;
 
             var e = new TaskStartedEventArgs(
                 fields.Message,
@@ -813,7 +813,8 @@ private BuildEventArgs ReadTaskStartedEventArgs()
                 projectFile,
                 taskFile,
                 taskName,
-                fields.Timestamp);
+                fields.Timestamp,
+                taskAssemblyLocation);
             e.LineNumber = fields.LineNumber;
             e.ColumnNumber = fields.ColumnNumber;
             SetCommonFields(e, fields);
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index a3ce5efa3c5..0c5c82846b3 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -408,6 +408,7 @@ private BinaryLogRecordKind Write(TaskStartedEventArgs e)
             WriteDeduplicatedString(e.TaskName);
             WriteDeduplicatedString(e.ProjectFile);
             WriteDeduplicatedString(e.TaskFile);
+            WriteDeduplicatedString(e.TaskAssemblyLocation);
 
             return BinaryLogRecordKind.TaskStarted;
         }
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
index 2993b3953c1..d8eca6c3848 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
@@ -5,6 +5,7 @@
 using System.Buffers;
 using System.Diagnostics;
 using System.IO;
+using System.Text;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
@@ -60,7 +61,8 @@ public static byte[] ReadToEnd(this Stream stream)
         {
             if (stream.TryGetLength(out long length))
             {
-                BinaryReader reader = new(stream);
+                using BinaryReader reader = new(stream, Encoding.UTF8, leaveOpen: true);
+
                 return reader.ReadBytes((int)length);
             }
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 6d41abd7891..d2801b103f0 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -120,6 +120,9 @@
     <Compile Include="..\Shared\TaskLoggingHelperExtension.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\TaskLoggingHelperExtension.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IsExternalInit.cs">
+      <Link>BuildCheck\Utilities\IsExternalInit.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\TaskParameter.cs" />
     <Compile Include="..\Shared\TaskParameterTypeVerifier.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
@@ -153,6 +156,38 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
+    <Compile Include="BuildCheck\Acquisition\AnalyzerAcquisitionData.cs" />
+    <Compile Include="BuildCheck\Acquisition\BuildCheckAcquisitionModule.cs" />
+    <Compile Include="BuildCheck\Acquisition\IBuildCheckAcquisitionModule.cs" />
+    <Compile Include="BuildCheck\Analyzers\SharedOutputPathAnalyzer.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckConfigurationException.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildEventsProcessor.cs" />
+    <Compile Include="BuildCheck\Infrastructure\IBuildCheckManagerProvider.cs" />
+    <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManager.cs" />
+    <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManagerProvider.cs" />
+    <Compile Include="BuildCheck\Infrastructure\TracingReporter.cs" />
+    <Compile Include="BuildCheck\OM\BuildCheckDataContext.cs" />
+    <Compile Include="BuildCheck\API\BuildAnalyzer.cs" />
+    <Compile Include="BuildCheck\API\BuildAnalyzerConfiguration.cs" />
+    <Compile Include="BuildCheck\API\BuildCheckResult.cs" />
+    <Compile Include="BuildCheck\API\BuildAnalyzerResultSeverity.cs" />
+    <Compile Include="BuildCheck\API\BuildAnalyzerRule.cs" />
+    <Compile Include="BuildCheck\API\ConfigurationContext.cs" />
+    <Compile Include="BuildCheck\API\EvaluationAnalysisScope.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildAnalyzerConfigurationInternal.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildAnalyzerWrapper.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckCentralContext.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckConnectorLogger.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckContext.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckManagerProvider.cs" />
+    <Compile Include="BuildCheck\Infrastructure\ConfigurationProvider.cs" />
+    <Compile Include="BuildCheck\Infrastructure\CustomConfigurationData.cs" />
+    <Compile Include="BuildCheck\API\IBuildCheckRegistrationContext.cs" />
+    <Compile Include="BuildCheck\Infrastructure\IBuildCheckManager.cs" />
+    <Compile Include="BuildCheck\Logging\IBuildAnalysisLoggingContextFactory.cs" />
+    <Compile Include="BuildCheck\OM\EvaluatedPropertiesAnalysisData.cs" />
+    <Compile Include="BuildCheck\OM\ParsedItemsAnalysisData.cs" />
+    <Compile Include="BuildCheck\Utilities\EnumerableExtensions.cs" />
     <Compile Include="Evaluation\IItemTypeDefinition.cs" />
     <Compile Include="FileAccess\DesiredAccess.cs" />
     <Compile Include="FileAccess\FileAccessData.cs" />
@@ -160,6 +195,8 @@
     <Compile Include="FileAccess\ProcessData.cs" />
     <Compile Include="FileAccess\ReportedFileOperation.cs" />
     <Compile Include="FileAccess\RequestedAccess.cs" />
+    <Compile Include="BuildCheck\Logging\AnalyzerLoggingContext.cs" />
+    <Compile Include="BuildCheck\Logging\AnalyzerLoggingContextFactory.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
@@ -354,7 +391,6 @@
     <Compile Include="BackEnd\Components\Scheduler\ScheduleResponse.cs" />
     <Compile Include="BackEnd\Node\INode.cs" />
     <!-- ########################## -->
-    <Compile Include="BackEnd\TaskExecutionHost\AddInParts\ITaskExecutionHost.cs" />
     <Compile Include="BackEnd\TaskExecutionHost\TaskExecutionHost.cs" />
     <!-- #### COLLECTIONS ### -->
     <Compile Include="..\Shared\CollectionHelpers.cs" />
@@ -682,11 +718,7 @@
   <!-- Extract binding redirects for MSBuild and dependencies from MSBuild.exe.config into a source file.
        This allows us to create secondary AppDomains with the same redirects at run-time, see
        https://github.com/dotnet/msbuild/blob/main/documentation/NETFramework-NGEN.md#nugetframeworks -->
-  <Target Name="GenerateAppDomainConfig"
-          Inputs="..\MSBuild\app.config;..\MSBuild\app.amd64.config;$(MSBuildThisFileFullPath)"
-          Outputs="$(NuGetFrameworkWrapperRedirects_FilePath)"
-          BeforeTargets="CoreCompile"
-          Condition="'$(FeatureAppDomain)' == 'true'">
+  <Target Name="GenerateAppDomainConfig" Inputs="..\MSBuild\app.config;..\MSBuild\app.amd64.config;$(MSBuildThisFileFullPath)" Outputs="$(NuGetFrameworkWrapperRedirects_FilePath)" BeforeTargets="CoreCompile" Condition="'$(FeatureAppDomain)' == 'true'">
     <PropertyGroup>
       <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>
       <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/*</BindingRedirectXPath>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index a037905be7e..62bcd2464c3 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -2000,7 +2000,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is a file path. {1} is a comma-separated list of target names
     </comment>
   </data>
-   <data name="DefaultSDKResolverError" xml:space="preserve">
+  <data name="DefaultSDKResolverError" xml:space="preserve">
     <value>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</value>
   </data>
   <data name="SDKResolverReturnedNull" xml:space="preserve">
@@ -2095,6 +2095,25 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
     </comment>
   </data>
+  <data name="CustomAnalyzerSuccessfulAcquisition" xml:space="preserve">
+    <value>Custom analyzer rule: {0} has been registered successfully.</value>
+    <comment>The message is emitted on successful loading of the custom analyzer rule in process.</comment>
+  </data>
+  <data name="CustomAnalyzerFailedAcquisition" xml:space="preserve">
+    <value>Failed to register the custom analyzer: {0}.</value>
+    <comment>The message is emitted on failed loading of the custom analyzer in process.</comment>
+  </data>
+  <data name="CustomAnalyzerFailedRuleLoading" xml:space="preserve">
+    <value>Failed to instantiate the custom analyzer rule with the following exception: {0}.</value>
+    <comment>The message is emitted on failed loading of the custom analyzer rule in process.</comment>
+  </data>
+  <data name="CustomAnalyzerAssemblyNotExist" xml:space="preserve">
+    <value>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</value>
+    <comment>The message is emitted when the custom analyzer assembly can not be found.</comment>
+  </data>
+  <data name="TaskAssemblyLocationMismatch" xml:space="preserve">
+    <value>Task assembly was loaded from '{0}' while the desired location was '{1}'.</value>
+  </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 650427a125b..805b9010ea3 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: VÃ½chozÃ­ pÅekladaÄ sady SDK nedokÃ¡zal pÅeloÅ¾it sadu SDK â{0}â, protoÅ¾e adresÃ¡Å â{1}â neexistoval.</target>
@@ -596,6 +616,11 @@ Chyby: {3}</target>
         <target state="translated">SestavenÃ­ naÄteno bÄhem {0}{1}: {2} (umÃ­stÄnÃ­: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Ãloha {0} uvolnila tento poÄet jader: {1}. TeÄ pouÅ¾Ã­vÃ¡ celkem tento poÄet jader: {2}</target>
@@ -1630,7 +1655,7 @@ Chyby: {3}</target>
       </trans-unit>
       <trans-unit id="SolutionVenusProjectSkipped">
         <source>Skipping because the "$(AspNetConfiguration)" configuration is not supported for this web project.  You can use the AspNetConfiguration property to override the configuration used for building web projects, by adding /p:AspNetConfiguration=&lt;value&gt; to the command line. Currently web projects only support Debug and Release configurations.</source>
-        <target state="translated">VynechÃ¡no, protoÅ¾e konfigurace "$(AspNetConfiguration)" nenÃ­ pro tento webovÃ½ projekt podporovÃ¡na. PomocÃ­ vlastnosti AspNetConfiguration mÅ¯Å¾ete pÅepsat konfiguraci pouÅ¾Ã­vanou k sestavovÃ¡nÃ­ webovÃ½ch projektÅ¯, a to pÅidÃ¡nÃ­m pÅÃ­kazu /p:AspNetConfiguration=&lt;hodnota&gt; do pÅÃ­kazovÃ©ho ÅÃ¡dku. WebovÃ© projekty nynÃ­ podporujÃ­ pouze konfigurace Debug a Release.</target>
+        <target state="translated">VynechÃ¡no, protoÅ¾e konfigurace $(AspNetConfiguration) nenÃ­ pro tento webovÃ½ projekt podporovÃ¡na. PomocÃ­ vlastnosti AspNetConfiguration mÅ¯Å¾ete pÅepsat konfiguraci pouÅ¾Ã­vanou k sestavovÃ¡nÃ­ webovÃ½ch projektÅ¯, a to pÅidÃ¡nÃ­m pÅÃ­kazu /p:AspNetConfiguration=&lt;hodnota&gt; do pÅÃ­kazovÃ©ho ÅÃ¡dku. WebovÃ© projekty nynÃ­ podporujÃ­ pouze konfigurace Debug a Release.</target>
         <note>
     UE: This is not an error, so doesn't need an error code.
     LOCALIZATION: Do NOT localize "AspNetConfiguration", "Debug", "Release".
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index e6a913e32bb..ee28388b3e7 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: Der SDK-Standardresolver konnte SDK "{0}" nicht auflÃ¶sen, da das Verzeichnis "{1}" nicht vorhanden war.</target>
@@ -508,7 +528,7 @@
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
 Errors: {3}</source>
-        <target state="translated">Der KonfliktlÃ¶ser "{0}" hat versucht, das SDK "{1}" aufzulÃ¶sen.
+        <target state="translated">Der KonfliktlÃ¶ser â{0}â hat versucht, das SDK â{1}â aufzulÃ¶sen.
 Warnungen: {2}
 Fehler: {3}</target>
         <note>
@@ -596,6 +616,11 @@ Fehler: {3}</target>
         <target state="translated">Assembly wÃ¤hrend {0}{1} geladen: {2} (Speicherort: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Die Aufgabe "{0}" hat {1} Kerne freigegeben und belegt jetzt insgesamt {2} Kerne.</target>
@@ -622,7 +647,7 @@ Fehler: {3}</target>
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Dies ist ein Ausnahmefehler in MSBuild. STIMMEN SIE EINEM VORHANDENEN ISSUE ZU, ODER ERSTELLEN SIE EIN NEUES ISSUE UNTER https://aka.ms/msbuild/unhandled
+        <target state="translated">Dies ist eine nicht behandelte Ausnahme in MSBuild. RUFEN SIE EIN VORHANDENES PROBLEM AUF, ODER ERSTELLEN SIE EIN NEUES UNTER https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 38ef5036baf..257fde173bd 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: La resoluciÃ³n predeterminada del SDK no pudo resolver el SDK "{0}" porque el directorio "{1}" no existÃ­a.</target>
@@ -508,7 +528,7 @@
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
 Errors: {3}</source>
-        <target state="translated">El solucionador "{0}" intentÃ³ resolver el SDK "{1}".
+        <target state="translated">El resolvedor "{0}" intentÃ³ resolver el SDK "{1}".
 Advertencias: {2}
 Errores: {3}</target>
         <note>
@@ -596,6 +616,11 @@ Errores: {3}</target>
         <target state="translated">Ensamblado cargado durante {0}{1}: {2}(ubicaciÃ³n: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">La tarea "{0}" liberÃ³ {1}Â nÃºcleos y ahora retiene un total de {2}Â nÃºcleos.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 7ecf671540f..c5d61abb801 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: Le programme de rÃ©solution du SDK par dÃ©faut nâa pas pu rÃ©soudre le SDK Â«{0}Â», car le rÃ©pertoire Â«{1}Â» nâexistait pas.</target>
@@ -596,6 +616,11 @@ ErreursÂ : {3}</target>
         <target state="translated">Assembly chargÃ© pendant {0}{1}Â : {2} (emplacement : {3}, MVID : {4}, AssemblyLoadContext : {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">La tÃ¢che "{0}" a libÃ©rÃ© {1} cÅur. Elle dÃ©tient dÃ©sormais {2} cÅurs au total.</target>
@@ -622,7 +647,7 @@ ErreursÂ : {3}</target>
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Il sâagit dâune exception non prise en charge dans MSBuildÂ ââ VOTEZ POUR UN PROBLÃME EXISTANT OU CRÃEZ-EN UN SUR https://aka.ms/msbuild/unhandled
+        <target state="translated">Il sâagit dâune exception non gÃ©rÃ©e dans MSBuildÂ ââ VOTEZ POUR UN PROBLÃME EXISTANT OU ENTREZ UN NOUVEAU FICHIER Ã https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index cc614a3a558..82875aa922e 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: il resolver SDK predefinito non Ã¨ riuscito a risolvere l'SDK "{0}" perchÃ© la directory "{1}" non esiste.</target>
@@ -508,7 +528,7 @@
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
 Errors: {3}</source>
-        <target state="translated">Il resolver "{0}" ha tentato di risolvere l'SDK "{1}".
+        <target state="translated">Il resolver "{0}" ha provato a risolvere l'SDK "{1}".
 Avvisi: {2}
 Errori: {3}</target>
         <note>
@@ -596,6 +616,11 @@ Errori: {3}</target>
         <target state="translated">Assembly caricato durante {0}{1}: {2} (percorso: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">L'attivitÃ  "{0}" ha rilasciato {1} core e ora contiene {2} core in totale.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 82ddae9c55f..745ed6f66cb 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: ãã£ã¬ã¯ããª "{0}" ãå­å¨ããªãã£ããããæ¢å®ã® SDK ãªã¾ã«ãã¼ã¯ SDK "{1}" ãè§£æ±ºã§ãã¾ããã§ããã</target>
@@ -596,6 +616,11 @@ Errors: {3}</source>
         <target state="translated">{0}{1} ä¸­ã«ã¢ã»ã³ããªãèª­ã¿è¾¼ã¾ãã¾ãã: {2} (å ´æ: {3}ãMVID: {4}ãAssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">ã¿ã¹ã¯ "{0}" ã§ã¯ã{1} åã®ã³ã¢ãè§£æ¾ãããããç¾å¨åè¨ {2} åã®ã³ã¢ãä¿æãã¦ãã¾ãã</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 4b5c0ff47ac..c965e326ed9 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: ëë í°ë¦¬ "{0}"ì´(ê°) ìì¼ë¯ë¡ ê¸°ë³¸ SDK íì¸ìê° SDK "{1}"ì(ë¥¼) íì¸íì§ ëª»íìµëë¤.</target>
@@ -596,6 +616,11 @@ Errors: {3}</source>
         <target state="translated">{0}{1} ëì ë¡ëë ì´ìë¸ë¦¬: {2}(ìì¹: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">"{0}" ìììì ì½ì´ {1}ê°ë¥¼ í´ì íê³  ì§ê¸ ì´ {2}ê°ì ì½ì´ë¥¼ ë³´ì íê³  ììµëë¤.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 864776c5006..34dbe8205e9 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -38,7 +38,7 @@
       </trans-unit>
       <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
         <source>ArchiveFile was obtained, but the final edited version was not set.</source>
-        <target state="translated">Uzyskano plik ArchiveFile, ale nie ustawiono ostatecznej edytowanej wersji.</target>
+        <target state="translated">Uzyskano plik ArchiveFile, ale nie ustawiono ostatecznej edycji wersji.</target>
         <note />
       </trans-unit>
       <trans-unit id="Binlog_FwdCompatUnsupported">
@@ -72,7 +72,7 @@
       </trans-unit>
       <trans-unit id="Binlog_ReaderUnderRead">
         <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
-        <target state="translated">Oczekiwano, Å¼e numer rekordu BuildEvent {0} odczyta ze strumienia liczbÄ bajtÃ³w rÃ³wnÄ dokÅadnie {1}, ale zamiast tego odczytaÅ {2}.</target>
+        <target state="translated">Oczekiwano, Å¼e numer rekordu BuildEvent {0} odczyta ze strumienia liczbÄ bajtÃ³w rÃ³wnÄ dokÅadnie {1}, ale zamiast tego odczyta {2}.</target>
         <note>
       LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
     </note>
@@ -91,7 +91,7 @@
       </trans-unit>
       <trans-unit id="Binlog_Source_MultiSubscribeError">
         <source>Structured events and raw events cannot be replayed at the same time.</source>
-        <target state="translated">Nie moÅ¼na ponownie odtwarzaÄ jednoczeÅnie zdarzeÅ strukturalnych i zdarzeÅ pierwotnych.</target>
+        <target state="translated">Nie moÅ¼na jednoczeÅnie odtwarzaÄ zdarzeÅ strukturalnych i nieprzetworzonych.</target>
         <note />
       </trans-unit>
       <trans-unit id="Binlog_Source_VersionUninitialized">
@@ -116,7 +116,7 @@
       </trans-unit>
       <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
         <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
-        <target state="translated">PrÃ³ba pominiÄcia {0} bajtÃ³w, tylko przesuniÄcie nieujemne do wartoÅci int.MaxValue jest dozwolone.</target>
+        <target state="translated">PrÃ³ba pominiÄcia {0} bajtÃ³w, tylko przesuniÄcie nieujemne do liczby caÅkowitej. WartoÅÄ MaxValue jest dozwolona.</target>
         <note>
       LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
     </note>
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: DomyÅlne narzÄdzie Resolver zestawu SDK nie moÅ¼e rozpoznaÄ zestawu SDK â{0}â, poniewaÅ¼ katalog â{1}â nie istnieje.</target>
@@ -252,7 +272,7 @@
       <trans-unit id="FatalErrorWhileLoggingWithInnerException">
         <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
     {0}</source>
-        <target state="translated">MSB4017: kompilacja zostaÅa nieoczekiwanie zatrzymana z powodu nieoczekiwanego bÅÄdu rejestratora.
+        <target state="translated">MSB4017: Kompilacja zostaÅa nieoczekiwanie zatrzymana z powodu nieoczekiwanego bÅÄdu rejestratora.
     {0}</target>
         <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
     likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
@@ -578,7 +598,7 @@ BÅÄdy: {3}</target>
       </trans-unit>
       <trans-unit id="SucceededToResolveSDK">
         <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
-        <target state="translated">Zestaw SDK â{0}â zostaÅ pomyÅlnie rozpoznany przez narzÄdzie Resolver â{1}â w lokalizacji â{2}â i w wersji â{3}â.</target>
+        <target state="translated">Zestaw SDK â{0}â zostaÅ pomyÅlnie rozpoznany przez narzÄdzie Resolver â{1}â do lokalizacji â{2}â i wersji â{3}â.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskAcquiredCores">
@@ -596,6 +616,11 @@ BÅÄdy: {3}</target>
         <target state="translated">ZaÅadowano zestaw podczas {0}{1}: {2} (lokalizacja: {3}, MVID: {4}, kontekst Åadowania zestawu: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Zadanie â{0}â zwolniÅo rdzenie ({1}) i teraz jego ÅÄczna liczba rdzeni to {2}.</target>
@@ -622,7 +647,7 @@ BÅÄdy: {3}</target>
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Jest to nieobsÅugiwany wyjÄtek na platformie MSBuild -- ZAGÅOSUJ NA ISTNIEJÄCY PROBLEM LUB ZAREJESTRUJ NOWY W WITRYNIE https://aka.ms/msbuild/unhandled.
+        <target state="translated">Jest to nieobsÅugiwany wyjÄtek w aplikacji MSBuild -- ZAGÅOSUJ NA ISTNIEJÄCY PROBLEM LUB ZAGÅOSUJ NA NOWY NA https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index c26eb2b35fc..888dcdb0508 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: O resolvedor SDK padrÃ£o falhou ao resolver SDK "{0}" porque o diretÃ³rio "{1}" nÃ£o existia.</target>
@@ -252,7 +272,7 @@
       <trans-unit id="FatalErrorWhileLoggingWithInnerException">
         <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
     {0}</source>
-        <target state="translated">MSB4017: a compilaÃ§Ã£o parou inesperadamente devido a uma falha do agente.
+        <target state="translated">MSB4017: A compilaÃ§Ã£o parou inesperadamente devido a uma falha do agente de log.
     {0}</target>
         <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
     likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
@@ -596,6 +616,11 @@ Erros: {3}</target>
         <target state="translated">Assembly carregado durante {0}{1}: {2} (local: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">A tarefa "{0}" liberou {1} nÃºcleos e agora contÃ©m {2} nÃºcleos no total.</target>
@@ -622,7 +647,7 @@ Erros: {3}</target>
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Essa Ã© uma exceÃ§Ã£o nÃ£o tratada no MSBuild -- POR FAVOR, ATUALIZE UMA QUESTÃO EXISTENTE OU ENCAMINHE UMA NOVA EM https://aka.ms/msbuild/unhandled
+        <target state="translated">Esta Ã© uma exceÃ§Ã£o nÃ£o tratada no MSBuild -- POR FAVOR, APOIE UM PROBLEMA EXISTENTE OU ARQUIVE UM NOVO EM https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 413d96ad90b..57544712fe8 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: ÑÑÐ°Ð½Ð´Ð°ÑÑÐ½Ð¾Ð¼Ñ ÑÐ¾Ð¿Ð¾ÑÑÐ°Ð²Ð¸ÑÐµÐ»Ñ Ð¿Ð°ÐºÐµÑÐ¾Ð² SDK Ð½Ðµ ÑÐ´Ð°Ð»Ð¾ÑÑ ÑÐ°Ð·ÑÐµÑÐ¸ÑÑ Ð¿Ð°ÐºÐµÑ SDK "{0}", ÑÐ°Ðº ÐºÐ°Ðº ÐºÐ°ÑÐ°Ð»Ð¾Ð³ "{1}" Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ.</target>
@@ -596,6 +616,11 @@ Errors: {3}</source>
         <target state="translated">Ð¡Ð±Ð¾ÑÐºÐ° Ð·Ð°Ð³ÑÑÐ¶ÐµÐ½Ð° Ð²Ð¾ Ð²ÑÐµÐ¼Ñ {0}{1}: {2} (ÑÐ°ÑÐ¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">ÐÐ°Ð´Ð°ÑÐ° "{0}" Ð¾ÑÐ²Ð¾Ð±Ð¾Ð´Ð¸Ð»Ð° ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ðµ ÑÐ¸ÑÐ»Ð¾ ÑÐ´ÐµÑ ({1}). Ð¢ÐµÐ¿ÐµÑÑ Ð¾Ð±ÑÐµÐµ ÑÐ¸ÑÐ»Ð¾ ÑÐ´ÐµÑ, ÐºÐ¾ÑÐ¾ÑÑÐ¼Ð¸ ÑÐ°ÑÐ¿Ð¾Ð»Ð°Ð³Ð°ÐµÑ Ð·Ð°Ð´Ð°ÑÐ°, ÑÐ°Ð²Ð½Ð¾ {2}.</target>
@@ -622,7 +647,7 @@ Errors: {3}</source>
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Ð­ÑÐ¾ Ð½ÐµÐ¾Ð±ÑÐ°Ð±Ð¾ÑÐ°Ð½Ð½Ð¾Ðµ Ð¸ÑÐºÐ»ÑÑÐµÐ½Ð¸Ðµ Ð² MSBuild. ÐÐ ÐÐÐÐÐÐ¡Ð£ÐÐ¢Ð ÐÐ Ð¡Ð£Ð©ÐÐ¡Ð¢ÐÐ£Ð®Ð©Ð£Ð® ÐÐ ÐÐÐÐÐÐ£ ÐÐÐ Ð¡ÐÐÐÐ©ÐÐ¢Ð Ð ÐÐÐÐ£Ð ÐÐ https://aka.ms/msbuild/unhandled
+        <target state="translated">Ð­ÑÐ¾ Ð½ÐµÐ¾Ð±ÑÐ°Ð±Ð¾ÑÐ°Ð½Ð½Ð¾Ðµ Ð¸ÑÐºÐ»ÑÑÐµÐ½Ð¸Ðµ Ð² MSBuild. ÐÑÐ¾Ð³Ð¾Ð»Ð¾ÑÑÐ¹ÑÐµ Ð·Ð° ÑÑÑÐµÑÑÐ²ÑÑÑÑÑ Ð¿ÑÐ¾Ð±Ð»ÐµÐ¼Ñ Ð¸Ð»Ð¸ ÑÐ¾Ð¾Ð±ÑÐ¸ÑÐµ Ð¾ Ð½Ð¾Ð²Ð¾Ð¹ Ð¿Ð¾ Ð°Ð´ÑÐµÑÑ https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 7bb2e2d9a16..0e42c1af423 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: "{1}" dizini olmadÄ±ÄÄ±ndan, varsayÄ±lan SDK Ã§Ã¶zÃ¼mleyicisi "{0}" SDKâsÄ±nÄ± Ã§Ã¶zÃ¼mleyemedi.</target>
@@ -596,6 +616,11 @@ Hatalar: {3}</target>
         <target state="translated">Derleme {0}{1} sÄ±rasÄ±nda yÃ¼klendi: {2} (konum: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">"{0}" gÃ¶revi {1} Ã§ekirdeÄi serbest bÄ±raktÄ±. Åu anda toplam {2} Ã§ekirdek tutuyor.</target>
@@ -622,7 +647,7 @@ Hatalar: {3}</target>
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Bu, MSBuild'de iÅlenmeyen bir istisnadÄ±r -- LÃTFEN MEVCUT BÄ°R SORUNU OYLAYIN VEYA https://aka.ms/msbuild/unhandled ADRESÄ°NDE YENÄ° BÄ°R SORUN OLUÅTURUN
+        <target state="translated">Bu, MSBuild'de iÅlenmeyen bir istisnadÄ±r -- LÃTFEN MEVCUT BÄ°R SORUNU OYLAYIN VEYA https://aka.ms/msbuild/unhandled ADRESÄ°NDE YENÄ° BÄ°R SORUN DOSYALAYIN
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index a6fd082e52a..d23e8334597 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: é»è®¤ SDK è§£æç¨åºè§£æ SDKâ{0}âå¤±è´¥ï¼å ä¸ºç®å½â{1}âä¸å­å¨ã</target>
@@ -285,7 +305,7 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated or SharingPolicy.SharedSDKCache do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="translated">ä½¿ç¨ SharingPolicy.Isolated åå»ºç EvaluationContext å¯¹è±¡ãSharingPolicy.SharedSDKCache ä¸æ¯æè¢«ä¼ é MSBuildFileSystemBase æä»¶ç³»ç»ã</target>
+        <target state="translated">ä½¿ç¨ SharingPolicy.Isolated æ SharingPolicy.SharedSDKCache åå»ºç EvaluationContext å¯¹è±¡ä¸æ¯æè¢«ä¼ é MSBuildFileSystemBase æä»¶ç³»ç»ã</target>
         <note />
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
@@ -596,6 +616,11 @@ Errors: {3}</source>
         <target state="translated">å¨ {0}{1} æé´å è½½çç¨åºé: {2} (ä½ç½®: {3}ï¼MVID: {4}ï¼AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">ä»»å¡â{0}âåå¸äº {1} ä¸ªæ ¸å¿ï¼ç°æ»å±åå« {2} ä¸ªæ ¸å¿ã</target>
@@ -2551,7 +2576,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
       </trans-unit>
       <trans-unit id="InvalidSdkFormat">
         <source>MSB4229: The value "{0}" is not valid for an Sdk specification. The attribute should be a semicolon-delimited list of Sdk-name/minimum-version pairs, separated by a forward slash.</source>
-        <target state="translated">MSB4229: å¼â{0}âå¯¹ Sdk è§èæ æãæ­¤å±æ§åºè¯¥æ¯ä»¥åå·åéçSdk-name/minimum-version å¯¹ (ç¨æ­£ææ åé) çåè¡¨ã</target>
+        <target state="translated">MSB4229: å¼â{0}âå¯¹ Sdk è§èæ æãæ­¤å±æ§åºè¯¥æ¯ä»¥åå·åéçSdk-name/minimum-version å¯¹ï¼ç¨æ­£ææ åéï¼çåè¡¨ã</target>
         <note>{StrBegin="MSB4229: "}</note>
       </trans-unit>
       <trans-unit id="TaskInstantiationFailureNotSupported">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index ea5e44adc41..f6f3cff5721 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -207,6 +207,26 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerAssemblyNotExist">
+        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedAcquisition">
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
+        <source>Custom analyzer rule: {0} has been registered successfully.</source>
+        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
         <target state="translated">MSB4276: é è¨­ç SDK è§£æç¨å¼ç¡æ³è§£æ SDK "{0}"ï¼å çºç®é "{1}" ä¸å­å¨ã</target>
@@ -252,7 +272,7 @@
       <trans-unit id="FatalErrorWhileLoggingWithInnerException">
         <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
     {0}</source>
-        <target state="translated">MSB4017: ç±æ¼ç¼çæªé æçè¨éå¨å¤±æï¼å æ­¤å·²ä¸­æ­¢çµå»ºã
+        <target state="translated">MSB4017: å çºæªé æçè¨éå¨å¤±æï¼å»ºç½®æªé æåæ­¢ã
    {0}</target>
         <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
     likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
@@ -596,6 +616,11 @@ Errors: {3}</source>
         <target state="translated">çµä»¶å¨ {0}{1} æéè¼å¥: {2} (ä½ç½®: {3}ï¼MVID: {4}ï¼AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">å·¥ä½ "{0}" å·²ç¼è¡ {1} åæ ¸å¿ï¼ç¾å¨å±ä¿ç {2} åæ ¸å¿ã</target>
diff --git a/src/UnitTests.Shared/AssemblyInfo.cs b/src/BuildCheck.UnitTests/AssemblyInfo.cs
similarity index 100%
rename from src/UnitTests.Shared/AssemblyInfo.cs
rename to src/BuildCheck.UnitTests/AssemblyInfo.cs
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
new file mode 100644
index 00000000000..248b66ea6b0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
@@ -0,0 +1,43 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Xunit;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class BuildAnalyzerConfigurationInternalTests
+{
+    [Theory]
+    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning, true, true)]
+    [InlineData("ruleId2", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning, true, true)]
+    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Error, true, false)]
+    public void IsSameConfigurationAsTest(
+        string secondRuleId,
+        EvaluationAnalysisScope secondScope,
+        BuildAnalyzerResultSeverity secondSeverity,
+        bool secondEnabled,
+        bool isExpectedToBeSame)
+    {
+        BuildAnalyzerConfigurationInternal configuration1 = new BuildAnalyzerConfigurationInternal(
+                       ruleId: "ruleId",
+                       evaluationAnalysisScope: EvaluationAnalysisScope.ProjectOnly,
+                       severity: BuildAnalyzerResultSeverity.Warning,
+                       isEnabled: true);
+
+        BuildAnalyzerConfigurationInternal configuration2 = new BuildAnalyzerConfigurationInternal(
+            ruleId: secondRuleId,
+            evaluationAnalysisScope: secondScope,
+            severity: secondSeverity,
+            isEnabled: secondEnabled);
+
+        configuration1.IsSameConfigurationAs(configuration2).ShouldBe(isExpectedToBeSame);
+    }
+}
diff --git a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
new file mode 100644
index 00000000000..1518241d42f
--- /dev/null
+++ b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
@@ -0,0 +1,110 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+using static Microsoft.Build.BuildCheck.Infrastructure.BuildCheckManagerProvider;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class BuildCheckManagerTests
+{
+    private readonly IBuildCheckManager _testedInstance;
+    private readonly ILoggingService _loggingService;
+    private readonly MockLogger _logger;
+
+    public BuildCheckManagerTests(ITestOutputHelper output)
+    {
+        _loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+        _logger = new MockLogger();
+        _loggingService.RegisterLogger(_logger);
+        _testedInstance = new BuildCheckManager(_loggingService);
+    }
+
+    [Theory]
+    [InlineData(true, new[] { "Custom analyzer rule: Rule1 has been registered successfully.", "Custom analyzer rule: Rule2 has been registered successfully." })]
+    [InlineData(false, new[] { "Failed to register the custom analyzer: DummyPath." })]
+    public void ProcessAnalyzerAcquisitionTest(bool isAnalyzerRuleExist, string[] expectedMessages)
+    {
+        MockBuildCheckAcquisition(isAnalyzerRuleExist);
+        MockEnabledDataSourcesDefinition();
+
+        _testedInstance.ProcessAnalyzerAcquisition(new AnalyzerAcquisitionData("DummyPath"), new BuildEventContext(1, 2, 3, 4, 5, 6, 7));
+
+        _logger.AllBuildEvents.Where(be => be.GetType() == typeof(BuildMessageEventArgs)).Select(be => be.Message).ToArray()
+            .ShouldBeEquivalentTo(expectedMessages);
+    }
+
+    private void MockBuildCheckAcquisition(bool isAnalyzerRuleExist) => MockField("_acquisitionModule", new BuildCheckAcquisitionModuleMock(isAnalyzerRuleExist));
+
+    private void MockEnabledDataSourcesDefinition() => MockField("_enabledDataSources", new[] { true, true });
+
+    private void MockField(string fieldName, object mockedValue)
+    {
+        var mockedField = _testedInstance.GetType().GetField(fieldName, BindingFlags.NonPublic | BindingFlags.Instance);
+        if (mockedField != null)
+        {
+            mockedField.SetValue(_testedInstance, mockedValue);
+        }
+    }
+}
+
+internal sealed class BuildCheckAcquisitionModuleMock : IBuildCheckAcquisitionModule
+{
+    private readonly bool _isAnalyzerRuleExistForTest = true;
+
+    internal BuildCheckAcquisitionModuleMock(bool isAnalyzerRuleExistForTest) => _isAnalyzerRuleExistForTest = isAnalyzerRuleExistForTest;
+
+    public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, BuildEventContext buildEventContext)
+        => _isAnalyzerRuleExistForTest
+        ? new List<BuildAnalyzerFactory>() { () => new BuildAnalyzerRuleMock("Rule1"), () => new BuildAnalyzerRuleMock("Rule2") }
+        : new List<BuildAnalyzerFactory>();
+}
+
+internal sealed class BuildAnalyzerRuleMock : BuildAnalyzer
+{
+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        "X01234",
+        "Title",
+        "Description",
+        "Message format: {0}",
+        new BuildAnalyzerConfiguration());
+
+    internal BuildAnalyzerRuleMock(string friendlyName)
+    {
+        FriendlyName = friendlyName;
+    }
+
+    public override string FriendlyName { get; }
+
+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        // configurationContext to be used only if analyzer needs external configuration data.
+    }
+
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+    {
+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+    }
+
+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    {
+        context.ReportResult(BuildCheckResult.Create(
+            SupportedRule,
+            ElementLocation.EmptyLocation,
+            "Argument for the message format"));
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
new file mode 100644
index 00000000000..9351612060f
--- /dev/null
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -0,0 +1,137 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EndToEndTests : IDisposable
+{
+    private readonly TestEnvironment _env;
+    public EndToEndTests(ITestOutputHelper output)
+    {
+        _env = TestEnvironment.Create(output);
+
+        // this is needed to ensure the binary logger does not pollute the environment
+        _env.WithEnvironmentInvariant();
+    }
+
+    public void Dispose() => _env.Dispose();
+
+    [Theory]
+    [InlineData(true, true)]
+    [InlineData(false, true)]
+    [InlineData(false, false)]
+    public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool analysisRequested)
+    {
+        string contents = $"""
+            <Project Sdk="Microsoft.NET.Sdk" DefaultTargets="Hello">
+                
+                <PropertyGroup>
+                <OutputType>Exe</OutputType>
+                <TargetFramework>net8.0</TargetFramework>
+                <ImplicitUsings>enable</ImplicitUsings>
+                <Nullable>enable</Nullable>
+                </PropertyGroup>
+                  
+                <PropertyGroup Condition="$(Test) == true">
+                <TestProperty>Test</TestProperty>
+                </PropertyGroup>
+                 
+                <ItemGroup>
+                <ProjectReference Include=".\FooBar-Copy.csproj" />
+                </ItemGroup>
+                  
+                <Target Name="Hello">
+                <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
+                </Target>
+                
+            </Project>
+            """;
+
+        string contents2 = $"""
+            <Project Sdk="Microsoft.NET.Sdk">
+                               
+                <PropertyGroup>
+                <OutputType>Exe</OutputType>
+                <TargetFramework>net8.0</TargetFramework>
+                <ImplicitUsings>enable</ImplicitUsings>
+                <Nullable>enable</Nullable>
+                </PropertyGroup>
+                                 
+                <PropertyGroup Condition="$(Test) == true">
+                <TestProperty>Test</TestProperty>
+                </PropertyGroup>
+                                
+                <ItemGroup>
+                <Reference Include="bin/foo.dll" />
+                </ItemGroup>
+                                
+                <Target Name="Hello">
+                <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
+                </Target>
+                               
+            </Project>
+            """;
+        TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
+        TransientTestFile projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
+        TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
+
+        // var cache = new SimpleProjectRootElementCache();
+        // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);
+
+
+        TransientTestFile config = _env.CreateFile(workFolder, "editorconfig.json",
+            /*lang=json,strict*/
+            """
+            {
+                "BC0101": {
+                    "IsEnabled": true,
+                    "Severity": "Error"
+                },
+                "COND0543": {
+                    "IsEnabled": false,
+                    "Severity": "Error",
+                    "EvaluationAnalysisScope": "AnalyzedProjectOnly",
+                    "CustomSwitch": "QWERTY"
+                },
+                "BLA": {
+                    "IsEnabled": false
+                }
+            }
+            """);
+
+        // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
+        // This discrepancy breaks path equality checks in analyzers if we pass to MSBuild full path to the initial project.
+        // See if there is a way of fixing it in the engine - tracked: https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=55702688.
+        _env.SetCurrentDirectory(Path.GetDirectoryName(projectFile.Path));
+
+        _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", buildInOutOfProcessNode ? "1" : "0");
+        _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore" +
+            (analysisRequested ? " -analyze" : string.Empty), out bool success, false, _env.Output);
+        _env.Output.WriteLine(output);
+        success.ShouldBeTrue();
+        // The conflicting outputs warning appears - but only if analysis was requested
+        if (analysisRequested)
+        {
+            output.ShouldContain("BC0101");
+        }
+        else
+        {
+            output.ShouldNotContain("BC0101");
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
new file mode 100644
index 00000000000..3aa9eaff7d1
--- /dev/null
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -0,0 +1,37 @@
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <!-- Don't build a netfx version of this unit with dotnet, as the netfx bootstrap layout created with 'dotnet build' is incomplete. -->
+    <TargetFrameworks>$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
+    <TargetFrameworks Condition="'$(MSBuildRuntimeType)' == 'Full'">$(FullFrameworkTFM);$(TargetFrameworks)</TargetFrameworks>
+
+    <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
+    <IsPackable>false</IsPackable>
+    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
+    <ProjectReference Include="..\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj" />
+    <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <PackageReference Include="System.Collections.Immutable" />
+    <PackageReference Include="Shouldly" />
+    <PackageReference Include="System.Net.Http" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <Service Include="{82a7f48d-3b50-4b1e-b82e-3ada8210c358}" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <None Include="..\Shared\UnitTests\App.config">
+      <Link>App.config</Link>
+      <SubType>Designer</SubType>
+    </None>
+    <None Include="..\Shared\UnitTests\xunit.runner.json">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+  </ItemGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
new file mode 100644
index 00000000000..05d1266d2ac
--- /dev/null
+++ b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
@@ -0,0 +1,46 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Xml;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.UnitTests;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class ParsedItemsAnalysisDataTests
+{
+    [Fact]
+    public void ItemsHolder_GetItemsOfType_ShouldFilterProperly()
+    {
+        ProjectRootElement root = ProjectRootElement.Create();
+
+        ProjectItemElement el1 = ProjectItemElement.CreateDisconnected("ItemB", root);
+        ProjectItemElement el2 = ProjectItemElement.CreateDisconnected("ItemB", root);
+        ProjectItemElement el3 = ProjectItemElement.CreateDisconnected("ItemA", root);
+        ProjectItemElement el4 = ProjectItemElement.CreateDisconnected("ItemB", root);
+        ProjectItemElement el5 = ProjectItemElement.CreateDisconnected("ItemA", root);
+
+        var items = new List<ProjectItemElement>()
+        {
+            el1,
+            el2,
+            el3,
+            el4,
+            el5
+        };
+        var itemsHolder = new ItemsHolder(items, new List<ProjectItemGroupElement>());
+
+        var itemsA = itemsHolder.GetItemsOfType("ItemA").ToList();
+        var itemsB = itemsHolder.GetItemsOfType("ItemB").ToList();
+
+        itemsA.ShouldBeSameIgnoringOrder(new List<ProjectItemElement>() { el3, el5 });
+        itemsB.ShouldBeSameIgnoringOrder(new List<ProjectItemElement>() { el1, el2, el4 });
+    }
+}
diff --git a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
index e38ed53576e..53bb173c271 100644
--- a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
+++ b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
@@ -197,6 +197,7 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
                     // of that error.
                     RegistryView view = (RegistryView)Enum.Parse(typeof(RegistryView), viewAsString, true);
 
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed as a false positive.
                     using (RegistryKey key = GetBaseKeyFromKeyName(keyName, view, out subKeyName))
                     {
                         if (key != null)
@@ -217,6 +218,7 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
                             }
                         }
                     }
+#pragma warning restore CA2000 // Dispose objects before losing scope
                 }
             }
 
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index 73869190849..ebf9109bf72 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -9,9 +9,9 @@
 using System.Collections;
 using System.Diagnostics;
 using System.IO;
+using System.Security.AccessControl;
 using System.Threading;
 using Microsoft.Build.BuildEngine.Shared;
-using System.Security.AccessControl;
 
 namespace Microsoft.Build.BuildEngine
 {
@@ -217,6 +217,7 @@ private static bool CreateGlobalEvents(int nodeNumber)
         /// This function starts local node when process is launched and shuts it down on time out
         /// Called by msbuild.exe.
         /// </summary>
+        [System.Diagnostics.CodeAnalysis.SuppressMessage("Reliability", "CA2000:Dispose objects before losing scope", Justification = "Agreed not to touch entries from Deprecated folder")]
         public static void StartLocalNodeServer(int nodeNumber)
         {
             // Create global events necessary for handshaking with the parent
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index fc6affaa7d2..f686521e233 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -13,6 +13,7 @@
     <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)Test.snk</AssemblyOriginatorKeyFile>
     <PublicKey>002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4</PublicKey>
     <PublicKeyToken>9d77cc7ad39b68eb</PublicKeyToken>
+    <NoWarn>$(NoWarn);CA2000</NoWarn>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(IsUnitTestProject)' == 'true'">
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
new file mode 100644
index 00000000000..b7edcb5161a
--- /dev/null
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -0,0 +1,173 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Base class for all build check event args.
+/// Not intended to be extended by external code.
+/// </summary>
+internal abstract class BuildCheckEventArgs : BuildEventArgs
+{ }
+
+/// <summary>
+/// Transport mean for the BuildCheck tracing data from additional nodes.
+/// </summary>
+/// <param name="tracingData"></param>
+internal sealed class BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> tracingData) : BuildCheckEventArgs
+{
+    internal BuildCheckTracingEventArgs()
+        : this([])
+    {
+    }
+
+    public Dictionary<string, TimeSpan> TracingData { get; private set; } = tracingData;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write7BitEncodedInt(TracingData.Count);
+        foreach (KeyValuePair<string, TimeSpan> kvp in TracingData)
+        {
+            writer.Write(kvp.Key);
+            writer.Write(kvp.Value.Ticks);
+        }
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        int count = reader.Read7BitEncodedInt();
+        TracingData = new Dictionary<string, TimeSpan>(count);
+        for (int i = 0; i < count; i++)
+        {
+            string key = reader.ReadString();
+            TimeSpan value = TimeSpan.FromTicks(reader.ReadInt64());
+
+            TracingData.Add(key, value);
+        }
+    }
+}
+
+internal sealed class BuildCheckAcquisitionEventArgs(string acquisitionPath) : BuildCheckEventArgs
+{
+    internal BuildCheckAcquisitionEventArgs()
+        : this(string.Empty)
+    {
+    }
+
+    /// <summary>
+    /// Gets the path to the analyzer assembly that needs to be loaded into the application context.
+    /// </summary>
+    /// <remarks>
+    /// The <see cref="AcquisitionPath"/> property contains the file system path to the assembly
+    /// that is required to be loaded into the application context. This path is used for loading
+    /// the specified assembly dynamically during runtime.
+    /// </remarks>
+    /// <value>
+    /// A <see cref="System.String"/> representing the file system path to the assembly.
+    /// </value>
+    public string AcquisitionPath { get; private set; } = acquisitionPath;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write(AcquisitionPath);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        AcquisitionPath = reader.ReadString();
+    }
+}
+internal sealed class BuildCheckResultWarning : BuildWarningEventArgs
+{
+    public BuildCheckResultWarning(IBuildCheckResult result)
+    {
+        this.Message = result.FormatMessage();
+    }
+
+    internal BuildCheckResultWarning() { }
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write(Message!);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        Message = reader.ReadString();
+    }
+
+    public override string? Message { get; protected set; }
+}
+
+internal sealed class BuildCheckResultError : BuildErrorEventArgs
+{
+    public BuildCheckResultError(IBuildCheckResult result)
+    {
+        this.Message = result.FormatMessage();
+    }
+
+    internal BuildCheckResultError() { }
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write(Message!);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        Message = reader.ReadString();
+    }
+
+    public override string? Message { get; protected set; }
+}
+
+internal sealed class BuildCheckResultMessage : BuildMessageEventArgs
+{
+    public BuildCheckResultMessage(IBuildCheckResult result)
+    {
+        this.Message = result.FormatMessage();
+    }
+
+    internal BuildCheckResultMessage() { }
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write(Message!);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        Message = reader.ReadString();
+    }
+
+    public override string? Message { get; protected set; }
+}
diff --git a/src/Framework/BuildCheck/IBuildCheckResult.cs b/src/Framework/BuildCheck/IBuildCheckResult.cs
new file mode 100644
index 00000000000..1d471e6c9bc
--- /dev/null
+++ b/src/Framework/BuildCheck/IBuildCheckResult.cs
@@ -0,0 +1,25 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Holder for the reported result of a build cop rule.
+/// </summary>
+internal interface IBuildCheckResult
+{
+    /// <summary>
+    /// Optional location of the finding (in near future we might need to support multiple locations).
+    /// </summary>
+    string LocationString { get; }
+    string[] MessageArgs { get; }
+    string MessageFormat { get; }
+
+    string FormatMessage();
+}
diff --git a/src/Framework/CustomBuildEventArgs.cs b/src/Framework/CustomBuildEventArgs.cs
index c39be4acc91..fe6cbc087b8 100644
--- a/src/Framework/CustomBuildEventArgs.cs
+++ b/src/Framework/CustomBuildEventArgs.cs
@@ -13,10 +13,9 @@ namespace Microsoft.Build.Framework
     /// <remarks>
     /// <format type="text/markdown"><![CDATA[
     /// ## Remarks
-    /// > [!CAUTION]
-    /// In .NET 8 and later and Visual Studio 17.8 and later, this type is deprecated; instead use <xref:Microsoft.Build.Framework.ExtendedCustomBuildEventArgs>.
-    /// For more information, [this link](https://learn.microsoft.com/dotnet/core/compatibility/sdk/8.0/custombuildeventargs).
-    /// For recommended replacement, see [this link](https://learn.microsoft.com/dotnet/core/compatibility/sdk/8.0/custombuildeventargs#recommended-action).
+    /// > [!WARNING]
+    /// > In .NET 8 and later and Visual Studio 17.8 and later, this type is deprecated; instead use [ExtendedCustomBuildEventArgs](/dotnet/api/microsoft.build.framework.extendedcustombuildeventargs).
+    /// > For more information, see [MSBuild custom derived build events deprecated](/dotnet/core/compatibility/sdk/8.0/custombuildeventargs).
     /// ]]></format>
     /// </remarks>
     [Serializable]
diff --git a/src/Framework/Features.cs b/src/Framework/Features.cs
index e5910b3cf5f..ec1183c94f5 100644
--- a/src/Framework/Features.cs
+++ b/src/Framework/Features.cs
@@ -42,6 +42,7 @@ public static class Features
     {
         private static readonly Dictionary<string, FeatureStatus> _featureStatusMap = new Dictionary<string, FeatureStatus>
         {
+            { "BuildCheck.Beta", FeatureStatus.Preview },
             { "EvaluationContext_SharedSDKCachePolicy", FeatureStatus.Available }, // EvaluationContext supports the SharingPolicy.SharedSDKCache flag.
             { "TerminalLogger_MultiLineHandler", FeatureStatus.Available }, // TerminalLogger has better explicit support for rendering multi-line messages
             // Add more features here.
diff --git a/src/Framework/IEventSource.cs b/src/Framework/IEventSource.cs
index 187c105d386..8e5402b6fd3 100644
--- a/src/Framework/IEventSource.cs
+++ b/src/Framework/IEventSource.cs
@@ -3,6 +3,8 @@
 
 #nullable disable
 
+using Microsoft.Build.Experimental.BuildCheck;
+
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -75,6 +77,11 @@ namespace Microsoft.Build.Framework
     /// </summary>
     public delegate void AnyEventHandler(object sender, BuildEventArgs e);
 
+    /// <summary>
+    /// Type of handler for BuildCheckEventRaised events
+    /// </summary>
+    internal delegate void BuildCheckEventHandler(object sender, BuildCheckEventArgs e);
+
     /// <summary>
     /// This interface defines the events raised by the build engine.
     /// Loggers use this interface to subscribe to the events they
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index b543973746e..747a065590e 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -1201,14 +1201,13 @@ internal static void KillTree(int processIdToKill)
 
             // Grab the process handle.  We want to keep this open for the duration of the function so that
             // it cannot be reused while we are running.
-            SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processIdToKill);
-            if (hProcess.IsInvalid)
+            using (SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processIdToKill))
             {
-                return;
-            }
+                if (hProcess.IsInvalid)
+                {
+                    return;
+                }
 
-            try
-            {
                 try
                 {
                     // Kill this process, so that no further children can be created.
@@ -1239,11 +1238,6 @@ internal static void KillTree(int processIdToKill)
                     }
                 }
             }
-            finally
-            {
-                // Release the handle.  After this point no more children of this process exist and this process has also exited.
-                hProcess.Dispose();
-            }
         }
         finally
         {
@@ -1296,11 +1290,9 @@ internal static int GetParentProcessId(int processId)
         else
 #endif
         {
-            SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processId);
-
-            if (!hProcess.IsInvalid)
+            using SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processId);
             {
-                try
+                if (!hProcess.IsInvalid)
                 {
                     // UNDONE: NtQueryInformationProcess will fail if we are not elevated and other process is. Advice is to change to use ToolHelp32 API's
                     // For now just return zero and worst case we will not kill some children.
@@ -1312,10 +1304,6 @@ internal static int GetParentProcessId(int processId)
                         ParentID = (int)pbi.InheritedFromUniqueProcessId;
                     }
                 }
-                finally
-                {
-                    hProcess.Dispose();
-                }
             }
         }
 
@@ -1337,34 +1325,38 @@ internal static List<KeyValuePair<int, SafeProcessHandle>> GetChildProcessIds(in
             {
                 // Hold the child process handle open so that children cannot die and restart with a different parent after we've started looking at it.
                 // This way, any handle we pass back is guaranteed to be one of our actual children.
+#pragma warning disable CA2000 // Dispose objects before losing scope - caller must dispose returned handles
                 SafeProcessHandle childHandle = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, possibleChildProcess.Id);
-                if (childHandle.IsInvalid)
+#pragma warning restore CA2000 // Dispose objects before losing scope
                 {
-                    continue;
-                }
+                    if (childHandle.IsInvalid)
+                    {
+                        continue;
+                    }
 
-                bool keepHandle = false;
-                try
-                {
-                    if (possibleChildProcess.StartTime > parentStartTime)
+                    bool keepHandle = false;
+                    try
                     {
-                        int childParentProcessId = GetParentProcessId(possibleChildProcess.Id);
-                        if (childParentProcessId != 0)
+                        if (possibleChildProcess.StartTime > parentStartTime)
                         {
-                            if (parentProcessId == childParentProcessId)
+                            int childParentProcessId = GetParentProcessId(possibleChildProcess.Id);
+                            if (childParentProcessId != 0)
                             {
-                                // Add this one
-                                myChildren.Add(new KeyValuePair<int, SafeProcessHandle>(possibleChildProcess.Id, childHandle));
-                                keepHandle = true;
+                                if (parentProcessId == childParentProcessId)
+                                {
+                                    // Add this one
+                                    myChildren.Add(new KeyValuePair<int, SafeProcessHandle>(possibleChildProcess.Id, childHandle));
+                                    keepHandle = true;
+                                }
                             }
                         }
                     }
-                }
-                finally
-                {
-                    if (!keepHandle)
+                    finally
                     {
-                        childHandle.Dispose();
+                        if (!keepHandle)
+                        {
+                            childHandle.Dispose();
+                        }
                     }
                 }
             }
diff --git a/src/Framework/Properties/AssemblyInfo.cs b/src/Framework/Properties/AssemblyInfo.cs
index 1f0b9011081..633749084f0 100644
--- a/src/Framework/Properties/AssemblyInfo.cs
+++ b/src/Framework/Properties/AssemblyInfo.cs
@@ -45,6 +45,7 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+[assembly: InternalsVisibleTo("Microsoft.Build.BuildCheck.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 // Ideally we wouldn't need to IVT to OM.UnitTests, which is supposed to test
 // only the public surface area of Microsoft.Build. However, there's a bunch
 // of shared code in Framework that's used there, and we can still avoid IVT
diff --git a/src/Framework/StringUtils.cs b/src/Framework/StringUtils.cs
new file mode 100644
index 00000000000..e5502ab7320
--- /dev/null
+++ b/src/Framework/StringUtils.cs
@@ -0,0 +1,34 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Framework;
+
+internal static class StringUtils
+{
+    /// <summary>
+    /// Generates a random string of the specified length.
+    /// The generated string is suitable for use in file paths.
+    /// The randomness distribution is given by the System.Random.
+    /// </summary>
+    /// <param name="length"></param>
+    /// <returns></returns>
+    internal static string GenerateRandomString(int length)
+    {
+        // Base64, 2^6 = 64
+        const int eachStringCharEncodesBites = 6;
+        const int eachByteHasBits = 8;
+        const double bytesNumNeededForSingleStringChar = eachStringCharEncodesBites / (double)eachByteHasBits;
+
+        int randomBytesNeeded = (int)Math.Ceiling(length * bytesNumNeededForSingleStringChar);
+        Random random = new();
+
+        byte[] randomBytes = new byte[randomBytesNeeded];
+        random.NextBytes(randomBytes);
+        // Base64: [A-Z], [a-z], [0-9], +, /, =
+        // We are replacing '/' to get a valid path
+        string randomBase64String = Convert.ToBase64String(randomBytes).Replace('/', '_');
+        return randomBase64String.Substring(0, length);
+    }
+}
diff --git a/src/Framework/TaskStartedEventArgs.cs b/src/Framework/TaskStartedEventArgs.cs
index bdf19fa080a..288a0193524 100644
--- a/src/Framework/TaskStartedEventArgs.cs
+++ b/src/Framework/TaskStartedEventArgs.cs
@@ -49,6 +49,27 @@ public TaskStartedEventArgs(
         {
         }
 
+        /// <summary>
+        /// This constructor allows event data to be initialized.
+        /// Sender is assumed to be "MSBuild".
+        /// </summary>
+        /// <param name="message">text message</param>
+        /// <param name="helpKeyword">help keyword </param>
+        /// <param name="projectFile">project file</param>
+        /// <param name="taskFile">file in which the task is defined</param>
+        /// <param name="taskName">task name</param>
+        /// <param name="taskAssemblyLocation">The location of the assembly containing the implementation of the task.</param>
+        public TaskStartedEventArgs(
+            string message,
+            string helpKeyword,
+            string projectFile,
+            string taskFile,
+            string taskName,
+            string taskAssemblyLocation)
+            : this(message, helpKeyword, projectFile, taskFile, taskName, DateTime.UtcNow, taskAssemblyLocation)
+        {
+        }
+
         /// <summary>
         /// This constructor allows event data to be initialized.
         /// Sender is assumed to be "MSBuild".
@@ -73,6 +94,33 @@ public TaskStartedEventArgs(
             this.taskFile = taskFile;
         }
 
+        /// <summary>
+        /// This constructor allows event data to be initialized.
+        /// Sender is assumed to be "MSBuild".
+        /// </summary>
+        /// <param name="message">text message</param>
+        /// <param name="helpKeyword">help keyword </param>
+        /// <param name="projectFile">project file</param>
+        /// <param name="taskFile">file in which the task is defined</param>
+        /// <param name="taskName">task name</param>
+        /// <param name="eventTimestamp">Timestamp when event was created</param>
+        /// <param name="taskAssemblyLocation">The location of the assembly containing the implementation of the task.</param>
+        public TaskStartedEventArgs(
+            string message,
+            string helpKeyword,
+            string projectFile,
+            string taskFile,
+            string taskName,
+            DateTime eventTimestamp,
+            string taskAssemblyLocation)
+            : base(message, helpKeyword, "MSBuild", eventTimestamp)
+        {
+            this.taskName = taskName;
+            this.projectFile = projectFile;
+            this.taskFile = taskFile;
+            TaskAssemblyLocation = taskAssemblyLocation;
+        }
+        
         private string taskName;
         private string projectFile;
         private string taskFile;
@@ -91,6 +139,7 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalString(taskFile);
             writer.Write7BitEncodedInt(LineNumber);
             writer.Write7BitEncodedInt(ColumnNumber);
+            writer.WriteOptionalString(TaskAssemblyLocation);
         }
 
         /// <summary>
@@ -102,11 +151,12 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         {
             base.CreateFromStream(reader, version);
 
-            taskName = reader.ReadByte() == 0 ? null : reader.ReadString();
-            projectFile = reader.ReadByte() == 0 ? null : reader.ReadString();
-            taskFile = reader.ReadByte() == 0 ? null : reader.ReadString();
+            taskName = reader.ReadOptionalString();
+            projectFile = reader.ReadOptionalString();
+            taskFile = reader.ReadOptionalString();
             LineNumber = reader.Read7BitEncodedInt();
             ColumnNumber = reader.Read7BitEncodedInt();
+            TaskAssemblyLocation = reader.ReadOptionalString();
         }
         #endregion
 
@@ -135,6 +185,11 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         /// </summary>
         public int ColumnNumber { get; internal set; }
 
+        /// <summary>
+        /// The location of the assembly containing the implementation of the task
+        /// </summary>
+        public string TaskAssemblyLocation { get; private set; }
+
         public override string Message
         {
             get
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index d678ab57d35..8e9d1e09d00 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -133,6 +133,7 @@ public Traits()
         public readonly bool DebugEngine = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildDebugEngine"));
         public readonly bool DebugScheduler;
         public readonly bool DebugNodeCommunication;
+        public readonly bool DebugUnitTests = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildDebugUnitTests"));
 
         public readonly bool InProcNodeDisabled = Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") == "1";
 
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index d2b2b866183..8a2a558e452 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -1,4 +1,6 @@
-ï»¿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <Import Project="$(RepoRoot)eng\BootStrapMsBuild.props" />
 
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
@@ -43,9 +45,9 @@
     <Copy SourceFiles="$(PublishDir)$(AssemblyName).deps.json" DestinationFiles="$(PublishDir)MSBuild.deps.json" SkipUnchangedFiles="true" />
   </Target>
 
-  <Import Project="..\Package\GetBinPaths.targets" Condition="$(TargetFramework.StartsWith('net4'))"/>
-  <Import Project="..\Package\GetBinPaths.Arm64.targets" Condition="$(TargetFramework.StartsWith('net4'))"/>
+  <Import Project="..\Package\GetBinPaths.targets" Condition="$(TargetFramework.StartsWith('net4'))" />
+  <Import Project="..\Package\GetBinPaths.Arm64.targets" Condition="$(TargetFramework.StartsWith('net4'))" />
 
-  <Import Project="$(RepoRoot)eng\BootStrapMSBuild.targets" />
+  <Import Project="$(RepoRoot)eng\BootStrapMsBuild.targets" />
 
 </Project>
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 53e4555fcf2..6ffae8dfb52 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -1185,6 +1185,7 @@ public void InvalidToolsVersionErrors()
                                         graphBuildOptions: null,
                                         lowPriority: false,
                                         question: false,
+                                        isBuildCheckEnabled: false,
                                         inputResultsCaches: null,
                                         outputResultsCache: null,
                                         saveProjectResult: false,
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index 16fbed5a461..2de493e68b9 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -68,7 +68,7 @@ public class MSBuildServer_Tests : IDisposable
         <ProcessIdTask>
             <Output PropertyName=""PID"" TaskParameter=""Pid"" />
         </ProcessIdTask>
-        <Message Text=""Server ID is $(PID)"" Importance=""High"" />
+        <Message Text=""[Work around Github issue #9667 with --interactive]Server ID is $(PID)"" Importance=""High"" />
     </Target>
 </Project>";
         private static string sleepingTaskContentsFormat = @$"
@@ -313,8 +313,8 @@ public void PropertyMSBuildStartupDirectoryOnServer()
         <ProcessIdTask>
             <Output PropertyName=""PID"" TaskParameter=""Pid"" />
         </ProcessIdTask>
-        <Message Text=""Server ID is $(PID)"" Importance=""High"" />
-		<Message Text="":MSBuildStartupDirectory:$(MSBuildStartupDirectory):"" Importance=""high"" />
+        <Message Text=""[Work around Github issue #9667 with --interactive]Server ID is $(PID)"" Importance=""High"" />
+		<Message Text=""[Work around Github issue #9667 with --interactive]:MSBuildStartupDirectory:$(MSBuildStartupDirectory):"" Importance=""high"" />
 	</Target>
 </Project>";
 
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Linux.verified.txt
index 2a011fd87a4..94ea05fb0d6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Linux.verified.txt
@@ -1,9 +1,14 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.OSX.verified.txt
index 94c8f8666eb..56e94ae3408 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,8 +1,13 @@
 ï»¿The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Windows.verified.txt
index 2a011fd87a4..94ea05fb0d6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,9 +1,14 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Linux.verified.txt
index 2a011fd87a4..94ea05fb0d6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Linux.verified.txt
@@ -1,9 +1,14 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.OSX.verified.txt
index 94c8f8666eb..56e94ae3408 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,8 +1,13 @@
 ï»¿The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Windows.verified.txt
index 2a011fd87a4..94ea05fb0d6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,9 +1,14 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Linux.verified.txt
index c0b5f816a67..0b4eb677187 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Linux.verified.txt
@@ -1,8 +1,13 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.OSX.verified.txt
index f2c3daca5c7..0ac0ba155c8 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,7 +1,12 @@
 ï»¿The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Windows.verified.txt
index c0b5f816a67..0b4eb677187 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,8 +1,13 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Linux.verified.txt
index c0b5f816a67..0b4eb677187 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Linux.verified.txt
@@ -1,8 +1,13 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.OSX.verified.txt
index f2c3daca5c7..0ac0ba155c8 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,7 +1,12 @@
 ï»¿The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Windows.verified.txt
index c0b5f816a67..0b4eb677187 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,8 +1,13 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt
index ed7d3ade9de..6e417bd1a11 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt
@@ -1,3 +1,8 @@
 ï»¿]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+  A
+  Multi
+  Line
+  Warning!
 directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt
index b52d4bf957f..63b3c74b0c3 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,2 +1,7 @@
 ï»¿directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+  A
+  Multi
+  Line
+  Warning!
 directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt
index ed7d3ade9de..6e417bd1a11 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,3 +1,8 @@
 ï»¿]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+  A
+  Multi
+  Line
+  Warning!
 directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Linux.verified.txt
index 2a011fd87a4..94ea05fb0d6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Linux.verified.txt
@@ -1,9 +1,14 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.OSX.verified.txt
index 94c8f8666eb..56e94ae3408 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,8 +1,13 @@
 ï»¿The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Windows.verified.txt
index 2a011fd87a4..94ea05fb0d6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,9 +1,14 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Linux.verified.txt
index 34897dfd415..1cd4aa011ed 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Linux.verified.txt
@@ -1,6 +1,6 @@
 ï»¿]9;4;3;\  project test [32;1msucceeded[m (0.2s)
 [?25l[1F
 [?25h
+Test summary: total: 10, [31;1mfailed: 1[m, succeeded: 7, skipped: 2, duration: 1.0s
 Build [32;1msucceeded[m in 5.0s
-Test run [31;1mfailed[m. Total: 10 Failed: 1 Passed: 7 Skipped: 2, Duration: 1.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.OSX.verified.txt
index 6615c0644e7..18ffc7942a8 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.OSX.verified.txt
@@ -1,5 +1,5 @@
 ï»¿  project test [32;1msucceeded[m (0.2s)
 [?25l[1F
 [?25h
+Test summary: total: 10, [31;1mfailed: 1[m, succeeded: 7, skipped: 2, duration: 1.0s
 Build [32;1msucceeded[m in 5.0s
-Test run [31;1mfailed[m. Total: 10 Failed: 1 Passed: 7 Skipped: 2, Duration: 1.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Windows.verified.txt
index 34897dfd415..1cd4aa011ed 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Windows.verified.txt
@@ -1,6 +1,6 @@
 ï»¿]9;4;3;\  project test [32;1msucceeded[m (0.2s)
 [?25l[1F
 [?25h
+Test summary: total: 10, [31;1mfailed: 1[m, succeeded: 7, skipped: 2, duration: 1.0s
 Build [32;1msucceeded[m in 5.0s
-Test run [31;1mfailed[m. Total: 10 Failed: 1 Passed: 7 Skipped: 2, Duration: 1.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
index 955610abad2..7f89f347c25 100644
--- a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
@@ -436,6 +436,7 @@ private void CallAllTypesOfMessagesWarningAndError()
             MessageRaised?.Invoke(_eventSender, MakeMessageEventArgs("Normal importance message!", MessageImportance.Normal));
             MessageRaised?.Invoke(_eventSender, MakeMessageEventArgs("Low importance message!", MessageImportance.Low));
             WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("Warning!"));
+            WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("A\nMulti\r\nLine\nWarning!"));
             ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Error!"));
         }
 
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 1c3aed6df74..73b4b3e282b 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -1989,9 +1989,7 @@ public void TestProcessFileLoggerSwitch1()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             distributedLoggerRecords.Count.ShouldBe(0); // "Expected no distributed loggers to be attached"
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
         }
@@ -2010,9 +2008,7 @@ public void TestProcessFileLoggerSwitch2()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected one distributed loggers to be attached"
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
         }
@@ -2031,9 +2027,7 @@ public void TestProcessFileLoggerSwitch3()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             distributedLoggerRecords.Count.ShouldBe(0); // "Expected no distributed loggers to be attached"
             loggers.Count.ShouldBe(0); // "Expected a central loggers to be attached"
 
@@ -2045,9 +2039,7 @@ public void TestProcessFileLoggerSwitch3()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             distributedLoggerRecords.Count.ShouldBe(0); // "Expected no distributed loggers to be attached"
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
 
@@ -2058,9 +2050,7 @@ public void TestProcessFileLoggerSwitch3()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             distributedLoggerRecords.Count.ShouldBe(0); // "Expected no distributed loggers to be attached"
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
         }
@@ -2079,9 +2069,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($"logFile={Path.Combine(Directory.GetCurrentDirectory(), "MSBuild.log")}", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
@@ -2094,9 +2082,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($"{fileLoggerParameters[0]};logFile={Path.Combine(Directory.GetCurrentDirectory(), "MSBuild.log")}", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
@@ -2109,9 +2095,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($"{fileLoggerParameters[0]};logFile={Path.Combine(Directory.GetCurrentDirectory(), "MSBuild.log")}", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
@@ -2124,9 +2108,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($";Parameter1;logFile={Path.Combine(Directory.GetCurrentDirectory(), "MSBuild.log")}", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
@@ -2139,9 +2121,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe(fileLoggerParameters[0] + ";" + fileLoggerParameters[1], StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
@@ -2152,9 +2132,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($"Parameter1;verbosity=Normal;logFile={Path.Combine(Directory.GetCurrentDirectory(), "..", "cat.log")};Parameter1", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
@@ -2165,9 +2143,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($"Parameter1;Parameter;;;Parameter;Parameter;logFile={Path.Combine(Directory.GetCurrentDirectory(), "msbuild.log")}", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
         }
 
@@ -2185,9 +2161,7 @@ public void TestProcessFileLoggerSwitch5()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           1);
+                           distributedLoggerRecords);
             distributedLoggerRecords.Count.ShouldBe(0); // "Expected no distributed loggers to be attached"
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
         }
@@ -2657,6 +2631,11 @@ public void EndToEndVersionMessage(string arguments, bool shouldContainVersionMe
         [InlineData("/v:normal /bl", MessageImportance.Low)] // v:normal but with binary logger so everything must be logged
         [InlineData("/v:minimal /bl", MessageImportance.Low)] // v:minimal but with binary logger so everything must be logged
         [InlineData("/v:quiet /bl", MessageImportance.Low)] // v:quiet but with binary logger so everything must be logged
+        [InlineData("/v:diagnostic /analyze", MessageImportance.Low)]
+        [InlineData("/v:detailed /analyze", MessageImportance.Low)]
+        [InlineData("/v:normal /analyze", MessageImportance.Low)] // v:normal but with analyzers so everything must be logged
+        [InlineData("/v:minimal /analyze", MessageImportance.Low)] // v:minimal but with analyzers so everything must be logged
+        [InlineData("/v:quiet /analyze", MessageImportance.Low)] // v:quiet but with analyzers so everything must be logged
         public void EndToEndMinimumMessageImportance(string arguments, MessageImportance expectedMinimumMessageImportance)
         {
             using TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create();
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index a4d81b8e2e3..e7800bdf4ca 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -99,6 +99,7 @@ internal enum ParameterizedSwitch
             WarningsNotAsErrors,
             WarningsAsMessages,
             BinaryLogger,
+            Analyze,
             Restore,
             ProfileEvaluation,
             RestoreProperty,
@@ -267,6 +268,7 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "warnnotaserror", "noerr" },           ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false),
             new ParameterizedSwitchInfo(  new string[] { "warnasmessage", "nowarn" },           ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "binarylogger", "bl" },                ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "analyze", },                     ParameterizedSwitch.Analyze,                    null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "restore", "r" },                      ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "profileevaluation", "prof" },         ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false),
             new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false),
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index c6ddf821ce0..1129806b5c5 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1641,10 +1641,25 @@
       {4}: duration in seconds with 1 decimal point
     </comment>
   </data>
-  <data name="TestSummary" xml:space="preserve">
-    <value>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</value>
-    <comment>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</comment>
+  <data name="TestSummary_BannerAndTotal" xml:space="preserve">
+    <value>Test summary: total: {0}</value>
+    <comment>{0} whole number</comment>
+  </data>
+  <data name="TestSummary_Duration" xml:space="preserve">
+    <value>duration: {0}s</value>
+    <comment>{0} whole number</comment>
+  </data>
+  <data name="TestSummary_Failed" xml:space="preserve">
+    <value>failed: {0}</value>
+    <comment>{0} whole number</comment>
+  </data>
+  <data name="TestSummary_Skipped" xml:space="preserve">
+    <value>skipped: {0}</value>
+    <comment>{0} whole number</comment>
+  </data>
+  <data name="TestSummary_Succeeded" xml:space="preserve">
+    <value>succeeded: {0}</value>
+    <comment>{0} whole number</comment>
   </data>
   <!-- **** TerminalLogger strings end **** -->
     <!--
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 00e2e647459..f417ee15051 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -33,14 +33,14 @@
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with {0} error(s)</source>
-        <target state="translated">selhalo s {0} chybou/chybami.</target>
+        <target state="translated">selhalo s {0} chybami.</target>
         <note>
       Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
         <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">selhalo s chybami (celkem {0}) a upozornÄnÃ­mi (celkem {1})</target>
+        <target state="translated">selhalo s {0} chybami a {1} upozornÄnÃ­mi.</target>
         <note>
       Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
@@ -61,7 +61,7 @@
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with {0} warning(s)</source>
-        <target state="translated">uspÄlo s {0} upozornÄnÃ­m(i).</target>
+        <target state="translated">akce probÄhla ÃºspÄÅ¡nÄ s {0} upozornÄnÃ­m(i).</target>
         <note>
       Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
@@ -582,17 +582,20 @@ KdyÅ¾ se nastavÃ­ na MessageUponIsolationViolation (nebo jeho krÃ¡tkÃ½
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;logger&gt;   PouÅ¾Ã­t danÃ½ protokolovacÃ­ nÃ¡stroj k protokolovÃ¡nÃ­ udÃ¡lostÃ­ nÃ¡stroje MSBuild. Pokud chcete zadat 
-                     vÃ­ce protokolovacÃ­ch nÃ¡strojÅ¯, musÃ­te je zadat jednotlivÄ.
-                     Syntaxe hodnoty &lt;logger&gt; je:
-                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
-                     Syntaxe hodnoty &lt;logger class&gt; je:
-                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
-                     Syntaxe hodnoty &lt;logger assembly&gt; je:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+        <target state="translated">  -logger:&lt;protok_nÃ¡st&gt;   PouÅ¾Ã­t danÃ½ protokolovacÃ­ nÃ¡stroj k protokolovÃ¡nÃ­
+                     udÃ¡lostÃ­ nÃ¡stroje MSBuild. Chcete-li zadat vÃ­ce protokolovacÃ­ch.
+                     nÃ¡strojÅ¯, musÃ­te je zadat jednotlivÄ.
+                     Syntaxe hodnoty &lt;protok_nÃ¡st&gt;:
+                        [&lt;tÅÃ­da_protok_nÃ¡st&gt;,]&lt;sestavenÃ­_protok_nÃ¡st&gt;
+                        [;&lt;param_protok_nÃ¡st&gt;]
+                     Syntaxe hodnoty &lt;tÅÃ­da_protok_nÃ¡st&gt;:
+                        [&lt;ÄÃ¡st/Ãºpl_obor_nÃ¡zvÅ¯&gt;.]&lt;nÃ¡z_tÅ_protok_nÃ¡st&gt;
+                     Syntaxe hodnoty &lt;sestavenÃ­_protok_nÃ¡st&gt;:
+                        {&lt;nÃ¡zev_sestavenÃ­&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavenÃ­&gt;}
                      Parametry protokolovacÃ­ho nÃ¡stroje urÄujÃ­, jak MSBuild vytvoÅÃ­ protokolovacÃ­ nÃ¡stroj.
-                     Parametry &lt;logger parameters&gt; jsou volitelnÃ© a pÅedÃ¡vajÃ­ se
-                     protokolovacÃ­mu nÃ¡stroji pÅesnÄ v tom tvaru, v jakÃ©m byly zadÃ¡ny. (KrÃ¡tkÃ½ tvar: -l)
+                     Parametry &lt;param_protok_nÃ¡st&gt; jsou volitelnÃ© a pÅedÃ¡vajÃ­ se 
+                     protokolovacÃ­mu nÃ¡stroji pÅesnÄ v tom tvaru, v jakÃ©m
+                     byly zadÃ¡ny. (KrÃ¡tkÃ½ tvar: -l)
                      PÅÃ­klady:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
@@ -861,20 +864,23 @@ KdyÅ¾ se nastavÃ­ na MessageUponIsolationViolation (nebo jeho krÃ¡tkÃ½
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
-        <target state="translated">  -distributedLogger:&lt;central logger&gt;*&lt;forwarding logger&gt;
-                     PouÅ¾Ã­t zadanÃ½ protokolovacÃ­ nÃ¡stroj pro protokolovÃ¡nÃ­ udÃ¡lostÃ­ z nÃ¡stroje MSBuild; ke kaÅ¾dÃ©mu uzlu pÅipojit
-                     jinou instanci protokolovacÃ­ho nÃ¡stroje. Pokud chcete zadat vÃ­ce
-                     protokolovacÃ­ch nÃ¡strojÅ¯, uveÄte je jednotlivÄ.
+        <target state="translated">  -distributedlogger:&lt;centr_protok_nÃ¡st&gt;*&lt;pÅedÃ¡v_protok_nÃ¡st&gt;                     
+                     PouÅ¾Ã­t zadanÃ½ protokolovacÃ­ nÃ¡stroj pro protokolovÃ¡nÃ­ udÃ¡lostÃ­
+                     z nÃ¡stroje MSBuild; ke kaÅ¾dÃ©mu uzlu pÅipojit jinou instanci 
+                     protokolovacÃ­ho nÃ¡stroje. Chcete-li zadat vÃ­ce 
+                     protokolovacÃ­ch nÃ¡strojÅ¯, uveÄte je jednotlivÄ. 
                      (KrÃ¡tkÃ½ tvar: -dl)
-                     Syntaxe hodnoty &lt;logger&gt; je:
-                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
-                     Syntaxe hodnoty &lt;logger class&gt; je:
-                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
-                     Syntaxe hodnoty &lt;logger assembly&gt; je:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     Syntaxe hodnoty &lt;protok_nÃ¡st&gt;:
+                        [&lt;tÅÃ­da_protok_nÃ¡st&gt;,]&lt;sestav_protok_nÃ¡st&gt;
+                        [;&lt;param_protok_nÃ¡st&gt;]
+                     Syntaxe hodnoty &lt;tÅÃ­da_protok_nÃ¡st&gt;:
+                        [&lt;ÄÃ¡st/Ãºpl_obor_nÃ¡zvÅ¯&gt;.]&lt;nÃ¡z_tÅ_protok_nÃ¡st&gt;
+                     Syntaxe hodnoty &lt;sestav_protok_nÃ¡st&gt;:
+                        {&lt;nÃ¡zev_sestavenÃ­&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavenÃ­&gt;}
                      Parametry protokolovacÃ­ho nÃ¡stroje urÄujÃ­, jak MSBuild vytvoÅÃ­ protokolovacÃ­ nÃ¡stroj.
                      Parametry &lt;param_protok_nÃ¡st&gt; jsou volitelnÃ© a pÅedÃ¡vajÃ­ se
-                     protokolovacÃ­mu nÃ¡stroji pÅesnÄ v zadanÃ©m tvaru. (KrÃ¡tkÃ½ tvar: -l)
+                     protokolovacÃ­mu nÃ¡stroji pÅesnÄ v zadanÃ©m tvaru.
+                     (KrÃ¡tkÃ½ tvar: -l)
                      PÅÃ­klady:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
@@ -1062,7 +1068,7 @@ KdyÅ¾ se nastavÃ­ na MessageUponIsolationViolation (nebo jeho krÃ¡tkÃ½
                                              Verbosity=diagnostic;Encoding=UTF-8
 
                        -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1696,11 +1702,30 @@ KdyÅ¾ se nastavÃ­ na MessageUponIsolationViolation (nebo jeho krÃ¡tkÃ½
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">TestovacÃ­ bÄh {0}. Celkem: {1}, neÃºspÄÅ¡nÃ©: {2}, ÃºspÄÅ¡nÃ©: {3}, pÅeskoÄeno: {4}, doba trvÃ¡nÃ­: {5} s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Souhrn testu: celkem: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">doba trvÃ¡nÃ­: {0} s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">selhalo: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">pÅeskoÄeno: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">ÃºspÄÅ¡nÃ©: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 74ac618d772..50706b404dc 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -119,11 +119,12 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -reportFileAccesses[:True|False]
-                     FÃ¼hrt dazu, dass MSBuild Dateizugriffe auf ein beliebiges konfiguriertes
-                     Projektcache-Plug-In meldet.
+        <target state="translated">  -reportFileAccesses[:True|Falsch]
+                     FÃ¼hrt dazu, dass MSBuild Dateizugriffe an alle konfigurierten
+ meldet
+                     Projektcache-Plug-Ins.
 
-                     Dieses Flag ist experimentell und funktioniert mÃ¶glicherweise nicht wie vorgesehen.
+                     Dieses Kennzeichen ist experimentell und funktioniert mÃ¶glicherweise nicht wie vorgesehen.
     </target>
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
@@ -580,11 +581,11 @@ Dies ist ein restriktiverer Modus von MSBuild, da er erfordert,
         <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben, 
                      wird jede Protokollierung gesondert angegeben.
                      Die Syntax fÃ¼r die &lt;Protokollierung&gt; lautet:
-                       [&lt;Klasse&gt;,]&lt;assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
+                       [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
                      Die Syntax fÃ¼r die &lt;Protokollierungsklasse&gt; lautet:
                         [&lt;Teilweiser oder vollstÃ¤ndiger Namespace&gt;.]&lt;Name der Protokollierungsklasse&gt;
                      Die Syntax fÃ¼r die &lt;Protokollierungsassembly&gt; lautet:
-                        {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
                      Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung Ã¼bergeben, wie sie eingegeben wurden. (Kurzform: -l)
@@ -862,11 +863,11 @@ Dieses Protokollierungsformat ist standardmÃ¤Ãig aktiviert.
                      gesondert angegeben.
                      (Kurzform -dl)
                      Die Syntax fÃ¼r die &lt;Protokollierung&gt; lautet:
-                       [&lt;Klasse&gt;,]&lt;assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
+                       [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
                      Die Syntax fÃ¼r die &lt;Protokollierungsklasse&gt; lautet:
                         [&lt;Teilweiser oder vollstÃ¤ndiger Namespace&gt;.]&lt;Name der Protokollierungsklasse&gt;
                      Die Syntax fÃ¼r die &lt;Protokollierungsassembly&gt; lautet:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
                      Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung Ã¼bergeben, wie sie eingegeben wurden. (Kurzform: -l)
@@ -1689,11 +1690,30 @@ Dieses Protokollierungsformat ist standardmÃ¤Ãig aktiviert.
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Testlauf {0}. Gesamt: {1} Fehlgeschlagen: {2} Erfolgreich: {3} Ãbersprungen: {4}, Dauer: {5}s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Testzusammenfassung: insgesamt: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">Dauer: {0} Sek.</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">fehlgeschlagen: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">Ã¼bersprungen: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">erfolgreich: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 7ec6b54f704..e8e133d96d3 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -123,7 +123,7 @@
                      Hace que MSBuild informe de los accesos a los archivos a cualquier
                      complemento de cachÃ© de proyectos.
 
-                     Esta marca es experimental y puede que no funcione segÃºn lo previsto.
+Esta marca es experimental y puede que no funcione segÃºn lo previsto.
     </target>
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
@@ -578,14 +578,18 @@
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
         <target state="translated">  -logger:&lt;registrador&gt;   Use este registrador para registrar eventos
-                     de MSBuild. Para especificar varios registradores, especifique cada uno de ellos por separado.
+                     de MSBuild. Para especificar varios registradores, especifique
+                     cada uno de ellos por separado.
                      La sintaxis de &lt;registrador&gt; es:
-                       [&lt;clase&gt;,]&lt;assembly&gt;[,&lt;opciones&gt;][;&lt;parÃ¡metros&gt;]
+                       [&lt;clase&gt;,]&lt;ensamblado&gt;[,&lt;opciones&gt;][;&lt;parÃ¡metros&gt;]
                      La sintaxis de &lt;clase del registrador&gt; es:
-                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de clase del registrador&gt;
-                       La sintaxis de &lt;ensamblado del registrador&gt; es:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
-                     Las opciones del registrador especifican cÃ³mo crea MSBuild el registrador.
+                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de
+                       clase del registrador&gt;
+                     La sintaxis de &lt;ensamblado del registrador&gt; es:
+                       {&lt;nombre del ensamblado&gt;[,&lt;strong name&gt;] | &lt;archivo
+                       de ensamblado&gt;}
+                     Las opciones del registrador especifican cÃ³mo crea MSBuild
+                     el registrador.
                      Los &lt;parÃ¡metros del registrador&gt; son opcionales y se pasan
                      al registrador tal como se escriben. (Forma corta: -l)
                      Ejemplos:
@@ -862,12 +866,15 @@
                      Para especificar varios registradores, especifique cada uno
                      de ellos por separado. (Forma corta: -dl)
                      La sintaxis de &lt;registrador&gt; es:
-                       [&lt;clase&gt;,]&lt;assembly&gt;[,&lt;opciones&gt;][;&lt;parÃ¡metros&gt;]
+                       [&lt;clase&gt;,]&lt;ensamblado&gt;[,&lt;opciones&gt;][;&lt;parÃ¡metros&gt;]
                      La sintaxis de &lt;clase del registrador&gt; es:
-                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de la clase del registrador&gt;
+                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre
+                       de la clase del registrador&gt;
                      La sintaxis de &lt;ensamblado del registrador&gt; es:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
-                     Las opciones del registrador especifican cÃ³mo crea MSBuild el registrador.
+                       {&lt;nombre del ensamblado&gt;[,&lt;strong name&gt;] | &lt;archivo
+                      de ensamblado&gt;}
+                     Las opciones del registrador especifican cÃ³mo crea MSBuild
+                     el registrador.
                      Los &lt;parÃ¡metros del registrador&gt; son opcionales y se pasan
                      al registrador tal como se escriben. (Forma corta: -l)
                      Ejemplos:
@@ -1689,11 +1696,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Serie de pruebas {0}. Total: {1} error: {2} Pasado: {3} Omitido: {4}, DuraciÃ³n: {5}s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Resumen de pruebas: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">duraciÃ³n: {0}Â s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">con errores: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">omitido: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">correcto: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 68b3a15005b..bf502af7f50 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -121,7 +121,7 @@
     </source>
         <target state="translated">  -reportFileAccesses[:True|False]
                      EntraÃ®ne le signalement par MSBuild des accÃ¨s par fichiers aux plug-ins
-                     de cache de projet configurÃ©s.
+                     cache de projet configurÃ©s.
 
                      Cet indicateur est expÃ©rimental et peut ne pas fonctionner comme prÃ©vu.
     </target>
@@ -584,7 +584,7 @@ Cet indicateur est expÃ©rimental et peut ne pas fonctionner comme prÃ©vu.
                      Syntaxe de &lt;classe de journalisation&gt;Â :
                        [&lt;espace de noms partiels ou complets&gt;.]&lt;nom de la classe de journalisation&gt;
                      Syntaxe de &lt;assembly de journalisation&gt;Â :
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;nom d'assembly&gt;[,&lt;strong name&gt;] | &lt;fichier d'assembly&gt;}
                      Les options de journalisation spÃ©cifient la faÃ§on dont MSBuild crÃ©e le journaliseur.
                      Les &lt;paramÃ¨tres de journalisation&gt; sont facultatifs. Ils sont passÃ©s
                      au journaliseur tels que vous les avez tapÃ©s. (Forme abrÃ©gÃ©eÂ : -l)
@@ -866,7 +866,7 @@ Remarque : verbositÃ© des enregistreurs dâÃ©vÃ©nements de fichiers
                      Syntaxe de &lt;classe de journalisation&gt;Â :
                        [&lt;espace de noms partiels ou complets&gt;.]&lt;nom de la classe de journalisation&gt;
                      Syntaxe de &lt;assembly de journalisation&gt;Â :
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;nom d'assembly&gt;[,&lt;strong name&gt;] | &lt;fichier d'assembly&gt;}
                      Les options de journalisation spÃ©cifient la faÃ§on dont MSBuild crÃ©e le journaliseur.
                      Les &lt;paramÃ¨tres de journalisation&gt; sont facultatifs. Ils sont passÃ©s
                      au journaliseur tels que vous les avez tapÃ©s. (Forme abrÃ©gÃ©eÂ : -l)
@@ -1339,7 +1339,7 @@ Remarque : verbositÃ© des enregistreurs dâÃ©vÃ©nements de fichiers
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="translated">MSBUILD : error MSB1014: Doit fournir un nom d'Ã©lÃ©ment pour le commutateur getItem.</target>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1348,7 +1348,7 @@ Remarque : verbositÃ© des enregistreurs dâÃ©vÃ©nements de fichiers
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="translated">MSBUILD : error MSB1010: Doit fournir un nom de propriÃ©tÃ© pour le commutateur getProperty.</target>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1366,7 +1366,7 @@ Remarque : verbositÃ© des enregistreurs dâÃ©vÃ©nements de fichiers
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="translated">MSBUILD : error MSB1017: Doit fournir un nom de cible pour le commutateur getTargetResult.</target>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1631,7 +1631,7 @@ Remarque : verbositÃ© des enregistreurs dâÃ©vÃ©nements de fichiers
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="translated">MSBUILD : error MSB1063: Impossible d'accÃ©der aux propriÃ©tÃ©s ou aux Ã©lÃ©ments lors de la crÃ©ation de fichiers de solution ou de fichiers de filtre de solution. Cette fonctionnalitÃ© est disponible uniquement lors de la gÃ©nÃ©ration de projets individuels.</target>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
@@ -1689,11 +1689,30 @@ Remarque : verbositÃ© des enregistreurs dâÃ©vÃ©nements de fichiers
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">SÃ©rie de testsÂ : {0}. TotalÂ : {1} ÃchecÂ : {2}, RÃ©ussiÂ : {3}, IgnorÃ©Â : {4}, DurÃ©eÂ : {5}Â s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">RÃ©capitulatif du testÂ : totalÂ : {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">durÃ©eÂ : {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">Ã©checÂ : {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">ignorÃ©Â : {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">rÃ©ussiÂ : {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 62edb772c61..9963ca29c49 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -120,10 +120,10 @@
                      This flag is experimental and may not work as intended.
     </source>
         <target state="translated">  -reportFileAccesses[:True|False]
-                     Fa in modo che MSBuild segnali gli accessi ai file a qualsiasi
+                     Fa in modo che MSBuild segnali gli accessi ai file a qualsiasi file configurato
                      plug-in della cache del progetto.
 
-                     Questo flag Ã¨ sperimentale e potrebbe non funzionare come previsto.
+Questo flag Ã¨ sperimentale e potrebbe non funzionare come previsto.
     </target>
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
@@ -590,8 +590,8 @@ Questo flag Ã¨ sperimentale e potrebbe non funzionare come previsto.
                        [&lt;classe&gt;,]&lt;assembly&gt;[,&lt;opzioni&gt;][;&lt;parametri&gt;]
                      La sintassi di &lt;classe logger&gt; Ã¨ la seguente:
                        [&lt;spazio dei nomi parziale o completo&gt;.]&lt;nome classe logger&gt;
-                     La sintassi di &lt;logger assembly&gt; Ã¨ la seguente:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     La sintassi di &lt;assembly logger&gt; Ã¨ la seguente:
+                       {&lt;nome assembly&gt;[,&lt;strong name&gt;] | &lt;file di assembly&gt;}
                      Le opzioni di logger consentono di specificare in che modo MSBuild crea il logger.
                      I &lt;parametri logger&gt; sono facoltativi e vengono passati al
                      logger cosÃ¬ come vengono digitati. Forma breve: -l.
@@ -872,8 +872,8 @@ Nota: livello di dettaglio dei logger di file
                        [&lt;classe&gt;,]&lt;assembly&gt;[,&lt;opzioni&gt;][;&lt;parametri&gt;]
                      La sintassi di &lt;classe logger&gt; Ã¨ la seguente:
                        [&lt;spazio dei nomi parziale o completo&gt;.]&lt;nome classe logger&gt;
-                     La sintassi di &lt;logger assembly&gt; Ã¨ la seguente:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     La sintassi di &lt;assembly logger&gt; Ã¨ la seguente:
+                       {&lt;nome assembly&gt;[,&lt;strong name&gt;] | &lt;file di assembly&gt;}
                      Le opzioni di logger consentono di specificare in che modo MSBuild crea il logger.
                      I &lt;parametri logger&gt; sono facoltativi e vengono passati al
                      logger cosÃ¬ come vengono digitati. Forma breve: -l
@@ -992,8 +992,9 @@ Nota: livello di dettaglio dei logger di file
                      Ã¨ la directory corrente. Per impostazione predefinita, ai
                      file viene assegnato il nome "MSBuild&lt;idnodo&gt;.log". Il
                      percorso dei file e altri parametri di fileLogger possono
-                     essere specificati aggiungendo l'opzione "-fileLoggerParameters".
+                     essere specificati aggiungendo l'opzione
 
+                     "-fileLoggerParameters".
                      Se il nome di un file di log viene impostato con l'opzione
                      fileLoggerParameters, il logger distribuito userÃ  il nome
                      file come modello e aggiungerÃ  l'ID del nodo per creare un
@@ -1340,7 +1341,7 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
         <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: Ã¨ necessario fornire un nome funzionalitÃ  per il passaggio a disponibilitÃ  di funzionalitÃ .</target>
+        <target state="translated">MSBUILD : error MSB1067: Ã necessario fornire un nome funzionalitÃ  per il passaggio a disponibilitÃ  funzionalitÃ .</target>
         <note>
       {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
       following the switch, as in "msbuild.exe -featureavailability:blah".
@@ -1699,11 +1700,30 @@ Nota: livello di dettaglio dei logger di file
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Esecuzione dei test {0}. Totale: {1} non superati: {2} superati: {3} ignorati: {4}, durata: {5}s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Riepilogo test: totale: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">durata: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">non riuscito: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">ignorato: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">riuscito: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
@@ -2088,15 +2108,16 @@ Esegue la profilatura della valutazione di MSBuild e scrive
                        -restoreProperty:IsRestore=true;MyProperty=value
     </source>
         <target state="translated">  -restoreProperty:&lt;n&gt;=&lt;v&gt;
-                     Imposta queste proprietÃ  a livello di progetto o ne esegue
-                     l'override solo durante il ripristino e non usa le
-                     proprietÃ  specificate con l'argomento -property.
-                     &lt;v&gt; rappresenta il nome della proprietÃ  e &lt;v&gt; il
-                     valore della proprietÃ . Usare il punto e virgola o la
-                     virgola per delimitare piÃ¹ proprietÃ  o specificare ogni proprietÃ  separatamente.
-                     (Forma breve: -rp)
-                     Esempio:
-                       -restoreProperty:IsRestore=true;MyProperty=value
+                      Imposta queste proprietÃ  a livello di progetto o ne esegue
+                      l'override solo durante il ripristino e non usa le
+                      proprietÃ  specificate con l'argomento -property.
+                      &lt;v&gt; rappresenta il nome della proprietÃ  e &lt;v&gt; il
+                      valore della proprietÃ . Usare il punto e virgola o la
+                      virgola per delimitare piÃ¹ proprietÃ  o specificare ogni
+                      proprietÃ  separatamente.
+                      Forma breve: -rp.
+                      Esempio:
+                        -restoreProperty:IsRestore=true;MyProperty=value
     </target>
         <note>
       LOCALIZATION: "-restoreProperty" and "-rp" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 686748c8286..e7954c3f91c 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -121,7 +121,7 @@
     </source>
         <target state="translated">  -reportFileAccesses[:True|False]
                      MSBuild ããæ§æããã¦ãããã­ã¸ã§ã¯ã ã­ã£ãã·ã¥ ãã©ã°ã¤ã³ã¸ã®
-                     ãã¡ã¤ã« ã¢ã¯ã»ã¹ãå ±åããããã«ãã¾ãã
+                     ãã¡ã¤ã« ã¢ã¯ã»ã¹ãå ±åãã¾ãã
 
                      ãã®ãã©ã°ã¯å®é¨çãªãã®ã§ãããæå³ããã¨ããã«åä½ããªãå¯è½æ§ãããã¾ãã
     </target>
@@ -142,7 +142,7 @@
       </trans-unit>
       <trans-unit id="InvalidTerminalLoggerValue">
         <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
-        <target state="translated">MSBUILD : error MSB1065: ã¿ã¼ããã« ã­ã¬ã¼ã®å¤ãç¡å¹ã§ãã'auto'ã'true'ãã¾ãã¯ 'false' ã®ããããã§ããå¿è¦ãããã¾ãã{0}</target>
+        <target state="translated">MSBUILD : error MSB1065: ã¿ã¼ããã« ã­ã¬ã¼ã®å¤ãç¡å¹ã§ãã'auto'ã'true'ãã¾ãã¯ 'false' ã®ããããã§ããå¿è¦ãããã¾ãã {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1065: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1689,11 +1689,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">{0}ãããã¹ãå®è¡ãã¾ããåè¨: {1} ä¸åæ ¼: {2} åæ ¼: {3} ã¹ã­ãã: {4}ãæé: {5} ç§</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">ãã¹ãæ¦è¦: åè¨: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">æé: {0} ç§</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">å¤±ææ°: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">ã¹ã­ããæ¸ã¿æ°: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">æåæ°: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index ddebf3ab442..f995ca421bc 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -580,11 +580,11 @@
         <target state="translated">  -logger:&lt;ë¡ê±°&gt;   ì´ ë¡ê±°ë¥¼ ì¬ì©íì¬ MSBuildì ì´ë²¤í¸ë¥¼ ê¸°ë¡í©ëë¤. ì¬ë¬
                      ë¡ê±°ë¥¼ ì§ì íë ¤ë©´ ê° ë¡ê±°ë¥¼ ê°ë³ì ì¼ë¡ ì§ì í©ëë¤.
                      &lt;ë¡ê±°&gt; êµ¬ë¬¸ì ë¤ìê³¼ ê°ìµëë¤.
-                       [&lt;í´ëì¤&gt;,]&lt;assembly&gt;[,&lt;ìµì&gt;][;&lt;ë§¤ê° ë³ì&gt;]
+                       [&lt;í´ëì¤&gt;,]&lt;ì´ìë¸ë¦¬&gt;[,&lt;ìµì&gt;][;&lt;ë§¤ê° ë³ì&gt;]
                      &lt;ë¡ê±° í´ëì¤&gt; êµ¬ë¬¸ì ë¤ìê³¼ ê°ìµëë¤.
                        [&lt;ë¶ë¶ ëë ì ì²´ ë¤ìì¤íì´ì¤&gt;.]&lt;ë¡ê±° í´ëì¤ ì´ë¦&gt;
                      &lt;ë¡ê±° ì´ìë¸ë¦¬&gt; êµ¬ë¬¸ì ë¤ìê³¼ ê°ìµëë¤.
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;ì´ìë¸ë¦¬ ì´ë¦&gt;[,&lt;strong name&gt;] | &lt;ì´ìë¸ë¦¬ íì¼&gt;}
                      ë¡ê±° ìµìì MSBuildê° ë¡ê±°ë¥¼ ë§ëë ë°©ë²ì ì§ì í©ëë¤.
                      &lt;ë¡ê±° ë§¤ê° ë³ì&gt;ë ì í ì¬í­ì´ê³  ìë ¥í ëë¡ ì íí
                      ë¡ê±°ì ì ë¬ë©ëë¤. (ì½ì: -l)
@@ -862,11 +862,11 @@
                      ë¡ê±°ë¥¼ ì§ì íë ¤ë©´ ê° ë¡ê±°ë¥¼ ê°ë³ì ì¼ë¡ ì§ì í©ëë¤.
                      (ì½ì -dl)
                      &lt;ë¡ê±°&gt; êµ¬ë¬¸ì ë¤ìê³¼ ê°ìµëë¤.
-                       [&lt;í´ëì¤&gt;,]&lt;assembly&gt;[,&lt;ìµì&gt;][;&lt;ë§¤ê° ë³ì&gt;]
+                       [&lt;í´ëì¤&gt;,]&lt;ì´ìë¸ë¦¬&gt;[,&lt;ìµì&gt;][;&lt;ë§¤ê° ë³ì&gt;]
                      &lt;ë¡ê±° í´ëì¤&gt; êµ¬ë¬¸ì ë¤ìê³¼ ê°ìµëë¤.
                        [&lt;ë¶ë¶ ëë ì ì²´ ë¤ìì¤íì´ì¤&gt;.]&lt;ë¡ê±° í´ëì¤ ì´ë¦&gt;
                      &lt;ë¡ê±° ì´ìë¸ë¦¬&gt; êµ¬ë¬¸ì ë¤ìê³¼ ê°ìµëë¤.
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;ì´ìë¸ë¦¬ ì´ë¦&gt;[,&lt;strong name&gt;] | &lt;ì´ìë¸ë¦¬ íì¼&gt;}
                      ë¡ê±° ìµìì MSBuildê° ë¡ê±°ë¥¼ ë§ëë ë°©ë²ì ì§ì í©ëë¤.
                       &lt;ë¡ê±° ë§¤ê° ë³ì&gt;ë ì í ì¬í­ì´ê³ 
                      ìë ¥í ëë¡ ì íí ë¡ê±°ì ì ë¬ë©ëë¤. (ì½ì: -l)
@@ -1689,11 +1689,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">{0} íì¤í¸ë¥¼ ì¤íí©ëë¤. í©ê³: {1} ì¤í¨: {2} íµê³¼: {3} ê±´ëë: {4}, ê¸°ê°: {5}ì´</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">íì¤í¸ ìì½: í©ê³: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">ê¸°ê°: {0}ì´</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">ì¤í¨: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">ê±´ëë: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">ì±ê³µ: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index fb1b6dec832..6d1956125cd 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -120,10 +120,10 @@
                      This flag is experimental and may not work as intended.
     </source>
         <target state="translated">  -reportFileAccesses[:True|False]
-                     Powoduje, Å¼e platforma MSBuild zgÅasza dostÄpy do wszystkich skonfigurowanych
+                     Powoduje, Å¼e program MSBuild zgÅasza dostÄpy do wszystkich skonfigurowanych plikÃ³w
                      wtyczek pamiÄci podrÄcznej projektu.
 
-                     Ta flaga jest eksperymentalna i moÅ¼e nie dziaÅaÄ zgodnie z oczekiwaniami.
+Ta flaga jest eksperymentalna i moÅ¼e nie dziaÅaÄ zgodnie z oczekiwaniami.
     </target>
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
@@ -582,14 +582,17 @@
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;rejestrator&gt;  UmoÅ¼liwia uÅ¼ycie podanego rejestratora do rejestrowania zdarzeÅ pochodzÄcych
-                     z programu MSBuild. Aby okreÅliÄ wiele rejestratorÃ³w, okreÅl kaÅ¼dy z nich osobno.
+        <target state="translated">  -logger:&lt;rejestrator&gt;  UmoÅ¼liwia uÅ¼ycie podanego rejestratora do rejestrowania
+                         zdarzeÅ pochodzÄcych z programu MSBuild. Aby okreÅliÄ
+                     wiele rejestratorÃ³w, okreÅl kaÅ¼dy z nich osobno.
                      SkÅadnia elementu &lt;rejestrator&gt;:
-                      [&lt;klasa rejestratora&gt;,]&lt;assembly&gt; [;&lt;parametry rejestratora&gt;]
+                        [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;
+                        [;&lt;parametry rejestratora&gt;]
                      SkÅadnia elementu &lt;klasa rejestratora&gt;:
-                       [&lt;czÄÅciowa lub peÅna przestrzeÅ nazw&gt;.] &lt;nazwa klasy rejestratora&gt;
+                        [&lt;czÄÅciowa lub peÅna przestrzeÅ nazw&gt;.]
+                        &lt;nazwa klasy rejestratora&gt;
                      SkÅadnia elementu &lt;zestaw rejestratora&gt;:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                        {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
                      WartoÅci &lt;parametry rejestratora&gt; sÄ opcjonalne i sÄ
                      przekazywane do rejestratora dokÅadnie tak, jak zostaÅy
                      wpisane. (KrÃ³tka wersja: -l)
@@ -868,11 +871,11 @@
                      wiele rejestratorÃ³w, okreÅl kaÅ¼dy z nich osobno.
                      (KrÃ³tka wersja: -dl)
                      SkÅadnia elementu &lt;rejestrator&gt;:
-                       [&lt;klasa rejestratora&gt;,]&lt;assembly&gt;[;&lt;parametry rejestratora&gt;]
+                       [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;[;&lt;parametry rejestratora&gt;]
                      SkÅadnia elementu &lt;klasa rejestratora&gt;:
                        [&lt;czÄÅciowa lub peÅna przestrzeÅ nazw&gt;.]&lt;nazwa klasy rejestratora&gt;
                      SkÅadnia elementu &lt;zestaw rejestratora&gt;:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
                      WartoÅci &lt;parametry rejestratora&gt; sÄ opcjonalne i sÄ
                      przekazywane do rejestratora dokÅadnie tak, jak zostaÅy
                      wpisane. (KrÃ³tka wersja: -l)
@@ -984,11 +987,13 @@
                      create a log file for each node.
     </source>
         <target state="translated">  -distributedFileLogger
-                     Rejestruje dane wyjÅciowe kompilacji w wielu plikach dziennika,po jednym pliku
-                     na wÄzeÅ programu MSBuild. PoczÄtkowÄ lokalizacjÄ tych plikÃ³w
-                     jest bieÅ¼Äcy katalog. DomyÅlnie pliki majÄ nazwÄ
+                     Rejestruje dane wyjÅciowe kompilacji w wielu plikach
+                     dziennika, po jednym pliku na wÄzeÅ programu MSBuild.
+                     PoczÄtkowÄ lokalizacjÄ tych plikÃ³w jest bieÅ¼Äcy katalog.
+                     DomyÅlnie pliki majÄ nazwÄ
                      âMSBuild&lt;identyfikator wÄzÅa&gt;.logâ. LokalizacjÄ plikÃ³w
                      i inne parametry rejestratora plikÃ³w moÅ¼na okreÅliÄ
+
                      przez dodanie przeÅÄcznika â-fileLoggerParametersâ.
 
                      JeÅli nazwa pliku zostanie ustawiona za pomocÄ przeÅÄcznika
@@ -1695,11 +1700,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Przebieg testu {0}. ÅÄcznie: {1} niepowodzenie: {2} zakoÅczone powodzeniem: {3} pominiÄto: {4}, czas trwania: {5}s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Podsumowanie testu: ÅÄcznie: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">czas trwania: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">niepowodzenie: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">pominiÄto: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">zakoÅczone powodzeniem: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 5b12a8d74c8..4e3266b9533 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -120,9 +120,8 @@
                      This flag is experimental and may not work as intended.
     </source>
         <target state="translated">  -reportFileAccesses[:True|False]
-                     Faz com que o MSBuild relate acessos a arquivos a qualquer
- configurado
-                     plug-ins de cache do projeto.
+                     Faz com que o MSBuild relate acessos a arquivos para qualquer plug-in
+                     de cache de projeto configurado.
 
                      Este sinalizador Ã© experimental e pode nÃ£o funcionar conforme o esperado.
     </target>
@@ -1691,11 +1690,30 @@ arquivo de resposta.
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">ExecuÃ§Ã£o de teste {0}. Total: {1} Falha: {2} Aprovado: {3} Ignorado: {4}, DuraÃ§Ã£o: {5}s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">ResumoÂ do teste: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">duraÃ§Ã£o: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">falhou: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">ignorado: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">bem-sucedido: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 27ad009b870..2c27bb72d73 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -86,7 +86,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}Ñ)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -142,7 +142,7 @@
       </trans-unit>
       <trans-unit id="InvalidTerminalLoggerValue">
         <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
-        <target state="translated">MSBUILD : error MSB1065: ÐÐµÐ´Ð¾Ð¿ÑÑÑÐ¸Ð¼Ð¾Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ ÑÑÐµÐ´ÑÑÐ²Ð° Ð²ÐµÐ´ÐµÐ½Ð¸Ñ Ð¶ÑÑÐ½Ð°Ð»Ð° ÑÐµÑÐ¼Ð¸Ð½Ð°Ð»Ð°. Ð­ÑÐ¾ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ Ð¾Ð´Ð½Ð¾ Ð¸Ð· ÑÐ»ÐµÐ´ÑÑÑÐ¸Ñ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¹: "auto", "ÐÐ¡Ð¢ÐÐÐ" Ð¸Ð»Ð¸ "ÐÐÐÐ¬". {0}</target>
+        <target state="new">MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1065: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1356,7 +1356,7 @@
       </trans-unit>
       <trans-unit id="MissingGetResultFileError">
         <source>MSBUILD : error MSB1068: Must provide a file for the getResultOutputFile switch.</source>
-        <target state="translated">MSBUILD : error MSB1068: Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾ Ð¿ÑÐµÐ´Ð¾ÑÑÐ°Ð²Ð¸ÑÑ ÑÐ°Ð¹Ð» Ð´Ð»Ñ Ð¿ÐµÑÐµÐºÐ»ÑÑÐ°ÑÐµÐ»Ñ getResultOutputFile.</target>
+        <target state="translated">MSBUILD : error MSB1068: Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾ ÑÐºÐ°Ð·Ð°ÑÑ ÑÐ°Ð¹Ð» Ð´Ð»Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ° getResultOutputFile.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1068: "}UE: This happens if the user does something like "msbuild.exe -getResultOutputFile". The user must pass in an actual file
       following the switch, as in "msbuild.exe -getTargetResult:blah -getResultOutputFile:blah.txt".
@@ -1688,11 +1688,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Ð¢ÐµÑÑÐ¾Ð²ÑÐ¹ Ð·Ð°Ð¿ÑÑÐº {0}. ÐÑÐµÐ³Ð¾: {1}, Ð½Ðµ Ð¿ÑÐ¾Ð¹Ð´ÐµÐ½Ð¾: {2}, Ð¿ÑÐ¾Ð¹Ð´ÐµÐ½Ð¾: {3}, Ð¿ÑÐ¾Ð¿ÑÑÐµÐ½Ð¾: {4}, Ð´Ð»Ð¸ÑÐµÐ»ÑÐ½Ð¾ÑÑÑ: {5}Â Ñ</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Ð¡Ð²Ð¾Ð´ÐºÐ° ÑÐµÑÑÐ°: Ð²ÑÐµÐ³Ð¾: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">Ð´Ð»Ð¸ÑÐµÐ»ÑÐ½Ð¾ÑÑÑ: {0}Â Ñ</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">ÑÐ±Ð¾Ð¹: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">Ð¿ÑÐ¾Ð¿ÑÑÐµÐ½Ð¾: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">ÑÑÐ¿ÐµÑÐ½Ð¾: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 52a46bd9af1..86fc2093ac5 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -86,7 +86,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="translated">({0:F1} sn)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -580,13 +580,13 @@
         <target state="translated">  -logger:&lt;gÃ¼nlÃ¼kÃ§Ã¼&gt;   MSBuild'deki olaylarÄ± gÃ¼nlÃ¼Äe almak iÃ§in bu gÃ¼nlÃ¼kÃ§Ã¼yÃ¼ kullanÄ±n. Birden fazla
                      gÃ¼nlÃ¼kÃ§Ã¼ belirtmek iÃ§in her gÃ¼nlÃ¼kÃ§Ã¼yÃ¼ ayrÄ± ayrÄ± belirtin.
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼&gt; sÃ¶z dizimi ÅÃ¶yledir:
-                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                       [&lt;sÄ±nÄ±f&gt;,]&lt;derleme&gt;[,&lt;seÃ§enekler&gt;][;&lt;parametreler&gt;]
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼ sÄ±nÄ±fÄ± &gt; sÃ¶z dizimi ÅÃ¶yledir:
                        [&lt;kÄ±smi veya tam ad alanÄ± &gt;.]&lt;gÃ¼nlÃ¼kÃ§Ã¼ sÄ±nÄ±fÄ± adÄ±&gt;
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼ derlemesi&gt; sÃ¶z dizimi ÅÃ¶yledir:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;derleme adÄ±&gt;[,&lt;strong name&gt;] | &lt;derleme dosyasÄ±&gt;}
                      GÃ¼nlÃ¼kÃ§Ã¼ seÃ§enekleri, MSBuild'in gÃ¼nlÃ¼kÃ§Ã¼yÃ¼ oluÅturma biÃ§imini belirtir.
-                     &lt;gÃ¼nlÃ¼kÃ§Ã¼ parametreleri &gt; isteÄe baÄlÄ±dÄ±r ve tam olarak
+                     &lt;gÃ¼nlÃ¼kÃ§Ã¼ parametreleri &gt; isteÄe baÄlÄ±dÄ±r ve tam olarak 
                      yazdÄ±ÄÄ±nÄ±z Åekliyle gÃ¼nlÃ¼kÃ§Ã¼ye geÃ§irilir. (KÄ±sa biÃ§im: -l)
                      Ãrnekler:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -862,11 +862,11 @@
                      gÃ¼nlÃ¼kÃ§Ã¼ belirtmek iÃ§in her gÃ¼nlÃ¼kÃ§Ã¼yÃ¼ ayrÄ± ayrÄ± belirtin.
                      (KÄ±sa biÃ§im -dl)
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼&gt; sÃ¶z dizimi ÅÃ¶yledir:
-                       [&lt;sÄ±nÄ±f&gt;,]&lt;assembly&gt;[,&lt;seÃ§enekler&gt;][;&lt;parametreler&gt;]
+                       [&lt;sÄ±nÄ±f&gt;,]&lt;derleme&gt;[,&lt;seÃ§enekler&gt;][;&lt;parametreler&gt;]
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼ sÄ±nÄ±fÄ±&gt; sÃ¶z dizimi ÅÃ¶yledir:
                        [&lt;kÄ±smi veya tam ad alanÄ±&gt;.]&lt;gÃ¼nlÃ¼kÃ§Ã¼ sÄ±nÄ±fÄ± adÄ±&gt;
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼ derlemesi&gt; sÃ¶z dizimi ÅÃ¶yledir:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;derleme adÄ±&gt;[,&lt;strong name&gt;] | &lt;derleme dosyasÄ±&gt;}
                      GÃ¼nlÃ¼kÃ§Ã¼ seÃ§enekleri, MSBuild'in gÃ¼nlÃ¼kÃ§Ã¼yÃ¼ oluÅturma biÃ§imini belirtir.
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼ parametreleri&gt; isteÄe baÄlÄ±dÄ±r ve tam olarak
                      yazdÄ±ÄÄ±nÄ±z Åekliyle gÃ¼nlÃ¼kÃ§Ã¼ye geÃ§irilir. (KÄ±sa biÃ§im: -l)
@@ -893,9 +893,10 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;uzantÄ±lar&gt;
-                     Hangi proje dosyasÄ±nÄ±n oluÅturulacaÄÄ± belirlenirken
-                     yoksayÄ±lacak uzantÄ±larÄ±n listesi. Birden Ã§ok uzantÄ±yÄ±
-                     birbirinden ayÄ±rmak iÃ§in noktalÄ± virgÃ¼l veya virgÃ¼l kullanÄ±n.
+                     Hangi proje dosyasÄ±nÄ±n oluÅturulacaÄÄ± belirlenirken 
+                     yoksayÄ±lacak uzantÄ±larÄ±n listesi. Birden Ã§ok uzantÄ±yÄ± 
+                     birbirinden ayÄ±rmak iÃ§in noktalÄ± virgÃ¼l veya 
+                     virgÃ¼l kullanÄ±n.
                      (KÄ±sa biÃ§im: -ignore)
                      Ãrnek:
                        -ignoreProjectExtensions:.sln
@@ -985,6 +986,7 @@
                      DosyalarÄ±n konumu ve fileLogger'Ä±n diÄer parametreleri 
                      "/fileLoggerParameters" anahtarÄ±nÄ±n eklenmesi yoluyla
                      belirtilebilir.
+
                      GÃ¼nlÃ¼k dosyasÄ± adÄ± fileLoggerParameters anahtarÄ±
                      aracÄ±lÄ±ÄÄ±yla ayarlanÄ±rsa daÄÄ±tÄ±lmÄ±Å gÃ¼nlÃ¼kÃ§Ã¼ fileName 
                      deÄerini Åablon olarak kullanÄ±p her dÃ¼ÄÃ¼mÃ¼n gÃ¼nlÃ¼k dosyasÄ±nÄ±
@@ -1031,31 +1033,32 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parametreler&gt;
                      Dosya gÃ¼nlÃ¼kÃ§Ã¼leri iÃ§in ek parametreler saÄlar.
-                     Bu anahtarÄ±n olmasÄ± karÅÄ±lÄ±k gelen -fileLogger[n]
+                     Bu anahtarÄ±n olmasÄ± karÅÄ±lÄ±k gelen -fileLogger[n] 
                      anahtarÄ±nÄ±n olduÄu anlamÄ±na gelir.
                      "n" varsa, 1-9 arasÄ±nda bir rakam olabilir.
-                     DaÄÄ±tÄ±lmÄ±Å dosya gÃ¼nlÃ¼kÃ§Ã¼leri varsa -fileLoggerParameters
-                     bunlar tarafÄ±ndan da kullanÄ±lÄ±r; -distributedFileLogger aÃ§Ä±klamasÄ±na bakÄ±n.
+                     DaÄÄ±tÄ±lmÄ±Å dosya gÃ¼nlÃ¼kÃ§Ã¼leri varsa -fileLoggerParameters 
+                     bunlar tarafÄ±ndan da kullanÄ±lÄ±r; -distributedFileLogger 
+                     aÃ§Ä±klamasÄ±na bakÄ±n.
                      (KÄ±sa biÃ§im: -flp[n])
-                     Konsol gÃ¼nlÃ¼kÃ§Ã¼sÃ¼ iÃ§in listelenenlerle aynÄ± parametreler
+                     Konsol gÃ¼nlÃ¼kÃ§Ã¼sÃ¼ iÃ§in listelenenlerle aynÄ± parametreler 
                      kullanÄ±labilir. KullanÄ±labilecek bazÄ± ek parametreler:
-                        LogFile--OluÅturma gÃ¼nlÃ¼ÄÃ¼nÃ¼n yazÄ±lacaÄÄ± gÃ¼nlÃ¼k
+                        LogFile--OluÅturma gÃ¼nlÃ¼ÄÃ¼nÃ¼n yazÄ±lacaÄÄ± gÃ¼nlÃ¼k 
                             dosyasÄ±nÄ±n yolu.
-                        Append--Derleme gÃ¼nlÃ¼ÄÃ¼nÃ¼n gÃ¼n dosyasÄ±nÄ±n sonuna mÄ±
-                            ekleneceÄini yoksa Ã¼zerine mi yazÄ±lacaÄÄ±nÄ±
-                            belirler. Anahtar ayarlandÄ±ÄÄ±nda oluÅturma gÃ¼nlÃ¼ÄÃ¼
-                            dosyanÄ±n sonuna eklenir. Anahtar ayarlanmadÄ±ÄÄ±nda
-                            varolan gÃ¼nlÃ¼k dosyasÄ±nÄ±n Ã¼zerine yazÄ±lÄ±r.
+                        Append--Derleme gÃ¼nlÃ¼ÄÃ¼nÃ¼n gÃ¼n dosyasÄ±nÄ±n sonuna mÄ± 
+                            ekleneceÄini yoksa Ã¼zerine mi yazÄ±lacaÄÄ±nÄ± 
+                            belirler. Anahtar ayarlandÄ±ÄÄ±nda oluÅturma gÃ¼nlÃ¼ÄÃ¼ 
+                            dosyanÄ±n sonuna eklenir. Anahtar ayarlanmadÄ±ÄÄ±nda 
+                            varolan gÃ¼nlÃ¼k dosyasÄ±nÄ±n Ã¼zerine yazÄ±lÄ±r. 
                             VarsayÄ±lan: gÃ¼nlÃ¼k dosyasÄ±nÄ±n sonuna eklenmez.
-                        Encoding--DosyanÄ±n kodlamasÄ±nÄ± belirtir; Ã¶rneÄin,
+                        Encoding--DosyanÄ±n kodlamasÄ±nÄ± belirtir; Ã¶rneÄin, 
                             UTF-8, Unicode veya ASCII
                      VarsayÄ±lan ayrÄ±ntÄ± dÃ¼zeyi ayarÄ± Detailed'dÄ±r.
                      Ãrnekler:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1079,7 +1082,8 @@
                        -nr:true
     </source>
         <target state="translated">  -nodeReuse:&lt;parametreler&gt;
-                     MSBuild dÃ¼ÄÃ¼mlerinin yeniden kullanÄ±mÄ±nÄ± etkinleÅtirir veya devre dÄ±ÅÄ± bÄ±rakÄ±r.
+                     MSBuild dÃ¼ÄÃ¼mlerinin yeniden kullanÄ±mÄ±nÄ± etkinleÅtirir
+                     veya devre dÄ±ÅÄ± bÄ±rakÄ±r.
                      Parametreler:
                      True --Derleme tamamlandÄ±ktan sonra dÃ¼ÄÃ¼mler kalÄ±r ve
                             izleyen derlemelerde yeniden kullanÄ±lÄ±r (varsayÄ±lan)
@@ -1428,7 +1432,7 @@
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="translated">MSBUILD : error MSB1066: terminalLoggerParameters anahtarÄ± kullanÄ±lÄ±yorsa terminal gÃ¼nlÃ¼kÃ§Ã¼sÃ¼ iÃ§in bir veya birden Ã§ok parametre belirtin</target>
+        <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters anahtarÄ± kullanÄ±lÄ±yorsa terminal gÃ¼nlÃ¼kÃ§Ã¼sÃ¼ iÃ§in bir veya birden Ã§ok parametre belirtin</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1689,11 +1693,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Test Ã§alÄ±ÅtÄ±rmasÄ± {0}. Toplam: {1} BaÅarÄ±sÄ±z: {2} GeÃ§ti: {3} AtlandÄ±: {4}, SÃ¼re: {5}s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Test Ã¶zeti: toplam: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">sÃ¼re: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">baÅarÄ±sÄ±z: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">atlandÄ±: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">baÅarÄ±lÄ±: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 2e64124c6d3..78c661b0857 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -17,7 +17,7 @@
       </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
-        <target state="translated">å¨ {1} ä¸­çæ {0}</target>
+        <target state="translated">å¨ {1} ç§åçæ {0}</target>
         <note>
       Overall build summary
       {0}: BuildResult_X (below)
@@ -1510,7 +1510,7 @@
       </trans-unit>
       <trans-unit id="ProjectFinished_NoTF">
         <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3})</target>
+        <target state="translated">{0}{1} {2} ({3} ç§)</target>
         <note>
       Project finished summary.
       {0}: indentation - few spaces to visually indent row
@@ -1588,14 +1588,14 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="translated">è¿åå®æ({0})</target>
+        <target state="translated">è¿åå®æ({0} ç§)</target>
         <note>
       {0}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="translated">å¨ {1} ä¸­è¿å {0}</target>
+        <target state="translated">å¨ {1} ç§åè¿å {0}</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
@@ -1689,11 +1689,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">æµè¯è¿è¡ {0}ãæ»è®¡: {1} å¤±è´¥: {2} éè¿: {3} è·³è¿: {4}, æç»­æ¶é´: {5} ç§</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">æµè¯æè¦: æ»è®¡: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">æç»­æ¶é´: {0} ç§</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">å¤±è´¥: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">å·²è·³è¿: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">æå: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 6a70c9a06b1..29c76948500 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -580,11 +580,11 @@
         <target state="translated">  -logger:&lt;è¨éå¨&gt;   ä½¿ç¨æ­¤è¨éå¨å¯è¨é MSBuild çäºä»¶ã
                      è¥è¦æå®å¤åè¨éå¨ï¼è«åå¥æå®æ¯åè¨éå¨ã
                      &lt;è¨éå¨&gt; èªæ³çº:
-                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                       [&lt;é¡å¥&gt;,]&lt;çµä»¶&gt;[,&lt;é¸é &gt;][;&lt;åæ¸&gt;]
                      &lt;è¨éå¨é¡å¥&gt; èªæ³çº:
                        [&lt;ä¸é¨åæå®æ´çå½åç©ºé&gt;.]&lt;è¨éå¨é¡å¥åç¨±&gt;
                      &lt;è¨éå¨çµä»¶&gt; èªæ³çº:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;çµä»¶åç¨±&gt;[,&lt;strong name&gt;] | &lt;çµä»¶æªæ¡&gt;}
                      è¨éå¨é¸é ææå® MSBuild å»ºç«è¨éå¨çæ¹å¼ã
                      &lt;è¨éå¨åæ¸&gt; æ¯é¸ææ§åæ¸ï¼å¶æä¾æ¨è¼¸å¥çå§å®¹ï¼
                      å®å¨ä¸æ¨£å°å³éå°è¨éå¨ã(ç°¡ç­å½¢å¼: -l)
@@ -862,11 +862,11 @@
                      è¥è¦æå®å¤åè¨éå¨ï¼è«åå¥æå®æ¯åè¨éå¨ã
                      (ç°¡ç­å½¢å¼ -dl)
                      &lt;è¨éå¨&gt; èªæ³çº:
-                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                       [&lt;é¡å¥&gt;,]&lt;çµä»¶&gt;[,&lt;é¸é &gt;][;&lt;åæ¸&gt;]
                      &lt;è¨éå¨é¡å¥&gt; èªæ³çº:
                        [&lt;ä¸é¨åæå®æ´çå½åç©ºé&gt;.]&lt;è¨éå¨é¡å¥åç¨±&gt;
                      &lt;è¨éå¨çµä»¶&gt; èªæ³çº:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;çµä»¶åç¨±&gt;[,&lt;strong name&gt;] | &lt;çµä»¶æªæ¡&gt;}
                      è¨éå¨é¸é ææå® MSBuild å»ºç«è¨éå¨çæ¹å¼ã
                      &lt;è¨éå¨åæ¸&gt; æ¯é¸ææ§åæ¸ï¼å¶æä¾æ¨è¼¸å¥çå§å®¹ï¼
                      å®å¨ä¸æ¨£å°å³éå°è¨éå¨ã(ç°¡ç­å½¢å¼: -l)
@@ -1689,11 +1689,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">æ¸¬è©¦åå {0}ãç¸½è¨: {1} å¤±æ: {2} å³é: {3} è·³é: {4}, æé: {5} ç§</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">æ¸¬è©¦æè¦: ç¸½è¨: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">æçºæé: {0} ç§</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">å¤±æ: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">å·²è·³é: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">æå: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index 944287944a0..c71d588ced0 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -11,12 +11,10 @@
 using System.Text.RegularExpressions;
 using System.Diagnostics;
 using Microsoft.Build.Framework.Logging;
+using System.Globalization;
 
 #if NET7_0_OR_GREATER
 using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
-
-
 #endif
 #if NETFRAMEWORK
 using Microsoft.IO;
@@ -64,10 +62,19 @@ public ProjectContext(BuildEventContext context)
     /// </summary>
     internal const string Indentation = "  ";
 
+    internal const string DoubleIndentation = $"{Indentation}{Indentation}";
+
+    internal const string TripleIndentation = $"{Indentation}{Indentation}{Indentation}";
+
     internal const TerminalColor TargetFrameworkColor = TerminalColor.Cyan;
 
     internal Func<StopwatchAbstraction>? CreateStopwatch = null;
 
+    /// <summary>
+    /// Name of target that identifies the project cache plugin run has just started.
+    /// </summary>
+    private const string CachePluginStartTarget = "_CachePluginRunStart";
+
     /// <summary>
     /// Protects access to state shared between the logger callbacks and the rendering thread.
     /// </summary>
@@ -200,11 +207,6 @@ public ProjectContext(BuildEventContext context)
     /// </summary>
     private DateTime? _testEndTime;
 
-    /// <summary>
-    /// Name of target that identifies the project cache plugin run has just started.
-    /// </summary>
-    private static string _cachePluginStartTarget = "_CachePluginRunStart";
-
     /// <summary>
     /// Demonstrates whether there exists at least one project which is a cache plugin project.
     /// </summary>
@@ -399,6 +401,31 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)
                 string buildResult = RenderBuildResult(e.Succeeded, _buildErrorsCount, _buildWarningsCount);
 
                 Terminal.WriteLine("");
+                if(_testRunSummaries.Any())
+                {
+                    var total = _testRunSummaries.Sum(t => t.Total);
+                    var failed = _testRunSummaries.Sum(t => t.Failed);
+                    var passed = _testRunSummaries.Sum(t => t.Passed);
+                    var skipped = _testRunSummaries.Sum(t => t.Skipped);
+                    var testDuration = (_testStartTime != null && _testEndTime != null ? (_testEndTime - _testStartTime).Value.TotalSeconds : 0).ToString("F1");
+
+                    var colorizeFailed = failed > 0;
+                    var colorizePassed = passed > 0 && _buildErrorsCount == 0 && failed == 0;
+                    var colorizeSkipped = skipped > 0 && skipped == total && _buildErrorsCount == 0 && failed == 0;
+
+                    string summaryAndTotalText = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("TestSummary_BannerAndTotal", total);
+                    string failedText = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("TestSummary_Failed", failed);
+                    string passedText = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("TestSummary_Succeeded", passed);
+                    string skippedText = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("TestSummary_Skipped", skipped);
+                    string durationText = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("TestSummary_Duration", testDuration);
+
+                    failedText = colorizeFailed ? AnsiCodes.Colorize(failedText.ToString(), TerminalColor.Red) : failedText;
+                    passedText = colorizePassed ? AnsiCodes.Colorize(passedText.ToString(), TerminalColor.Green) : passedText;
+                    skippedText = colorizeSkipped ? AnsiCodes.Colorize(skippedText.ToString(), TerminalColor.Yellow) : skippedText;
+
+                    Terminal.WriteLine(string.Join(CultureInfo.CurrentCulture.TextInfo.ListSeparator + " ", summaryAndTotalText, failedText, passedText, skippedText, durationText));
+                }
+
                 if (_restoreFailed)
                 {
                     Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("RestoreCompleteWithMessage",
@@ -411,27 +438,6 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)
                         buildResult,
                         duration));
                 }
-
-                if (_testRunSummaries.Any())
-                {
-                    var total = _testRunSummaries.Sum(t => t.Total);
-                    var failed = _testRunSummaries.Sum(t => t.Failed);
-                    var passed = _testRunSummaries.Sum(t => t.Passed);
-                    var skipped = _testRunSummaries.Sum(t => t.Skipped);
-                    var testDuration = (_testStartTime != null && _testEndTime != null ? (_testEndTime - _testStartTime).Value.TotalSeconds : 0).ToString("F1");
-
-                    var colorizedResult = _testRunSummaries.Any(t => t.Failed > 0) || (_buildErrorsCount > 0)
-                        ? AnsiCodes.Colorize(ResourceUtilities.GetResourceString("BuildResult_Failed"), TerminalColor.Red)
-                        : AnsiCodes.Colorize(ResourceUtilities.GetResourceString("BuildResult_Succeeded"), TerminalColor.Green);
-
-                    Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("TestSummary",
-                        colorizedResult,
-                        total,
-                        failed,
-                        passed,
-                        skipped,
-                        testDuration));
-                }
             }
         }
         finally
@@ -654,7 +660,7 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
                     {
                         foreach (BuildMessage buildMessage in project.BuildMessages)
                         {
-                            Terminal.WriteLine($"{Indentation}{Indentation}{buildMessage.Message}");
+                            Terminal.WriteLine($"{DoubleIndentation}{buildMessage.Message}");
                         }
                     }
 
@@ -684,7 +690,7 @@ private void TargetStarted(object sender, TargetStartedEventArgs e)
             string projectFile = Path.GetFileNameWithoutExtension(e.ProjectFile);
 
             string targetName = e.TargetName;
-            if (targetName == _cachePluginStartTarget)
+            if (targetName == CachePluginStartTarget)
             {
                 project.IsCachePluginProject = true;
                 _hasUsedCache = true;
@@ -891,32 +897,22 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
     private void WarningRaised(object sender, BuildWarningEventArgs e)
     {
         BuildEventContext? buildEventContext = e.BuildEventContext;
-        string message = FormatEventMessage(
-                category: AnsiCodes.Colorize("warning", TerminalColor.Yellow),
-                subcategory: e.Subcategory,
-                message: e.Message,
-                code: AnsiCodes.Colorize(e.Code, TerminalColor.Yellow),
-                file: HighlightFileName(e.File),
-                lineNumber: e.LineNumber,
-                endLineNumber: e.EndLineNumber,
-                columnNumber: e.ColumnNumber,
-                endColumnNumber: e.EndColumnNumber);
 
         if (buildEventContext is not null
             && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project)
             && Verbosity > LoggerVerbosity.Quiet)
         {
-            if (IsImmediateMessage(message))
+            if (!String.IsNullOrEmpty(e.Message) && IsImmediateMessage(e.Message!))
             {
-                RenderImmediateMessage(message);
+                RenderImmediateMessage(FormatWarningMessage(e, Indentation));
             }
 
-            project.AddBuildMessage(MessageSeverity.Warning, message);
+            project.AddBuildMessage(MessageSeverity.Warning, FormatWarningMessage(e, TripleIndentation));
         }
         else
         {
             // It is necessary to display warning messages reported by MSBuild, even if it's not tracked in _projects collection or the verbosity is Quiet.
-            RenderImmediateMessage(message);
+            RenderImmediateMessage(FormatWarningMessage(e, Indentation));
             _buildWarningsCount++;
         }
     }
@@ -939,27 +935,17 @@ private bool IsImmediateMessage(string message) =>
     private void ErrorRaised(object sender, BuildErrorEventArgs e)
     {
         BuildEventContext? buildEventContext = e.BuildEventContext;
-        string message = FormatEventMessage(
-                category: AnsiCodes.Colorize("error", TerminalColor.Red),
-                subcategory: e.Subcategory,
-                message: e.Message,
-                code: AnsiCodes.Colorize(e.Code, TerminalColor.Red),
-                file: HighlightFileName(e.File),
-                lineNumber: e.LineNumber,
-                endLineNumber: e.EndLineNumber,
-                columnNumber: e.ColumnNumber,
-                endColumnNumber: e.EndColumnNumber);
-
+        
         if (buildEventContext is not null
             && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project)
             && Verbosity > LoggerVerbosity.Quiet)
         {
-            project.AddBuildMessage(MessageSeverity.Error, message);
+            project.AddBuildMessage(MessageSeverity.Error, FormatErrorMessage(e, TripleIndentation));
         }
         else
         {
             // It is necessary to display error messages reported by MSBuild, even if it's not tracked in _projects collection or the verbosity is Quiet.
-            RenderImmediateMessage(message);
+            RenderImmediateMessage(FormatErrorMessage(e, Indentation));
             _buildErrorsCount++;
         }
     }
@@ -1103,6 +1089,36 @@ private int NodeIndexForContext(BuildEventContext context)
             : path;
     }
 
+    private string FormatWarningMessage(BuildWarningEventArgs e, string indent)
+    {
+        return FormatEventMessage(
+                category: AnsiCodes.Colorize("warning", TerminalColor.Yellow),
+                subcategory: e.Subcategory,
+                message: e.Message,
+                code: AnsiCodes.Colorize(e.Code, TerminalColor.Yellow),
+                file: HighlightFileName(e.File),
+                lineNumber: e.LineNumber,
+                endLineNumber: e.EndLineNumber,
+                columnNumber: e.ColumnNumber,
+                endColumnNumber: e.EndColumnNumber,
+                indent);
+    }
+
+    private string FormatErrorMessage(BuildErrorEventArgs e, string indent)
+    {
+        return FormatEventMessage(
+                category: AnsiCodes.Colorize("error", TerminalColor.Red),
+                subcategory: e.Subcategory,
+                message: e.Message,
+                code: AnsiCodes.Colorize(e.Code, TerminalColor.Red),
+                file: HighlightFileName(e.File),
+                lineNumber: e.LineNumber,
+                endLineNumber: e.EndLineNumber,
+                columnNumber: e.ColumnNumber,
+                endColumnNumber: e.EndColumnNumber,
+                indent);
+    }
+
     private string FormatEventMessage(
             string category,
             string subcategory,
@@ -1112,7 +1128,8 @@ private string FormatEventMessage(
             int lineNumber,
             int endLineNumber,
             int columnNumber,
-            int endColumnNumber)
+            int endColumnNumber,
+            string indent)
     {
         message ??= string.Empty;
         StringBuilder builder = new(128);
@@ -1166,7 +1183,7 @@ private string FormatEventMessage(
         // render multi-line message in a special way
         if (message.IndexOf('\n') >= 0)
         {
-            const string indent = $"{Indentation}{Indentation}{Indentation}";
+            // Place the multiline message under the project in case of minimal and higher verbosity.
             string[] lines = message.Split(newLineStrings, StringSplitOptions.None);
 
             foreach (string line in lines)
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 213b842ae6a..9fa6956ae03 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -34,8 +34,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
-using static Microsoft.Build.CommandLine.MSBuildApp;
 using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
 using ConsoleLogger = Microsoft.Build.Logging.ConsoleLogger;
 using FileLogger = Microsoft.Build.Logging.FileLogger;
@@ -662,6 +660,9 @@ public static ExitType Execute(
             ExitType exitType = ExitType.Success;
 
             ConsoleCancelEventHandler cancelHandler = Console_CancelKeyPress;
+
+            TextWriter preprocessWriter = null;
+            TextWriter targetsWriter = null;
             try
             {
 #if FEATURE_GET_COMMANDLINE
@@ -701,8 +702,6 @@ public static ExitType Execute(
 #else
                 bool enableNodeReuse = false;
 #endif
-                TextWriter preprocessWriter = null;
-                TextWriter targetsWriter = null;
                 bool detailedSummary = false;
                 ISet<string> warningsAsErrors = null;
                 ISet<string> warningsNotAsErrors = null;
@@ -717,6 +716,7 @@ public static ExitType Execute(
                 string[] inputResultsCaches = null;
                 string outputResultsCache = null;
                 bool question = false;
+                bool isBuildCheckEnabled = false;
                 string[] getProperty = Array.Empty<string>();
                 string[] getItem = Array.Empty<string>();
                 string[] getTargetResult = Array.Empty<string>();
@@ -764,6 +764,7 @@ public static ExitType Execute(
 #endif
                                             ref lowPriority,
                                             ref question,
+                                            ref isBuildCheckEnabled,
                                             ref getProperty,
                                             ref getItem,
                                             ref getTargetResult,
@@ -824,8 +825,18 @@ public static ExitType Execute(
                             using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))
                             {
                                 Project project = collection.LoadProject(projectFile, globalProperties, toolsVersion);
-                                TextWriter output = getResultOutputFile.Length > 0 ? new StreamWriter(getResultOutputFile) : Console.Out;
-                                exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project, output);
+
+                                if (getResultOutputFile.Length == 0)
+                                {
+                                    exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project, Console.Out);
+                                }
+                                else
+                                {
+                                    using (var streamWriter = new StreamWriter(getResultOutputFile))
+                                    {
+                                        exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project, streamWriter);
+                                    }
+                                }
                                 collection.LogBuildFinishedEvent(exitType == ExitType.Success);
                             }
                         }
@@ -866,6 +877,7 @@ public static ExitType Execute(
                                     graphBuildOptions,
                                     lowPriority,
                                     question,
+                                    isBuildCheckEnabled,
                                     inputResultsCaches,
                                     outputResultsCache,
                                     saveProjectResult: outputPropertiesItemsOrTargetResults,
@@ -887,8 +899,17 @@ public static ExitType Execute(
 
                     if (outputPropertiesItemsOrTargetResults && targets?.Length > 0 && result is not null)
                     {
-                        TextWriter outputStream = getResultOutputFile.Length > 0 ? new StreamWriter(getResultOutputFile) : Console.Out;
-                        exitType = OutputBuildInformationInJson(result, getProperty, getItem, getTargetResult, loggers, exitType, outputStream);
+                        if (getResultOutputFile.Length == 0)
+                        {
+                            exitType = OutputBuildInformationInJson(result, getProperty, getItem, getTargetResult, loggers, exitType, Console.Out);
+                        }
+                        else
+                        {
+                            using (var streamWriter = new StreamWriter(getResultOutputFile))
+                            {
+                                exitType = OutputBuildInformationInJson(result, getProperty, getItem, getTargetResult, loggers, exitType, streamWriter);
+                            }
+                        }
                     }
 
                     if (!string.IsNullOrEmpty(timerOutputFilename))
@@ -1032,6 +1053,9 @@ public static ExitType Execute(
 
                 NativeMethodsShared.RestoreConsoleMode(s_originalConsoleMode);
 
+                preprocessWriter?.Dispose();
+                targetsWriter?.Dispose();
+
 #if FEATURE_GET_COMMANDLINE
                 MSBuildEventSource.Log.MSBuildExeStop(commandLine);
 #else
@@ -1252,6 +1276,7 @@ internal static bool BuildProject(
             GraphBuildOptions graphBuildOptions,
             bool lowPriority,
             bool question,
+            bool isBuildCheckEnabled,
             string[] inputResultsCaches,
             string outputResultsCache,
             bool saveProjectResult,
@@ -1453,6 +1478,7 @@ internal static bool BuildProject(
                     parameters.InputResultsCacheFiles = inputResultsCaches;
                     parameters.OutputResultsCacheFile = outputResultsCache;
                     parameters.Question = question;
+                    parameters.IsBuildCheckEnabled = isBuildCheckEnabled;
 #if FEATURE_REPORTFILEACCESSES
                     parameters.ReportFileAccesses = reportFileAccesses;
 #endif
@@ -2447,6 +2473,7 @@ private static bool ProcessCommandLineSwitches(
 #endif
             ref bool lowPriority,
             ref bool question,
+            ref bool isBuildCheckEnabled,
             ref string[] getProperty,
             ref string[] getItem,
             ref string[] getTargetResult,
@@ -2577,6 +2604,7 @@ private static bool ProcessCommandLineSwitches(
 #endif
                                                            ref lowPriority,
                                                            ref question,
+                                                           ref isBuildCheckEnabled,
                                                            ref getProperty,
                                                            ref getItem,
                                                            ref getTargetResult,
@@ -2662,6 +2690,8 @@ private static bool ProcessCommandLineSwitches(
 
                     question = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Question);
 
+                    isBuildCheckEnabled = IsBuildCheckEnabled(commandLineSwitches);
+
                     inputResultsCaches = ProcessInputResultsCaches(commandLineSwitches);
 
                     outputResultsCache = ProcessOutputResultsCache(commandLineSwitches);
@@ -2734,6 +2764,13 @@ private static bool ProcessCommandLineSwitches(
             return invokeBuild;
         }
 
+        private static bool IsBuildCheckEnabled(CommandLineSwitches commandLineSwitches)
+        {
+            // Opt-in behavior to be determined by: https://github.com/dotnet/msbuild/issues/9723
+            bool isAnalysisEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Analyze);
+            return isAnalysisEnabled;
+        }
+
         private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)
         {
             aggregatedParameters = AggregateParameters(commandLineSwitches);
@@ -3764,9 +3801,9 @@ private static ILogger[] ProcessLoggingSwitches(
                 ProcessConsoleLoggerSwitch(noConsoleLogger, consoleLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
             }
 
-            ProcessDistributedFileLogger(distributedFileLogger, fileLoggerParameters, distributedLoggerRecords, loggers, cpuCount);
+            ProcessDistributedFileLogger(distributedFileLogger, fileLoggerParameters, distributedLoggerRecords);
 
-            ProcessFileLoggers(groupedFileLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
+            ProcessFileLoggers(groupedFileLoggerParameters, distributedLoggerRecords, cpuCount, loggers);
 
             verbosity = outVerbosity;
 
@@ -3808,7 +3845,7 @@ internal static string AggregateParameters(string anyPrefixingParameter, string[
         /// Add a file logger with the appropriate parameters to the loggers list for each
         /// non-empty set of file logger parameters provided.
         /// </summary>
-        private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, List<DistributedLoggerRecord> distributedLoggerRecords, LoggerVerbosity verbosity, int cpuCount, List<ILogger> loggers)
+        private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, List<DistributedLoggerRecord> distributedLoggerRecords, int cpuCount, List<ILogger> loggers)
         {
             for (int i = 0; i < groupedFileLoggerParameters.Length; i++)
             {
@@ -4001,9 +4038,7 @@ private static DistributedLoggerRecord CreateForwardingLoggerRecord(ILogger logg
         internal static void ProcessDistributedFileLogger(
             bool distributedFileLogger,
             string[] fileLoggerParameters,
-            List<DistributedLoggerRecord> distributedLoggerRecords,
-            List<ILogger> loggers,
-            int cpuCount)
+            List<DistributedLoggerRecord> distributedLoggerRecords)
         {
             if (distributedFileLogger)
             {
diff --git a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
index 9e4f47ac424..845c52c7b8c 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
+++ b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
@@ -21,6 +21,7 @@ folder InstallDir:\MSBuild\Current\Bin\arm64
   file source=$(Arm64BinPath)Microsoft.Common.overridetasks
   file source=$(Arm64BinPath)Microsoft.Common.targets
   file source=$(Arm64BinPath)Microsoft.Common.tasks
+  file source=$(Arm64BinPath)Microsoft.Common.Test.targets
   file source=$(Arm64BinPath)Microsoft.Managed.targets
   file source=$(Arm64BinPath)Microsoft.Managed.Before.targets
   file source=$(Arm64BinPath)Microsoft.Managed.After.targets
diff --git a/src/Shared/IsExternalInit.cs b/src/Shared/IsExternalInit.cs
new file mode 100644
index 00000000000..ae2ffb321cd
--- /dev/null
+++ b/src/Shared/IsExternalInit.cs
@@ -0,0 +1,9 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace System.Runtime.CompilerServices
+{
+    // Needed so we can use init setters in full fw or netstandard
+    //  (details: https://developercommunity.visualstudio.com/t/error-cs0518-predefined-type-systemruntimecompiler/1244809)
+    internal static class IsExternalInit { }
+}
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 81eacb5e604..291594fcfdc 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -9,6 +9,11 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 
+#if !TASKHOST
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.BuildCheck.Infrastructure;
+#endif
+
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
 using Microsoft.Build.Collections;
 using Microsoft.Build.Framework.Profiler;
@@ -210,6 +215,31 @@ internal enum LoggingEventType : int
         /// Event is a <see cref="GeneratedFileUsedEventArgs"/>
         /// </summary>
         GeneratedFileUsedEvent = 34,
+        
+        /// <summary>
+        /// Event is <see cref="BuildCheckResultMessage"/>
+        /// </summary>
+        BuildCheckMessageEvent = 35,
+
+        /// <summary>
+        /// Event is <see cref="BuildCheckResultWarning"/>
+        /// </summary>
+        BuildCheckWarningEvent = 36,
+
+        /// <summary>
+        /// Event is <see cref="BuildCheckResultError"/>
+        /// </summary>
+        BuildCheckErrorEvent = 37,
+
+        /// <summary>
+        /// Event is <see cref="BuildCheckTracingEventArgs"/>
+        /// </summary>
+        BuildCheckTracingEvent = 38,
+
+        /// <summary>
+        /// Event is <see cref="BuildCheckAcquisitionEventArgs"/>
+        /// </summary>
+        BuildCheckAcquisitionEvent = 39,
     }
     #endregion
 
@@ -617,6 +647,11 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.PropertyReassignment => new PropertyReassignmentEventArgs(),
                 LoggingEventType.UninitializedPropertyRead => new UninitializedPropertyReadEventArgs(),
                 LoggingEventType.GeneratedFileUsedEvent => new GeneratedFileUsedEventArgs(),
+                LoggingEventType.BuildCheckMessageEvent => new BuildCheckResultMessage(),
+                LoggingEventType.BuildCheckWarningEvent => new BuildCheckResultWarning(),
+                LoggingEventType.BuildCheckErrorEvent => new BuildCheckResultError(),
+                LoggingEventType.BuildCheckAcquisitionEvent => new BuildCheckAcquisitionEventArgs(),
+                LoggingEventType.BuildCheckTracingEvent => new BuildCheckTracingEventArgs(),
 #endif
                 _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
             };
@@ -732,6 +767,26 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.GeneratedFileUsedEvent;
             }
+            else if (eventType == typeof(BuildCheckResultMessage))
+            {
+                return LoggingEventType.BuildCheckMessageEvent;
+            }
+            else if (eventType == typeof(BuildCheckResultWarning))
+            {
+                return LoggingEventType.BuildCheckWarningEvent;
+            }
+            else if (eventType == typeof(BuildCheckResultError))
+            {
+                return LoggingEventType.BuildCheckErrorEvent;
+            }
+            else if (eventType == typeof(BuildCheckAcquisitionEventArgs))
+            {
+                return LoggingEventType.BuildCheckAcquisitionEvent;
+            }
+            else if (eventType == typeof(BuildCheckTracingEventArgs))
+            {
+                return LoggingEventType.BuildCheckTracingEvent;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 6c12448b1ad..8783318b2e5 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Diagnostics.CodeAnalysis;
 #if CLR2COMPATIBILITY
 using Microsoft.Build.Shared.Concurrent;
 #else
@@ -14,6 +15,7 @@
 using Microsoft.Build.Shared;
 #if FEATURE_SECURITY_PERMISSIONS || FEATURE_PIPE_SECURITY
 using System.Security.AccessControl;
+
 #endif
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
 using System.Security.Principal;
@@ -29,6 +31,7 @@ namespace Microsoft.Build.BackEnd
     /// <summary>
     /// This is an implementation of INodeEndpoint for the out-of-proc nodes.  It acts only as a client.
     /// </summary>
+    [SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope", Justification = "It is expected to keep the stream open for the process lifetime")]
     internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
     {
         #region Private Data
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index adcdc9b419a..b8eb609791a 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -325,7 +325,7 @@
       </trans-unit>
       <trans-unit id="WildcardResultsInDriveEnumeration">
         <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; in file "{3}" is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined and that the project and current working directory are not at the drive root.</source>
-        <target state="translated">MSB5029: Hodnota {0} atributu {1} v elementu &lt;{2}&gt; v souboru {3} je zÃ¡stupnÃ½ znak, jehoÅ¾ vÃ½sledkem je vÃ½Äet vÅ¡ech souborÅ¯ na jednotce, coÅ¾ pravdÄpodobnÄ nebylo zamÃ½Å¡leno. Zkontrolujte, zda jsou odkazovanÃ© vlastnosti vÅ¾dy definovÃ¡ny a zda projekt a aktuÃ¡lnÃ­ pracovnÃ­ adresÃ¡Å nejsou v koÅenovÃ©m adresÃ¡Åi jednotky.</target>
+        <target state="translated">MSB5029: Hodnota {0} atributu {1} v elementu &lt;{2}&gt; v souboru {3}je zÃ¡stupnÃ½ znak, jehoÅ¾ vÃ½sledkem je vÃ½Äet vÅ¡ech souborÅ¯ na jednotce, coÅ¾ pravdÄpodobnÄ nebylo zamÃ½Å¡leno. Zkontrolujte, zda jsou odkazovanÃ© vlastnosti vÅ¾dy definovÃ¡ny a zda projekt a aktuÃ¡lnÃ­ pracovnÃ­ adresÃ¡Å nejsou v koÅenovÃ©m adresÃ¡Åi jednotky.</target>
         <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
       </trans-unit>
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
index acea1b5a025..b63fa1e4e9e 100644
--- a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
@@ -1,4 +1,4 @@
-ï»¿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -14,6 +14,7 @@
     <IsTestProject>true</IsTestProject>
     <IsLibraryTestProject>true</IsLibraryTestProject>
     <DefineConstants>$(DefineConstants);NET35_UNITTEST</DefineConstants>
+    <NoWarn>$(NoWarn);CA2000</NoWarn>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 38700fed179..bbba6eab034 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Reflection;
 using System.Text;
 using Microsoft.Build.Evaluation;
@@ -169,7 +170,10 @@ public void Timeout()
             Assert.False(result);
             Assert.Equal(expectedExitCode, exec.ExitCode);
             ((MockEngine)exec.BuildEngine).AssertLogContains("MSB5002");
-            Assert.Equal(1, ((MockEngine)exec.BuildEngine).Warnings);
+            int warningsCount = ((MockEngine)exec.BuildEngine).Warnings;
+            warningsCount.ShouldBe(1,
+                $"Expected 1 warning, encountered {warningsCount}: " + string.Join(",",
+                    ((MockEngine)exec.BuildEngine).WarningEvents.Select(w => w.Message)));
 
             // ToolTask does not log an error on timeout.
             Assert.Equal(0, ((MockEngine)exec.BuildEngine).Errors);
diff --git a/src/Tasks/AppConfig/AppConfig.cs b/src/Tasks/AppConfig/AppConfig.cs
index 7f50e75cc29..0e746a573e7 100644
--- a/src/Tasks/AppConfig/AppConfig.cs
+++ b/src/Tasks/AppConfig/AppConfig.cs
@@ -34,7 +34,9 @@ internal void Load(string appConfigFilePath)
                 // Need a filestream as the XmlReader doesn't support nonstandard unicode characters in path.
                 // No need to dispose - as 'CloseInput' was passed to XmlReaderSettings
                 FileStream fs = File.OpenRead(appConfigFilePath);
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because the reader is disposed in the finally block
                 reader = XmlReader.Create(fs, readerSettings);
+#pragma warning restore CA2000 // Dispose objects before losing scope
                 Read(reader);
             }
             catch (XmlException e)
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index 0b296e958ca..76e17988b08 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -225,7 +225,8 @@ public BuildResults Build(BuildSettings settings)
                     var fi = new FileInfo(de.Value);
                     using (FileStream fs = fi.OpenRead())
                     {
-                        data = new StreamReader(fs).ReadToEnd();
+                        using var sr = new StreamReader(fs);
+                        data = sr.ReadToEnd();
                     }
 
                     resourceUpdater.AddStringResource(44, de.Key, data);
@@ -835,7 +836,7 @@ private XmlDocument LoadAndValidateXmlDocument(string filePath, bool validateFil
                     if (validate)
                     {
 #pragma warning disable 618 // Using XmlValidatingReader. TODO: We need to switch to using XmlReader.Create() with validation.
-                        var validatingReader = new XmlValidatingReader(xmlReader);
+                        using var validatingReader = new XmlValidatingReader(xmlReader);
 #pragma warning restore 618
                         var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
                         FileStream fs = File.OpenRead(schemaPath);
@@ -1657,7 +1658,7 @@ private static string GetFileHash(string filePath)
             // pre-signed anwyay; this is a fallback in case we ever encounter a bootstrapper that is
             // not signed.
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-            System.Security.Cryptography.SHA256 sha = System.Security.Cryptography.SHA256.Create(
+            using System.Security.Cryptography.SHA256 sha = System.Security.Cryptography.SHA256.Create(
 #if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
                 "System.Security.Cryptography.SHA256CryptoServiceProvider"
 #endif
@@ -2033,7 +2034,8 @@ private static void DumpXmlToFile(XmlNode node, string fileName)
                     {
                         xmlwriter.Formatting = Formatting.Indented;
                         xmlwriter.Indentation = 4;
-                        xmlwriter.WriteNode(new XmlNodeReader(node), true);
+                        using var xmlReader = new XmlNodeReader(node);
+                        xmlwriter.WriteNode(xmlReader, true);
                     }
                 }
                 catch (IOException)
@@ -2194,7 +2196,7 @@ private static string GetPublicKeyOfFile(string fileSource)
             {
                 try
                 {
-                    var cert = new X509Certificate(fileSource);
+                    using var cert = new X509Certificate(fileSource);
                     string publicKey = cert.GetPublicKeyString();
                     return publicKey;
                 }
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index f863c969cbf..e1923c87f9d 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -738,7 +738,7 @@ private Assembly CompileInMemoryAssembly()
 
                 // Horrible code dom / compilation declarations
                 var codeBuilder = new StringBuilder();
-                var writer = new StringWriter(codeBuilder, CultureInfo.CurrentCulture);
+                using var writer = new StringWriter(codeBuilder, CultureInfo.CurrentCulture);
                 var codeGeneratorOptions = new CodeGeneratorOptions
                 {
                     BlankLinesBetweenMembers = true,
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index efe54f514ca..71dc72e4c91 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -146,6 +146,7 @@ private async Task<bool> ExecuteAsync()
         private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
         {
             // The main reason to use HttpClient vs WebClient is because we can pass a message handler for unit tests to mock
+#pragma warning disable CA2000 // Dispose objects before losing scope because HttpClientHandler is disposed by HTTPClient.Dispose()
             using (var client = new HttpClient(HttpMessageHandler ?? new HttpClientHandler(), disposeHandler: true) { Timeout = TimeSpan.FromMilliseconds(Timeout) })
             {
                 // Only get the response without downloading the file so we can determine if the file is already up-to-date
@@ -226,6 +227,7 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
                     }
                 }
             }
+#pragma warning restore CA2000 // Dispose objects before losing scope
         }
 
         /// <summary>
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 572a19ea3bb..af988ec51d3 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -974,8 +974,8 @@ private bool IsDangerous(String filename)
                 // XML files are only dangerous if there are unrecognized objects in them
                 dangerous = false;
 
-                FileStream stream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);
-                XmlTextReader reader = new XmlTextReader(stream);
+                using FileStream stream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);
+                using XmlTextReader reader = new XmlTextReader(stream);
                 reader.DtdProcessing = DtdProcessing.Ignore;
                 reader.XmlResolver = null;
                 try
@@ -1622,14 +1622,13 @@ private bool NeedToRebuildSourceFile(string sourceFilePath, DateTime sourceTime,
         private void GetStronglyTypedResourceToProcess(ref List<ITaskItem> inputsToProcess, ref List<ITaskItem> outputsToProcess)
         {
             bool needToRebuildSTR = false;
+            CodeDomProvider provider = null;
 
             // The resource file isn't out of date. So check whether the STR class file is.
             try
             {
                 if (StronglyTypedFileName == null)
                 {
-                    CodeDomProvider provider = null;
-
                     if (ProcessResourceFiles.TryCreateCodeDomProvider(Log, StronglyTypedLanguage, out provider))
                     {
                         StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(provider, OutputResources[0].ItemSpec);
@@ -1645,6 +1644,10 @@ private void GetStronglyTypedResourceToProcess(ref List<ITaskItem> inputsToProce
                 _stronglyTypedResourceSuccessfullyCreated = false;
                 return;
             }
+            finally
+            {
+                provider?.Dispose();
+            }
 
             // Now we have the filename, check if it's up to date
             DateTime sourceTime = NativeMethodsShared.GetLastWriteFileUtcTime(Sources[0].ItemSpec);
@@ -2153,11 +2156,18 @@ private void RecordFilesWritten()
             {
                 if (StronglyTypedFileName == null)
                 {
-                    CodeDomProvider provider;
-                    if (ProcessResourceFiles.TryCreateCodeDomProvider(Log, StronglyTypedLanguage, out provider))
+                    CodeDomProvider provider = null;
+                    try
                     {
-                        StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(
-                            provider, OutputResources[0].ItemSpec);
+                        if (ProcessResourceFiles.TryCreateCodeDomProvider(Log, StronglyTypedLanguage, out provider))
+                        {
+                            StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(
+                                provider, OutputResources[0].ItemSpec);
+                        }
+                    }
+                    finally
+                    {
+                        provider?.Dispose();
                     }
                 }
 
@@ -3412,61 +3422,69 @@ private bool HaveSystemResourcesExtensionsReference
         /// <param name="sourceFile">The generated strongly typed filename</param>
         private void CreateStronglyTypedResources(ReaderInfo reader, String outFile, String inputFileName, out String sourceFile)
         {
-            CodeDomProvider provider;
-            if (!TryCreateCodeDomProvider(_logger, _stronglyTypedLanguage, out provider))
-            {
-                sourceFile = null;
-                return;
-            }
-
-            // Default the class name if we need to
-            if (_stronglyTypedClassName == null)
-            {
-                _stronglyTypedClassName = Path.GetFileNameWithoutExtension(outFile);
-            }
-
-            // Default the filename if we need to
-            if (_stronglyTypedFilename == null)
+            CodeDomProvider provider = null;
+            try
             {
-                _stronglyTypedFilename = GenerateDefaultStronglyTypedFilename(provider, outFile);
-            }
-            sourceFile = this.StronglyTypedFilename;
+                if (!TryCreateCodeDomProvider(_logger, _stronglyTypedLanguage, out provider))
+                {
+                    sourceFile = null;
+                    return;
+                }
 
-            _logger.LogMessageFromResources("GenerateResource.CreatingSTR", _stronglyTypedFilename);
 
-            // Generate the STR class
-            String[] errors;
-            bool generateInternalClass = !_stronglyTypedClassIsPublic;
-            // StronglyTypedResourcesNamespace can be null and this is ok.
-            // If it is null then the default namespace (=stronglyTypedNamespace) is used.
-            CodeCompileUnit ccu = StronglyTypedResourceBuilder.Create(
-                    reader.resourcesHashTable,
-                    _stronglyTypedClassName,
-                    _stronglyTypedNamespace,
-                    _stronglyTypedResourcesNamespace,
-                    provider,
-                    generateInternalClass,
-                    out errors);
+                // Default the class name if we need to
+                if (_stronglyTypedClassName == null)
+                {
+                    _stronglyTypedClassName = Path.GetFileNameWithoutExtension(outFile);
+                }
 
-            CodeGeneratorOptions codeGenOptions = new CodeGeneratorOptions();
-            using (TextWriter output = new StreamWriter(_stronglyTypedFilename))
-            {
-                provider.GenerateCodeFromCompileUnit(ccu, output, codeGenOptions);
-            }
+                // Default the filename if we need to
+                if (_stronglyTypedFilename == null)
+                {
+                    _stronglyTypedFilename = GenerateDefaultStronglyTypedFilename(provider, outFile);
+                }
+                sourceFile = this.StronglyTypedFilename;
+
+                _logger.LogMessageFromResources("GenerateResource.CreatingSTR", _stronglyTypedFilename);
+
+                // Generate the STR class
+                String[] errors;
+                bool generateInternalClass = !_stronglyTypedClassIsPublic;
+                // StronglyTypedResourcesNamespace can be null and this is ok.
+                // If it is null then the default namespace (=stronglyTypedNamespace) is used.
+                CodeCompileUnit ccu = StronglyTypedResourceBuilder.Create(
+                        reader.resourcesHashTable,
+                        _stronglyTypedClassName,
+                        _stronglyTypedNamespace,
+                        _stronglyTypedResourcesNamespace,
+                        provider,
+                        generateInternalClass,
+                        out errors);
+
+                CodeGeneratorOptions codeGenOptions = new CodeGeneratorOptions();
+                using (TextWriter output = new StreamWriter(_stronglyTypedFilename))
+                {
+                    provider.GenerateCodeFromCompileUnit(ccu, output, codeGenOptions);
+                }
 
-            if (errors.Length > 0)
-            {
-                _logger.LogErrorWithCodeFromResources("GenerateResource.ErrorFromCodeDom", inputFileName);
-                foreach (String error in errors)
+                if (errors.Length > 0)
+                {
+                    _logger.LogErrorWithCodeFromResources("GenerateResource.ErrorFromCodeDom", inputFileName);
+                    foreach (String error in errors)
+                    {
+                        _logger.LogErrorWithCodeFromResources("GenerateResource.CodeDomError", error);
+                    }
+                }
+                else
                 {
-                    _logger.LogErrorWithCodeFromResources("GenerateResource.CodeDomError", error);
+                    // No errors, and no exceptions - we presumably did create the STR class file
+                    // and it should get added to FilesWritten. So set a flag to indicate this.
+                    _stronglyTypedResourceSuccessfullyCreated = true;
                 }
             }
-            else
+            finally
             {
-                // No errors, and no exceptions - we presumably did create the STR class file
-                // and it should get added to FilesWritten. So set a flag to indicate this.
-                _stronglyTypedResourceSuccessfullyCreated = true;
+                provider?.Dispose();
             }
         }
 
@@ -3542,15 +3560,16 @@ private void ReadResources(ReaderInfo readerInfo, IResourceReader reader, String
 #endif // FEATURE_RESXREADER_LIVEDESERIALIZATION
 
         /// <summary>
-        /// Read resources from a text format file
+        /// Read resources from a text format file.
         /// </summary>
-        /// <param name="reader">Reader info</param>
-        /// <param name="fileName">Input resources filename</param>
+        /// <param name="reader">Reader info.</param>
+        /// <param name="fileName">Input resources filename.</param>
         private void ReadTextResources(ReaderInfo reader, String fileName)
         {
             // Check for byte order marks in the beginning of the input file, but
             // default to UTF-8.
-            using (LineNumberStreamReader sr = new LineNumberStreamReader(fileName, new UTF8Encoding(true), true))
+            using var fs = File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
+            using (LineNumberStreamReader sr = new LineNumberStreamReader(fs, new UTF8Encoding(true), true))
             {
                 StringBuilder name = new StringBuilder(255);
                 StringBuilder value = new StringBuilder(2048);
@@ -3876,8 +3895,8 @@ internal sealed class LineNumberStreamReader : StreamReader
             private int _lineNumber;
             private int _col;
 
-            internal LineNumberStreamReader(String fileName, Encoding encoding, bool detectEncoding)
-                : base(File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.Read), encoding, detectEncoding)
+            internal LineNumberStreamReader(Stream fileStream, Encoding encoding, bool detectEncoding)
+                : base(fileStream, encoding, detectEncoding)
             {
                 _lineNumber = 1;
                 _col = 0;
diff --git a/src/Tasks/GetInstalledSDKLocations.cs b/src/Tasks/GetInstalledSDKLocations.cs
index 011ce919725..e1d4bb966e7 100644
--- a/src/Tasks/GetInstalledSDKLocations.cs
+++ b/src/Tasks/GetInstalledSDKLocations.cs
@@ -194,7 +194,9 @@ public override bool Execute()
                 object staticCacheDisposer = buildEngine4.GetRegisteredTaskObject(StaticSDKCacheKey, RegisteredTaskObjectLifetime.Build);
                 if (staticCacheDisposer == null)
                 {
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because the object is registered with the engine and disposed of at the end of the build.
                     BuildCacheDisposeWrapper staticDisposer = new BuildCacheDisposeWrapper(ToolLocationHelper.ClearSDKStaticCache);
+#pragma warning restore CA2000 // Dispose objects before losing scope
                     buildEngine4.RegisterTaskObject(StaticSDKCacheKey, staticDisposer, RegisteredTaskObjectLifetime.Build, allowEarlyCollection: false);
                 }
             }
diff --git a/src/Tasks/ManifestUtil/ManifestFormatter.cs b/src/Tasks/ManifestUtil/ManifestFormatter.cs
index a4295b3da34..d7d7ee01eb1 100644
--- a/src/Tasks/ManifestUtil/ManifestFormatter.cs
+++ b/src/Tasks/ManifestUtil/ManifestFormatter.cs
@@ -16,7 +16,7 @@ internal static class ManifestFormatter
         public static Stream Format(Stream input)
         {
             int t1 = Environment.TickCount;
-
+#pragma warning disable CA2000 // Dispose objects before losing scope - caller needs underlying stream
             var r = new XmlTextReader(input)
             {
                 DtdProcessing = DtdProcessing.Ignore,
@@ -31,6 +31,7 @@ public static Stream Format(Stream input)
                 Indentation = 2
             };
             w.WriteStartDocument();
+#pragma warning restore CA2000 // Dispose objects before losing scope
 
             while (r.Read())
             {
@@ -100,4 +101,4 @@ public static Stream Format(Stream input)
             return m;
         }
     }
-}
+}
\ No newline at end of file
diff --git a/src/Tasks/ManifestUtil/ManifestReader.cs b/src/Tasks/ManifestUtil/ManifestReader.cs
index fc4afee3919..3d6393e6518 100644
--- a/src/Tasks/ManifestUtil/ManifestReader.cs
+++ b/src/Tasks/ManifestUtil/ManifestReader.cs
@@ -224,8 +224,8 @@ public static Manifest ReadManifest(string manifestType, Stream input, bool pres
         private static Manifest Deserialize(Stream s)
         {
             s.Position = 0;
-            var r = new XmlTextReader(s) { DtdProcessing = DtdProcessing.Ignore };
-
+            var settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = false };
+            using XmlReader r = XmlReader.Create(s, settings);
             do
             {
                 r.Read();
@@ -238,7 +238,7 @@ private static Manifest Deserialize(Stream s)
             var xs = new XmlSerializer(t);
 
             int t1 = Environment.TickCount;
-            var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+            var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = false };
             using (XmlReader xr = XmlReader.Create(s, xrSettings))
             {
                 var m = (Manifest)xs.Deserialize(xr);
diff --git a/src/Tasks/ManifestUtil/ManifestWriter.cs b/src/Tasks/ManifestUtil/ManifestWriter.cs
index 562cc1f1c0f..8da08fbacde 100644
--- a/src/Tasks/ManifestUtil/ManifestWriter.cs
+++ b/src/Tasks/ManifestUtil/ManifestWriter.cs
@@ -24,7 +24,7 @@ private static Stream Serialize(Manifest manifest)
             manifest.OnBeforeSave();
             var m = new MemoryStream();
             var s = new XmlSerializer(manifest.GetType());
-            var w = new StreamWriter(m);
+            using var w = new StreamWriter(m, System.Text.Encoding.UTF8, bufferSize: 1024, leaveOpen: true);
 
             int t1 = Environment.TickCount;
             s.Serialize(w, manifest);
@@ -32,6 +32,7 @@ private static Stream Serialize(Manifest manifest)
 
             w.Flush();
             m.Position = 0;
+
             return m;
         }
 
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 9951399b793..b49395de0d6 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -205,7 +205,7 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkName fn)
                         {
                             try
                             {
-                                var sr = new StreamReader(fs);
+                                using var sr = new StreamReader(fs, Encoding.UTF8, detectEncodingFromByteOrderMarks: true, 1024, leaveOpen: true);
                                 string data = sr.ReadToEnd();
                                 if (!string.IsNullOrEmpty(data))
                                 {
@@ -610,7 +610,7 @@ public static void SignFile(string certThumbprint,
         [SupportedOSPlatform("windows")]
         public static void SignFile(string certPath, SecureString certPassword, Uri timestampUrl, string path)
         {
-            X509Certificate2 cert = new X509Certificate2(certPath, certPassword, X509KeyStorageFlags.PersistKeySet);
+            using X509Certificate2 cert = new X509Certificate2(certPath, certPassword, X509KeyStorageFlags.PersistKeySet);
             SignFile(cert, timestampUrl, path);
         }
 
@@ -705,8 +705,9 @@ private static void SignFileInternal(X509Certificate2 cert,
                         CmiManifestSigner2 signer;
                         if (useSha256 && rsa is RSACryptoServiceProvider rsacsp)
                         {
-                            RSACryptoServiceProvider csp = SignedCmiManifest2.GetFixedRSACryptoServiceProvider(rsacsp, useSha256);
-                            signer = new CmiManifestSigner2(csp, cert, useSha256);
+#pragma warning disable CA2000 // Dispose objects before losing scope because CmiManifestSigner2 will dispose the RSACryptoServiceProvider
+                            signer = new CmiManifestSigner2(SignedCmiManifest2.GetFixedRSACryptoServiceProvider(rsacsp, useSha256), cert, useSha256);
+#pragma warning restore CA2000 // Dispose objects before losing scope
                         }
                         else
                         {
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index ecc02c975a7..8776175eddc 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -534,7 +534,8 @@ public override string ToString()
             var m = new MemoryStream();
             Write(m);
             m.Position = 0;
-            var r = new StreamReader(m);
+            using var r = new StreamReader(m);
+
             return r.ReadToEnd();
         }
 
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index 4d6b6ca09ea..f8bd53d1a44 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -209,7 +209,7 @@ public static Version GetTargetFrameworkVersion(string targetFramework)
         public static string GetEmbeddedResourceString(string name)
         {
             Stream s = GetEmbeddedResourceStream(name);
-            StreamReader r = new StreamReader(s);
+            using StreamReader r = new StreamReader(s);
             return r.ReadToEnd();
         }
 
@@ -238,10 +238,10 @@ private static void GetFileInfoImpl(string path, string targetFrameWorkVersion,
             length = fi.Length;
 
             Stream s = null;
+            HashAlgorithm hashAlg = null;
             try
             {
                 s = fi.OpenRead();
-                HashAlgorithm hashAlg;
 
                 if (string.IsNullOrEmpty(targetFrameWorkVersion) || CompareFrameworkVersions(targetFrameWorkVersion, Constants.TargetFrameworkVersion40) <= 0)
                 {
@@ -269,6 +269,7 @@ private static void GetFileInfoImpl(string path, string targetFrameWorkVersion,
             finally
             {
                 s?.Close();
+                hashAlg?.Dispose();
             }
         }
 
@@ -473,7 +474,7 @@ public static void WriteFile(string path, string s)
 
         public static void WriteFile(string path, Stream s)
         {
-            StreamReader r = new StreamReader(s);
+            using StreamReader r = new StreamReader(s);
             WriteFile(path, r.ReadToEnd());
         }
 
@@ -520,7 +521,7 @@ public static void WriteLogFile(string filename, Stream s)
             }
 
             string path = Path.Combine(logPath, filename);
-            StreamReader r = new StreamReader(s);
+            using var r = new StreamReader(s, Encoding.UTF8, detectEncodingFromByteOrderMarks: true, 1024, leaveOpen: true);
             string text = r.ReadToEnd();
             try
             {
@@ -538,6 +539,7 @@ public static void WriteLogFile(string filename, Stream s)
             catch (SecurityException)
             {
             }
+
             s.Position = 0;
         }
 
diff --git a/src/Tasks/ManifestUtil/XmlUtil.cs b/src/Tasks/ManifestUtil/XmlUtil.cs
index ca35d8090a0..32f985124aa 100644
--- a/src/Tasks/ManifestUtil/XmlUtil.cs
+++ b/src/Tasks/ManifestUtil/XmlUtil.cs
@@ -114,8 +114,10 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
                     }
                 }
 
+#pragma warning disable CA2000 // Dispose objects before losing scope - the caller expects to receive an open stream
                 var m = new MemoryStream();
                 var w = new XmlTextWriter(m, Encoding.UTF8);
+#pragma warning restore CA2000 // Dispose objects before losing scope
                 w.WriteStartDocument();
 
                 int t5 = Environment.TickCount;
@@ -127,6 +129,7 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
                 m.Position = 0;
 
                 Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform(\"{0}\") t={1}", resource, Environment.TickCount - t1));
+
                 return m;
             }
         }
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index dfc7d8e46c2..1e98ca0ec72 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -511,7 +511,8 @@ private static void ReplacePublicKeyToken(XmlDocument manifestDom, AsymmetricAlg
 
             if (snKey is RSACryptoServiceProvider rsacsp)
             {
-                cspPublicKeyBlob = (GetFixedRSACryptoServiceProvider(rsacsp, useSha256)).ExportCspBlob(false);
+                using var cryptoProvider = GetFixedRSACryptoServiceProvider(rsacsp, useSha256);
+                cspPublicKeyBlob = cryptoProvider.ExportCspBlob(false);
                 if (cspPublicKeyBlob == null || cspPublicKeyBlob.Length == 0)
                 {
                     throw new CryptographicException(Win32.NTE_BAD_KEY);
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 1c931d712d0..3fc9a9c4d00 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -388,8 +388,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   
   <PropertyGroup Condition="'$(MSBuildCopyMarkerName)' == ''">
     <MSBuildCopyMarkerName>$(MSBuildProjectFile)</MSBuildCopyMarkerName>
-    <!-- For a long MSBuildProjectFile let's shorten this to 17 chars - using the first 8 chars of the filename and a filename hash. -->
-    <MSBuildCopyMarkerName Condition="'$(MSBuildCopyMarkerName.Length)' &gt; '17'">$(MSBuildProjectFile.Substring(0,8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString("X8"))</MSBuildCopyMarkerName>
+    <!-- For a long MSBuildProjectFile let's shorten this to 17 chars - using the first 8 codepoints of the filename and a filename hash. -->
+    <MSBuildCopyMarkerName Condition="'$(MSBuildCopyMarkerName.Length)' &gt; '17'">$([MSBuild]::SubstringByTextElements($(MSBuildProjectFile), 0, 8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString("X8"))</MSBuildCopyMarkerName>
     <MSBuildCopyMarkerName>$(MSBuildCopyMarkerName).Up2Date</MSBuildCopyMarkerName>
   </PropertyGroup>
 
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 5bce63d6e60..614ed571685 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -289,10 +289,11 @@ public override bool Execute()
                     // Default the filename if we need to - regardless of whether the STR was successfully generated
                     if (StronglyTypedFileName == null)
                     {
-                        CodeDomProvider provider;
+                        CodeDomProvider provider = null;
                         try
                         {
                             provider = CodeDomProvider.CreateProvider(StronglyTypedLanguage);
+                            StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(provider, outputFile.ItemSpec);
                         }
                         catch (System.Configuration.ConfigurationException)
                         {
@@ -306,8 +307,10 @@ public override bool Execute()
                             // logged an appropriate error.
                             return false;
                         }
-
-                        StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(provider, outputFile.ItemSpec);
+                        finally
+                        {
+                            provider?.Dispose();
+                        }
                     }
                 }
 
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index deade89479b..2fcfbe94245 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -216,7 +216,7 @@ private bool ResolveManifestKey()
                     {
                         bool imported = false;
                         // first try it with no password
-                        var cert = new X509Certificate2();
+                        using var cert = new X509Certificate2();
                         var personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
                         try
                         {
diff --git a/src/Tasks/ResourceHandling/FileStreamResource.cs b/src/Tasks/ResourceHandling/FileStreamResource.cs
index ea29bf5b772..39117f25e70 100644
--- a/src/Tasks/ResourceHandling/FileStreamResource.cs
+++ b/src/Tasks/ResourceHandling/FileStreamResource.cs
@@ -12,8 +12,11 @@ namespace Microsoft.Build.Tasks.ResourceHandling
     internal class FileStreamResource : IResource
     {
         public string Name { get; }
+
         public string TypeAssemblyQualifiedName { get; }
+
         public string OriginatingFile { get; }
+
         public string FileName { get; }
 
         public string TypeFullName => NameUtilities.FullNameFromAssemblyQualifiedName(TypeAssemblyQualifiedName);
@@ -37,7 +40,9 @@ public void AddTo(IResourceWriter writer)
         {
             if (writer is PreserializedResourceWriter preserializedResourceWriter)
             {
+#pragma warning disable CA2000 // Dispose objects before losing scope the stream is expected to be disposed by the PreserializedResourceWriter.ResourceDataRecord
                 FileStream fileStream = new FileStream(FileName, FileMode.Open, FileAccess.Read, FileShare.Read);
+#pragma warning restore CA2000 // Dispose objects before losing scope
 
                 preserializedResourceWriter.AddActivatorResource(Name, fileStream, TypeAssemblyQualifiedName, closeAfterWrite: true);
             }
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index bb642bc1dc9..eef9d9a6a5e 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -118,7 +118,7 @@
       </trans-unit>
       <trans-unit id="AxTlbBaseTask.StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3654: Delay signing requires that at least a public key be specified.  Please either supply a public key using the KeyFile or KeyContainer properties, or disable delay signing.</source>
-        <target state="translated">MSB3654: La firma retrasada requiere que se especifique al menos una clave pÃºblica.  Proporcione una clave pÃºblica mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retrasada.</target>
+        <target state="translated">MSB3654: La firma retardada requiere que se especifique al menos una clave pÃºblica.  Proporcione una clave pÃºblica mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retardada.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
@@ -2307,7 +2307,7 @@
       </trans-unit>
       <trans-unit id="ResolveComReference.LoadingDelaySignedAssemblyWithStrongNameVerificationEnabled">
         <source>MSB3295: Failed to load an assembly. Please make sure you have disabled strong name verification for your public key if you want to generate delay signed wrappers. {0}</source>
-        <target state="translated">MSB3295: No se pudo cargar un ensamblado. AsegÃºrese de que deshabilitÃ³ la comprobaciÃ³n de nombres seguros para su clave pÃºblica si desea generar contenedores de firma con retraso. {0}</target>
+        <target state="translated">MSB3295: No se pudo cargar un ensamblado. AsegÃºrese de que deshabilitÃ³ la comprobaciÃ³n de nombres seguros para su clave pÃºblica si desea generar contenedores de firma retardada. {0}</target>
         <note>{StrBegin="MSB3295: "}</note>
       </trans-unit>
       <trans-unit id="ResolveComReference.MissingOrUnknownComReferenceAttribute">
@@ -2516,7 +2516,7 @@
       </trans-unit>
       <trans-unit id="StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3353: Public key necessary for delay signing was not specified.</source>
-        <target state="translated">MSB3353: No se especificÃ³ la clave pÃºblica necesaria para la firma con retraso.</target>
+        <target state="translated">MSB3353: No se especificÃ³ la clave pÃºblica necesaria para la firma retardada.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
       <trans-unit id="Task.FileLocked">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 0caa71beb21..27b03e70d2e 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="translated">MSB3991: â{0}â non Ã¨ impostato o Ã¨ vuoto. Quando {1} Ã¨ false, assicurarsi di impostare un valore non vuoto per "{0}".</target>
+        <target state="translated">MSB3991: '{0}' non Ã¨ impostato o Ã¨ vuoto. Quando {1} Ã¨ false, assicurarsi di impostare un valore non vuoto per '{0}'.</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="translated">MSB3992: "{0}" non impostato. Quando {1} Ã¨ true, assicurarsi di impostare un valore per "{0}".</target>
+        <target state="translated">MSB3992: '{0}' non Ã¨ impostato. Quando {1} Ã¨ true, assicurarsi di impostare un valore per '{0}'.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 53ad3198125..6590a161c43 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -116,6 +116,7 @@ public override bool Execute()
                         {
                             using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))
                             {
+#pragma warning disable CA2000 // Dispose objects before losing scope because ZipArchive will dispose the stream when it is disposed.
                                 using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))
                                 {
                                     try
@@ -129,6 +130,7 @@ public override bool Execute()
                                         return false;
                                     }
                                 }
+#pragma warning restore CA2000 // Dispose objects before losing scope
                             }
                         }
                         catch (OperationCanceledException)
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 77128537b7a..81b2c4d9497 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -140,145 +140,151 @@ private string GenerateCode(out string extension)
             extension = null;
             bool haveGeneratedContent = false;
 
-            CodeDomProvider provider;
-
+            CodeDomProvider provider = null;
             try
             {
-                provider = CodeDomProvider.CreateProvider(Language);
-            }
-            catch (SystemException e) when
+                try
+                {
+                    provider = CodeDomProvider.CreateProvider(Language);
+                }
+                catch (SystemException e) when
 #if FEATURE_SYSTEM_CONFIGURATION
-            (e is ConfigurationException || e is SecurityException)
+                (e is ConfigurationException || e is SecurityException)
 #else
             (e.GetType().Name == "ConfigurationErrorsException") // TODO: catch specific exception type once it is public https://github.com/dotnet/corefx/issues/40456
 #endif
-            {
-                Log.LogErrorWithCodeFromResources("WriteCodeFragment.CouldNotCreateProvider", Language, e.Message);
-                return null;
-            }
-
-            extension = provider.FileExtension;
+                {
+                    Log.LogErrorWithCodeFromResources("WriteCodeFragment.CouldNotCreateProvider", Language, e.Message);
+                    return null;
+                }
 
-            var unit = new CodeCompileUnit();
+                extension = provider.FileExtension;
 
-            var globalNamespace = new CodeNamespace();
-            unit.Namespaces.Add(globalNamespace);
+                var unit = new CodeCompileUnit();
 
-            // Declare authorship. Unfortunately CodeDOM puts this comment after the attributes.
-            string comment = ResourceUtilities.GetResourceString("WriteCodeFragment.Comment");
-            globalNamespace.Comments.Add(new CodeCommentStatement(comment));
+                var globalNamespace = new CodeNamespace();
+                unit.Namespaces.Add(globalNamespace);
 
-            if (AssemblyAttributes == null)
-            {
-                return String.Empty;
-            }
+                // Declare authorship. Unfortunately CodeDOM puts this comment after the attributes.
+                string comment = ResourceUtilities.GetResourceString("WriteCodeFragment.Comment");
+                globalNamespace.Comments.Add(new CodeCommentStatement(comment));
 
-            // For convenience, bring in the namespaces, where many assembly attributes lie
-            foreach (string name in NamespaceImports)
-            {
-                globalNamespace.Imports.Add(new CodeNamespaceImport(name));
-            }
+                if (AssemblyAttributes == null)
+                {
+                    return String.Empty;
+                }
 
-            foreach (ITaskItem attributeItem in AssemblyAttributes)
-            {
-                // Some attributes only allow positional constructor arguments, or the user may just prefer them.
-                // To set those, use metadata names like "_Parameter1", "_Parameter2" etc.
-                // If a parameter index is skipped, it's an error.
-                IDictionary customMetadata = attributeItem.CloneCustomMetadata();
+                // For convenience, bring in the namespaces, where many assembly attributes lie
+                foreach (string name in NamespaceImports)
+                {
+                    globalNamespace.Imports.Add(new CodeNamespaceImport(name));
+                }
 
-                // Some metadata may indicate the types of parameters. Use that metadata to determine
-                // the parameter types. Those metadata items will be removed from the dictionary.
-                IReadOnlyDictionary<string, ParameterType> parameterTypes = ExtractParameterTypes(customMetadata);
+                foreach (ITaskItem attributeItem in AssemblyAttributes)
+                {
+                    // Some attributes only allow positional constructor arguments, or the user may just prefer them.
+                    // To set those, use metadata names like "_Parameter1", "_Parameter2" etc.
+                    // If a parameter index is skipped, it's an error.
+                    IDictionary customMetadata = attributeItem.CloneCustomMetadata();
 
-                var orderedParameters = new List<AttributeParameter?>(new AttributeParameter?[customMetadata.Count + 1] /* max possible slots needed */);
-                var namedParameters = new List<AttributeParameter>();
+                    // Some metadata may indicate the types of parameters. Use that metadata to determine
+                    // the parameter types. Those metadata items will be removed from the dictionary.
+                    IReadOnlyDictionary<string, ParameterType> parameterTypes = ExtractParameterTypes(customMetadata);
 
-                foreach (DictionaryEntry entry in customMetadata)
-                {
-                    string name = (string)entry.Key;
-                    string value = (string)entry.Value;
+                    var orderedParameters = new List<AttributeParameter?>(new AttributeParameter?[customMetadata.Count + 1] /* max possible slots needed */);
+                    var namedParameters = new List<AttributeParameter>();
 
-                    // Get the declared type information for this parameter.
-                    // If a type is not declared, then we infer the type.
-                    if (!parameterTypes.TryGetValue(name, out ParameterType type))
+                    foreach (DictionaryEntry entry in customMetadata)
                     {
-                        type = new ParameterType { Kind = ParameterTypeKind.Inferred };
+                        string name = (string)entry.Key;
+                        string value = (string)entry.Value;
+
+                        // Get the declared type information for this parameter.
+                        // If a type is not declared, then we infer the type.
+                        if (!parameterTypes.TryGetValue(name, out ParameterType type))
+                        {
+                            type = new ParameterType { Kind = ParameterTypeKind.Inferred };
+                        }
+
+                        if (name.StartsWith("_Parameter", StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (!Int32.TryParse(name.Substring("_Parameter".Length), out int index))
+                            {
+                                Log.LogErrorWithCodeFromResources("General.InvalidValue", name, "WriteCodeFragment");
+                                return null;
+                            }
+
+                            if (index > orderedParameters.Count || index < 1)
+                            {
+                                Log.LogErrorWithCodeFromResources("WriteCodeFragment.SkippedNumberedParameter", index);
+                                return null;
+                            }
+
+                            // "_Parameter01" and "_Parameter1" would overwrite each other
+                            orderedParameters[index - 1] = new AttributeParameter { Type = type, Value = value };
+                        }
+                        else
+                        {
+                            namedParameters.Add(new AttributeParameter { Name = name, Type = type, Value = value });
+                        }
                     }
 
-                    if (name.StartsWith("_Parameter", StringComparison.OrdinalIgnoreCase))
+                    bool encounteredNull = false;
+                    List<AttributeParameter> providedOrderedParameters = new();
+                    for (int i = 0; i < orderedParameters.Count; i++)
                     {
-                        if (!Int32.TryParse(name.Substring("_Parameter".Length), out int index))
+                        if (!orderedParameters[i].HasValue)
                         {
-                            Log.LogErrorWithCodeFromResources("General.InvalidValue", name, "WriteCodeFragment");
-                            return null;
+                            // All subsequent args should be null, else a slot was missed
+                            encounteredNull = true;
+                            continue;
                         }
 
-                        if (index > orderedParameters.Count || index < 1)
+                        if (encounteredNull)
                         {
-                            Log.LogErrorWithCodeFromResources("WriteCodeFragment.SkippedNumberedParameter", index);
+                            Log.LogErrorWithCodeFromResources("WriteCodeFragment.SkippedNumberedParameter", i + 1 /* back to 1 based */);
                             return null;
                         }
 
-                        // "_Parameter01" and "_Parameter1" would overwrite each other
-                        orderedParameters[index - 1] = new AttributeParameter { Type = type, Value = value };
-                    }
-                    else
-                    {
-                        namedParameters.Add(new AttributeParameter { Name = name, Type = type, Value = value });
+                        providedOrderedParameters.Add(orderedParameters[i].Value);
                     }
-                }
 
-                bool encounteredNull = false;
-                List<AttributeParameter> providedOrderedParameters = new();
-                for (int i = 0; i < orderedParameters.Count; i++)
-                {
-                    if (!orderedParameters[i].HasValue)
-                    {
-                        // All subsequent args should be null, else a slot was missed
-                        encounteredNull = true;
-                        continue;
-                    }
+                    var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));
+
+                    // We might need the type of the attribute if we need to infer the
+                    // types of the parameters. Search for it by the given type name,
+                    // as well as within the namespaces that we automatically import.
+                    Lazy<Type> attributeType = new(
+                        () => Type.GetType(attribute.Name, throwOnError: false) ?? NamespaceImports.Select(x => Type.GetType($"{x}.{attribute.Name}", throwOnError: false)).FirstOrDefault(),
+                        System.Threading.LazyThreadSafetyMode.None);
 
-                    if (encounteredNull)
+                    if (
+                        !AddArguments(attribute, attributeType, providedOrderedParameters, isPositional: true)
+                        || !AddArguments(attribute, attributeType, namedParameters, isPositional: false))
                     {
-                        Log.LogErrorWithCodeFromResources("WriteCodeFragment.SkippedNumberedParameter", i + 1 /* back to 1 based */);
                         return null;
                     }
 
-                    providedOrderedParameters.Add(orderedParameters[i].Value);
+                    unit.AssemblyCustomAttributes.Add(attribute);
+                    haveGeneratedContent = true;
                 }
 
-                var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));
-
-                // We might need the type of the attribute if we need to infer the
-                // types of the parameters. Search for it by the given type name,
-                // as well as within the namespaces that we automatically import.
-                Lazy<Type> attributeType = new(
-                    () => Type.GetType(attribute.Name, throwOnError: false) ?? NamespaceImports.Select(x => Type.GetType($"{x}.{attribute.Name}", throwOnError: false)).FirstOrDefault(),
-                    System.Threading.LazyThreadSafetyMode.None);
-
-                if (
-                    !AddArguments(attribute, attributeType, providedOrderedParameters, isPositional: true)
-                    || !AddArguments(attribute, attributeType, namedParameters, isPositional: false))
+                var generatedCode = new StringBuilder();
+                using (var writer = new StringWriter(generatedCode, CultureInfo.CurrentCulture))
                 {
-                    return null;
+                    provider.GenerateCodeFromCompileUnit(unit, writer, new CodeGeneratorOptions());
                 }
 
-                unit.AssemblyCustomAttributes.Add(attribute);
-                haveGeneratedContent = true;
-            }
+                string code = generatedCode.ToString();
 
-            var generatedCode = new StringBuilder();
-            using (var writer = new StringWriter(generatedCode, CultureInfo.CurrentCulture))
+                // If we just generated infrastructure, don't bother returning anything
+                // as there's no point writing the file
+                return haveGeneratedContent ? code : String.Empty;
+            }
+            finally
             {
-                provider.GenerateCodeFromCompileUnit(unit, writer, new CodeGeneratorOptions());
+                provider?.Dispose();
             }
-
-            string code = generatedCode.ToString();
-
-            // If we just generated infrastructure, don't bother returning anything
-            // as there's no point writing the file
-            return haveGeneratedContent ? code : String.Empty;
         }
 
         /// <summary>
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index bd9f1aa2185..626a1a92587 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -144,7 +144,9 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
                     throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Xaml.RuleFileNotFound", contentOrFile));
                 }
 
-                return ParseXamlDocument(new StreamReader(contentOrFile), desiredRule);
+                using var sr = new StreamReader(contentOrFile);
+
+                return ParseXamlDocument(sr, desiredRule);
             }
 
             // On Windows, xml content string is not a valid path, so, maybeFullPath == null
@@ -158,7 +160,9 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
             if (FileSystems.Default.FileExists(maybeFullPath))
             {
                 // file found, parse as a file
-                return ParseXamlDocument(new StreamReader(maybeFullPath), desiredRule);
+                using var sr = new StreamReader(maybeFullPath);
+
+                return ParseXamlDocument(sr, desiredRule);
             }
 
             // @maybeFullPath is either:
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 4094d25b62e..342fb1f30b2 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -131,7 +131,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
             };
 
             // create the code provider
-            var codegenerator = CodeDomProvider.CreateProvider("cs");
+            using var codegenerator = CodeDomProvider.CreateProvider("cs");
             CompilerResults results;
             bool debugXamlTask = Environment.GetEnvironmentVariable("MSBUILDWRITEXAMLTASK") == "1";
             if (debugXamlTask)
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 2f255f143cc..f55532b9546 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -451,8 +451,12 @@ public XslCompiledTransform LoadXslt(bool useTrustedSettings)
                 switch (_xslMode)
                 {
                     case XslModes.Xslt:
-                        xslct.Load(XmlReader.Create(new StringReader(_data)), settings, new XmlUrlResolver());
-                        break;
+                        {
+                            using var sr = new StringReader(_data);
+                            using var xmlReader = XmlReader.Create(sr);
+                            xslct.Load(xmlReader, settings, new XmlUrlResolver());
+                            break;
+                        }         
                     case XslModes.XsltFile:
                         if (useTrustedSettings)
                         {
diff --git a/src/UnitTests.Shared/BootstrapLocationAttribute.cs b/src/UnitTests.Shared/BootstrapLocationAttribute.cs
new file mode 100644
index 00000000000..7f8627a69b3
--- /dev/null
+++ b/src/UnitTests.Shared/BootstrapLocationAttribute.cs
@@ -0,0 +1,13 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
+namespace Microsoft.Build.UnitTests.Shared;
+
+[System.AttributeUsage(System.AttributeTargets.Assembly)]
+internal sealed class BootstrapLocationAttribute(string bootstrapMsbuildBinaryLocation)
+    : System.Attribute
+{
+    public string BootstrapMsbuildBinaryLocation { get; } = bootstrapMsbuildBinaryLocation;
+}
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 0bade6a09d5..fee3abf670f 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -1,6 +1,6 @@
 <Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
-    <TargetFrameworks>$(FullFrameworkTFM);$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
+    <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <AssemblyName>Microsoft.Build.UnitTests.Shared</AssemblyName>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
     <IsShipping>false</IsShipping>
@@ -18,5 +18,21 @@
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
+    <ProjectReference Include="..\MSBuild.Bootstrap\MSBuild.Bootstrap.csproj">
+      <Private>false</Private>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+
+  <ItemGroup>
+    <Compile Include="..\Shared\IsExternalInit.cs" />
+  </ItemGroup>
+
+  <Import Project="..\..\eng\BootStrapMsBuild.props" />
+
+  <ItemGroup>
+    <AssemblyAttribute Include="Microsoft.Build.UnitTests.Shared.BootstrapLocationAttribute">
+      <_Parameter1>$(BootstrapBinaryDestination)</_Parameter1>
+    </AssemblyAttribute>
   </ItemGroup>
 </Project>
diff --git a/src/UnitTests.Shared/ObjectModelHelpers.cs b/src/UnitTests.Shared/ObjectModelHelpers.cs
index ce51be22785..e5cf81e5fe3 100644
--- a/src/UnitTests.Shared/ObjectModelHelpers.cs
+++ b/src/UnitTests.Shared/ObjectModelHelpers.cs
@@ -1971,7 +1971,8 @@ public static void VerifyAssertLineByLine(string expected, string actual, bool i
         /// </summary>
         public static void ClearDirtyFlag(ProjectRootElement project)
         {
-            project.Save(new StringWriter());
+            using var sw = new StringWriter();
+            project.Save(sw);
             Assert.False(project.HasUnsavedChanges);
         }
 
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index c1e96f7a6cb..a61f1a9fb4c 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -4,7 +4,11 @@
 using System;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
+using System.IO;
+using System.Reflection;
+using Microsoft.Build.Framework;
 using Xunit.Abstractions;
+using System.Linq;
 
 #nullable disable
 
@@ -48,6 +52,21 @@ public static string ExecMSBuild(string pathToMsBuildExe, string msbuildParamete
             return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper);
         }
 
+        public static string ExecBootstrapedMSBuild(string msbuildParameters, out bool successfulExit, bool shellExecute = false, ITestOutputHelper outputHelper = null)
+        {
+            BootstrapLocationAttribute attribute = Assembly.GetExecutingAssembly().GetCustomAttribute<BootstrapLocationAttribute>()
+                                                   ?? throw new InvalidOperationException("This test assembly does not have the BootstrapLocationAttribute");
+
+            string binaryFolder = attribute.BootstrapMsbuildBinaryLocation;
+#if NET
+            string pathToExecutable = EnvironmentProvider.GetDotnetExePath()!;
+            msbuildParameters = Path.Combine(binaryFolder, "MSBuild.dll") + " " + msbuildParameters;
+#else
+            string pathToExecutable = Path.Combine(binaryFolder, "MSBuild.exe");
+#endif
+            return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper);
+        }
+
         private static void AdjustForShellExecution(ref string pathToExecutable, ref string arguments)
         {
             if (NativeMethodsShared.IsWindows)
@@ -91,8 +110,9 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
             {
                 DataReceivedEventHandler handler = delegate (object sender, DataReceivedEventArgs args)
                 {
-                    if (args != null)
+                    if (args != null && args.Data != null)
                     {
+                        WriteOutput(args.Data);
                         output += args.Data + "\r\n";
                     }
                 };
@@ -100,15 +120,18 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
                 p.OutputDataReceived += handler;
                 p.ErrorDataReceived += handler;
 
-                outputHelper?.WriteLine("Executing [{0} {1}]", process, parameters);
-                Console.WriteLine("Executing [{0} {1}]", process, parameters);
-
+                WriteOutput( $"Executing [{process} {parameters}]");
+                WriteOutput("==== OUTPUT ====");
                 p.Start();
                 p.BeginOutputReadLine();
                 p.BeginErrorReadLine();
                 p.StandardInput.Dispose();
 
-                if (!p.WaitForExit(30_000))
+                if (Traits.Instance.DebugUnitTests)
+                {
+                    p.WaitForExit();
+                }
+                else if (!p.WaitForExit(30_000))
                 {
                     // Let's not create a unit test for which we need more than 30 sec to execute.
                     // Please consider carefully if you would like to increase the timeout.
@@ -125,18 +148,17 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
                 successfulExit = p.ExitCode == 0;
             }
 
-            outputHelper?.WriteLine("==== OUTPUT ====");
-            outputHelper?.WriteLine(output);
-            outputHelper?.WriteLine("Process ID is " + pid + "\r\n");
-            outputHelper?.WriteLine("==============");
-
-            Console.WriteLine("==== OUTPUT ====");
-            Console.WriteLine(output);
-            Console.WriteLine("Process ID is " + pid + "\r\n");
-            Console.WriteLine("==============");
+            WriteOutput("Process ID is " + pid + "\r\n");
+            WriteOutput("==============");
 
             output += "Process ID is " + pid + "\r\n";
             return output;
+
+            void WriteOutput(string data)
+            {
+                outputHelper?.WriteLine(data);
+                Console.WriteLine(data);
+            }
         }
     }
 }
diff --git a/src/UnitTests.Shared/TestEnvironment.cs b/src/UnitTests.Shared/TestEnvironment.cs
index 86e85d3cd51..d961178b298 100644
--- a/src/UnitTests.Shared/TestEnvironment.cs
+++ b/src/UnitTests.Shared/TestEnvironment.cs
@@ -53,6 +53,10 @@ public static TestEnvironment Create(ITestOutputHelper output = null, bool ignor
                 env.WithInvariant(new BuildFailureLogInvariant());
             }
 
+            // Clear these two environment variables first in case pre-setting affects the test.
+            env.SetEnvironmentVariable("MSBUILDLIVELOGGER", null);
+            env.SetEnvironmentVariable("MSBUILDTERMINALLOGGER", null);
+
             return env;
         }
 
@@ -83,10 +87,10 @@ private void Cleanup()
             {
                 _disposed = true;
 
-                // Reset test variants
-                foreach (var variant in _variants)
+                // Reset test variants in reverse order to get back to original state.
+                for (int i = _variants.Count - 1; i >= 0; i--)
                 {
-                    variant.Revert();
+                    _variants[i].Revert();
                 }
 
                 // Assert invariants
diff --git a/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json b/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
new file mode 100644
index 00000000000..52c4467e930
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
@@ -0,0 +1,49 @@
+{
+    "$schema": "http://json.schemastore.org/template",
+    "author": "Microsoft",
+    "classifications": [
+      "Common",
+      "Library"
+    ],
+    "name": "MSBuild custom analyzer skeleton project.",
+    "generatorVersions": "[1.0.0.0-*)",
+    "description": "A project for creating a MSBuild analyzer library that targets .NET Standard",
+    "groupIdentity": "Microsoft.AnalyzerTemplate",
+    "identity": "Microsoft.AnalyzerTemplate",
+    "shortName": "msbuildanalyzer",
+    "tags": {
+      "language": "C#",
+      "type": "project"
+    },
+    "sourceName": "Company.AnalyzerTemplate",
+    "preferNameDirectory": true,
+    "primaryOutputs": [
+      {
+        "path": "Company.AnalyzerTemplate.csproj"
+      }
+   ],
+   "symbols": {
+    "MicrosoftBuildVersion": {
+      "type": "parameter",
+      "description": "Overrides the default Microsoft.Build version where analyzer's interfaces are placed",
+      "datatype": "text",
+      "defaultValue": "17.11.0",
+      "replaces": "1.0.0-MicrosoftBuildPackageVersion",
+      "displayName": "Microsoft.Build default package version override"
+    }
+   },
+    "postActions": [
+      {
+        "id": "restore",
+        "condition": "(!skipRestore)",
+        "description": "Restore NuGet packages required by this project.",
+        "manualInstructions": [
+          {
+            "text": "Run 'dotnet restore'"
+          }
+        ],
+        "actionId": "210D431B-A78B-4D2F-B762-4ED3E3EA9025",
+        "continueOnError": true
+      }
+    ]
+  }
\ No newline at end of file
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs b/template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs
new file mode 100644
index 00000000000..78dae77947b
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs
@@ -0,0 +1,39 @@
+ï»¿using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+using System.Collections.Generic;
+
+namespace Company.AnalyzerTemplate
+{
+    public sealed class Analyzer1 : BuildAnalyzer
+    {
+        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+            "X01234",
+            "Title",
+            "Description",
+            "Message format: {0}",
+            new BuildAnalyzerConfiguration());
+
+        public override string FriendlyName => "Company.Analyzer1";
+
+        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+
+        public override void Initialize(ConfigurationContext configurationContext)
+        {
+            // configurationContext to be used only if analyzer needs external configuration data.
+        }
+
+
+        public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+        {
+            registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+        }
+
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        {
+            context.ReportResult(BuildCheckResult.Create(
+                SupportedRule,
+                ElementLocation.EmptyLocation,
+                "Argument for the message format"));
+        }
+    }
+}
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj b/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
new file mode 100644
index 00000000000..0a1b8f974fc
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
@@ -0,0 +1,45 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <TargetFramework>netstandard2.0</TargetFramework>
+    <DevelopmentDependency>true</DevelopmentDependency>
+    <IncludeBuildOutput>false</IncludeBuildOutput>
+    <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
+    <!-- The output structure was modified for msbuild development needs.-->
+    <NoWarn>NU5101;NU5128</NoWarn>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <None Include="Company.AnalyzerTemplate.props" Pack="true" PackagePath="build\Company.AnalyzerTemplate.props" />
+    <Content Include="README.md" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <!-- Please add IncludeInPackage field to all third party dependencies. See the example below.-->
+    <PackageReference Include="Microsoft.Build" PrivateAssets="all" IncludeInPackage="true" />
+  </ItemGroup>
+
+  <Target Name="AddNuGetDlls" BeforeTargets="_GetPackageFiles">
+    <!-- Merge the collection of PackageReference and Assemblies using the NuGetPackageId key.
+       This produces a new list containing the DLL path and the "IncludeInPackage" metadata-->
+    <JoinItems Left="@(ResolvedCompileFileDefinitions)" LeftKey="NuGetPackageId" LeftMetadata="*" Right="@(PackageReference)" RightKey="" RightMetadata="*" ItemSpecToUse="Left">
+    <Output TaskParameter="JoinResult" ItemName="_PackagesToPack" />
+    </JoinItems>
+
+    <ItemGroup>
+    <!-- Remove NETStandard DLLs -->
+    <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(NuGetPackageId) == 'NETStandard.Library'" />
+    <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(_PackagesToPack.IncludeInPackage) != 'true'" />
+    </ItemGroup>
+
+    <Message Importance="High" Text="Adding DLLs from the following packages: @(_PackagesToPack->'%(NuGetPackageId)')" />
+
+    <ItemGroup>
+    <!-- Update the collection of items to pack with the DLLs from the NuGet packages -->
+    <None Include="@(_PackagesToPack)" Pack="true" PackagePath="lib" Visible="false" />
+
+    <!-- Add the DLL produced by the current project to the NuGet package -->
+    <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="lib" Visible="false" />
+    </ItemGroup>
+  </Target>
+</Project>
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props b/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
new file mode 100644
index 00000000000..3b752b831cc
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildAnalyzer>$([MSBuild]::RegisterAnalyzer($(MSBuildThisFileDirectory)..\lib\Company.AnalyzerTemplate.dll))</MSBuildAnalyzer>
+  </PropertyGroup>
+  <ItemGroup>
+    <PackageVersion Include="Microsoft.Build" Version="1.0.0-MicrosoftBuildPackageVersion" />
+  </ItemGroup>
+</Project>
diff --git a/template_feed/Microsoft.AnalyzerTemplate/README.md b/template_feed/Microsoft.AnalyzerTemplate/README.md
new file mode 100644
index 00000000000..4f29145e7f0
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Analyzer Template
+
+## Overview
+MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild analyzer libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom analysis rules.
+
+## Getting Started
+To use the MSBuild Custom Analyzer Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildanalyzer
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildanalyzer -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
\ No newline at end of file
