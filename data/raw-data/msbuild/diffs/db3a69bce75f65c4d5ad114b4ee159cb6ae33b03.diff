diff --git a/src/Build/BuildCheck/API/Check.cs b/src/Build/BuildCheck/API/Check.cs
index 4eeeb8599f1..55c1d87a950 100644
--- a/src/Build/BuildCheck/API/Check.cs
+++ b/src/Build/BuildCheck/API/Check.cs
@@ -43,6 +43,8 @@ public abstract class Check : IDisposable
     /// </param>
     public abstract void RegisterActions(IBuildCheckRegistrationContext registrationContext);
 
+    internal virtual bool IsBuiltIn => false;
+
     public virtual void Dispose()
     { }
 }
diff --git a/src/Build/BuildCheck/API/InternalCheck.cs b/src/Build/BuildCheck/API/InternalCheck.cs
index 728a01c053d..242c513e655 100644
--- a/src/Build/BuildCheck/API/InternalCheck.cs
+++ b/src/Build/BuildCheck/API/InternalCheck.cs
@@ -28,4 +28,6 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
 
         this.RegisterInternalActions(internalRegistrationContext);
     }
+
+    internal override bool IsBuiltIn => true;
 }
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index b0899f22134..97c4c65cae1 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -7,6 +7,7 @@
 using System.Reflection;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
@@ -53,21 +54,24 @@ public List<CheckFactory> CreateCheckFactories(
                     .ForEach(t => checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckBaseTypeNotAssignable", t.Name, t.Assembly));
             }
         }
-        catch (ReflectionTypeLoadException ex)
+        catch (ReflectionTypeLoadException ex) when (ex.LoaderExceptions.Length != 0)
         {
-            if (ex.LoaderExceptions.Length != 0)
+            foreach (Exception? loaderException in ex.LoaderExceptions)
             {
-                foreach (Exception? loaderException in ex.LoaderExceptions)
-                {
-                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", loaderException?.Message);
-                }
+                ReportLoadingError(loaderException);
             }
         }
         catch (Exception ex)
         {
-            checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", ex?.Message);
+            ReportLoadingError(ex);
         }
 
         return checksFactories;
+
+        void ReportLoadingError(Exception? ex)
+        {
+            checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", ex?.Message);
+            KnownTelemetry.BuildCheckTelemetry.AddCustomCheckLoadingFailure();
+        }
     }
 }
diff --git a/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
index df2cbd61145..dd53b3caf0d 100644
--- a/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
+++ b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
@@ -41,6 +41,8 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
         registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);
     }
 
+    internal override bool IsBuiltIn => true;
+
     /// <summary>
     /// Contains the first project file + task that wrote the given file during the build.
     /// </summary>
@@ -125,5 +127,5 @@ private void CheckWrite(BuildCheckDataContext<TaskInvocationCheckData> context,
                 _filesWritten.Add(fileBeingWritten, (context.Data.ProjectFilePath, context.Data.TaskName));
             }
         }
-   }
+    }
 }
diff --git a/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
index 51411b9502f..d5a65070dc2 100644
--- a/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
+++ b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
@@ -49,6 +49,8 @@ public override void Initialize(ConfigurationContext configurationContext)
 
     public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);
 
+    internal override bool IsBuiltIn => true;
+
     private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)
     {
         EnvironmentVariableIdentityKey identityKey = new(context.Data.EnvironmentVariableName, context.Data.EnvironmentVariableLocation);
diff --git a/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs b/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs
index f2e7d2fc37a..64f2e3bce65 100644
--- a/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs
+++ b/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs
@@ -118,6 +118,8 @@ public override void RegisterInternalActions(IInternalCheckRegistrationContext r
         }
     }
 
+    internal override bool IsBuiltIn => true;
+
     private Dictionary<string, IMSBuildElementLocation?> _writenProperties = new(MSBuildNameIgnoreCaseComparer.Default);
     private HashSet<string> _readProperties = new(MSBuildNameIgnoreCaseComparer.Default);
     // For the 'Property Initialized after used' check - we are interested in cases where:
diff --git a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
index 1ec84093e3a..97230dbdd16 100644
--- a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
+++ b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
@@ -35,6 +35,8 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
         registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
     }
 
+    internal override bool IsBuiltIn => true;
+
     private readonly Dictionary<string, string> _projectsPerOutputPath = new(StringComparer.CurrentCultureIgnoreCase);
     private readonly HashSet<string> _projects = new(StringComparer.CurrentCultureIgnoreCase);
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
index 419ca2c9f26..6cf33f96a37 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
@@ -107,7 +107,7 @@ private void HandleBuildCheckTracingEvent(BuildCheckTracingEventArgs eventArgs)
     {
         if (!eventArgs.IsAggregatedGlobalReport)
         {
-            _stats.Merge(eventArgs.TracingData, (span1, span2) => span1 + span2);
+            _tracingData.MergeIn(eventArgs.TracingData);
         }
     }
 
@@ -138,36 +138,25 @@ private void HandleEnvironmentVariableReadEvent(EnvironmentVariableReadEventArgs
 
     private bool IsMetaProjFile(string? projectFile) => projectFile?.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase) == true;
 
-    private readonly Dictionary<string, TimeSpan> _stats = new Dictionary<string, TimeSpan>();
+    private readonly BuildCheckTracingData _tracingData = new BuildCheckTracingData();
 
     private void HandleBuildFinishedEvent(BuildFinishedEventArgs eventArgs)
     {
         _buildCheckManager.ProcessBuildFinished(_checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!));
 
-        _stats.Merge(_buildCheckManager.CreateCheckTracingStats(), (span1, span2) => span1 + span2);
+        _tracingData.MergeIn(_buildCheckManager.CreateCheckTracingStats());
 
         LogCheckStats(_checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)));
     }
 
     private void LogCheckStats(ICheckContext checkContext)
     {
-        Dictionary<string, TimeSpan> infraStats = new Dictionary<string, TimeSpan>();
-        Dictionary<string, TimeSpan> checkStats = new Dictionary<string, TimeSpan>();
+        Dictionary<string, TimeSpan>  infraStats = _tracingData.InfrastructureTracingData;
+        // Stats are per rule, while runtime is per check - and check can have multiple rules.
+        // In case of multi-rule check, the runtime stats are duplicated for each rule.
+        Dictionary<string, TimeSpan> checkStats = _tracingData.ExtractCheckStats();
 
-        foreach (var stat in _stats)
-        {
-            if (stat.Key.StartsWith(BuildCheckConstants.infraStatPrefix))
-            {
-                string newKey = stat.Key.Substring(BuildCheckConstants.infraStatPrefix.Length);
-                infraStats[newKey] = stat.Value;
-            }
-            else
-            {
-                checkStats[stat.Key] = stat.Value;
-            }
-        }
-
-        BuildCheckTracingEventArgs statEvent = new BuildCheckTracingEventArgs(_stats, true)
+        BuildCheckTracingEventArgs statEvent = new BuildCheckTracingEventArgs(_tracingData, true)
         { BuildEventContext = checkContext.BuildEventContext };
 
         checkContext.DispatchBuildEvent(statEvent);
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index d219233aedb..814d265307a 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -234,10 +234,10 @@ private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string pr
             CheckConfigurationEffective[] configurations;
             if (checkFactoryContext.MaterializedCheck == null)
             {
-                CheckConfiguration[] userConfigs =
+                CheckConfiguration[] userEditorConfigs =
                     _configurationProvider.GetUserConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
-                if (userConfigs.All(c => !(c.IsEnabled ?? checkFactoryContext.IsEnabledByDefault)))
+                if (userEditorConfigs.All(c => !(c.IsEnabled ?? checkFactoryContext.IsEnabledByDefault)))
                 {
                     // the check was not yet instantiated nor mounted - so nothing to do here now.
                     return;
@@ -247,7 +247,7 @@ private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string pr
                     _configurationProvider.GetCustomConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
                 Check uninitializedCheck = checkFactoryContext.Factory();
-                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, uninitializedCheck);
+                configurations = _configurationProvider.GetMergedConfigurations(userEditorConfigs, uninitializedCheck);
 
                 ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData, configurations);
 
@@ -276,7 +276,7 @@ private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string pr
                 // price to be paid in that case is slight performance cost.
 
                 // Create the wrapper and register to central context
-                wrapper.StartNewProject(projectFullPath, configurations);
+                wrapper.StartNewProject(projectFullPath, configurations, userEditorConfigs);
                 var wrappedContext = new CheckRegistrationContext(wrapper, _buildCheckCentralContext);
                 check.RegisterActions(wrappedContext);
             }
@@ -284,13 +284,15 @@ private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string pr
             {
                 wrapper = checkFactoryContext.MaterializedCheck;
 
-                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.Check);
+                CheckConfiguration[] userEditorConfigs =
+                    _configurationProvider.GetUserConfigurations(projectFullPath, checkFactoryContext.RuleIds);
+                configurations = _configurationProvider.GetMergedConfigurations(userEditorConfigs, wrapper.Check);
 
                 _configurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
                     checkFactoryContext.RuleIds[0]);
 
                 // Update the wrapper
-                wrapper.StartNewProject(projectFullPath, configurations);
+                wrapper.StartNewProject(projectFullPath, configurations, userEditorConfigs);
             }
         }
 
@@ -336,7 +338,7 @@ private void RemoveChecks(List<CheckFactoryContext> checksToRemove, ICheckContex
             foreach (var checkToRemove in checksToRemove.Select(a => a.MaterializedCheck).Where(a => a != null))
             {
                 _buildCheckCentralContext.DeregisterCheck(checkToRemove!);
-                _tracingReporter.AddCheckStats(checkToRemove!.Check.FriendlyName, checkToRemove.Elapsed);
+                _ruleTelemetryData.AddRange(checkToRemove!.GetRuleTelemetryData());
                 checkToRemove.Check.Dispose();
             }
         }
@@ -401,19 +403,18 @@ public void ProcessTaskParameterEventArgs(
             => _buildEventsProcessor
                 .ProcessTaskParameterEventArgs(checkContext, taskParameterEventArgs);
 
-        public Dictionary<string, TimeSpan> CreateCheckTracingStats()
+        private readonly List<BuildCheckRuleTelemetryData> _ruleTelemetryData = [];
+        public BuildCheckTracingData CreateCheckTracingStats()
         {
             foreach (CheckFactoryContext checkFactoryContext in _checkRegistry)
             {
                 if (checkFactoryContext.MaterializedCheck != null)
                 {
-                    _tracingReporter.AddCheckStats(checkFactoryContext.FriendlyName, checkFactoryContext.MaterializedCheck.Elapsed);
-                    checkFactoryContext.MaterializedCheck.ClearStats();
+                    _ruleTelemetryData.AddRange(checkFactoryContext.MaterializedCheck.GetRuleTelemetryData());
                 }
             }
 
-            _tracingReporter.AddCheckInfraStats();
-            return _tracingReporter.TracingStats;
+            return new BuildCheckTracingData(_ruleTelemetryData, _tracingReporter.GetInfrastructureTracingStats());
         }
 
         public void FinalizeProcessing(LoggingContext loggingContext)
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index f2925ff1556..5d89499ff1f 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -242,6 +242,9 @@ private static void ReportResult(
             return;
         }
 
+        // Add the diagnostic to the check wrapper for telemetry purposes.
+        checkWrapper.AddDiagnostic(config);
+
         BuildEventArgs eventArgs = result.ToEventArgs(config.Severity);
 
         eventArgs.BuildEventContext = checkContext.BuildEventContext;
diff --git a/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs b/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
index 62011296cb5..c71cc40d3ae 100644
--- a/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
@@ -16,10 +16,28 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 internal sealed class CheckWrapper
 {
     private readonly Stopwatch _stopwatch = new Stopwatch();
+    private readonly BuildCheckRuleTelemetryData[] _ruleTelemetryData;
 
     public CheckWrapper(Check check)
     {
         Check = check;
+        _ruleTelemetryData = new BuildCheckRuleTelemetryData[check.SupportedRules.Count];
+
+        InitializeTelemetryData(_ruleTelemetryData, check);
+    }
+
+    private static void InitializeTelemetryData(BuildCheckRuleTelemetryData[] ruleTelemetryData, Check check)
+    {
+        int idx = 0;
+        foreach (CheckRule checkRule in check.SupportedRules)
+        {
+            ruleTelemetryData[idx++] = new BuildCheckRuleTelemetryData(
+                ruleId: checkRule.Id,
+                checkFriendlyName: check.FriendlyName,
+                isBuiltIn: check.IsBuiltIn,
+                defaultSeverity: (checkRule.DefaultConfiguration.Severity ??
+                                  CheckConfigurationEffective.Default.Severity).ToDiagnosticSeverity());
+        }
     }
 
     internal Check Check { get; }
@@ -29,38 +47,98 @@ public CheckWrapper(Check check)
     // In such case - configuration will be same for all projects. So we do not need to store it per project in a collection.
     internal CheckConfigurationEffective? CommonConfig { get; private set; }
 
-    // start new project
+    /// <summary>
+    /// Ensures the check being configured for a new project (as each project can have different settings)
+    /// </summary>
+    /// <param name="fullProjectPath"></param>
+    /// <param name="effectiveConfigs">Resulting merged configurations per rule (merged from check default and explicit user editorconfig).</param>
+    /// <param name="editorConfigs">Configurations from editorconfig per rule.</param>
     internal void StartNewProject(
         string fullProjectPath,
-        IReadOnlyList<CheckConfigurationEffective> userConfigs)
+        IReadOnlyList<CheckConfigurationEffective> effectiveConfigs,
+        IReadOnlyList<CheckConfiguration> editorConfigs)
     {
+        // Let's first update the telemetry data for the rules.
+        int idx = 0;
+        foreach (BuildCheckRuleTelemetryData ruleTelemetryData in _ruleTelemetryData)
+        {
+            CheckConfigurationEffective effectiveConfig = effectiveConfigs[Math.Max(idx, effectiveConfigs.Count - 1)];
+            ruleTelemetryData.ExplicitSeverities.Add(editorConfigs[idx].Severity.ToDiagnosticSeverity());
+
+            if (effectiveConfig.IsEnabled)
+            {
+                ruleTelemetryData.ProjectNamesWhereEnabled.Add(fullProjectPath);
+            }
+
+            idx++;
+        }
+
         if (!_isInitialized)
         {
             _isInitialized = true;
-            CommonConfig = userConfigs[0];
+            CommonConfig = effectiveConfigs[0];
 
-            if (userConfigs.Count == 1)
+            if (effectiveConfigs.Count == 1)
             {
                 return;
             }
         }
 
         // The Common configuration is not common anymore - let's nullify it and we will need to fetch configuration per project.
-        if (CommonConfig == null || !userConfigs.All(t => t.IsSameConfigurationAs(CommonConfig)))
+        if (CommonConfig == null || !effectiveConfigs.All(t => t.IsSameConfigurationAs(CommonConfig)))
         {
             CommonConfig = null;
         }
     }
 
+    internal void AddDiagnostic(CheckConfigurationEffective configurationEffective)
+    {
+        BuildCheckRuleTelemetryData? telemetryData =
+            _ruleTelemetryData.FirstOrDefault(td => td.RuleId.Equals(configurationEffective.RuleId));
+
+        if (telemetryData == null)
+        {
+            return;
+        }
+
+        switch (configurationEffective.Severity)
+        {
+            
+            case CheckResultSeverity.Suggestion:
+                telemetryData.IncrementMessagesCount();
+                break;
+            case CheckResultSeverity.Warning:
+                telemetryData.IncrementWarningsCount();
+                break;
+            case CheckResultSeverity.Error:
+                telemetryData.IncrementErrorsCount();
+                break;
+            case CheckResultSeverity.Default:
+            case CheckResultSeverity.None:
+            default:
+                break;
+        }
+
+        // TODO: add throttling info - once it's merged
+    }
+
     // to be used on eval node (BuildCheckDataSource.check)
     internal void Uninitialize()
     {
         _isInitialized = false;
     }
 
-    internal TimeSpan Elapsed => _stopwatch.Elapsed;
+    internal IReadOnlyList<BuildCheckRuleTelemetryData> GetRuleTelemetryData()
+    {
+        foreach (BuildCheckRuleTelemetryData ruleTelemetryData in _ruleTelemetryData)
+        {
+            ruleTelemetryData.TotalRuntime = _stopwatch.Elapsed;
+        }
 
-    internal void ClearStats() => _stopwatch.Reset();
+        return _ruleTelemetryData;
+    }
+
+    internal TimeSpan Elapsed => _stopwatch.Elapsed;
 
     internal CleanupScope StartSpan()
     {
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index 88c644954e7..8f125db4551 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -61,7 +61,7 @@ void ProcessTaskParameterEventArgs(
 
     void ProcessCheckAcquisition(CheckAcquisitionData acquisitionData, ICheckContext checksContext);
 
-    Dictionary<string, TimeSpan> CreateCheckTracingStats();
+    BuildCheckTracingData CreateCheckTracingStats();
 
     void FinalizeProcessing(LoggingContext loggingContext);
 
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index a5bf0b968a8..5f6e5c19b66 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -79,7 +79,7 @@ public void EndProjectRequest(ICheckContext checkContext, string projectFullPath
     {
     }
 
-    public Dictionary<string, TimeSpan> CreateCheckTracingStats() => new Dictionary<string, TimeSpan>();
+    public BuildCheckTracingData CreateCheckTracingStats() => new BuildCheckTracingData();
 
     public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext buildEventContext)
     { }
diff --git a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
index d7f75922966..05bb2f33cdc 100644
--- a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
+++ b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
@@ -13,26 +13,10 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal class TracingReporter
 {
-    internal Dictionary<string, TimeSpan> TracingStats { get; } = new();
-
-    // Infrastructure time keepers
-    // TODO: add more timers throughout BuildCheck run
     private TimeSpan checkAcquisitionTime;
     private TimeSpan checkSetDataSourceTime;
     private TimeSpan newProjectChecksTime;
 
-    public void AddCheckStats(string name, TimeSpan subtotal)
-    {
-        if (TracingStats.TryGetValue(name, out TimeSpan existing))
-        {
-            TracingStats[name] = existing + subtotal;
-        }
-        else
-        {
-            TracingStats[name] = subtotal;
-        }
-    }
-
     public void AddAcquisitionStats(TimeSpan subtotal)
     {
         checkAcquisitionTime += subtotal;
@@ -48,14 +32,11 @@ public void AddNewProjectStats(TimeSpan subtotal)
         newProjectChecksTime += subtotal;
     }
 
-    public void AddCheckInfraStats()
-    {
-        var infraStats = new Dictionary<string, TimeSpan>() {
-                { $"{BuildCheckConstants.infraStatPrefix}checkAcquisitionTime", checkAcquisitionTime },
-                { $"{BuildCheckConstants.infraStatPrefix}checkSetDataSourceTime", checkSetDataSourceTime },
-                { $"{BuildCheckConstants.infraStatPrefix}newProjectChecksTime", newProjectChecksTime }
-            };
-
-        TracingStats.Merge(infraStats, (span1, span2) => span1 + span2);
-    }
+    public Dictionary<string, TimeSpan> GetInfrastructureTracingStats()
+        => new Dictionary<string, TimeSpan>()
+        {
+            { $"{BuildCheckConstants.infraStatPrefix}checkAcquisitionTime", checkAcquisitionTime },
+            { $"{BuildCheckConstants.infraStatPrefix}checkSetDataSourceTime", checkSetDataSourceTime },
+            { $"{BuildCheckConstants.infraStatPrefix}newProjectChecksTime", newProjectChecksTime }
+        };
 }
diff --git a/src/Build/BuildCheck/Utilities/CherResultSeverityExtensions.cs b/src/Build/BuildCheck/Utilities/CherResultSeverityExtensions.cs
new file mode 100644
index 00000000000..ab61dce17ac
--- /dev/null
+++ b/src/Build/BuildCheck/Utilities/CherResultSeverityExtensions.cs
@@ -0,0 +1,31 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+internal static class CherResultSeverityExtensions
+{
+    public static DiagnosticSeverity? ToDiagnosticSeverity(this CheckResultSeverity? severity)
+    {
+        if (severity == null)
+        {
+            return null;
+        }
+
+        return ToDiagnosticSeverity(severity.Value);
+    }
+
+    public static DiagnosticSeverity ToDiagnosticSeverity(this CheckResultSeverity severity)
+    {
+        return severity switch
+        {
+            CheckResultSeverity.Default => DiagnosticSeverity.Default,
+            CheckResultSeverity.None => DiagnosticSeverity.None,
+            CheckResultSeverity.Suggestion => DiagnosticSeverity.Suggestion,
+            CheckResultSeverity.Warning => DiagnosticSeverity.Warning,
+            CheckResultSeverity.Error => DiagnosticSeverity.Error,
+            _ => throw new ArgumentOutOfRangeException(nameof(severity), severity, null)
+        };
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 294d96bae2c..f140698b70a 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -338,7 +338,11 @@ private BinaryLogRecordKind Write(BuildCheckResultError e)
         private BinaryLogRecordKind Write(BuildCheckTracingEventArgs e)
         {
             WriteBuildEventArgsFields(e, writeMessage: false);
-            WriteProperties(e.TracingData);
+
+            Dictionary<string, TimeSpan> stats = e.TracingData.ExtractCheckStats();
+            stats.Merge(e.TracingData.InfrastructureTracingData, (span1, span2) => span1 + span2);
+
+            WriteProperties(stats);
 
             return BinaryLogRecordKind.BuildCheckTracing;
         }
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
index b490195a034..bd8a1c6644e 100644
--- a/src/Framework/BuildCheck/BuildCheckEventArgs.cs
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -19,15 +19,20 @@ internal abstract class BuildCheckEventArgs : BuildEventArgs
 /// <summary>
 /// Transport mean for the BuildCheck tracing data from additional nodes.
 /// </summary>
-/// <param name="tracingData"></param>
-internal sealed class BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> tracingData) : BuildCheckEventArgs
+internal sealed class BuildCheckTracingEventArgs(
+    BuildCheckTracingData tracingData) : BuildCheckEventArgs
 {
     internal BuildCheckTracingEventArgs()
-        : this([])
-    {
-    }
+        : this(new BuildCheckTracingData())
+    { }
+
+    internal BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> executionData)
+        : this(new BuildCheckTracingData(executionData))
+    { }
 
-    internal BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> data, bool isAggregatedGlobalReport) : this(data) => IsAggregatedGlobalReport = isAggregatedGlobalReport;
+    internal BuildCheckTracingEventArgs(
+        BuildCheckTracingData tracingData,
+        bool isAggregatedGlobalReport) : this(tracingData) => IsAggregatedGlobalReport = isAggregatedGlobalReport;
 
     /// <summary>
     /// When true, the tracing information is from the whole build for logging purposes
@@ -35,18 +40,42 @@ internal BuildCheckTracingEventArgs()
     /// </summary>
     public bool IsAggregatedGlobalReport { get; private set; } = false;
 
-    public Dictionary<string, TimeSpan> TracingData { get; private set; } = tracingData;
+    public BuildCheckTracingData TracingData { get; private set; } = tracingData;
 
     internal override void WriteToStream(BinaryWriter writer)
     {
         base.WriteToStream(writer);
 
-        writer.Write7BitEncodedInt(TracingData.Count);
-        foreach (KeyValuePair<string, TimeSpan> kvp in TracingData)
+        writer.Write7BitEncodedInt(TracingData.InfrastructureTracingData.Count);
+        foreach (KeyValuePair<string, TimeSpan> kvp in TracingData.InfrastructureTracingData)
         {
             writer.Write(kvp.Key);
             writer.Write(kvp.Value.Ticks);
         }
+
+        writer.Write7BitEncodedInt(TracingData.TelemetryData.Count);
+        foreach (BuildCheckRuleTelemetryData data in TracingData.TelemetryData.Values)
+        {
+            writer.Write(data.RuleId);
+            writer.Write(data.CheckFriendlyName);
+            writer.Write(data.IsBuiltIn);
+            writer.Write7BitEncodedInt((int)data.DefaultSeverity);
+            writer.Write7BitEncodedInt(data.ExplicitSeverities.Count);
+            foreach (DiagnosticSeverity? severity in data.ExplicitSeverities)
+            {
+                writer.WriteOptionalInt32(severity == null ? null : (int)severity);
+            }
+            writer.Write7BitEncodedInt(data.ProjectNamesWhereEnabled.Count);
+            foreach (string projectName in data.ProjectNamesWhereEnabled)
+            {
+                writer.Write(projectName);
+            }
+            writer.Write7BitEncodedInt(data.ViolationMessagesCount);
+            writer.Write7BitEncodedInt(data.ViolationWarningsCount);
+            writer.Write7BitEncodedInt(data.ViolationErrorsCount);
+            writer.Write(data.IsThrottled);
+            writer.Write(data.TotalRuntime.Ticks);
+        }
     }
 
     internal override void CreateFromStream(BinaryReader reader, int version)
@@ -54,14 +83,59 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         base.CreateFromStream(reader, version);
 
         int count = reader.Read7BitEncodedInt();
-        TracingData = new Dictionary<string, TimeSpan>(count);
+        var infrastructureTracingData = new Dictionary<string, TimeSpan>(count);
         for (int i = 0; i < count; i++)
         {
             string key = reader.ReadString();
             TimeSpan value = TimeSpan.FromTicks(reader.ReadInt64());
 
-            TracingData.Add(key, value);
+            infrastructureTracingData.Add(key, value);
         }
+
+        count = reader.Read7BitEncodedInt();
+        List<BuildCheckRuleTelemetryData> tracingData = new List<BuildCheckRuleTelemetryData>(count);
+        for (int i = 0; i < count; i++)
+        {
+            string ruleId = reader.ReadString();
+            string checkFriendlyName = reader.ReadString();
+            bool isBuiltIn = reader.ReadBoolean();
+            DiagnosticSeverity defaultSeverity = (DiagnosticSeverity)reader.Read7BitEncodedInt();
+            int explicitSeveritiesCount = reader.Read7BitEncodedInt();
+            HashSet<DiagnosticSeverity?> explicitSeverities =
+#if NETSTANDARD2_0
+                new HashSet<DiagnosticSeverity?>();
+#else
+                new HashSet<DiagnosticSeverity?>(explicitSeveritiesCount);
+#endif
+            for (int j = 0; j < explicitSeveritiesCount; j++)
+            {
+                explicitSeverities.Add(reader.ReadOptionalInt32() == null ? null : (DiagnosticSeverity)reader.ReadInt32());
+            }
+            int projectNamesWhereEnabledCount = reader.Read7BitEncodedInt();
+            HashSet<string> projectNamesWhereEnabled =
+#if NETSTANDARD2_0
+                new HashSet<string>();
+#else
+                new HashSet<string>(projectNamesWhereEnabledCount);
+#endif
+            for (int j = 0; j < projectNamesWhereEnabledCount; j++)
+            {
+                projectNamesWhereEnabled.Add(reader.ReadString());
+            }
+            int violationMessagesCount = reader.Read7BitEncodedInt();
+            int violationWarningsCount = reader.Read7BitEncodedInt();
+            int violationErrorsCount = reader.Read7BitEncodedInt();
+            bool isThrottled = reader.ReadBoolean();
+            TimeSpan totalRuntime = TimeSpan.FromTicks(reader.ReadInt64());
+
+            BuildCheckRuleTelemetryData data = new BuildCheckRuleTelemetryData(
+                ruleId, checkFriendlyName, isBuiltIn, defaultSeverity, explicitSeverities, projectNamesWhereEnabled,
+                violationMessagesCount, violationWarningsCount, violationErrorsCount, isThrottled, totalRuntime);
+
+            tracingData.Add(data);
+        }
+
+        TracingData = new BuildCheckTracingData(tracingData, infrastructureTracingData);
     }
 }
 
diff --git a/src/Framework/BuildCheck/BuildCheckRuleTelemetryData.cs b/src/Framework/BuildCheck/BuildCheckRuleTelemetryData.cs
new file mode 100644
index 00000000000..886febef9cc
--- /dev/null
+++ b/src/Framework/BuildCheck/BuildCheckRuleTelemetryData.cs
@@ -0,0 +1,89 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Telemetry data for a single build check rule.
+/// </summary>
+/// <param name="ruleId"></param>
+/// <param name="checkFriendlyName"></param>
+/// <param name="isBuiltIn"></param>
+/// <param name="defaultSeverity"></param>
+internal sealed class BuildCheckRuleTelemetryData(
+    string ruleId,
+    string checkFriendlyName,
+    bool isBuiltIn,
+    DiagnosticSeverity defaultSeverity)
+{
+    public BuildCheckRuleTelemetryData(
+        string ruleId,
+        string checkFriendlyName,
+        bool isBuiltIn,
+        DiagnosticSeverity defaultSeverity,
+        HashSet<DiagnosticSeverity?> explicitSeverities,
+        HashSet<string> projectNamesWhereEnabled,
+        int violationMessagesCount,
+        int violationWarningsCount,
+        int violationErrorsCount,
+        bool isThrottled,
+        TimeSpan totalRuntime) : this(ruleId, checkFriendlyName, isBuiltIn,
+        defaultSeverity)
+    {
+        ExplicitSeverities = explicitSeverities;
+        ProjectNamesWhereEnabled = projectNamesWhereEnabled;
+        ViolationMessagesCount = violationMessagesCount;
+        ViolationWarningsCount = violationWarningsCount;
+        ViolationErrorsCount = violationErrorsCount;
+        IsThrottled = isThrottled;
+        TotalRuntime = totalRuntime;
+    }
+
+    public static BuildCheckRuleTelemetryData Merge(
+        BuildCheckRuleTelemetryData data1,
+        BuildCheckRuleTelemetryData data2)
+    {
+        if (data1.RuleId != data2.RuleId)
+        {
+            throw new InvalidOperationException("Cannot merge telemetry data for different rules.");
+        }
+        return new BuildCheckRuleTelemetryData(
+            data1.RuleId,
+            data1.CheckFriendlyName,
+            data1.IsBuiltIn,
+            data1.DefaultSeverity,
+            new HashSet<DiagnosticSeverity?>(data1.ExplicitSeverities.Union(data2.ExplicitSeverities)),
+            new HashSet<string>(data1.ProjectNamesWhereEnabled.Union(data2.ProjectNamesWhereEnabled)),
+            data1.ViolationMessagesCount + data2.ViolationMessagesCount,
+            data1.ViolationWarningsCount + data2.ViolationWarningsCount,
+            data1.ViolationErrorsCount + data2.ViolationErrorsCount,
+            data1.IsThrottled || data2.IsThrottled,
+            data1.TotalRuntime + data2.TotalRuntime);
+    }
+
+    public string RuleId { get; init; } = ruleId;
+    public string CheckFriendlyName { get; init; } = checkFriendlyName;
+    public bool IsBuiltIn { get; init; } = isBuiltIn;
+    public DiagnosticSeverity DefaultSeverity { get; init; } = defaultSeverity;
+
+    /// <summary>
+    /// A set of explicitly set severities (through editorconfig(s)) for the rule. There can be multiple - as different projects can have different settings.
+    /// </summary>
+    public HashSet<DiagnosticSeverity?> ExplicitSeverities { get; init; } = [];
+    public HashSet<string> ProjectNamesWhereEnabled { get; init; } = [];
+    public int ViolationMessagesCount { get; private set; }
+    public int ViolationWarningsCount { get; private set; }
+    public int ViolationErrorsCount { get; private set; }
+    public bool IsThrottled { get; private set; }
+    public TimeSpan TotalRuntime { get; set; }
+
+    public void IncrementMessagesCount() => ViolationMessagesCount++;
+    public void IncrementWarningsCount() => ViolationWarningsCount++;
+    public void IncrementErrorsCount() => ViolationErrorsCount++;
+    public void SetThrottled() => IsThrottled = true;
+}
+
diff --git a/src/Framework/BuildCheck/BuildCheckTracingData.cs b/src/Framework/BuildCheck/BuildCheckTracingData.cs
new file mode 100644
index 00000000000..dc3ef3cb227
--- /dev/null
+++ b/src/Framework/BuildCheck/BuildCheckTracingData.cs
@@ -0,0 +1,51 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Wrapper for the tracing data to be transferred from the worker nodes to the central node.
+/// </summary>
+/// <param name="telemetryData"></param>
+/// <param name="infrastructureTracingData"></param>
+internal sealed class BuildCheckTracingData(
+    Dictionary<string, BuildCheckRuleTelemetryData> telemetryData,
+    Dictionary<string, TimeSpan> infrastructureTracingData)
+{
+    public BuildCheckTracingData(IReadOnlyList<BuildCheckRuleTelemetryData> telemetryData, Dictionary<string, TimeSpan> infrastructureTracingData)
+        : this(telemetryData.ToDictionary(data => data.RuleId), infrastructureTracingData)
+    { }
+
+    public BuildCheckTracingData()
+        : this(new Dictionary<string, BuildCheckRuleTelemetryData>(), [])
+    { }
+
+    internal BuildCheckTracingData(Dictionary<string, TimeSpan> executionData)
+        : this(new Dictionary<string, BuildCheckRuleTelemetryData>(), executionData)
+    { }
+
+    public Dictionary<string, BuildCheckRuleTelemetryData> TelemetryData { get; private set; } = telemetryData;
+    public Dictionary<string, TimeSpan> InfrastructureTracingData { get; private set; } = infrastructureTracingData;
+
+    /// <summary>
+    /// Gets the runtime stats per individual checks friendly names
+    /// </summary>
+    public Dictionary<string, TimeSpan> ExtractCheckStats() =>
+        // Stats are per rule, while runtime is per check - and check can have multiple rules.
+        // In case of multi-rule check, the runtime stats are duplicated for each rule.
+        TelemetryData
+            .GroupBy(d => d.Value.CheckFriendlyName)
+            .ToDictionary(g => g.Key, g => g.First().Value.TotalRuntime);
+
+    public void MergeIn(BuildCheckTracingData other)
+    {
+        InfrastructureTracingData.Merge(other.InfrastructureTracingData, (span1, span2) => span1 + span2);
+        TelemetryData.Merge(other.TelemetryData, BuildCheckRuleTelemetryData.Merge);
+    }
+}
diff --git a/src/Framework/BuildCheck/DiagnosticSeverity.cs b/src/Framework/BuildCheck/DiagnosticSeverity.cs
new file mode 100644
index 00000000000..025b83faa1b
--- /dev/null
+++ b/src/Framework/BuildCheck/DiagnosticSeverity.cs
@@ -0,0 +1,32 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+internal enum DiagnosticSeverity
+{
+    /// <summary>
+    /// When set, the default value of the BuildCheck rule will be used.
+    /// </summary>
+    Default,
+
+    /// <summary>
+    /// When set to None the rule will not run.
+    /// </summary>
+    None,
+
+    /// <summary>
+    /// Information level message.
+    /// </summary>
+    Suggestion,
+
+    /// <summary>
+    /// Results a warning in build if the BuildCheck rule applied.
+    /// </summary>
+    Warning,
+
+    /// <summary>
+    /// Results an error in build if the BuildCheck rule applied.
+    /// </summary>
+    Error
+}
diff --git a/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs b/src/Framework/BuildCheck/EnumerableExtensions.cs
similarity index 69%
rename from src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
rename to src/Framework/BuildCheck/EnumerableExtensions.cs
index f89f72b0e2c..2ec4f958fca 100644
--- a/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
+++ b/src/Framework/BuildCheck/EnumerableExtensions.cs
@@ -66,4 +66,33 @@ public static void Merge<TKey, TValue>(
             }
         }
     }
+
+    /// <summary>
+    /// Adds a content of given list to current dictionary.
+    /// </summary>
+    /// <typeparam name="TKey"></typeparam>
+    /// <typeparam name="TValue"></typeparam>
+    /// <param name="dict">Dictionary to receive another values.</param>
+    /// <param name="another">List to be merged into current.</param>
+    /// <param name="extractKey">Way of getting a key of an incoming value.</param>
+    /// <param name="mergeValues">Way of resolving keys conflicts.</param>
+    public static void Merge<TKey, TValue>(
+        this IDictionary<TKey, TValue> dict,
+        IReadOnlyList<TValue> another,
+        Func<TValue, TKey> extractKey,
+        Func<TValue, TValue, TValue> mergeValues)
+    {
+        foreach (var mergeValue in another)
+        {
+            TKey key = extractKey(mergeValue);
+            if (!dict.TryGetValue(key, out TValue? value))
+            {
+                dict[key] = mergeValue;
+            }
+            else
+            {
+                dict[key] = mergeValues(value, mergeValue);
+            }
+        }
+    }
 }
diff --git a/src/Framework/BuildException/BuildExceptionBase.cs b/src/Framework/BuildException/BuildExceptionBase.cs
index 07db4994b93..426ad35526b 100644
--- a/src/Framework/BuildException/BuildExceptionBase.cs
+++ b/src/Framework/BuildException/BuildExceptionBase.cs
@@ -127,7 +127,7 @@ internal static Exception ReadExceptionFromTranslator(ITranslator translator)
         string? deserializedStackTrace = reader.ReadOptionalString();
         string? source = reader.ReadOptionalString();
         string? helpLink = reader.ReadOptionalString();
-        int hResult = reader.ReadOptionalInt32();
+        int hResult = reader.ReadOptionalInt32() ?? 0;
 
         IDictionary<string, string?>? customKeyedSerializedData = null;
         if (reader.ReadByte() == 1)
diff --git a/src/Framework/Telemetry/BuildCheckTelemetry.cs b/src/Framework/Telemetry/BuildCheckTelemetry.cs
new file mode 100644
index 00000000000..1c950a0e65c
--- /dev/null
+++ b/src/Framework/Telemetry/BuildCheckTelemetry.cs
@@ -0,0 +1,62 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Framework.Telemetry;
+
+internal class BuildCheckTelemetry
+{
+    internal void AddCustomCheckLoadingFailure()
+    { }
+}
+
+////internal class BuildCheckTelemetry : TelemetryBase
+////{
+////    public override string EventName => "buildcheck";
+
+////    internal void AddCustomCheckLoadingFailure()
+////    {
+
+////    }
+
+////    /// <summary>
+////    /// True if terminal logger was used.
+////    /// </summary>
+////    public bool IsBuildCheckOn { get; set; }
+////    public int RulesCount { get; set; }
+////    public int CustomRulesCount { get; set; }
+////    public int ViolationsCount { get; set; }
+////    public TimeSpan TotalRuntime { get; set; }
+
+
+
+////    public override IDictionary<string, string> GetProperties() => throw new NotImplementedException();
+
+////    internal class BuildCheckRuleTelemetryData
+////    {
+////        public string RuleId { get; set; }
+////        public bool IsBuiltIn { get; set; }
+////        public byte DefaultSeverityId { get; set; }
+////        public string DefaultSeverityName { get; set; }
+////        public int ProjectsCount { get; set; }
+////        public byte? ExplicitSeverityId { get; set; }
+////        public string? ExplicitSeverityName { get; set; }
+////        public int ViolationCount { get; set; }
+////        public bool IsThrottled { get; set; }
+////        public TimeSpan TotalRuntime { get; set; }
+////    }
+
+////    internal class CustomCheckErrorTelemetryData
+////    {
+////        public string RuleId { get; set; }
+////        public string ExceptionType { get; set; }
+////        public string ExceptionMessage { get; set; }
+////    }
+////}
+
+
diff --git a/src/Framework/Telemetry/KnownTelemetry.cs b/src/Framework/Telemetry/KnownTelemetry.cs
index 7685bdda537..e775bce1fe6 100644
--- a/src/Framework/Telemetry/KnownTelemetry.cs
+++ b/src/Framework/Telemetry/KnownTelemetry.cs
@@ -20,4 +20,9 @@ internal static class KnownTelemetry
     /// Describes how logging was configured.
     /// </summary>
     public static LoggingConfigurationTelemetry LoggingConfigurationTelemetry { get; } = new LoggingConfigurationTelemetry();
+
+    /// <summary>
+    /// Describes if and how BuildCheck was used.
+    /// </summary>
+    public static BuildCheckTelemetry BuildCheckTelemetry { get; } = new BuildCheckTelemetry();
 }
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index 822af5c1a96..7990d261f93 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -22,9 +22,9 @@ internal static class BinaryReaderExtensions
 #if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
 #endif
-        public static int ReadOptionalInt32(this BinaryReader reader)
+        public static int? ReadOptionalInt32(this BinaryReader reader)
         {
-            return reader.ReadByte() == 0 ? 0 : reader.ReadInt32();
+            return reader.ReadByte() == 0 ? null : reader.ReadInt32();
         }
 
 #if !TASKHOST
