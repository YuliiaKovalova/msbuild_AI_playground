diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 3f53fc8b1e7..a78e25f2103 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2020,6 +2020,11 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
 
         internal bool CreateRarNode()
         {
+            // If the _buildParametrs is not set, we are in OutOfProc mode, so continue
+            // Else check if users specified that he want to use multiple nodes, if so use RARaaS
+            if (_buildParameters?.MaxNodeCount == 1)
+                return false;
+
             string nodeLocation = _buildParameters?.NodeExeLocation ?? BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
             if (string.IsNullOrEmpty(nodeLocation))
             {
diff --git a/src/Build/BackEnd/Node/RarNode.cs b/src/Build/BackEnd/Node/RarNode.cs
index 2079ee91b8f..6c0ba92f565 100644
--- a/src/Build/BackEnd/Node/RarNode.cs
+++ b/src/Build/BackEnd/Node/RarNode.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.CodeDom;
 using System.Diagnostics;
 using System.IO;
 using System.IO.Pipes;
@@ -42,7 +41,7 @@ public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Except
             Handshake handshake = NodeProviderOutOfProc.GetHandshake(enableNodeReuse: nodeReuse,
                                                                      enableLowPriority: lowPriority, specialNode: true);
 
-            Console.WriteLine(pipeName);
+            CommunicationsUtilities.Trace("RAR node name: {0}", pipeName);
             IRarController controller = GetController(pipeName, handshake);
 
             Task<int> rarTask = controller.StartAsync(cts.Token);
@@ -64,11 +63,6 @@ public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Except
             {
                 return NodeEngineShutdownReason.BuildComplete;
             }
-            catch (Exception e)
-            {
-                shutdownException = e;
-                return NodeEngineShutdownReason.Error;
-            }
 
             cts.Cancel();
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs
index a6172587bd3..2870e1d102b 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs
@@ -1,4 +1,8 @@
-﻿using System;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Data.SqlTypes;
 using System.IO;
 using System.Linq;
 using System.Reflection;
@@ -8,6 +12,7 @@
 using Microsoft.Build.Tasks.ResolveAssemblyReferences;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Client;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;
 using Microsoft.Build.UnitTests;
@@ -27,72 +32,75 @@ public ResolveAssemblyReferenceAsAService_Tests(ITestOutputHelper output) : base
         {
         }
 
-        [Fact]
-        public void EnsureInputPropertiesMatch()
+        [InlineData(typeof(ResolveAssemblyReferenceRequest), false)]
+        [InlineData(typeof(ResolveAssemblyReferenceResponse), true)]
+        [Theory]
+        public void EnsurePropertiesMatch(Type t, bool isOutputProperty)
         {
-            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
-                .Where(p => !p.GetCustomAttributes(typeof(OutputAttribute), inherit: true).Any()).Select(p => p.Name).ToArray();
-            string[] inputProperties = typeof(ResolveAssemblyReferenceRequest).GetProperties().Select(p => p.Name).ToArray();
+            string[] rarProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
+                .Where(p => isOutputProperty == p.GetCustomAttributes(typeof(OutputAttribute), inherit: true).Any()).Select(p => p.Name).ToArray();
+            string[] properties = t.GetProperties().Select(p => p.Name).ToArray();
 
-            foreach (var item in rarInputProperties)
+            foreach (var item in rarProperties)
             {
-                inputProperties.ShouldContain(item);
+                properties.ShouldContain(item);
             }
         }
 
-        [Fact]
-        public void EnsureOutputPropertiesMatch()
+        [InlineData(typeof(ResolveAssemblyReferenceRequest), RequestFormatter.MemberCount)]
+        [InlineData(typeof(ResolveAssemblyReferenceResponse), ResponseFormatter.MemberCount)]
+        [InlineData(typeof(ResolveAssemblyReferenceResult), ResultFormatter.MemberCount)]
+        [Theory]
+        public void FormatterHeaderSizeMatchTest(Type type, int memberCount)
         {
-            string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
-                .Where(p => p.GetCustomAttributes(typeof(OutputAttribute), true).Any()).Select(p => p.Name).ToArray();
-            string[] inputProperties = typeof(ResolveAssemblyReferenceResponse).GetProperties().Select(p => p.Name).ToArray();
+            int propertyCount = type.GetProperties().Length;
 
-            foreach (var item in rarInputProperties)
-            {
-                inputProperties.ShouldContain(item);
-            }
+            propertyCount.ShouldBe(memberCount);
         }
 
-        [Fact]
-        public void TransferredRequestEquals()
+        [InlineData(typeof(ResolveAssemblyReferenceRequest))]
+        [InlineData(typeof(ResolveAssemblyReferenceResponse))]
+        [Theory]
+        public void TransferredObjectsEqual(Type type)
         {
             MessagePackSerializerOptions options = MessagePackSerializerOptions.Standard.WithResolver(ResolveAssemblyReferneceResolver.Instance);
-            ResolveAssemblyReferenceRequest request = GetPopulatedObject<ResolveAssemblyReferenceRequest>("test", new[] { "testArr" }, true, new[] { new ReadOnlyTaskItem("test") });
+            object obj = GetPopulatedObject(type, "test", new[] { "testArr" }, true, new[] { new TaskItem("test") });
 
-            byte[] data = MessagePackSerializer.Serialize(request, options);
-            ResolveAssemblyReferenceRequest requestDes = MessagePackSerializer.Deserialize<ResolveAssemblyReferenceRequest>(data, options);
+            byte[] data = MessagePackSerializer.Serialize(type, obj, options);
+            object objDes = MessagePackSerializer.Deserialize(type, data, options);
 
-            ResolveAssemblyReferenceComparer.CompareInput(request, requestDes).ShouldBeTrue();
-        }
-
-        [Fact]
-        public void TransferredResponseEquals()
-        {
-            MessagePackSerializerOptions options = MessagePackSerializerOptions.Standard.WithResolver(ResolveAssemblyReferneceResolver.Instance);
-            ResolveAssemblyReferenceResponse response = GetPopulatedObject<ResolveAssemblyReferenceResponse>("test", new[] { "testArr" }, true, new[] { new ReadOnlyTaskItem("test") });
+            objDes.ShouldBeOfType(type);
 
-            byte[] data = MessagePackSerializer.Serialize(response, options);
-            ResolveAssemblyReferenceResponse responseDes = MessagePackSerializer.Deserialize<ResolveAssemblyReferenceResponse>(data, options);
-
-            ResolveAssemblyReferenceComparer.CompareOutput(response, responseDes).ShouldBeTrue();
+            if (typeof(ResolveAssemblyReferenceRequest).Equals(type))
+            {
+                ResolveAssemblyReferenceComparer.CompareRequest((ResolveAssemblyReferenceRequest)obj, (ResolveAssemblyReferenceRequest)objDes).ShouldBeTrue();
+            }
+            else if (typeof(ResolveAssemblyReferenceResponse).Equals(type))
+            {
+                ResolveAssemblyReferenceComparer.CompareResponse((ResolveAssemblyReferenceResponse)obj, (ResolveAssemblyReferenceResponse)objDes).ShouldBeTrue();
+            }
+            else
+            {
+                objDes.ShouldBe(obj);
+            }
         }
 
         [Fact]
         public void RarOutputPropertyTest()
         {
-            ResolveAssemblyReferenceResponse expectedResponse = GetPopulatedObject<ResolveAssemblyReferenceResponse>("test", new[] { "testArr" }, true, new[] { new ReadOnlyTaskItem("test") });
+            ResolveAssemblyReferenceResponse expectedResponse = GetPopulatedObject<ResolveAssemblyReferenceResponse>("test", new[] { "testArr" }, true, new[] { new TaskItem("test") });
 
             ResolveAssemblyReference rar = new ResolveAssemblyReference();
             rar.ResolveAssemblyReferenceOutput = expectedResponse;
             ResolveAssemblyReferenceResponse response = rar.ResolveAssemblyReferenceOutput;
 
-            ResolveAssemblyReferenceComparer.CompareOutput(expectedResponse, response).ShouldBeTrue();
+            ResolveAssemblyReferenceComparer.CompareResponse(expectedResponse, response).ShouldBeTrue();
         }
 
         [Fact]
         public void RarIputPropertyTest()
         {
-            ResolveAssemblyReferenceRequest expectedRequest = GetPopulatedObject<ResolveAssemblyReferenceRequest>("test", new[] { "testArr" }, true, new[] { new ReadOnlyTaskItem("test") });
+            ResolveAssemblyReferenceRequest expectedRequest = GetPopulatedObject<ResolveAssemblyReferenceRequest>("test", new[] { "testArr" }, true, new[] { new TaskItem("test") });
             expectedRequest.CurrentPath = Directory.GetCurrentDirectory();
             expectedRequest.WarnOrErrorOnTargetArchitectureMismatch = "None"; // Serialized into enum, so we have to provide correct value
 
@@ -100,7 +108,7 @@ public void RarIputPropertyTest()
             rar.ResolveAssemblyReferenceInput = expectedRequest;
             ResolveAssemblyReferenceRequest request = rar.ResolveAssemblyReferenceInput;
 
-            ResolveAssemblyReferenceComparer.CompareInput(expectedRequest, request).ShouldBeTrue();
+            ResolveAssemblyReferenceComparer.CompareRequest(expectedRequest, request).ShouldBeTrue();
         }
 
 
@@ -134,24 +142,27 @@ public void TransmitDataTest()
             ResolveAssemblyReferenceResult result = client.Execute(rar.ResolveAssemblyReferenceInput);
             cts.Cancel();
 
-            ResolveAssemblyReferenceComparer.CompareOutput(expectedResult.Response, result.Response).ShouldBeTrue();
+            ResolveAssemblyReferenceComparer.CompareResponse(expectedResult.Response, result.Response).ShouldBeTrue();
 
             serverStream.Dispose();
             clientStream.Dispose();
         }
 
-        private T GetPopulatedObject<T>(string str, string[] strArray, bool boolVal, ReadOnlyTaskItem[] taskItems) where T : new()
+        private T GetPopulatedObject<T>(string str, string[] strArray, bool boolVal, ITaskItem[] taskItems) where T : new()
+        {
+            return (T)GetPopulatedObject(typeof(T), str, strArray, boolVal, taskItems);
+        }
+
+        private object GetPopulatedObject(Type type, string str, string[] strArray, bool boolVal, ITaskItem[] taskItems)
         {
             int count = 0;
-            T request = new T();
-            Type t = typeof(T);
-            t.GetConstructor(Type.EmptyTypes).Invoke(null);
-            foreach (var prop in t.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
+            object obj = Activator.CreateInstance(type);
+            foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
             {
                 var propType = prop.PropertyType;
                 if (propType == typeof(string))
                 {
-                    prop.SetValue(request, str + count++);
+                    prop.SetValue(obj, str + count++);
                 }
                 else if (propType == typeof(string[]))
                 {
@@ -160,20 +171,20 @@ public void TransmitDataTest()
                         strArray[0] += count++;
                     }
 
-                    prop.SetValue(request, strArray);
+                    prop.SetValue(obj, strArray);
                 }
                 else if (propType == typeof(bool))
                 {
-                    prop.SetValue(request, boolVal);
+                    prop.SetValue(obj, boolVal);
                 }
-                else if (propType == typeof(ReadOnlyTaskItem[]))
+                else if (propType == typeof(ITaskItem[]))
                 {
                     if (taskItems?.Length > 0 && taskItems[0] != null)
                     {
                         taskItems[0].ItemSpec += count++;
                     }
 
-                    prop.SetValue(request, taskItems);
+                    prop.SetValue(obj, taskItems);
                 }
                 else
                 {
@@ -181,7 +192,7 @@ public void TransmitDataTest()
                     throw new NotImplementedException($"Invalid type: {propType.FullName}");
                 }
             }
-            return request;
+            return obj;
         }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 7b885a76f0a..b5de4c36cd5 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -928,8 +928,8 @@ internal ResolveAssemblyReferenceRequest ResolveAssemblyReferenceInput
                 AllowedAssemblyExtensions = AllowedAssemblyExtensions,
                 AllowedRelatedFileExtensions = AllowedRelatedFileExtensions,
                 AppConfigFile = AppConfigFile,
-                Assemblies = ReadOnlyTaskItem.ToReadOnlyItems(Assemblies),
-                AssemblyFiles = ReadOnlyTaskItem.ToReadOnlyItems(AssemblyFiles),
+                Assemblies = Assemblies,
+                AssemblyFiles = AssemblyFiles,
                 AutoUnify = AutoUnify,
                 CandidateAssemblyFiles = CandidateAssemblyFiles,
                 CopyLocalDependenciesWhenParentReferenceInGac = CopyLocalDependenciesWhenParentReferenceInGac,
@@ -939,18 +939,18 @@ internal ResolveAssemblyReferenceRequest ResolveAssemblyReferenceInput
                 FindRelatedFiles = FindRelatedFiles,
                 FindSatellites = FindSatellites,
                 FindSerializationAssemblies = FindSerializationAssemblies,
-                FullFrameworkAssemblyTables = ReadOnlyTaskItem.ToReadOnlyItems(FullFrameworkAssemblyTables),
+                FullFrameworkAssemblyTables = FullFrameworkAssemblyTables,
                 FullFrameworkFolders = FullFrameworkFolders,
                 FullTargetFrameworkSubsetNames = FullTargetFrameworkSubsetNames,
                 IgnoreDefaultInstalledAssemblySubsetTables = IgnoreDefaultInstalledAssemblySubsetTables,
                 IgnoreDefaultInstalledAssemblyTables = IgnoreDefaultInstalledAssemblyTables,
                 IgnoreTargetFrameworkAttributeVersionMismatch = IgnoreTargetFrameworkAttributeVersionMismatch,
                 IgnoreVersionForFrameworkReferences = IgnoreVersionForFrameworkReferences,
-                InstalledAssemblySubsetTables = ReadOnlyTaskItem.ToReadOnlyItems(InstalledAssemblySubsetTables),
-                InstalledAssemblyTables = ReadOnlyTaskItem.ToReadOnlyItems(InstalledAssemblyTables),
+                InstalledAssemblySubsetTables = InstalledAssemblySubsetTables,
+                InstalledAssemblyTables = InstalledAssemblyTables,
                 LatestTargetFrameworkDirectories = LatestTargetFrameworkDirectories,
                 ProfileName = ProfileName,
-                ResolvedSDKReferences = ReadOnlyTaskItem.ToReadOnlyItems(ResolvedSDKReferences),
+                ResolvedSDKReferences = ResolvedSDKReferences,
                 SearchPaths = SearchPaths,
                 Silent = Silent,
                 StateFile = StateFile,
@@ -966,7 +966,7 @@ internal ResolveAssemblyReferenceRequest ResolveAssemblyReferenceInput
                 UseResolveAssemblyReferenceService = UseResolveAssemblyReferenceService,
                 WarnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatch,
                 AssemblyInformationCacheOutputPath = AssemblyInformationCacheOutputPath,
-                AssemblyInformationCachePaths = ReadOnlyTaskItem.ToReadOnlyItems(AssemblyInformationCachePaths),
+                AssemblyInformationCachePaths = AssemblyInformationCachePaths,
                 CurrentPath = Directory.GetCurrentDirectory()
             };
             set
@@ -974,8 +974,8 @@ internal ResolveAssemblyReferenceRequest ResolveAssemblyReferenceInput
                 AllowedAssemblyExtensions = value.AllowedAssemblyExtensions;
                 AllowedRelatedFileExtensions = value.AllowedRelatedFileExtensions;
                 AppConfigFile = value.AppConfigFile;
-                Assemblies = ReadOnlyTaskItem.ToTaskItems(value.Assemblies);
-                AssemblyFiles = ReadOnlyTaskItem.ToTaskItems(value.AssemblyFiles);
+                Assemblies = value.Assemblies;
+                AssemblyFiles = value.AssemblyFiles;
                 AutoUnify = value.AutoUnify;
                 CandidateAssemblyFiles = value.CandidateAssemblyFiles;
                 CopyLocalDependenciesWhenParentReferenceInGac = value.CopyLocalDependenciesWhenParentReferenceInGac;
@@ -985,18 +985,18 @@ internal ResolveAssemblyReferenceRequest ResolveAssemblyReferenceInput
                 FindRelatedFiles = value.FindRelatedFiles;
                 FindSatellites = value.FindSatellites;
                 FindSerializationAssemblies = value.FindSerializationAssemblies;
-                FullFrameworkAssemblyTables = ReadOnlyTaskItem.ToTaskItems(value.FullFrameworkAssemblyTables);
+                FullFrameworkAssemblyTables = value.FullFrameworkAssemblyTables;
                 FullFrameworkFolders = value.FullFrameworkFolders;
                 FullTargetFrameworkSubsetNames = value.FullTargetFrameworkSubsetNames;
                 IgnoreDefaultInstalledAssemblySubsetTables = value.IgnoreDefaultInstalledAssemblySubsetTables;
                 IgnoreDefaultInstalledAssemblyTables = value.IgnoreDefaultInstalledAssemblyTables;
                 IgnoreTargetFrameworkAttributeVersionMismatch = value.IgnoreTargetFrameworkAttributeVersionMismatch;
                 IgnoreVersionForFrameworkReferences = value.IgnoreVersionForFrameworkReferences;
-                InstalledAssemblySubsetTables = ReadOnlyTaskItem.ToTaskItems(value.InstalledAssemblySubsetTables);
-                InstalledAssemblyTables = ReadOnlyTaskItem.ToTaskItems(value.InstalledAssemblyTables);
+                InstalledAssemblySubsetTables = value.InstalledAssemblySubsetTables;
+                InstalledAssemblyTables = value.InstalledAssemblyTables;
                 LatestTargetFrameworkDirectories = value.LatestTargetFrameworkDirectories;
                 ProfileName = value.ProfileName;
-                ResolvedSDKReferences = ReadOnlyTaskItem.ToTaskItems(value.ResolvedSDKReferences);
+                ResolvedSDKReferences = value.ResolvedSDKReferences;
                 SearchPaths = value.SearchPaths;
                 Silent = value.Silent;
                 StateFile = value.StateFile;
@@ -1012,7 +1012,7 @@ internal ResolveAssemblyReferenceRequest ResolveAssemblyReferenceInput
                 UseResolveAssemblyReferenceService = value.UseResolveAssemblyReferenceService;
                 WarnOrErrorOnTargetArchitectureMismatch = value.WarnOrErrorOnTargetArchitectureMismatch;
                 AssemblyInformationCacheOutputPath = value.AssemblyInformationCacheOutputPath;
-                AssemblyInformationCachePaths = ReadOnlyTaskItem.ToTaskItems(value.AssemblyInformationCachePaths);
+                AssemblyInformationCachePaths = value.AssemblyInformationCachePaths;
             }
         }
 
@@ -1020,31 +1020,31 @@ internal ResolveAssemblyReferenceResponse ResolveAssemblyReferenceOutput
         {
             get => new ResolveAssemblyReferenceResponse
             {
-                CopyLocalFiles = ReadOnlyTaskItem.ToReadOnlyItems(CopyLocalFiles),
+                CopyLocalFiles = CopyLocalFiles,
                 DependsOnNETStandard = DependsOnNETStandard,
                 DependsOnSystemRuntime = DependsOnSystemRuntime,
-                FilesWritten = ReadOnlyTaskItem.ToReadOnlyItems(FilesWritten),
-                RelatedFiles = ReadOnlyTaskItem.ToReadOnlyItems(RelatedFiles),
-                ResolvedDependencyFiles = ReadOnlyTaskItem.ToReadOnlyItems(ResolvedDependencyFiles),
-                ResolvedFiles = ReadOnlyTaskItem.ToReadOnlyItems(ResolvedFiles),
-                SatelliteFiles = ReadOnlyTaskItem.ToReadOnlyItems(SatelliteFiles),
-                ScatterFiles = ReadOnlyTaskItem.ToReadOnlyItems(ScatterFiles),
-                SerializationAssemblyFiles = ReadOnlyTaskItem.ToReadOnlyItems(SerializationAssemblyFiles),
-                SuggestedRedirects = ReadOnlyTaskItem.ToReadOnlyItems(SuggestedRedirects),
+                FilesWritten = FilesWritten,
+                RelatedFiles = RelatedFiles,
+                ResolvedDependencyFiles = ResolvedDependencyFiles,
+                ResolvedFiles = ResolvedFiles,
+                SatelliteFiles = SatelliteFiles,
+                ScatterFiles = ScatterFiles,
+                SerializationAssemblyFiles = SerializationAssemblyFiles,
+                SuggestedRedirects = SuggestedRedirects,
             };
             set
             {
-                _copyLocalFiles = ReadOnlyTaskItem.ToTaskItems(value.CopyLocalFiles);
+                _copyLocalFiles = value.CopyLocalFiles;
                 DependsOnNETStandard = value.DependsOnNETStandard;
                 DependsOnSystemRuntime = value.DependsOnSystemRuntime;
-                _filesWritten = new List<ITaskItem>(ReadOnlyTaskItem.ToTaskItems(value.FilesWritten));
-                _relatedFiles = ReadOnlyTaskItem.ToTaskItems(value.RelatedFiles);
-                _resolvedDependencyFiles =  ReadOnlyTaskItem.ToTaskItems(value.ResolvedDependencyFiles);
-                _resolvedFiles =  ReadOnlyTaskItem.ToTaskItems(value.ResolvedFiles);
-                _satelliteFiles =  ReadOnlyTaskItem.ToTaskItems(value.SatelliteFiles);
-                _scatterFiles =  ReadOnlyTaskItem.ToTaskItems(value.ScatterFiles);
-                _serializationAssemblyFiles =  ReadOnlyTaskItem.ToTaskItems(value.SerializationAssemblyFiles);
-                _suggestedRedirects =  ReadOnlyTaskItem.ToTaskItems(value.SuggestedRedirects);
+                _filesWritten = new List<ITaskItem>(value.FilesWritten);
+                _relatedFiles = value.RelatedFiles;
+                _resolvedDependencyFiles =  value.ResolvedDependencyFiles;
+                _resolvedFiles =  value.ResolvedFiles;
+                _satelliteFiles =  value.SatelliteFiles;
+                _scatterFiles =  value.ScatterFiles;
+                _serializationAssemblyFiles =  value.SerializationAssemblyFiles;
+                _suggestedRedirects =  value.SuggestedRedirects;
             }
         }
 
@@ -3160,10 +3160,6 @@ public override bool Execute()
                     LogEvents(result.BuildEvents);
                     return result.TaskResult;
                 }
-                else
-                {
-                    ErrorUtilities.ThrowInternalError(UseResolveAssemblyReferenceService.ToString());
-                }
             }
 
             return Execute
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 2d9656c249b..c189068f77e 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -351,11 +351,10 @@
     <Compile Include="ResolveAssemblyReferences\Client\RarClient.cs" />
     <Compile Include="ResolveAssemblyReferences\Contract\IResolveAssemblyReferenceTaskHandler.cs" />
     <Compile Include="ResolveAssemblyReferences\Contract\ResolveAssemblyReferenceResult.cs" />
-    <Compile Include="ResolveAssemblyReferences\Contract\ReadOnlyTaskItem.cs" />
     <Compile Include="ResolveAssemblyReferences\Contract\ResolveAssemblyReferenceRequest.cs" />
     <Compile Include="ResolveAssemblyReferences\Contract\ResolveAssemblyReferenceResponse.cs" />
     <Compile Include="ResolveAssemblyReferences\Formatters\BuildEventArgsFormatter.cs" />
-    <Compile Include="ResolveAssemblyReferences\Formatters\ReadOnlyTaskItemFormatter.cs" />
+    <Compile Include="ResolveAssemblyReferences\Formatters\TaskItemFormatter.cs" />
     <Compile Include="ResolveAssemblyReferences\Formatters\RequestFormatter.cs" />
     <Compile Include="ResolveAssemblyReferences\Formatters\ResponseFormatter.cs" />
     <Compile Include="ResolveAssemblyReferences\Formatters\ResultFormatter.cs" />
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs
deleted file mode 100644
index 69daa6edba6..00000000000
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs
+++ /dev/null
@@ -1,91 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System.Collections;
-using System.Collections.Generic;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
-
-namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
-{
-    internal sealed class ReadOnlyTaskItem
-    {
-        public string ItemSpec { get; set; }
-
-        public Dictionary<string, string> MetadataNameToValue { get; set; }
-
-        public ReadOnlyTaskItem(string itemSpec)
-        {
-            ItemSpec = itemSpec;
-            MetadataNameToValue = new Dictionary<string, string>();
-        }
-
-        public ReadOnlyTaskItem(string itemSpec, IDictionary metadata)
-        {
-            ItemSpec = itemSpec;
-
-            if (metadata is Dictionary<string, string> metadataNameToValue)
-            {
-                MetadataNameToValue = metadataNameToValue;
-            }
-            else if (metadata is IDictionary<string, string> metadataByInterface)
-            {
-                MetadataNameToValue = new Dictionary<string, string>(metadataByInterface);
-            }
-            else
-            {
-                if (metadata.Count > 0)
-                {
-                    MetadataNameToValue = new Dictionary<string, string>();
-
-                    foreach (DictionaryEntry singleMetadata in metadata)
-                    {
-                        string key = (string)singleMetadata.Key;
-                        if (key == null)
-                        {
-                            return;
-                        }
-
-                        MetadataNameToValue[key] = (string)singleMetadata.Value ?? string.Empty;
-                    }
-                }
-            }
-        }
-
-        internal static ReadOnlyTaskItem[] ToReadOnlyItems(ITaskItem[] items)
-        {
-            if (items == null)
-                return null;
-
-            ReadOnlyTaskItem[] readOnlyTaskItems = new ReadOnlyTaskItem[items.Length];
-            for (int i = 0; i < items.Length; i++)
-            {
-                if (items[i] == null)
-                    continue;
-
-                ReadOnlyTaskItem readOnlyTaskItem = new ReadOnlyTaskItem(items[i].ItemSpec, items[i].CloneCustomMetadata());
-                readOnlyTaskItems[i] = readOnlyTaskItem;
-            }
-
-            return readOnlyTaskItems;
-        }
-
-        internal static ITaskItem[] ToTaskItems(ReadOnlyTaskItem[] readOnlyTaskItems)
-        {
-            if (readOnlyTaskItems == null)
-                return null;
-
-            ITaskItem[] items = new ITaskItem[readOnlyTaskItems.Length];
-            for (int i = 0; i < items.Length; i++)
-            {
-                if (readOnlyTaskItems[i] == null)
-                    continue;
-
-                TaskItem item = new TaskItem(readOnlyTaskItems[i].ItemSpec, readOnlyTaskItems[i].MetadataNameToValue);
-                items[i] = item;
-            }
-
-            return items;
-        }
-    }
-}
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
index 148218cf76c..d81a883faea 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
+
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
     internal sealed class ResolveAssemblyReferenceRequest
@@ -13,9 +15,9 @@ public ResolveAssemblyReferenceRequest() { }
 
         public string AppConfigFile { get; set; }
 
-        public ReadOnlyTaskItem[] Assemblies { get; set; }
+        public ITaskItem[] Assemblies { get; set; }
 
-        public ReadOnlyTaskItem[] AssemblyFiles { get; set; }
+        public ITaskItem[] AssemblyFiles { get; set; }
 
         public bool AutoUnify { get; set; }
 
@@ -35,7 +37,7 @@ public ResolveAssemblyReferenceRequest() { }
 
         public bool FindSerializationAssemblies { get; set; }
 
-        public ReadOnlyTaskItem[] FullFrameworkAssemblyTables { get; set; }
+        public ITaskItem[] FullFrameworkAssemblyTables { get; set; }
 
         public string[] FullFrameworkFolders { get; set; }
 
@@ -49,15 +51,15 @@ public ResolveAssemblyReferenceRequest() { }
 
         public bool IgnoreVersionForFrameworkReferences { get; set; }
 
-        public ReadOnlyTaskItem[] InstalledAssemblySubsetTables { get; set; }
+        public ITaskItem[] InstalledAssemblySubsetTables { get; set; }
 
-        public ReadOnlyTaskItem[] InstalledAssemblyTables { get; set; }
+        public ITaskItem[] InstalledAssemblyTables { get; set; }
 
         public string[] LatestTargetFrameworkDirectories { get; set; }
 
         public string ProfileName { get; set; }
 
-        public ReadOnlyTaskItem[] ResolvedSDKReferences { get; set; }
+        public ITaskItem[] ResolvedSDKReferences { get; set; }
 
         public string[] SearchPaths { get; set; }
 
@@ -91,6 +93,6 @@ public ResolveAssemblyReferenceRequest() { }
 
         public string AssemblyInformationCacheOutputPath { get; set; }
 
-        public ReadOnlyTaskItem[] AssemblyInformationCachePaths { get; set; }
+        public ITaskItem[] AssemblyInformationCachePaths { get; set; }
     }
 }
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
index 64f369864b0..b0f7afa35c2 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
+
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
     internal sealed class ResolveAssemblyReferenceResponse
@@ -9,26 +11,26 @@ public ResolveAssemblyReferenceResponse()
         {
         }
 
-        public ReadOnlyTaskItem[] CopyLocalFiles { get; set; }
+        public ITaskItem[] CopyLocalFiles { get; set; }
 
         public string DependsOnNETStandard { get; set; }
 
         public string DependsOnSystemRuntime { get; set; }
 
-        public ReadOnlyTaskItem[] FilesWritten { get; set; }
+        public ITaskItem[] FilesWritten { get; set; }
 
-        public ReadOnlyTaskItem[] RelatedFiles { get; set; }
+        public ITaskItem[] RelatedFiles { get; set; }
 
-        public ReadOnlyTaskItem[] ResolvedDependencyFiles { get; set; }
+        public ITaskItem[] ResolvedDependencyFiles { get; set; }
 
-        public ReadOnlyTaskItem[] ResolvedFiles { get; set; }
+        public ITaskItem[] ResolvedFiles { get; set; }
 
-        public ReadOnlyTaskItem[] SatelliteFiles { get; set; }
+        public ITaskItem[] SatelliteFiles { get; set; }
 
-        public ReadOnlyTaskItem[] ScatterFiles { get; set; }
+        public ITaskItem[] ScatterFiles { get; set; }
 
-        public ReadOnlyTaskItem[] SerializationAssemblyFiles { get; set; }
+        public ITaskItem[] SerializationAssemblyFiles { get; set; }
 
-        public ReadOnlyTaskItem[] SuggestedRedirects { get; set; }
+        public ITaskItem[] SuggestedRedirects { get; set; }
     }
 }
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/BuildEventArgsFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/BuildEventArgsFormatter.cs
index 02272e30cc4..0ce77d6f548 100644
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/BuildEventArgsFormatter.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/BuildEventArgsFormatter.cs
@@ -26,58 +26,17 @@ BuildWarningEventArgs IMessagePackFormatter<BuildWarningEventArgs>.Deserialize(r
             }
 
             options.Security.DepthStep(ref reader);
-            int length = reader.ReadArrayHeader();
-            string message = null;
-            string helpKeyword = null;
-            string senderName = null;
-            int columnNumber = default;
-            int endColumnNumber = default;
-            int endLineNumber = default;
-            int lineNumber = default;
-            string code = default;
-            string file = default;
-            string subCategory = default;
-
-            for (int key = 0; key < length; key++)
-            {
-                switch (key)
-                {
-                    case 0:
-                        message = reader.ReadString();
-                        break;
-                    case 1:
-                        helpKeyword = reader.ReadString();
-                        break;
-                    case 2:
-                        senderName = reader.ReadString();
-                        break;
-                    case 3:
-                        columnNumber = reader.ReadInt32();
-                        break;
-                    case 4:
-                        endColumnNumber = reader.ReadInt32();
-                        break;
-                    case 5:
-                        endLineNumber = reader.ReadInt32();
-                        break;
-                    case 6:
-                        lineNumber = reader.ReadInt32();
-                        break;
-                    case 7:
-                        code = reader.ReadString();
-                        break;
-                    case 8:
-                        file = reader.ReadString();
-                        break;
-                    case 9:
-                        subCategory = reader.ReadString();
-                        break;
-                    default:
-                        reader.Skip();
-                        break;
-                }
-            }
-
+            _ = reader.ReadArrayHeader();
+            string message = reader.ReadString();
+            string helpKeyword = reader.ReadString();
+            string senderName = reader.ReadString();
+            int columnNumber = reader.ReadInt32();
+            int endColumnNumber = reader.ReadInt32();
+            int endLineNumber = reader.ReadInt32();
+            int lineNumber = reader.ReadInt32();
+            string code = reader.ReadString();
+            string file = reader.ReadString();
+            string subCategory = reader.ReadString();
 
             BuildWarningEventArgs buildEvent =
                 new BuildWarningEventArgs(
@@ -128,57 +87,17 @@ BuildErrorEventArgs IMessagePackFormatter<BuildErrorEventArgs>.Deserialize(ref M
             }
 
             options.Security.DepthStep(ref reader);
-            int length = reader.ReadArrayHeader();
-            string message = null;
-            string helpKeyword = null;
-            string senderName = null;
-            int columnNumber = default;
-            int endColumnNumber = default;
-            int endLineNumber = default;
-            int lineNumber = default;
-            string code = default;
-            string file = default;
-            string subCategory = default;
-
-            for (int key = 0; key < length; key++)
-            {
-                switch (key)
-                {
-                    case 0:
-                        message = reader.ReadString();
-                        break;
-                    case 1:
-                        helpKeyword = reader.ReadString();
-                        break;
-                    case 2:
-                        senderName = reader.ReadString();
-                        break;
-                    case 3:
-                        columnNumber = reader.ReadInt32();
-                        break;
-                    case 4:
-                        endColumnNumber = reader.ReadInt32();
-                        break;
-                    case 5:
-                        endLineNumber = reader.ReadInt32();
-                        break;
-                    case 6:
-                        lineNumber = reader.ReadInt32();
-                        break;
-                    case 7:
-                        code = reader.ReadString();
-                        break;
-                    case 8:
-                        file = reader.ReadString();
-                        break;
-                    case 9:
-                        subCategory = reader.ReadString();
-                        break;
-                    default:
-                        reader.Skip();
-                        break;
-                }
-            }
+            _ = reader.ReadArrayHeader();
+            string message = reader.ReadString();
+            string helpKeyword = reader.ReadString();
+            string senderName = reader.ReadString();
+            int columnNumber = reader.ReadInt32();
+            int endColumnNumber = reader.ReadInt32();
+            int endLineNumber = reader.ReadInt32();
+            int lineNumber = reader.ReadInt32();
+            string code = reader.ReadString();
+            string file = reader.ReadString();
+            string subCategory = reader.ReadString();
 
             BuildErrorEventArgs buildEvent =
                 new BuildErrorEventArgs(
@@ -228,61 +147,18 @@ BuildMessageEventArgs IMessagePackFormatter<BuildMessageEventArgs>.Deserialize(r
             }
 
             options.Security.DepthStep(ref reader);
-            int length = reader.ReadArrayHeader();
-            string message = null;
-            string helpKeyword = null;
-            string senderName = null;
-            int columnNumber = default;
-            int endColumnNumber = default;
-            int endLineNumber = default;
-            int lineNumber = default;
-            string code = default;
-            string file = default;
-            string subCategory = default;
-            int importance = default;
-
-            for (int key = 0; key < length; key++)
-            {
-                switch (key)
-                {
-                    case 0:
-                        message = reader.ReadString();
-                        break;
-                    case 1:
-                        helpKeyword = reader.ReadString();
-                        break;
-                    case 2:
-                        senderName = reader.ReadString();
-                        break;
-                    case 3:
-                        columnNumber = reader.ReadInt32();
-                        break;
-                    case 4:
-                        endColumnNumber = reader.ReadInt32();
-                        break;
-                    case 5:
-                        endLineNumber = reader.ReadInt32();
-                        break;
-                    case 6:
-                        lineNumber = reader.ReadInt32();
-                        break;
-                    case 7:
-                        code = reader.ReadString();
-                        break;
-                    case 8:
-                        file = reader.ReadString();
-                        break;
-                    case 9:
-                        subCategory = reader.ReadString();
-                        break;
-                    case 10:
-                        importance = reader.ReadInt32();
-                        break;
-                    default:
-                        reader.Skip();
-                        break;
-                }
-            }
+            _ = reader.ReadArrayHeader();
+            string message = reader.ReadString();
+            string helpKeyword = reader.ReadString();
+            string senderName = reader.ReadString();
+            int columnNumber = reader.ReadInt32();
+            int endColumnNumber = reader.ReadInt32();
+            int endLineNumber = reader.ReadInt32();
+            int lineNumber = reader.ReadInt32();
+            string code = reader.ReadString();
+            string file = reader.ReadString();
+            string subCategory = reader.ReadString();
+            int importance = reader.ReadInt32();
 
             BuildMessageEventArgs buildEvent =
                new BuildMessageEventArgs(
@@ -297,6 +173,7 @@ BuildMessageEventArgs IMessagePackFormatter<BuildMessageEventArgs>.Deserialize(r
                        helpKeyword,
                        senderName,
                        (MessageImportance)importance);
+
             reader.Depth--;
 
             return buildEvent;
@@ -388,37 +265,12 @@ ExternalProjectStartedEventArgs IMessagePackFormatter<ExternalProjectStartedEven
             }
 
             options.Security.DepthStep(ref reader);
-            int length = reader.ReadArrayHeader();
-            string message = null;
-            string helpKeyword = null;
-            string senderName = null;
-            string projectFile = default;
-            string targetNames = default;
-
-            for (int key = 0; key < length; key++)
-            {
-                switch (key)
-                {
-                    case 0:
-                        message = reader.ReadString();
-                        break;
-                    case 1:
-                        helpKeyword = reader.ReadString();
-                        break;
-                    case 2:
-                        senderName = reader.ReadString();
-                        break;
-                    case 3:
-                        projectFile = reader.ReadString();
-                        break;
-                    case 4:
-                        targetNames = reader.ReadString();
-                        break;
-                    default:
-                        reader.Skip();
-                        break;
-                }
-            }
+            _ = reader.ReadArrayHeader();
+            string message = reader.ReadString();
+            string helpKeyword = reader.ReadString();
+            string senderName = reader.ReadString();
+            string projectFile = reader.ReadString();
+            string targetNames = reader.ReadString();
 
             ExternalProjectStartedEventArgs buildEvent =
                new ExternalProjectStartedEventArgs(
@@ -456,37 +308,12 @@ ExternalProjectFinishedEventArgs IMessagePackFormatter<ExternalProjectFinishedEv
             }
 
             options.Security.DepthStep(ref reader);
-            int length = reader.ReadArrayHeader();
-            string message = null;
-            string helpKeyword = null;
-            string senderName = null;
-            string projectFile = default;
-            bool succeeded = default;
-
-            for (int key = 0; key < length; key++)
-            {
-                switch (key)
-                {
-                    case 0:
-                        message = reader.ReadString();
-                        break;
-                    case 1:
-                        helpKeyword = reader.ReadString();
-                        break;
-                    case 2:
-                        senderName = reader.ReadString();
-                        break;
-                    case 3:
-                        projectFile = reader.ReadString();
-                        break;
-                    case 4:
-                        succeeded = reader.ReadBoolean();
-                        break;
-                    default:
-                        reader.Skip();
-                        break;
-                }
-            }
+            _ = reader.ReadArrayHeader();
+            string message = reader.ReadString();
+            string helpKeyword = reader.ReadString();
+            string senderName = reader.ReadString();
+            string projectFile = reader.ReadString();
+            bool succeeded = reader.ReadBoolean();
 
             ExternalProjectFinishedEventArgs buildEvent =
                new ExternalProjectFinishedEventArgs(
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs
deleted file mode 100644
index 049208e0619..00000000000
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System.Collections.Generic;
-using MessagePack;
-using MessagePack.Formatters;
-using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
-
-namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
-{
-    internal sealed class ReadOnlyTaskItemFormatter : IMessagePackFormatter<ReadOnlyTaskItem>
-    {
-        public void Serialize(ref MessagePackWriter writer, ReadOnlyTaskItem value, MessagePackSerializerOptions options)
-        {
-            if (value == null)
-            {
-                writer.WriteNil();
-                return;
-            }
-
-            IFormatterResolver formatterResolver = options.Resolver;
-            writer.WriteArrayHeader(2);
-            writer.Write(value.ItemSpec);
-            formatterResolver.GetFormatter<Dictionary<string, string>>().Serialize(ref writer, value.MetadataNameToValue, options);
-        }
-
-        public ReadOnlyTaskItem Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
-        {
-            if (reader.TryReadNil())
-            {
-                return null;
-            }
-
-            options.Security.DepthStep(ref reader);
-            IFormatterResolver formatterResolver = options.Resolver;
-            int length = reader.ReadArrayHeader();
-            string itemSpec = null;
-            Dictionary<string, string> metadataNameToValue = null;
-
-            for (int i = 0; i < length; i++)
-            {
-                var key = i;
-
-                switch (key)
-                {
-                    case 0:
-                        itemSpec = reader.ReadString();
-                        break;
-                    case 1:
-                        metadataNameToValue = formatterResolver.GetFormatter<Dictionary<string, string>>().Deserialize(ref reader, options);
-                        break;
-                    default:
-                        reader.Skip();
-                        break;
-                }
-            }
-
-            ReadOnlyTaskItem result = new ReadOnlyTaskItem(itemSpec)
-            {
-                MetadataNameToValue = metadataNameToValue
-            };
-            reader.Depth--;
-            return result;
-        }
-    }
-}
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/RequestFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/RequestFormatter.cs
index d25304f64cc..e4509f8d112 100644
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/RequestFormatter.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/RequestFormatter.cs
@@ -3,12 +3,15 @@
 
 using MessagePack;
 using MessagePack.Formatters;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
 {
     internal sealed class RequestFormatter : IMessagePackFormatter<ResolveAssemblyReferenceRequest>
     {
+        internal const int MemberCount = 43;
+
         public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceRequest value, MessagePackSerializerOptions options)
         {
             if (value == null)
@@ -18,12 +21,12 @@ public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceRequ
             }
 
             IFormatterResolver formatterResolver = options.Resolver;
-            writer.WriteArrayHeader(43);
+            writer.WriteArrayHeader(MemberCount);
             formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.AllowedAssemblyExtensions, options);
             formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.AllowedRelatedFileExtensions, options);
             writer.Write(value.AppConfigFile);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.Assemblies, options);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.AssemblyFiles, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.Assemblies, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.AssemblyFiles, options);
             writer.Write(value.AutoUnify);
             formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.CandidateAssemblyFiles, options);
             writer.Write(value.CopyLocalDependenciesWhenParentReferenceInGac);
@@ -33,18 +36,18 @@ public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceRequ
             writer.Write(value.FindRelatedFiles);
             writer.Write(value.FindSatellites);
             writer.Write(value.FindSerializationAssemblies);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.FullFrameworkAssemblyTables, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.FullFrameworkAssemblyTables, options);
             formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.FullFrameworkFolders, options);
             formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.FullTargetFrameworkSubsetNames, options);
             writer.Write(value.IgnoreDefaultInstalledAssemblySubsetTables);
             writer.Write(value.IgnoreDefaultInstalledAssemblyTables);
             writer.Write(value.IgnoreTargetFrameworkAttributeVersionMismatch);
             writer.Write(value.IgnoreVersionForFrameworkReferences);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.InstalledAssemblySubsetTables, options);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.InstalledAssemblyTables, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.InstalledAssemblySubsetTables, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.InstalledAssemblyTables, options);
             formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.LatestTargetFrameworkDirectories, options);
             writer.Write(value.ProfileName);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.ResolvedSDKReferences, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.ResolvedSDKReferences, options);
             formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.SearchPaths, options);
             writer.Write(value.Silent);
             writer.Write(value.StateFile);
@@ -61,7 +64,7 @@ public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceRequ
             writer.Write(value.WarnOrErrorOnTargetArchitectureMismatch);
             writer.Write(value.CurrentPath);
             writer.Write(value.AssemblyInformationCacheOutputPath);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.AssemblyInformationCachePaths, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.AssemblyInformationCachePaths, options);
         }
 
         public ResolveAssemblyReferenceRequest Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
@@ -73,149 +76,52 @@ public ResolveAssemblyReferenceRequest Deserialize(ref MessagePackReader reader,
 
             options.Security.DepthStep(ref reader);
             IFormatterResolver formatterResolver = options.Resolver;
-            int length = reader.ReadArrayHeader();
+            int _ = reader.ReadArrayHeader(); // Content starts with this
             ResolveAssemblyReferenceRequest result = new ResolveAssemblyReferenceRequest();
 
-            for (int i = 0; i < length; i++)
-            {
-                int key = i;
-
-                switch (key)
-                {
-                    case 0:
-                        result.AllowedAssemblyExtensions = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 1:
-                        result.AllowedRelatedFileExtensions = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 2:
-                        result.AppConfigFile = reader.ReadString();
-                        break;
-                    case 3:
-                        result.Assemblies = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 4:
-                        result.AssemblyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 5:
-                        result.AutoUnify = reader.ReadBoolean();
-                        break;
-                    case 6:
-                        result.CandidateAssemblyFiles = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 7:
-                        result.CopyLocalDependenciesWhenParentReferenceInGac = reader.ReadBoolean();
-                        break;
-                    case 8:
-                        result.DoNotCopyLocalIfInGac = reader.ReadBoolean();
-                        break;
-                    case 9:
-                        result.FindDependencies = reader.ReadBoolean();
-                        break;
-                    case 10:
-                        result.FindDependenciesOfExternallyResolvedReferences = reader.ReadBoolean();
-                        break;
-                    case 11:
-                        result.FindRelatedFiles = reader.ReadBoolean();
-                        break;
-                    case 12:
-                        result.FindSatellites = reader.ReadBoolean();
-                        break;
-                    case 13:
-                        result.FindSerializationAssemblies = reader.ReadBoolean();
-                        break;
-                    case 14:
-                        result.FullFrameworkAssemblyTables = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 15:
-                        result.FullFrameworkFolders = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 16:
-                        result.FullTargetFrameworkSubsetNames = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 17:
-                        result.IgnoreDefaultInstalledAssemblySubsetTables = reader.ReadBoolean();
-                        break;
-                    case 18:
-                        result.IgnoreDefaultInstalledAssemblyTables = reader.ReadBoolean();
-                        break;
-                    case 19:
-                        result.IgnoreTargetFrameworkAttributeVersionMismatch = reader.ReadBoolean();
-                        break;
-                    case 20:
-                        result.IgnoreVersionForFrameworkReferences = reader.ReadBoolean();
-                        break;
-                    case 21:
-                        result.InstalledAssemblySubsetTables = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 22:
-                        result.InstalledAssemblyTables = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 23:
-                        result.LatestTargetFrameworkDirectories = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 24:
-                        result.ProfileName = reader.ReadString();
-                        break;
-                    case 25:
-                        result.ResolvedSDKReferences = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 26:
-                        result.SearchPaths = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 27:
-                        result.Silent = reader.ReadBoolean();
-                        break;
-                    case 28:
-                        result.StateFile = reader.ReadString();
-                        break;
-                    case 29:
-                        result.SupportsBindingRedirectGeneration = reader.ReadBoolean();
-                        break;
-                    case 30:
-                        result.TargetedRuntimeVersion = reader.ReadString();
-                        break;
-                    case 31:
-                        result.TargetFrameworkDirectories = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 32:
-                        result.TargetFrameworkMoniker = reader.ReadString();
-                        break;
-                    case 33:
-                        result.TargetFrameworkMonikerDisplayName = reader.ReadString();
-                        break;
-                    case 34:
-                        result.TargetFrameworkSubsets = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 35:
-                        result.TargetFrameworkVersion = reader.ReadString();
-                        break;
-                    case 36:
-                        result.TargetProcessorArchitecture = reader.ReadString();
-                        break;
-                    case 37:
-                        result.UnresolveFrameworkAssembliesFromHigherFrameworks = reader.ReadBoolean();
-                        break;
-                    case 38:
-                        result.UseResolveAssemblyReferenceService = reader.ReadBoolean();
-                        break;
-                    case 39:
-                        result.WarnOrErrorOnTargetArchitectureMismatch = reader.ReadString();
-                        break;
-                    case 40:
-                        result.CurrentPath = reader.ReadString();
-                        break;
-                    case 41:
-                        result.AssemblyInformationCacheOutputPath = reader.ReadString();
-                        break;
-                    case 42:
-                        result.AssemblyInformationCachePaths = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    default:
-                        reader.Skip();
-                        break;
-                }
-            }
+            result.AllowedAssemblyExtensions = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+            result.AllowedRelatedFileExtensions = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+            result.AppConfigFile = reader.ReadString();
+            result.Assemblies = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.AssemblyFiles = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.AutoUnify = reader.ReadBoolean();
+            result.CandidateAssemblyFiles = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+            result.CopyLocalDependenciesWhenParentReferenceInGac = reader.ReadBoolean();
+            result.DoNotCopyLocalIfInGac = reader.ReadBoolean();
+            result.FindDependencies = reader.ReadBoolean();
+            result.FindDependenciesOfExternallyResolvedReferences = reader.ReadBoolean();
+            result.FindRelatedFiles = reader.ReadBoolean();
+            result.FindSatellites = reader.ReadBoolean();
+            result.FindSerializationAssemblies = reader.ReadBoolean();
+            result.FullFrameworkAssemblyTables = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.FullFrameworkFolders = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+            result.FullTargetFrameworkSubsetNames = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+            result.IgnoreDefaultInstalledAssemblySubsetTables = reader.ReadBoolean();
+            result.IgnoreDefaultInstalledAssemblyTables = reader.ReadBoolean();
+            result.IgnoreTargetFrameworkAttributeVersionMismatch = reader.ReadBoolean();
+            result.IgnoreVersionForFrameworkReferences = reader.ReadBoolean();
+            result.InstalledAssemblySubsetTables = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.InstalledAssemblyTables = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.LatestTargetFrameworkDirectories = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+            result.ProfileName = reader.ReadString();
+            result.ResolvedSDKReferences = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.SearchPaths = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+            result.Silent = reader.ReadBoolean();
+            result.StateFile = reader.ReadString();
+            result.SupportsBindingRedirectGeneration = reader.ReadBoolean();
+            result.TargetedRuntimeVersion = reader.ReadString();
+            result.TargetFrameworkDirectories = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+            result.TargetFrameworkMoniker = reader.ReadString();
+            result.TargetFrameworkMonikerDisplayName = reader.ReadString();
+            result.TargetFrameworkSubsets = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+            result.TargetFrameworkVersion = reader.ReadString();
+            result.TargetProcessorArchitecture = reader.ReadString();
+            result.UnresolveFrameworkAssembliesFromHigherFrameworks = reader.ReadBoolean();
+            result.UseResolveAssemblyReferenceService = reader.ReadBoolean();
+            result.WarnOrErrorOnTargetArchitectureMismatch = reader.ReadString();
+            result.CurrentPath = reader.ReadString();
+            result.AssemblyInformationCacheOutputPath = reader.ReadString();
+            result.AssemblyInformationCachePaths = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
 
             reader.Depth--;
             return result;
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ResponseFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ResponseFormatter.cs
index 7914ded3560..8e4b68606a9 100644
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/ResponseFormatter.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ResponseFormatter.cs
@@ -2,12 +2,15 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using MessagePack;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
 {
     internal sealed class ResponseFormatter : MessagePack.Formatters.IMessagePackFormatter<ResolveAssemblyReferenceResponse>
     {
+        internal const int MemberCount = 11;
+
         public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceResponse value, MessagePackSerializerOptions options)
         {
             if (value == null)
@@ -17,18 +20,18 @@ public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceResp
             }
 
             IFormatterResolver formatterResolver = options.Resolver;
-            writer.WriteArrayHeader(11);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.CopyLocalFiles, options);
+            writer.WriteArrayHeader(MemberCount);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.CopyLocalFiles, options);
             writer.Write(value.DependsOnNETStandard);
             writer.Write(value.DependsOnSystemRuntime);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.FilesWritten, options);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.RelatedFiles, options);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.ResolvedDependencyFiles, options);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.ResolvedFiles, options);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.SatelliteFiles, options);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.ScatterFiles, options);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.SerializationAssemblyFiles, options);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.SuggestedRedirects, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.FilesWritten, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.RelatedFiles, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.ResolvedDependencyFiles, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.ResolvedFiles, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.SatelliteFiles, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.ScatterFiles, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.SerializationAssemblyFiles, options);
+            formatterResolver.GetFormatter<ITaskItem[]>().Serialize(ref writer, value.SuggestedRedirects, options);
         }
 
         public ResolveAssemblyReferenceResponse Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
@@ -40,51 +43,20 @@ public ResolveAssemblyReferenceResponse Deserialize(ref MessagePackReader reader
 
             options.Security.DepthStep(ref reader);
             IFormatterResolver formatterResolver = options.Resolver;
-            int length = reader.ReadArrayHeader();
+            int _ = reader.ReadArrayHeader(); // Content starts with this
             ResolveAssemblyReferenceResponse result = new ResolveAssemblyReferenceResponse();
 
-            for (int i = 0; i < length; i++)
-            {
-                switch (i)
-                {
-                    case 0:
-                        result.CopyLocalFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 1:
-                        result.DependsOnNETStandard = reader.ReadString();
-                        break;
-                    case 2:
-                        result.DependsOnSystemRuntime = reader.ReadString();
-                        break;
-                    case 3:
-                        result.FilesWritten = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 4:
-                        result.RelatedFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 5:
-                        result.ResolvedDependencyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 6:
-                        result.ResolvedFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 7:
-                        result.SatelliteFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 8:
-                        result.ScatterFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 9:
-                        result.SerializationAssemblyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 10:
-                        result.SuggestedRedirects = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    default:
-                        reader.Skip();
-                        break;
-                }
-            }
+            result.CopyLocalFiles = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.DependsOnNETStandard = reader.ReadString();
+            result.DependsOnSystemRuntime = reader.ReadString();
+            result.FilesWritten = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.RelatedFiles = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.ResolvedDependencyFiles = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.ResolvedFiles = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.SatelliteFiles = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.ScatterFiles = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.SerializationAssemblyFiles = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
+            result.SuggestedRedirects = formatterResolver.GetFormatter<ITaskItem[]>().Deserialize(ref reader, options);
 
             reader.Depth--;
             return result;
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ResultFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ResultFormatter.cs
index 4ae77645385..6dfd90f6e4e 100644
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/ResultFormatter.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ResultFormatter.cs
@@ -11,6 +11,8 @@ namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
 {
     internal sealed class ResultFormatter : IMessagePackFormatter<ResolveAssemblyReferenceResult>
     {
+        internal const int MemberCount = 3;
+
         public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceResult value, MessagePackSerializerOptions options)
         {
             if (value == null)
@@ -20,7 +22,7 @@ public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceResu
             }
 
             IFormatterResolver formatterResolver = options.Resolver;
-            writer.WriteArrayHeader(3);
+            writer.WriteArrayHeader(MemberCount);
             formatterResolver.GetFormatter<List<BuildEventArgs>>().Serialize(ref writer, value.BuildEvents, options);
             formatterResolver.GetFormatter<ResolveAssemblyReferenceResponse>().Serialize(ref writer, value.Response, options);
             writer.Write(value.TaskResult);
@@ -35,28 +37,12 @@ public ResolveAssemblyReferenceResult Deserialize(ref MessagePackReader reader,
 
             options.Security.DepthStep(ref reader);
             IFormatterResolver formatterResolver = options.Resolver;
-            int length = reader.ReadArrayHeader();
-
+            int _ = reader.ReadArrayHeader();
             ResolveAssemblyReferenceResult result = new ResolveAssemblyReferenceResult();
 
-            for (int i = 0; i < length; i++)
-            {
-                switch (i)
-                {
-                    case 2:
-                        result.TaskResult = reader.ReadBoolean();
-                        break;
-                    case 1:
-                        result.Response = formatterResolver.GetFormatter<ResolveAssemblyReferenceResponse>().Deserialize(ref reader, options);
-                        break;
-                    case 0:
-                        result.BuildEvents = formatterResolver.GetFormatter<List<BuildEventArgs>>().Deserialize(ref reader, options);
-                        break;
-                    default:
-                        reader.Skip();
-                        break;
-                }
-            }
+            result.BuildEvents = formatterResolver.GetFormatter<List<BuildEventArgs>>().Deserialize(ref reader, options);
+            result.Response = formatterResolver.GetFormatter<ResolveAssemblyReferenceResponse>().Deserialize(ref reader, options);
+            result.TaskResult = reader.ReadBoolean();
 
             reader.Depth--;
             return result;
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/TaskItemFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/TaskItemFormatter.cs
new file mode 100644
index 00000000000..2bb00e15852
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/TaskItemFormatter.cs
@@ -0,0 +1,93 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using MessagePack;
+using MessagePack.Formatters;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
+{
+    internal sealed class TaskItemFormatter : IMessagePackFormatter<ITaskItem>
+    {
+        public void Serialize(ref MessagePackWriter writer, ITaskItem value, MessagePackSerializerOptions options)
+        {
+            if (value == null)
+            {
+                writer.WriteNil();
+                return;
+            }
+
+            string escapedItemSpec;
+            IDictionary metadata;
+            bool metadataIsEscaped;
+
+
+            if (value is ITaskItem2 taskItem2)
+            {
+                escapedItemSpec = taskItem2.EvaluatedIncludeEscaped;
+                metadata = taskItem2.CloneCustomMetadataEscaped();
+                metadataIsEscaped = true;
+            }
+            else
+            {
+                // We know that the ITaskItem constructor expects an escaped string, and that ITaskItem.ItemSpec 
+                // is expected to be unescaped, so make sure we give the constructor what it wants. 
+                escapedItemSpec = EscapingUtilities.Escape(value.ItemSpec);
+                metadata = value.CloneCustomMetadata();
+                metadataIsEscaped = false;
+            }
+
+            if (!(metadata is Dictionary<string, string> escapedGenericMetadata))
+            {
+                escapedGenericMetadata = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+
+                foreach (object key in metadata.Keys)
+                {
+                    string metdataValue = (string)metadata[key];
+
+                    if (!metadataIsEscaped)
+                    {
+                        metdataValue = metdataValue == null ? metdataValue : EscapingUtilities.Escape(metdataValue);
+                    }
+
+                    escapedGenericMetadata.Add((string)key, metdataValue);
+                }
+            }
+            else if (!metadataIsEscaped)
+            {
+                foreach (KeyValuePair<string, string> entry in escapedGenericMetadata)
+                {
+                    escapedGenericMetadata[entry.Key] = entry.Value == null ? entry.Value : EscapingUtilities.Escape(entry.Value);
+                }
+            }
+
+            IFormatterResolver formatterResolver = options.Resolver;
+            writer.WriteArrayHeader(2);
+            writer.Write(escapedItemSpec);
+            formatterResolver.GetFormatter<Dictionary<string, string>>().Serialize(ref writer, escapedGenericMetadata, options);
+        }
+
+        public ITaskItem Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            if (reader.TryReadNil())
+            {
+                return null;
+            }
+
+            options.Security.DepthStep(ref reader);
+            IFormatterResolver formatterResolver = options.Resolver;
+            _ = reader.ReadArrayHeader();
+            string itemSpec = reader.ReadString();
+            Dictionary<string, string> metaData = formatterResolver.GetFormatter<Dictionary<string, string>>().Deserialize(ref reader, options);
+            ITaskItem result = new TaskItem(itemSpec, metaData);
+
+            reader.Depth--;
+            return result;
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/ResolveAssemblyReferneceResolver.cs b/src/Tasks/ResolveAssemblyReferences/ResolveAssemblyReferneceResolver.cs
index b4947d3aa6b..e33e4954fdb 100644
--- a/src/Tasks/ResolveAssemblyReferences/ResolveAssemblyReferneceResolver.cs
+++ b/src/Tasks/ResolveAssemblyReferences/ResolveAssemblyReferneceResolver.cs
@@ -49,10 +49,10 @@ static GeneratedResolverGetFormatterHelper()
         {
             lookup = new Dictionary<Type, int>
             {
-                { typeof(ReadOnlyTaskItem[]), 0 },
+                { typeof(ITaskItem[]), 0 },
                 { typeof(Dictionary<string, string>), 1 },
                 { typeof(List<BuildEventArgs>), 2 },
-                { typeof(ReadOnlyTaskItem), 3 },
+                { typeof(ITaskItem), 3 },
                 { typeof(ResolveAssemblyReferenceRequest), 4 },
                 { typeof(ResolveAssemblyReferenceResponse), 5 },
                 { typeof(ResolveAssemblyReferenceResult), 6 },
@@ -70,10 +70,10 @@ internal static object GetFormatter(Type t)
 
             return key switch
             {
-                0 => new ArrayFormatter<ReadOnlyTaskItem>(),
+                0 => new ArrayFormatter<ITaskItem>(),
                 1 => new DictionaryFormatter<string, string>(),
                 2 => new ListFormatter<BuildEventArgs>(),
-                3 => new ReadOnlyTaskItemFormatter(),
+                3 => new TaskItemFormatter(),
                 4 => new RequestFormatter(),
                 5 => new ResponseFormatter(),
                 6 => new ResultFormatter(),
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs
index 92e2bf35916..a530f01d946 100644
--- a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs
@@ -1,15 +1,18 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using System.Linq;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services
 {
     internal static class ResolveAssemblyReferenceComparer
     {
-        internal static bool CompareInput(ResolveAssemblyReferenceRequest x, ResolveAssemblyReferenceRequest y)
+        internal static bool CompareRequest(ResolveAssemblyReferenceRequest x, ResolveAssemblyReferenceRequest y)
         {
             if (x == y)
             {
@@ -68,7 +71,7 @@ internal static bool CompareInput(ResolveAssemblyReferenceRequest x, ResolveAsse
                    AreStringListsEqual(x.TargetFrameworkSubsets, y.TargetFrameworkSubsets);
         }
 
-        internal static bool CompareOutput(ResolveAssemblyReferenceResponse x, ResolveAssemblyReferenceResponse y)
+        internal static bool CompareResponse(ResolveAssemblyReferenceResponse x, ResolveAssemblyReferenceResponse y)
         {
             if (x == y)
             {
@@ -121,7 +124,7 @@ private static bool AreStringListsEqual(string[] x, string[] y)
             return true;
         }
 
-        private static bool AreTaskItemListsEqual(ReadOnlyTaskItem[] x, ReadOnlyTaskItem[] y)
+        private static bool AreTaskItemListsEqual(ITaskItem[] x, ITaskItem[] y)
         {
             if (x == y)
             {
@@ -149,7 +152,7 @@ private static bool AreTaskItemListsEqual(ReadOnlyTaskItem[] x, ReadOnlyTaskItem
             return true;
         }
 
-        private static bool AreTaskItemsEqual(ReadOnlyTaskItem x, ReadOnlyTaskItem y)
+        private static bool AreTaskItemsEqual(ITaskItem x, ITaskItem y)
         {
             if (x == y)
             {
@@ -161,20 +164,24 @@ private static bool AreTaskItemsEqual(ReadOnlyTaskItem x, ReadOnlyTaskItem y)
                 return false;
             }
 
-            if (x.ItemSpec != y.ItemSpec || x.MetadataNameToValue.Count != y.MetadataNameToValue.Count)
+            if (x.ItemSpec != y.ItemSpec || x.MetadataCount != y.MetadataCount)
             {
                 return false;
             }
 
-            foreach (KeyValuePair<string, string> metadataNameWithValue in x.MetadataNameToValue)
-            {
-                string metadataName = metadataNameWithValue.Key;
-                string metadataValue = metadataNameWithValue.Value;
+            IEnumerable<string> xMetadataNames = x.MetadataNames.Cast<string>();
 
-                bool hasMetadata = y.MetadataNameToValue.TryGetValue(metadataName, out string metadataValueToCompare);
-                bool isMetadataEqual = hasMetadata && metadataValue == metadataValueToCompare;
+            if(!xMetadataNames.SequenceEqual(y.MetadataNames.Cast<string>()))
+            {
+                return false;
+            }
 
-                if (!isMetadataEqual)
+            foreach (string metdataName in xMetadataNames)
+            {
+                string xMetdata = x.GetMetadata(metdataName);
+                string yMetdata = y.GetMetadata(metdataName);
+                
+                if (xMetdata != yMetdata)
                 {
                     return false;
                 }
