diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index a7b495b66bb..eadc2078a63 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -51,12 +51,35 @@ public class ResolveAssemblyReference : TaskExtension
         /// <summary>
         /// Cache of system state information, used to optimize performance.
         /// </summary>
-        private SystemState _cache;
+        private SystemState _cache = null;
+
+        /// <summary>
+        /// Construct
+        /// </summary>
+        public ResolveAssemblyReference()
+        {
+        }
 
         #region Properties
 
+        private ITaskItem[] _assemblyFiles = Array.Empty<TaskItem>();
+        private ITaskItem[] _assemblyNames = Array.Empty<TaskItem>();
+        private ITaskItem[] _installedAssemblyTables = Array.Empty<TaskItem>();
         private ITaskItem[] _installedAssemblySubsetTables = Array.Empty<TaskItem>();
         private ITaskItem[] _fullFrameworkAssemblyTables = Array.Empty<TaskItem>();
+        private ITaskItem[] _resolvedSDKReferences = Array.Empty<TaskItem>();
+        private bool _ignoreDefaultInstalledAssemblyTables = false;
+        private bool _ignoreDefaultInstalledAssemblySubsetTables = false;
+        private string[] _candidateAssemblyFiles = Array.Empty<string>();
+        private string[] _targetFrameworkDirectories = Array.Empty<string>();
+        private string[] _searchPaths = Array.Empty<string>();
+        private string[] _allowedAssemblyExtensions = new string[] { ".winmd", ".dll", ".exe" };
+        private string[] _relatedFileExtensions = new string[] { ".pdb", ".xml", ".pri" };
+        private string _appConfigFile = null;
+        private bool _supportsBindingRedirectGeneration;
+        private bool _autoUnify = false;
+        private bool _ignoreVersionForFrameworkReferences = false;
+        private bool _ignoreTargetFrameworkAttributeVersionMismatch = false;
         private ITaskItem[] _resolvedFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _resolvedDependencyFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _relatedFiles = Array.Empty<TaskItem>();
@@ -67,19 +90,43 @@ public class ResolveAssemblyReference : TaskExtension
         private ITaskItem[] _suggestedRedirects = Array.Empty<TaskItem>();
         private string[] _targetFrameworkSubsets = Array.Empty<string>();
         private string[] _fullTargetFrameworkSubsetNames = Array.Empty<string>();
-
+        private string _targetedFrameworkMoniker = String.Empty;
+
+        private bool _findDependencies = true;
+        private bool _findSatellites = true;
+        private bool _findSerializationAssemblies = true;
+        private bool _findRelatedFiles = true;
+        private bool _silent = false;
+        private string _projectTargetFrameworkAsString = String.Empty;
+        private string _targetedRuntimeVersionRawValue = String.Empty;
         private Version _projectTargetFramework;
 
+        private string _stateFile = null;
+        private string _targetProcessorArchitecture = null;
+
         private string _profileName = String.Empty;
         private string[] _fullFrameworkFolders = Array.Empty<string>();
-        private readonly Dictionary<string, MessageImportance> _showAssemblyFoldersExLocations = new Dictionary<string, MessageImportance>(StringComparer.OrdinalIgnoreCase);
-        private bool _logVerboseSearchResults;
+        private string[] _latestTargetFrameworkDirectories = Array.Empty<string>();
+        private bool _copyLocalDependenciesWhenParentReferenceInGac = true;
+        private Dictionary<string, MessageImportance> _showAssemblyFoldersExLocations = new Dictionary<string, MessageImportance>(StringComparer.OrdinalIgnoreCase);
+        private bool _logVerboseSearchResults = false;
         private WarnOrErrorOnTargetArchitectureMismatchBehavior _warnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatchBehavior.Warning;
+        private bool _unresolveFrameworkAssembliesFromHigherFrameworks = false;
 
         /// <summary>
         /// If set to true, it forces to unresolve framework assemblies with versions higher or equal the version of the target framework, regardless of the target framework
         /// </summary>
-        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get; set; } = false;
+        public bool UnresolveFrameworkAssembliesFromHigherFrameworks
+        {
+            get
+            {
+                return _unresolveFrameworkAssembliesFromHigherFrameworks;
+            }
+            set
+            {
+                _unresolveFrameworkAssembliesFromHigherFrameworks = value;
+            }
+        }
 
         /// <summary>
         /// If there is a mismatch between the targetprocessor architecture and the architecture of a primary reference.
@@ -92,10 +139,14 @@ public class ResolveAssemblyReference : TaskExtension
         /// </summary>
         public string WarnOrErrorOnTargetArchitectureMismatch
         {
-            get => _warnOrErrorOnTargetArchitectureMismatch.ToString();
+            get
+            {
+                return _warnOrErrorOnTargetArchitectureMismatch.ToString();
+            }
+
             set
             {
-                if (!Enum.TryParse(value, /*ignoreCase*/true, out _warnOrErrorOnTargetArchitectureMismatch))
+                if (!Enum.TryParse<WarnOrErrorOnTargetArchitectureMismatchBehavior>(value, /*ignoreCase*/true, out _warnOrErrorOnTargetArchitectureMismatch))
                 {
                     _warnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatchBehavior.Warning;
                 }
@@ -114,7 +165,11 @@ public string WarnOrErrorOnTargetArchitectureMismatch
         ///        so several steps can be skipped as an optimization: finding dependencies, 
         ///        satellite assemblies, etc.
         /// </summary>
-        public ITaskItem[] AssemblyFiles { get; set; } = Array.Empty<TaskItem>();
+        public ITaskItem[] AssemblyFiles
+        {
+            get { return _assemblyFiles; }
+            set { _assemblyFiles = value; }
+        }
 
         /// <summary>
         /// The list of directories which contain the redist lists for the most current 
@@ -122,12 +177,34 @@ public string WarnOrErrorOnTargetArchitectureMismatch
         /// Then we will looks for the highest framework installed on the machine 
         /// for a given target framework identifier and use that.
         /// </summary>
-        public string[] LatestTargetFrameworkDirectories { get; set; } = Array.Empty<string>();
+        public string[] LatestTargetFrameworkDirectories
+        {
+            get
+            {
+                return _latestTargetFrameworkDirectories;
+            }
+
+            set
+            {
+                _latestTargetFrameworkDirectories = value;
+            }
+        }
 
         /// <summary>
         /// Should the framework attribute be ignored when checking to see if an assembly is compatible with the targeted framework.
         /// </summary>
-        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get; set; } = false;
+        public bool IgnoreTargetFrameworkAttributeVersionMismatch
+        {
+            get
+            {
+                return _ignoreTargetFrameworkAttributeVersionMismatch;
+            }
+
+            set
+            {
+                _ignoreTargetFrameworkAttributeVersionMismatch = value;
+            }
+        }
 
         /// <summary>
         /// Force dependencies to be walked even when a reference is marked with ExternallyResolved=true
@@ -144,7 +221,7 @@ public string WarnOrErrorOnTargetArchitectureMismatch
         /// </summary>
         public string[] TargetFrameworkSubsets
         {
-            get => _targetFrameworkSubsets;
+            get { return _targetFrameworkSubsets; }
             set
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "TargetFrameworkSubsets");
@@ -187,7 +264,11 @@ public string[] TargetFrameworkSubsets
         ///         when true, we should treat this assembly as if it has no dependencies and should 
         ///         be completely embedded into the target assembly.
         /// </summary>
-        public ITaskItem[] Assemblies { get; set; } = Array.Empty<TaskItem>();
+        public ITaskItem[] Assemblies
+        {
+            get { return _assemblyNames; }
+            set { _assemblyNames = value; }
+        }
 
         /// <summary>
         /// A list of assembly files that can be part of the search and resolution process.
@@ -196,13 +277,21 @@ public string[] TargetFrameworkSubsets
         /// Assembly files in this list will be considered when SearchPaths contains
         /// {CandidateAssemblyFiles} as one of the paths to consider.
         /// </summary>
-        public string[] CandidateAssemblyFiles { get; set; } = Array.Empty<string>();
+        public string[] CandidateAssemblyFiles
+        {
+            get { return _candidateAssemblyFiles; }
+            set { _candidateAssemblyFiles = value; }
+        }
 
         /// <summary>
         /// A list of resolved SDK references which contain the sdk name, sdk location and the targeted configuration.
         /// These locations will only be searched if the reference has the SDKName metadata attached to it.
         /// </summary>
-        public ITaskItem[] ResolvedSDKReferences { get; set; } = Array.Empty<TaskItem>();
+        public ITaskItem[] ResolvedSDKReferences
+        {
+            get { return _resolvedSDKReferences; }
+            set { _resolvedSDKReferences = value; }
+        }
 
         /// <summary>
         /// Path to the target frameworks directory. Required to figure out CopyLocal status 
@@ -210,7 +299,11 @@ public string[] TargetFrameworkSubsets
         /// If not present, then no resulting items will be deemed CopyLocal='true' unless they explicity 
         /// have a Private='true' attribute on their source item.
         /// </summary>
-        public string[] TargetFrameworkDirectories { get; set; } = Array.Empty<string>();
+        public string[] TargetFrameworkDirectories
+        {
+            get { return _targetFrameworkDirectories; }
+            set { _targetFrameworkDirectories = value; }
+        }
 
         /// <summary>
         /// A list of XML files that contain assemblies that are expected to be installed on the target machine.
@@ -232,7 +325,11 @@ public string[] TargetFrameworkSubsets
         /// "FrameworkDirectory" metadata will be treated as though this metadata is set to the lone (unique) value passed
         /// to TargetFrameworkDirectories.
         /// </summary>
-        public ITaskItem[] InstalledAssemblyTables { get; set; } = Array.Empty<TaskItem>();
+        public ITaskItem[] InstalledAssemblyTables
+        {
+            get { return _installedAssemblyTables; }
+            set { _installedAssemblyTables = value; }
+        }
 
         /// <summary>
         /// A list of XML files that contain assemblies that are expected to be in the target subset
@@ -252,7 +349,7 @@ public string[] TargetFrameworkSubsets
         /// </summary>
         public ITaskItem[] InstalledAssemblySubsetTables
         {
-            get => _installedAssemblySubsetTables;
+            get { return _installedAssemblySubsetTables; }
             set
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "InstalledAssemblySubsetTables");
@@ -279,7 +376,7 @@ public ITaskItem[] InstalledAssemblySubsetTables
         /// </summary>
         public ITaskItem[] FullFrameworkAssemblyTables
         {
-            get => _fullFrameworkAssemblyTables;
+            get { return _fullFrameworkAssemblyTables; }
             set
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "FullFrameworkAssemblyTables");
@@ -293,7 +390,11 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// assembly tables (a.k.a Redist Lists) found in the RedistList directory underneath the provided
         /// TargetFrameworkDirectories.
         /// </summary>
-        public bool IgnoreDefaultInstalledAssemblyTables { get; set; } = false;
+        public bool IgnoreDefaultInstalledAssemblyTables
+        {
+            get { return _ignoreDefaultInstalledAssemblyTables; }
+            set { _ignoreDefaultInstalledAssemblyTables = value; }
+        }
 
         /// <summary>
         /// [default=false]
@@ -301,12 +402,20 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// assembly subset tables (a.k.a Subset Lists) found in the SubsetList directory underneath the provided
         /// TargetFrameworkDirectories.
         /// </summary>
-        public bool IgnoreDefaultInstalledAssemblySubsetTables { get; set; } = false;
+        public bool IgnoreDefaultInstalledAssemblySubsetTables
+        {
+            get { return _ignoreDefaultInstalledAssemblySubsetTables; }
+            set { _ignoreDefaultInstalledAssemblySubsetTables = value; }
+        }
 
         /// <summary>
         /// If the primary reference is a framework assembly ignore its version information and actually resolve the framework assembly from the currently targeted framework.
         /// </summary>
-        public bool IgnoreVersionForFrameworkReferences { get; set; } = false;
+        public bool IgnoreVersionForFrameworkReferences
+        {
+            get { return _ignoreVersionForFrameworkReferences; }
+            set { _ignoreVersionForFrameworkReferences = value; }
+        }
 
         /// <summary>
         /// The preferred target processor architecture. Used for resolving {GAC} references. 
@@ -320,12 +429,20 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// If absent, then only consider assemblies in the GAC that have ProcessorArchitecture==MSIL or
         /// no ProcessorArchitecture (these are pre-Whidbey assemblies).
         /// </summary>
-        public string TargetProcessorArchitecture { get; set; } = null;
+        public string TargetProcessorArchitecture
+        {
+            get { return _targetProcessorArchitecture; }
+            set { _targetProcessorArchitecture = value; }
+        }
 
         /// <summary>
         /// What is the runtime we are targeting, is it 2.0.57027 or anotherone, It can have a v or not prefixed onto it.
         /// </summary>
-        public string TargetedRuntimeVersion { get; set; } = String.Empty;
+        public string TargetedRuntimeVersion
+        {
+            get { return _targetedRuntimeVersionRawValue; }
+            set { _targetedRuntimeVersionRawValue = value; }
+        }
 
         /// <summary>
         /// List of locations to search for assemblyFiles when resolving dependencies.
@@ -366,20 +483,32 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// </summary>
         /// <value></value>
         [Required]
-        public string[] SearchPaths { get; set; } = Array.Empty<string>();
+        public string[] SearchPaths
+        {
+            get { return _searchPaths; }
+            set { _searchPaths = value; }
+        }
 
         /// <summary>
         /// [default=.exe;.dll]
         /// These are the assembly extensions that will be considered during references resolution.
         /// </summary>
-        public string[] AllowedAssemblyExtensions { get; set; } = { ".winmd", ".dll", ".exe" };
+        public string[] AllowedAssemblyExtensions
+        {
+            get { return _allowedAssemblyExtensions; }
+            set { _allowedAssemblyExtensions = value; }
+        }
 
 
         /// <summary>
         /// [default=.pdb;.xml]
         /// These are the extensions that will be considered when looking for related files.
         /// </summary>
-        public string[] AllowedRelatedFileExtensions { get; set; } = { ".pdb", ".xml", ".pri" };
+        public string[] AllowedRelatedFileExtensions
+        {
+            get { return _relatedFileExtensions; }
+            set { _relatedFileExtensions = value; }
+        }
 
 
         /// <summary>
@@ -389,13 +518,21 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// If this parameter is passed in, then AutoUnify must be false, otherwise error.
         /// </summary>
         /// <value></value>
-        public string AppConfigFile { get; set; }
+        public string AppConfigFile
+        {
+            get { return _appConfigFile; }
+            set { _appConfigFile = value; }
+        }
 
         /// <summary>
         /// This is true if the project type supports "AutoGenerateBindingRedirects" (currently only for EXE projects).
         /// </summary>
         /// <value></value>
-        public bool SupportsBindingRedirectGeneration { get; set; }
+        public bool SupportsBindingRedirectGeneration
+        {
+            get { return _supportsBindingRedirectGeneration; }
+            set { _supportsBindingRedirectGeneration = value; }
+        }
 
         /// <summary>
         /// [default=false]
@@ -423,8 +560,13 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// different versions of reference and dependent assemblies".
         /// </summary>
         /// <value></value>
-        public bool AutoUnify { get; set; } = false;
-        
+        public bool AutoUnify
+        {
+            get { return _autoUnify; }
+            set { _autoUnify = value; }
+        }
+
+
         /// <summary>
         ///  When determining if a dependency should be copied locally one of the checks done is to see if the 
         ///  parent reference in the project file has the Private metadata set or not. If that metadata is set then 
@@ -443,21 +585,33 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// 
         /// NOTE: If there are multiple parent reference and ANY of them does not come from the GAC then we will set copy local to true.
         /// </summary>
-        public bool CopyLocalDependenciesWhenParentReferenceInGac { get; set; } = true;
+        public bool CopyLocalDependenciesWhenParentReferenceInGac
+        {
+            get { return _copyLocalDependenciesWhenParentReferenceInGac; }
+            set { _copyLocalDependenciesWhenParentReferenceInGac = value; }
+        }
 
         /// <summary>
         /// [default=false]
         /// Enables legacy mode for CopyLocal determination. If true, referenced assemblies will not be copied locally if they
         /// are found in the GAC. If false, assemblies will be copied locally unless they were found only in the GAC.
         /// </summary>
-        public bool DoNotCopyLocalIfInGac { get; set; }
+        public bool DoNotCopyLocalIfInGac
+        {
+            get;
+            set;
+        }
 
         /// <summary>
         /// An optional file name that indicates where to save intermediate build state
         /// for this task. If not specified, then no inter-build caching will occur.
         /// </summary>
         /// <value></value>
-        public string StateFile { get; set; }
+        public string StateFile
+        {
+            get { return _stateFile; }
+            set { _stateFile = value; }
+        }
 
         /// <summary>
         /// If set, then dependencies will be found. Otherwise, only Primary references will be
@@ -466,7 +620,11 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// Default is true.
         /// </summary>
         /// <value></value>
-        public bool FindDependencies { get; set; } = true;
+        public bool FindDependencies
+        {
+            get { return _findDependencies; }
+            set { _findDependencies = value; }
+        }
 
         /// <summary>
         /// If set, then satellites will be found.
@@ -474,7 +632,11 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// Default is true.
         /// </summary>
         /// <value></value>
-        public bool FindSatellites { get; set; } = true;
+        public bool FindSatellites
+        {
+            get { return _findSatellites; }
+            set { _findSatellites = value; }
+        }
 
         /// <summary>
         /// If set, then serialization assemblies will be found.
@@ -482,7 +644,11 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// Default is true.
         /// </summary>
         /// <value></value>
-        public bool FindSerializationAssemblies { get; set; } = true;
+        public bool FindSerializationAssemblies
+        {
+            get { return _findSerializationAssemblies; }
+            set { _findSerializationAssemblies = value; }
+        }
 
         /// <summary>
         /// If set, then related files (.pdbs and .xmls) will be found.
@@ -490,7 +656,11 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// Default is true.
         /// </summary>
         /// <value></value>
-        public bool FindRelatedFiles { get; set; } = true;
+        public bool FindRelatedFiles
+        {
+            get { return _findRelatedFiles; }
+            set { _findRelatedFiles = value; }
+        }
 
         /// <summary>
         /// If set, then don't log any messages to the screen.
@@ -498,7 +668,11 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// Default is false.
         /// </summary>
         /// <value></value>
-        public bool Silent { get; set; }
+        public bool Silent
+        {
+            get { return _silent; }
+            set { _silent = value; }
+        }
 
         /// <summary>
         /// The project target framework version.
@@ -506,7 +680,11 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// Default is empty. which means there will be no filtering for the reference based on their target framework.
         /// </summary>
         /// <value></value>
-        public string TargetFrameworkVersion { get; set; } = String.Empty;
+        public string TargetFrameworkVersion
+        {
+            get { return _projectTargetFrameworkAsString; }
+            set { _projectTargetFrameworkAsString = value; }
+        }
 
         /// <summary>
         /// The target framework moniker we are targeting if any. This is used for logging purposes.
@@ -514,12 +692,20 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// Default is empty.
         /// </summary>
         /// <value></value>
-        public string TargetFrameworkMoniker { get; set; } = String.Empty;
+        public string TargetFrameworkMoniker
+        {
+            get { return _targetedFrameworkMoniker; }
+            set { _targetedFrameworkMoniker = value; }
+        }
 
         /// <summary>
         /// The display name of the target framework moniker, if any. This is only for logging.
         /// </summary>
-        public string TargetFrameworkMonikerDisplayName { get; set; }
+        public string TargetFrameworkMonikerDisplayName
+        {
+            get;
+            set;
+        }
 
         /// <summary>
         /// Provide a set of names which if seen in the TargetFrameworkSubset list will cause the ignoring 
@@ -529,7 +715,11 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// </summary>
         public string[] FullTargetFrameworkSubsetNames
         {
-            get => _fullTargetFrameworkSubsetNames;
+            get
+            {
+                return _fullTargetFrameworkSubsetNames;
+            }
+
             set
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "FullTargetFrameworkSubsetNames");
@@ -543,7 +733,11 @@ public string[] FullTargetFrameworkSubsetNames
         /// </summary>
         public string ProfileName
         {
-            get => _profileName;
+            get
+            {
+                return _profileName;
+            }
+
             set
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "profileName");
@@ -558,7 +752,11 @@ public string ProfileName
         /// </summary>
         public string[] FullFrameworkFolders
         {
-            get => _fullFrameworkFolders;
+            get
+            {
+                return _fullFrameworkFolders;
+            }
+
             set
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "FullFrameworkFolders");
@@ -579,7 +777,10 @@ public string[] FullFrameworkFolders
         ///     string Redist - The name (if any) of the redist that contains this assembly.
         /// </summary>
         [Output]
-        public ITaskItem[] ResolvedFiles => _resolvedFiles;
+        public ITaskItem[] ResolvedFiles
+        {
+            get { return _resolvedFiles; }
+        }
 
         /// <summary>
         /// A list of all n-th order paths-to-dependencies with the following attributes:
@@ -595,7 +796,10 @@ public string[] FullFrameworkFolders
         /// Does not include first order primary references--this list is in ResolvedFiles.
         /// </summary>
         [Output]
-        public ITaskItem[] ResolvedDependencyFiles => _resolvedDependencyFiles;
+        public ITaskItem[] ResolvedDependencyFiles
+        {
+            get { return _resolvedDependencyFiles; }
+        }
 
         /// <summary>
         /// Related files are files like intellidoc (.XML) and symbols (.PDB) that have the same base
@@ -604,7 +808,10 @@ public string[] FullFrameworkFolders
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
         /// </summary>
         [Output]
-        public ITaskItem[] RelatedFiles => _relatedFiles;
+        public ITaskItem[] RelatedFiles
+        {
+            get { return _relatedFiles; }
+        }
 
         /// <summary>
         /// Any satellite files found. These will be CopyLocal=true iff the reference or dependency 
@@ -614,7 +821,10 @@ public string[] FullFrameworkFolders
         ///       should be copied to. This is mainly for satellites.
         /// </summary>
         [Output]
-        public ITaskItem[] SatelliteFiles => _satelliteFiles;
+        public ITaskItem[] SatelliteFiles
+        {
+            get { return _satelliteFiles; }
+        }
 
         /// <summary>
         /// Any XML serialization assemblies found. These will be CopyLocal=true iff the reference or dependency 
@@ -622,14 +832,20 @@ public string[] FullFrameworkFolders
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
         /// </summary>
         [Output]
-        public ITaskItem[] SerializationAssemblyFiles => _serializationAssemblyFiles;
+        public ITaskItem[] SerializationAssemblyFiles
+        {
+            get { return _serializationAssemblyFiles; }
+        }
 
         /// <summary>
         /// Scatter files associated with one of the given assemblies.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
         /// </summary>
         [Output]
-        public ITaskItem[] ScatterFiles => _scatterFiles;
+        public ITaskItem[] ScatterFiles
+        {
+            get { return _scatterFiles; }
+        }
 
         /// <summary>
         /// Returns every file in ResolvedFiles+ResolvedDependencyFiles+RelatedFiles+SatelliteFiles+ScatterFiles+SatelliteAssemblyFiles
@@ -637,7 +853,10 @@ public string[] FullFrameworkFolders
         /// </summary>
         /// <value></value>
         [Output]
-        public ITaskItem[] CopyLocalFiles => _copyLocalFiles;
+        public ITaskItem[] CopyLocalFiles
+        {
+            get { return _copyLocalFiles; }
+        }
 
         /// <summary>
         /// Regardless of the value of AutoUnify, returns one item for every distinct conflicting assembly 
@@ -649,12 +868,15 @@ public string[] FullFrameworkFolders
         ///  MaxVersion - the maximum version number.
         /// </summary>
         [Output]
-        public ITaskItem[] SuggestedRedirects => _suggestedRedirects;
+        public ITaskItem[] SuggestedRedirects
+        {
+            get { return _suggestedRedirects; }
+        }
 
         /// <summary>
         /// Storage for names of all files writen to disk.
         /// </summary>
-        private readonly ArrayList _filesWritten = new ArrayList();
+        private ArrayList _filesWritten = new ArrayList();
 
         /// <summary>
         /// The names of all files written to disk.
@@ -670,13 +892,22 @@ public ITaskItem[] FilesWritten
         /// Whether the assembly or any of its primary references depends on system.runtime. (Aka needs Facade references to resolve duplicate types)
         /// </summary>
         [Output]
-        public String DependsOnSystemRuntime { get; private set; }
+        public String DependsOnSystemRuntime
+        {
+            get;
+            private set;
+        }
 
         /// <summary>
         /// Whether the assembly or any of its primary references depends on netstandard
         /// </summary>
         [Output]
-        public String DependsOnNETStandard { get; private set; }
+        public String DependsOnNETStandard
+        {
+            get;
+            private set;
+        }
+
 
         #endregion
         #region Logging
@@ -811,6 +1042,7 @@ quiet at the engine level.
                                         assemblyIdentityAttributes.Add(new XAttribute("name", idealRemappingPartialAssemblyName.Name));
 
                                         // We use "neutral" for "Invariant Language (Invariant Country)" in assembly names.
+                                        var cultureString = idealRemappingPartialAssemblyName.CultureName;
                                         assemblyIdentityAttributes.Add(new XAttribute("culture", String.IsNullOrEmpty(idealRemappingPartialAssemblyName.CultureName) ? "neutral" : idealRemappingPartialAssemblyName.CultureName));
 
                                         var publicKeyToken = idealRemappingPartialAssemblyName.GetPublicKeyToken();
@@ -866,8 +1098,9 @@ quiet at the engine level.
                     // Log general resolution exceptions.
                     foreach (Exception error in generalResolutionExceptions)
                     {
-                        if (error is InvalidReferenceAssemblyNameException e)
+                        if (error is InvalidReferenceAssemblyNameException)
                         {
+                            InvalidReferenceAssemblyNameException e = (InvalidReferenceAssemblyNameException)error;
                             Log.LogWarningWithCodeFromResources("General.MalformedAssemblyName", e.SourceItemSpec);
                         }
                         else
@@ -884,9 +1117,9 @@ quiet at the engine level.
             {
                 foreach (Resolver r in dependencyTable.Resolvers)
                 {
-                    if (r is AssemblyFoldersExResolver resolver)
+                    if (r is AssemblyFoldersExResolver)
                     {
-                        AssemblyFoldersEx assemblyFoldersEx = resolver.AssemblyFoldersExLocations;
+                        AssemblyFoldersEx assemblyFoldersEx = ((AssemblyFoldersExResolver)r).AssemblyFoldersExLocations;
 
                         MessageImportance messageImportance = MessageImportance.Low;
                         if (assemblyFoldersEx != null && _showAssemblyFoldersExLocations.TryGetValue(r.SearchPath, out messageImportance))
@@ -917,9 +1150,7 @@ internal static string ByteArrayToString(byte[] a)
 
             var buffer = new StringBuilder(a.Length * 2);
             for (int i = 0; i < a.Length; ++i)
-            {
                 buffer.Append(a[i].ToString("x2", CultureInfo.InvariantCulture));
-            }
 
             return buffer.ToString();
         }
@@ -1015,7 +1246,7 @@ private void LogReference(Reference reference, string fusionName)
         /// Choose an importance level for reporting information about this reference.
         /// </summary>
         /// <param name="reference">The reference.</param>
-        private static MessageImportance ChooseReferenceLoggingImportance(Reference reference)
+        private MessageImportance ChooseReferenceLoggingImportance(Reference reference)
         {
             MessageImportance importance = MessageImportance.Low;
 
@@ -1044,13 +1275,13 @@ private void LogInputs()
             if (!Silent)
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "TargetFrameworkMoniker");
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", TargetFrameworkMoniker);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", _targetedFrameworkMoniker);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "TargetFrameworkMonikerDisplayName");
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", TargetFrameworkMonikerDisplayName);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "TargetedRuntimeVersion");
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", TargetedRuntimeVersion);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", _targetedRuntimeVersionRawValue);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "Assemblies");
                 foreach (ITaskItem item in Assemblies)
@@ -1077,7 +1308,7 @@ private void LogInputs()
                 {
                     try
                     {
-                        if (FileUtilities.HasExtension(file, AllowedAssemblyExtensions))
+                        if (FileUtilities.HasExtension(file, _allowedAssemblyExtensions))
                         {
                             Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", file);
                         }
@@ -1099,7 +1330,7 @@ private void LogInputs()
                 }
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "IgnoreInstalledAssemblyTable");
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", IgnoreDefaultInstalledAssemblyTables);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", _ignoreDefaultInstalledAssemblyTables);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "SearchPaths");
                 foreach (string path in SearchPaths)
@@ -1108,13 +1339,13 @@ private void LogInputs()
                 }
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "AllowedAssemblyExtensions");
-                foreach (string allowedAssemblyExtension in AllowedAssemblyExtensions)
+                foreach (string allowedAssemblyExtension in _allowedAssemblyExtensions)
                 {
                     Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", allowedAssemblyExtension);
                 }
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "AllowedRelatedFileExtensions");
-                foreach (string allowedRelatedFileExtension in AllowedRelatedFileExtensions)
+                foreach (string allowedRelatedFileExtension in _relatedFileExtensions)
                 {
                     Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", allowedRelatedFileExtension);
                 }
@@ -1126,10 +1357,10 @@ private void LogInputs()
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", AutoUnify.ToString());
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "CopyLocalDependenciesWhenParentReferenceInGac");
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", CopyLocalDependenciesWhenParentReferenceInGac);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", _copyLocalDependenciesWhenParentReferenceInGac);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "FindDependencies");
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", FindDependencies);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", _findDependencies);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "TargetProcessorArchitecture");
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", TargetProcessorArchitecture);
@@ -1145,7 +1376,7 @@ private void LogInputs()
                 }
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "IgnoreInstalledAssemblySubsetTable");
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", IgnoreDefaultInstalledAssemblySubsetTables);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", _ignoreDefaultInstalledAssemblySubsetTables);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "TargetFrameworkSubsets");
                 foreach (string subset in _targetFrameworkSubsets)
@@ -1169,7 +1400,7 @@ private void LogInputs()
                 }
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "LatestTargetFrameworkDirectories");
-                foreach (string latestFolder in LatestTargetFrameworkDirectories)
+                foreach (string latestFolder in _latestTargetFrameworkDirectories)
                 {
                     Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", latestFolder);
                 }
@@ -1187,10 +1418,12 @@ private void LogInputs()
         /// <summary>
         /// Log a specific item metadata.
         /// </summary>
+        /// <param name="item"></param>
+        /// <param name="attribute"></param>
         private void LogAttribute(ITaskItem item, string metadataName)
         {
             string metadataValue = item.GetMetadata(metadataName);
-            if (!string.IsNullOrEmpty(metadataValue))
+            if (metadataValue != null && metadataValue.Length > 0)
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.EightSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.LogAttributeFormat", metadataName, metadataValue));
             }
@@ -1238,7 +1471,7 @@ private void LogPrimaryOrDependency(Reference reference, string fusionName, Mess
                         }
                         else
                         {
-                            Log.LogMessageFromResources(importance, "ResolveAssemblyReference.FourSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.UnificationByAppConfig", unificationVersion.version, AppConfigFile, unificationVersion.referenceFullPath));
+                            Log.LogMessageFromResources(importance, "ResolveAssemblyReference.FourSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.UnificationByAppConfig", unificationVersion.version, _appConfigFile, unificationVersion.referenceFullPath));
                         }
                         break;
 
@@ -1298,7 +1531,8 @@ private void LogReferenceErrors(Reference reference, MessageImportance importanc
                     Debug.Assert(false, "Unexpected exception type.");
                 }
 
-                string warningCode = Log.ExtractMessageCode(message, out string messageOnly);
+                string messageOnly;
+                string warningCode = Log.ExtractMessageCode(message, out messageOnly);
 
                 // Treat as warning if this is primary and the problem wasn't with a dependency, otherwise, make it a comment.
                 if (reference.IsPrimary && !dependencyProblem)
@@ -1351,7 +1585,8 @@ private void LogAssembliesConsideredAndRejected(Reference reference, string fusi
                     if (logAssemblyFoldersMinimal)
                     {
                         // We not only need to track if we logged a message but also what importance. We want the logging of the assemblyfoldersex folder structure to match the same importance.
-                        if (!_showAssemblyFoldersExLocations.TryGetValue(location.SearchPath, out MessageImportance messageImportance))
+                        MessageImportance messageImportance = MessageImportance.Low;
+                        if (!_showAssemblyFoldersExLocations.TryGetValue(location.SearchPath, out messageImportance))
                         {
                             _showAssemblyFoldersExLocations.Add(location.SearchPath, importance);
                         }
@@ -1409,7 +1644,7 @@ private void LogAssembliesConsideredAndRejected(Reference reference, string fusi
                                 break;
                             }
                         case NoMatchReason.ProcessorArchitectureDoesNotMatch:
-                            Log.LogMessageFromResources(importance, "ResolveAssemblyReference.EightSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch", location.FileNameAttempted, location.AssemblyName.AssemblyName.ProcessorArchitecture.ToString(), TargetProcessorArchitecture));
+                            Log.LogMessageFromResources(importance, "ResolveAssemblyReference.EightSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch", location.FileNameAttempted, location.AssemblyName.AssemblyName.ProcessorArchitecture.ToString(), _targetProcessorArchitecture));
                             break;
                         default:
                             Debug.Assert(false, "Should have handled this case.");
@@ -1609,7 +1844,7 @@ private void LogConflict(Reference reference, string fusionName)
         /// </summary>
         private void ReadStateFile()
         {
-            _cache = (SystemState)StateFileBase.DeserializeCache(StateFile, Log, typeof(SystemState));
+            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));
 
             // Construct the cache if necessary.
             if (_cache == null)
@@ -1623,9 +1858,9 @@ private void ReadStateFile()
         /// </summary>
         private void WriteStateFile()
         {
-            if (!string.IsNullOrEmpty(StateFile) && _cache.IsDirty)
+            if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
             {
-                _cache.SerializeCache(StateFile, Log);
+                _cache.SerializeCache(_stateFile, Log);
             }
         }
         #endregion
@@ -1637,10 +1872,10 @@ private void WriteStateFile()
         /// <returns></returns>
         private DependentAssembly[] GetAssemblyRemappingsFromAppConfig()
         {
-            if (AppConfigFile != null)
+            if (_appConfigFile != null)
             {
                 AppConfig appConfig = new AppConfig();
-                appConfig.Load(AppConfigFile);
+                appConfig.Load(_appConfigFile);
 
                 return appConfig.Runtime.DependentAssemblies;
             }
@@ -1692,21 +1927,21 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                 try
                 {
                     FrameworkNameVersioning frameworkMoniker = null;
-                    if (!String.IsNullOrEmpty(TargetFrameworkMoniker))
+                    if (!String.IsNullOrEmpty(_targetedFrameworkMoniker))
                     {
                         try
                         {
-                            frameworkMoniker = new FrameworkNameVersioning(TargetFrameworkMoniker);
+                            frameworkMoniker = new FrameworkNameVersioning(_targetedFrameworkMoniker);
                         }
                         catch (ArgumentException)
                         {
                             // The exception doesn't contain the bad value, so log it ourselves
-                            Log.LogErrorWithCodeFromResources("ResolveAssemblyReference.InvalidParameter", "TargetFrameworkMoniker", TargetFrameworkMoniker, String.Empty);
+                            Log.LogErrorWithCodeFromResources("ResolveAssemblyReference.InvalidParameter", "TargetFrameworkMoniker", _targetedFrameworkMoniker, String.Empty);
                             return false;
                         }
                     }
 
-                    Version targetedRuntimeVersion = SetTargetedRuntimeVersion(TargetedRuntimeVersion);
+                    Version targetedRuntimeVersion = SetTargetedRuntimeVersion(_targetedRuntimeVersionRawValue);
 
                     // Log task inputs.
                     LogInputs();
@@ -1721,17 +1956,17 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     // Loop through all the target framework directories that were passed in,
                     // and ensure that they all have a trailing slash.  This is necessary
                     // for the string comparisons we will do later on.
-                    if (TargetFrameworkDirectories != null)
+                    if (_targetFrameworkDirectories != null)
                     {
-                        for (int i = 0; i < TargetFrameworkDirectories.Length; i++)
+                        for (int i = 0; i < _targetFrameworkDirectories.Length; i++)
                         {
-                            TargetFrameworkDirectories[i] = FileUtilities.EnsureTrailingSlash(TargetFrameworkDirectories[i]);
+                            _targetFrameworkDirectories[i] = FileUtilities.EnsureTrailingSlash(_targetFrameworkDirectories[i]);
                         }
                     }
 
 
                     // Validate the contents of the InstalledAssemblyTables parameter.
-                    AssemblyTableInfo[] installedAssemblyTableInfo = GetInstalledAssemblyTableInfo(IgnoreDefaultInstalledAssemblyTables, InstalledAssemblyTables, new GetListPath(RedistList.GetRedistListPathsFromDisk), TargetFrameworkDirectories);
+                    AssemblyTableInfo[] installedAssemblyTableInfo = GetInstalledAssemblyTableInfo(_ignoreDefaultInstalledAssemblyTables, _installedAssemblyTables, new GetListPath(RedistList.GetRedistListPathsFromDisk), TargetFrameworkDirectories);
                     AssemblyTableInfo[] whiteListSubsetTableInfo = null;
 
                     InstalledAssemblies installedAssemblies = null;
@@ -1849,7 +2084,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     getDirectories = _cache.CacheDelegate(getDirectories);
                     getRuntimeVersion = _cache.CacheDelegate(getRuntimeVersion);
 
-                    _projectTargetFramework = FrameworkVersionFromString(TargetFrameworkVersion);
+                    _projectTargetFramework = FrameworkVersionFromString(_projectTargetFrameworkAsString);
 
                     // Filter out all Assemblies that have SubType!='', or higher framework
                     FilterBySubtypeAndTargetFramework();
@@ -1869,7 +2104,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         }
                     }
 
-                    SystemProcessorArchitecture processorArchitecture = TargetProcessorArchitectureToEnumeration(TargetProcessorArchitecture);
+                    SystemProcessorArchitecture processorArchitecture = TargetProcessorArchitectureToEnumeration(_targetProcessorArchitecture);
 
                     ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache =
                         Traits.Instance.EscapeHatches.CacheAssemblyInformation
@@ -1880,16 +2115,16 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     ReferenceTable dependencyTable = new ReferenceTable
                     (
                         BuildEngine,
-                        FindDependencies,
-                        FindSatellites,
-                        FindSerializationAssemblies,
-                        FindRelatedFiles,
-                        SearchPaths,
-                        AllowedAssemblyExtensions,
-                        AllowedRelatedFileExtensions,
-                        CandidateAssemblyFiles,
-                        ResolvedSDKReferences,
-                        TargetFrameworkDirectories,
+                        _findDependencies,
+                        _findSatellites,
+                        _findSerializationAssemblies,
+                        _findRelatedFiles,
+                        _searchPaths,
+                        _allowedAssemblyExtensions,
+                        _relatedFileExtensions,
+                        _candidateAssemblyFiles,
+                        _resolvedSDKReferences,
+                        _targetFrameworkDirectories,
                         installedAssemblies,
                         processorArchitecture,
                         fileExists,
@@ -1907,16 +2142,16 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         _projectTargetFramework,
                         frameworkMoniker,
                         Log,
-                        LatestTargetFrameworkDirectories,
-                        CopyLocalDependenciesWhenParentReferenceInGac,
+                        _latestTargetFrameworkDirectories,
+                        _copyLocalDependenciesWhenParentReferenceInGac,
                         DoNotCopyLocalIfInGac,
                         getAssemblyPathInGac,
                         isWinMDFile,
-                        IgnoreVersionForFrameworkReferences,
+                        _ignoreVersionForFrameworkReferences,
                         readMachineTypeFromPEHeader,
                         _warnOrErrorOnTargetArchitectureMismatch,
-                        IgnoreTargetFrameworkAttributeVersionMismatch,
-                        UnresolveFrameworkAssembliesFromHigherFrameworks,
+                        _ignoreTargetFrameworkAttributeVersionMismatch,
+                        _unresolveFrameworkAssembliesFromHigherFrameworks,
                         assemblyMetadataCache
                         );
 
@@ -1925,7 +2160,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     // If AutoUnify, then compute the set of assembly remappings.
                     ArrayList generalResolutionExceptions = new ArrayList();
 
-                    subsetOrProfileName = targetingSubset && String.IsNullOrEmpty(TargetFrameworkMoniker) ? subsetOrProfileName : TargetFrameworkMoniker;
+                    subsetOrProfileName = targetingSubset && String.IsNullOrEmpty(_targetedFrameworkMoniker) ? subsetOrProfileName : _targetedFrameworkMoniker;
                     bool excludedReferencesExist = false;
 
                     DependentAssembly[] autoUnifiedRemappedAssemblies = null;
@@ -1938,8 +2173,8 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             // Use any app.config specified binding redirects so that later when we output suggested redirects
                             // for the GenerateBindingRedirects target, we don't suggest ones that the user already wrote
                             appConfigRemappedAssemblies,
-                            AssemblyFiles,
-                            Assemblies,
+                            _assemblyFiles,
+                            _assemblyNames,
                             generalResolutionExceptions
                         );
 
@@ -1975,7 +2210,7 @@ out autoUnifiedRemappedAssemblyReferences
                     DependentAssembly[] allRemappedAssemblies = CombineRemappedAssemblies(appConfigRemappedAssemblies, autoUnifiedRemappedAssemblies);
 
                     // Compute all dependencies.
-                    dependencyTable.ComputeClosure(allRemappedAssemblies, AssemblyFiles, Assemblies, generalResolutionExceptions);
+                    dependencyTable.ComputeClosure(allRemappedAssemblies, _assemblyFiles, _assemblyNames, generalResolutionExceptions);
 
                     try
                     {
@@ -2090,9 +2325,9 @@ out _copyLocalFiles
                     WriteStateFile();
 
                     // Save the new state out and put into the file exists if it is actually on disk.
-                    if (StateFile != null && fileExists(StateFile))
+                    if (_stateFile != null && fileExists(_stateFile))
                     {
-                        _filesWritten.Add(new TaskItem(StateFile));
+                        _filesWritten.Add(new TaskItem(_stateFile));
                     }
 
                     // Log the results.
@@ -2106,7 +2341,7 @@ out _copyLocalFiles
                         {
                             AssemblyNameExtension assemblyName = null;
 
-                            if (fileExists(item.ItemSpec) && !Reference.IsFrameworkFile(item.ItemSpec, TargetFrameworkDirectories))
+                            if (fileExists(item.ItemSpec) && !Reference.IsFrameworkFile(item.ItemSpec, _targetFrameworkDirectories))
                             {
                                 try
                                 {
@@ -2451,7 +2686,7 @@ private bool ShouldUseSubsetBlackList()
                 {
                     if (String.Equals(fullSubsetName, subsetName, StringComparison.OrdinalIgnoreCase))
                     {
-                        if (!Silent)
+                        if (!_silent)
                         {
                             Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.NoExclusionListBecauseofFullClientName", subsetName);
                         }
@@ -2473,7 +2708,7 @@ private bool ShouldUseSubsetBlackList()
                 return false;
             }
 
-            if (!Silent)
+            if (!_silent)
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.UsingExclusionList");
             }
@@ -2622,7 +2857,7 @@ private void FilterBySubtypeAndTargetFramework()
             foreach (ITaskItem assembly in Assemblies)
             {
                 string subType = assembly.GetMetadata(ItemMetadataNames.subType);
-                if (!string.IsNullOrEmpty(subType))
+                if (subType != null && subType.Length > 0)
                 {
                     Log.LogMessageFromResources(MessageImportance.Normal, "ResolveAssemblyReference.IgnoringBecauseNonEmptySubtype", assembly.ItemSpec, subType);
                 }
@@ -2637,7 +2872,7 @@ private void FilterBySubtypeAndTargetFramework()
             }
 
             // Save the array of assemblies filtered by SubType==''.
-            Assemblies = (ITaskItem[])assembliesLeft.ToArray(typeof(ITaskItem));
+            _assemblyNames = (ITaskItem[])assembliesLeft.ToArray(typeof(ITaskItem));
         }
 
         /// <summary>
@@ -2714,7 +2949,7 @@ private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, SystemPr
         /// Execute the task.
         /// </summary>
         /// <returns>True if there was success.</returns>
-        public override bool Execute()
+        override public bool Execute()
         {
             return Execute
             (
