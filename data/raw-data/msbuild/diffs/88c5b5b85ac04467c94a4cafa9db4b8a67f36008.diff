diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index 93abec24663..0f2be626fca 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1168,7 +1168,7 @@ private void InitializeHost(bool throwOnExecute)
             TaskBuilderTestTask.TaskBuilderTestTaskFactory taskFactory = new TaskBuilderTestTask.TaskBuilderTestTaskFactory();
             taskFactory.ThrowOnExecute = throwOnExecute;
             string taskName = "TaskBuilderTestTask";
-            (_host as TaskExecutionHost)._UNITTESTONLY_TaskFactoryWrapper = new TaskFactoryWrapper(taskFactory, loadedType, taskName, null);
+            (_host as TaskExecutionHost)._UNITTESTONLY_TaskFactoryWrapper = new TaskFactoryWrapper(taskFactory, loadedType, loadInfo, taskName, null);
             _host.InitializeForTask
                 (
                 this,
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 77497354b7b..5d117b6822a 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -255,12 +255,12 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
 
             TaskRequirements requirements = TaskRequirements.None;
 
-            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasSTAThreadAttribute())
+            if (_taskFactoryWrapper.TaskFactoryTypeInformation.HasSTAThreadAttribute)
             {
                 requirements |= TaskRequirements.RequireSTAThread;
             }
 
-            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasLoadInSeparateAppDomainAttribute())
+            if (_taskFactoryWrapper.TaskFactoryTypeInformation.HasLoadInSeparateAppDomainAttribute)
             {
                 requirements |= TaskRequirements.RequireSeparateAppDomain;
 
@@ -297,7 +297,7 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It
             if (_resolver == null)
             {
                 _resolver = new TaskEngineAssemblyResolver();
-                _resolver.Initialize(_taskFactoryWrapper.TaskFactoryLoadedType.Assembly.AssemblyFile);
+                _resolver.Initialize(_taskFactoryWrapper.TaskFactoryAssemblyLoadInfo.AssemblyFile);
                 _resolver.InstallHandler();
             }
 #endif
@@ -919,12 +919,12 @@ private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskId
                 // Map to an intrinsic task, if necessary.
                 if (String.Equals(returnClass.TaskFactory.TaskType.FullName, "Microsoft.Build.Tasks.MSBuild", StringComparison.OrdinalIgnoreCase))
                 {
-                    returnClass = new TaskFactoryWrapper(new IntrinsicTaskFactory(typeof(MSBuild)), new LoadedType(typeof(MSBuild), AssemblyLoadInfo.Create(typeof(TaskExecutionHost).GetTypeInfo().Assembly.FullName, null)), _taskName, null);
+                    returnClass = new TaskFactoryWrapper(new IntrinsicTaskFactory(typeof(MSBuild)), new TypeInformation(new LoadedType(typeof(MSBuild), AssemblyLoadInfo.Create(typeof(TaskExecutionHost).GetTypeInfo().Assembly.FullName, null))), AssemblyLoadInfo.Create(typeof(TaskExecutionHost).GetTypeInfo().Assembly.FullName, null), _taskName, null);
                     _intrinsicTasks[_taskName] = returnClass;
                 }
                 else if (String.Equals(returnClass.TaskFactory.TaskType.FullName, "Microsoft.Build.Tasks.CallTarget", StringComparison.OrdinalIgnoreCase))
                 {
-                    returnClass = new TaskFactoryWrapper(new IntrinsicTaskFactory(typeof(CallTarget)), new LoadedType(typeof(CallTarget), AssemblyLoadInfo.Create(typeof(TaskExecutionHost).GetTypeInfo().Assembly.FullName, null)), _taskName, null);
+                    returnClass = new TaskFactoryWrapper(new IntrinsicTaskFactory(typeof(CallTarget)), new TypeInformation(new LoadedType(typeof(CallTarget), AssemblyLoadInfo.Create(typeof(TaskExecutionHost).GetTypeInfo().Assembly.FullName, null))), AssemblyLoadInfo.Create(typeof(TaskExecutionHost).GetTypeInfo().Assembly.FullName, null), _taskName, null);
                     _intrinsicTasks[_taskName] = returnClass;
                 }
             }
@@ -1095,30 +1095,15 @@ out parameterSet
                 else
                 {
                     // flag an error if we find a parameter that has no .NET property equivalent
-                    if (_taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly is null)
-                    {
-                        _taskLoggingContext.LogError
-                            (
-                            new BuildEventFileInfo( parameterLocation ),
-                            "UnexpectedTaskAttribute",
-                            parameterName,
-                            _taskName,
-                            _taskFactoryWrapper.TaskFactoryLoadedType.Type.Assembly.FullName,
-                            _taskFactoryWrapper.TaskFactoryLoadedType.Type.Assembly.Location
-                            );
-                    }
-                    else
-                    {
-                        _taskLoggingContext.LogError
-                            (
-                            new BuildEventFileInfo( parameterLocation ),
-                            "UnexpectedTaskAttribute",
-                            parameterName,
-                            _taskName,
-                            _taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly.FullName,
-                            _taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly.Location
-                            );
-                    }
+                    _taskLoggingContext.LogError
+                        (
+                        new BuildEventFileInfo( parameterLocation ),
+                        "UnexpectedTaskAttribute",
+                        parameterName,
+                        _taskName,
+                        _taskFactoryWrapper.TaskFactoryAssemblyLoadInfo.AssemblyName,
+                        _taskFactoryWrapper.TaskFactoryAssemblyLoadInfo.AssemblyLocation
+                        );
                 }
             }
             catch (AmbiguousMatchException)
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 4596be57f52..836565cd1e4 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.Reflection;
 using System.Threading.Tasks;
-
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -36,7 +35,7 @@ internal class AssemblyTaskFactory : ITaskFactory2
         /// <summary>
         /// The loaded type (type, assembly name / file) of the task wrapped by the factory
         /// </summary>
-        private LoadedType _loadedType;
+        private TypeInformation _typeInformation;
 
 #if FEATURE_APPDOMAIN
         /// <summary>
@@ -82,7 +81,7 @@ public string FactoryName
         {
             get
             {
-                return _loadedType.Assembly.AssemblyLocation;
+                return _typeInformation.LoadInfo.AssemblyLocation ?? _typeInformation.LoadedType.LoadedAssembly.Location;
             }
         }
 
@@ -91,7 +90,7 @@ public string FactoryName
         /// </summary>
         public Type TaskType
         {
-            get { return _loadedType.Type; }
+            get { return _typeInformation.LoadedType?.Type ?? Type.GetType(_typeInformation.TypeName, true, true); }
         }
 
         /// <summary>
@@ -145,7 +144,7 @@ public bool Initialize(string taskName, IDictionary<string, string> factoryIdent
         /// </summary>
         public TaskPropertyInfo[] GetTaskParameters()
         {
-            PropertyInfo[] infos = _loadedType.Type.GetProperties(BindingFlags.Instance | BindingFlags.Public);
+            PropertyInfo[] infos = _typeInformation.GetProperties(BindingFlags.Instance | BindingFlags.Public);
             var propertyInfos = new TaskPropertyInfo[infos.Length];
             for (int i = 0; i < infos.Length; i++)
             {
@@ -248,7 +247,7 @@ public void CleanupTask(ITask task)
         /// <summary>
         /// Initialize the factory from the task registry
         /// </summary>
-        internal LoadedType InitializeFactory
+        internal TypeInformation InitializeFactory
             (
                 AssemblyLoadInfo loadInfo,
                 string taskName,
@@ -275,8 +274,8 @@ string taskProjectFile
             {
                 ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
                 _taskName = taskName;
-                _loadedType = _typeLoader.Load(taskName, loadInfo);
-                ProjectErrorUtilities.VerifyThrowInvalidProject(_loadedType != null, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, String.Empty);
+                _typeInformation = _typeLoader.Load(taskName, loadInfo, taskHostFactoryExplicitlyRequested);
+                _typeInformation.LoadInfo = loadInfo;
             }
             catch (TargetInvocationException e)
             {
@@ -312,7 +311,7 @@ string taskProjectFile
                 ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
             }
 
-            return _loadedType;
+            return _typeInformation;
         }
 
         /// <summary>
@@ -365,7 +364,7 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
                     mergedParameters[XMakeAttributes.architecture] = XMakeAttributes.GetCurrentMSBuildArchitecture();
                 }
 
-                TaskHostTask task = new TaskHostTask(taskLocation, taskLoggingContext, buildComponentHost, mergedParameters, _loadedType
+                TaskHostTask task = new TaskHostTask(taskLocation, taskLoggingContext, buildComponentHost, mergedParameters, _typeInformation
 #if FEATURE_APPDOMAIN
                     , appDomainSetup
 #endif
@@ -374,17 +373,13 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
             }
             else
             {
-#if FEATURE_APPDOMAIN
-                AppDomain taskAppDomain = null;
-#endif
-
-                ITask taskInstance = TaskLoader.CreateTask(_loadedType, _taskName, taskLocation.File, taskLocation.Line, taskLocation.Column, new TaskLoader.LogError(ErrorLoggingDelegate)
+                ITask taskInstance = TaskLoader.CreateTask(_typeInformation, _taskName, taskLocation.File, taskLocation.Line, taskLocation.Column, new TaskLoader.LogError(ErrorLoggingDelegate)
 #if FEATURE_APPDOMAIN
                     , appDomainSetup
 #endif
                     , isOutOfProc
 #if FEATURE_APPDOMAIN
-                    , out taskAppDomain
+                    , out AppDomain taskAppDomain
 #endif
                     );
 
@@ -414,13 +409,13 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
             {
                 ErrorUtilities.VerifyThrowArgumentLength(taskName, "TaskName");
                 // Parameters match, so now we check to see if the task exists. 
-                return _typeLoader.ReflectionOnlyLoad(taskName, _loadedType.Assembly) != null;
+                return _typeLoader.ReflectionOnlyLoad(taskName, _typeInformation.LoadInfo) != null;
             }
             catch (TargetInvocationException e)
             {
                 // Exception thrown by the called code itself
                 // Log the stack, so the task vendor can fix their code
-                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, _loadedType.Assembly.AssemblyLocation, Environment.NewLine + e.InnerException.ToString());
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, _typeInformation.LoadInfo.AssemblyLocation ?? _typeInformation.LoadedType.Assembly.AssemblyLocation, Environment.NewLine + e.InnerException.ToString());
             }
             catch (ReflectionTypeLoadException e)
             {
@@ -429,16 +424,16 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
                 {
                     if (exception != null)
                     {
-                        targetLoggingContext.LogError(new BuildEventFileInfo(taskProjectFile), "TaskLoadFailure", taskName, _loadedType.Assembly.AssemblyLocation, exception.Message);
+                        targetLoggingContext.LogError(new BuildEventFileInfo(taskProjectFile), "TaskLoadFailure", taskName, _typeInformation.LoadInfo.AssemblyLocation ?? _typeInformation.LoadedType.Assembly.AssemblyLocation, exception.Message);
                     }
                 }
 
-                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, _loadedType.Assembly.AssemblyLocation, e.Message);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, _typeInformation.LoadInfo.AssemblyLocation ?? _typeInformation.LoadedType.Assembly.AssemblyLocation, e.Message);
             }
             catch (ArgumentNullException e)
             {
                 // taskName may be null
-                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, _loadedType.Assembly.AssemblyLocation, e.Message);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, _typeInformation.LoadInfo.AssemblyLocation ?? _typeInformation.LoadedType.Assembly.AssemblyLocation, e.Message);
             }
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
@@ -447,7 +442,7 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
                     throw;
                 }
 
-                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, _loadedType.Assembly.AssemblyLocation, e.Message);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, _typeInformation.LoadInfo.AssemblyLocation ?? _typeInformation.LoadedType.Assembly.AssemblyLocation, e.Message);
             }
 
             return false;
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 99bc7663895..8fad81079da 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.BackEnd.Logging;
+using System.Linq;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -72,7 +73,7 @@ internal class TaskHostTask : IGeneratedTask, ICancelableTask, INodePacketFactor
         /// <summary>
         /// The type of the task that we are wrapping.  
         /// </summary>
-        private LoadedType _taskType;
+        private TypeInformation _taskType;
 
 #if FEATURE_APPDOMAIN
         /// <summary>
@@ -122,7 +123,7 @@ internal class TaskHostTask : IGeneratedTask, ICancelableTask, INodePacketFactor
         /// <summary>
         /// Constructor
         /// </summary>
-        public TaskHostTask(IElementLocation taskLocation, TaskLoggingContext taskLoggingContext, IBuildComponentHost buildComponentHost, IDictionary<string, string> taskHostParameters, LoadedType taskType
+        public TaskHostTask(IElementLocation taskLocation, TaskLoggingContext taskLoggingContext, IBuildComponentHost buildComponentHost, IDictionary<string, string> taskHostParameters, TypeInformation taskType
 #if FEATURE_APPDOMAIN
                 , AppDomainSetup appDomainSetup
 #endif
@@ -210,7 +211,7 @@ public object GetPropertyValue(TaskPropertyInfo property)
             }
             else
             {
-                PropertyInfo parameter = _taskType.Type.GetProperty(property.Name, BindingFlags.Instance | BindingFlags.Public);
+                PropertyInfo parameter = _taskType.GetProperties(BindingFlags.Instance | BindingFlags.Public).Where(p => p.Name.Equals(property.Name)).FirstOrDefault();
                 return parameter.GetValue(this, null);
             }
         }
@@ -242,7 +243,7 @@ public bool Execute()
             // log that we are about to spawn the task host
             string runtime = _taskHostParameters[XMakeAttributes.runtime];
             string architecture = _taskHostParameters[XMakeAttributes.architecture];
-            _taskLoggingContext.LogComment(MessageImportance.Low, "ExecutingTaskInTaskHost", _taskType.Type.Name, _taskType.Assembly.AssemblyLocation, runtime, architecture);
+            _taskLoggingContext.LogComment(MessageImportance.Low, "ExecutingTaskInTaskHost", _taskType.TypeName, _taskType.LoadInfo.AssemblyLocation ?? _taskType.LoadedType.LoadedAssembly.Location, runtime, architecture);
 
             // set up the node
             lock (_taskHostLock)
@@ -266,8 +267,8 @@ public bool Execute()
                         BuildEngine.ColumnNumberOfTaskNode,
                         BuildEngine.ProjectFileOfTaskNode,
                         BuildEngine.ContinueOnError,
-                        _taskType.Type.FullName,
-                        AssemblyUtilities.GetAssemblyLocation(_taskType.Type.GetTypeInfo().Assembly),
+                        _taskType.TypeName,
+                        _taskType.LoadInfo.AssemblyLocation ?? _taskType.LoadedType.LoadedAssembly.Location,
                         _buildComponentHost.BuildParameters.LogTaskInputs,
                         _setParameters,
                         new Dictionary<string, string>(_buildComponentHost.BuildParameters.GlobalProperties),
@@ -463,8 +464,8 @@ private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplet
                 }
                 else
                 {
-                    exceptionMessageArgs = new string[] { _taskType.Type.Name,
-                        AssemblyUtilities.GetAssemblyLocation(_taskType.Type.GetTypeInfo().Assembly),
+                    exceptionMessageArgs = new string[] { _taskType.TypeName,
+                        _taskType.LoadInfo.AssemblyLocation ?? _taskType.LoadedType.LoadedAssembly.Location,
                         string.Empty };
                 }
 
@@ -556,11 +557,11 @@ private void LogErrorUnableToCreateTaskHost(HandshakeOptions requiredContext, st
 
             if (e == null)
             {
-                _taskLoggingContext.LogError(new BuildEventFileInfo(_taskLocation), "TaskHostAcquireFailed", _taskType.Type.Name, runtime, architecture, msbuildLocation);
+                _taskLoggingContext.LogError(new BuildEventFileInfo(_taskLocation), "TaskHostAcquireFailed", _taskType.TypeName, runtime, architecture, msbuildLocation);
             }
             else
             {
-                _taskLoggingContext.LogError(new BuildEventFileInfo(_taskLocation), "TaskHostNodeFailedToLaunch", _taskType.Type.Name, runtime, architecture, msbuildLocation, e.ErrorCode, e.Message);
+                _taskLoggingContext.LogError(new BuildEventFileInfo(_taskLocation), "TaskHostNodeFailedToLaunch", _taskType.TypeName, runtime, architecture, msbuildLocation, e.ErrorCode, e.Message);
             }
         }
     }
diff --git a/src/Build/Instance/TaskFactoryWrapper.cs b/src/Build/Instance/TaskFactoryWrapper.cs
index f097932a8e6..2ce6fc0de37 100644
--- a/src/Build/Instance/TaskFactoryWrapper.cs
+++ b/src/Build/Instance/TaskFactoryWrapper.cs
@@ -60,13 +60,14 @@ internal sealed class TaskFactoryWrapper
         /// <summary>
         /// Creates an instance of this class for the given type.
         /// </summary>
-        internal TaskFactoryWrapper(ITaskFactory taskFactory, LoadedType taskFactoryLoadInfo, string taskName, IDictionary<string, string> factoryIdentityParameters)
+        internal TaskFactoryWrapper(ITaskFactory taskFactory, TypeInformation taskFactoryLoadInfo, AssemblyLoadInfo taskFactoryAssemblyLoadInfo, string taskName, IDictionary<string, string> factoryIdentityParameters)
         {
             ErrorUtilities.VerifyThrowArgumentNull(taskFactory, nameof(taskFactory));
             ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
             _taskFactory = taskFactory;
             _taskName = taskName;
-            TaskFactoryLoadedType = taskFactoryLoadInfo;
+            TaskFactoryTypeInformation = taskFactoryLoadInfo;
+            TaskFactoryAssemblyLoadInfo = taskFactoryAssemblyLoadInfo;
             _factoryIdentityParameters = factoryIdentityParameters;
         }
 
@@ -77,7 +78,13 @@ internal TaskFactoryWrapper(ITaskFactory taskFactory, LoadedType taskFactoryLoad
         /// <summary>
         /// Load information about the task factory itself
         /// </summary>
-        public LoadedType TaskFactoryLoadedType
+        public TypeInformation TaskFactoryTypeInformation
+        {
+            get;
+            private set;
+        }
+
+        public AssemblyLoadInfo TaskFactoryAssemblyLoadInfo
         {
             get;
             private set;
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index a44626cccae..4377f3ce0e0 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -434,7 +434,7 @@ ElementLocation elementLocation
                         targetLoggingContext.LogComment(MessageImportance.Low, "TaskFoundFromFactory", taskName, taskFactory.Name);
                     }
 
-                    if (taskFactory.TaskFactoryLoadedType.HasSTAThreadAttribute())
+                    if (taskFactory.TaskFactoryTypeInformation.HasSTAThreadAttribute)
                     {
                         targetLoggingContext.LogComment(MessageImportance.Low, "TaskNeedsSTA", taskName);
                     }
@@ -1287,7 +1287,7 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                     AssemblyLoadInfo taskFactoryLoadInfo = TaskFactoryAssemblyLoadInfo;
                     ErrorUtilities.VerifyThrow(taskFactoryLoadInfo != null, "TaskFactoryLoadInfo should never be null");
                     ITaskFactory factory = null;
-                    LoadedType loadedType = null;
+                    TypeInformation typeInformation = null;
 
                     bool isAssemblyTaskFactory = String.Equals(TaskFactoryAttributeName, AssemblyTaskFactory, StringComparison.OrdinalIgnoreCase);
                     bool isTaskHostFactory = String.Equals(TaskFactoryAttributeName, TaskHostFactory, StringComparison.OrdinalIgnoreCase);
@@ -1303,8 +1303,8 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                             );
 
                         // Create an instance of the internal assembly task factory, it has the error handling built into its methods.
-                        AssemblyTaskFactory taskFactory = new AssemblyTaskFactory();
-                        loadedType = taskFactory.InitializeFactory(taskFactoryLoadInfo, RegisteredName, ParameterGroupAndTaskBody.UsingTaskParameters, ParameterGroupAndTaskBody.InlineTaskXmlBody, TaskFactoryParameters, explicitlyLaunchTaskHost, targetLoggingContext, elementLocation, taskProjectFile);
+                        AssemblyTaskFactory taskFactory = new();
+                        typeInformation = taskFactory.InitializeFactory(taskFactoryLoadInfo, RegisteredName, ParameterGroupAndTaskBody.UsingTaskParameters, ParameterGroupAndTaskBody.InlineTaskXmlBody, TaskFactoryParameters, explicitlyLaunchTaskHost, targetLoggingContext, elementLocation, taskProjectFile);
                         factory = taskFactory;
                     }
                     else
@@ -1330,9 +1330,9 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                                 }
 
                                 // Make sure we only look for task factory classes when loading based on the name
-                                loadedType = s_taskFactoryTypeLoader.Load(TaskFactoryAttributeName, taskFactoryLoadInfo);
+                                typeInformation = s_taskFactoryTypeLoader.Load(TaskFactoryAttributeName, taskFactoryLoadInfo, false);
 
-                                if (loadedType == null)
+                                if (typeInformation == null)
                                 {
                                     // We could not find the type (this is what null means from the Load method) but there is no reason given so we can only log the fact that 
                                     // we could not find the name given in the task factory attribute in the class specified in the assembly File or assemblyName fields.
@@ -1375,9 +1375,9 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                                 // We have loaded the type, lets now try and construct it
                                 // Any exceptions from the constructor of the task factory will be caught lower down and turned into an InvalidProjectFileExceptions
 #if FEATURE_APPDOMAIN
-                                factory = (ITaskFactory)AppDomain.CurrentDomain.CreateInstanceAndUnwrap(loadedType.Type.GetTypeInfo().Assembly.FullName, loadedType.Type.FullName);
+                                factory = (ITaskFactory)AppDomain.CurrentDomain.CreateInstanceAndUnwrap(typeInformation.LoadInfo.AssemblyName ?? typeInformation.LoadedType.Type.GetTypeInfo().Assembly.FullName, typeInformation.TypeName);
 #else
-                                factory = (ITaskFactory) Activator.CreateInstance(loadedType.Type);
+                                factory = (ITaskFactory) Activator.CreateInstance(typeInformation.LoadInfo.AssemblyName ?? typeInformation.LoadedType.LoadedAssembly.FullName, typeInformation.TypeName);
 #endif
                                 TaskFactoryLoggingHost taskFactoryLoggingHost = new TaskFactoryLoggingHost(true /*I dont have the data at this point, the safest thing to do is make sure events are serializable*/, elementLocation, targetLoggingContext);
 
@@ -1473,7 +1473,7 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                         }
                     }
 
-                    _taskFactoryWrapperInstance = new TaskFactoryWrapper(factory, loadedType, RegisteredName, TaskFactoryParameters);
+                    _taskFactoryWrapperInstance = new TaskFactoryWrapper(factory, typeInformation, TaskFactoryAssemblyLoadInfo, RegisteredName, TaskFactoryParameters);
                 }
 
                 return true;
diff --git a/src/Build/Logging/LoggerDescription.cs b/src/Build/Logging/LoggerDescription.cs
index f50a53d0e68..dfce31973bf 100644
--- a/src/Build/Logging/LoggerDescription.cs
+++ b/src/Build/Logging/LoggerDescription.cs
@@ -212,7 +212,7 @@ private ILogger CreateLogger(bool forwardingLogger)
                 if (forwardingLogger)
                 {
                     // load the logger from its assembly
-                    LoadedType loggerClass = (new TypeLoader(s_forwardingLoggerClassFilter)).Load(_loggerClassName, _loggerAssembly);
+                    LoadedType loggerClass = (new TypeLoader(s_forwardingLoggerClassFilter)).Load(_loggerClassName, _loggerAssembly, false).LoadedType;
 
                     if (loggerClass != null)
                     {
@@ -223,7 +223,7 @@ private ILogger CreateLogger(bool forwardingLogger)
                 else
                 {
                     // load the logger from its assembly
-                    LoadedType loggerClass = (new TypeLoader(s_loggerClassFilter)).Load(_loggerClassName, _loggerAssembly);
+                    LoadedType loggerClass = (new TypeLoader(s_loggerClassFilter)).Load(_loggerClassName, _loggerAssembly, false).LoadedType;
 
                     if (loggerClass != null)
                     {
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index cbfee6c66db..681568a8914 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -35,7 +35,7 @@
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
     <PackageReference Include="System.Text.Json" />
 
-    <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
+    <PackageReference Include="System.Reflection.Metadata" />
 
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
   </ItemGroup>
@@ -47,7 +47,6 @@
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <PackageReference Include="System.Reflection.Metadata" />
     <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Text.Encoding.CodePages" />
     <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
@@ -722,6 +721,10 @@
       <Link>SharedUtilities\LoadedType.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\TypeInformation.cs">
+      <Link>SharedUtilities\TypeInformation.cs</Link>
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="..\Shared\InprocTrackingNativeMethods.cs">
       <Link>InprocTrackingNativeMethods.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 348be39ffa6..552daadad6b 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -135,8 +135,9 @@
     <Compile Include="..\Shared\TaskLoader.cs" />
     <Compile Include="..\Shared\MSBuildLoadContext.cs" Condition="'$(TargetFrameworkIdentifier)'!='.NETFramework'" />
     <Compile Include="..\Shared\TypeLoader.cs" />
+	<Compile Include="..\Shared\TypeInformation.cs" />
     <Compile Include="..\Shared\LoadedType.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+	   <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\AssemblyLoadInfo.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index b1f085e2da1..337baacedf9 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -115,7 +115,7 @@ IDictionary<string, TaskParameter> taskParams
             try
             {
                 TypeLoader typeLoader = new TypeLoader(TaskLoader.IsTaskClass);
-                taskType = typeLoader.Load(taskName, AssemblyLoadInfo.Create(null, taskLocation));
+                taskType = typeLoader.Load(taskName, AssemblyLoadInfo.Create(null, taskLocation), false).LoadedType;
             }
             catch (Exception e)
             {
@@ -309,7 +309,7 @@ IDictionary<string, TaskParameter> taskParams
 
             try
             {
-                wrappedTask = TaskLoader.CreateTask(taskType, taskName, taskFile, taskLine, taskColumn, new TaskLoader.LogError(LogErrorDelegate),
+                wrappedTask = TaskLoader.CreateTask(new TypeInformation(taskType), taskName, taskFile, taskLine, taskColumn, new TaskLoader.LogError(LogErrorDelegate),
 #if FEATURE_APPDOMAIN
                     appDomainSetup,
 #endif
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index a2e79399940..b93931c9015 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -176,7 +176,8 @@
     </Compile>
     <Compile Include="..\Shared\TaskLoader.cs" />
     <Compile Include="..\Shared\LoadedType.cs" />
-    <Compile Include="..\Shared\AssemblyLoadInfo.cs" />
+	<Compile Include="..\Shared\TypeInformation.cs" />
+	<Compile Include="..\Shared\AssemblyLoadInfo.cs" />
     <Compile Include="..\Shared\TaskHostTaskCancelled.cs" />
     <Compile Include="..\Shared\TaskParameter.cs" />
     <Compile Include="..\Shared\AssemblyNameExtension.cs" />
diff --git a/src/MSBuildTaskHost/TypeLoader.cs b/src/MSBuildTaskHost/TypeLoader.cs
index 59579d98cac..033af6c3290 100644
--- a/src/MSBuildTaskHost/TypeLoader.cs
+++ b/src/MSBuildTaskHost/TypeLoader.cs
@@ -125,10 +125,11 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
         /// any) is unambiguous; otherwise, if there are multiple types with the same name in different namespaces, the first type
         /// found will be returned.
         /// </summary>
-        internal LoadedType Load
+        internal TypeInformation Load
         (
             string typeName,
-            AssemblyLoadInfo assembly
+            AssemblyLoadInfo assembly,
+            bool taskHostFactoryExplicitlyRequested
         )
         {
             return GetLoadedType(s_cacheOfLoadedTypesByFilter, typeName, assembly);
@@ -146,7 +147,7 @@ internal LoadedType ReflectionOnlyLoad
             AssemblyLoadInfo assembly
         )
         {
-            return GetLoadedType(s_cacheOfReflectionOnlyLoadedTypesByFilter, typeName, assembly);
+            return GetLoadedType(s_cacheOfReflectionOnlyLoadedTypesByFilter, typeName, assembly).LoadedType;
         }
 
         /// <summary>
@@ -154,7 +155,7 @@ AssemblyLoadInfo assembly
         /// any) is unambiguous; otherwise, if there are multiple types with the same name in different namespaces, the first type
         /// found will be returned.
         /// </summary>
-        private LoadedType GetLoadedType(Concurrent.ConcurrentDictionary<TypeFilter, Concurrent.ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly)
+        private TypeInformation GetLoadedType(Concurrent.ConcurrentDictionary<TypeFilter, Concurrent.ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly)
         {
             // A given type filter have been used on a number of assemblies, Based on the type filter we will get another dictionary which 
             // will map a specific AssemblyLoadInfo to a AssemblyInfoToLoadedTypes class which knows how to find a typeName in a given assembly.
@@ -231,7 +232,7 @@ internal AssemblyInfoToLoadedTypes(TypeFilter typeFilter, AssemblyLoadInfo loadI
             /// <summary>
             /// Determine if a given type name is in the assembly or not. Return null if the type is not in the assembly
             /// </summary>
-            internal LoadedType GetLoadedTypeByTypeName(string typeName)
+            internal TypeInformation GetLoadedTypeByTypeName(string typeName)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(typeName, nameof(typeName));
 
@@ -282,7 +283,7 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)
                     return null;
                 });
 
-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;
+                return type != null ? new TypeInformation() { LoadedType = new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) } : null;
             }
 
             /// <summary>
diff --git a/src/Shared/LoadedType.cs b/src/Shared/LoadedType.cs
index b1cdebf4649..b5169d475dd 100644
--- a/src/Shared/LoadedType.cs
+++ b/src/Shared/LoadedType.cs
@@ -90,7 +90,7 @@ private void CheckForHardcodedSTARequirement()
             {
                 AssemblyName assemblyName = _type.GetTypeInfo().Assembly.GetName();
                 Version lastVersionToForce = new Version(3, 5);
-                if (assemblyName.Version.CompareTo(lastVersionToForce) > 0)
+                if (assemblyName.Version > lastVersionToForce)
                 {
                     if (String.Equals(assemblyName.Name, "PresentationBuildTasks", StringComparison.OrdinalIgnoreCase))
                     {
diff --git a/src/Shared/TaskLoader.cs b/src/Shared/TaskLoader.cs
index 5388f15d8e6..e0dce14cd65 100644
--- a/src/Shared/TaskLoader.cs
+++ b/src/Shared/TaskLoader.cs
@@ -19,7 +19,7 @@ internal static class TaskLoader
         /// For saving the assembly that was loaded by the TypeLoader
         /// We only use this when the assembly failed to load properly into the appdomain
         /// </summary>
-        private static LoadedType s_resolverLoadedType;
+        private static TypeInformation s_resolverTypeInformation;
 #endif
 
         /// <summary>
@@ -45,7 +45,7 @@ internal static bool IsTaskClass(Type type, object unused)
         /// <summary>
         /// Creates an ITask instance and returns it.  
         /// </summary>
-        internal static ITask CreateTask(LoadedType loadedType, string taskName, string taskLocation, int taskLine, int taskColumn, LogError logError
+        internal static ITask CreateTask(TypeInformation typeInformation, string taskName, string taskLocation, int taskLine, int taskColumn, LogError logError
 #if FEATURE_APPDOMAIN
             , AppDomainSetup appDomainSetup
 #endif
@@ -56,8 +56,8 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
             )
         {
 #if FEATURE_APPDOMAIN
-            bool separateAppDomain = loadedType.HasLoadInSeparateAppDomainAttribute();
-            s_resolverLoadedType = null;
+            bool separateAppDomain = typeInformation.HasLoadInSeparateAppDomainAttribute;
+            s_resolverTypeInformation = null;
             taskAppDomain = null;
             ITask taskInstanceInOtherAppDomain = null;
 #endif
@@ -67,7 +67,7 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
 #if FEATURE_APPDOMAIN
                 if (separateAppDomain)
                 {
-                    if (!loadedType.Type.GetTypeInfo().IsMarshalByRef)
+                    if (!typeInformation.IsMarshallByRef)
                     {
                         logError
                         (
@@ -104,13 +104,13 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
                         }
 
                         AppDomain.CurrentDomain.AssemblyResolve += AssemblyResolver;
-                        s_resolverLoadedType = loadedType;
+                        s_resolverTypeInformation = typeInformation;
 
                         taskAppDomain = AppDomain.CreateDomain(isOutOfProc ? "taskAppDomain (out-of-proc)" : "taskAppDomain (in-proc)", null, appDomainInfo);
 
-                        if (loadedType.LoadedAssembly != null)
+                        if (typeInformation.LoadedType.LoadedAssembly != null)
                         {
-                            taskAppDomain.Load(loadedType.LoadedAssembly.GetName());
+                            taskAppDomain.Load(typeInformation.AssemblyName);
                         }
 
 #if FEATURE_APPDOMAIN_UNHANDLED_EXCEPTION
@@ -124,13 +124,13 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
                 {
                     // perf improvement for the same appdomain case - we already have the type object
                     // and don't want to go through reflection to recreate it from the name.
-                    return (ITask)Activator.CreateInstance(loadedType.Type);
+                    return (ITask)Activator.CreateInstance(typeInformation.LoadInfo.AssemblyName ?? typeInformation.LoadedType.Assembly.AssemblyName, typeInformation.TypeName);
                 }
 
 #if FEATURE_APPDOMAIN
-                if (loadedType.Assembly.AssemblyFile != null)
+                if ((typeInformation.LoadInfo.AssemblyFile ?? typeInformation.LoadedType.Assembly.AssemblyFile) != null)
                 {
-                    taskInstanceInOtherAppDomain = (ITask)taskAppDomain.CreateInstanceFromAndUnwrap(loadedType.Assembly.AssemblyFile, loadedType.Type.FullName);
+                    taskInstanceInOtherAppDomain = (ITask)taskAppDomain.CreateInstanceFromAndUnwrap(typeInformation.LoadInfo.AssemblyFile ?? typeInformation.LoadedType.Assembly.AssemblyFile, typeInformation.TypeName);
 
                     // this will force evaluation of the task class type and try to load the task assembly
                     Type taskType = taskInstanceInOtherAppDomain.GetType();
@@ -146,8 +146,8 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
                         taskLine,
                         taskColumn,
                         "ConflictingTaskAssembly",
-                        loadedType.Assembly.AssemblyFile,
-                        loadedType.Type.GetTypeInfo().Assembly.Location
+                        typeInformation.LoadInfo.AssemblyFile ?? typeInformation.LoadedType.Assembly.AssemblyFile,
+                        typeInformation.LoadInfo.AssemblyLocation ?? typeInformation.LoadedType.Type.GetTypeInfo().Assembly.Location
                         );
 
                         taskInstanceInOtherAppDomain = null;
@@ -155,7 +155,7 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
                 }
                 else
                 {
-                    taskInstanceInOtherAppDomain = (ITask)taskAppDomain.CreateInstanceAndUnwrap(loadedType.Type.GetTypeInfo().Assembly.FullName, loadedType.Type.FullName);
+                    taskInstanceInOtherAppDomain = (ITask)taskAppDomain.CreateInstanceAndUnwrap(typeInformation.LoadInfo.AssemblyName ?? typeInformation.LoadedType.Type.GetTypeInfo().Assembly.FullName, typeInformation.TypeName);
                 }
 
                 return taskInstanceInOtherAppDomain;
@@ -181,12 +181,12 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
         /// </summary>
         internal static Assembly AssemblyResolver(object sender, ResolveEventArgs args)
         {
-            if ((s_resolverLoadedType?.LoadedAssembly != null))
+            if ((s_resolverTypeInformation?.LoadedType?.LoadedAssembly != null))
             {
                 // Match the name being requested by the resolver with the FullName of the assembly we have loaded
-                if (args.Name.Equals(s_resolverLoadedType.LoadedAssembly.FullName, StringComparison.Ordinal))
+                if (args.Name.Equals(s_resolverTypeInformation.LoadedType.LoadedAssembly.FullName, StringComparison.Ordinal))
                 {
-                    return s_resolverLoadedType.LoadedAssembly;
+                    return s_resolverTypeInformation.LoadedType.LoadedAssembly;
                 }
             }
 
@@ -198,10 +198,10 @@ internal static Assembly AssemblyResolver(object sender, ResolveEventArgs args)
         /// </summary>
         internal static void RemoveAssemblyResolver()
         {
-            if (s_resolverLoadedType != null)
+            if (s_resolverTypeInformation != null)
             {
                 AppDomain.CurrentDomain.AssemblyResolve -= AssemblyResolver;
-                s_resolverLoadedType = null;
+                s_resolverTypeInformation = null;
             }
         }
 #endif
diff --git a/src/Shared/TypeInformation.cs b/src/Shared/TypeInformation.cs
new file mode 100644
index 00000000000..e1c684209b5
--- /dev/null
+++ b/src/Shared/TypeInformation.cs
@@ -0,0 +1,44 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Reflection;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Shared
+{
+    internal sealed class TypeInformation
+    {
+        internal AssemblyLoadInfo LoadInfo { get; set; }
+        internal string TypeName { get; set; }
+        internal string AssemblyLocation { get; set; }
+
+        internal LoadedType LoadedType { get; set; }
+
+        internal bool HasSTAThreadAttribute { get; set; }
+        internal bool HasLoadInSeparateAppDomainAttribute { get; set; }
+        internal bool IsMarshallByRef { get; set; }
+        internal bool ImplementsIGeneratedTask { get; set; }
+        internal AssemblyName AssemblyName { get; set; }
+        internal Func<BindingFlags, PropertyInfo[]> GetProperties { get; set; }
+
+        internal TypeInformation()
+        {
+        }
+
+        internal TypeInformation(LoadedType baseType)
+        {
+            LoadedType = baseType;
+            HasSTAThreadAttribute = LoadedType.HasSTAThreadAttribute();
+            HasLoadInSeparateAppDomainAttribute = LoadedType.HasLoadInSeparateAppDomainAttribute();
+            IsMarshallByRef = LoadedType.Type.GetTypeInfo().IsMarshalByRef;
+#if TASKHOST
+            ImplementsIGeneratedTask = false;
+#else
+            ImplementsIGeneratedTask = LoadedType.Type is IGeneratedTask;
+#endif
+            AssemblyName = LoadedType.LoadedAssembly.GetName();
+            GetProperties = bindingAttr => LoadedType.Type.GetProperties(bindingAttr);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 7f879afa8aa..e585bf50329 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -8,6 +8,8 @@
 using System.Diagnostics.CodeAnalysis;
 using System.IO;
 using System.Reflection;
+using System.Reflection.Metadata;
+using System.Reflection.PortableExecutable;
 using System.Threading;
 
 namespace Microsoft.Build.Shared
@@ -183,13 +185,14 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)
         /// any) is unambiguous; otherwise, if there are multiple types with the same name in different namespaces, the first type
         /// found will be returned.
         /// </summary>
-        internal LoadedType Load
+        internal TypeInformation Load
         (
             string typeName,
-            AssemblyLoadInfo assembly
+            AssemblyLoadInfo assembly,
+            bool taskHostFactoryExplicitlyRequested
         )
         {
-            return GetLoadedType(s_cacheOfLoadedTypesByFilter, typeName, assembly);
+            return GetLoadedType(s_cacheOfLoadedTypesByFilter, typeName, assembly, taskHostFactoryExplicitlyRequested);
         }
 
         /// <summary>
@@ -204,7 +207,7 @@ internal LoadedType ReflectionOnlyLoad
             AssemblyLoadInfo assembly
         )
         {
-            return GetLoadedType(s_cacheOfReflectionOnlyLoadedTypesByFilter, typeName, assembly);
+            return GetLoadedType(s_cacheOfReflectionOnlyLoadedTypesByFilter, typeName, assembly, false).LoadedType;
         }
 
         /// <summary>
@@ -212,7 +215,11 @@ AssemblyLoadInfo assembly
         /// any) is unambiguous; otherwise, if there are multiple types with the same name in different namespaces, the first type
         /// found will be returned.
         /// </summary>
-        private LoadedType GetLoadedType(ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly)
+        private TypeInformation GetLoadedType(
+            ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache,
+            string typeName,
+            AssemblyLoadInfo assembly,
+            bool taskHostFactoryExplicitlyRequested)
         {
             // A given type filter have been used on a number of assemblies, Based on the type filter we will get another dictionary which 
             // will map a specific AssemblyLoadInfo to a AssemblyInfoToLoadedTypes class which knows how to find a typeName in a given assembly.
@@ -223,7 +230,7 @@ private LoadedType GetLoadedType(ConcurrentDictionary<Func<Type, object, bool>,
             AssemblyInfoToLoadedTypes typeNameToType =
                 loadInfoToType.GetOrAdd(assembly, (_) => new AssemblyInfoToLoadedTypes(_isDesiredType, _));
 
-            return typeNameToType.GetLoadedTypeByTypeName(typeName);
+            return typeNameToType.GetLoadedTypeByTypeName(typeName, taskHostFactoryExplicitlyRequested);
         }
 
         /// <summary>
@@ -290,12 +297,11 @@ internal AssemblyInfoToLoadedTypes(Func<Type, object, bool> typeFilter, Assembly
             /// <summary>
             /// Determine if a given type name is in the assembly or not. Return null if the type is not in the assembly
             /// </summary>
-            internal LoadedType GetLoadedTypeByTypeName(string typeName)
+            internal TypeInformation GetLoadedTypeByTypeName(string typeName, bool taskHostFactoryExplicitlyRequested)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(typeName, nameof(typeName));
 
                 // Only one thread should be doing operations on this instance of the object at a time.
-
                 Type type = _typeNameToType.GetOrAdd(typeName, (key) =>
                 {
                     if ((_assemblyLoadInfo.AssemblyName != null) && (typeName.Length > 0))
@@ -317,31 +323,56 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)
                         }
                     }
 
-                    if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)
+                    if (!taskHostFactoryExplicitlyRequested)
                     {
-                        lock (_lockObject)
+                        if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)
                         {
-                            if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)
+                            lock (_lockObject)
                             {
-                                ScanAssemblyForPublicTypes();
-                                Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);
+                                if (Interlocked.Read(ref _haveScannedPublicTypes) == 0)
+                                {
+                                    ScanAssemblyForPublicTypes();
+                                    Interlocked.Exchange(ref _haveScannedPublicTypes, ~0);
+                                }
                             }
                         }
-                    }
 
-                    foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)
-                    {
-                        // if type matches partially on its name
-                        if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))
+                        foreach (KeyValuePair<string, Type> desiredTypeInAssembly in _publicTypeNameToType)
                         {
-                            return desiredTypeInAssembly.Value;
+                            // if type matches partially on its name
+                            if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(desiredTypeInAssembly.Key, typeName))
+                            {
+                                return desiredTypeInAssembly.Value;
+                            }
                         }
                     }
 
                     return null;
                 });
 
-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;
+                if (type is null)
+                {
+                    TypeInformation typeInformation = new();
+                    if (_assemblyLoadInfo.AssemblyFile != null)
+                    {
+                        using (FileStream stream = File.OpenRead(_assemblyLoadInfo.AssemblyFile))
+                        using (PEReader peFile = new(stream))
+                        {
+                            MetadataReader metadataReader = peFile.GetMetadataReader();
+                            AssemblyDefinition assemblyDef = metadataReader.GetAssemblyDefinition();
+                            foreach (TypeDefinitionHandle typeDefHandle in metadataReader.TypeDefinitions)
+                            {
+                                TypeDefinition typeDef = metadataReader.GetTypeDefinition(typeDefHandle);
+                                foreach (var attr in typeDef.Attributes) ;
+                            }
+                        }
+                    }
+                    return typeInformation;
+                }
+                else
+                {
+                    return new TypeInformation() { LoadedType = new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) };
+                }
             }
 
             /// <summary>
diff --git a/src/Shared/UnitTests/TypeLoader_Tests.cs b/src/Shared/UnitTests/TypeLoader_Tests.cs
index a572f51576a..be185b4288f 100644
--- a/src/Shared/UnitTests/TypeLoader_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Tests.cs
@@ -198,13 +198,13 @@ public void Regress640476PartialName()
         {
             string forwardingLoggerLocation = typeof(Microsoft.Build.Logging.ConfigurableForwardingLogger).Assembly.Location;
             TypeLoader loader = new TypeLoader(IsForwardingLoggerClass);
-            LoadedType loadedType = loader.Load("ConfigurableForwardingLogger", AssemblyLoadInfo.Create(null, forwardingLoggerLocation));
+            LoadedType loadedType = loader.Load("ConfigurableForwardingLogger", AssemblyLoadInfo.Create(null, forwardingLoggerLocation), false).LoadedType;
             Assert.NotNull(loadedType);
             Assert.Equal(forwardingLoggerLocation, loadedType.Assembly.AssemblyLocation);
 
             string fileLoggerLocation = typeof(Microsoft.Build.Logging.FileLogger).Assembly.Location;
             loader = new TypeLoader(IsLoggerClass);
-            loadedType = loader.Load("FileLogger", AssemblyLoadInfo.Create(null, fileLoggerLocation));
+            loadedType = loader.Load("FileLogger", AssemblyLoadInfo.Create(null, fileLoggerLocation), false).LoadedType;
             Assert.NotNull(loadedType);
             Assert.Equal(fileLoggerLocation, loadedType.Assembly.AssemblyLocation);
         }
@@ -219,14 +219,14 @@ public void Regress640476FullyQualifiedName()
             Type forwardingLoggerType = typeof(Microsoft.Build.Logging.ConfigurableForwardingLogger);
             string forwardingLoggerLocation = forwardingLoggerType.Assembly.Location;
             TypeLoader loader = new TypeLoader(IsForwardingLoggerClass);
-            LoadedType loadedType = loader.Load(forwardingLoggerType.FullName, AssemblyLoadInfo.Create(null, forwardingLoggerLocation));
+            LoadedType loadedType = loader.Load(forwardingLoggerType.FullName, AssemblyLoadInfo.Create(null, forwardingLoggerLocation), false).LoadedType;
             Assert.NotNull(loadedType);
             Assert.Equal(forwardingLoggerLocation, loadedType.Assembly.AssemblyLocation);
 
             Type fileLoggerType = typeof(Microsoft.Build.Logging.FileLogger);
             string fileLoggerLocation = fileLoggerType.Assembly.Location;
             loader = new TypeLoader(IsLoggerClass);
-            loadedType = loader.Load(fileLoggerType.FullName, AssemblyLoadInfo.Create(null, fileLoggerLocation));
+            loadedType = loader.Load(fileLoggerType.FullName, AssemblyLoadInfo.Create(null, fileLoggerLocation), false).LoadedType;
             Assert.NotNull(loadedType);
             Assert.Equal(fileLoggerLocation, loadedType.Assembly.AssemblyLocation);
         }
@@ -246,7 +246,7 @@ public void NoTypeNamePicksFirstType()
             Type firstPublicType = FirstPublicDesiredType(forwardingLoggerfilter, forwardingLoggerAssemblyLocation);
 
             TypeLoader loader = new TypeLoader(forwardingLoggerfilter);
-            LoadedType loadedType = loader.Load(String.Empty, AssemblyLoadInfo.Create(null, forwardingLoggerAssemblyLocation));
+            LoadedType loadedType = loader.Load(String.Empty, AssemblyLoadInfo.Create(null, forwardingLoggerAssemblyLocation), false).LoadedType;
             Assert.NotNull(loadedType);
             Assert.Equal(forwardingLoggerAssemblyLocation, loadedType.Assembly.AssemblyLocation);
             Assert.Equal(firstPublicType, loadedType.Type);
@@ -258,7 +258,7 @@ public void NoTypeNamePicksFirstType()
             firstPublicType = FirstPublicDesiredType(fileLoggerfilter, fileLoggerAssemblyLocation);
 
             loader = new TypeLoader(fileLoggerfilter);
-            loadedType = loader.Load(String.Empty, AssemblyLoadInfo.Create(null, fileLoggerAssemblyLocation));
+            loadedType = loader.Load(String.Empty, AssemblyLoadInfo.Create(null, fileLoggerAssemblyLocation), false).LoadedType;
             Assert.NotNull(loadedType);
             Assert.Equal(fileLoggerAssemblyLocation, loadedType.Assembly.AssemblyLocation);
             Assert.Equal(firstPublicType, loadedType.Type);
