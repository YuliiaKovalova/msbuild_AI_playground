diff --git a/.gitattributes b/.gitattributes
index a8bb4d389ee..af9d9e931ae 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -20,7 +20,7 @@ src/Tasks/*.targets linguist-detectable=true
 src/Tasks/*.tasks linguist-detectable=true
 
 # Don't include Arcade-owned path
-eng/common/** linguist-detectable=false
+eng/common/** linguist-vendored linguist-generated
 
 # Display XLF files collapsed by default in PR diffs
 *.xlf linguist-generated=true
diff --git a/.github/ISSUE_TEMPLATE/04_blankissue.md b/.github/ISSUE_TEMPLATE/04_blankissue.md
new file mode 100644
index 00000000000..9be0e37587f
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/04_blankissue.md
@@ -0,0 +1,6 @@
+---
+name: 📄 Blank Issue
+about: Doesn't fit the other categories? File a blank ticket here.
+title: ''
+labels: untriaged
+---
\ No newline at end of file
diff --git a/.github/ISSUE_TEMPLATE/config.yml b/.github/ISSUE_TEMPLATE/config.yml
index 63f52d67500..0b4875ecad3 100644
--- a/.github/ISSUE_TEMPLATE/config.yml
+++ b/.github/ISSUE_TEMPLATE/config.yml
@@ -1,4 +1,4 @@
-blank_issues_enabled: true
+blank_issues_enabled: false
 contact_links:
   - name: Issue with .NET (Core) SDK
     url:  https://github.com/dotnet/sdk/issues/new/choose
diff --git a/MSBuild.sln b/MSBuild.sln
index 966817afd12..f58cad8b0d6 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -67,6 +67,8 @@ Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild.Bootstrap", "src\MS
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.UnGAC", "src\Package\Microsoft.Build.UnGAC\Microsoft.Build.UnGAC.csproj", "{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}"
 EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ProjectCachePlugin", "src\Samples\ProjectCachePlugin\ProjectCachePlugin.csproj", "{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -866,6 +868,36 @@ Global
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|x64.ActiveCfg = Debug|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|x64.Build.0 = Debug|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|x86.Build.0 = Debug|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|Any CPU.Build.0 = Release|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|x64.ActiveCfg = Release|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|x64.Build.0 = Release|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|x86.ActiveCfg = Release|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|x86.Build.0 = Release|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -883,6 +915,7 @@ Global
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943} = {760FF85D-8BEB-4992-8095-A9678F88FD47}
 	EndGlobalSection
 	GlobalSection(ExtensibilityGlobals) = postSolution
 		SolutionGuid = {F948D667-14E3-4F98-BA50-3F3C948BF4C2}
diff --git a/NuGet.config b/NuGet.config
index cda7383f71e..6a442ae4089 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -5,9 +5,6 @@
     <add key="dotnet-core" value="https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json" />
     <add key="arcade" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json" />
     <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
-    <add key="roslyn" value="https://dotnet.myget.org/F/roslyn/api/v3/index.json" />
-    <add key="nuget-build" value="https://dotnet.myget.org/F/nuget-build/api/v3/index.json" />
-    <add key="roslyn-tools" value="https://dotnet.myget.org/F/roslyn-tools/api/v3/index.json" />
     <add key="dotnet-tools" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json" />
   </packageSources>
   <disabledPackageSources />
diff --git a/documentation/specs/project-cache.md b/documentation/specs/project-cache.md
new file mode 100644
index 00000000000..a9da734d26f
--- /dev/null
+++ b/documentation/specs/project-cache.md
@@ -0,0 +1,132 @@
+- [Summary](#summary)
+- [Motivation](#motivation)
+- [Plugin requirements](#plugin-requirements)
+- [High-level design](#high-level-design)
+- [APIs and calling patterns](#apis-and-calling-patterns)
+  - [From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order)
+  - [From command line](#from-command-line)
+  - [From Visual Studio, a temporary workaround](#from-visual-studio-a-temporary-workaround)
+- [Details](#details)
+- [Caveats](#caveats)
+- [Future work](#future-work)
+- [Potential work of dubious value](#potential-work-of-dubious-value)
+
+# Summary
+
+Project cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).
+
+# Motivation
+
+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, large and complex repos expose the weaknesses in MSBuild's scheduling and incrementality models as build times elongate. This project cache plugin lets MSBuild natively communicate with existing tools that enable build caching and/or distribution, enabling true scalability.
+
+Visual Studio is one beneficiary. This plugin inverts dependencies among build systems: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild calls into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.
+
+This change also simplifies and unifies user experiences. MSBuild works the same from Visual Studio or the command line without dramatically changing how it works.
+
+# Plugin requirements
+
+- The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:
+  - it makes the filesystem look as if the project built
+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.
+
+# High-level design
+- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.
+  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.
+- If the plugin decides to build, then MSBuild proceeds building the project as usual.
+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.
+  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.
+- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).
+  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.
+  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.
+- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.
+- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.
+- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the "graph" when static graph is not available).
+- A single plugin is supported (for now).
+
+# APIs and calling patterns
+- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).
+
+## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.
+- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.
+  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.
+- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.
+- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.
+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.
+- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.
+
+## From command line
+- Requires /graph. It is the easiest way to implement the plugin:
+  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.
+  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.
+- User calls msbuild /graph.
+- MSBuild constructs the static graph.
+- The graph builder finds and loads the plugin into the `BuildManager`.
+  - Each graph node has a ProjectInstance, which is used to search for the plugin.
+  - If a project defines a plugin, then all projects in the graph must define that same plugin.
+  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).
+- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.
+  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.
+
+## From Visual Studio, a temporary workaround
+- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:
+  - The workaround logic activates only when MSBuild detects that it's running under VS.
+  - Plugin discovery
+    - When VS evaluates projects via "new Project(..)" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.
+  - Plugin usage:
+    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.
+
+# Details
+- Plugin discovery
+  - Each project defines an item containing the path to the plugin DLL:
+```xml
+<ProjectCachePlugin Include="..\..\QuickbuildProjectCachePlugin.dll">
+```
+- Plugin acquisition
+  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.
+- Defining the "graph" when static graph is not available
+  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.
+  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.
+    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.
+- Returning a valid BuildResult object on cache hits.
+  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).
+  - Plugins have three options:
+    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.
+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.
+      - Proxy target assumptions:
+        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).
+        - They do not mutate state (file system, environment variables, etc).
+        - They do not MSBuild task call into other projects.
+      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.
+    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.
+      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.
+      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.
+- Configuring plugins
+  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.
+```xml
+<ProjectCachePlugin Update="@(ProjectCachePlugin)" setting1="val1" setting2="val2" />
+```
+- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):
+  - From command line: `msbuild /graph:NoBuild`
+  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`
+- Logging
+  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.
+  - Log messages from querying a project get parented under that project's logging context.
+    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.
+
+# Caveats
+- Absolute paths circulating through the saved build results
+  - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.
+- Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.
+- Inferring what targets to run on each node when using /graph
+  - Msbuild /graph requires that the [target inference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.
+- Small repos will probably be slower with plugin implementations that access the network. Remote distribution and caching will only be worth it for repos that are large enough.
+
+# Future work
+- On cache misses plugins can build the project with IO monitoring and write to the local cache. As far as we can tell there are two main possibilities:
+  - plugins build the projects themselves in isolation (without projects building their reference, probably by setting `BuildProjectReferences` to false) by calling msbuild.exe.
+  - plugins request msbuild to build the projects on special out of proc nodes whose IO system calls can be monitored.
+
+# Potential work of dubious value
+- Allow multiple plugin instances and query them based on some priority, similar to sdk resolvers.
+- Enable plugins to work with the just-in-time top down msbuild traversal that msbuild natively does when it's not using `/graph`.
+- Extend the project cache API to allow skipping individual targets or tasks instead of entire projects. This would allow for smaller specialized plugins, like plugins that only know to distribute, cache, and skip CSC.exe calls.
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index dba5ad2a992..e1d14d55a01 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -5,9 +5,9 @@
       <Uri>https://github.com/dotnet/arcade</Uri>
       <Sha>7ee8c2b620e66b3762d7a5a688dee8238770c86a</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="5.9.0-preview.2.6979">
+    <Dependency Name="NuGet.Build.Tasks" Version="5.9.0-preview.3.7016">
       <Uri>https://github.com/NuGet/NuGet.Client</Uri>
-      <Sha>8e3cdf1b3475a0cb68a65dd2ffd51a2135f1fb67</Sha>
+      <Sha>719f110bf31709b7f8bdf1ab74024450936d866c</Sha>
     </Dependency>
     <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="">
       <Uri>https://github.com/dotnet/roslyn</Uri>
diff --git a/eng/Versions.props b/eng/Versions.props
index 58dc35e10ec..8e618b92c93 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -1,19 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
-  <Import Project="$(DotNetRestoreSourcePropsPath)" Condition="'$(DotNetRestoreSourcePropsPath)' != ''" />
-  <PropertyGroup>
-    <RestoreSources>$(DotNetRestoreSources)</RestoreSources>
-    <RestoreSources Condition="'$(DotNetBuildOffline)' != 'true'">
-        $(RestoreSources);
-        https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json;
-        https://dotnet.myget.org/F/roslyn/api/v3/index.json;
-        https://dotnet.myget.org/F/nuget-build/api/v3/index.json;
-        https://dotnet.myget.org/F/roslyn-tools/api/v3/index.json;
-        https://dotnet.myget.org/F/dotnet-buildtools/api/v3/index.json
-    </RestoreSources>
-    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
-  </PropertyGroup>
   <PropertyGroup>
     <VersionPrefix>16.9.0</VersionPrefix>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
@@ -38,7 +25,7 @@
   <PropertyGroup>
     <DotNetCliVersion>3.1.100</DotNetCliVersion>
     <MicrosoftNetCompilersToolsetVersion>3.3.1-beta3-final</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>5.9.0-preview.2.6979</NuGetBuildTasksVersion>
+    <NuGetBuildTasksVersion>5.9.0-preview.3.7016</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index cbc25f139be..dc26ebeb9ba 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -926,6 +926,7 @@ public ResolveAssemblyReference() { }
         public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
         public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
+        public bool OutputUnresolvedAssemblyConflicts { get { throw null; } set { } }
         public string ProfileName { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] RelatedFiles { get { throw null; } }
@@ -954,6 +955,8 @@ public ResolveAssemblyReference() { }
         public string[] TargetFrameworkSubsets { get { throw null; } set { } }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public string TargetProcessorArchitecture { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] UnresolvedAssemblyConflicts { get { throw null; } }
         public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
         public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
         public override bool Execute() { throw null; }
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 349308aac70..0d85a2cc928 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -671,6 +671,7 @@ public ResolveAssemblyReference() { }
         public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
         public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
+        public bool OutputUnresolvedAssemblyConflicts { get { throw null; } set { } }
         public string ProfileName { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] RelatedFiles { get { throw null; } }
@@ -699,6 +700,8 @@ public ResolveAssemblyReference() { }
         public string[] TargetFrameworkSubsets { get { throw null; } set { } }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public string TargetProcessorArchitecture { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] UnresolvedAssemblyConflicts { get { throw null; } }
         public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
         public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
         public override bool Execute() { throw null; }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 9d481a020ac..3b2268d29e2 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -998,6 +998,7 @@ public BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectColle
         public string NodeExeLocation { get { throw null; } set { } }
         public bool OnlyLogCriticalEvents { get { throw null; } set { } }
         public string OutputResultsCacheFile { get { throw null; } set { } }
+        public Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor ProjectCacheDescriptor { get { throw null; } set { } }
         public Microsoft.Build.Evaluation.ProjectLoadSettings ProjectLoadSettings { get { throw null; } set { } }
         public bool ResetCaches { get { throw null; } set { } }
         public bool SaveOperatingEnvironment { get { throw null; } set { } }
@@ -1407,6 +1408,73 @@ public enum TargetResultCode : byte
         Success = (byte)1,
     }
 }
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    public partial class CacheContext
+    {
+        public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph=null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints=null) { }
+        public Microsoft.Build.FileSystem.MSBuildFileSystemBase FileSystem { get { throw null; } }
+        public Microsoft.Build.Graph.ProjectGraph Graph { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> GraphEntryPoints { get { throw null; } }
+        public string MSBuildExePath { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
+    }
+    public partial class CacheResult
+    {
+        internal CacheResult() { }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) { throw null; }
+    }
+    public enum CacheResultType
+    {
+        CacheHit = 1,
+        CacheMiss = 2,
+        CacheNotApplicable = 3,
+        None = 0,
+    }
+    public abstract partial class PluginLoggerBase
+    {
+        protected PluginLoggerBase(Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
+        public abstract bool HasLoggedErrors { get; protected set; }
+        public abstract void LogError(string error);
+        public abstract void LogMessage(string message, System.Nullable<Microsoft.Build.Framework.MessageImportance> messageImportance=default(System.Nullable<Microsoft.Build.Framework.MessageImportance>));
+        public abstract void LogWarning(string warning);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public partial struct PluginTargetResult
+    {
+        public PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) { throw null;}
+        public Microsoft.Build.Execution.BuildResultCode ResultCode { get { throw null; } }
+        public string TargetName { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> TaskItems { get { throw null; } }
+    }
+    public partial class ProjectCacheDescriptor
+    {
+        internal ProjectCacheDescriptor() { }
+        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> EntryPoints { get { throw null; } }
+        public string PluginAssemblyPath { get { throw null; } }
+        public Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase PluginInstance { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
+        public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
+        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings=null) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings=null) { throw null; }
+        public string GetDetailedDescription() { throw null; }
+    }
+    public abstract partial class ProjectCachePluginBase
+    {
+        protected ProjectCachePluginBase() { }
+        public abstract System.Threading.Tasks.Task BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
+        public abstract System.Threading.Tasks.Task EndBuildAsync(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
+        public abstract System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.CacheResult> GetCacheResultAsync(Microsoft.Build.Execution.BuildRequestData buildRequest, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
+    }
+    public partial class ProxyTargets
+    {
+        public ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap) { }
+        public System.Collections.Generic.IReadOnlyDictionary<string, string> ProxyTargetToRealTargetMap { get { throw null; } }
+    }
+}
 namespace Microsoft.Build.FileSystem
 {
     public abstract partial class MSBuildFileSystemBase
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index 705dfafe932..2d8bde06715 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -993,6 +993,7 @@ public BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectColle
         public string NodeExeLocation { get { throw null; } set { } }
         public bool OnlyLogCriticalEvents { get { throw null; } set { } }
         public string OutputResultsCacheFile { get { throw null; } set { } }
+        public Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor ProjectCacheDescriptor { get { throw null; } set { } }
         public Microsoft.Build.Evaluation.ProjectLoadSettings ProjectLoadSettings { get { throw null; } set { } }
         public bool ResetCaches { get { throw null; } set { } }
         public bool SaveOperatingEnvironment { get { throw null; } set { } }
@@ -1401,6 +1402,73 @@ public enum TargetResultCode : byte
         Success = (byte)1,
     }
 }
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    public partial class CacheContext
+    {
+        public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph=null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints=null) { }
+        public Microsoft.Build.FileSystem.MSBuildFileSystemBase FileSystem { get { throw null; } }
+        public Microsoft.Build.Graph.ProjectGraph Graph { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> GraphEntryPoints { get { throw null; } }
+        public string MSBuildExePath { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
+    }
+    public partial class CacheResult
+    {
+        internal CacheResult() { }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) { throw null; }
+    }
+    public enum CacheResultType
+    {
+        CacheHit = 1,
+        CacheMiss = 2,
+        CacheNotApplicable = 3,
+        None = 0,
+    }
+    public abstract partial class PluginLoggerBase
+    {
+        protected PluginLoggerBase(Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
+        public abstract bool HasLoggedErrors { get; protected set; }
+        public abstract void LogError(string error);
+        public abstract void LogMessage(string message, System.Nullable<Microsoft.Build.Framework.MessageImportance> messageImportance=default(System.Nullable<Microsoft.Build.Framework.MessageImportance>));
+        public abstract void LogWarning(string warning);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public partial struct PluginTargetResult
+    {
+        public PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) { throw null;}
+        public Microsoft.Build.Execution.BuildResultCode ResultCode { get { throw null; } }
+        public string TargetName { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> TaskItems { get { throw null; } }
+    }
+    public partial class ProjectCacheDescriptor
+    {
+        internal ProjectCacheDescriptor() { }
+        public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> EntryPoints { get { throw null; } }
+        public string PluginAssemblyPath { get { throw null; } }
+        public Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase PluginInstance { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
+        public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
+        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings=null) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings=null) { throw null; }
+        public string GetDetailedDescription() { throw null; }
+    }
+    public abstract partial class ProjectCachePluginBase
+    {
+        protected ProjectCachePluginBase() { }
+        public abstract System.Threading.Tasks.Task BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
+        public abstract System.Threading.Tasks.Task EndBuildAsync(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
+        public abstract System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.CacheResult> GetCacheResultAsync(Microsoft.Build.Execution.BuildRequestData buildRequest, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken);
+    }
+    public partial class ProxyTargets
+    {
+        public ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap) { }
+        public System.Collections.Generic.IReadOnlyDictionary<string, string> ProxyTargetToRealTargetMap { get { throw null; } }
+    }
+}
 namespace Microsoft.Build.FileSystem
 {
     public abstract partial class MSBuildFileSystemBase
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 9539898ed8b..8d9406a91cb 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -2604,6 +2604,92 @@ public void LastUpdateWins()
             ObjectModelHelpers.AssertItemHasMetadata(expectedUpdate, items[0]);
         }
 
+        [Theory]
+        [InlineData("abc", "def", "abc")]
+        [InlineData("abc", "de*", "abc")]
+        [InlineData("a*c", "def", "abc")]
+        [InlineData("abc", "def", "*bc")]
+        [InlineData("abc", "d*f", "*bc")]
+        [InlineData("*c", "d*f", "*bc")]
+        [InlineData("a*", "d*", "abc")]
+        public void UpdatesProceedInOrder(string first, string second, string third)
+        {
+            string contents = $@"
+<i Include='abc'>
+    <m1>m1_contents</m1>
+</i>
+<j Include='def'>
+    <m1>m1_contents</m1>
+</j>
+<i Update='{first}'>
+    <m1>first</m1>
+</i>
+<j Update='{second}'>
+    <m1>second</m1>
+</j>
+<i Update='{third}'>
+    <m1>third</m1>
+</i>
+";
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(contents, allItems: true);
+            Dictionary<string, string> expectedUpdatei = new Dictionary<string, string>
+            {
+                {"m1", "third" }
+            };
+            Dictionary<string, string> expectedUpdatej = new Dictionary<string, string>
+            {
+                {"m1", "second" }
+            };
+
+            ObjectModelHelpers.AssertItemHasMetadata(expectedUpdatei, items[0]);
+            ObjectModelHelpers.AssertItemHasMetadata(expectedUpdatej, items[1]);
+        }
+
+        [Fact]
+        public void UpdatingIndividualItemsProceedsInOrder()
+        {
+            string contents = @"
+<i Include='a;b;c'>
+    <m1>m1_contents</m1>
+</i>
+<i Update='a'>
+    <m1>second</m1>
+</i>
+<i Update='b'>
+    <m1>third</m1>
+</i>
+<i Update='c'>
+    <m1>fourth</m1>
+</i>
+<afterFirst Include='@(i)' />
+<i Update='*'>
+    <m1>sixth</m1>
+</i>
+<afterSecond Include='@(i)' />
+<i Update='b'>
+    <m1>seventh</m1>
+</i>
+<afterThird Include='@(i)' />
+<i Update='c'>
+    <m1>eighth</m1>
+</i>
+<afterFourth Include='@(i)' />
+";
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(contents, allItems: true);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "second", items[3]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "third", items[4]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "fourth", items[5]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "sixth", items[6]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "sixth", items[7]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "sixth", items[8]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "sixth", items[9]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "seventh", items[10]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "sixth", items[11]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "sixth", items[12]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "seventh", items[13]);
+            ObjectModelHelpers.AssertItemHasMetadata("m1", "eighth", items[14]);
+        }
+
         [Fact]
         public void UpdateWithNoMetadataShouldNotAffectItems()
         {
@@ -2850,6 +2936,25 @@ public void UpdateFromReferencedItemShouldBeCaseInsensitive()
             ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataA, items[1]);
         }
 
+        [Fact]
+        public void UpdateMetadataWithoutItemReferenceShouldBeCaseInsensitive()
+        {
+            string content = @"
+                              <to Include='a' />
+
+                              <to Update='A' m='m1_contents' />";
+
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content, true);
+
+            var expectedMetadataA = new Dictionary<string, string>
+            {
+                {"m", "m1_contents"},
+            };
+
+            items[0].ItemType.ShouldBe("to");
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataA, items[0]);
+        }
+
         [Fact]
         public void UndeclaredQualifiedMetadataReferencesInUpdateShouldResolveToEmptyStrings()
         {
diff --git a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
index 237fcf00856..e46a84eb0e4 100644
--- a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Engine.UnitTests.TestComparers;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
diff --git a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
index 791db350934..738978a9e07 100644
--- a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Unittest;
 using Shouldly;
 using Xunit;
 using static Microsoft.Build.Unittest.BuildResultUtilities;
@@ -279,25 +280,7 @@ private void AssertBuildResultsEquivalent(BuildResult inputResult, BuildResult a
             aggregatedBuildResult.NodeRequestId.ShouldBe(BuildRequest.InvalidNodeRequestId);
             aggregatedBuildResult.SubmissionId.ShouldBe(BuildEventContext.InvalidSubmissionId);
 
-            inputResult.InitialTargets.ShouldBe(aggregatedBuildResult.InitialTargets);
-            inputResult.DefaultTargets.ShouldBe(aggregatedBuildResult.DefaultTargets);
-            inputResult.CircularDependency.ShouldBe(aggregatedBuildResult.CircularDependency);
-            inputResult.Exception.ShouldBe(aggregatedBuildResult.Exception);
-            inputResult.OverallResult.ShouldBe(aggregatedBuildResult.OverallResult);
-            inputResult.ProjectStateAfterBuild.ShouldBe(aggregatedBuildResult.ProjectStateAfterBuild);
-
-            Helpers.AssertDictionariesEqual(inputResult.ResultsByTarget, aggregatedBuildResult.ResultsByTarget, (a, b) =>
-            {
-                a.Key.ShouldBe(b.Key);
-
-                a.Value.Exception.ShouldBe(b.Value.Exception);
-                a.Value.Items.ShouldBe(b.Value.Items);
-                a.Value.ResultCode.ShouldBe(b.Value.ResultCode);
-
-                a.Value.WorkUnitResult.ActionCode.ShouldBe(b.Value.WorkUnitResult.ActionCode);
-                a.Value.WorkUnitResult.Exception.ShouldBe(b.Value.WorkUnitResult.Exception);
-                a.Value.WorkUnitResult.ResultCode.ShouldBe(b.Value.WorkUnitResult.ResultCode);
-            });
+            SdkUtilities.EngineHelpers.AssertBuildResultsEqual(inputResult, aggregatedBuildResult);
         }
 
         private void AssertConfigurationsEquivalent(BuildRequestConfiguration inputConfiguration, BuildRequestConfiguration aggregatedConfig)
diff --git a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
index 9cd1fe75b02..346da6846b9 100644
--- a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Execution;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Xunit;
+using Microsoft.Build.Engine.UnitTests.TestComparers;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index 8660f8d86fc..93abec24663 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -20,6 +20,7 @@
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Xunit;
+using Microsoft.Build.Engine.UnitTests.TestComparers;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
diff --git a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
index 7cc2060da0f..62cc2016a58 100644
--- a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
+++ b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
@@ -473,8 +473,9 @@ public void SkippedTargetsShouldNotTriggerCacheMissEnforcement()
 ".Cleanup()).Path;
 
             _buildParametersPrototype.IsolateProjects.ShouldBeTrue();
+            var buildParameters = _buildParametersPrototype.Clone();
 
-            using (var buildManagerSession = new Helpers.BuildManagerSession(_env, _buildParametersPrototype))
+            using (var buildManagerSession = new Helpers.BuildManagerSession(_env, buildParameters))
             {
                 // seed caches with results from the reference
                 buildManagerSession.BuildProjectFile(referenceFile).OverallResult.ShouldBe(BuildResultCode.Success);
diff --git a/src/Build.UnitTests/InternalEngineHelpers.cs b/src/Build.UnitTests/InternalEngineHelpers.cs
index 2a4de9d485d..aa0ae0c34be 100644
--- a/src/Build.UnitTests/InternalEngineHelpers.cs
+++ b/src/Build.UnitTests/InternalEngineHelpers.cs
@@ -7,8 +7,13 @@
 using System.Linq;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Definition;
+using Microsoft.Build.Engine.UnitTests.TestComparers;
 using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.BackEnd;
+using Shouldly;
 using SdkResolverContext = Microsoft.Build.Framework.SdkResolverContext;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 using SdkResultFactory = Microsoft.Build.Framework.SdkResultFactory;
@@ -143,5 +148,40 @@ public override Framework.SdkResult Resolve(SdkReference sdkReference, SdkResolv
                     : factory.IndicateFailure(new[] { $"Not in {nameof(_mapping)}" });
             }
         }
+
+        internal static class EngineHelpers
+        {
+            internal static void AssertBuildResultsEqual(BuildResult actualBuildResult, BuildResult expectedBuildResult)
+            {
+                actualBuildResult.InitialTargets.ShouldBe(expectedBuildResult.InitialTargets);
+                actualBuildResult.DefaultTargets.ShouldBe(expectedBuildResult.DefaultTargets);
+                actualBuildResult.CircularDependency.ShouldBe(expectedBuildResult.CircularDependency);
+                actualBuildResult.Exception.ShouldBe(expectedBuildResult.Exception);
+                actualBuildResult.OverallResult.ShouldBe(expectedBuildResult.OverallResult);
+                actualBuildResult.ProjectStateAfterBuild.ShouldBe(expectedBuildResult.ProjectStateAfterBuild);
+
+                Helpers.AssertDictionariesEqual(
+                    actualBuildResult.ResultsByTarget,
+                    expectedBuildResult.ResultsByTarget,
+                    (a, b) =>
+                    {
+                        a.Key.ShouldBe(b.Key);
+
+                        AssertTargetResultsEqual(a.Value, b.Value);
+                    });
+            }
+
+            internal static void AssertTargetResultsEqual(TargetResult a, TargetResult b)
+            {
+                TranslationHelpers.CompareExceptions(a.Exception, b.Exception).ShouldBeTrue();
+                TranslationHelpers.CompareCollections(a.Items, b.Items, TaskItemComparer.Instance).ShouldBeTrue();
+
+                a.ResultCode.ShouldBe(b.ResultCode);
+
+                a.WorkUnitResult.ActionCode.ShouldBe(b.WorkUnitResult.ActionCode);
+                a.WorkUnitResult.Exception.ShouldBe(b.WorkUnitResult.Exception);
+                a.WorkUnitResult.ResultCode.ShouldBe(b.WorkUnitResult.ResultCode);
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index fdeaf730a1b..9b45fb61b7e 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -40,6 +40,12 @@
     </ProjectReference>
     <ProjectReference Include="..\Samples\PortableTask\PortableTask.csproj" Private="false" ReferenceOutputAssembly="false" OutputItemType="PortableTaskResolvedProjectReferencePath" SetTargetFramework="TargetFramework=netstandard1.3" />
 
+    <ProjectReference Include="..\Samples\ProjectCachePlugin\ProjectCachePlugin.csproj" Private="false" ReferenceOutputAssembly="false">
+      <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
+      <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' == 'true'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
+      <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=netcoreapp2.1</SetTargetFramework>
+    </ProjectReference>
+
     <Reference Include="System.Configuration" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
new file mode 100644
index 00000000000..f7d7eca1c2c
--- /dev/null
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -0,0 +1,884 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text.RegularExpressions;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Graph;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Unittest;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.Utilities;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+using Task = System.Threading.Tasks.Task;
+
+namespace Microsoft.Build.Engine.UnitTests.ProjectCache
+{
+    public class ProjectCacheTests : IDisposable
+    {
+        public ProjectCacheTests(ITestOutputHelper output)
+        {
+            _output = output;
+            _env = TestEnvironment.Create(output);
+
+            BuildManager.ProjectCacheItems.ShouldBeEmpty();
+            _env.WithInvariant(new CustomConditionInvariant(() => BuildManager.ProjectCacheItems.Count == 0));
+        }
+
+        public void Dispose()
+        {
+            _env.Dispose();
+        }
+
+        private static readonly string AssemblyMockCache = nameof(AssemblyMockCache);
+
+        private static readonly Lazy<string> SamplePluginAssemblyPath =
+            new Lazy<string>(
+                () =>
+                {
+                    return Directory.EnumerateFiles(
+                        Path.GetFullPath(
+                            Path.Combine(
+                                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
+                                "..",
+                                "..",
+                                "..",
+                                "Samples",
+                                "ProjectCachePlugin")),
+                        "ProjectCachePlugin.dll",
+                        SearchOption.AllDirectories).First();
+                });
+
+        public class GraphCacheResponse
+        {
+            public const string CacheHitByProxy = nameof(CacheHitByProxy);
+            public const string CacheHitByTargetResult = nameof(CacheHitByTargetResult);
+
+            private static readonly string P2PTargets =
+                @$"
+                    <ItemGroup>
+                        <ProjectReferenceTargets Include=`Build` Targets=`Build` />
+                        <{ItemTypeNames.ProjectCachePlugin} Include=`{SamplePluginAssemblyPath.Value}` />
+                    </ItemGroup>
+
+                    <Target Name=`Build` Returns=`@(ReturnValue)`>
+                        <MSBuild Projects=`@(ProjectReference)` Targets=`Build`>
+                            <Output TaskParameter=`TargetOutputs` ItemName=`ReferenceReturns` />
+                        </MSBuild>
+
+                        <Message Text=`Reference: %(ReferenceReturns.Identity) : %(ReferenceReturns.File)` Importance=`High` />
+                        <Error Text=`Reference file [%(ReferenceReturns.File)] does not exist` Condition=`@(ReferenceReturns->Count()) != 0 and !Exists(%(ReferenceReturns.File))` />
+
+                        <ItemGroup>
+                            <ReturnValue Include=`$(MSBuildProjectName)` File=`$(MSBuildProjectFile)` />
+                        </ItemGroup>
+                    </Target>
+
+                    <Target Name=`ProxyBuild` Returns=`@(ReturnValue)`>
+                        <ItemGroup>
+                            <ReturnValue Include=`$(MSBuildProjectName)` File=`$(MSBuildProjectFile)` {CacheHitByProxy}=`true`/>
+                        </ItemGroup>
+                    </Target>";
+
+            private Dictionary<int, int[]> GraphEdges { get; }
+
+            public Dictionary<int, CacheResult> NonCacheMissResults { get; }
+
+            public GraphCacheResponse(Dictionary<int, int[]> graphEdges, Dictionary<int, CacheResult>? nonCacheMissResults = null)
+            {
+                GraphEdges = graphEdges;
+                NonCacheMissResults = nonCacheMissResults ?? new Dictionary<int, CacheResult>();
+            }
+
+            public ProjectGraph CreateGraph(TestEnvironment env)
+            {
+                return Helpers.CreateProjectGraph(
+                    env,
+                    GraphEdges,
+                    null,
+                    P2PTargets);
+            }
+
+            public static CacheResult SuccessfulProxyTargetResult()
+            {
+                return CacheResult.IndicateCacheHit(
+                    new ProxyTargets(
+                        new Dictionary<string, string>
+                        {
+                            {"ProxyBuild", "Build"}
+                        }));
+            }
+
+            public static CacheResult SuccessfulTargetResult(int projectNumber, string projectPath)
+            {
+                return CacheResult.IndicateCacheHit(
+                    new[]
+                    {
+                        new PluginTargetResult(
+                            "Build",
+                            new ITaskItem2[]
+                            {
+                                new TaskItem(
+                                    projectNumber.ToString(),
+                                    new Dictionary<string, string>
+                                    {
+                                        {"File", projectPath},
+                                        {CacheHitByTargetResult, "true"}
+                                    })
+                            },
+                            BuildResultCode.Success
+                            )
+                    });
+            }
+
+            public CacheResult GetExpectedCacheResultForNode(ProjectGraphNode node)
+            {
+                return GetExpectedCacheResultForProjectNumber(GetProjectNumber(node));
+            }
+
+            public CacheResult GetExpectedCacheResultForProjectNumber(int projectNumber)
+            {
+                return NonCacheMissResults.TryGetValue(projectNumber, out var cacheResult)
+                    ? cacheResult
+                    : CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss);
+            }
+
+            public override string ToString()
+            {
+                //return base.ToString();
+                return string.Join(
+                    ", ",
+                    GraphEdges.Select(e => $"{Node(e.Key)}->{FormatChildren(e.Value)}"));
+
+                string FormatChildren(int[] children)
+                {
+                    return children == null
+                        ? "Null"
+                        : string.Join(",", children.Select(c => Node(c)));
+                }
+
+                string Node(int projectNumber)
+                {
+                    return $"{projectNumber}({Chr(projectNumber)})";
+                }
+
+                char Chr(int projectNumber)
+                {
+                    var cacheResult = GetExpectedCacheResultForProjectNumber(projectNumber);
+                    return cacheResult.ResultType switch
+                    {
+
+                        CacheResultType.CacheHit => cacheResult.ProxyTargets != null
+                            ? 'P'
+                            : 'T',
+                        CacheResultType.CacheMiss => 'M',
+                        CacheResultType.CacheNotApplicable => 'N',
+                        CacheResultType.None => 'E',
+                        _ => throw new ArgumentOutOfRangeException()
+                        };
+                }
+            }
+        }
+
+        [Flags]
+        public enum ExceptionLocations
+        {
+            Constructor = 1 << 0,
+            BeginBuildAsync = 1 << 1,
+            GetCacheResultAsync = 1 << 2,
+            EndBuildAsync = 1 << 3
+        }
+
+        public class InstanceMockCache : ProjectCachePluginBase
+        {
+            private readonly GraphCacheResponse? _testData;
+            public ConcurrentQueue<BuildRequestData> Requests { get; } = new ConcurrentQueue<BuildRequestData>();
+
+            public bool BeginBuildCalled { get; set; }
+            public bool EndBuildCalled { get; set; }
+
+            public InstanceMockCache(GraphCacheResponse? testData = null)
+            {
+                _testData = testData;
+            }
+
+            public override Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken)
+            {
+                logger.LogMessage("MockCache: BeginBuildAsync", MessageImportance.High);
+
+                BeginBuildCalled = true;
+
+                return Task.CompletedTask;
+            }
+
+            public override Task<CacheResult> GetCacheResultAsync(
+                BuildRequestData buildRequest,
+                PluginLoggerBase logger,
+                CancellationToken cancellationToken)
+            {
+                Requests.Enqueue(buildRequest);
+                logger.LogMessage($"MockCache: GetCacheResultAsync for {buildRequest.ProjectFullPath}", MessageImportance.High);
+
+                return
+                    Task.FromResult(
+                        _testData?.GetExpectedCacheResultForProjectNumber(GetProjectNumber(buildRequest.ProjectFullPath))
+                        ?? CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss));
+            }
+
+            public override Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken)
+            {
+                logger.LogMessage("MockCache: EndBuildAsync", MessageImportance.High);
+
+                EndBuildCalled = true;
+
+                return Task.CompletedTask;
+            }
+
+            public CacheResult GetCacheResultForNode(ProjectGraphNode node)
+            {
+                throw new NotImplementedException();
+            }
+        }
+
+        private readonly TestEnvironment _env;
+
+        private readonly ITestOutputHelper _output;
+
+        public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
+        {
+            get
+            {
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, null!}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, null!}
+                    },
+                    new Dictionary<int, CacheResult>
+                    {
+                        {1, GraphCacheResponse.SuccessfulProxyTargetResult()}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, null!}
+                    },
+                    new Dictionary<int, CacheResult>
+                    {
+                        {1, GraphCacheResponse.SuccessfulTargetResult(1, "1.proj")}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}}
+                    },
+                    new Dictionary<int, CacheResult>
+                    {
+                        {2, GraphCacheResponse.SuccessfulProxyTargetResult()}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}}
+                    },
+                    new Dictionary<int, CacheResult>
+                    {
+                        {2, GraphCacheResponse.SuccessfulTargetResult(2, "2.proj")}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}}
+                    },
+                    new Dictionary<int, CacheResult>
+                    {
+                        {1, GraphCacheResponse.SuccessfulProxyTargetResult()},
+                        {2, GraphCacheResponse.SuccessfulTargetResult(2, "2.proj")}
+                    });
+
+                yield return new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2, 3, 7}},
+                        {2, new[] {4}},
+                        {3, new[] {4}},
+                        {4, new[] {5, 6, 7}}
+                    });
+            }
+        }
+
+        public static IEnumerable<object[]> MultiProcWithAndWithoutInProcNode
+        {
+            get
+            {
+                yield return new object[]
+                {
+                    new BuildParameters
+                    {
+                        DisableInProcNode = false,
+                        MaxNodeCount = Environment.ProcessorCount
+                    }
+                };
+
+                yield return new object[]
+                {
+                    new BuildParameters
+                    {
+                        DisableInProcNode = true,
+                        MaxNodeCount = Environment.ProcessorCount
+                    }
+                };
+            }
+        }
+
+        public static IEnumerable<object[]> SuccessfulGraphsWithBuildParameters
+        {
+            get
+            {
+                foreach (var graph in SuccessfulGraphs)
+                {
+                    foreach (var buildParameters in MultiProcWithAndWithoutInProcNode)
+                    {
+                        yield return new object[]
+                        {
+                            graph,
+                            ((BuildParameters) buildParameters.First()).Clone()
+                        };
+                    }
+                }
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(SuccessfulGraphsWithBuildParameters))]
+        public void ProjectCacheByBuildParametersAndGraphBuildWorks(GraphCacheResponse testData, BuildParameters buildParameters)
+        {
+            _output.WriteLine(testData.ToString());
+            var graph = testData.CreateGraph(_env);
+            var mockCache = new InstanceMockCache(testData);
+
+            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
+                mockCache,
+                null,
+                graph);
+
+            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+
+            var graphResult = buildSession.BuildGraph(graph);
+
+            graphResult.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            buildSession.Dispose();
+
+            buildSession.Logger.FullLog.ShouldContain("Static graph based");
+
+            AssertCacheBuild(graph, testData, mockCache, buildSession.Logger, graphResult.ResultsByNode);
+        }
+
+        [Theory]
+        [MemberData(nameof(SuccessfulGraphsWithBuildParameters))]
+        public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheResponse testData, BuildParameters buildParameters)
+        {
+            var graph = testData.CreateGraph(_env);
+            var mockCache = new InstanceMockCache(testData);
+
+            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
+                mockCache,
+                null,
+                graph);
+
+            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+            var nodesToBuildResults = new Dictionary<ProjectGraphNode, BuildResult>();
+
+            foreach (var node in graph.ProjectNodesTopologicallySorted)
+            {
+                var buildResult = buildSession.BuildProjectFile(node.ProjectInstance.FullPath);
+                buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+
+                nodesToBuildResults[node] = buildResult;
+            }
+
+            buildSession.Dispose();
+
+            buildSession.Logger.FullLog.ShouldContain("Static graph based");
+
+            AssertCacheBuild(graph, testData, mockCache, buildSession.Logger, nodesToBuildResults);
+        }
+
+        [Theory]
+        [MemberData(nameof(SuccessfulGraphsWithBuildParameters))]
+        public void ProjectCacheByVSWorkaroundWorks(GraphCacheResponse testData, BuildParameters buildParameters)
+        {
+            var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
+
+            try
+            {
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(
+                    new BuildEnvironment(
+                        currentBuildEnvironment.Mode,
+                        currentBuildEnvironment.CurrentMSBuildExePath,
+                        currentBuildEnvironment.RunningTests,
+                        true,
+                        currentBuildEnvironment.VisualStudioInstallRootDirectory));
+
+                BuildManager.ProjectCacheItems.ShouldBeEmpty();
+
+                var graph = testData.CreateGraph(_env);
+
+                BuildManager.ProjectCacheItems.ShouldHaveSingleItem();
+
+                using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+                var nodesToBuildResults = new Dictionary<ProjectGraphNode, BuildResult>();
+
+                foreach (var node in graph.ProjectNodesTopologicallySorted)
+                {
+                    var buildResult = buildSession.BuildProjectFile(
+                        node.ProjectInstance.FullPath,
+                        globalProperties:
+                            new Dictionary<string, string> {{"SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath}});
+                    buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+
+                    nodesToBuildResults[node] = buildResult;
+                }
+
+                buildSession.Logger.FullLog.ShouldContain("Graph entrypoint based");
+
+                AssertCacheBuild(graph, testData, null, buildSession.Logger, nodesToBuildResults);
+            }
+            finally
+            {
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
+                BuildManager.ProjectCacheItems.Clear();
+            }
+        }
+
+        private void AssertCacheBuild(
+            ProjectGraph graph,
+            GraphCacheResponse testData,
+            InstanceMockCache? instanceMockCache,
+            MockLogger mockLogger,
+            IReadOnlyDictionary<ProjectGraphNode, BuildResult> projectPathToBuildResults)
+        {
+            if (instanceMockCache != null)
+            {
+                mockLogger.FullLog.ShouldContain("MockCache: BeginBuildAsync");
+                mockLogger.FullLog.ShouldContain("Instance based");
+                mockLogger.FullLog.ShouldNotContain("Assembly path based");
+
+                instanceMockCache.Requests.Count.ShouldBe(graph.ProjectNodes.Count);
+            }
+            else
+            {
+                mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: BeginBuildAsync");
+                mockLogger.FullLog.ShouldContain("Assembly path based");
+                mockLogger.FullLog.ShouldNotContain("Instance based");
+
+                Regex.Matches(mockLogger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for").Count.ShouldBe(graph.ProjectNodes.Count);
+            }
+
+            foreach (var node in graph.ProjectNodes)
+            {
+                var expectedCacheResponse = testData.GetExpectedCacheResultForNode(node);
+
+                mockLogger.FullLog.ShouldContain($"====== Querying project cache for project {node.ProjectInstance.FullPath}");
+
+                if (instanceMockCache != null)
+                {
+                    instanceMockCache.Requests.ShouldContain(r => r.ProjectFullPath.Equals(node.ProjectInstance.FullPath));
+                    instanceMockCache.BeginBuildCalled.ShouldBeTrue();
+                    instanceMockCache.EndBuildCalled.ShouldBeTrue();
+                }
+                else
+                {
+                    mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: GetCacheResultAsync for {node.ProjectInstance.FullPath}");
+                }
+
+                if (instanceMockCache == null)
+                {
+                    // Too complicated, not worth it to send expected results to the assembly plugin, so skip checking the build results.
+                    continue;
+                }
+
+                switch (expectedCacheResponse.ResultType)
+                {
+                    case CacheResultType.CacheHit:
+                        AssertBuildResultForCacheHit(node.ProjectInstance.FullPath, projectPathToBuildResults[node], expectedCacheResponse);
+                        break;
+                    case CacheResultType.CacheMiss:
+                        break;
+                    case CacheResultType.CacheNotApplicable:
+                        break;
+                    case CacheResultType.None:
+                        break;
+                    default:
+                        throw new ArgumentOutOfRangeException();
+                }
+            }
+        }
+
+        private static int GetProjectNumber(ProjectGraphNode node)
+        {
+            return GetProjectNumber(node.ProjectInstance.FullPath);
+        }
+
+        private static int GetProjectNumber(string projectPath)
+        {
+            return int.Parse(Path.GetFileNameWithoutExtension(projectPath));
+        }
+
+        private void AssertBuildResultForCacheHit(
+            string projectPath,
+            BuildResult buildResult,
+            CacheResult expectedCacheResponse)
+        {
+            // If the cache hit is via proxy targets then the build result should contain entry for both the real target
+            // and the proxy target. Both target results should be the same.
+            // If it's not a cache result by proxy targets then the cache constructed the target results by hand and only the real target result
+            // exists in the BuildResult.
+
+            var targetResult = buildResult.ResultsByTarget["Build"];
+
+            targetResult.Items.ShouldHaveSingleItem();
+            var itemResult = targetResult.Items.First();
+            string expectedMetadata;
+
+            if (expectedCacheResponse.ProxyTargets != null)
+            {
+                var proxyTargetResult = buildResult.ResultsByTarget["ProxyBuild"];
+                SdkUtilities.EngineHelpers.AssertTargetResultsEqual(targetResult, proxyTargetResult);
+
+                expectedMetadata = GraphCacheResponse.CacheHitByProxy;
+            }
+            else
+            {
+                expectedMetadata = GraphCacheResponse.CacheHitByTargetResult;
+            }
+
+            itemResult.ItemSpec.ShouldBe(GetProjectNumber(projectPath).ToString());
+            itemResult.GetMetadata("File").ShouldBe(Path.GetFileName(projectPath));
+            itemResult.GetMetadata(expectedMetadata).ShouldBe("true");
+        }
+
+        [Theory]
+        [MemberData(nameof(MultiProcWithAndWithoutInProcNode))]
+        public void CacheShouldNotGetQueriedForNestedBuildRequests(BuildParameters buildParameters)
+        {
+            var project1 = _env.CreateFile("1.proj", @"
+                    <Project>
+                        <Target Name=`Build`>
+                            <MSBuild Projects=`2.proj` />
+                        </Target>
+                    </Project>".Cleanup());
+
+            _env.CreateFile("2.proj", @"
+                    <Project>
+                        <Target Name=`Build`>
+                            <Message Text=`Hello` Importance=`High` />
+                        </Target>
+                    </Project>".Cleanup());
+
+            var mockCache = new InstanceMockCache();
+            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
+                mockCache,
+                new[] {new ProjectGraphEntryPoint(project1.Path)},
+                null);
+
+            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+
+            var buildResult = buildSession.BuildProjectFile(project1.Path);
+
+            buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            buildSession.Logger.ProjectStartedEvents.Count.ShouldBe(2);
+
+            mockCache.Requests.Count.ShouldBe(1);
+            mockCache.Requests.First().ProjectFullPath.ShouldEndWith("1.proj");
+        }
+
+        [Fact]
+        public void CacheViaBuildParametersCanDiscoverAndLoadPluginFromAssembly()
+        {
+            var testData = new GraphCacheResponse(
+                new Dictionary<int, int[]>
+                {
+                    {1, new[] {2, 3}}
+                }
+                );
+
+            var graph = testData.CreateGraph(_env);
+
+            using var buildSession = new Helpers.BuildManagerSession(
+                _env,
+                new BuildParameters
+                {
+                    ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
+                        SamplePluginAssemblyPath.Value,
+                        graph.EntryPointNodes.Select(n => new ProjectGraphEntryPoint(n.ProjectInstance.FullPath)).ToArray(),
+                        null)
+                });
+
+            var graphResult = buildSession.BuildGraph(graph);
+
+            graphResult.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            buildSession.Logger.FullLog.ShouldContain("Graph entrypoint based");
+
+            AssertCacheBuild(graph, testData, null, buildSession.Logger, graphResult.ResultsByNode);
+        }
+
+        [Fact]
+        public void GraphBuildCanDiscoverAndLoadPluginFromAssembly()
+        {
+            var testData = new GraphCacheResponse(
+                new Dictionary<int, int[]>
+                {
+                    {1, new[] {2, 3}}
+                }
+                );
+
+            var graph = testData.CreateGraph(_env);
+
+            using var buildSession = new Helpers.BuildManagerSession(_env);
+
+            var graphResult = buildSession.BuildGraph(graph);
+
+            graphResult.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            buildSession.Logger.FullLog.ShouldContain("Static graph based");
+
+            AssertCacheBuild(graph, testData, null, buildSession.Logger, graphResult.ResultsByNode);
+        }
+
+        [Fact]
+        public void BuildFailsWhenCacheBuildResultIsWrong()
+        {
+            var testData = new GraphCacheResponse(
+                new Dictionary<int, int[]>
+                {
+                    {1, new[] {2}}
+                },
+                new Dictionary<int, CacheResult>
+                {
+                    {
+                        2, CacheResult.IndicateCacheHit(
+                            new[]
+                            {
+                                new PluginTargetResult(
+                                    "Build",
+                                    new ITaskItem2[]
+                                    {
+                                        new TaskItem(
+                                            "NA",
+                                            new Dictionary<string, string>
+                                            {
+                                                {"File", "Invalid file"}
+                                            })
+                                    },
+                                    BuildResultCode.Success
+                                    )
+                            })
+                    }
+                }
+                );
+
+            var graph = testData.CreateGraph(_env);
+            var mockCache = new InstanceMockCache(testData);
+
+            using var buildSession = new Helpers.BuildManagerSession(
+                _env,
+                new BuildParameters
+                {
+                    ProjectCacheDescriptor =
+                        ProjectCacheDescriptor.FromInstance(mockCache, null, graph)
+                });
+
+            var buildResult = buildSession.BuildGraph(graph);
+
+            mockCache.Requests.Count.ShouldBe(2);
+
+            buildResult.ResultsByNode.First(r => GetProjectNumber(r.Key) == 2).Value.OverallResult.ShouldBe(BuildResultCode.Success);
+            buildResult.ResultsByNode.First(r => GetProjectNumber(r.Key) == 1).Value.OverallResult.ShouldBe(BuildResultCode.Failure);
+
+            buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+
+            buildSession.Logger.FullLog.ShouldContain("Reference file [Invalid file] does not exist");
+        }
+
+        [Fact]
+        public void GraphBuildErrorsIfMultiplePluginsAreFound()
+        {
+            _env.DoNotLaunchDebugger();
+
+            var graph = Helpers.CreateProjectGraph(
+                _env,
+                new Dictionary<int, int[]>
+                {
+                    {1, new[] {2}}
+                },
+                extraContentPerProjectNumber: null,
+                extraContentForAllNodes: @$"
+<ItemGroup>
+   <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />
+</ItemGroup>
+");
+
+            using var buildSession = new Helpers.BuildManagerSession(_env);
+
+            var graphResult = buildSession.BuildGraph(graph);
+
+            graphResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+            graphResult.Exception.Message.ShouldContain("A single project cache plugin must be specified but multiple where found:");
+        }
+
+        [Fact]
+        public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
+        {
+            _env.DoNotLaunchDebugger();
+
+            var graph = Helpers.CreateProjectGraph(
+                _env,
+                dependencyEdges: new Dictionary<int, int[]>
+                {
+                    {1, new[] {2}}
+                },
+                extraContentPerProjectNumber: new Dictionary<int, string>
+                {
+                    {
+                        2,
+                        @$"
+<ItemGroup>
+   <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />
+</ItemGroup>
+"
+                    }
+                });
+
+            using var buildSession = new Helpers.BuildManagerSession(_env);
+
+            var graphResult = buildSession.BuildGraph(graph);
+
+            graphResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+            graphResult.Exception.Message.ShouldContain("When any static graph node defines a project cache, all nodes must define the same project cache.");
+        }
+
+        public static IEnumerable<object[]> CacheExceptionLocationsTestData
+        {
+            get
+            {
+                yield return new object[]{ExceptionLocations.Constructor};
+
+                yield return new object[]{ExceptionLocations.BeginBuildAsync};
+                yield return new object[]{ExceptionLocations.BeginBuildAsync | ExceptionLocations.GetCacheResultAsync};
+                yield return new object[]{ExceptionLocations.BeginBuildAsync | ExceptionLocations.GetCacheResultAsync | ExceptionLocations.EndBuildAsync};
+                yield return new object[]{ExceptionLocations.BeginBuildAsync | ExceptionLocations.EndBuildAsync};
+
+                yield return new object[]{ExceptionLocations.GetCacheResultAsync};
+                yield return new object[]{ExceptionLocations.GetCacheResultAsync | ExceptionLocations.EndBuildAsync};
+
+                yield return new object[]{ExceptionLocations.EndBuildAsync};
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(CacheExceptionLocationsTestData))]
+        public void EngineShouldHandleExceptionsFromCachePlugin(ExceptionLocations exceptionLocations)
+        {
+            _env.DoNotLaunchDebugger();
+
+            var project = _env.CreateFile("1.proj", @$"
+                    <Project>
+                        <Target Name=`Build`>
+                            <Message Text=`Hello EngineShouldHandleExceptionsFromCachePlugin` Importance=`High` />
+                        </Target>
+                    </Project>".Cleanup());
+
+            foreach (var enumValue in Enum.GetValues(typeof(ExceptionLocations)))
+            {
+                var typedValue = (ExceptionLocations) enumValue;
+                if (exceptionLocations.HasFlag(typedValue))
+                {
+                    var exceptionLocation = typedValue.ToString();
+                    _env.SetEnvironmentVariable(exceptionLocation, "1");
+                    _output.WriteLine($"Set exception location: {exceptionLocation}");
+                }
+            }
+
+            using var buildSession = new Helpers.BuildManagerSession(
+                _env,
+                new BuildParameters
+                {
+                    UseSynchronousLogging = true,
+                    ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
+                        SamplePluginAssemblyPath.Value,
+                        new[] {new ProjectGraphEntryPoint(project.Path)},
+                        null)
+                });
+
+            var logger = buildSession.Logger;
+            var buildResult = buildSession.BuildProjectFile(project.Path);
+
+            if (exceptionLocations == ExceptionLocations.EndBuildAsync || exceptionLocations == (ExceptionLocations.GetCacheResultAsync
+                                                                                                 | ExceptionLocations.EndBuildAsync))
+            {
+                var e = Should.Throw<Exception>(() => buildSession.Dispose());
+                e.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+            }
+            else
+            {
+                buildSession.Dispose();
+            }
+
+            var exceptionsThatEndUpInBuildResult = ExceptionLocations.Constructor | ExceptionLocations.BeginBuildAsync | ExceptionLocations.GetCacheResultAsync;
+
+            if ((exceptionsThatEndUpInBuildResult & exceptionLocations) != 0)
+            {
+                buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+                buildResult.Exception.Message.ShouldContain("Cache plugin exception from");
+            }
+
+            if (exceptionLocations == ExceptionLocations.EndBuildAsync)
+            {
+                buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+            }
+
+            var exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ExceptionLocations.Constructor | ExceptionLocations.BeginBuildAsync;
+
+            if ((exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & exceptionLocations) != 0)
+            {
+                logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: GetCacheResultAsync for");
+                logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: EndBuildAsync");
+            }
+            else
+            {
+                logger.FullLog.ShouldContain($"{AssemblyMockCache}: GetCacheResultAsync for");
+                logger.FullLog.ShouldContain($"{AssemblyMockCache}: EndBuildAsync");
+            }
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/TaskItemComparer.cs b/src/Build.UnitTests/TestComparers/TaskItemComparer.cs
similarity index 97%
rename from src/Build.UnitTests/BackEnd/TaskItemComparer.cs
rename to src/Build.UnitTests/TestComparers/TaskItemComparer.cs
index 61e423692eb..cc089195da3 100644
--- a/src/Build.UnitTests/BackEnd/TaskItemComparer.cs
+++ b/src/Build.UnitTests/TestComparers/TaskItemComparer.cs
@@ -5,7 +5,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.UnitTests.BackEnd
+namespace Microsoft.Build.Engine.UnitTests.TestComparers
 {
     /// <summary>
     /// Implementation of IComparer on ITaskItems used for testing.
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 030adec848d..29c2e7c16d6 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Collections.ObjectModel;
@@ -18,14 +19,18 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 
@@ -37,6 +42,9 @@ namespace Microsoft.Build.Execution
     [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Refactoring at the end of Beta1 is not appropriate.")]
     public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
     {
+        // TODO: Remove this when VS gets updated to setup project cache plugins.
+        internal static ConcurrentDictionary<string, ProjectCacheItem> ProjectCacheItems { get; } = new ConcurrentDictionary<string, ProjectCacheItem>();
+
         /// <summary>
         /// The object used for thread-safe synchronization of static members.
         /// </summary>
@@ -233,6 +241,8 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         private DateTime _instantiationTimeUtc;
 
         private IEnumerable<DeferredBuildMessage> _deferredBuildMessages;
+        private Task<ProjectCacheService> _projectCacheService;
+        private bool _projectCacheServiceInstantiatedByVSWorkaround;
 
 #if DEBUG
         /// <summary>
@@ -435,6 +445,12 @@ public void BeginBuild(BuildParameters parameters)
 
                 InitializeCaches();
 
+                if (_buildParameters.ProjectCacheDescriptor != null)
+                {
+                    // TODO: Implement cancellation.
+                    InitializeProjectCacheService(_buildParameters.ProjectCacheDescriptor, CancellationToken.None);
+                }
+
                 _taskHostNodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.TaskHostNodeManager) as INodeManager;
                 _scheduler = ((IBuildComponentHost)this).GetComponent(BuildComponentType.Scheduler) as IScheduler;
 
@@ -539,6 +555,24 @@ void InitializeCaches()
             }
         }
 
+        private void InitializeProjectCacheService(
+            ProjectCacheDescriptor pluginDescriptor,
+            CancellationToken cancellationToken)
+        {
+            if (_projectCacheService != null)
+            {
+                ErrorUtilities.ThrowInternalError("Only one project cache plugin may be set on the BuildManager during a begin / end build session");
+            }
+
+            LogMessage(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("LoadingProjectCachePlugin", pluginDescriptor.GetDetailedDescription()));
+
+            _projectCacheService = ProjectCacheService.FromDescriptorAsync(
+                pluginDescriptor,
+                this,
+                ((IBuildComponentHost) this).LoggingService,
+                cancellationToken);
+        }
+
         /// <summary>
         /// Cancels all outstanding submissions asynchronously.
         /// </summary>
@@ -749,6 +783,8 @@ public void EndBuild()
                 // Stop the graph scheduling thread(s)
                 _graphSchedulingCancellationSource?.Cancel();
 
+                var projectCacheShutdown = _projectCacheService?.Result.ShutDown();
+
                 ErrorUtilities.VerifyThrow(_buildSubmissions.Count == 0 && _graphBuildSubmissions.Count == 0, "All submissions not yet complete.");
                 ErrorUtilities.VerifyThrow(_activeNodes.Count == 0, "All nodes not yet shut down.");
 
@@ -757,6 +793,8 @@ public void EndBuild()
                     SerializeCaches();
                 }
 
+                projectCacheShutdown?.Wait();
+
                 if (loggingService != null)
                 {
                     // Override the build success if the user specified /warnaserror and any errors were logged outside of a build submission.
@@ -798,6 +836,10 @@ public void EndBuild()
                     _resultsCache.ClearResults();
                 }
             }
+            catch (AggregateException ae) when (ae.InnerExceptions.Count == 1)
+            {
+                throw ae.InnerExceptions.First();
+            }
             finally
             {
                 try
@@ -960,117 +1002,314 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));
             ErrorUtilities.VerifyThrow(!submission.IsCompleted, "Submission already complete.");
 
-            lock (_syncLock)
+            bool thisMethodIsAsync = false;
+
+            if (ProjectCacheIsPresent())
+            {
+                thisMethodIsAsync = true;
+
+                // Potential long running operations:
+                //  - submission may need evaluation
+                //  - project cache may need initializing
+                //  - project cache will be queried
+                // Use separate thread to unblock calling thread.
+                Task.Factory.StartNew(
+                    ExecuteSubmissionImpl,
+                    CancellationToken.None,
+                    TaskCreationOptions.LongRunning,
+                    TaskScheduler.Default
+                );
+            }
+            else
+            {
+                ExecuteSubmissionImpl();
+            }
+
+            void ExecuteSubmissionImpl()
             {
-                ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;
-                if (projectInstance != null)
+                lock (_syncLock)
                 {
-                    if (_acquiredProjectRootElementCacheFromProjectInstance)
+                    ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;
+                    if (projectInstance != null)
                     {
-                        ErrorUtilities.VerifyThrowArgument(
-                            _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,
-                            "OM_BuildSubmissionsMultipleProjectCollections");
+                        if (_acquiredProjectRootElementCacheFromProjectInstance)
+                        {
+                            ErrorUtilities.VerifyThrowArgument(
+                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,
+                                "OM_BuildSubmissionsMultipleProjectCollections");
+                        }
+                        else
+                        {
+                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;
+                            _acquiredProjectRootElementCacheFromProjectInstance = true;
+                        }
                     }
-                    else
+                    else if (_buildParameters.ProjectRootElementCache == null)
                     {
-                        _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;
-                        _acquiredProjectRootElementCacheFromProjectInstance = true;
+                        // Create our own cache; if we subsequently get a build submission with a project instance attached,
+                        // we'll dump our cache and use that one.
+                        _buildParameters.ProjectRootElementCache =
+                            new ProjectRootElementCache(false /* do not automatically reload from disk */);
                     }
-                }
-                else if (_buildParameters.ProjectRootElementCache == null)
-                {
-                    // Create our own cache; if we subsequently get a build submission with a project instance attached,
-                    // we'll dump our cache and use that one.
-                    _buildParameters.ProjectRootElementCache =
-                        new ProjectRootElementCache(false /* do not automatically reload from disk */);
-                }
 
-                VerifyStateInternal(BuildManagerState.Building);
+                    VerifyStateInternal(BuildManagerState.Building);
 
-                try
-                {
-                    // If we have an unnamed project, assign it a temporary name.
-                    if (String.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))
+                    try
                     {
-                        ErrorUtilities.VerifyThrow(submission.BuildRequestData.ProjectInstance != null,
-                            "Unexpected null path for a submission with no ProjectInstance.");
-
-                        // If we have already named this instance when it was submitted previously during this build, use the same
-                        // name so that we get the same configuration (and thus don't cause it to rebuild.)
-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance,
-                            out string tempName))
+                        // If we have an unnamed project, assign it a temporary name.
+                        if (string.IsNullOrEmpty(submission.BuildRequestData.ProjectFullPath))
                         {
-                            tempName = "Unnamed_" + _nextUnnamedProjectId++;
-                            _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;
+                            ErrorUtilities.VerifyThrow(
+                                submission.BuildRequestData.ProjectInstance != null,
+                                "Unexpected null path for a submission with no ProjectInstance.");
+
+                            // If we have already named this instance when it was submitted previously during this build, use the same
+                            // name so that we get the same configuration (and thus don't cause it to rebuild.)
+                            if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance, out var tempName))
+                            {
+                                tempName = "Unnamed_" + _nextUnnamedProjectId++;
+                                _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;
+                            }
+
+                            submission.BuildRequestData.ProjectFullPath = Path.Combine(
+                                submission.BuildRequestData.ProjectInstance.GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue,
+                                tempName);
                         }
 
-                        submission.BuildRequestData.ProjectFullPath = Path.Combine(
-                            submission.BuildRequestData.ProjectInstance
-                                .GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue, tempName);
-                    }
+                        // Create/Retrieve a configuration for each request
+                        var buildRequestConfiguration = new BuildRequestConfiguration(submission.BuildRequestData, _buildParameters.DefaultToolsVersion);
+                        var matchingConfiguration = _configCache.GetMatchingConfiguration(buildRequestConfiguration);
+                        var newConfiguration = ResolveConfiguration(
+                            buildRequestConfiguration,
+                            matchingConfiguration,
+                            submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags.ReplaceExistingProjectInstance));
 
-                    // Create/Retrieve a configuration for each request
-                    BuildRequestConfiguration buildRequestConfiguration =
-                        new BuildRequestConfiguration(submission.BuildRequestData,
-                            _buildParameters.DefaultToolsVersion);
-                    BuildRequestConfiguration matchingConfiguration =
-                        _configCache.GetMatchingConfiguration(buildRequestConfiguration);
-                    BuildRequestConfiguration newConfiguration = ResolveConfiguration(buildRequestConfiguration,
-                        matchingConfiguration,
-                        submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags
-                            .ReplaceExistingProjectInstance));
-
-                    newConfiguration.ExplicitlyLoaded = true;
-
-                    // Now create the build request
-                    submission.BuildRequest = new BuildRequest(
-                        submission.SubmissionId,
-                        BackEnd.BuildRequest.InvalidNodeRequestId,
-                        newConfiguration.ConfigurationId,
-                        submission.BuildRequestData.TargetNames,
-                        submission.BuildRequestData.HostServices,
-                        BuildEventContext.Invalid,
-                        null,
-                        submission.BuildRequestData.Flags,
-                        submission.BuildRequestData.RequestedProjectState);
+                        newConfiguration.ExplicitlyLoaded = true;
 
-                    if (_shuttingDown)
-                    {
-                        // We were already canceled!
-                        BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());
-                        submission.CompleteResults(result);
-                        submission.CompleteLogging(true);
-                        CheckSubmissionCompletenessAndRemove(submission);
-                        return;
-                    }
+                        submission.BuildRequest = CreateRealBuildRequest(submission, newConfiguration.ConfigurationId);
 
-                    // Submit the build request.
-                    _workQueue.Post(() =>
-                    {
-                        try
+                        // TODO: Remove this when VS gets updated to setup project cache plugins.
+                        AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio(submission, newConfiguration);
+
+                        CacheResult cacheResult = null;
+                        if (_projectCacheService != null)
                         {
-                            IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);
+                            cacheResult = QueryCache(submission, newConfiguration);
                         }
-                        catch (BuildAbortedException bae)
+
+                        if (cacheResult == null || cacheResult.ResultType != CacheResultType.CacheHit)
                         {
-                            // We were canceled before we got issued by the work queue.
-                            var result = new BuildResult(submission.BuildRequest, bae);
-                            submission.CompleteResults(result);
-                            submission.CompleteLogging(true);
-                            CheckSubmissionCompletenessAndRemove(submission);
+                            // Issue the real build request.
+                            SubmitBuildRequest();
+                        }
+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)
+                        {
+                            // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid ProjectInstance serialization).
+                            // The proxy target results are used as results for the real targets.
+
+                            submission.BuildRequest = CreateProxyBuildRequest(
+                                submission,
+                                newConfiguration.ConfigurationId,
+                                cacheResult.ProxyTargets);
+
+                            SubmitBuildRequest();
+                        }
+                        else if (cacheResult?.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)
+                        {
+                            // Mark the build submission as complete with the provided results and return.
+                            var result = new BuildResult(submission.BuildRequest);
+
+                            foreach (var targetResult in cacheResult.BuildResult.ResultsByTarget)
+                            {
+                                result.AddResultsForTarget(targetResult.Key, targetResult.Value);
+                            }
+
+                            _resultsCache.AddResult(result);
+                            submission.CompleteLogging(false);
+                            ReportResultsToSubmission(result);
                         }
-                        catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+                    }
+                    catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+                    {
+                        HandleExecuteSubmissionException(submission, ex);
+                        throw;
+                    }
+                    catch (Exception ex) when (thisMethodIsAsync)
+                    {
+                        OnThreadException(ex);
+                    }
+                    void SubmitBuildRequest()
+                    {
+                        if (CheckForShutdown())
                         {
-                            HandleExecuteSubmissionException(submission, ex);
+                            return;
                         }
-                    });
+
+                        _workQueue.Post(
+                            () =>
+                            {
+                                try
+                                {
+                                    IssueBuildSubmissionToScheduler(submission, allowMainThreadBuild);
+                                }
+                                catch (BuildAbortedException bae)
+                                {
+                                    // We were canceled before we got issued by the work queue.
+                                    var result = new BuildResult(submission.BuildRequest, bae);
+                                    submission.CompleteResults(result);
+                                    submission.CompleteLogging(true);
+                                    CheckSubmissionCompletenessAndRemove(submission);
+                                }
+                                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+                                {
+                                    HandleExecuteSubmissionException(submission, ex);
+                                }
+                            });
+                    }
                 }
-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+            }
+
+            bool ProjectCacheIsPresent()
+            {
+                return _projectCacheService != null ||
+                       _buildParameters.ProjectCacheDescriptor != null ||
+                       (BuildEnvironmentHelper.Instance.RunningInVisualStudio && ProjectCacheItems.Count > 0);
+            }
+
+            bool CheckForShutdown()
+            {
+                if (!_shuttingDown)
                 {
-                    HandleExecuteSubmissionException(submission, ex);
+                    return false;
+                }
+
+                // We were already canceled!
+                var result = new BuildResult(submission.BuildRequest, new BuildAbortedException());
+                submission.CompleteResults(result);
+                submission.CompleteLogging(true);
+                CheckSubmissionCompletenessAndRemove(submission);
+
+                return true;
+            }
+
+            CacheResult QueryCache(BuildSubmission buildSubmission, BuildRequestConfiguration newConfiguration)
+            {
+                ProjectCacheService cacheService = null;
+
+                try
+                {
+                    cacheService = _projectCacheService.Result;
+                }
+                catch
+                {
+                    // Set to null so that EndBuild does not try to shut it down and thus rethrow the exception.
+                    _projectCacheService = null;
                     throw;
                 }
+
+                // Project cache plugins require an evaluated project. Evaluate the submission if it's by path.
+                LoadSubmissionProjectIntoConfiguration(buildSubmission, newConfiguration);
+
+                var cacheResult = cacheService.GetCacheResultAsync(
+                        new BuildRequestData(
+                            newConfiguration.Project,
+                            buildSubmission.BuildRequestData.TargetNames.ToArray()))
+                    .GetAwaiter()
+                    .GetResult();
+
+                return cacheResult;
+            }
+
+            static BuildRequest CreateRealBuildRequest(BuildSubmission submission, int configurationId)
+            {
+                return new BuildRequest(
+                    submission.SubmissionId,
+                    BackEnd.BuildRequest.InvalidNodeRequestId,
+                    configurationId,
+                    submission.BuildRequestData.TargetNames,
+                    submission.BuildRequestData.HostServices,
+                    BuildEventContext.Invalid,
+                    null,
+                    submission.BuildRequestData.Flags,
+                    submission.BuildRequestData.RequestedProjectState);
+            }
+
+            static BuildRequest CreateProxyBuildRequest(
+                BuildSubmission submission,
+                int configurationId,
+                ProxyTargets proxyTargets)
+            {
+                return new BuildRequest(
+                    submission.SubmissionId,
+                    BackEnd.BuildRequest.InvalidNodeRequestId,
+                    configurationId,
+                    proxyTargets,
+                    submission.BuildRequestData.HostServices,
+                    submission.BuildRequestData.Flags,
+                    submission.BuildRequestData.RequestedProjectState);
+            }
+        }
+
+        private void AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio(
+            BuildSubmission submission,
+            BuildRequestConfiguration config)
+        {
+            if (BuildEnvironmentHelper.Instance.RunningInVisualStudio &&
+                ProjectCacheItems.Count > 0 &&
+                !_projectCacheServiceInstantiatedByVSWorkaround &&
+                _projectCacheService == null &&
+                _buildParameters.ProjectCacheDescriptor == null)
+            {
+                _projectCacheServiceInstantiatedByVSWorkaround = true;
+                ErrorUtilities.VerifyThrowInvalidOperation(
+                    ProjectCacheItems.Count == 1,
+                    "OnlyOneCachePluginMustBeSpecified",
+                    string.Join("; ", ProjectCacheItems.Values.Select(c => c.PluginPath)));
+
+                LoadSubmissionProjectIntoConfiguration(submission, config);
+
+                if (IsDesignTimeBuild(config.Project))
+                {
+                    // Design time builds do not use the project cache.
+                    return;
+                }
+
+                var solutionPath = config.Project.GetPropertyValue(SolutionProjectGenerator.SolutionPathPropertyName);
+
+                ErrorUtilities.VerifyThrow(
+                    solutionPath != null && !string.IsNullOrWhiteSpace(solutionPath) && solutionPath != "*Undefined*",
+                    $"Expected VS to set a valid SolutionPath property but got: {solutionPath}");
+                ErrorUtilities.VerifyThrow(
+                    FileSystems.Default.FileExists(solutionPath),
+                    $"Solution file does not exist: {solutionPath}");
+
+                var projectCacheItem = ProjectCacheItems.First().Value;
+
+                InitializeProjectCacheService(
+                    ProjectCacheDescriptor.FromAssemblyPath(
+                        projectCacheItem.PluginPath,
+                        new[]
+                        {
+                            new ProjectGraphEntryPoint(
+                                solutionPath,
+                                config.Project.GlobalProperties)
+                        },
+                        null,
+                        projectCacheItem.PluginSettings),
+                    CancellationToken.None);
+            }
+
+            static bool IsDesignTimeBuild(ProjectInstance project)
+            {
+                var designTimeBuild = project.GetPropertyValue(DesignTimeProperties.DesignTimeBuild);
+                var buildingProject = project.GlobalPropertiesDictionary[DesignTimeProperties.BuildingProject]?.EvaluatedValue;
+
+                return MSBuildStringIsTrue(designTimeBuild) ||
+                       buildingProject != null && !MSBuildStringIsTrue(buildingProject);
             }
+
+            static bool MSBuildStringIsTrue(string msbuildString) =>
+                ConversionUtilities.ConvertStringToBool(msbuildString, nullOrWhitespaceIsFalse: true);
         }
 
         /// <summary>
@@ -1126,10 +1365,27 @@ internal void ExecuteSubmission(GraphBuildSubmission submission)
             }
         }
 
+        private void LoadSubmissionProjectIntoConfiguration(BuildSubmission submission, BuildRequestConfiguration config)
+        {
+            if (!config.IsLoaded)
+            {
+                config.LoadProjectIntoConfiguration(
+                    this,
+                    submission.BuildRequestData.Flags,
+                    submission.SubmissionId,
+                    Scheduler.InProcNodeId
+                );
+
+                // If we're taking the time to evaluate, avoid having other nodes to repeat the same evaluation.
+                // Based on the assumption that ProjectInstance serialization is faster than evaluating from scratch.
+                config.Project.TranslateEntireState = true;
+            }
+        }
+
         /// <summary>
         /// Creates the traversal and metaproject instances necessary to represent the solution and populates new configurations with them.
         /// </summary>
-        internal void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, BuildRequest request)
+        private void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, BuildRequest request)
         {
             if (config.IsLoaded)
             {
@@ -1138,7 +1394,17 @@ internal void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, Bu
             }
 
             ErrorUtilities.VerifyThrow(FileUtilities.IsSolutionFilename(config.ProjectFullPath), "{0} is not a solution", config.ProjectFullPath);
-            ProjectInstance[] instances = ProjectInstance.LoadSolutionForBuild(config.ProjectFullPath, config.GlobalProperties, config.ExplicitToolsVersionSpecified ? config.ToolsVersion : null, _buildParameters, ((IBuildComponentHost)this).LoggingService, request.BuildEventContext, false /* loaded by solution parser*/, config.TargetNames, SdkResolverService, request.SubmissionId);
+            var instances = ProjectInstance.LoadSolutionForBuild(
+                config.ProjectFullPath,
+                config.GlobalProperties,
+                config.ExplicitToolsVersionSpecified ? config.ToolsVersion : null,
+                _buildParameters,
+                ((IBuildComponentHost) this).LoggingService,
+                request.BuildEventContext,
+                false /* loaded by solution parser*/,
+                config.TargetNames,
+                SdkResolverService,
+                request.SubmissionId);
 
             // The first instance is the traversal project, which goes into this configuration
             config.Project = instances[0];
@@ -1287,6 +1553,10 @@ private void ProcessPacket(int node, INodePacket packet)
         /// </summary>
         private void HandleExecuteSubmissionException(BuildSubmission submission, Exception ex)
         {
+            if (ex is AggregateException ae && ae.InnerExceptions.Count == 1)
+            {
+                ex = ae.InnerExceptions.First();
+            }
             if (ex is InvalidProjectFileException projectException)
             {
                 if (!projectException.HasBeenLogged)
@@ -1324,6 +1594,10 @@ private void HandleExecuteSubmissionException(GraphBuildSubmission submission, E
                 }
             }
 
+            ex = ex is AggregateException ae && ae.InnerExceptions.Count == 1
+                ? ae.InnerExceptions.First()
+                : ex;
+
             if (submission.IsStarted)
             {
                 submission.CompleteResults(new GraphBuildResult(submission.SubmissionId, ex));
@@ -1447,7 +1721,11 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                         projectGraph.ConstructionMetrics.NodeCount,
                         projectGraph.ConstructionMetrics.EdgeCount));
 
-                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
+                var targetListTask = Task.Run(() => projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames));
+                var cacheServiceTask = Task.Run(() => SearchAndInitializeProjectCachePluginFromGraph(projectGraph));
+
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = targetListTask.Result;
+                using var cacheService = cacheServiceTask.Result;
 
                 var waitHandle = new AutoResetEvent(true);
                 var graphBuildStateLock = new object();
@@ -1455,7 +1733,8 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                 var blockedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes);
                 var finishedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes.Count);
                 var buildingNodes = new Dictionary<BuildSubmission, ProjectGraphNode>();
-                Dictionary<ProjectGraphNode, BuildResult> resultsPerNode = new Dictionary<ProjectGraphNode, BuildResult>(projectGraph.ProjectNodes.Count);
+                var resultsPerNode = new Dictionary<ProjectGraphNode, BuildResult>(projectGraph.ProjectNodes.Count);
+
                 while (blockedNodes.Count > 0 || buildingNodes.Count > 0)
                 {
                     waitHandle.WaitOne();
@@ -1562,6 +1841,96 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
             }
         }
 
+        private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(ProjectGraph projectGraph)
+        {
+            // TODO: Consider allowing parallel graph submissions, each with its own separate cache plugin. Right now the second graph submission with a cache will fail.
+
+            if (_buildParameters.ProjectCacheDescriptor != null)
+            {
+                // Build parameter specified project cache takes precedence.
+                return new DisposePluginService(null);
+            }
+
+            var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(
+                n => n,
+                n => n.ProjectInstance.GetItems(ItemTypeNames.ProjectCachePlugin)
+                    .Select(
+                        i =>
+                        {
+                            var metadataDictionary = i.Metadata.ToDictionary(
+                                m => ((IKeyed) m).Key,
+                                m => ((IValued) m).EscapedValue);
+
+                            var pluginPath = Path.Combine(i.Project.Directory, i.EvaluatedInclude);
+
+                            var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);
+
+                            return projectCacheItem;
+                        })
+                    .ToArray());
+
+            var cacheItems = nodeToCacheItems.Values.SelectMany(i => i).ToHashSet();
+
+            if (cacheItems.Count == 0)
+            {
+                return new DisposePluginService(null);
+            }
+
+            ErrorUtilities.VerifyThrowInvalidOperation(
+                cacheItems.Count == 1,
+                "OnlyOneCachePluginMustBeSpecified",
+                string.Join("; ", cacheItems.Select(ci => ci.PluginPath)));
+
+            var nodesWithoutCacheItems = nodeToCacheItems.Where(kvp => kvp.Value.Length == 0).ToArray();
+
+            if (nodesWithoutCacheItems.Length > 0)
+            {
+                ErrorUtilities.ThrowInvalidOperation(
+                    "NotAllNodesDefineACacheItem",
+                    ItemTypeNames.ProjectCachePlugin,
+                    string.Join(", ", nodesWithoutCacheItems.Select(kvp => kvp.Key.ProjectInstance.FullPath)));
+            }
+
+            var cacheItem = cacheItems.First();
+
+            lock (_syncLock)
+            {
+                InitializeProjectCacheService(
+                    ProjectCacheDescriptor.FromAssemblyPath(
+                        cacheItem.PluginPath,
+                        entryPoints: null,
+                        projectGraph,
+                        cacheItem.PluginSettings),
+                    _graphSchedulingCancellationSource.Token);
+            }
+
+            return new DisposePluginService(this);
+        }
+
+        private class DisposePluginService : IDisposable
+        {
+            private readonly BuildManager _buildManager;
+
+            public DisposePluginService(BuildManager buildManager)
+            {
+                _buildManager = buildManager;
+            }
+
+            public void Dispose()
+            {
+                if (_buildManager == null)
+                {
+                    return;
+                }
+
+                lock (_buildManager._syncLock)
+                {
+                    _buildManager._projectCacheService?.Result.ShutDown().GetAwaiter().GetResult();
+                    _buildManager._projectCacheService = null;
+                }
+            }
+        }
+
         /// <summary>
         /// Asks the nodeManager to tell the currently connected nodes to shut down and sets a flag preventing all non-shutdown-related packets from
         /// being processed.
@@ -1630,6 +1999,7 @@ private void Reset()
             _nodeManager.UnregisterPacketHandler(NodePacketType.BuildRequestConfigurationResponse);
             _nodeManager.UnregisterPacketHandler(NodePacketType.BuildResult);
             _nodeManager.UnregisterPacketHandler(NodePacketType.NodeShutdown);
+
             _nodeManager.ClearPerBuildState();
             _nodeManager = null;
 
@@ -1637,10 +2007,13 @@ private void Reset()
             _nodeConfiguration = null;
             _buildSubmissions.Clear();
             _graphBuildSubmissions.Clear();
+
             _scheduler.Reset();
             _scheduler = null;
             _workQueue = null;
             _graphSchedulingCancellationSource = null;
+            _projectCacheService = null;
+            _projectCacheServiceInstantiatedByVSWorkaround = false;
             _acquiredProjectRootElementCacheFromProjectInstance = false;
 
             _unnamedProjectInstanceToNames.Clear();
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 355822a0330..1129274ba2f 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -10,7 +10,9 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Graph;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -296,6 +298,7 @@ private BuildParameters(BuildParameters other)
             _outputResultsCacheFile = other._outputResultsCacheFile;
             DiscardBuildResults = other.DiscardBuildResults;
             LowPriority = other.LowPriority;
+            ProjectCacheDescriptor = other.ProjectCacheDescriptor;
         }
 
 #if FEATURE_THREAD_PRIORITY
@@ -555,7 +558,7 @@ public bool OnlyLogCriticalEvents
         /// <comments>
         /// toolsetProvider.Toolsets is already a readonly collection.
         /// </comments>
-        public ICollection<Toolset> Toolsets => _toolsetProvider.Toolsets;
+        public ICollection<Toolset> Toolsets => ToolsetProvider.Toolsets;
 
         /// <summary>
         /// The name of the UI culture to use during the build.
@@ -780,6 +783,14 @@ public string OutputResultsCacheFile
         /// </summary>
         public bool LowPriority { get; set; }
 
+        /// <summary>
+        /// If set, the BuildManager will query all
+        /// incoming <see cref="BuildSubmission"/> requests against the specified project cache.
+        /// Any <see cref="GraphBuildSubmission"/> requests will also use this project cache instead of
+        /// the potential project caches described in graph node's evaluations.
+        /// </summary>
+        public ProjectCacheDescriptor ProjectCacheDescriptor { get; set; }
+
         /// <summary>
         /// Retrieves a toolset.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
new file mode 100644
index 00000000000..bc7354b9a90
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
@@ -0,0 +1,44 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System.Collections.Generic;
+using Microsoft.Build.FileSystem;
+using Microsoft.Build.Graph;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    ///     Holds various information about the current msbuild execution that the cache might use.
+    ///     The cache may need to know about the top level projects or the entire project graph, so MSBuild
+    ///     provides a graph when one is available. When it isn't available, MSBuild provides the top level projects
+    ///     and the plugin can construct its own graph based on those.
+    ///     So either <see cref="Graph" />is null, or <see cref="GraphEntryPoints" /> is null. But not both.
+    /// </summary>
+    public class CacheContext
+    {
+        public IReadOnlyDictionary<string, string> PluginSettings { get; }
+        public ProjectGraph? Graph { get; }
+        public IReadOnlyCollection<ProjectGraphEntryPoint>? GraphEntryPoints { get; }
+        public string? MSBuildExePath { get; }
+        public MSBuildFileSystemBase FileSystem { get; }
+
+        public CacheContext(
+            IReadOnlyDictionary<string, string> pluginSettings,
+            MSBuildFileSystemBase fileSystem,
+            ProjectGraph? graph = null,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = null)
+        {
+            ErrorUtilities.VerifyThrow(
+                (graph != null) ^ (graphEntryPoints != null),
+                "Either Graph is specified, or GraphEntryPoints is specified. Not both.");
+
+            PluginSettings = pluginSettings;
+            Graph = graph;
+            GraphEntryPoints = graphEntryPoints;
+            MSBuildExePath = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
+            FileSystem = fileSystem;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
new file mode 100644
index 00000000000..af194e45728
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
@@ -0,0 +1,128 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    /// Result types that a plugin can return for a given build request.
+    /// </summary>
+    public enum CacheResultType
+    {
+        /// <summary>
+        /// The plugin failed and couldn't return a result. The plugin should log an error detailing the failure. MSBuild will stop the build.
+        /// </summary>
+        None = 0,
+
+        /// <summary>
+        /// The plugin determined that it supports a build request and found that it can be skipped. MSBuild won't build the request.
+        /// </summary>
+        CacheHit,
+
+        /// <summary>
+        /// The plugin determined that it supports a build request and found that it cannot be skipped. MSBuild will build the request.
+        /// </summary>
+        CacheMiss,
+
+        /// <summary>
+        /// The plugin determined that it does not support a certain build request. MSBuild will build the request.
+        /// For example, a plugin may not support projects with a certain extension, certain properties, or certain called targets.
+        /// </summary>
+        CacheNotApplicable
+    }
+
+    /// <summary>
+    ///     Represents the cache result a plugin returns back to MSBuild when queried about a certain project.
+    ///     Results representing cache hits (with <see cref="ResultType"/> == <see cref="CacheResultType.CacheHit"/>)
+    ///     contain information about what <see cref="Execution.BuildResult"/> MSBuild should use for the queried project.
+    ///     It is assumed that all cache hits result in a successful <see cref="Execution.BuildResult"/>.
+    /// </summary>
+    public class CacheResult
+    {
+        private CacheResult(
+            CacheResultType resultType,
+            BuildResult? buildResult = null,
+            ProxyTargets? proxyTargets = null)
+        {
+            if (resultType == CacheResultType.CacheHit)
+            {
+                ErrorUtilities.VerifyThrow(
+                    buildResult != null ^ proxyTargets != null,
+                    "Either buildResult is specified, or proxyTargets is specified. Not both.");
+            }
+
+            ResultType = resultType;
+            BuildResult = buildResult;
+            ProxyTargets = proxyTargets;
+        }
+
+        internal CacheResultType ResultType { get; }
+        internal BuildResult? BuildResult { get; }
+        internal ProxyTargets? ProxyTargets { get; }
+
+        public static CacheResult IndicateCacheHit(BuildResult buildResult)
+        {
+            return new CacheResult(CacheResultType.CacheHit, buildResult);
+        }
+
+        public static CacheResult IndicateCacheHit(ProxyTargets proxyTargets)
+        {
+            return new CacheResult(CacheResultType.CacheHit, proxyTargets: proxyTargets);
+        }
+
+        public static CacheResult IndicateCacheHit(IReadOnlyCollection<PluginTargetResult> targetResults)
+        {
+            ErrorUtilities.VerifyThrowArgumentLength(targetResults, nameof(targetResults));
+
+            return new CacheResult(CacheResultType.CacheHit, ConstructBuildResult(targetResults));
+        }
+
+        public static CacheResult IndicateNonCacheHit(CacheResultType resultType)
+        {
+            ErrorUtilities.VerifyThrowInvalidOperation(resultType != CacheResultType.CacheHit, "CantBeCacheHit");
+            return new CacheResult(resultType);
+        }
+
+        private static BuildResult ConstructBuildResult(IReadOnlyCollection<PluginTargetResult> targetResults)
+        {
+            var buildResult = new BuildResult();
+
+            foreach (var pluginTargetResult in targetResults)
+            {
+                buildResult.AddResultsForTarget(
+                    pluginTargetResult.TargetName,
+                    new TargetResult(
+                        pluginTargetResult.TaskItems.Select(ti => CreateTaskItem(ti)).ToArray(),
+                        CreateWorkUnitResult(pluginTargetResult.ResultCode)));
+            }
+
+            return buildResult;
+        }
+
+        private static WorkUnitResult CreateWorkUnitResult(BuildResultCode resultCode)
+        {
+            return resultCode == BuildResultCode.Success
+                ? new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null)
+                : new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null);
+        }
+
+        private static ProjectItemInstance.TaskItem CreateTaskItem(ITaskItem2 taskItemInterface)
+        {
+            var taskItem = new ProjectItemInstance.TaskItem(taskItemInterface.EvaluatedIncludeEscaped, null);
+
+            foreach (string metadataName in taskItemInterface.MetadataNames)
+            {
+                taskItem.SetMetadata(metadataName, taskItemInterface.GetMetadataValueEscaped(metadataName));
+            }
+
+            return taskItem;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs b/src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs
new file mode 100644
index 00000000000..15ae99e97f5
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/PluginLoggerBase.cs
@@ -0,0 +1,32 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    ///     Events logged with this logger will get pushed into MSBuild's logging infrastructure.
+    /// </summary>
+    public abstract class PluginLoggerBase
+    {
+        protected PluginLoggerBase(LoggerVerbosity verbosity)
+        {
+            Verbosity = verbosity;
+        }
+
+        /// <summary>
+        ///     See <see cref="ILogger.Verbosity" />
+        /// </summary>
+        private LoggerVerbosity Verbosity { get; }
+
+        public abstract bool HasLoggedErrors { get; protected set; }
+
+        public abstract void LogMessage(string message, MessageImportance? messageImportance = null);
+
+        public abstract void LogWarning(string warning);
+
+        public abstract void LogError(string error);
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/PluginTargetResult.cs b/src/Build/BackEnd/Components/ProjectCache/PluginTargetResult.cs
new file mode 100644
index 00000000000..7afe81169c0
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/PluginTargetResult.cs
@@ -0,0 +1,31 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System.Collections.Generic;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    ///     A cache hit can use this to instruct MSBuild to construct a BuildResult with the target result specified in this
+    ///     type.
+    /// </summary>
+    public readonly struct PluginTargetResult
+    {
+        public string TargetName { get; }
+        public IReadOnlyCollection<ITaskItem2> TaskItems { get; }
+        public BuildResultCode ResultCode { get; }
+
+        public PluginTargetResult(
+            string targetName,
+            IReadOnlyCollection<ITaskItem2> taskItems,
+            BuildResultCode resultCode)
+        {
+            TargetName = targetName;
+            TaskItems = taskItems;
+            ResultCode = resultCode;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
new file mode 100644
index 00000000000..22d98780b2b
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs
@@ -0,0 +1,113 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.Graph;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    public class ProjectCacheDescriptor
+    {
+        /// <summary>
+        ///     The path to the assembly containing the project cache plugin.
+        /// </summary>
+        public string? PluginAssemblyPath { get; }
+
+        /// <summary>
+        ///     The entry points with which the plugin will be initialized.
+        /// </summary>
+        public IReadOnlyCollection<ProjectGraphEntryPoint>? EntryPoints { get; }
+
+        /// <summary>
+        ///     The graph with which the plugin will be initialized.
+        /// </summary>
+        public ProjectGraph? ProjectGraph { get; }
+
+        public IReadOnlyDictionary<string, string> PluginSettings { get; }
+
+        public ProjectCachePluginBase? PluginInstance { get; }
+
+        private ProjectCacheDescriptor(
+            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
+            ProjectGraph? projectGraph,
+            IReadOnlyDictionary<string, string>? pluginSettings)
+        {
+            ErrorUtilities.VerifyThrowArgument(
+                (entryPoints == null) ^ (projectGraph == null),
+                "EitherEntryPointsOrTheProjectGraphIsSet");
+
+            EntryPoints = entryPoints;
+            ProjectGraph = projectGraph;
+            PluginSettings = pluginSettings ?? new Dictionary<string, string>();
+        }
+
+        private ProjectCacheDescriptor(
+            string pluginAssemblyPath,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
+            ProjectGraph? projectGraph,
+            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)
+        {
+            PluginAssemblyPath = pluginAssemblyPath;
+        }
+
+        private ProjectCacheDescriptor(
+            ProjectCachePluginBase pluginInstance,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
+            ProjectGraph? projectGraph,
+            IReadOnlyDictionary<string, string>? pluginSettings) : this(entryPoints, projectGraph, pluginSettings)
+        {
+            PluginInstance = pluginInstance;
+        }
+
+        public static ProjectCacheDescriptor FromAssemblyPath(
+            string pluginAssemblyPath,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
+            ProjectGraph? projectGraph,
+            IReadOnlyDictionary<string, string>? pluginSettings = null)
+        {
+            return new ProjectCacheDescriptor(pluginAssemblyPath, entryPoints, projectGraph, pluginSettings);
+        }
+
+        public static ProjectCacheDescriptor FromInstance(
+            ProjectCachePluginBase pluginInstance,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? entryPoints,
+            ProjectGraph? projectGraph,
+            IReadOnlyDictionary<string, string>? pluginSettings = null)
+        {
+            return new ProjectCacheDescriptor(pluginInstance, entryPoints, projectGraph, pluginSettings);
+        }
+
+        public string GetDetailedDescription()
+        {
+            var loadStyle = PluginInstance != null
+                ? $"Instance based: {PluginInstance.GetType().AssemblyQualifiedName}"
+                : $"Assembly path based: {PluginAssemblyPath}";
+
+            var entryPointStyle = EntryPoints != null
+                ? "Graph entrypoint based"
+                : "Static graph based";
+
+            var entryPoints = EntryPoints != null
+                ? string.Join(
+                    "\n",
+                    EntryPoints.Select(e => $"{e.ProjectFile} {{{FormatGlobalProperties(e.GlobalProperties)}}}"))
+                : string.Join(
+                    "\n",
+                    ProjectGraph!.EntryPointNodes.Select(
+                        n =>
+                            $"{n.ProjectInstance.FullPath} {{{FormatGlobalProperties(n.ProjectInstance.GlobalProperties)}}}"));
+
+            return $"{loadStyle}\nEntry-point style: {entryPointStyle}\nEntry-points:\n{entryPoints}";
+
+            static string FormatGlobalProperties(IDictionary<string, string>? globalProperties)
+            {
+                return globalProperties == null
+                    ? string.Empty
+                    : string.Join(", ", globalProperties.Select(gp => $"{gp.Key}={gp.Value}"));
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs
new file mode 100644
index 00000000000..21af5dd54ed
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheItem.cs
@@ -0,0 +1,70 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    internal class ProjectCacheItem : IEquatable<ProjectCacheItem>
+    {
+        private readonly IReadOnlyCollection<KeyValuePair<string, string>> _pluginSettingsSorted;
+
+        public ProjectCacheItem(string pluginPath, IReadOnlyDictionary<string, string> pluginSettings)
+        {
+            PluginPath = pluginPath;
+
+            PluginSettings = pluginSettings;
+
+            // Sort by key to avoid doing it during hashcode computation.
+            _pluginSettingsSorted = pluginSettings.OrderBy(_ => _.Key).ToArray();
+        }
+
+        public string PluginPath { get; }
+        public IReadOnlyDictionary<string, string> PluginSettings { get; }
+
+        public bool Equals(ProjectCacheItem other)
+        {
+            if (ReferenceEquals(this, other))
+            {
+                return true;
+            }
+
+            return PluginPath == other.PluginPath &&
+                   CollectionHelpers.DictionaryEquals(PluginSettings, other.PluginSettings);
+        }
+
+        public override bool Equals(object obj)
+        {
+            if (ReferenceEquals(this, obj))
+            {
+                return true;
+            }
+
+            if (obj.GetType() != GetType())
+            {
+                return false;
+            }
+
+            return Equals((ProjectCacheItem) obj);
+        }
+
+        public override int GetHashCode()
+        {
+            int hashCode = -1043047289;
+
+            hashCode = (hashCode * -1521134295) + PluginPath.GetHashCode();
+
+            foreach (var pluginSetting in _pluginSettingsSorted)
+            {
+                hashCode = (hashCode * -1521134295) + pluginSetting.Key.GetHashCode();
+                hashCode = (hashCode * -1521134295) + pluginSetting.Value.GetHashCode();
+            }
+
+            return hashCode;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
new file mode 100644
index 00000000000..2fe895fe150
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
@@ -0,0 +1,43 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.Execution;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    ///     Only one plugin instance can exist for a given BuildManager BeginBuild / EndBuild session.
+    /// </summary>
+    public abstract class ProjectCachePluginBase
+    {
+        /// <summary>
+        ///     Called once before the build, to have the plugin instantiate its state.
+        ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
+        /// </summary>
+        public abstract Task BeginBuildAsync(
+            CacheContext context,
+            PluginLoggerBase logger,
+            CancellationToken cancellationToken);
+
+        /// <summary>
+        ///     Called once for each build request.
+        ///     Operation needs to be atomic. Any side effects (IO, environment variables, etc) need to be reverted upon
+        ///     cancellation.
+        ///     MSBuild may choose to cancel this method and build the project itself.
+        ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
+        /// </summary>
+        public abstract Task<CacheResult> GetCacheResultAsync(
+            BuildRequestData buildRequest,
+            PluginLoggerBase logger,
+            CancellationToken cancellationToken);
+
+        /// <summary>
+        ///     Called once after all the build to let the plugin do any post build operations (log metrics, cleanup, etc).
+        ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
+        /// </summary>
+        public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
new file mode 100644
index 00000000000..340d613c1c3
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -0,0 +1,239 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Execution;
+using Microsoft.Build.FileSystem;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    internal class ProjectCacheService
+    {
+        private readonly BuildManager _buildManager;
+        private readonly PluginLoggerBase _logger;
+        private readonly ProjectCacheDescriptor _projectCacheDescriptor;
+        private readonly CancellationToken _cancellationToken;
+        private readonly ProjectCachePluginBase _projectCachePlugin;
+
+        private ProjectCacheService(
+            ProjectCachePluginBase projectCachePlugin,
+            BuildManager buildManager,
+            PluginLoggerBase logger,
+            ProjectCacheDescriptor projectCacheDescriptor,
+            CancellationToken cancellationToken)
+        {
+            _projectCachePlugin = projectCachePlugin;
+            _buildManager = buildManager;
+            _logger = logger;
+            _projectCacheDescriptor = projectCacheDescriptor;
+            _cancellationToken = cancellationToken;
+        }
+
+        public static async Task<ProjectCacheService> FromDescriptorAsync(
+            ProjectCacheDescriptor pluginDescriptor,
+            BuildManager buildManager,
+            ILoggingService loggingService,
+            CancellationToken cancellationToken)
+        {
+            var plugin = await Task.Run(() => GetPluginInstance(pluginDescriptor), cancellationToken)
+                .ConfigureAwait(false);
+
+            // TODO: Detect and use the highest verbosity from all the user defined loggers. That's tricky because right now we can't discern between user set loggers and msbuild's internally added loggers.
+            var logger = new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService);
+
+            await plugin.BeginBuildAsync(
+                new CacheContext(
+                    pluginDescriptor.PluginSettings,
+                    new IFileSystemAdapter(FileSystems.Default),
+                    pluginDescriptor.ProjectGraph,
+                    pluginDescriptor.EntryPoints),
+                // TODO: Detect verbosity from logging service.
+                logger,
+                cancellationToken);
+
+            if (logger.HasLoggedErrors)
+            {
+                throw new Exception(
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectCacheInitializationFailed"));
+            }
+
+            return new ProjectCacheService(plugin, buildManager, logger, pluginDescriptor, cancellationToken);
+        }
+
+        private static ProjectCachePluginBase GetPluginInstance(ProjectCacheDescriptor pluginDescriptor)
+        {
+            if (pluginDescriptor.PluginInstance != null)
+            {
+                return pluginDescriptor.PluginInstance;
+            }
+            if (pluginDescriptor.PluginAssemblyPath != null)
+            {
+                return GetPluginInstanceFromType(GetTypeFromAssemblyPath(pluginDescriptor.PluginAssemblyPath));
+            }
+
+            ErrorUtilities.ThrowInternalErrorUnreachable();
+
+#pragma warning disable CS8603 // Possible null reference return.
+            return null;
+#pragma warning restore CS8603 // Possible null reference return.
+        }
+
+        private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
+        {
+            try
+            {
+                return (ProjectCachePluginBase) Activator.CreateInstance(pluginType);
+            }
+            catch (TargetInvocationException e) when (e.InnerException != null)
+            {
+                throw e.InnerException;
+            }
+        }
+
+        private static Type GetTypeFromAssemblyPath(string pluginAssemblyPath)
+        {
+            var assembly = LoadAssembly(pluginAssemblyPath);
+
+            var type = GetTypes<ProjectCachePluginBase>(assembly).FirstOrDefault();
+
+            ErrorUtilities.VerifyThrow(type != null, "NoProjectCachePluginFoundInAssembly", pluginAssemblyPath);
+
+            return type!;
+
+            Assembly LoadAssembly(string resolverPath)
+            {
+#if !FEATURE_ASSEMBLYLOADCONTEXT
+                return Assembly.LoadFrom(resolverPath);
+#else
+                return _loader.LoadFromPath(resolverPath);
+#endif
+            }
+
+            IEnumerable<Type> GetTypes<T>(Assembly assembly)
+            {
+                return assembly.ExportedTypes
+                    .Select(type => new {type, info = type.GetTypeInfo()})
+                    .Where(
+                        t => t.info.IsClass &&
+                             t.info.IsPublic &&
+                             !t.info.IsAbstract &&
+                             typeof(T).IsAssignableFrom(t.type))
+                    .Select(t => t.type);
+            }
+        }
+
+#if FEATURE_ASSEMBLYLOADCONTEXT
+        private static readonly CoreClrAssemblyLoader _loader = new CoreClrAssemblyLoader();
+#endif
+
+        public async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest)
+        {
+            // TODO: Parent these logs under the project build event so they appear nested under the project in the binlog viewer.
+            var queryDescription = $"{buildRequest.ProjectFullPath}" +
+                                   $"\n\tTargets:[{string.Join(", ", buildRequest.TargetNames)}]" +
+                                   $"\n\tGlobal Properties: {{{string.Join(",", buildRequest.GlobalProperties.Select(kvp => $"{kvp.Name}={kvp.EvaluatedValue}"))}}}";
+
+            _logger.LogMessage(
+                "\n====== Querying project cache for project " + queryDescription,
+                MessageImportance.High);
+
+            var cacheResult = await _projectCachePlugin.GetCacheResultAsync(buildRequest, _logger, _cancellationToken);
+
+            if (_logger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
+            {
+                throw new Exception(
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectCacheQueryFailed", queryDescription));
+            }
+
+            var message = $"Plugin result: {cacheResult.ResultType}.";
+
+            switch (cacheResult.ResultType)
+            {
+                case CacheResultType.CacheHit:
+                    message += " Skipping project.";
+                    break;
+                case CacheResultType.CacheMiss:
+                case CacheResultType.CacheNotApplicable:
+                    message += " Building project.";
+                    break;
+                case CacheResultType.None:
+                    break;
+                default:
+                    throw new ArgumentOutOfRangeException();
+            }
+
+            _logger.LogMessage(
+                message,
+                MessageImportance.High);
+
+            return cacheResult;
+        }
+
+        public async Task ShutDown()
+        {
+            await _projectCachePlugin.EndBuildAsync(_logger, _cancellationToken);
+
+            if (_logger.HasLoggedErrors)
+            {
+                throw new Exception(
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectCacheShutdownFailed"));
+            }
+        }
+
+        private class LoggingServiceToPluginLoggerAdapter : PluginLoggerBase
+        {
+            private readonly ILoggingService _loggingService;
+
+            public override bool HasLoggedErrors { get; protected set; }
+
+            public LoggingServiceToPluginLoggerAdapter(
+                LoggerVerbosity verbosity,
+                ILoggingService loggingService) : base(verbosity)
+            {
+                _loggingService = loggingService;
+            }
+
+            public override void LogMessage(string message, MessageImportance? messageImportance = null)
+            {
+                _loggingService.LogCommentFromText(
+                    BuildEventContext.Invalid,
+                    messageImportance ?? MessageImportance.Normal,
+                    message);
+            }
+
+            public override void LogWarning(string warning)
+            {
+                _loggingService.LogWarningFromText(
+                    BuildEventContext.Invalid,
+                    null,
+                    null,
+                    null,
+                    BuildEventFileInfo.Empty,
+                    warning);
+            }
+
+            public override void LogError(string error)
+            {
+                HasLoggedErrors = true;
+
+                _loggingService.LogErrorFromText(
+                    BuildEventContext.Invalid,
+                    null,
+                    null,
+                    null,
+                    BuildEventFileInfo.Empty,
+                    error);
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProxyTargets.cs b/src/Build/BackEnd/Components/ProjectCache/ProxyTargets.cs
new file mode 100644
index 00000000000..6b83993c148
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProxyTargets.cs
@@ -0,0 +1,55 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    ///     A cache hit can use this to instruct MSBuild to build the cheaper version of the targets that the plugin avoided
+    ///     running.
+    ///     For example, GetTargetPath is the cheaper version of Build.
+    ///
+    ///     MSBuild will build the proxy targets and assign their target results to the real targets the mapping points to.
+    ///     The proxy targets are left in the build result (i.e., both GetTargetPath and Build will appear in the build result).
+    ///     Real targets can be committed in which case msbuild only keeps the proxy target in the build result.
+    /// </summary>
+    public class ProxyTargets: ITranslatable
+    {
+        private Dictionary<string, string> _proxyTargetToRealTargetMap = null!;
+
+        /// <summary>
+        /// Mapping from proxy targets to real targets. Case insensitive.
+        /// </summary>
+        public IReadOnlyDictionary<string, string> ProxyTargetToRealTargetMap => _proxyTargetToRealTargetMap;
+
+        private ProxyTargets()
+        {
+        }
+
+        public ProxyTargets(IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap)
+        {
+            ErrorUtilities.VerifyThrowArgumentLength(proxyTargetToRealTargetMap, nameof(proxyTargetToRealTargetMap));
+
+            _proxyTargetToRealTargetMap = proxyTargetToRealTargetMap.ToDictionary(kvp => kvp.Key, kvp => kvp.Value, StringComparer.OrdinalIgnoreCase);
+        }
+
+        void ITranslatable.Translate(ITranslator translator)
+        {
+            translator.TranslateDictionary(ref _proxyTargetToRealTargetMap, StringComparer.OrdinalIgnoreCase);
+        }
+
+        internal static ProxyTargets FactoryForDeserialization(ITranslator translator)
+        {
+            var instance = new ProxyTargets();
+            ((ITranslatable) instance).Translate(translator);
+
+            return instance;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 00512fc9c9b..d5b83a1566c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -19,6 +19,7 @@
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.Experimental.ProjectCache;
 using NodeLoggingContext = Microsoft.Build.BackEnd.Logging.NodeLoggingContext;
 using ProjectLoggingContext = Microsoft.Build.BackEnd.Logging.ProjectLoggingContext;
 
@@ -1019,7 +1020,12 @@ private async Task<BuildResult> BuildProject()
                 // Load the project
                 if (!_requestEntry.RequestConfiguration.IsLoaded)
                 {
-                    LoadProjectIntoConfiguration();
+                    _requestEntry.RequestConfiguration.LoadProjectIntoConfiguration(
+                        _componentHost,
+                        RequestEntry.Request.BuildRequestDataFlags,
+                        RequestEntry.Request.SubmissionId,
+                        _nodeLoggingContext.BuildEventContext.NodeId
+                    );
                 }
             }
             catch
@@ -1078,77 +1084,45 @@ private async Task<BuildResult> BuildProject()
             // Build the targets
             BuildResult result = await _targetBuilder.BuildTargets(_projectLoggingContext, _requestEntry, this, allTargets, _requestEntry.RequestConfiguration.BaseLookup, _cancellationTokenSource.Token);
 
+            result = _requestEntry.Request.ProxyTargets == null
+                ? result
+                : CopyTargetResultsFromProxyTargetsToRealTargets(result);
+
             if (MSBuildEventSource.Log.IsEnabled())
             {
                 MSBuildEventSource.Log.BuildProjectStop(_requestEntry.RequestConfiguration.ProjectFullPath, string.Join(", ", allTargets));
             }
 
             return result;
-        }
-
-        /// <summary>
-        /// Loads the project specified by the configuration's parameters into the configuration block.
-        /// </summary>
-        private void LoadProjectIntoConfiguration()
-        {
-            ErrorUtilities.VerifyThrow(!_requestEntry.RequestConfiguration.IsLoaded, "Already loaded the project for this configuration id {0}.", _requestEntry.RequestConfiguration.ConfigurationId);
-
-            _requestEntry.RequestConfiguration.InitializeProject(_componentHost.BuildParameters, LoadProjectFromFile);
-        }
 
-        private ProjectInstance LoadProjectFromFile()
-        {
-            if (_componentHost.BuildParameters.SaveOperatingEnvironment)
+            BuildResult CopyTargetResultsFromProxyTargetsToRealTargets(BuildResult resultFromTargetBuilder)
             {
-                try
-                {
-                    NativeMethodsShared.SetCurrentDirectory(BuildParameters.StartupDirectory);
-                }
-                catch (DirectoryNotFoundException)
-                {
-                    // Somehow the startup directory vanished. This can happen if build was started from a USB Key and it was removed.
-                    NativeMethodsShared.SetCurrentDirectory(
-                        BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);
-                }
-            }
+                var proxyTargetMapping = _requestEntry.Request.ProxyTargets.ProxyTargetToRealTargetMap;
 
-            Dictionary<string, string> globalProperties = new Dictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
+                var resultsCache = (IResultsCache)_componentHost.GetComponent(BuildComponentType.ResultsCache);
+                var cachedResult = resultsCache.GetResultsForConfiguration(_requestEntry.Request.ConfigurationId);
 
-            foreach (ProjectPropertyInstance property in _requestEntry.RequestConfiguration.GlobalProperties)
-            {
-                globalProperties.Add(property.Name, ((IProperty)property).EvaluatedValueEscaped);
-            }
+                // Some proxy targets do not point to real targets. Exclude those.
+                foreach (var proxyMapping in proxyTargetMapping.Where(kvp => kvp.Value != null))
+                {
+                    var proxyTarget = proxyMapping.Key;
+                    var realTarget = proxyMapping.Value;
 
-            string toolsVersionOverride = _requestEntry.RequestConfiguration.ExplicitToolsVersionSpecified ? _requestEntry.RequestConfiguration.ToolsVersion : null;
+                    var proxyTargetResult = resultFromTargetBuilder.ResultsByTarget[proxyTarget];
 
-            // Get the hosted ISdkResolverService.  This returns either the MainNodeSdkResolverService or the OutOfProcNodeSdkResolverService depending on who created the current RequestBuilder
-            ISdkResolverService sdkResolverService = _componentHost.GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
+                    // Update the results cache.
+                    cachedResult.AddResultsForTarget(
+                        realTarget,
+                        proxyTargetResult);
 
-            // Use different project load settings if the build request indicates to do so
-            ProjectLoadSettings projectLoadSettings = _componentHost.BuildParameters.ProjectLoadSettings;
+                    // Update and return this one because TargetBuilder.BuildTargets did some mutations on it not present in the cached result.
+                    resultFromTargetBuilder.AddResultsForTarget(
+                        realTarget,
+                        proxyTargetResult);
+                }
 
-            if (_requestEntry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports))
-            {
-                projectLoadSettings |= ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.IgnoreInvalidImports | ProjectLoadSettings.IgnoreEmptyImports;
+                return resultFromTargetBuilder;
             }
-
-            return new ProjectInstance(
-                _requestEntry.RequestConfiguration.ProjectFullPath,
-                globalProperties,
-                toolsVersionOverride,
-                _componentHost.BuildParameters,
-                _nodeLoggingContext.LoggingService,
-                new BuildEventContext(
-                    _requestEntry.Request.SubmissionId,
-                    _nodeLoggingContext.BuildEventContext.NodeId,
-                    BuildEventContext.InvalidEvaluationId,
-                    BuildEventContext.InvalidProjectInstanceId,
-                    BuildEventContext.InvalidProjectContextId,
-                    BuildEventContext.InvalidTargetId,
-                    BuildEventContext.InvalidTaskId),
-                sdkResolverService,
-                _requestEntry.Request.SubmissionId,
-                projectLoadSettings);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index 3d72ed52c91..4a0a4efb7f1 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -3,9 +3,11 @@
 
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Linq;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -55,11 +57,12 @@ internal class BuildRequest : INodePacket
         /// </summary>
         private int _nodeRequestId;
 
-        /// <summary>
-        /// The targets specified when the request was made.  Doesn't include default or initial targets.
-        /// </summary>
+        /// <inheritdoc cref="BuildRequest.Targets"/>
         private List<string> _targets;
 
+        /// <inheritdoc cref="BuildRequest.ProxyTargets"/>
+        private ProxyTargets _proxyTargets;
+
         /// <summary>
         /// The build event context of the parent
         /// </summary>
@@ -87,6 +90,56 @@ internal class BuildRequest : INodePacket
         /// </summary>
         public BuildRequest()
         {
+
+        }
+
+        private BuildRequest(
+            int submissionId,
+            int nodeRequestId,
+            int configurationId,
+            HostServices hostServices,
+            BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
+            RequestedProjectState requestedProjectState = null)
+        {
+            _submissionId = submissionId;
+            _configurationId = configurationId;
+
+            HostServices = hostServices;
+            _buildEventContext = BuildEventContext.Invalid;
+            _globalRequestId = InvalidGlobalRequestId;
+
+            _nodeRequestId = nodeRequestId;
+            _buildRequestDataFlags = buildRequestDataFlags;
+            _requestedProjectState = requestedProjectState;
+        }
+
+        /// <summary>
+        /// Initializes a build request with a parent context.
+        /// </summary>
+        /// <param name="submissionId">The id of the build submission.</param>
+        /// <param name="nodeRequestId">The id of the node issuing the request</param>
+        /// <param name="configurationId">The configuration id to use.</param>
+        /// <param name="proxyTargets"><see cref="ProxyTargets"/></param>
+        /// <param name="hostServices">Host services if any. May be null.</param>
+        /// <param name="buildRequestDataFlags">Additional flags for the request.</param>
+        /// <param name="requestedProjectState">Filter for desired build results.</param>
+        public BuildRequest(
+            int submissionId,
+            int nodeRequestId,
+            int configurationId,
+            ProxyTargets proxyTargets,
+            HostServices hostServices,
+            BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
+            RequestedProjectState requestedProjectState = null)
+            : this(submissionId, nodeRequestId, configurationId, hostServices, buildRequestDataFlags,
+                requestedProjectState)
+        {
+            _proxyTargets = proxyTargets;
+            _targets = proxyTargets.ProxyTargetToRealTargetMap.Keys.ToList();
+
+            // Only root requests can have proxy targets.
+            _parentGlobalRequestId = InvalidGlobalRequestId;
+            _parentBuildEventContext = BuildEventContext.Invalid;
         }
 
         /// <summary>
@@ -113,13 +166,11 @@ public BuildRequest(
             BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
             RequestedProjectState requestedProjectState = null,
             bool skipStaticGraphIsolationConstraints = false)
+        : this(submissionId, nodeRequestId, configurationId, hostServices, buildRequestDataFlags, requestedProjectState)
         {
             ErrorUtilities.VerifyThrowArgumentNull(escapedTargets, "targets");
             ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, nameof(parentBuildEventContext));
 
-            _submissionId = submissionId;
-            _configurationId = configurationId;
-
             // When targets come into a build request, we unescape them.
             _targets = new List<string>(escapedTargets.Count);
             foreach (string target in escapedTargets)
@@ -127,16 +178,9 @@ public BuildRequest(
                 _targets.Add(EscapingUtilities.UnescapeAll(target));
             }
 
-            HostServices = hostServices;
-            _buildEventContext = BuildEventContext.Invalid;
             _parentBuildEventContext = parentBuildEventContext;
-            _globalRequestId = InvalidGlobalRequestId;
             _parentGlobalRequestId = parentRequest?.GlobalRequestId ?? InvalidGlobalRequestId;
 
-            _nodeRequestId = nodeRequestId;
-            _buildRequestDataFlags = buildRequestDataFlags;
-            _requestedProjectState = requestedProjectState;
-
             _skipStaticGraphIsolationConstraints = skipStaticGraphIsolationConstraints;
         }
 
@@ -221,7 +265,8 @@ public int NodeRequestId
         }
 
         /// <summary>
-        /// Returns the set of unescaped targets to be built
+        /// The targets specified when the request was made.  Doesn't include default or initial targets.
+        /// Either this is null or <see cref="ProxyTargets"/> is null;
         /// </summary>
         public List<string> Targets
         {
@@ -230,6 +275,16 @@ public List<string> Targets
             { return _targets; }
         }
 
+        /// <summary>
+        /// See <see cref="ProxyTargets"/>. Either this is null, or <see cref="_targets"/> is null;
+        /// </summary>
+        public ProxyTargets ProxyTargets
+        {
+            [DebuggerStepThrough]
+            get
+            { return _proxyTargets; }
+        }
+
         /// <summary>
         /// Returns the type of packet.
         /// </summary>
@@ -350,6 +405,7 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _skipStaticGraphIsolationConstraints);
             translator.Translate(ref _requestedProjectState);
             translator.Translate(ref _hostServices);
+            translator.Translate(ref _proxyTargets, ProxyTargets.FactoryForDeserialization);
 
             // UNDONE: (Compat) Serialize the host object.
         }
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index feb27293007..97f9531e074 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -10,7 +10,9 @@
 using System.Diagnostics;
 using System.IO;
 using System.Linq;
+using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Globbing;
 using Microsoft.Build.Shared.FileSystem;
 
@@ -417,7 +419,74 @@ private void SetProjectBasedState(ProjectInstance project)
             }
         }
 
-        public void InitializeProject(BuildParameters buildParameters, Func<ProjectInstance> loadProjectFromFile)
+        /// <summary>
+        /// Loads the project specified by the configuration's parameters into the configuration block.
+        /// </summary>
+        internal void LoadProjectIntoConfiguration(
+            IBuildComponentHost componentHost,
+            BuildRequestDataFlags buildRequestDataFlags,
+            int submissionId,
+            int nodeId)
+        {
+            ErrorUtilities.VerifyThrow(!IsLoaded, "Already loaded the project for this configuration id {0}.", ConfigurationId);
+
+            InitializeProject(componentHost.BuildParameters, () =>
+            {
+                if (componentHost.BuildParameters.SaveOperatingEnvironment)
+                {
+                    try
+                    {
+                        NativeMethodsShared.SetCurrentDirectory(BuildParameters.StartupDirectory);
+                    }
+                    catch (DirectoryNotFoundException)
+                    {
+                        // Somehow the startup directory vanished. This can happen if build was started from a USB Key and it was removed.
+                        NativeMethodsShared.SetCurrentDirectory(
+                            BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);
+                    }
+                }
+
+                Dictionary<string, string> globalProperties = new Dictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
+
+                foreach (ProjectPropertyInstance property in GlobalProperties)
+                {
+                    globalProperties.Add(property.Name, ((IProperty)property).EvaluatedValueEscaped);
+                }
+
+                string toolsVersionOverride = ExplicitToolsVersionSpecified ? ToolsVersion : null;
+
+                // Get the hosted ISdkResolverService.  This returns either the MainNodeSdkResolverService or the OutOfProcNodeSdkResolverService depending on who created the current RequestBuilder
+                ISdkResolverService sdkResolverService = componentHost.GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
+
+                // Use different project load settings if the build request indicates to do so
+                ProjectLoadSettings projectLoadSettings = componentHost.BuildParameters.ProjectLoadSettings;
+
+                if (buildRequestDataFlags.HasFlag(BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports))
+                {
+                    projectLoadSettings |= ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.IgnoreInvalidImports | ProjectLoadSettings.IgnoreEmptyImports;
+                }
+
+                return new ProjectInstance(
+                    ProjectFullPath,
+                    globalProperties,
+                    toolsVersionOverride,
+                    componentHost.BuildParameters,
+                    componentHost.LoggingService,
+                    new BuildEventContext(
+                        submissionId,
+                        nodeId,
+                        BuildEventContext.InvalidEvaluationId,
+                        BuildEventContext.InvalidProjectInstanceId,
+                        BuildEventContext.InvalidProjectContextId,
+                        BuildEventContext.InvalidTargetId,
+                        BuildEventContext.InvalidTaskId),
+                    sdkResolverService,
+                    submissionId,
+                    projectLoadSettings);
+            });
+        }
+
+        private void InitializeProject(BuildParameters buildParameters, Func<ProjectInstance> loadProjectFromFile)
         {
             if (_project == null || // building from file. Load project from file
                 _transferredProperties != null // need to overwrite particular properties, so load project from file and overwrite properties
@@ -664,6 +733,13 @@ public List<string> GetTargetsUsedToBuildRequest(BuildRequest request)
             ErrorUtilities.VerifyThrow(_projectInitialTargets != null, "Initial targets have not been set.");
             ErrorUtilities.VerifyThrow(_projectDefaultTargets != null, "Default targets have not been set.");
 
+            if (request.ProxyTargets != null)
+            {
+                ErrorUtilities.VerifyThrow(
+                    CollectionHelpers.SetEquivalent(request.Targets, request.ProxyTargets.ProxyTargetToRealTargetMap.Keys),
+                    "Targets must be same as proxy targets");
+            }
+
             List<string> initialTargets = _projectInitialTargets;
             List<string> nonInitialTargets = (request.Targets.Count == 0) ? _projectDefaultTargets : request.Targets;
 
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index b5bf9d3706d..ec989c4e92d 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -464,6 +464,12 @@ public void AddResultsForTarget(string target, TargetResult result)
         {
             ErrorUtilities.VerifyThrowArgumentNull(target, nameof(target));
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
+
+            lock (this)
+            {
+                _resultsByTarget ??= CreateTargetResultDictionary(1);
+            }
+
             if (_resultsByTarget.ContainsKey(target))
             {
                 ErrorUtilities.VerifyThrow(_resultsByTarget[target].ResultCode == TargetResultCode.Skipped, "Items already exist for target {0}.", target);
diff --git a/src/Build/Construction/ProjectItemElement.cs b/src/Build/Construction/ProjectItemElement.cs
index 8e6bbd2ffa8..dd7f7f6ea6c 100644
--- a/src/Build/Construction/ProjectItemElement.cs
+++ b/src/Build/Construction/ProjectItemElement.cs
@@ -171,7 +171,7 @@ public string Update
         }
 
         /// <summary>
-        /// Gets of sets the MatchOnMetadata value.
+        /// Gets or sets the MatchOnMetadata value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty or null.
         /// </summary>
@@ -194,7 +194,7 @@ public string MatchOnMetadata
         }
 
         /// <summary>
-        /// Gets of sets the MatchOnMetadataOptions value.
+        /// Gets or sets the MatchOnMetadataOptions value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty or null.
         /// </summary>
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 8d48735d241..67a17a6066a 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -42,9 +42,7 @@ namespace Microsoft.Build.Evaluation
     /// Always backed by XML; can be built directly, or an instance can be cloned off to add virtual items/properties and build.
     /// Edits to this project always update the backing XML.
     /// </summary>
-    /// <remarks>
-    /// UNDONE: (Multiple configurations.) Protect against problems when attempting to edit, after edits were made to the same ProjectRootElement either directly or through other projects evaluated from that ProjectRootElement.
-    /// </remarks>
+    // UNDONE: (Multiple configurations.) Protect against problems when attempting to edit, after edits were made to the same ProjectRootElement either directly or through other projects evaluated from that ProjectRootElement.
     [DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={_data.GlobalPropertiesDictionary.Count} #Properties={_data.Properties.Count} #ItemTypes={_data.ItemTypes.Count} #ItemDefinitions={_data.ItemDefinitions.Count} #Items={_data.Items.Count} #Targets={_data.Targets.Count}")]
     public class Project : ILinkableObject
     {
@@ -1331,7 +1329,7 @@ public ProjectInstance CreateProjectInstance()
         /// access concurrently from multiple threads.
         /// </summary>
         /// <param name="settings">The project instance creation settings.</param>
-        /// <returns>the created project instance.</returns>
+        /// <returns>The created project instance.</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         {
             return CreateProjectInstance(settings, null);
@@ -1342,7 +1340,7 @@ public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         /// </summary>
         /// <param name="settings">The project instance creation settings.</param>
         /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
-        /// <returns>the created project instance.</returns>
+        /// <returns>The created project instance.</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
         {
             return implementation.CreateProjectInstance(settings, evaluationContext);
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 5ef5fdfe6e8..ec52f815e3d 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -582,9 +582,9 @@ public int Count
         /// <summary>
         /// Loggers that all contained projects will use for their builds.
         /// Loggers are added with the <see cref="RegisterLogger"/>.
-        /// UNDONE: Currently they cannot be removed.
         /// Returns an empty collection if there are no loggers.
         /// </summary>
+        // UNDONE: Currently loggers cannot be removed.
         public ICollection<ILogger> Loggers
         {
             [DebuggerStepThrough]
@@ -1465,10 +1465,10 @@ public bool RemoveGlobalProperty(string name)
 
         /// <summary>
         /// Called when a host is completely done with the project collection.
-        /// UNDONE: This is a hack to make sure the logging thread shuts down if the build used the logging service
-        /// off the ProjectCollection. After CTP we need to rationalize this and see if we can remove the logging service from
-        /// the project collection entirely so this isn't necessary.
         /// </summary>
+        // UNDONE: This is a hack to make sure the logging thread shuts down if the build used the logging service
+        // off the ProjectCollection. After CTP we need to rationalize this and see if we can remove the logging service from
+        // the project collection entirely so this isn't necessary.
         public void Dispose()
         {
             Dispose(true);
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 220cd07daba..0b3c28e1562 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -25,7 +25,7 @@ namespace Microsoft.Build.Evaluation
     /// we do use it for build-time items.
     /// </comment>
     [DebuggerDisplay("{ItemType}={EvaluatedInclude} [{UnevaluatedInclude}] #DirectMetadata={DirectMetadataCount}")]
-    public class ProjectItem : IKeyed, IItem<ProjectMetadata>, IMetadataTable, IProjectMetadataParent
+    public class ProjectItem : IItem<ProjectMetadata>, IProjectMetadataParent
     {
         /// <summary>
         /// Project that this item lives in.
@@ -280,6 +280,8 @@ public ICollection<ProjectMetadata> Metadata
             { return Link != null ? Link.MetadataCollection : MetadataCollection; }
         }
 
+        IEnumerable<ProjectMetadata> IItem<ProjectMetadata>.Metadata => Metadata;
+
         /// <summary>
         /// Count of metadata on this item, if any.
         /// Includes any metadata inherited from item definitions.
diff --git a/src/Build/Definition/ProjectMetadata.cs b/src/Build/Definition/ProjectMetadata.cs
index 7bf9f740605..2e5f4c958ae 100644
--- a/src/Build/Definition/ProjectMetadata.cs
+++ b/src/Build/Definition/ProjectMetadata.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.Evaluation
     /// Never used to represent built-in metadata, like %(Filename). There is always a backing XML object.
     /// </remarks>
     [DebuggerDisplay("{Name}={EvaluatedValue} [{_xml.Value}]")]
-    public class ProjectMetadata : IKeyed, IValued, IEquatable<ProjectMetadata>, IMetadatum
+    public class ProjectMetadata : IEquatable<ProjectMetadata>, IMetadatum
     {
         /// <summary>
         /// Parent item or item definition that this metadatum lives in.
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index fc08972debb..a4e4d21565b 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -35,9 +35,7 @@ namespace Microsoft.Build.Evaluation
     /// Aggregation of a toolset version (eg. "2.0"), tools path, and optional set of associated properties.
     /// Toolset is immutable.
     /// </summary>
-    /// <remarks>
-    /// UNDONE: Review immutability. If this is not immutable, add a mechanism to notify the project collection/s owning it to increment their toolsetVersion.
-    /// </remarks>
+    // UNDONE: Review immutability. If this is not immutable, add a mechanism to notify the project collection/s owning it to increment their toolsetVersion.
     [DebuggerDisplay("ToolsVersion={ToolsVersion} ToolsPath={ToolsPath} #Properties={_properties.Count}")]
     public class Toolset : ITranslatable
     {
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index d1872605c82..7a1e0aa25ad 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -16,11 +16,9 @@ namespace Microsoft.Build.Exceptions
     /// This exception is used to wrap an unhandled exception from a logger. This exception aborts the build, and it can only be
     /// thrown by the MSBuild engine.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
     public sealed class InternalLoggerException : Exception
     {
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index ce0835ec396..6588acce0b8 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -15,11 +15,9 @@ namespace Microsoft.Build.Exceptions
     /// This exception is thrown whenever there is a problem with the user's XML project file. The problem might be semantic or
     /// syntactical. The latter would be of a type typically caught by XSD validation (if it was performed by the project writer).
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
     public sealed class InvalidProjectFileException : Exception
     {
diff --git a/src/Build/Evaluation/Conditionals/IItem.cs b/src/Build/Evaluation/Conditionals/IItem.cs
index c59074f73f1..000aacf9c0a 100644
--- a/src/Build/Evaluation/Conditionals/IItem.cs
+++ b/src/Build/Evaluation/Conditionals/IItem.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
 using Microsoft.Build.Construction;
 
 namespace Microsoft.Build.Evaluation
@@ -25,5 +26,7 @@ internal interface IItem<M> : IItem
         /// Predecessor is any preceding overridden metadata
         /// </summary>
         M SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue);
+
+        IEnumerable<M> Metadata { get; }
     }
 }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 6111e2e60a4..5df077fe418 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using ObjectModel = System.Collections.ObjectModel;
 using System.Diagnostics;
@@ -17,6 +18,7 @@
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Internal;
@@ -737,6 +739,12 @@ private void Evaluate()
                     _data.BeforeTargets = targetsWhichRunBeforeByTarget;
                     _data.AfterTargets = targetsWhichRunAfterByTarget;
 
+                    if (BuildEnvironmentHelper.Instance.RunningInVisualStudio)
+                    {
+                        // TODO: Remove this when VS gets updated to setup project cache plugins.
+                        CollectProjectCachePlugins();
+                    }
+
                     if (Traits.Instance.EscapeHatches.DebugEvaluation)
                     {
                         // This is so important for VS performance it's worth always tracing; accidentally having 
@@ -777,6 +785,20 @@ private void Evaluate()
             });
         }
 
+        private void CollectProjectCachePlugins()
+        {
+            foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))
+            {
+                var metadataDictionary = item.Metadata.ToDictionary(m => m.Key, m => m.EscapedValue);
+
+                var pluginPath = Path.Combine(_data.Directory, item.EvaluatedInclude);
+
+                var projectCacheItem = new ProjectCacheItem(pluginPath, metadataDictionary);
+
+                BuildManager.ProjectCacheItems[pluginPath] = projectCacheItem;
+            }
+        }
+
         /// <summary>
         /// Evaluate the properties in the passed in XML, into the project.
         /// Does a depth first traversal into Imports.
diff --git a/src/Build/Evaluation/IMetadatum.cs b/src/Build/Evaluation/IMetadatum.cs
index aa828e835ad..5521a562ea6 100644
--- a/src/Build/Evaluation/IMetadatum.cs
+++ b/src/Build/Evaluation/IMetadatum.cs
@@ -1,12 +1,14 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Collections;
+
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
     /// This interface represents a metadata object.
     /// </summary>
-    internal interface IMetadatum
+    internal interface IMetadatum : IKeyed, IValued
     {
     }
 }
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index ba38ae601d5..2756ccb9c37 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -414,7 +414,7 @@ internal abstract class ItemSpecFragment
         /// <summary>
         ///     Path of the project the itemspec is coming from
         /// </summary>
-        protected string ProjectDirectory { get; }
+        internal string ProjectDirectory { get; }
 
         // not a Lazy to reduce memory
         private ref FileSpecMatcherTester FileMatcher
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 146e15c4df2..9934759efbf 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -30,7 +30,8 @@ private abstract class LazyItemOperation : IItemOperation
             //  This is used only when evaluating an expression, which instantiates
             //  the items and then removes them
             protected readonly IItemFactory<I, I> _itemFactory;
-
+            internal ItemSpec<P, I> Spec => _itemSpec;
+            
             protected LazyItemOperation(OperationBuilder builder, LazyItemEvaluator<P, I, M, D> lazyEvaluator)
             {
                 _itemElement = builder.ItemElement;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index b1e13d2ed83..5423bcf0286 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -15,6 +15,9 @@ internal partial class LazyItemEvaluator<P, I, M, D>
         class UpdateOperation : LazyItemOperation
         {
             private readonly ImmutableList<ProjectMetadataElement> _metadata;
+            private ImmutableList<ItemBatchingContext>.Builder _itemsToUpdate = null;
+            private ItemSpecMatchesItem _matchItemSpec = null;
+            private bool? _needToExpandMetadataForEachItem = null;
 
             public UpdateOperation(OperationBuilderWithMetadata builder, LazyItemEvaluator<P, I, M, D> lazyEvaluator)
                 : base(builder, lazyEvaluator)
@@ -43,23 +46,77 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I
                     return;
                 }
 
-                ItemSpecMatchesItem matchItemspec;
-                bool? needToExpandMetadataForEachItem = null;
+                SetMatchItemSpec();
+                _itemsToUpdate ??= ImmutableList.CreateBuilder<ItemBatchingContext>();
+                _itemsToUpdate.Clear();
 
+                for (int i = 0; i < listBuilder.Count; i++)
+                {
+                    var itemData = listBuilder[i];
+
+                    var matchResult = _matchItemSpec(_itemSpec, itemData.Item);
+
+                    if (matchResult.IsMatch)
+                    {
+                        listBuilder[i] = UpdateItem(listBuilder[i], matchResult.CapturedItemsFromReferencedItemTypes);
+                    }
+                }
+
+                DecorateItemsWithMetadata(_itemsToUpdate.ToImmutableList(), _metadata, _needToExpandMetadataForEachItem);
+            }
+
+            /// <summary>
+            /// Apply the Update operation to the item if it matches.
+            /// </summary>
+            /// <param name="item">The item to check for a match.</param>
+            /// <returns>The updated item.</returns>
+            internal ItemData UpdateItem(ItemData item)
+            {
+                if (_conditionResult)
+                {
+                    SetMatchItemSpec();
+                    _itemsToUpdate ??= ImmutableList.CreateBuilder<ItemBatchingContext>();
+                    _itemsToUpdate.Clear();
+                    MatchResult matchResult = _matchItemSpec(_itemSpec, item.Item);
+                    if (matchResult.IsMatch)
+                    {
+                        ItemData clonedData = UpdateItem(item, matchResult.CapturedItemsFromReferencedItemTypes);
+                        DecorateItemsWithMetadata(_itemsToUpdate.ToImmutableList(), _metadata, _needToExpandMetadataForEachItem);
+                        return clonedData;
+                    }
+                }
+                return item;
+            }
+
+            private ItemData UpdateItem(ItemData item, Dictionary<string, I> capturedItemsFromReferencedItemTypes)
+            {
+                // items should be deep immutable, so clone and replace items before mutating them
+                // otherwise, with GetItems caching enabled, the mutations would leak into the cache causing
+                // future operations to mutate the state of past operations
+                ItemData clonedData = item.Clone(_itemFactory, _itemElement);
+                _itemsToUpdate.Add(new ItemBatchingContext(clonedData.Item, capturedItemsFromReferencedItemTypes));
+                return clonedData;
+            }
+
+            /// <summary>
+            /// This sets the function used to determine whether an item matches an item spec.
+            /// </summary>
+            private void SetMatchItemSpec()
+            {
                 if (ItemspecContainsASingleBareItemReference(_itemSpec, _itemElement.ItemType))
                 {
                     // Perf optimization: If the Update operation references itself (e.g. <I Update="@(I)"/>)
                     // then all items are updated and matching is not necessary
-                    matchItemspec = (itemSpec, item) => new MatchResult(true, null);
+                    _matchItemSpec = (itemSpec, item) => new MatchResult(true, null);
                 }
                 else if (ItemSpecContainsItemReferences(_itemSpec)
-                         && QualifiedMetadataReferencesExist(_metadata, out needToExpandMetadataForEachItem)
+                         && QualifiedMetadataReferencesExist(_metadata, out _needToExpandMetadataForEachItem)
                          && !Traits.Instance.EscapeHatches.DoNotExpandQualifiedMetadataInUpdateOperation)
                 {
-                    var itemReferenceFragments = _itemSpec.Fragments.OfType<ItemSpec<P,I>.ItemExpressionFragment>().ToArray();
-                    var nonItemReferenceFragments = _itemSpec.Fragments.Where(f => !(f is ItemSpec<P,I>.ItemExpressionFragment)).ToArray();
+                    var itemReferenceFragments = _itemSpec.Fragments.OfType<ItemSpec<P, I>.ItemExpressionFragment>().ToArray();
+                    var nonItemReferenceFragments = _itemSpec.Fragments.Where(f => !(f is ItemSpec<P, I>.ItemExpressionFragment)).ToArray();
 
-                    matchItemspec = (itemSpec, item) =>
+                    _matchItemSpec = (itemSpec, item) =>
                     {
                         var isMatch = nonItemReferenceFragments.Any(f => f.IsMatch(item.EvaluatedInclude));
                         Dictionary<string, I> capturedItemsFromReferencedItemTypes = null;
@@ -84,30 +141,8 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I
                 }
                 else
                 {
-                    matchItemspec = (itemSpec, item) => new MatchResult(itemSpec.MatchesItem(item), null);
-                }
-
-                var itemsToUpdate = ImmutableList.CreateBuilder<ItemBatchingContext>();
-
-                for (int i = 0; i < listBuilder.Count; i++)
-                {
-                    var itemData = listBuilder[i];
-
-                    var matchResult = matchItemspec(_itemSpec, itemData.Item);
-
-                    if (matchResult.IsMatch)
-                    {
-                        // items should be deep immutable, so clone and replace items before mutating them
-                        // otherwise, with GetItems caching enabled, the mutations would leak into the cache causing
-                        // future operations to mutate the state of past operations
-                        var clonedItemData = listBuilder[i].Clone(_itemFactory, _itemElement);
-                        listBuilder[i] = clonedItemData;
-
-                        itemsToUpdate.Add(new ItemBatchingContext(clonedItemData.Item, matchResult.CapturedItemsFromReferencedItemTypes));
-                    }
+                    _matchItemSpec = (itemSpec, item) => new MatchResult(itemSpec.MatchesItem(item), null);
                 }
-
-                DecorateItemsWithMetadata(itemsToUpdate.ToImmutableList(), _metadata, needToExpandMetadataForEachItem);
             }
 
             private bool QualifiedMetadataReferencesExist(ImmutableList<ProjectMetadataElement> metadata, out bool? needToExpandMetadataForEachItem)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 64df2a7402f..e5f2a72f61a 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -151,7 +151,7 @@ public ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initial
 
         private class MemoizedOperation : IItemOperation
         {
-            public IItemOperation Operation { get; }
+            public LazyItemOperation Operation { get; }
             private Dictionary<ISet<string>, ImmutableList<ItemData>> _cache;
 
             private bool _isReferenced;
@@ -159,7 +159,7 @@ private class MemoizedOperation : IItemOperation
             private int _applyCalls;
 #endif
 
-            public MemoizedOperation(IItemOperation operation)
+            public MemoizedOperation(LazyItemOperation operation)
             {
                 Operation = operation;
             }
@@ -291,6 +291,14 @@ public ImmutableList<ItemData>.Builder GetItemData(ImmutableHashSet<string> glob
                 }
             }
 
+            /// <summary>
+            /// Applies uncached item operations (include, remove, update) in order. Since Remove effectively overwrites Include or Update,
+            /// Remove operations are preprocessed (adding to globsToIgnore) to create a longer list of globs we don't need to process
+            /// properly because we know they will be removed. Update operations are batched as much as possible, meaning rather
+            /// than being applied immediately, they are combined into a dictionary of UpdateOperations that need to be applied. This
+            /// is to optimize the case in which as series of UpdateOperations, each of which affects a single ItemSpec, are applied to all
+            /// items in the list, leading to a quadratic-time operation.
+            /// </summary>
             private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyItemList, ImmutableHashSet<string> globsToIgnore)
             {
                 // Stack of operations up to the first one that's cached (exclusive)
@@ -315,13 +323,9 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte
 
                     //  If this is a remove operation, then add any globs that will be removed
                     //  to a list of globs to ignore in previous operations
-                    var removeOperation = currentList._memoizedOperation.Operation as RemoveOperation;
-                    if (removeOperation != null)
+                    if (currentList._memoizedOperation.Operation is RemoveOperation removeOperation)
                     {
-                        if (globsToIgnoreStack == null)
-                        {
-                            globsToIgnoreStack = new Stack<ImmutableHashSet<string>>();
-                        }
+                        globsToIgnoreStack ??= new Stack<ImmutableHashSet<string>>();
 
                         var globsToIgnoreForPreviousOperations = removeOperation.GetRemovedGlobs();
                         foreach (var globToRemove in globsToIgnoreFromFutureOperations)
@@ -342,15 +346,65 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte
 
                 ImmutableHashSet<string> currentGlobsToIgnore = globsToIgnoreStack == null ? globsToIgnore : globsToIgnoreStack.Peek();
 
+                Dictionary<string, UpdateOperation> itemsWithNoWildcards = new Dictionary<string, UpdateOperation>(StringComparer.OrdinalIgnoreCase);
+                bool addedToBatch = false;
+
                 //  Walk back down the stack of item lists applying operations
                 while (itemListStack.Count > 0)
                 {
                     var currentList = itemListStack.Pop();
 
+                    if (currentList._memoizedOperation.Operation is UpdateOperation op)
+                    {
+                        bool addToBatch = true;
+                        int i;
+                        // The TextFragments are things like abc.def or x*y.*z.
+                        for (i = 0; i < op.Spec.Fragments.Count; i++)
+                        {
+                            ItemSpecFragment frag = op.Spec.Fragments[i];
+                            if (MSBuildConstants.CharactersForExpansion.Any(frag.TextFragment.Contains))
+                            {
+                                // Fragment contains wild cards, items, or properties. Cannot batch over it using a dictionary.
+                                addToBatch = false;
+                                break;
+                            }
+
+                            string fullPath = FileUtilities.GetFullPath(frag.TextFragment, frag.ProjectDirectory);
+                            if (itemsWithNoWildcards.ContainsKey(fullPath))
+                            {
+                                // Another update will already happen on this path. Make that happen before evaluating this one.
+                                addToBatch = false;
+                                break;
+                            }
+                            else
+                            {
+                                itemsWithNoWildcards.Add(fullPath, op);
+                            }
+                        }
+                        if (!addToBatch)
+                        {
+                            // We found a wildcard. Remove any fragments associated with the current operation and process them later.
+                            for (int j = 0; j < i; j++)
+                            {
+                                itemsWithNoWildcards.Remove(currentList._memoizedOperation.Operation.Spec.Fragments[j].TextFragment);
+                            }
+                        }
+                        else
+                        {
+                            addedToBatch = true;
+                            continue;
+                        }
+                    }
+
+                    if (addedToBatch)
+                    {
+                        addedToBatch = false;
+                        ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);
+                    }
+
                     //  If this is a remove operation, then it could modify the globs to ignore, so pop the potentially
                     //  modified entry off the stack of globs to ignore
-                    var removeOperation = currentList._memoizedOperation.Operation as RemoveOperation;
-                    if (removeOperation != null)
+                    if (currentList._memoizedOperation.Operation is RemoveOperation)
                     {
                         globsToIgnoreStack.Pop();
                         currentGlobsToIgnore = globsToIgnoreStack.Count == 0 ? globsToIgnore : globsToIgnoreStack.Peek();
@@ -359,9 +413,30 @@ private static ImmutableList<ItemData>.Builder ComputeItems(LazyItemList lazyIte
                     currentList._memoizedOperation.Apply(items, currentGlobsToIgnore);
                 }
 
+                // We finished looping through the operations. Now process the final batch if necessary.
+                ProcessNonWildCardItemUpdates(itemsWithNoWildcards, items);
+
                 return items;
             }
 
+            private static void ProcessNonWildCardItemUpdates(Dictionary<string, UpdateOperation> itemsWithNoWildcards, ImmutableList<ItemData>.Builder items)
+            {
+#if DEBUG
+                ErrorUtilities.VerifyThrow(itemsWithNoWildcards.All(fragment => !MSBuildConstants.CharactersForExpansion.Any(fragment.Key.Contains)), $"{nameof(itemsWithNoWildcards)} should not contain any text fragments with wildcards.");
+#endif
+                if (itemsWithNoWildcards.Count > 0)
+                {
+                    for (int i = 0; i < items.Count; i++)
+                    {
+                        if (itemsWithNoWildcards.TryGetValue(FileUtilities.GetFullPath(items[i].Item.EvaluatedInclude, items[i].Item.ProjectDirectory), out UpdateOperation op))
+                        {
+                            items[i] = op.UpdateItem(items[i]);
+                        }
+                    }
+                    itemsWithNoWildcards.Clear();
+                }
+            }
+
             public void MarkAsReferenced()
             {
                 _memoizedOperation.MarkAsReferenced();
diff --git a/src/Build/FileSystem/IFileSystemAdapter.cs b/src/Build/FileSystem/IFileSystemAdapter.cs
new file mode 100644
index 00000000000..dce1574702c
--- /dev/null
+++ b/src/Build/FileSystem/IFileSystemAdapter.cs
@@ -0,0 +1,97 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared.FileSystem;
+
+namespace Microsoft.Build.FileSystem
+{
+    internal class IFileSystemAdapter : MSBuildFileSystemBase
+    {
+        private readonly IFileSystem _wrappedFileSystem;
+
+        public IFileSystemAdapter(IFileSystem wrappedFileSystem)
+        {
+            _wrappedFileSystem = wrappedFileSystem;
+        }
+
+        public override TextReader ReadFile(string path)
+        {
+            return _wrappedFileSystem.ReadFile(path);
+        }
+
+        public override Stream GetFileStream(
+            string path,
+            FileMode mode,
+            FileAccess access,
+            FileShare share)
+        {
+            return _wrappedFileSystem.GetFileStream(
+                path,
+                mode,
+                access,
+                share);
+        }
+
+        public override string ReadFileAllText(string path)
+        {
+            return _wrappedFileSystem.ReadFileAllText(path);
+        }
+
+        public override byte[] ReadFileAllBytes(string path)
+        {
+            return _wrappedFileSystem.ReadFileAllBytes(path);
+        }
+
+        public override IEnumerable<string> EnumerateFiles(
+            string path,
+            string searchPattern = "*",
+            SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            return _wrappedFileSystem.EnumerateFiles(path, searchPattern, searchOption);
+        }
+
+        public override IEnumerable<string> EnumerateDirectories(
+            string path,
+            string searchPattern = "*",
+            SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            return _wrappedFileSystem.EnumerateDirectories(path, searchPattern, searchOption);
+        }
+
+        public override IEnumerable<string> EnumerateFileSystemEntries(
+            string path,
+            string searchPattern = "*",
+            SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            return _wrappedFileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+        }
+
+        public override FileAttributes GetAttributes(string path)
+        {
+            return _wrappedFileSystem.GetAttributes(path);
+        }
+
+        public override DateTime GetLastWriteTimeUtc(string path)
+        {
+            return _wrappedFileSystem.GetLastWriteTimeUtc(path);
+        }
+
+        public override bool DirectoryExists(string path)
+        {
+            return _wrappedFileSystem.DirectoryExists(path);
+        }
+
+        public override bool FileExists(string path)
+        {
+            return _wrappedFileSystem.FileExists(path);
+        }
+
+        public override bool FileOrDirectoryExists(string path)
+        {
+            return _wrappedFileSystem.DirectoryEntryExists(path);
+        }
+    }
+}
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 2f372f2bf35..bd160b2f66c 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -61,7 +61,7 @@ public enum ProjectInstanceSettings
     /// and call it several times to build it.
     /// </summary>
     /// <comments>
-    /// Neither this class nor none of its constituents are allowed to have
+    /// Neither this class nor any of its constituents are allowed to have
     /// references to any of the Construction or Evaluation objects.
     /// This class is immutable except for adding instance items and setting instance properties.
     /// It only exposes items and properties: targets, host services, and the task registry are not exposed as they are only the concern of build.
@@ -2103,7 +2103,17 @@ private void TranslateItems(ITranslator translator)
         /// <summary>
         /// Creates a set of project instances which represent the project dependency graph for a solution build.
         /// </summary>
-        internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, PropertyDictionary<ProjectPropertyInstance> globalPropertiesInstances, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext projectBuildEventContext, bool isExplicitlyLoaded, IReadOnlyCollection<string> targetNames, ISdkResolverService sdkResolverService, int submissionId)
+        internal static ProjectInstance[] LoadSolutionForBuild(
+            string projectFile,
+            PropertyDictionary<ProjectPropertyInstance> globalPropertiesInstances,
+            string toolsVersion,
+            BuildParameters buildParameters,
+            ILoggingService loggingService,
+            BuildEventContext projectBuildEventContext,
+            bool isExplicitlyLoaded,
+            IReadOnlyCollection<string> targetNames,
+            ISdkResolverService sdkResolverService,
+            int submissionId)
         {
             ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentNull(globalPropertiesInstances, nameof(globalPropertiesInstances));
diff --git a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
index 77ef8bbf6c8..62f79e2d8a0 100644
--- a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
@@ -74,47 +74,47 @@ public class ProjectItemGroupTaskItemInstance: ITranslatable
         private ElementLocation _location;
 
         /// <summary>
-        /// Location of the include, if any
+        /// Location of the include, if any.
         /// </summary>
         private ElementLocation _includeLocation;
 
         /// <summary>
-        /// Location of the exclude, if any
+        /// Location of the exclude, if any.
         /// </summary>
         private ElementLocation _excludeLocation;
 
         /// <summary>
-        /// Location of the remove, if any
+        /// Location of the remove, if any.
         /// </summary>
         private ElementLocation _removeLocation;
 
         /// <summary>
-        /// Location of matchOnMetadata, if any
+        /// Location of matchOnMetadata, if any.
         /// </summary>
         private ElementLocation _matchOnMetadataLocation;
 
         /// <summary>
-        /// Location of metadataMatchingSchema, if any
+        /// Location of metadataMatchingSchema, if any.
         /// </summary>
         private ElementLocation _matchOnMetadataOptionsLocation;
 
         /// <summary>
-        /// Location of keepMetadata, if any
+        /// Location of keepMetadata, if any.
         /// </summary>
         private ElementLocation _keepMetadataLocation;
 
         /// <summary>
-        /// Location of removeMetadata, if any
+        /// Location of removeMetadata, if any.
         /// </summary>
         private ElementLocation _removeMetadataLocation;
 
         /// <summary>
-        /// Location of keepDuplicates, if any
+        /// Location of keepDuplicates, if any.
         /// </summary>
         private ElementLocation _keepDuplicatesLocation;
 
         /// <summary>
-        /// Location of the condition, if any
+        /// Location of the condition, if any.
         /// </summary>
         private ElementLocation _conditionLocation;
 
@@ -258,7 +258,7 @@ public string Remove
         }
 
         /// <summary>
-        /// Unevaluated MatchOnMetadata value
+        /// Unevaluated MatchOnMetadata value.
         /// </summary>
         public string MatchOnMetadata
         {
@@ -268,7 +268,7 @@ public string MatchOnMetadata
         }
 
         /// <summary>
-        /// Unevaluated MatchOnMetadataOptions value
+        /// Unevaluated MatchOnMetadataOptions value.
         /// </summary>
         public string MatchOnMetadataOptions
         {
@@ -278,7 +278,7 @@ public string MatchOnMetadataOptions
         }
 
         /// <summary>
-        /// Unevaluated keepMetadata value
+        /// Unevaluated keepMetadata value.
         /// </summary>
         public string KeepMetadata
         {
@@ -288,7 +288,7 @@ public string KeepMetadata
         }
 
         /// <summary>
-        /// Unevaluated removeMetadata value
+        /// Unevaluated removeMetadata value.
         /// </summary>
         public string RemoveMetadata
         {
@@ -298,7 +298,7 @@ public string RemoveMetadata
         }
 
         /// <summary>
-        /// Unevaluated keepDuplicates value
+        /// Unevaluated keepDuplicates value.
         /// </summary>
         public string KeepDuplicates
         {
@@ -308,7 +308,7 @@ public string KeepDuplicates
         }
 
         /// <summary>
-        /// Unevaluated condition value
+        /// Unevaluated condition value.
         /// </summary>
         public string Condition
         {
@@ -333,7 +333,7 @@ public ICollection<ProjectItemGroupTaskMetadataInstance> Metadata
         }
 
         /// <summary>
-        /// Location of the element
+        /// Location of the element.
         /// </summary>
         public ElementLocation Location
         {
@@ -343,7 +343,7 @@ public ElementLocation Location
         }
 
         /// <summary>
-        /// Location of the include attribute, if any
+        /// Location of the include attribute, if any.
         /// </summary>
         public ElementLocation IncludeLocation
         {
@@ -353,7 +353,7 @@ public ElementLocation IncludeLocation
         }
 
         /// <summary>
-        /// Location of the exclude attribute, if any
+        /// Location of the exclude attribute, if any.
         /// </summary>
         public ElementLocation ExcludeLocation
         {
@@ -363,7 +363,7 @@ public ElementLocation ExcludeLocation
         }
 
         /// <summary>
-        /// Location of the remove attribute, if any
+        /// Location of the remove attribute, if any.
         /// </summary>
         public ElementLocation RemoveLocation
         {
@@ -373,7 +373,7 @@ public ElementLocation RemoveLocation
         }
 
         /// <summary>
-        /// Location of the matchOnMetadata attribute, if any
+        /// Location of the matchOnMetadata attribute, if any.
         /// </summary>
         public ElementLocation MatchOnMetadataLocation
         {
@@ -383,7 +383,7 @@ public ElementLocation MatchOnMetadataLocation
         }
 
         /// <summary>
-        /// Location of the matchOnMetadataOptions attribute, if any
+        /// Location of the matchOnMetadataOptions attribute, if any.
         /// </summary>
         public ElementLocation MatchOnMetadataOptionsLocation
         {
@@ -393,7 +393,7 @@ public ElementLocation MatchOnMetadataOptionsLocation
         }
 
         /// <summary>
-        /// Location of the keepMetadata attribute, if any
+        /// Location of the keepMetadata attribute, if any.
         /// </summary>
         public ElementLocation KeepMetadataLocation
         {
@@ -403,7 +403,7 @@ public ElementLocation KeepMetadataLocation
         }
 
         /// <summary>
-        /// Location of the removeMetadata attribute, if any
+        /// Location of the removeMetadata attribute, if any.
         /// </summary>
         public ElementLocation RemoveMetadataLocation
         {
@@ -413,7 +413,7 @@ public ElementLocation RemoveMetadataLocation
         }
 
         /// <summary>
-        /// Location of the keepDuplicates attribute, if any
+        /// Location of the keepDuplicates attribute, if any.
         /// </summary>
         public ElementLocation KeepDuplicatesLocation
         {
@@ -423,7 +423,7 @@ public ElementLocation KeepDuplicatesLocation
         }
 
         /// <summary>
-        /// Location of the condition attribute if any
+        /// Location of the condition attribute if any.
         /// </summary>
         public ElementLocation ConditionLocation
         {
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index d91f248d264..6200da27e43 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -28,7 +28,7 @@ namespace Microsoft.Build.Execution
     /// and evaluation has already been performed, so it is unnecessary bulk.
     /// </remarks>
     [DebuggerDisplay("{ItemType}={EvaluatedInclude} #DirectMetadata={DirectMetadataCount})")]
-    public class ProjectItemInstance : IKeyed, IItem<ProjectMetadataInstance>, ITaskItem, ITaskItem2, IMetadataTable, ITranslatable, IDeepCloneable<ProjectItemInstance>
+    public class ProjectItemInstance : IItem<ProjectMetadataInstance>, ITaskItem2, IMetadataTable, ITranslatable, IDeepCloneable<ProjectItemInstance>
     {
         /// <summary>
         /// The project instance to which this item belongs.
@@ -723,7 +723,7 @@ internal sealed class TaskItem :
 #if FEATURE_APPDOMAIN
             MarshalByRefObject,
 #endif
-            ITaskItem, ITaskItem2, IItem<ProjectMetadataInstance>, ITranslatable, IEquatable<TaskItem>
+            ITaskItem2, IItem<ProjectMetadataInstance>, ITranslatable, IEquatable<TaskItem>
         {
             /// <summary>
             /// The source file that defined this item.
@@ -1108,6 +1108,8 @@ internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollecti
                 }
             }
 
+            IEnumerable<ProjectMetadataInstance> IItem<ProjectMetadataInstance>.Metadata => MetadataCollection;
+
             #region Operators
 
             /// <summary>
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index 3e02154592c..6f9367bed45 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Execution
     /// IMMUTABLE OBJECT.
     /// </summary>
     [DebuggerDisplay("{_name}={EvaluatedValue}")]
-    public class ProjectMetadataInstance : IKeyed, IValued, IEquatable<ProjectMetadataInstance>, ITranslatable, IMetadatum, IDeepCloneable<ProjectMetadataInstance>, IImmutable
+    public class ProjectMetadataInstance : IEquatable<ProjectMetadataInstance>, ITranslatable, IMetadatum, IDeepCloneable<ProjectMetadataInstance>, IImmutable
     {
         /// <summary>
         /// Name of the metadatum
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 41fc39891bb..35b6e45e851 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -156,8 +156,9 @@
     <Compile Include="BackEnd\BuildManager\CacheAggregator.cs" />
     <Compile Include="BackEnd\Components\Caching\ConfigCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
+    <Compile Include="BackEnd\Components\ProjectCache\*.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
-    <Compile Include="FileSystem\MSBuildFileSystemBase.cs" />
+    <Compile Include="FileSystem\*.cs" />
     <Compile Include="Utilities\NuGetFrameworkWrapper.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectUsingTaskParameterElementLink.cs" />
     <Compile Include="ObjectModelRemoting\ExternalProjectsProvider.cs" />
@@ -264,7 +265,6 @@
     <Compile Include="Evaluation\LazyItemEvaluator.ItemFactoryWrapper.cs" />
     <Compile Include="Evaluation\LazyItemEvaluator.RemoveOperation.cs" />
     <Compile Include="Evaluation\MetadataReference.cs" />
-    <Compile Include="FileSystem\MSBuildFileSystemAdapter.cs" />
     <Compile Include="Graph\ProjectGraphEntryPoint.cs" />
     <Compile Include="Graph\ProjectGraph.cs" />
     <Compile Include="Graph\ProjectGraphNode.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 21f58d65fd8..7d3fa3d7161 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1,17 +1,17 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <root>
-  <!-- 
-    Microsoft ResX Schema 
-    
+  <!--
+    Microsoft ResX Schema
+
     Version 2.0
-    
-    The primary goals of this format is to allow a simple XML format 
-    that is mostly human readable. The generation and parsing of the 
-    various data types are done through the TypeConverter classes 
+
+    The primary goals of this format is to allow a simple XML format
+    that is mostly human readable. The generation and parsing of the
+    various data types are done through the TypeConverter classes
     associated with the data types.
-    
+
     Example:
-    
+
     ... ado.net/XML headers & schema ...
     <resheader name="resmimetype">text/microsoft-resx</resheader>
     <resheader name="version">2.0</resheader>
@@ -26,36 +26,36 @@
         <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
         <comment>This is a comment</comment>
     </data>
-                
-    There are any number of "resheader" rows that contain simple 
+
+    There are any number of "resheader" rows that contain simple
     name/value pairs.
-    
-    Each data row contains a name, and value. The row also contains a 
-    type or mimetype. Type corresponds to a .NET class that support 
-    text/value conversion through the TypeConverter architecture. 
-    Classes that don't support this are serialized and stored with the 
+
+    Each data row contains a name, and value. The row also contains a
+    type or mimetype. Type corresponds to a .NET class that support
+    text/value conversion through the TypeConverter architecture.
+    Classes that don't support this are serialized and stored with the
     mimetype set.
-    
-    The mimetype is used for serialized objects, and tells the 
-    ResXResourceReader how to depersist the object. This is currently not 
+
+    The mimetype is used for serialized objects, and tells the
+    ResXResourceReader how to depersist the object. This is currently not
     extensible. For a given mimetype the value must be set accordingly:
-    
-    Note - application/x-microsoft.net.object.binary.base64 is the format 
-    that the ResXResourceWriter will generate, however the reader can 
+
+    Note - application/x-microsoft.net.object.binary.base64 is the format
+    that the ResXResourceWriter will generate, however the reader can
     read any of the formats listed below.
-    
+
     mimetype: application/x-microsoft.net.object.binary.base64
-    value   : The object must be serialized with 
+    value   : The object must be serialized with
             : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
             : and then encoded with base64 encoding.
-    
+
     mimetype: application/x-microsoft.net.object.soap.base64
-    value   : The object must be serialized with 
+    value   : The object must be serialized with
             : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
             : and then encoded with base64 encoding.
 
     mimetype: application/x-microsoft.net.object.bytearray.base64
-    value   : The object must be serialized into a byte array 
+    value   : The object must be serialized into a byte array
             : using a System.ComponentModel.TypeConverter
             : and then encoded with base64 encoding.
     -->
@@ -1851,4 +1851,29 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="IsolatedContextDoesNotSupportFileSystem" xml:space="preserve">
     <value>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</value>
   </data>
+  <data name="LoadingProjectCachePlugin" xml:space="preserve">
+    <value>"Loading the following project cache plugin:
+    {0}"</value>
+  </data>
+  <data name="SolutionPathPropertyMustBeSetOnVSSubmissions" xml:space="preserve">
+    <value>"MSB4264: Invalid $(SolutionPath) property: {0}"</value>
+  </data>
+  <data name="OnlyOneCachePluginMustBeSpecified" xml:space="preserve">
+    <value>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</value>
+  </data>
+  <data name="ProjectCacheInitializationFailed" xml:space="preserve">
+    <value>MSB4266: Failed to initialize the project cache.</value>
+  </data>
+  <data name="ProjectCacheQueryFailed" xml:space="preserve">
+    <value>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</value>
+  </data>
+  <data name="ProjectCacheShutdownFailed" xml:space="preserve">
+    <value>MSB4268: The project cache failed to shut down properly.</value>
+  </data>
+  <data name="NotAllNodesDefineACacheItem" xml:space="preserve">
+    <value>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</value>
+  </data>
+  <data name="NoProjectCachePluginFoundInAssembly" xml:space="preserve">
+    <value>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</value>
+  </data>
 </root>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 93562d16e6c..e53798c778d 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -132,6 +132,13 @@
         <target state="translated">Objekty EvaluationContext vytvořené pomocí SharingPolicy.Isolated nepodporují předávání souborového systému MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Podrobnost protokolování je nastavená na: {0}.</target>
@@ -154,6 +161,16 @@
         <target state="translated">Operaci nelze dokončit, protože funkce BeginBuild ještě nebyla zavolána.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Požadované sestavení NuGet se nenašlo. Očekávaná cesta: {0}</target>
@@ -192,6 +209,26 @@
         <target state="translated">Metoda {0} se nedá zavolat s kolekcí, která obsahuje prázdné cílové názvy nebo názvy null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph nepodporuje položky ProjectReference s nastavenými metadaty ToolsVersion. V souboru {1} byla nalezena položka ProjectReference {0} s metadaty ToolsVersion.</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Bylo zjištěno více vstupních bodů s řešeními: {0}. Pokud se z řešení načte statický graf, musí být toto řešení jediným vstupním bodem.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index becd3410796..cedd498f70f 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -132,6 +132,13 @@
         <target state="translated">"Die Übergabe eines MSBuildFileSystemBase-Dateisystems wird von EvaluationContext-Objekten, die mit SharingPolicy.Isolated erstellt wurden, nicht unterstützt."</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Die Ausführlichkeit der Protokollierung ist auf "{0}" festgelegt.</target>
@@ -154,6 +161,16 @@
         <target state="translated">Der Vorgang kann nicht abgeschlossen werden, da BeginBuild noch nicht aufgerufen wurde.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Eine erforderliche NuGet-Assembly wurde nicht gefunden. Erwarteter Pfad: {0}</target>
@@ -192,6 +209,26 @@
         <target state="translated">Die Methode "{0}" kann nicht mit einer Sammlung aufgerufen werden, die NULL oder leere Zielnamen enthält.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph bietet keine Unterstützung für ProjectReference-Elemente mit dem ToolsVersion-Metadatensatz. In der Datei "{1}" wurde ProjectReference "{0}" mit "ToolsVersion" gefunden.</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Es wurden mehrere Einstiegspunkte mit Projektmappen gefunden: {0}. Wenn ein statischer Graph aus einer Projektmappe geladen wird, muss diese Projektmappe der einzige Einstiegspunkt sein.</target>
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index a43e6b33729..d2f150f9752 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -132,6 +132,13 @@
         <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="new">Logging verbosity is set to: {0}.</target>
@@ -154,6 +161,16 @@
         <target state="new">The operation cannot be completed because BeginBuild has not yet been called.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
@@ -192,6 +209,26 @@
         <target state="new">Method {0} cannot be called with a collection containing null or empty target names.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="new">MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="new">MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 27bb8de9472..67be95b5e38 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -132,6 +132,13 @@
         <target state="translated">"Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase".</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">El nivel de detalle de registro está establecido en {0}.</target>
@@ -154,6 +161,16 @@
         <target state="translated">La operación no se puede completar porque todavía no se llamó a BeginBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">No se encontró un ensamblado de NuGet necesario. Ruta de acceso esperada: {0}</target>
@@ -192,6 +209,26 @@
         <target state="translated">No se puede llamar al método {0} con una colección que contiene nombres de destino nulos o vacíos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph no admite elementos de ProjectReference con los metadatos de ToolsVersion establecidos. Se encontró ProjectReference "{0}" con ToolsVersion en el archivo "{1}"</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Se detectaron varios puntos de entrada con soluciones: {0}. Si el gráfico estático se carga a partir de una solución, esa solución debe ser el único punto de entrada.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 0a6fa86e5b3..fd377f2b9be 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -132,6 +132,13 @@
         <target state="translated">"Les objets EvaluationContext créés avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un système de fichiers MSBuildFileSystemBase."</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">La verbosité de la journalisation a la valeur {0}.</target>
@@ -154,6 +161,16 @@
         <target state="translated">Impossible d'effectuer l'opération car la méthode BeginBuild n'a pas encore été appelée.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Un assembly NuGet obligatoire est introuvable. Chemin attendu : {0}</target>
@@ -192,6 +209,26 @@
         <target state="translated">Impossible d'appeler la méthode {0} avec une collection contenant des noms de cibles qui ont une valeur null ou qui sont vides.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph ne prend pas en charge les éléments ProjectReference avec l'ensemble de métadonnées ToolsVersion. ProjectReference "{0}" trouvé avec ToolsVersion dans le fichier "{1}"</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: détection de plusieurs points d'entrée avec des solutions : {0}. Si un graphe statique est chargé à partir d'une solution, cette solution doit être le seul point d'entrée.</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 0d4a32056ed..08e593ca38c 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -132,6 +132,13 @@
         <target state="translated">"Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non è possibile passare un file system MSBuildFileSystemBase."</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Il livello di dettaglio della registrazione è impostato su: {0}.</target>
@@ -154,6 +161,16 @@
         <target state="translated">Non è possibile completare l'operazione perché BeginBuild non è stato ancora chiamato.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Un assembly NuGet obbligatorio non è stato trovato. Percorso previsto: {0}</target>
@@ -192,6 +209,26 @@
         <target state="translated">Non è possibile chiamare il metodo {0} con una raccolta contenente nomi di destinazione Null o vuoti.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph non supporta elementi ProjectReference con metadati ToolsVersion impostati. L'elemento ProjectReference "{0}" con ToolsVersion è stato trovato nel file "{1}"</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Sono stati rilevati più punti di ingresso con le soluzioni: {0}. Se il grafo statico viene caricato da una soluzione, tale soluzione deve essere l'unico punto di ingresso.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index bde5c0e21f1..375becad3df 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -132,6 +132,13 @@
         <target state="translated">"SharingPolicy.Isolated を指定して作成された EvaluationContext オブジェクトに MSBuildFileSystemBase ファイル システムを渡すことはサポートされていません。"</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">ログの詳細度は次のように設定されています: {0}。</target>
@@ -154,6 +161,16 @@
         <target state="translated">BeginBuild がまだ呼び出されていないため、操作を完了できません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">必要な NuGet アセンブリが見つかりませんでした。想定されるパス: {0}</target>
@@ -192,6 +209,26 @@
         <target state="translated">Null または空のターゲット名を含むコレクションを指定してメソッド {0} を呼び出すことはできません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph では、ToolsVersion メタデータが設定された ProjectReference 項目はサポートしていません。ToolsVersion が含まれる ProjectReference "{0}" がファイル "{1}" で見つかりました</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: ソリューションが検出されたエントリ ポイントが複数あります: {0}。静的グラフがソリューションから読み込まれる場合、そのソリューションが唯一のエントリ ポイントである必要があります。</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index b13fb3cd31b..71515138175 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -132,6 +132,13 @@
         <target state="translated">"SharingPolicy.Isolated로 만든 EvaluationContext 개체는 MSBuildFileSystemBase 파일 시스템 전달을 지원하지 않습니다."</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">로깅의 세부 정보 표시가 {0}(으)로 설정되었습니다.</target>
@@ -154,6 +161,16 @@
         <target state="translated">BeginBuild가 아직 호출되지 않았으므로 작업을 완료할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">필요한 NuGet 어셈블리를 찾을 수 없습니다. 예상 경로: {0}</target>
@@ -192,6 +209,26 @@
         <target state="translated">null 또는 빈 대상 이름을 포함하는 컬렉션을 사용하여 {0} 메서드를 호출할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph는 ToolsVersion 메타데이터가 설정된 ProjectReference 항목을 지원하지 않습니다. "{1}" 파일에 ToolsVersion이 포함된 ProjectReference "{0}"이(가) 있습니다.</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: 솔루션에서 여러 진입점이 검색되었습니다. {0}. 솔루션에서 정적 그래프가 로드되는 경우 해당 솔루션이 유일한 진입점이어야 합니다.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 97c0f8f033b..6e351a614d3 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -132,6 +132,13 @@
         <target state="translated">„Obiekty EvaluationContext utworzone za pomocą elementu SharingPolicy.Isolated nie obsługują przekazywania za pomocą systemu plików MSBuildFileSystemBase.”</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Szczegółowość rejestrowania została ustawiona na: {0}.</target>
@@ -154,6 +161,16 @@
         <target state="translated">Nie można zakończyć operacji, ponieważ metoda BeginBuild nie została jeszcze wywołana.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Nie znaleziono wymaganego zestawu NuGet. Oczekiwano ścieżki {0}.</target>
@@ -192,6 +209,26 @@
         <target state="translated">Metody {0} nie można wywołać przy użyciu kolekcji zawierającej nazwy docelowe o wartości null lub puste.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: Element ProjectGraph nie obsługuje elementów ProjectReference z ustawionymi metadanymi atrybutu ToolsVersion. W pliku „{1}” odnaleziono element ProjectReference „{0}” z atrybutem ToolsVersion</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Wykryto wiele punktów wejścia z rozwiązaniami: {0}. Jeśli graf statyczny jest ładowany z rozwiązania, musi ono być jedynym punktem wejścia.</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index b2a37ebc161..f70c147770a 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -132,6 +132,13 @@
         <target state="translated">"Os objetos EvaluationContext criados com SharingPolicy.Isolable não são compatíveis com o recebimento de um sistema de arquivos MSBuildFileSystemBase."</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">O detalhamento do log está definido como: {0}.</target>
@@ -154,6 +161,16 @@
         <target state="translated">A operação não pode ser concluída porque BeginBuild ainda não foi chamado.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Um assembly NuGet necessário não foi encontrado. Caminho Esperado: {0}</target>
@@ -192,6 +209,26 @@
         <target state="translated">O método {0} não pode ser chamado com uma coleção que contém nomes de destino nulos ou vazios.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: O ProjectGraph não tem suporte para os itens ProjectReference com o conjunto de metadados ToolsVersion. O ProjectReference "{0}" foi encontrado com ToolsVersion no arquivo "{1}"</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Vários pontos de entrada com soluções detectados: {0}. Se o grafo estático for carregado de uma solução, ela precisará ser o único ponto de entrada.</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 7855cd60ba4..cd8b9a1caac 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -132,6 +132,13 @@
         <target state="translated">"Объекты EvaluationContext, созданные с помощью SharingPolicy.Isolated, не поддерживают передачу в файловую систему MSBuildFileSystemBase."</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Уровень детализации журнала: {0}.</target>
@@ -154,6 +161,16 @@
         <target state="translated">Не удается завершить операцию, так как ещё не был вызван BeginBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Не найдена обязательная сборка NuGet. Ожидаемый путь: {0}</target>
@@ -192,6 +209,26 @@
         <target state="translated">Метод {0} не может быть вызван с коллекцией, содержащей целевые имена, которые пусты или равны NULL.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph не поддерживает элементы ProjectReference с набором метаданных ToolsVersion. Обнаружен ProjectReference "{0}" с ToolsVersion в файле "{1}"</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: обнаружено несколько точек входа с решениями: {0}. Если статический граф загружен из решения, то это решение должно быть единственной точкой входа.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index d7dfbe4cb5b..825f2dcc90a 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -132,6 +132,13 @@
         <target state="translated">"SharingPolicy.Isolated ile oluşturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin geçirilmesini desteklemez."</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Günlük kaydı ayrıntı düzeyi {0} olarak ayarlandı.</target>
@@ -154,6 +161,16 @@
         <target state="translated">BeginBuild henüz çağrılmadığı için işlem tamamlanamıyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">Gereken NuGet derlemesi bulunamadı. Beklenen Yol: {0}</target>
@@ -192,6 +209,26 @@
         <target state="translated">{0} metosu null veya boş hedef adları içeren bir koleksiyonla çağrılamaz.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph, ToolsVersion meta veri kümesine sahip ProjectReference öğelerini desteklemez. "{1}" dosyasında ToolsVersion içeren ProjectReference "{0}" bulundu</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: Çözümlerde birden fazla giriş noktası algılandı: {0}. Statik graf bir çözümden yükleniyorsa bu çözüm tek giriş noktası olmalıdır.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 89f1c2d53ae..cf4bce1a797 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -132,6 +132,13 @@
         <target state="translated">“使用 SharingPolicy.Isolated 创建的 EvaluationContext 对象不支持通过 MSBuildFileSystemBase 文件系统传递。”</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">日志记录详细程度设置为: {0}。</target>
@@ -154,6 +161,16 @@
         <target state="translated">无法完成该操作，因为尚未调用 BeginBuild。</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">未找到所需的 NuGet 程序集。所需路径: {0}</target>
@@ -192,6 +209,26 @@
         <target state="translated">无法使用包含 null 或空目标名称的集合调用方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph 不支持具有 ToolsVersion 元数据集的 ProjectReference 项。在“{1}”文件中发现了带有 ToolsVersion 的 ProjectReference“{0}”</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: 检测到多个具有解决方案的入口点: {0}。如果静态图表是从解决方案中加载的，则该解决方案必须是唯一的入口点。</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 471797ec1b6..64f91b3ebe5 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -132,6 +132,13 @@
         <target state="translated">"使用 SharingPolicy.Isolated 建立的 EvaluationContext 物件不支援以 MSBuildFileSystemBase 檔案系統傳遞。"</target>
         <note />
       </trans-unit>
+      <trans-unit id="LoadingProjectCachePlugin">
+        <source>"Loading the following project cache plugin:
+    {0}"</source>
+        <target state="new">"Loading the following project cache plugin:
+    {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">記錄詳細程度設定為: {0}。</target>
@@ -154,6 +161,16 @@
         <target state="translated">無法完成作業，因為尚未呼叫 BeginBuild。</target>
         <note />
       </trans-unit>
+      <trans-unit id="NoProjectCachePluginFoundInAssembly">
+        <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
+        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="NotAllNodesDefineACacheItem">
+        <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
+        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
         <target state="translated">找不到必要的 NuGet 元件。預期的路徑: {0}</target>
@@ -192,6 +209,26 @@
         <target state="translated">無法使用內含 null 或空白目標名稱的集合呼叫方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OnlyOneCachePluginMustBeSpecified">
+        <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
+        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheInitializationFailed">
+        <source>MSB4266: Failed to initialize the project cache.</source>
+        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheQueryFailed">
+        <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
+        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="ProjectCacheShutdownFailed">
+        <source>MSB4268: The project cache failed to shut down properly.</source>
+        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph 不支援設有 ToolsVersion 中繼資料的 ProjectReference 項目。在檔案 "{1}" 中找到具有 ToolsVersion 的 ProjectReference "{0}"</target>
@@ -212,6 +249,11 @@
       LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
+      <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
+        <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
+        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
         <target state="translated">MSB4261: 偵測到解決方案有多個進入點: {0}。若是從解決方案載入靜態圖表，則該解決方案只可有一個進入點。</target>
diff --git a/src/Build/Utilities/FileSpecMatchTester.cs b/src/Build/Utilities/FileSpecMatchTester.cs
index bdca578f85a..e48fca39e77 100644
--- a/src/Build/Utilities/FileSpecMatchTester.cs
+++ b/src/Build/Utilities/FileSpecMatchTester.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
-using System;
 using System.Diagnostics;
 using System.IO;
 using System.Text.RegularExpressions;
diff --git a/src/Deprecated/Engine/Errors/InternalLoggerException.cs b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
index 22f730e348c..3926d8504db 100644
--- a/src/Deprecated/Engine/Errors/InternalLoggerException.cs
+++ b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
@@ -14,12 +14,10 @@ namespace Microsoft.Build.BuildEngine
     /// This exception is used to wrap an unhandled exception from a logger. This exception aborts the build, and it can only be
     /// thrown by the MSBuild engine.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
     /// <owner>SumedhK</owner>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
     public sealed class InternalLoggerException : Exception
     {
diff --git a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
index 63d3c34a620..2f08d3348e9 100644
--- a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
@@ -14,12 +14,11 @@ namespace Microsoft.Build.BuildEngine
     /// This exception is thrown whenever there is a problem with the user's XML project file. The problem might be semantic or
     /// syntactical. The latter would be of a type typically caught by XSD validation (if it was performed by the project writer).
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
     /// <owner>RGoel</owner>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
+
     [Serializable]
     public sealed class InvalidProjectFileException : Exception
     {
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 8e63a94f93d..3741fdc7d47 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -42,7 +42,6 @@
     <DefineConstants Condition="'$(MonoBuild)' != 'true' and '$(MachineIndependentBuild)' != 'true'">$(DefineConstants);FEATURE_ENCODING_DEFAULT</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_ENVIRONMENT_SYSTEMDIRECTORY</DefineConstants>
     <DefineConstants Condition="'$(MonoBuild)' != 'true'">$(DefineConstants);FEATURE_FILE_TRACKER</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_FUSION_COMPAREASSEMBLYIDENTITY</DefineConstants>
     <DefineConstants Condition="'$(MachineIndependentBuild)' != 'true'">$(DefineConstants);FEATURE_GAC</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_GET_COMMANDLINE</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_HANDLE_SAFEWAITHANDLE</DefineConstants>
diff --git a/src/Framework/BuildErrorEventArgs.cs b/src/Framework/BuildErrorEventArgs.cs
index 5d086d1850e..4cbbb4106d6 100644
--- a/src/Framework/BuildErrorEventArgs.cs
+++ b/src/Framework/BuildErrorEventArgs.cs
@@ -10,14 +10,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for error events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class BuildErrorEventArgs : LazyFormattedBuildEventArgs
     {
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index 5e56b0c79aa..1592e8fd480 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -12,14 +12,12 @@ namespace Microsoft.Build.Framework
     /// This class encapsulates the default data associated with build events. 
     /// It is intended to be extended/sub-classed.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public abstract class BuildEventArgs : EventArgs
     {
diff --git a/src/Framework/BuildFinishedEventArgs.cs b/src/Framework/BuildFinishedEventArgs.cs
index 34083b46ebe..198b7df2034 100644
--- a/src/Framework/BuildFinishedEventArgs.cs
+++ b/src/Framework/BuildFinishedEventArgs.cs
@@ -9,14 +9,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// This class represents the event arguments for build finished events.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class BuildFinishedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/BuildMessageEventArgs.cs b/src/Framework/BuildMessageEventArgs.cs
index c31672b68a5..7a73a533151 100644
--- a/src/Framework/BuildMessageEventArgs.cs
+++ b/src/Framework/BuildMessageEventArgs.cs
@@ -33,14 +33,12 @@ public enum MessageImportance
     /// <summary>
     /// Arguments for message events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class BuildMessageEventArgs : LazyFormattedBuildEventArgs
     {
diff --git a/src/Framework/BuildStartedEventArgs.cs b/src/Framework/BuildStartedEventArgs.cs
index a177576f7e2..8297879a12c 100644
--- a/src/Framework/BuildStartedEventArgs.cs
+++ b/src/Framework/BuildStartedEventArgs.cs
@@ -9,14 +9,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for build started events.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class BuildStartedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/BuildWarningEventArgs.cs b/src/Framework/BuildWarningEventArgs.cs
index 5b37aa338c1..f78f7716bff 100644
--- a/src/Framework/BuildWarningEventArgs.cs
+++ b/src/Framework/BuildWarningEventArgs.cs
@@ -10,14 +10,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for warning events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class BuildWarningEventArgs : LazyFormattedBuildEventArgs
     {
diff --git a/src/Framework/CriticalBuildMessageEventArgs.cs b/src/Framework/CriticalBuildMessageEventArgs.cs
index 2bc8853a295..0aad4046ada 100644
--- a/src/Framework/CriticalBuildMessageEventArgs.cs
+++ b/src/Framework/CriticalBuildMessageEventArgs.cs
@@ -8,14 +8,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for critical message events. These always have High importance.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class CriticalBuildMessageEventArgs : BuildMessageEventArgs
     {
diff --git a/src/Framework/CustomBuildEventArgs.cs b/src/Framework/CustomBuildEventArgs.cs
index c676c75f8f1..cba045ebb3e 100644
--- a/src/Framework/CustomBuildEventArgs.cs
+++ b/src/Framework/CustomBuildEventArgs.cs
@@ -8,14 +8,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for custom build events.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public abstract class CustomBuildEventArgs : LazyFormattedBuildEventArgs
     {
diff --git a/src/Framework/ExternalProjectFinishedEventArgs.cs b/src/Framework/ExternalProjectFinishedEventArgs.cs
index ab5a72406dc..d09c6f56df1 100644
--- a/src/Framework/ExternalProjectFinishedEventArgs.cs
+++ b/src/Framework/ExternalProjectFinishedEventArgs.cs
@@ -8,14 +8,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for external project finished events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class ExternalProjectFinishedEventArgs : CustomBuildEventArgs
     {
diff --git a/src/Framework/ExternalProjectStartedEventArgs.cs b/src/Framework/ExternalProjectStartedEventArgs.cs
index d086130dfab..2073ee505d6 100644
--- a/src/Framework/ExternalProjectStartedEventArgs.cs
+++ b/src/Framework/ExternalProjectStartedEventArgs.cs
@@ -8,14 +8,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for external project started events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class ExternalProjectStartedEventArgs : CustomBuildEventArgs
     {
diff --git a/src/Framework/ILogger.cs b/src/Framework/ILogger.cs
index 9dd6e9f675d..938ea0bd890 100644
--- a/src/Framework/ILogger.cs
+++ b/src/Framework/ILogger.cs
@@ -19,11 +19,12 @@ namespace Microsoft.Build.Framework
     /// 3) Normal -- display all errors, warnings, high importance events, some status events, and a build summary
     /// 4) Detailed -- display all errors, warnings, high and normal importance events, all status events, and a build summary
     /// 5) Diagnostic -- display all events, and a build summary
-    /// 
-    /// WARNING: VS Automation code for the Tools/Options MSBuild build verbosity setting will be broken
-    /// by changes to this enum (not to mention existing MSBuild clients and vsproject code). 
-    /// Please make sure to talk to automation devs before changing it.
     /// </remarks>
+    // 
+    // WARNING: VS Automation code for the Tools/Options MSBuild build verbosity setting will be broken
+    // by changes to this enum (not to mention existing MSBuild clients and vsproject code). 
+    // Please make sure to talk to automation devs before changing it.
+
     [ComVisible(true)]
     public enum LoggerVerbosity
     {
diff --git a/src/Framework/LoggerException.cs b/src/Framework/LoggerException.cs
index f30bf2452f3..63ed9ea7606 100644
--- a/src/Framework/LoggerException.cs
+++ b/src/Framework/LoggerException.cs
@@ -14,11 +14,9 @@ namespace Microsoft.Build.Framework
     /// Allows a logger to force the build to stop in an explicit way, when, for example, it 
     /// receives invalid parameters, or cannot write to disk.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
     public class LoggerException : Exception
     {
diff --git a/src/Framework/ProjectFinishedEventArgs.cs b/src/Framework/ProjectFinishedEventArgs.cs
index 7ae29c7215f..5c0cee0f259 100644
--- a/src/Framework/ProjectFinishedEventArgs.cs
+++ b/src/Framework/ProjectFinishedEventArgs.cs
@@ -10,14 +10,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for project finished events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class ProjectFinishedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index b1bd90f8076..2de82ffe9cb 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -14,14 +14,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for project started events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class ProjectStartedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/TargetFinishedEventArgs.cs b/src/Framework/TargetFinishedEventArgs.cs
index c4951de6c61..fae6bbd1c9b 100644
--- a/src/Framework/TargetFinishedEventArgs.cs
+++ b/src/Framework/TargetFinishedEventArgs.cs
@@ -11,14 +11,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for target finished events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class TargetFinishedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/TargetStartedEventArgs.cs b/src/Framework/TargetStartedEventArgs.cs
index 69b2ae7a1db..5d2b3b11dbd 100644
--- a/src/Framework/TargetStartedEventArgs.cs
+++ b/src/Framework/TargetStartedEventArgs.cs
@@ -10,14 +10,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for target started events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>    
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility    
     [Serializable]
     public class TargetStartedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/TaskFinishedEventArgs.cs b/src/Framework/TaskFinishedEventArgs.cs
index f8a8e1ef918..ca969f10712 100644
--- a/src/Framework/TaskFinishedEventArgs.cs
+++ b/src/Framework/TaskFinishedEventArgs.cs
@@ -10,14 +10,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for task finished events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class TaskFinishedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/Framework/TaskStartedEventArgs.cs b/src/Framework/TaskStartedEventArgs.cs
index 7f9c63b3338..039ef4b2b81 100644
--- a/src/Framework/TaskStartedEventArgs.cs
+++ b/src/Framework/TaskStartedEventArgs.cs
@@ -10,14 +10,12 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for task started events
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing
-    /// ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is
-    /// immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both
-    /// forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing
+    // ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is
+    // immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both
+    // forward and backward compatibility
     [Serializable]
     public class TaskStartedEventArgs : BuildStatusEventArgs
     {
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 5fee06a9d1e..03f84f7fd47 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -448,7 +448,7 @@ public void TargetsSwitchIdentificationTests(string @switch)
         public void TargetsSwitchParameter()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList() { "/targets:targets.txt" }, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>() { "/targets:targets.txt" }, switches);
 
             switches.HaveErrors().ShouldBeFalse();
             switches[CommandLineSwitches.ParameterizedSwitch.Targets].ShouldBe(new[] { "targets.txt" });
@@ -458,7 +458,7 @@ public void TargetsSwitchParameter()
         public void TargetsSwitchDoesNotSupportMultipleOccurrences()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList() { "/targets /targets" }, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>() { "/targets /targets" }, switches);
 
             switches.HaveErrors().ShouldBeTrue();
         }
@@ -537,7 +537,7 @@ public void InputResultsCachesSupportsMultipleOccurrence()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(){"/irc", "/irc:a;b", "/irc:c;d"}, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(){"/irc", "/irc:a;b", "/irc:c;d"}, switches);
 
             switches[CommandLineSwitches.ParameterizedSwitch.InputResultsCaches].ShouldBe(new []{null, "a", "b", "c", "d"});
 
@@ -549,7 +549,7 @@ public void OutputResultsCache()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(){"/orc:a"}, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(){"/orc:a"}, switches);
 
             switches[CommandLineSwitches.ParameterizedSwitch.OutputResultsCache].ShouldBe(new []{"a"});
 
@@ -561,7 +561,7 @@ public void OutputResultsCachesDoesNotSupportMultipleOccurrences()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(){"/orc:a", "/orc:b"}, switches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(){"/orc:a", "/orc:b"}, switches);
 
             switches.HaveErrors().ShouldBeTrue();
         }
@@ -1041,7 +1041,7 @@ public void ProcessWarnAsErrorSwitchNotSpecified()
         {
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[] { "" }), commandLineSwitches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[] { "" }), commandLineSwitches);
 
             Assert.Null(MSBuildApp.ProcessWarnAsErrorSwitch(commandLineSwitches));
         }
@@ -1056,7 +1056,7 @@ public void ProcessWarnAsErrorSwitchWithCodes()
 
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[]
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[]
             {
                 "\"/warnaserror: a,B ; c \"", // Leading, trailing, leading and trailing whitespace
                 "/warnaserror:A,b,C",         // Repeats of different case
@@ -1081,7 +1081,7 @@ public void ProcessWarnAsErrorSwitchEmptySwitchClearsSet()
         {
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[]
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[]
             {
                 "/warnaserror:a;b;c",
                 "/warnaserror",
@@ -1104,7 +1104,7 @@ public void ProcessWarnAsErrorSwitchValuesAfterEmptyAddOn()
 
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[]
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[]
             {
                 "/warnaserror:a;b;c",
                 "/warnaserror",
@@ -1126,7 +1126,7 @@ public void ProcessWarnAsErrorSwitchEmpty()
         {
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new [] { "/warnaserror" }), commandLineSwitches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new [] { "/warnaserror" }), commandLineSwitches);
 
             ISet<string> actualWarningsAsErrors = MSBuildApp.ProcessWarnAsErrorSwitch(commandLineSwitches);
 
@@ -1143,7 +1143,7 @@ public void ProcessWarnAsMessageSwitchEmpty()
         {
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[] { "/warnasmessage" }), commandLineSwitches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[] { "/warnasmessage" }), commandLineSwitches);
 
             VerifySwitchError(commandLineSwitches, "/warnasmessage", AssemblyResources.GetString("MissingWarnAsMessageParameterError"));
         }
@@ -1158,7 +1158,7 @@ public void ProcessWarnAsMessageSwitchWithCodes()
 
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[]
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[]
             {
                 "\"/warnasmessage: a,B ; c \"", // Leading, trailing, leading and trailing whitespace
                 "/warnasmessage:A,b,C",         // Repeats of different case
@@ -1183,7 +1183,7 @@ public void ProcessProfileEvaluationEmpty()
         {
             CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
 
-            MSBuildApp.GatherCommandLineSwitches(new ArrayList(new[] { "/profileevaluation" }), commandLineSwitches);
+            MSBuildApp.GatherCommandLineSwitches(new List<string>(new[] { "/profileevaluation" }), commandLineSwitches);
             commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ProfileEvaluation][0].ShouldBe("no-file");
         }
 
@@ -1211,7 +1211,7 @@ public void ProcessProfileEvaluationInvalidFilename(string filename)
         {
             bool enableProfiler = false;
             Should.Throw(
-                () => MSBuildApp.ProcessProfileEvaluationSwitch(new[] {filename}, new ArrayList(), out enableProfiler),
+                () => MSBuildApp.ProcessProfileEvaluationSwitch(new[] {filename}, new List<ILogger>(), out enableProfiler),
                 typeof(CommandLineSwitchException));
         }
 
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 2000fafaa02..630890e9085 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -44,7 +44,7 @@ public void GatherCommandLineSwitchesTwoProperties()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            ArrayList arguments = new ArrayList();
+            var arguments = new List<string>();
             arguments.AddRange(new string[] { "/p:a=b", "/p:c=d" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
@@ -59,7 +59,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithArgument()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            ArrayList arguments = new ArrayList();
+            var arguments = new List<string>();
             arguments.AddRange(new string[] { "/m:2" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
@@ -76,7 +76,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithoutArgument()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            ArrayList arguments = new ArrayList();
+            var arguments = new List<string>();
             arguments.AddRange(new string[] { "/m:3", "/m" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
@@ -96,7 +96,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithoutArgumentButWithColon()
         {
             CommandLineSwitches switches = new CommandLineSwitches();
 
-            ArrayList arguments = new ArrayList();
+            var arguments = new List<string>();
             arguments.AddRange(new string[] { "/m:" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
@@ -137,7 +137,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithoutArgumentButWithColon()
         [Fact]
         public void SplitUnquotedTest()
         {
-            ArrayList sa;
+            List<string> sa;
             int emptySplits;
 
             // nothing quoted
@@ -586,7 +586,7 @@ public void SetConsoleUICulture()
             MSBuildApp.SetConsoleUI();
 
             // Make sure this doesn't throw an exception.
-            string bar = String.Format(CultureInfo.CurrentUICulture, "{0}", (int)1);
+            string bar = String.Format(CultureInfo.CurrentUICulture, "{0}", 1);
 
             // Restore the current UI culture back to the way it was at the beginning of this unit test.
             thisThread.CurrentUICulture = originalUICulture;
@@ -1329,7 +1329,7 @@ public void TestTwoIdenticalExtensionsToIgnore()
         public void TestProcessProjectSwitchNullandEmptyProjectsToIgnore()
         {
             string[] projects = new string[] { "my.proj" };
-            string[] extensionsToIgnore = (string[])null;
+            string[] extensionsToIgnore = null;
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
 
@@ -1697,7 +1697,7 @@ public void TestProcessFileLoggerSwitch1()
             string[] fileLoggerParameters = null;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1720,7 +1720,7 @@ public void TestProcessFileLoggerSwitch2()
             string[] fileLoggerParameters = null;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1743,7 +1743,7 @@ public void TestProcessFileLoggerSwitch3()
             string[] fileLoggerParameters = null;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1758,7 +1758,7 @@ public void TestProcessFileLoggerSwitch3()
             // add a set of parameters and make sure the logger has those parameters
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[1] { "Parameter" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1773,7 +1773,7 @@ public void TestProcessFileLoggerSwitch3()
 
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[2] { "Parameter1", "Parameter" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1797,7 +1797,7 @@ public void TestProcessFileLoggerSwitch4()
             string[] fileLoggerParameters = null;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1813,7 +1813,7 @@ public void TestProcessFileLoggerSwitch4()
             // Not add a set of parameters and make sure the logger has those parameters
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[1] { "verbosity=Normal;" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1830,7 +1830,7 @@ public void TestProcessFileLoggerSwitch4()
             // Not add a set of parameters and make sure the logger has those parameters
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[2] { "verbosity=Normal", "" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1847,7 +1847,7 @@ public void TestProcessFileLoggerSwitch4()
             // Not add a set of parameters and make sure the logger has those parameters
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[2] { "", "Parameter1" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1864,7 +1864,7 @@ public void TestProcessFileLoggerSwitch4()
             // Not add a set of parameters and make sure the logger has those parameters
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[2] { "Parameter1", "verbosity=Normal;logfile=" + (NativeMethodsShared.IsWindows ? "c:\\temp\\cat.log" : "/tmp/cat.log") };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1879,7 +1879,7 @@ public void TestProcessFileLoggerSwitch4()
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe(fileLoggerParameters[0] + ";" + fileLoggerParameters[1], StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
 
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             fileLoggerParameters = new string[2] { "Parameter1", "verbosity=Normal;logfile=" + Path.Combine("..", "cat.log") + ";Parameter1" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
@@ -1893,7 +1893,7 @@ public void TestProcessFileLoggerSwitch4()
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($"Parameter1;verbosity=Normal;logFile={Path.Combine(Directory.GetCurrentDirectory(), "..", "cat.log")};Parameter1", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
 
-            loggers = new ArrayList();
+            loggers = new List<ILogger>();
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
             fileLoggerParameters = new string[6] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
             MSBuildApp.ProcessDistributedFileLogger
@@ -1917,7 +1917,7 @@ public void TestProcessFileLoggerSwitch5()
             string[] fileLoggerParameters = null;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1935,7 +1935,7 @@ public void TestProcessFileLoggerSwitch5()
         [Fact]
         public void ProcessConsoleLoggerSwitches()
         {
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
             LoggerVerbosity verbosity = LoggerVerbosity.Normal;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>(); 
             string[] consoleLoggerParameters = new string[6] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
@@ -1962,7 +1962,7 @@ public void ProcessConsoleLoggerSwitches()
                            loggers
                        );
             loggers.Count.ShouldBe(1); // "Expected a central loggers to be attached"
-            ((ILogger)loggers[0]).Parameters.ShouldBe("EnableMPLogging;SHOWPROJECTFILE=TRUE;Parameter1;Parameter;;;parameter;Parameter", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameters passed in"
+            loggers[0].Parameters.ShouldBe("EnableMPLogging;SHOWPROJECTFILE=TRUE;Parameter1;Parameter;;;parameter;Parameter", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameters passed in"
 
             MSBuildApp.ProcessConsoleLoggerSwitch
                        (
@@ -1975,7 +1975,7 @@ public void ProcessConsoleLoggerSwitches()
                       );
             loggers.Count.ShouldBe(1); // "Expected a central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
-            DistributedLoggerRecord distributedLogger = ((DistributedLoggerRecord)distributedLoggerRecords[0]);
+            DistributedLoggerRecord distributedLogger = distributedLoggerRecords[0];
             distributedLogger.CentralLogger.Parameters.ShouldBe("SHOWPROJECTFILE=TRUE;Parameter1;Parameter;;;parameter;Parameter", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameters passed in"
             distributedLogger.ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe("SHOWPROJECTFILE=TRUE;Parameter1;Parameter;;;Parameter;Parameter", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
         }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 68f4c0b82ba..89b5641c4c4 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.ComponentModel;
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -48,7 +47,7 @@ namespace Microsoft.Build.CommandLine
     /// This class implements the MSBuild.exe command-line application. It processes
     /// command-line arguments and invokes the build engine.
     /// </summary>
-    static public class MSBuildApp
+    public static class MSBuildApp
     {
         /// <summary>
         /// Enumeration of the various ways in which the MSBuild.exe application can exit.
@@ -95,7 +94,7 @@ public enum ExitType
         /// <summary>
         /// The object used to synchronize access to shared build state
         /// </summary>
-        private static Object s_buildLock = new Object();
+        private static readonly object s_buildLock = new object();
 
         /// <summary>
         /// Whether a build has started.
@@ -103,19 +102,19 @@ public enum ExitType
         private static bool s_hasBuildStarted;
 
         /// <summary>
-        /// Event signalled when the build is complete.
+        /// Event signaled when the build is complete.
         /// </summary>
-        private static ManualResetEvent s_buildComplete = new ManualResetEvent(false);
+        private static readonly ManualResetEvent s_buildComplete = new ManualResetEvent(false);
 
         /// <summary>
-        /// Event signalled when the cancel method is complete.
+        /// Event signaled when the cancel method is complete.
         /// </summary>
-        private static ManualResetEvent s_cancelComplete = new ManualResetEvent(true);
+        private static readonly ManualResetEvent s_cancelComplete = new ManualResetEvent(true);
 
         /// <summary>
         /// Cancel when handling Ctrl-C
         /// </summary>
-        private static CancellationTokenSource s_buildCancellationSource = new CancellationTokenSource();
+        private static readonly CancellationTokenSource s_buildCancellationSource = new CancellationTokenSource();
 
         private static readonly char[] s_commaSemicolon = { ',', ';' };
 
@@ -212,29 +211,28 @@ string [] args
 #endif
             )
         {
-            using (PerformanceLogEventListener eventListener = PerformanceLogEventListener.Create())
+            using PerformanceLogEventListener eventListener = PerformanceLogEventListener.Create();
+
+            if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
             {
-                if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
-                {
-                    DumpCounters(true /* initialize only */);
-                }
+                DumpCounters(true /* initialize only */);
+            }
 
-                // return 0 on success, non-zero on failure
-                int exitCode = ((s_initialized && Execute(
+            // return 0 on success, non-zero on failure
+            int exitCode = ((s_initialized && Execute(
 #if FEATURE_GET_COMMANDLINE
                 Environment.CommandLine
 #else
                 ConstructArrayArg(args)
 #endif
-                ) == ExitType.Success) ? 0 : 1);
+            ) == ExitType.Success) ? 0 : 1);
 
-                if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
-                {
-                    DumpCounters(false /* log to console */);
-                }
-
-                return exitCode;
+            if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
+            {
+                DumpCounters(false /* log to console */);
             }
+
+            return exitCode;
         }
 
 #if !FEATURE_GET_COMMANDLINE
@@ -260,21 +258,17 @@ private static string[] ConstructArrayArg(string[] args)
         /// <comments>
         /// This is a non-supported feature to facilitate timing multiple runs
         /// </comments>
-        static private void AppendOutputFile(string path, Int64 elapsedTime)
+        private static void AppendOutputFile(string path, long elapsedTime)
         {
             if (!FileSystems.Default.FileExists(path))
             {
-                using (StreamWriter sw = File.CreateText(path))
-                {
-                    sw.WriteLine(elapsedTime);
-                }
+                using StreamWriter sw = File.CreateText(path);
+                sw.WriteLine(elapsedTime);
             }
             else
             {
-                using (StreamWriter sw = File.AppendText(path))
-                {
-                    sw.WriteLine(elapsedTime);
-                }
+                using StreamWriter sw = File.AppendText(path);
+                sw.WriteLine(elapsedTime);
             }
         }
 
@@ -296,7 +290,7 @@ private static void DumpCounters(bool initializeOnly)
 
             if (!initializeOnly)
             {
-                Console.WriteLine("\n{0}{1}{0}", new String('=', 41 - ("Process".Length / 2)), "Process");
+                Console.WriteLine("\n{0}{1}{0}", new string('=', 41 - ("Process".Length / 2)), "Process");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak Working Set", currentProcess.PeakWorkingSet64, "bytes");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak Paged Memory", currentProcess.PeakPagedMemorySize64, "bytes"); // Not very useful one
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak Virtual Memory", currentProcess.PeakVirtualMemorySize64, "bytes"); // Not very useful one
@@ -304,7 +298,7 @@ private static void DumpCounters(bool initializeOnly)
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak User Processor Time", currentProcess.UserProcessorTime.TotalMilliseconds, "ms");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Peak Total Processor Time", currentProcess.TotalProcessorTime.TotalMilliseconds, "ms");
 
-                Console.WriteLine("{0}{0}", new String('=', 41));
+                Console.WriteLine("{0}{0}", new string('=', 41));
             }
 
 #if FEATURE_PERFORMANCE_COUNTERS
@@ -319,20 +313,18 @@ private static void DumpCounters(bool initializeOnly)
             PerformanceCounterCategory processCategory = new PerformanceCounterCategory("Process");
             foreach (string instance in processCategory.GetInstanceNames())
             {
-                using (PerformanceCounter counter = new PerformanceCounter(".NET CLR Memory", "Process ID", instance, true))
+                using PerformanceCounter counter = new PerformanceCounter(".NET CLR Memory", "Process ID", instance, true);
+                try
                 {
-                    try
-                    {
-                        if ((int)counter.RawValue == currentProcess.Id)
-                        {
-                            currentInstance = instance;
-                            break;
-                        }
-                    }
-                    catch (InvalidOperationException) // Instance 'WmiApSrv' does not exist in the specified Category. (??)
+                    if ((int)counter.RawValue == currentProcess.Id)
                     {
+                        currentInstance = instance;
+                        break;
                     }
                 }
+                catch (InvalidOperationException) // Instance 'WmiApSrv' does not exist in the specified Category. (??)
+                {
+                }
             }
 
             foreach (PerformanceCounterCategory category in PerformanceCounterCategory.GetCategories())
@@ -366,7 +358,7 @@ private static void DumpAllInCategory(string currentInstance, PerformanceCounter
 
             if (!initializeOnly)
             {
-                Console.WriteLine("\n{0}{1}{0}", new String('=', 41 - (category.CategoryName.Length / 2)), category.CategoryName);
+                Console.WriteLine("\n{0}{1}{0}", new string('=', 41 - (category.CategoryName.Length / 2)), category.CategoryName);
             }
 
             foreach (PerformanceCounter counter in counters)
@@ -376,7 +368,7 @@ private static void DumpAllInCategory(string currentInstance, PerformanceCounter
 
             if (!initializeOnly)
             {
-                Console.WriteLine("{0}{0}", new String('=', 41));
+                Console.WriteLine("{0}{0}", new string('=', 41));
             }
         }
 
@@ -403,7 +395,7 @@ private static void DumpCounter(PerformanceCounter counter, bool initializeOnly)
                     // Show decimal places if meaningful
                     string valueFormat = value < 10 ? "{0,20:N2}" : "{0,20:N0}";
 
-                    string valueString = String.Format(CultureInfo.CurrentCulture, valueFormat, value);
+                    string valueString = string.Format(CultureInfo.CurrentCulture, valueFormat, value);
 
                     Console.WriteLine("||{0,50}|{1}|{2,8}|", counter.CounterName, valueString, friendlyCounterType);
                 }
@@ -576,9 +568,7 @@ string [] commandLine
                 string[] inputResultsCaches = null;
                 string outputResultsCache = null;
 
-                CommandLineSwitches switchesFromAutoResponseFile;
-                CommandLineSwitches switchesNotFromAutoResponseFile;
-                GatherAllSwitches(commandLine, out switchesFromAutoResponseFile, out switchesNotFromAutoResponseFile);
+                GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile);
 
                 if (ProcessCommandLineSwitches(
                         switchesFromAutoResponseFile,
@@ -707,7 +697,7 @@ string [] commandLine
 
                     string timerOutputFilename = Environment.GetEnvironmentVariable("MSBUILDTIMEROUTPUTS");
 
-                    if (!String.IsNullOrEmpty(timerOutputFilename))
+                    if (!string.IsNullOrEmpty(timerOutputFilename))
                     {
                         AppendOutputFile(timerOutputFilename, (long)elapsedTime.TotalMilliseconds);
                     }
@@ -781,7 +771,7 @@ string [] commandLine
                 if (!e.InitializationException)
                 {
                     // display the localized message from the outer exception in canonical format
-                    Console.WriteLine("MSBUILD : error " + e.ErrorCode + ": " + e.Message);
+                    Console.WriteLine($"MSBUILD : error {e.ErrorCode}: {e.Message}");
 #if DEBUG
                     Console.WriteLine("This is an unhandled exception from a logger -- PLEASE OPEN A BUG AGAINST THE LOGGER OWNER.");
 #endif
@@ -793,15 +783,15 @@ string [] commandLine
                 }
                 else
                 {
-                    Console.WriteLine("MSBUILD : error " + e.ErrorCode + ": " + e.Message +
-                        (e.InnerException != null ? " " + e.InnerException.Message : ""));
+                    Console.WriteLine(
+                        $"MSBUILD : error {e.ErrorCode}: {e.Message}{(e.InnerException != null ? $" {e.InnerException.Message}" : "")}");
                     exitType = ExitType.InitializationError;
                 }
             }
             catch (BuildAbortedException e)
             {
-                Console.WriteLine("MSBUILD : error " + e.ErrorCode + ": " + e.Message +
-                                (e.InnerException != null ? " " + e.InnerException.Message : String.Empty));
+                Console.WriteLine(
+                    $"MSBUILD : error {e.ErrorCode}: {e.Message}{(e.InnerException != null ? $" {e.InnerException.Message}" : string.Empty)}");
 
                 exitType = ExitType.Unexpected;
             }
@@ -903,8 +893,7 @@ private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs
             // by calling Microsoft.Win32.SystemEvents.Initialize.
             // So do our work asynchronously so we can return immediately.
             // We're already on a threadpool thread anyway.
-            WaitCallback callback = new WaitCallback(
-            delegate (Object state)
+            WaitCallback callback = delegate
             {
                 s_cancelComplete.Reset();
 
@@ -918,7 +907,7 @@ private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs
                 // If the build has already started (or already finished), we will cancel it
                 // If the build has not yet started, it will cancel itself, because
                 // we set alreadyCalled=1
-                bool hasBuildStarted = false;
+                bool hasBuildStarted;
                 lock (s_buildLock)
                 {
                     hasBuildStarted = s_hasBuildStarted;
@@ -931,7 +920,7 @@ private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs
                 }
 
                 s_cancelComplete.Set(); // This will release our main Execute method so we can finally exit.
-            });
+            };
 
             ThreadPoolExtensions.QueueThreadPoolWorkItemWithCulture(callback, CultureInfo.CurrentCulture, CultureInfo.CurrentUICulture);
         }
@@ -942,7 +931,7 @@ private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs
         /// </summary>
         private static void ResetBuildState()
         {
-            s_includedResponseFiles = new ArrayList();
+            s_includedResponseFiles = new List<string>();
             usingSwitchesFromAutoResponseFile = false;
         }
 
@@ -1068,16 +1057,13 @@ string outputResultsCache
                 {
                     foreach (var logger in distributedLoggerRecords)
                     {
-                        if (logger.CentralLogger != null)
+                        if (logger.CentralLogger?.Parameters != null &&
+                            (logger.CentralLogger.Parameters.IndexOf("V=DIAG", StringComparison.OrdinalIgnoreCase) != -1 ||
+                             logger.CentralLogger.Parameters.IndexOf("VERBOSITY=DIAG", StringComparison.OrdinalIgnoreCase) != -1)
+                        )
                         {
-                            if (logger.CentralLogger.Parameters != null &&
-                                (logger.CentralLogger.Parameters.IndexOf("V=DIAG", StringComparison.OrdinalIgnoreCase) != -1 ||
-                                 logger.CentralLogger.Parameters.IndexOf("VERBOSITY=DIAG", StringComparison.OrdinalIgnoreCase) != -1)
-                               )
-                            {
-                                logTaskInputs = true;
-                                break;
-                            }
+                            logTaskInputs = true;
+                            break;
                         }
                     }
                 }
@@ -1144,7 +1130,7 @@ string outputResultsCache
 
                     // By default we log synchronously to the console for compatibility with previous versions,
                     // but it is slightly slower
-                    if (!String.Equals(Environment.GetEnvironmentVariable("MSBUILDLOGASYNC"), "1", StringComparison.Ordinal))
+                    if (!string.Equals(Environment.GetEnvironmentVariable("MSBUILDLOGASYNC"), "1", StringComparison.Ordinal))
                     {
                         parameters.UseSynchronousLogging = true;
                     }
@@ -1176,13 +1162,13 @@ string outputResultsCache
                         parameters.ProjectLoadSettings |= ProjectLoadSettings.ProfileEvaluation;
                     }
 
-                    if (!String.IsNullOrEmpty(toolsVersion))
+                    if (!string.IsNullOrEmpty(toolsVersion))
                     {
                         parameters.DefaultToolsVersion = toolsVersion;
                     }
 
                     string memoryUseLimit = Environment.GetEnvironmentVariable("MSBUILDMEMORYUSELIMIT");
-                    if (!String.IsNullOrEmpty(memoryUseLimit))
+                    if (!string.IsNullOrEmpty(memoryUseLimit))
                     {
                         parameters.MemoryUseLimit = Convert.ToInt32(memoryUseLimit, CultureInfo.InvariantCulture);
 
@@ -1214,7 +1200,7 @@ string outputResultsCache
                         try
                         {
                             // Determine if the user specified /Target:Restore which means we should only execute a restore in the fancy way that /restore is executed
-                            bool restoreOnly = targets.Length == 1 && String.Equals(targets[0], MSBuildConstants.RestoreTargetName, StringComparison.OrdinalIgnoreCase);
+                            bool restoreOnly = targets.Length == 1 && string.Equals(targets[0], MSBuildConstants.RestoreTargetName, StringComparison.OrdinalIgnoreCase);
 
                             // ExecuteRestore below changes the current working directory and does not change back. Therefore, if we try to create the request after
                             // the restore call we end up with incorrectly normalized paths to the project. To avoid that, we are preparing the request before the first
@@ -1616,11 +1602,11 @@ private static void GatherAllSwitches(
         {
 #if FEATURE_GET_COMMANDLINE
             // split the command line on (unquoted) whitespace
-            ArrayList commandLineArgs = QuotingUtilities.SplitUnquoted(commandLine);
+            var commandLineArgs = QuotingUtilities.SplitUnquoted(commandLine);
 
-            s_exeName = FileUtilities.FixFilePath(QuotingUtilities.Unquote((string)commandLineArgs[0]));
+            s_exeName = FileUtilities.FixFilePath(QuotingUtilities.Unquote(commandLineArgs[0]));
 #else
-            ArrayList commandLineArgs = new ArrayList(commandLine);
+            var commandLineArgs = new List<string>(commandLine);
 
             s_exeName = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
 #endif
@@ -1658,12 +1644,11 @@ private static void GatherAllSwitches(
         /// <remarks>
         /// Internal for unit testing only.
         /// </remarks>
-        internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, CommandLineSwitches commandLineSwitches)
+        internal static void GatherCommandLineSwitches(List<string> commandLineArgs, CommandLineSwitches commandLineSwitches)
         {
             foreach (string commandLineArg in commandLineArgs)
             {
-                int doubleQuotesRemovedFromArg;
-                string unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+                string unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out var doubleQuotesRemovedFromArg);
 
                 if (unquotedCommandLineArg.Length > 0)
                 {
@@ -1682,7 +1667,7 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman
                         {
                             switchName = null;
                             // add a (fake) parameter indicator for later parsing
-                            switchParameters = ":" + commandLineArg;
+                            switchParameters = $":{commandLineArg}";
                         }
                         else
                         {
@@ -1698,7 +1683,7 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman
                             if (switchParameterIndicator == -1)
                             {
                                 switchName = unquotedCommandLineArg.Substring(switchIndicatorsLength);
-                                switchParameters = String.Empty;
+                                switchParameters = string.Empty;
                             }
                             else
                             {
@@ -1707,47 +1692,38 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman
                             }
                         }
 
-                        CommandLineSwitches.ParameterlessSwitch parameterlessSwitch;
-                        CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
-                        string duplicateSwitchErrorMessage;
-                        bool multipleParametersAllowed;
-                        string missingParametersErrorMessage;
-                        bool unquoteParameters;
-                        bool allowEmptyParameters;
-
                         // Special case: for the switches "/m" (or "/maxCpuCount") and "/bl" (or "/binarylogger") we wish to pretend we saw a default argument
                         // This allows a subsequent /m:n on the command line to override it.
                         // We could create a new kind of switch with optional parameters, but it's a great deal of churn for this single case. 
                         // Note that if no "/m" or "/maxCpuCount" switch -- either with or without parameters -- is present, then we still default to 1 cpu
                         // for backwards compatibility.
-                        if (String.IsNullOrEmpty(switchParameters))
+                        if (string.IsNullOrEmpty(switchParameters))
                         {
-                            if (String.Equals(switchName, "m", StringComparison.OrdinalIgnoreCase) ||
-                                String.Equals(switchName, "maxcpucount", StringComparison.OrdinalIgnoreCase))
+                            if (string.Equals(switchName, "m", StringComparison.OrdinalIgnoreCase) ||
+                                string.Equals(switchName, "maxcpucount", StringComparison.OrdinalIgnoreCase))
                             {
                                 int numberOfCpus = NativeMethodsShared.GetLogicalCoreCount();
-
-                                switchParameters = ":" + numberOfCpus;
+                                switchParameters = $":{numberOfCpus}";
                             }
-                            else if (String.Equals(switchName, "bl", StringComparison.OrdinalIgnoreCase) ||
-                                String.Equals(switchName, "binarylogger", StringComparison.OrdinalIgnoreCase))
+                            else if (string.Equals(switchName, "bl", StringComparison.OrdinalIgnoreCase) ||
+                                string.Equals(switchName, "binarylogger", StringComparison.OrdinalIgnoreCase))
                             {
                                 // we have to specify at least one parameter otherwise it's impossible to distinguish the situation
                                 // where /bl is not specified at all vs. where /bl is specified without the file name.
                                 switchParameters = ":msbuild.binlog";
                             }
-                            else if (String.Equals(switchName, "prof", StringComparison.OrdinalIgnoreCase) ||
-                                     String.Equals(switchName, "profileevaluation", StringComparison.OrdinalIgnoreCase))
+                            else if (string.Equals(switchName, "prof", StringComparison.OrdinalIgnoreCase) ||
+                                     string.Equals(switchName, "profileevaluation", StringComparison.OrdinalIgnoreCase))
                             {
                                 switchParameters = ":no-file";
                             }
                         }
 
-                        if (CommandLineSwitches.IsParameterlessSwitch(switchName, out parameterlessSwitch, out duplicateSwitchErrorMessage))
+                        if (CommandLineSwitches.IsParameterlessSwitch(switchName, out var parameterlessSwitch, out var duplicateSwitchErrorMessage))
                         {
                             GatherParameterlessCommandLineSwitch(commandLineSwitches, parameterlessSwitch, switchParameters, duplicateSwitchErrorMessage, unquotedCommandLineArg);
                         }
-                        else if (CommandLineSwitches.IsParameterizedSwitch(switchName, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out allowEmptyParameters))
+                        else if (CommandLineSwitches.IsParameterizedSwitch(switchName, out var parameterizedSwitch, out duplicateSwitchErrorMessage, out var multipleParametersAllowed, out var missingParametersErrorMessage, out var unquoteParameters, out var allowEmptyParameters))
                         {
                             GatherParameterizedCommandLineSwitch(commandLineSwitches, parameterizedSwitch, switchParameters, duplicateSwitchErrorMessage, multipleParametersAllowed, missingParametersErrorMessage, unquoteParameters, unquotedCommandLineArg, allowEmptyParameters);
                         }
@@ -1788,8 +1764,7 @@ int switchParameterIndicator
             int quotedSwitchParameterIndicator = commandLineArg.IndexOf(':');
 
             // check if there is any quoting in the name portion of the switch
-            int doubleQuotesRemovedFromSwitchIndicatorAndName;
-            string unquotedSwitchIndicatorAndName = QuotingUtilities.Unquote(commandLineArg.Substring(0, quotedSwitchParameterIndicator), out doubleQuotesRemovedFromSwitchIndicatorAndName);
+            string unquotedSwitchIndicatorAndName = QuotingUtilities.Unquote(commandLineArg.Substring(0, quotedSwitchParameterIndicator), out var doubleQuotesRemovedFromSwitchIndicatorAndName);
 
             ErrorUtilities.VerifyThrow(switchName == unquotedSwitchIndicatorAndName.Substring(1),
                 "The switch name extracted from either the partially or completely unquoted arg should be the same.");
@@ -1819,7 +1794,7 @@ int switchParameterIndicator
                 {
                     // otherwise, use the quoted parameters, after compensating for the quoting that was started in the name
                     // portion of the switch
-                    switchParameters = ":\"" + commandLineArg.Substring(quotedSwitchParameterIndicator + 1);
+                    switchParameters = $":\"{commandLineArg.Substring(quotedSwitchParameterIndicator + 1)}";
                 }
             }
 
@@ -1832,7 +1807,7 @@ int switchParameterIndicator
         /// Used to keep track of response files to prevent them from
         /// being included multiple times (or even recursively).
         /// </summary>
-        private static ArrayList s_includedResponseFiles;
+        private static List<string> s_includedResponseFiles;
 
         /// <summary>
         /// Called when a response file switch is detected on the command line. It loads the specified response file, and parses
@@ -1864,7 +1839,7 @@ private static void GatherResponseFileSwitch(string unquotedCommandLineArg, Comm
 
                     foreach (string includedResponseFile in s_includedResponseFiles)
                     {
-                        if (String.Equals(responseFile, includedResponseFile, StringComparison.OrdinalIgnoreCase))
+                        if (string.Equals(responseFile, includedResponseFile, StringComparison.OrdinalIgnoreCase))
                         {
                             commandLineSwitches.SetParameterError("RepeatedResponseFileError", unquotedCommandLineArg);
                             isRepeatedResponseFile = true;
@@ -1877,7 +1852,7 @@ private static void GatherResponseFileSwitch(string unquotedCommandLineArg, Comm
                         var responseFileDirectory = FileUtilities.EnsureTrailingSlash(Path.GetDirectoryName(responseFile));
                         s_includedResponseFiles.Add(responseFile);
 
-                        ArrayList argsFromResponseFile;
+                        List<string> argsFromResponseFile;
 
 #if FEATURE_ENCODING_DEFAULT
                         using (StreamReader responseFileContents = new StreamReader(responseFile, Encoding.Default)) // HIGHCHAR: If response files have no byte-order marks, then assume ANSI rather than ASCII.
@@ -1885,7 +1860,7 @@ private static void GatherResponseFileSwitch(string unquotedCommandLineArg, Comm
                         using (StreamReader responseFileContents = FileUtilities.OpenRead(responseFile)) // HIGHCHAR: If response files have no byte-order marks, then assume ANSI rather than ASCII.
 #endif
                         {
-                            argsFromResponseFile = new ArrayList();
+                            argsFromResponseFile = new List<string>();
 
                             while (responseFileContents.Peek() != -1)
                             {
@@ -2064,7 +2039,7 @@ private static bool GatherAutoResponseFileSwitchesFromFullPath(string autoRespon
             if (FileSystems.Default.FileExists(autoResponseFile))
             {
                 found = true;
-                GatherResponseFileSwitch("@" + autoResponseFile, switchesFromAutoResponseFile);
+                GatherResponseFileSwitch($"@{autoResponseFile}", switchesFromAutoResponseFile);
 
                 // if the "/noautoresponse" switch was set in the auto-response file, flag an error
                 if (switchesFromAutoResponseFile[CommandLineSwitches.ParameterlessSwitch.NoAutoResponse])
@@ -2193,10 +2168,10 @@ bool recursing
                         // gather any switches from the first Directory.Build.rsp found in the project directory or above
                         string directoryResponseFile = FileUtilities.GetPathOfFileAbove(directoryResponseFileName, projectDirectory);
 
-                        bool found = !String.IsNullOrWhiteSpace(directoryResponseFile) && GatherAutoResponseFileSwitchesFromFullPath(directoryResponseFile, switchesFromAutoResponseFile);
+                        bool found = !string.IsNullOrWhiteSpace(directoryResponseFile) && GatherAutoResponseFileSwitchesFromFullPath(directoryResponseFile, switchesFromAutoResponseFile);
 
                         // Don't look for more response files if it's only in the same place we already looked (next to the exe)
-                        if (!String.Equals(projectDirectory, s_exePath, StringComparison.OrdinalIgnoreCase))
+                        if (!string.Equals(projectDirectory, s_exePath, StringComparison.OrdinalIgnoreCase))
                         {
                             // this combines any found, with higher precedence, with the switches from the original auto response file switches
                             found |= GatherAutoResponseFileSwitches(projectDirectory, switchesFromAutoResponseFile);
@@ -2260,7 +2235,7 @@ bool recursing
                     // figure out if there was a max cpu count provided
                     cpuCount = ProcessMaxCPUCountSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.MaxCPUCount]);
 
-                    // figure out if we shold reuse nodes
+                    // figure out if we should reuse nodes
                     // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False
                     enableNodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);
 
@@ -2348,7 +2323,7 @@ out enableProfiler
                     if (verbosity == LoggerVerbosity.Diagnostic)
                     {
                         string equivalentCommandLine = commandLineSwitches.GetEquivalentCommandLineExceptProjectFile();
-                        Console.WriteLine(Path.Combine(s_exePath, s_exeName) + " " + equivalentCommandLine + " " + projectFile);
+                        Console.WriteLine($"{Path.Combine(s_exePath, s_exeName)} {equivalentCommandLine} {projectFile}");
                     }
 
 #if FEATURE_XML_SCHEMA_VALIDATION
@@ -2360,7 +2335,7 @@ out enableProfiler
                 }
             }
 
-            ErrorUtilities.VerifyThrow(!invokeBuild || !String.IsNullOrEmpty(projectFile), "We should have a project file if we're going to build.");
+            ErrorUtilities.VerifyThrow(!invokeBuild || !string.IsNullOrEmpty(projectFile), "We should have a project file if we're going to build.");
 
             return invokeBuild;
         }
@@ -2487,7 +2462,7 @@ internal static ISet<string> ProcessWarnAsErrorSwitch(CommandLineSwitches comman
                     // so that all warnings are treated errors
                     warningsAsErrors.Clear();
                 }
-                else if (!String.IsNullOrWhiteSpace(code))
+                else if (!string.IsNullOrWhiteSpace(code))
                 {
                     warningsAsErrors.Add(code.Trim());
                 }
@@ -2509,7 +2484,7 @@ internal static ISet<string> ProcessWarnAsMessageSwitch(CommandLineSwitches comm
 
             foreach (string code in parameters
                 .SelectMany(parameter => parameter?.Split(s_commaSemicolon, StringSplitOptions.RemoveEmptyEntries))
-                .Where(i => !String.IsNullOrWhiteSpace(i))
+                .Where(i => !string.IsNullOrWhiteSpace(i))
                 .Select(i => i.Trim()))
             {
                 warningsAsMessages.Add(code);
@@ -2549,7 +2524,7 @@ internal static bool ProcessBooleanSwitch(string[] parameters, bool defaultValue
         /// and also returns the created logger. Otherwise, the collection of loggers is not affected and null
         /// is returned
         /// </remarks>
-        internal static ProfilerLogger ProcessProfileEvaluationSwitch(string[] parameters, ArrayList loggers, out bool enableProfiler)
+        internal static ProfilerLogger ProcessProfileEvaluationSwitch(string[] parameters, List<ILogger> loggers, out bool enableProfiler)
         {
             if (parameters == null || parameters.Length == 0)
             {
@@ -2637,7 +2612,7 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
                         // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False
                         bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);
                         string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];
-                        bool lowpriority = lowPriorityInput.Length > 0 ? lowPriorityInput[0].Equals("true") : false;
+                        bool lowpriority = lowPriorityInput.Length > 0 && lowPriorityInput[0].Equals("true");
 
                         shutdownReason = node.Run(nodeReuse, lowpriority, out nodeException);
 
@@ -2806,7 +2781,7 @@ DirectoryGetFiles getFiles
                     string solutionName = Path.GetFileNameWithoutExtension(actualSolutionFiles[0]);
                     string projectName = Path.GetFileNameWithoutExtension(actualProjectFiles[0]);
                     // Compare the names and error if they are not identical
-                    InitializationException.VerifyThrow(String.Equals(solutionName, projectName, StringComparison.OrdinalIgnoreCase), projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
+                    InitializationException.VerifyThrow(string.Equals(solutionName, projectName, StringComparison.OrdinalIgnoreCase), projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
                     projectFile = actualSolutionFiles[0];
                 }
                 // If there is more than one solution file in the current directory we have no idea which one to use
@@ -2827,17 +2802,17 @@ DirectoryGetFiles getFiles
                         string secondPotentialProjectExtension = Path.GetExtension(actualProjectFiles[1]);
 
                         // If the two projects have the same extension we can't decide which one to pick
-                        if (!String.Equals(firstPotentialProjectExtension, secondPotentialProjectExtension, StringComparison.OrdinalIgnoreCase))
+                        if (!string.Equals(firstPotentialProjectExtension, secondPotentialProjectExtension, StringComparison.OrdinalIgnoreCase))
                         {
                             // Check to see if the first project is the proj, if it is use it
-                            if (String.Equals(firstPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
+                            if (string.Equals(firstPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
                             {
                                 projectFile = actualProjectFiles[0];
                                 // We have made a decision
                                 isAmbiguousProject = false;
                             }
                             // If the first project is not the proj check to see if the second one is the proj, if so use it
-                            else if (String.Equals(secondPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
+                            else if (string.Equals(secondPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
                             {
                                 projectFile = actualProjectFiles[1];
                                 // We have made a decision
@@ -2879,9 +2854,9 @@ private static void ValidateExtensions(string[] projectExtensionsToIgnore)
                     InitializationException.VerifyThrow(extension.IndexOfAny(Path.GetInvalidPathChars()) == -1, "InvalidExtensionToIgnore", extension, null, false);
 
                     // There were characters before the extension.
-                    InitializationException.VerifyThrow(String.Equals(extension, Path.GetExtension(extension), StringComparison.OrdinalIgnoreCase), "InvalidExtensionToIgnore", extension, null, false);
+                    InitializationException.VerifyThrow(string.Equals(extension, Path.GetExtension(extension), StringComparison.OrdinalIgnoreCase), "InvalidExtensionToIgnore", extension, null, false);
 
-                    // Make sure that no wild cards are in the string because for now we dont allow wild card extensions.
+                    // Make sure that no wild cards are in the string because for now we don't allow wild card extensions.
                     InitializationException.VerifyThrow(extension.IndexOfAny(s_wildcards) == -1, "InvalidExtensionToIgnore", extension, null, false);
                 }
             }
@@ -3028,7 +3003,7 @@ out bool enableProfiler
                 verbosity = ProcessVerbositySwitch(verbositySwitchParameters[verbositySwitchParameters.Length - 1]);
             }
 
-            ArrayList loggers = ProcessLoggerSwitch(loggerSwitchParameters, verbosity);
+            var loggers = ProcessLoggerSwitch(loggerSwitchParameters, verbosity);
 
             // Add any loggers which have been specified on the commandline
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
@@ -3048,7 +3023,7 @@ out bool enableProfiler
                 detailedSummary = true;
             }
 
-            return (ILogger[])loggers.ToArray(typeof(ILogger));
+            return loggers.ToArray();
         }
 
         /// <summary>
@@ -3066,10 +3041,10 @@ internal static string AggregateParameters(string anyPrefixingParameter, string[
                 parametersToAggregate[i] = parametersToAggregate[i].Trim(MSBuildConstants.SemicolonChar);
             }
 
-            // Join the logger parameters into one string seperated by semicolons
-            string result = anyPrefixingParameter ?? String.Empty;
+            // Join the logger parameters into one string separated by semicolons
+            string result = anyPrefixingParameter ?? string.Empty;
 
-            result += String.Join(";", parametersToAggregate);
+            result += string.Join(";", parametersToAggregate);
 
             return result;
         }
@@ -3078,7 +3053,7 @@ internal static string AggregateParameters(string anyPrefixingParameter, string[
         /// Add a file logger with the appropriate parameters to the loggers list for each
         /// non-empty set of file logger parameters provided.
         /// </summary>
-        private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, List<DistributedLoggerRecord> distributedLoggerRecords, LoggerVerbosity verbosity, int cpuCount, ArrayList loggers)
+        private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, List<DistributedLoggerRecord> distributedLoggerRecords, LoggerVerbosity verbosity, int cpuCount, List<ILogger> loggers)
         {
             for (int i = 0; i < groupedFileLoggerParameters.Length; i++)
             {
@@ -3094,12 +3069,12 @@ private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, L
                 }
                 else
                 {
-                    fileParameters += "logfile=msbuild" + i + ".log;";
+                    fileParameters += $"logfile=msbuild{i}.log;";
                 }
 
                 if (groupedFileLoggerParameters[i].Length > 0)
                 {
-                    // Join the file logger parameters into one string seperated by semicolons
+                    // Join the file logger parameters into one string separated by semicolons
                     fileParameters = AggregateParameters(fileParameters, groupedFileLoggerParameters[i]);
                 }
 
@@ -3113,7 +3088,7 @@ private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, L
                     // We've decided to use the MP logger even in single proc mode.
                     // Switch it on here, rather than in the logger, so that other hosts that use
                     // the existing ConsoleLogger don't see the behavior change in single proc.
-                    fileLogger.Parameters = "ENABLEMPLOGGING;" + fileParameters;
+                    fileLogger.Parameters = $"ENABLEMPLOGGING;{fileParameters}";
                     loggers.Add(fileLogger);
                 }
                 else
@@ -3128,7 +3103,7 @@ private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, L
             }
         }
 
-        private static void ProcessBinaryLogger(string[] binaryLoggerParameters, ArrayList loggers, ref LoggerVerbosity verbosity)
+        private static void ProcessBinaryLogger(string[] binaryLoggerParameters, List<ILogger> loggers, ref LoggerVerbosity verbosity)
         {
             if (binaryLoggerParameters == null || binaryLoggerParameters.Length == 0)
             {
@@ -3137,8 +3112,7 @@ private static void ProcessBinaryLogger(string[] binaryLoggerParameters, ArrayLi
 
             string arguments = binaryLoggerParameters[binaryLoggerParameters.Length - 1];
 
-            BinaryLogger logger = new BinaryLogger();
-            logger.Parameters = arguments;
+            BinaryLogger logger = new BinaryLogger {Parameters = arguments};
 
             // If we have a binary logger, force verbosity to diagnostic.
             // The only place where verbosity is used downstream is to determine whether to log task inputs.
@@ -3158,7 +3132,7 @@ internal static void ProcessConsoleLoggerSwitch
             List<DistributedLoggerRecord> distributedLoggerRecords,
             LoggerVerbosity verbosity,
             int cpuCount,
-            ArrayList loggers
+            List<ILogger> loggers
         )
         {
             // the console logger is always active, unless specifically disabled
@@ -3178,7 +3152,7 @@ ArrayList loggers
                     // We've decided to use the MP logger even in single proc mode.
                     // Switch it on here, rather than in the logger, so that other hosts that use
                     // the existing ConsoleLogger don't see the behavior change in single proc.
-                    logger.Parameters = "ENABLEMPLOGGING;" + consoleParameters;
+                    logger.Parameters = $"ENABLEMPLOGGING;{consoleParameters}";
                     loggers.Add(logger);
                 }
                 else
@@ -3205,7 +3179,7 @@ private static DistributedLoggerRecord CreateForwardingLoggerRecord(ILogger logg
             string verbosityValue = ExtractAnyParameterValue(verbosityParameter);
 
             LoggerVerbosity effectiveVerbosity = defaultVerbosity;
-            if (!String.IsNullOrEmpty(verbosityValue))
+            if (!string.IsNullOrEmpty(verbosityValue))
             {
                 effectiveVerbosity = ProcessVerbositySwitch(verbosityValue);
             }
@@ -3228,7 +3202,7 @@ internal static void ProcessDistributedFileLogger
             bool distributedFileLogger,
             string[] fileLoggerParameters,
             List<DistributedLoggerRecord> distributedLoggerRecords,
-            ArrayList loggers,
+            List<ILogger> loggers,
             int cpuCount
         )
         {
@@ -3237,7 +3211,7 @@ int cpuCount
                 string fileParameters = string.Empty;
                 if ((fileLoggerParameters?.Length > 0))
                 {
-                    // Join the file logger parameters into one string seperated by semicolons
+                    // Join the file logger parameters into one string separated by semicolons
                     fileParameters = AggregateParameters(null, fileLoggerParameters);
                 }
 
@@ -3250,9 +3224,10 @@ int cpuCount
                 {
                     // If the path is not an absolute path set the path to the current directory of the exe combined with the relative path
                     // If the string is empty then send it through as the distributed file logger WILL deal with EMPTY logfile paths
-                    if (!String.IsNullOrEmpty(logFileName) && !Path.IsPathRooted(logFileName))
+                    if (!string.IsNullOrEmpty(logFileName) && !Path.IsPathRooted(logFileName))
                     {
-                        fileParameters = fileParameters.Replace(logFileParameter, "logFile=" + Path.Combine(Directory.GetCurrentDirectory(), logFileName));
+                        fileParameters = fileParameters.Replace(logFileParameter,
+                            $"logFile={Path.Combine(Directory.GetCurrentDirectory(), logFileName)}");
                     }
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
@@ -3260,16 +3235,16 @@ int cpuCount
                     throw new LoggerException(e.Message, e);
                 }
 
-                if (String.IsNullOrEmpty(logFileName))
+                if (string.IsNullOrEmpty(logFileName))
                 {
-                    // If the string is not empty and it does not end in a ;, we need to add a ; to seperate what is in the parameter from the logfile
+                    // If the string is not empty and it does not end in a ;, we need to add a ; to separate what is in the parameter from the logfile
                     // if the string is empty, no ; is needed because logfile is the only parameter which will be passed in
-                    if (!String.IsNullOrEmpty(fileParameters) && !fileParameters.EndsWith(";", StringComparison.OrdinalIgnoreCase))
+                    if (!string.IsNullOrEmpty(fileParameters) && !fileParameters.EndsWith(";", StringComparison.OrdinalIgnoreCase))
                     {
                         fileParameters += ";";
                     }
 
-                    fileParameters += "logFile=" + Path.Combine(Directory.GetCurrentDirectory(), msbuildLogFileName);
+                    fileParameters += $"logFile={Path.Combine(Directory.GetCurrentDirectory(), msbuildLogFileName)}";
                 }
 
                 //Gets the currently loaded assembly in which the specified class is defined
@@ -3297,8 +3272,8 @@ internal static string ExtractAnyLoggerParameter(string parameters, params strin
             {
                 foreach (string name in parameterNames)
                 {
-                    bool found = nameValue.StartsWith(name + "=", StringComparison.OrdinalIgnoreCase) ||   // Parameters with value, such as "logfile=foo.txt"
-                                 String.Equals(name, nameValue, StringComparison.OrdinalIgnoreCase);       // Parameters without value, such as "append"
+                    bool found = nameValue.StartsWith($"{name}=", StringComparison.OrdinalIgnoreCase) ||   // Parameters with value, such as "logfile=foo.txt"
+                                 string.Equals(name, nameValue, StringComparison.OrdinalIgnoreCase);       // Parameters without value, such as "append"
 
                     if (found)
                     {
@@ -3318,7 +3293,7 @@ private static string ExtractAnyParameterValue(string parameter)
         {
             string value = null;
 
-            if (!String.IsNullOrEmpty(parameter))
+            if (!string.IsNullOrEmpty(parameter))
             {
                 string[] nameValuePair = parameter.Split(MSBuildConstants.EqualsChar);
 
@@ -3340,28 +3315,28 @@ internal static LoggerVerbosity ProcessVerbositySwitch(string value)
         {
             LoggerVerbosity verbosity = LoggerVerbosity.Normal;
 
-            if (String.Equals(value, "q", StringComparison.OrdinalIgnoreCase) ||
-                String.Equals(value, "quiet", StringComparison.OrdinalIgnoreCase))
+            if (string.Equals(value, "q", StringComparison.OrdinalIgnoreCase) ||
+                string.Equals(value, "quiet", StringComparison.OrdinalIgnoreCase))
             {
                 verbosity = LoggerVerbosity.Quiet;
             }
-            else if (String.Equals(value, "m", StringComparison.OrdinalIgnoreCase) ||
-                     String.Equals(value, "minimal", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(value, "m", StringComparison.OrdinalIgnoreCase) ||
+                     string.Equals(value, "minimal", StringComparison.OrdinalIgnoreCase))
             {
                 verbosity = LoggerVerbosity.Minimal;
             }
-            else if (String.Equals(value, "n", StringComparison.OrdinalIgnoreCase) ||
-                     String.Equals(value, "normal", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(value, "n", StringComparison.OrdinalIgnoreCase) ||
+                     string.Equals(value, "normal", StringComparison.OrdinalIgnoreCase))
             {
                 verbosity = LoggerVerbosity.Normal;
             }
-            else if (String.Equals(value, "d", StringComparison.OrdinalIgnoreCase) ||
-                     String.Equals(value, "detailed", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(value, "d", StringComparison.OrdinalIgnoreCase) ||
+                     string.Equals(value, "detailed", StringComparison.OrdinalIgnoreCase))
             {
                 verbosity = LoggerVerbosity.Detailed;
             }
-            else if (String.Equals(value, "diag", StringComparison.OrdinalIgnoreCase) ||
-                     String.Equals(value, "diagnostic", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(value, "diag", StringComparison.OrdinalIgnoreCase) ||
+                     string.Equals(value, "diagnostic", StringComparison.OrdinalIgnoreCase))
             {
                 verbosity = LoggerVerbosity.Diagnostic;
             }
@@ -3377,9 +3352,9 @@ internal static LoggerVerbosity ProcessVerbositySwitch(string value)
         /// Figures out which additional loggers are going to listen to build events.
         /// </summary>
         /// <returns>List of loggers.</returns>
-        private static ArrayList ProcessLoggerSwitch(string[] parameters, LoggerVerbosity verbosity)
+        private static List<ILogger> ProcessLoggerSwitch(string[] parameters, LoggerVerbosity verbosity)
         {
-            ArrayList loggers = new ArrayList();
+            var loggers = new List<ILogger>();
 
             foreach (string parameter in parameters)
             {
@@ -3407,15 +3382,14 @@ private static List<DistributedLoggerRecord> ProcessDistributedLoggerSwitch(stri
             foreach (string parameter in parameters)
             {
                 // split each <central logger>|<node logger> string into two pieces, breaking on the first | that is found
-                int emptySplits; // ignored
-                ArrayList loggerSpec = QuotingUtilities.SplitUnquoted(parameter, 2, true /* keep empty splits */, false /* keep quotes */, out emptySplits, '*');
+                var loggerSpec = QuotingUtilities.SplitUnquoted(parameter, 2, true /* keep empty splits */, false /* keep quotes */, out _, '*');
 
                 ErrorUtilities.VerifyThrow((loggerSpec.Count >= 1) && (loggerSpec.Count <= 2),
                     "SplitUnquoted() must return at least one string, and no more than two.");
 
-                string unquotedParameter = QuotingUtilities.Unquote((string)loggerSpec[0]);
+                string unquotedParameter = QuotingUtilities.Unquote(loggerSpec[0]);
                 LoggerDescription centralLoggerDescription =
-                    ParseLoggingParameter((string)loggerSpec[0], unquotedParameter, verbosity);
+                    ParseLoggingParameter(loggerSpec[0], unquotedParameter, verbosity);
 
                 if (!CreateAndConfigureLogger(centralLoggerDescription, verbosity, unquotedParameter, out ILogger centralLogger))
                 {
@@ -3427,8 +3401,8 @@ private static List<DistributedLoggerRecord> ProcessDistributedLoggerSwitch(stri
 
                 if (loggerSpec.Count > 1)
                 {
-                    unquotedParameter = QuotingUtilities.Unquote((string)loggerSpec[1]);
-                    forwardingLoggerDescription = ParseLoggingParameter((string)loggerSpec[1], unquotedParameter, verbosity);
+                    unquotedParameter = QuotingUtilities.Unquote(loggerSpec[1]);
+                    forwardingLoggerDescription = ParseLoggingParameter(loggerSpec[1], unquotedParameter, verbosity);
                 }
 
                 DistributedLoggerRecord distributedLoggerRecord =
@@ -3449,31 +3423,28 @@ private static List<DistributedLoggerRecord> ProcessDistributedLoggerSwitch(stri
         /// <returns></returns>
         private static LoggerDescription ParseLoggingParameter(string parameter, string unquotedParameter, LoggerVerbosity verbosity)
         {
-            ArrayList loggerSpec;
             string loggerClassName;
-            string loggerAssemblyName;
-            string loggerAssemblyFile;
             string loggerParameters = null;
             bool isOptional = false;
 
             // split each <logger type>;<logger parameters> string into two pieces, breaking on the first ; that is found
-            loggerSpec = QuotingUtilities.SplitUnquoted(parameter, 2, true /* keep empty splits */, false /* keep quotes */, out _, ';');
+            var loggerSpec = QuotingUtilities.SplitUnquoted(parameter, 2, true /* keep empty splits */, false /* keep quotes */, out _, ';');
 
             ErrorUtilities.VerifyThrow((loggerSpec.Count >= 1) && (loggerSpec.Count <= 2),
                 "SplitUnquoted() must return at least one string, and no more than two.");
 
             // check that the logger is specified
-            CommandLineSwitchException.VerifyThrow(((string)loggerSpec[0]).Length > 0,
+            CommandLineSwitchException.VerifyThrow(loggerSpec[0].Length > 0,
                 "InvalidLoggerError", unquotedParameter);
 
             // extract logger parameters if present
             if (loggerSpec.Count == 2)
             {
-                loggerParameters = QuotingUtilities.Unquote((string)loggerSpec[1]);
+                loggerParameters = QuotingUtilities.Unquote(loggerSpec[1]);
             }
 
             // split each <logger class>,<logger assembly>[,<option1>][,option2] parameters string into pieces
-            ArrayList loggerTypeSpec = QuotingUtilities.SplitUnquoted((string)loggerSpec[0], int.MaxValue, true /* keep empty splits */, false /* keep quotes */, out _, ',');
+            var loggerTypeSpec = QuotingUtilities.SplitUnquoted(loggerSpec[0], int.MaxValue, true /* keep empty splits */, false /* keep quotes */, out _, ',');
 
             ErrorUtilities.VerifyThrow(loggerTypeSpec.Count >= 1, "SplitUnquoted() must return at least one string");
 
@@ -3482,13 +3453,13 @@ private static LoggerDescription ParseLoggingParameter(string parameter, string
             // if the logger class and assembly are both specified
             if (loggerTypeSpec.Count >= 2)
             {
-                loggerClassName = QuotingUtilities.Unquote((string)loggerTypeSpec[0]);
-                loggerAssemblySpec = QuotingUtilities.Unquote((string)loggerTypeSpec[1]);
+                loggerClassName = QuotingUtilities.Unquote(loggerTypeSpec[0]);
+                loggerAssemblySpec = QuotingUtilities.Unquote(loggerTypeSpec[1]);
             }
             else
             {
-                loggerClassName = String.Empty;
-                loggerAssemblySpec = QuotingUtilities.Unquote((string)loggerTypeSpec[0]);
+                loggerClassName = string.Empty;
+                loggerAssemblySpec = QuotingUtilities.Unquote(loggerTypeSpec[0]);
             }
 
             // Loop through the remaining items as options
@@ -3503,13 +3474,13 @@ private static LoggerDescription ParseLoggingParameter(string parameter, string
             CommandLineSwitchException.VerifyThrow(loggerAssemblySpec.Length > 0,
                 "InvalidLoggerError", unquotedParameter);
 
-            loggerAssemblyName = null;
-            loggerAssemblyFile = null;
+            string loggerAssemblyName = null;
+            string loggerAssemblyFile = null;
 
             // DDB Bug msbuild.exe -Logger:FileLogger,Microsoft.Build.Engine fails due to moved engine file.
             // Only add strong naming if the assembly is a non-strong named 'Microsoft.Build.Engine' (i.e, no additional characteristics)
             // Concat full Strong Assembly to match v4.0
-            if (String.Equals(loggerAssemblySpec, "Microsoft.Build.Engine", StringComparison.OrdinalIgnoreCase))
+            if (string.Equals(loggerAssemblySpec, "Microsoft.Build.Engine", StringComparison.OrdinalIgnoreCase))
             {
                 loggerAssemblySpec = "Microsoft.Build.Engine,Version=4.0.0.0,Culture=neutral,PublicKeyToken=b03f5f7f11d50a3a";
             }
@@ -3619,9 +3590,9 @@ private static void ReplayBinaryLog
                 {
                     nodeLogger.Initialize(replayEventSource, cpuCount);
                 }
-                else if (centralLogger != null)
+                else
                 {
-                    centralLogger.Initialize(replayEventSource);
+                    centralLogger?.Initialize(replayEventSource);
                 }
             }
 
@@ -3685,10 +3656,10 @@ private static string ProcessValidateSwitch(string[] parameters)
         /// </summary>
         private static void ThrowInvalidToolsVersionInitializationException(IEnumerable<Toolset> toolsets, string toolsVersion)
         {
-            string toolsVersionList = String.Empty;
+            string toolsVersionList = string.Empty;
             foreach (Toolset toolset in toolsets)
             {
-                toolsVersionList += "\"" + toolset.ToolsVersion + "\", ";
+                toolsVersionList += $"\"{toolset.ToolsVersion}\", ";
             }
 
             // Remove trailing comma and space
diff --git a/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs b/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
new file mode 100644
index 00000000000..8b0a83ecc8b
--- /dev/null
+++ b/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
@@ -0,0 +1,58 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.Framework;
+
+namespace MockCacheFromAssembly
+{
+    public class AssemblyMockCache : ProjectCachePluginBase
+    {
+        public AssemblyMockCache()
+        {
+            ThrowFrom("Constructor");
+        }
+
+        public override Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken)
+        {
+            logger.LogMessage($"{nameof(AssemblyMockCache)}: BeginBuildAsync", MessageImportance.High);
+
+            ThrowFrom(nameof(BeginBuildAsync));
+
+            return Task.CompletedTask;
+        }
+
+        public override Task<CacheResult> GetCacheResultAsync(
+            BuildRequestData buildRequest,
+            PluginLoggerBase logger,
+            CancellationToken cancellationToken)
+        {
+            logger.LogMessage($"{nameof(AssemblyMockCache)}: GetCacheResultAsync for {buildRequest.ProjectFullPath}", MessageImportance.High);
+
+            ThrowFrom(nameof(GetCacheResultAsync));
+
+            return Task.FromResult(CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable));
+        }
+
+        public override Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken)
+        {
+            logger.LogMessage($"{nameof(AssemblyMockCache)}: EndBuildAsync", MessageImportance.High);
+
+            ThrowFrom(nameof(EndBuildAsync));
+
+            return Task.CompletedTask;
+        }
+
+        private static void ThrowFrom(string throwFrom)
+        {
+            if (Environment.GetEnvironmentVariable(throwFrom) != null)
+            {
+                throw new Exception($"Cache plugin exception from {throwFrom}");
+            }
+        }
+    }
+}
diff --git a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
new file mode 100644
index 00000000000..9e1faa4fdbf
--- /dev/null
+++ b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
@@ -0,0 +1,15 @@
+﻿<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <UseProductOutputPath>true</UseProductOutputPath>
+    <CopyNuGetImplementations>false</CopyNuGetImplementations>
+    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
+
+    <TargetFrameworks>netcoreapp2.1</TargetFrameworks>
+    <TargetFrameworks Condition="'$(OsEnvironment)'=='windows'">$(FullFrameworkTFM);netcoreapp2.1</TargetFrameworks>
+    <TargetFrameworks Condition="'$(MonoBuild)'=='true'">$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
+  </PropertyGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\Build\Microsoft.Build.csproj" />
+    <ProjectReference Include="..\..\Framework\Microsoft.Build.Framework.csproj" />
+  </ItemGroup>
+</Project>
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 9d211bc1148..3785175e7fd 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -440,6 +440,14 @@ internal static void ResetInstance_ForUnitTestsOnly(Func<string> getProcessFromR
             BuildEnvironmentHelperSingleton.s_instance = Initialize();
         }
 
+        /// <summary>
+        /// Resets the current singleton instance (for testing).
+        /// </summary>
+        internal static void ResetInstance_ForUnitTestsOnly(BuildEnvironment buildEnvironment)
+        {
+            BuildEnvironmentHelperSingleton.s_instance = buildEnvironment;
+        }
+
         private static Func<string> s_getProcessFromRunningProcess = GetProcessFromRunningProcess;
         private static Func<string> s_getExecutingAssemblyPath = GetExecutingAssemblyPath;
         private static Func<string> s_getAppContextBaseDirectory = GetAppContextBaseDirectory;
diff --git a/src/Shared/CollectionHelpers.cs b/src/Shared/CollectionHelpers.cs
index 07ba40bad1d..8d66f374154 100644
--- a/src/Shared/CollectionHelpers.cs
+++ b/src/Shared/CollectionHelpers.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 
 namespace Microsoft.Build.Shared
 {
@@ -45,5 +46,35 @@ internal static bool ContainsValueAndIsEqual(this Dictionary<string, string> dic
 
             return false;
         }
+
+#if !CLR2COMPATIBILITY
+        internal static bool SetEquivalent<T>(IEnumerable<T> a, IEnumerable<T> b)
+        {
+            return a.ToHashSet().SetEquals(b);
+        }
+
+        internal static bool DictionaryEquals<K, V>(IReadOnlyDictionary<K, V> a, IReadOnlyDictionary<K, V> b)
+        {
+            if (a.Count != b.Count)
+            {
+                return false;
+            }
+
+            foreach (var aKvp in a)
+            {
+                if (!b.TryGetValue(aKvp.Key, out var bValue))
+                {
+                    return false;
+                }
+
+                if (!Equals(aKvp.Value, bValue))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+#endif
     }
 }
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index d2f3da6b887..42f82771737 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -97,6 +97,7 @@ internal static class MSBuildConstants
         internal static readonly char[] ForwardSlash = { '/' };
         internal static readonly char[] ForwardSlashBackslash = { '/', '\\' };
         internal static readonly char[] WildcardChars = { '*', '?' };
+        internal static readonly string[] CharactersForExpansion = { "*", "?", "$(", "@(", "%" };
         internal static readonly char[] CommaChar = { ',' };
         internal static readonly char[] HyphenChar = { '-' };
         internal static readonly char[] DirectorySeparatorChar = { Path.DirectorySeparatorChar };
@@ -117,6 +118,13 @@ internal static class PropertyNames
         internal const string InnerBuildPropertyValues = nameof(InnerBuildPropertyValues);
     }
 
+    // TODO: Remove these when VS gets updated to setup project cache plugins.
+    internal static class DesignTimeProperties
+    {
+        internal const string DesignTimeBuild = nameof(DesignTimeBuild);
+        internal const string BuildingProject = nameof(BuildingProject);
+    }
+
     internal static class ItemTypeNames
     {
         /// <summary>
@@ -130,6 +138,11 @@ internal static class ItemTypeNames
         internal const string ProjectReferenceTargets = nameof(ProjectReferenceTargets);
 
         internal const string GraphIsolationExemptReference = nameof(GraphIsolationExemptReference);
+
+        /// <summary>
+        /// Declares a project cache plugin and its configuration.
+        /// </summary>
+        internal const string ProjectCachePlugin = nameof(ProjectCachePlugin);
     }
 
     /// <summary>
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index b1332593d52..be59150401f 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Generic;
 using System.IO;
 using System.Diagnostics;
 using System.Globalization;
@@ -743,6 +744,37 @@ internal static void VerifyThrowArgumentLength(string parameter, string paramete
                 throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
             }
         }
+
+#if !CLR2COMPATIBILITY
+        /// <summary>
+        /// Throws an ArgumentNullException if the given collection is null
+        /// and ArgumentException if it has zero length.
+        /// </summary>
+        /// <param name="parameter"></param>
+        /// <param name="parameterName"></param>
+        internal static void VerifyThrowArgumentLength<T>(IReadOnlyCollection<T> parameter, string parameterName)
+        {
+            VerifyThrowArgumentNull(parameter, parameterName);
+
+            if (parameter.Count == 0 && s_throwExceptions)
+            {
+                throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
+            }
+        }
+
+        /// <summary>
+        /// Throws an ArgumentException if the given collection is not null but of zero length.
+        /// </summary>
+        /// <param name="parameter"></param>
+        /// <param name="parameterName"></param>
+        internal static void VerifyThrowArgumentLengthIfNotNull<T>(IReadOnlyCollection<T> parameter, string parameterName)
+        {
+            if (parameter?.Count == 0 && s_throwExceptions)
+            {
+                throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
+            }
+        }
+#endif
         
         /// <summary>
         /// Throws an ArgumentNullException if the given string parameter is null
diff --git a/src/Shared/QuotingUtilities.cs b/src/Shared/QuotingUtilities.cs
index 186fb087fa1..1e63c841cf9 100644
--- a/src/Shared/QuotingUtilities.cs
+++ b/src/Shared/QuotingUtilities.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections;
+using System.Collections.Generic;
 using System.Diagnostics;
 using System.Text;
 
@@ -58,7 +59,7 @@ internal static class QuotingUtilities
         /// <param name="emptySplits">[out] a count of all pieces that were empty, and thus discarded, per remark (1) above</param>
         /// <param name="separator"></param>
         /// <returns>ArrayList of all the pieces the string was split into.</returns>
-        internal static ArrayList SplitUnquoted
+        internal static List<string> SplitUnquoted
         (
             string input,
             int maxSplits,
@@ -131,7 +132,7 @@ params char[] separator
                 }
             }
 
-            ArrayList pieces = new ArrayList();
+            var pieces = new List<string>();
             emptySplits = 0;
 
             foreach (string splitPiece in splitString.ToString().Split(s_splitMarker, maxSplits))
@@ -163,7 +164,7 @@ params char[] separator
         /// <param name="input"></param>
         /// <param name="separator"></param>
         /// <returns>ArrayList of all the pieces the string was split into.</returns>
-        internal static ArrayList SplitUnquoted(string input, params char[] separator)
+        internal static List<string> SplitUnquoted(string input, params char[] separator)
         {
             int emptySplits;
             return SplitUnquoted(input, int.MaxValue, false /* discard empty splits */, false /* don't unquote the split pieces */, out emptySplits, separator);
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 6c62d8044f4..c20d923b67c 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -424,6 +424,12 @@ internal static void AssertItemHasMetadata(Dictionary<string, string> expected,
             AssertItemHasMetadata(expected, new ProjectItemTestItemAdapter(item));
         }
 
+        internal static void AssertItemHasMetadata(string key, string value, ProjectItem item)
+        {
+            item.DirectMetadataCount.ShouldBe(1, () => $"Expected 1 metadata, ({key}), got {item.DirectMetadataCount}");
+            item.GetMetadataValue(key).ShouldBe(value);
+        }
+
         internal static void AssertItemHasMetadata(Dictionary<string, string> expected, TestItem item)
         {
             expected ??= new Dictionary<string, string>();
@@ -1896,14 +1902,14 @@ internal class BuildManagerSession : IDisposable
         {
             private readonly TestEnvironment _env;
             private readonly BuildManager _buildManager;
+            private bool _disposed;
 
             public MockLogger Logger { get; set; }
 
             public BuildManagerSession(
                 TestEnvironment env,
-                BuildParameters buildParametersPrototype = null,
+                BuildParameters buildParameters = null,
                 bool enableNodeReuse = false,
-                bool shutdownInProcNode = true,
                 IEnumerable<BuildManager.DeferredBuildMessage> deferredMessages = null)
             {
                 _env = env;
@@ -1911,24 +1917,27 @@ public BuildManagerSession(
                 Logger = new MockLogger(_env.Output);
                 var loggers = new[] {Logger};
 
-                var actualBuildParameters = buildParametersPrototype?.Clone() ?? new BuildParameters();
+                var actualBuildParameters = buildParameters ?? new BuildParameters();
 
                 actualBuildParameters.Loggers = actualBuildParameters.Loggers == null
                     ? loggers
                     : actualBuildParameters.Loggers.Concat(loggers).ToArray();
 
-                actualBuildParameters.ShutdownInProcNodeOnBuildFinish = shutdownInProcNode;
+                actualBuildParameters.ShutdownInProcNodeOnBuildFinish = true;
                 actualBuildParameters.EnableNodeReuse = enableNodeReuse;
 
                 _buildManager = new BuildManager();
                 _buildManager.BeginBuild(actualBuildParameters, deferredMessages);
             }
 
-            public BuildResult BuildProjectFile(string projectFile, string[] entryTargets = null)
+            public BuildResult BuildProjectFile(
+                string projectFile,
+                string[] entryTargets = null,
+                Dictionary<string, string> globalProperties = null)
             {
                 var buildResult = _buildManager.BuildRequest(
                     new BuildRequestData(projectFile,
-                        new Dictionary<string, string>(),
+                        globalProperties ?? new Dictionary<string, string>(),
                         MSBuildConstants.CurrentToolsVersion,
                         entryTargets ?? new string[0],
                         null));
@@ -1938,9 +1947,21 @@ public BuildResult BuildProjectFile(string projectFile, string[] entryTargets =
 
             public void Dispose()
             {
+                if (_disposed)
+                {
+                    return;
+                }
+
+                _disposed = true;
+
                 _buildManager.EndBuild();
                 _buildManager.Dispose();
             }
+
+            public GraphBuildResult BuildGraph(ProjectGraph graph, string[] entryTargets = null)
+            {
+                return _buildManager.BuildRequest(new GraphBuildRequestData(graph, entryTargets ?? new string[0]));
+            }
         }
 
         internal class LoggingFileSystem : MSBuildFileSystemBase
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 97344d309fc..569bd92a66e 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -467,6 +467,21 @@ public override void AssertInvariant(ITestOutputHelper output)
         }
     }
 
+    public class CustomConditionInvariant : TestInvariant
+    {
+        private readonly Func<bool> _condition;
+
+        public CustomConditionInvariant(Func<bool> condition)
+        {
+            _condition = condition;
+        }
+
+        public override void AssertInvariant(ITestOutputHelper output)
+        {
+            _condition().ShouldBeTrue();
+        }
+    }
+
     public class TransientTempPath : TransientTestState
     {
         private const string TMP = "TMP";
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 2d0f453a127..2d0aaec17b3 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3686,6 +3686,37 @@ public void ConflictGeneratesMessageReferencingAssemblyName()
             warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.FourSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ReferenceDependsOn", "D, Version=1.0.0.0, CulTUre=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa", Path.Combine(s_myLibraries_V1Path, "D.dll"))));
         }
 
+        [Fact]
+        public void ConflictOutputsExtraInformationOnDemand()
+        {
+            ResolveAssemblyReference t = new ResolveAssemblyReference();
+
+            MockEngine e = new MockEngine(_output);
+            t.BuildEngine = e;
+
+            t.Assemblies = new ITaskItem[]
+            {
+                new TaskItem("B"),
+                new TaskItem("D, Version=1.0.0.0, Culture=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa")
+            };
+
+            t.SearchPaths = new string[]
+            {
+                s_myLibrariesRootPath, s_myLibraries_V2Path, s_myLibraries_V1Path
+            };
+
+            t.TargetFrameworkDirectories = new string[] { s_myVersion20Path };
+            t.OutputUnresolvedAssemblyConflicts = true;
+
+            Execute(t);
+
+            ITaskItem[] conflicts = t.UnresolvedAssemblyConflicts;
+            conflicts.Length.ShouldBe(1);
+            conflicts[0].ItemSpec.ShouldBe("D");
+            conflicts[0].GetMetadata("victorVersionNumber").ShouldBe("1.0.0.0");
+            conflicts[0].GetMetadata("victimVersionNumber").ShouldBe("2.0.0.0");
+        }
+
         /// <summary>
         /// Consider this dependency chain:
         ///
diff --git a/src/Tasks.UnitTests/CommandLine_Support.cs b/src/Tasks.UnitTests/CommandLine_Support.cs
index 4319bce40fa..3698bc32d69 100644
--- a/src/Tasks.UnitTests/CommandLine_Support.cs
+++ b/src/Tasks.UnitTests/CommandLine_Support.cs
@@ -38,7 +38,7 @@ static internal bool CallValidateParameters(ToolTask task)
         private static string[] Parse(string cl)
         {
             int emptySplits;
-            string[] pieces = (string[])QuotingUtilities.SplitUnquoted(cl, int.MaxValue, false, true, out emptySplits, ' ', '\n').ToArray(typeof(string));
+            string[] pieces = QuotingUtilities.SplitUnquoted(cl, int.MaxValue, false, true, out emptySplits, ' ', '\n').ToArray();
             return pieces;
         }
 
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index a842843a021..405f8662611 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -2236,6 +2236,118 @@ Dictionary<string, List<AssemblyNameReference>> baseNameToReferences
             }
         }
 
+        // TODO: Verify correctness of this implementation and extend to more cases.
+        // Should be consistent with CompareAssemblyIdentity from Fusion API:
+        // The result should be TRUE if one (or more) of the following conditions is true:
+        // a) The assembly identities are equivalent. For strongly-named assemblies this means full match on (name, version, pkt, culture); for simply-named assemblies this means a match on (name, culture)
+        // b) The assemblies being compared are FX assemblies (even if the version numbers are not the same, these will compare as equivalent by way of unification)
+        // c) The assemblies are not FX assemblies but are equivalent because fUnified1 and/or fUnified2 were set.
+        // The fUnified flag is used to indicate that all versions up to the version number of the strongly-named assembly are considered equivalent to itself.
+        // For example, if assemblyIdentity1 is "foo, version=5.0.0.0, culture=neutral, publicKeyToken=...." and fUnified1==TRUE, then this means to treat all versions of the assembly in the range 0.0.0.0-5.0.0.0 to be equivalent to "foo, version=5.0.0.0, culture=neutral, publicKeyToken=...".
+        // If assemblyIdentity2 is the same as assemblyIdentity1, except has a lower version number (e.g.version range 0.0.0.0-5.0.0.0), then the function will return that the identities are equivalent.
+        // If assemblyIdentity2 is the same as assemblyIdentity1, but has a greater version number than 5.0.0.0 then the two identities will only be equivalent if fUnified2 is set.
+        /// <summary>
+        /// Compares two assembly identities to determine whether or not they are equivalent.
+        /// </summary>
+        /// <param name="assemblyIdentity1"> Textual identity of the first assembly to be compared.</param>
+        /// <param name="fUnified1">Flag to indicate user-specified unification for assemblyIdentity1.</param>
+        /// <param name="assemblyIdentity2">Textual identity of the second assembly to be compared.</param>
+        /// <param name="fUnified2">Flag to indicate user-specified unification for assemblyIdentity2.</param>
+        /// <returns>
+        /// Boolean indicating whether the identities are equivalent.
+        /// </returns>
+        private static bool AreAssembliesEquivalent(
+            string assemblyIdentity1,
+            bool fUnified1,
+            string assemblyIdentity2,
+            bool fUnified2)
+        {
+            AssemblyName an1 = new AssemblyName(assemblyIdentity1);
+            AssemblyName an2 = new AssemblyName(assemblyIdentity2);
+
+            if (RefMatchesDef(an1, an2))
+            {
+                return true;
+            }
+
+            if (!an1.Name.Equals(an2.Name, StringComparison.OrdinalIgnoreCase))
+            {
+                return false;
+            }
+
+            var versionCompare = an1.Version.CompareTo(an2.Version);
+
+            if ((versionCompare < 0 && fUnified2) || (versionCompare > 0 && fUnified1))
+            {
+                return true;
+            }
+
+            if (versionCompare == 0)
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        //  Based on coreclr baseassemblyspec.cpp (https://github.com/dotnet/coreclr/blob/4cf8a6b082d9bb1789facd996d8265d3908757b2/src/vm/baseassemblyspec.cpp#L330)
+        private static bool RefMatchesDef(AssemblyName @ref, AssemblyName def)
+        {
+            if (IsStrongNamed(@ref))
+            {
+                return IsStrongNamed(def) && CompareRefToDef(@ref, def);
+            }
+            else
+            {
+                return @ref.Name.Equals(def.Name, StringComparison.OrdinalIgnoreCase);
+            }
+        }
+
+        // Based on coreclr baseassemblyspec.inl (https://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/src/vm/baseassemblyspec.inl#L679-L683)
+        private static bool IsStrongNamed(AssemblyName assembly)
+        {
+            var refPkt = assembly.GetPublicKeyToken();
+            return refPkt != null && refPkt.Length != 0;
+        }
+
+        //  Based on https://github.com/dotnet/coreclr/blob/4cf8a6b082d9bb1789facd996d8265d3908757b2/src/vm/baseassemblyspec.cpp#L241
+        private static bool CompareRefToDef(AssemblyName @ref, AssemblyName def)
+        {
+            if (!@ref.Name.Equals(def.Name, StringComparison.OrdinalIgnoreCase))
+            {
+                return false;
+            }
+
+            byte[] rpkt = @ref.GetPublicKeyToken();
+            byte[] dpkt = def.GetPublicKeyToken();
+
+            if (rpkt.Length != dpkt.Length)
+            {
+                return false;
+            }
+
+            for (int i = 0; i < rpkt.Length; i++)
+            {
+                if (rpkt[i] != dpkt[i])
+                {
+                    return false;
+                }
+            }
+
+            if (@ref.Version != def.Version)
+            {
+                return false;
+            }
+
+            if (@ref.CultureName != null &&
+                @ref.CultureName != def.CultureName)
+            {
+                return false;
+            }
+
+            return true;
+        }
+
         /// <summary>
         /// Given two references along with their fusion names, resolve the filename conflict that they
         /// would have if both assemblies need to be copied to the same directory.
@@ -2279,14 +2391,12 @@ private static int ResolveAssemblyNameConflict(AssemblyNameReference assemblyRef
                 bool rightConflictLegacyUnified = !isNonUnified && assemblyReference1.reference.IsPrimary;
 
                 // This is ok here because even if the method says two versions are equivalent the algorithm below will still pick the highest version.
-                NativeMethods.CompareAssemblyIdentity
+                bool equivalent = AreAssembliesEquivalent
                 (
                     leftConflictFusionName,
                     leftConflictLegacyUnified,
                     rightConflictFusionName,
-                    rightConflictLegacyUnified,
-                    out bool equivalent,
-                    out _
+                    rightConflictLegacyUnified
                 );
 
                 Version leftConflictVersion = assemblyReference0.assemblyName.Version;
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 90af55781f5..b7e72734291 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -86,6 +86,7 @@ public ResolveAssemblyReference()
         private ITaskItem[] _scatterFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _copyLocalFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _suggestedRedirects = Array.Empty<TaskItem>();
+        private List<ITaskItem> _unresolvedConflicts = new List<ITaskItem>();
         private string[] _targetFrameworkSubsets = Array.Empty<string>();
         private string[] _fullTargetFrameworkSubsetNames = Array.Empty<string>();
         private string _targetedFrameworkMoniker = String.Empty;
@@ -214,6 +215,11 @@ public bool IgnoreTargetFrameworkAttributeVersionMismatch
         /// </remarks>
         public bool FindDependenciesOfExternallyResolvedReferences { get; set; }
 
+        /// <summary>
+        /// If true, outputs any unresolved assembly conflicts (MSB3277) in UnresolvedAssemblyConflicts.
+        /// </summary>
+        public bool OutputUnresolvedAssemblyConflicts { get; set; }
+
         /// <summary>
         /// List of target framework subset names which will be searched for in the target framework directories
         /// </summary>
@@ -915,6 +921,13 @@ public String DependsOnNETStandard
             private set;
         }
 
+        /// <summary>
+        /// If OutputUnresolvedAssemblyConflicts then a list of information about unresolved conflicts that normally would have
+        /// been outputted in MSB3277. Otherwise empty.
+        /// </summary>
+        [Output]
+        public ITaskItem[] UnresolvedAssemblyConflicts => _unresolvedConflicts.ToArray();
+
         #endregion
         #region Logging
 
@@ -990,16 +1003,30 @@ quiet at the engine level.
                             // Log the reference which lost the conflict and the dependencies and source items which caused it.
                             LogReferenceDependenciesAndSourceItemsToStringBuilder(fusionName, conflictCandidate, logDependencies.AppendLine());
 
+                            string output = StringBuilderCache.GetStringAndRelease(logConflict);
+                            string details = string.Empty;
                             if (logWarning)
                             {
                                 // This warning is logged regardless of AutoUnify since it means a conflict existed where the reference	
                                 // chosen was not the conflict victor in a version comparison. In other words, the victor was older.
-                                Log.LogWarningWithCodeFromResources("ResolveAssemblyReference.FoundConflicts", assemblyName.Name, StringBuilderCache.GetStringAndRelease(logConflict));
+                                Log.LogWarningWithCodeFromResources("ResolveAssemblyReference.FoundConflicts", assemblyName.Name, output);
                             }
                             else
                             {
-                                Log.LogMessage(ChooseReferenceLoggingImportance(conflictCandidate), StringBuilderCache.GetStringAndRelease(logConflict));
-                                Log.LogMessage(MessageImportance.Low, StringBuilderCache.GetStringAndRelease(logDependencies));
+                                details = StringBuilderCache.GetStringAndRelease(logDependencies);
+                                Log.LogMessage(ChooseReferenceLoggingImportance(conflictCandidate), output);
+                                Log.LogMessage(MessageImportance.Low, details);
+                            }
+
+                            if (OutputUnresolvedAssemblyConflicts)
+                            {
+                                _unresolvedConflicts.Add(new TaskItem(assemblyName.Name, new Dictionary<string, string>()
+                                {
+                                    { "logMessage", output },
+                                    { "logMessageDetails", details },
+                                    { "victorVersionNumber", victor.ReferenceVersion.ToString() },
+                                    { "victimVersionNumber", conflictCandidate.ReferenceVersion.ToString() }
+                                }));
                             }
                         }
                     }
diff --git a/src/Tasks/ComReferenceResolutionException.cs b/src/Tasks/ComReferenceResolutionException.cs
index cbfe1b1efca..48f2f0f0231 100644
--- a/src/Tasks/ComReferenceResolutionException.cs
+++ b/src/Tasks/ComReferenceResolutionException.cs
@@ -10,11 +10,9 @@ namespace Microsoft.Build.Tasks
     /// Internal exception thrown when there's an unrecoverable failure resolving a COM reference and we should 
     /// move on to the next one, if it makes sense.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
     internal class ComReferenceResolutionException : Exception
     {
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index a821fb22c9c..0cf22b566c5 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -17,9 +17,7 @@ namespace Microsoft.Build.Tasks
     /// This class defines an "Exec" MSBuild task, which simply invokes the specified process with the specified arguments, waits
     /// for it to complete, and then returns True if the process completed successfully, and False if an error occurred.
     /// </summary>
-    /// <comments>
-    /// UNDONE: ToolTask has a "UseCommandProcessor" flag that duplicates much of the code in this class. Remove the duplication.
-    /// </comments>
+    // UNDONE: ToolTask has a "UseCommandProcessor" flag that duplicates much of the code in this class. Remove the duplication.
     public class Exec : ToolTaskExtension
     {
         #region Constructors
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index cacc0e712a8..9e82022491e 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -2156,6 +2156,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <ResolveAssemblyReferencesFindRelatedSatellites Condition="'$(ResolveAssemblyReferencesFindRelatedSatellites)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindRelatedSatellites>
       <ResolveAssemblyReferencesFindSerializationAssemblies Condition="'$(ResolveAssemblyReferencesFindSerializationAssemblies)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindSerializationAssemblies>
       <ResolveAssemblyReferencesFindRelatedFiles Condition="'$(ResolveAssemblyReferencesFindRelatedFiles)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindRelatedFiles>
+      <ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts Condition="'$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)' == ''">false</ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts>
     </PropertyGroup>
 
     <ItemGroup>
@@ -2218,6 +2219,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         IgnoreTargetFrameworkAttributeVersionMismatch ="$(ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch)"
         FindDependenciesOfExternallyResolvedReferences="$(FindDependenciesOfExternallyResolvedReferences)"
         ContinueOnError="$(ContinueOnError)"
+        OutputUnresolvedAssemblyConflicts="$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)"
         Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!='' or '@(_ExplicitReference)' != ''"
         >
 
@@ -2233,6 +2235,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="FilesWritten" ItemName="FileWrites"/>
       <Output TaskParameter="DependsOnSystemRuntime" PropertyName="DependsOnSystemRuntime"/>
       <Output TaskParameter="DependsOnNETStandard" PropertyName="_DependsOnNETStandard"/>
+      <Output TaskParameter="UnresolvedAssemblyConflicts" ItemName="ResolveAssemblyReferenceUnresolvedAssemblyConflicts"/>
     </ResolveAssemblyReference>
   </Target>
 
@@ -4169,10 +4172,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup>
       <_SatelliteAssemblies Include="@(IntermediateSatelliteAssembliesWithTargetPath);@(ReferenceSatellitePaths)" />
       <_DeploymentReferencePaths Include="@(ReferenceCopyLocalPaths)"
-                                 Condition="'%(Extension)' == '.dll' Or '%(Extension)' == '.exe' Or '%(Extension)' == '.md'">
+                                 Condition="('%(Extension)' == '.dll' Or '%(Extension)' == '.exe' Or '%(Extension)' == '.md') and ('%(ReferenceCopyLocalPaths.CopyToPublishDirectory)' != 'false')">
         <IsPrimary>true</IsPrimary>
       </_DeploymentReferencePaths>
-      <_DeploymentReferencePaths Include="@(_DeploymentReferencePaths);@(_CopyLocalFalseRefPathsWithExclusion)" />
+      <_DeploymentReferencePaths Include="@(_CopyLocalFalseRefPathsWithExclusion)" />
     </ItemGroup>
 
     <!-- Include managed references in clickonce manifest only if single file publish is false -->
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index a4e4fd164a2..174dfe25f83 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -1052,200 +1052,6 @@ internal static extern int CreateAssemblyNameObject(
         internal static extern int GetCachePath(AssemblyCacheFlags cacheFlags, StringBuilder cachePath, ref int pcchPath);
 #endif
 
-        /*------------------------------------------------------------------------------
-        CompareAssemblyIdentity
-        The Fusion API to compare two assembly identities to determine whether or not they are equivalent is now available. This new API is exported from mscorwks.dll, which you can access via mscoree's GetRealProcAddress. The function prototype is defined in fusion.h as follows:
-
-        STDAPI CompareAssemblyIdentity(LPCWSTR pwzAssemblyIdentity1,
-                                    BOOL fUnified1,
-                                    LPCWSTR pwzAssemblyIdentity2,
-                                    BOOL fUnified2,
-                                    BOOL *pfEquivalent,
-                                    AssemblyComparisonResult *pResult);
-
-typedef enum _tagAssemblyComparisonResult 
-{
-    ACR_Unknown,                    // Unknown 
-    ACR_EquivalentFullMatch,        // all fields match
-    ACR_EquivalentWeakNamed,        // match based on weak-name, version numbers ignored
-    ACR_EquivalentFXUnified,        // match based on FX-unification of version numbers
-    ACR_EquivalentUnified,          // match based on legacy-unification of version numbers
-    ACR_NonEquivalentVersion,       // all fields match except version field
-    ACR_NonEquivalent,              // no match
-
-    ACR_EquivalentPartialMatch,
-    ACR_EquivalentPartialWeakNamed,  
-    ACR_EquivalentPartialUnified,
-    ACR_EquivalentPartialFXUnified,
-    ACR_NonEquivalentPartialVersion     
-} AssemblyComparisonResult;
-
-        Parameters:
-            [in] LPCWSTR pwzAssemblyIdentity1 : Textual identity of the first assembly to be compared
-            [in] BOOL fUnified1               : Flag to indicate user-specified unification for pwzAssemblyIdentity1 (see below)
-            [in] LPCWSTR pwzAssemblyIdentity2 : Textual identity of the second assembly to be compared
-            [in] BOOL fUnified2               : Flag to inidcate user-specified unification for pwzAssemblyIdentity2 (see below)
-            [out] BOOL *pfEquivalent          : Boolean indicating whether the identities are equivalent
-            [out] AssemblyComparisonResult *pResult : Contains detailed information about the comparison result
-
-        This API will check whether or not pwzAssemblyIdentity1 and pwzAssemblyIdentity2 are equivalent. Both of these identities must be full-specified (name, version, pkt, culture). The pfEquivalent parameter will be set to TRUE if one (or more) of the following conditions is true:
-
-        a) The assembly identities are equivalent. For strongly-named assemblies this means full match on (name, version, pkt, culture); for simply-named assemblies this means a match on (name, culture)
-
-        b) The assemblies being compared are FX assemblies (even if the version numbers are not the same, these will compare as equivalent by way of unification)
-
-        c) The assemblies are not FX assemblies but are equivalent because fUnified1 and/or fUnified2 were set.
-
-        The fUnified flag is used to indicate that all versions up to the version number of the strongly-named assembly are considered equivalent to itself. For example, if pwzAssemblyIdentity1 is "foo, version=5.0.0.0, culture=neutral, publicKeyToken=...." and fUnified1==TRUE, then this means to treat all versions of the assembly in the range 0.0.0.0-5.0.0.0 to be equivalent to "foo, version=5.0.0.0, culture=neutral, publicKeyToken=...". If pwzAssemblyIdentity2 is the same as pwzAssemblyIdentity1, except has a lower version number (e.g. version range 0.0.0.0-5.0.0.0), then the API will return that the identities are equivalent. If pwzAssemblyIdentity2 is the same as pwzAssemblyIdentity1, but has a greater version number than 5.0.0.0 then the two identities will only be equivalent if fUnified2 is set.
-
-        The AssemblyComparisonResult gives you information about why the identities compared as equal or not equal. The description of the meaning of each ACR_* return value is described in the declaration above.
-        ------------------------------------------------------------------------------*/
-        [DllImport("fusion.dll", CharSet = CharSet.Unicode, EntryPoint = "CompareAssemblyIdentity")]
-        internal static extern int CompareAssemblyIdentityWindows
-            (
-                string pwzAssemblyIdentity1,
-                [MarshalAs(UnmanagedType.Bool)] bool fUnified1,
-                string pwzAssemblyIdentity2,
-                [MarshalAs(UnmanagedType.Bool)] bool fUnified2,
-                [MarshalAs(UnmanagedType.Bool)] out bool pfEquivalent,
-                out AssemblyComparisonResult pResult
-            );
-
-        // TODO: Verify correctness of this implementation and
-        // extend to more cases.
-        internal static void CompareAssemblyIdentity(
-            string assemblyIdentity1,
-            bool fUnified1,
-            string assemblyIdentity2,
-            bool fUnified2,
-            out bool pfEquivalent,
-            out AssemblyComparisonResult pResult)
-        {
-#if FEATURE_FUSION_COMPAREASSEMBLYIDENTITY
-            if (NativeMethodsShared.IsWindows)
-            {
-                CompareAssemblyIdentityWindows(
-                    assemblyIdentity1,
-                    fUnified1,
-                    assemblyIdentity2,
-                    fUnified2,
-                    out pfEquivalent,
-                    out pResult);
-            }
-#endif
-
-            AssemblyName an1 = new AssemblyName(assemblyIdentity1);
-            AssemblyName an2 = new AssemblyName(assemblyIdentity2);
-
-            //pfEquivalent = AssemblyName.ReferenceMatchesDefinition(an1, an2);
-            pfEquivalent = RefMatchesDef(an1, an2);
-            if (pfEquivalent)
-            {
-                pResult = AssemblyComparisonResult.ACR_EquivalentFullMatch;
-                return;
-            }
-
-            if (!an1.Name.Equals(an2.Name, StringComparison.OrdinalIgnoreCase))
-            {
-                pResult = AssemblyComparisonResult.ACR_NonEquivalent;
-                pfEquivalent = false;
-                return;
-            }
-
-            var versionCompare = an1.Version.CompareTo(an2.Version);
-
-            if ((versionCompare < 0 && fUnified2) || (versionCompare > 0 && fUnified1))
-            {
-                pResult = AssemblyComparisonResult.ACR_NonEquivalentVersion;
-                pfEquivalent = true;
-                return;
-            }
-
-            if (versionCompare == 0)
-            {
-                pResult = AssemblyComparisonResult.ACR_EquivalentFullMatch;
-                pfEquivalent = true;
-                return;
-            }
-
-            pResult = pfEquivalent ? AssemblyComparisonResult.ACR_EquivalentFullMatch : AssemblyComparisonResult.ACR_NonEquivalent;
-        }
-
-        //  Based on coreclr baseassemblyspec.cpp (https://github.com/dotnet/coreclr/blob/4cf8a6b082d9bb1789facd996d8265d3908757b2/src/vm/baseassemblyspec.cpp#L330)
-        private static bool RefMatchesDef(AssemblyName @ref, AssemblyName def)
-        {
-            if (IsStrongNamed(@ref))
-            {
-                return IsStrongNamed(def) && CompareRefToDef(@ref, def);
-            }
-            else
-            {
-                return @ref.Name.Equals(def.Name, StringComparison.OrdinalIgnoreCase);
-            }
-        }
-
-        // Based on coreclr baseassemblyspec.inl (https://github.com/dotnet/coreclr/blob/32f0f9721afb584b4a14d69135bea7ddc129f755/src/vm/baseassemblyspec.inl#L679-L683)
-        private static bool IsStrongNamed(AssemblyName assembly)
-        {
-            var refPkt = assembly.GetPublicKeyToken();
-            return refPkt != null && refPkt.Length != 0;
-        }
-
-        //  Based on https://github.com/dotnet/coreclr/blob/4cf8a6b082d9bb1789facd996d8265d3908757b2/src/vm/baseassemblyspec.cpp#L241
-        private static bool CompareRefToDef(AssemblyName @ref, AssemblyName def)
-        {
-            if (!@ref.Name.Equals(def.Name, StringComparison.OrdinalIgnoreCase))
-            {
-                return false;
-            }
-
-            byte[] rpkt = @ref.GetPublicKeyToken();
-            byte[] dpkt = def.GetPublicKeyToken();
-
-            if (rpkt.Length != dpkt.Length)
-            {
-                return false;
-            }
-
-            for (int i = 0; i < rpkt.Length; i++)
-            {
-                if (rpkt[i] != dpkt[i])
-                {
-                    return false;
-                }
-            }
-
-            if (@ref.Version != def.Version)
-            {
-                return false;
-            }
-
-            if (@ref.CultureName != null &&
-                @ref.CultureName != def.CultureName)
-            {
-                return false;
-            }
-
-            return true;
-        }
-
-        internal enum AssemblyComparisonResult
-        {
-            ACR_Unknown,                    // Unknown 
-            ACR_EquivalentFullMatch,        // all fields match
-            ACR_EquivalentWeakNamed,        // match based on weak-name, version numbers ignored
-            ACR_EquivalentFXUnified,        // match based on FX-unification of version numbers
-            ACR_EquivalentUnified,          // match based on legacy-unification of version numbers
-            ACR_NonEquivalentVersion,       // all fields match except version field
-            ACR_NonEquivalent,              // no match
-
-            ACR_EquivalentPartialMatch,
-            ACR_EquivalentPartialWeakNamed,
-            ACR_EquivalentPartialUnified,
-            ACR_EquivalentPartialFXUnified,
-            ACR_NonEquivalentPartialVersion
-        }
-
         //------------------------------------------------------------------------------
         // PFXImportCertStore
         //------------------------------------------------------------------------------
diff --git a/src/Tasks/StrongNameException.cs b/src/Tasks/StrongNameException.cs
index 040d841c0a4..2a533772616 100644
--- a/src/Tasks/StrongNameException.cs
+++ b/src/Tasks/StrongNameException.cs
@@ -9,11 +9,9 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Internal exception thrown when there's an unrecoverable failure extracting public/private keys.
     /// </summary>
-    /// <remarks>
-    /// WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
-    /// promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
-    /// without following certain special FX guidelines, can break both forward and backward compatibility
-    /// </remarks>
+    // WARNING: marking a type [Serializable] without implementing ISerializable imposes a serialization contract -- it is a
+    // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
+    // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
     internal class StrongNameException : Exception
     {
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 6fc1777dcad..fd31a3cf970 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -43,10 +43,10 @@ namespace Microsoft.Build.Utilities
     ///     At this point we will look up the success state of the project finished event for the submission ID and log a build finished event to the logger.
     ///     The event source will be cleaned up.  This may be interesting because the unregister will come from a thread other than what is doing the logging.
     ///     This may create a Synchronization issue, if unregister is called while events are being logged.
-    ///     
-    /// UNDONE: If we can use ErrorUtilities, replace all InvalidOperation and Argument exceptions with the appropriate calls.
-    /// 
     /// </summary>
+    //     
+    // UNDONE: If we can use ErrorUtilities, replace all InvalidOperation and Argument exceptions with the appropriate calls.
+    // 
     public class MuxLogger : INodeLogger
     {
         /// <summary>
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 93ec1767db9..23f7abc7e67 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -54,10 +54,8 @@ public enum HostObjectInitializationStatus
     /// Base class used for tasks that spawn an executable. This class implements the ToolPath property which can be used to
     /// override the default path.
     /// </summary>
-    /// <remarks>
-    /// INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and 
-    /// we want to use resources from Utilities. Use LogPrivate (for private Utilities resources) and LogShared (for shared MSBuild resources)
-    /// </remarks>
+    // INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and 
+    // we want to use resources from Utilities. Use LogPrivate (for private Utilities resources) and LogShared (for shared MSBuild resources)
     public abstract class ToolTask : Task, ICancelableTask
     {
         private static readonly bool s_preserveTempFiles = string.Equals(Environment.GetEnvironmentVariable("MSBUILDPRESERVETOOLTEMPFILES"), "1", StringComparison.Ordinal);
