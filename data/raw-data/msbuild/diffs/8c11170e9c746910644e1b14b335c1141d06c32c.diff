diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index 9e96c8516c3..dcd1abc5b09 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -34,7 +34,9 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 | ReusableStringBuilderFactoryUnbalanced | Identifies improper usage from multiple threads or buggy code: multiple Gets were called without a Relase. |
 | Save | Saves a project to the file system if dirty, creating directories as necessary. |
 | SdkResolverResolveSdk | A single SDK resolver is called. |
-| SdkResolverServiceInitialize | Initializes SDK resolvers. |
+| SdkResolverServiceFindResolversManifests | Find all resolvers manifests. (Only appear under Changewave 17.4.) |
+| SdkResolverServiceInitialize | Initializes SDK resolvers. (Only appear before Changewave 17.4.) |
+| SdkResolverServiceLoadResolvers | Load resolvers given a resolver manifest. (Only appear under Changewave 17.4.) |
 | SdkResolverEvent | An SDK resolver logs an event. |
 | Target | Executes a target. |
 | TargetUpToDate | Checks whether a particular target needs to run or is up-to-date. |
diff --git a/documentation/specs/sdk-resolvers-algorithm.md b/documentation/specs/sdk-resolvers-algorithm.md
new file mode 100644
index 00000000000..eb962ad2644
--- /dev/null
+++ b/documentation/specs/sdk-resolvers-algorithm.md
@@ -0,0 +1,28 @@
+## SDK Resolution Algorithm
+In 17.3 under ChangeWave 17.4 the sdk resolution algorithm is changed.
+
+### Reason for change
+Previously (before ChangeWave 17.4) all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavior in 17.3 under ChangeWave 17.4.
+
+### New SDK Resolution Algorithm
+Under ChangeWave 17.4 all the resolvers divides into two groups:
+- Specific resolvers, i.e. resolvers with specified sdk name pattern `ResolvableSdkPattern`
+- General resolvers, i.e. resolvers without specified sdk name pattern `ResolvableSdkPattern`
+
+The resolving algorithm works in two passes. 
+- On the first pass all the specific resolvers that match the given sdk name would be loaded, ordered by priority and tried one after one. 
+- If the sdk is not found, on the second pass all general resolvers would be loaded, ordered by priority and tried one after one.
+
+By default the resolvers are general. To make all the resolvers from some dll specific, in the corresponding manifest (xml file) one need to specify the `ResolvableSdkPattern` using C# regex format:
+```
+<SdkResolver>
+  <Path>MySdkResolver.dll</Path>
+  <ResolvableSdkPattern>MySdk.*</ResolvableSdkPattern>
+</SdkResolver>
+```
+
+Note, that the manifest file, if exists, from ChangeWave 17.4 would have preference over the dll.
+The sdk discovery works according to the following algorithm:
+- First try locate the manifest file and use it. 
+- If it is not found, we try to locate the dll in the resolver's folder. 
+Both xml and dll name should match the following name pattern `...\SdkResolvers\(ResolverName)\(ResolverName).(xml/dll)`.
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index e489729fad6..2158cd2a8a5 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -25,8 +25,8 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 
 ### 17.4
 - [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
-- [Remove opt in for new schema for CombineTargetFrameworkInfoProperties](https://github.com/dotnet/msbuild/pull/6928)
 - [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
+- [Adding accepted SDK name match pattern to SDK manifests](https://github.com/dotnet/msbuild/pull/7597)
 
 ### 17.0
 - [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
diff --git a/documentation/wiki/ResolveAssemblyReference.md b/documentation/wiki/ResolveAssemblyReference.md
index 10041d58494..27241f5dbd5 100644
--- a/documentation/wiki/ResolveAssemblyReference.md
+++ b/documentation/wiki/ResolveAssemblyReference.md
@@ -162,6 +162,6 @@ By default, there are ten locations RAR will search (four if using the .NET SDK)
 
 ## There was a conflict
 
-A common situation is MSBuild gives a warning about different versions of the same assembly being used by different references. The solution often involves adding a binding redirect to the app.config file. 
+A common situation is MSBuild gives a warning about different versions of the same assembly being used by different references. The solution often involves adding a binding redirect to the app.config file.
 
 A useful way to investigate these conflicts is to search in MSBuild Structured Log Viewer for "There was a conflict". It will show you detailed information about which references needed which versions of the assembly in question.
diff --git a/eng/Packages.props b/eng/Packages.props
index 6812e9a0a6b..b189ed67979 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -19,7 +19,7 @@
     <PackageReference Update="System.Collections.Immutable" Version="6.0.0" />
     <PackageReference Update="System.Configuration.ConfigurationManager" Version="6.0.0" />
     <PackageReference Update="System.Net.Http" Version="4.3.4" />
-    <PackageReference Update="System.Memory" Version="4.5.4" />
+    <PackageReference Update="System.Memory" Version="4.5.5" />
     <PackageReference Update="System.Reflection.Metadata" Version="6.0.0" />
     <PackageReference Update="System.Reflection.MetadataLoadContext" Version="6.0.0" />
     <PackageReference Update="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 1a45702700d..7756215e8f6 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22261.7">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22314.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e3cbecc5b0e51374e3d71dbb976004ab9cc90430</Sha>
+      <Sha>fdd3a242bc813f371023adff4e4c05c0be705d2a</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="6.2.0-rc.146">
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>b8a61266d9a6780cb7eb9c1942695cf813fdef0a</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.2.0-4.22255.15">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.2.0-4.22307.8">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>8d1fd8de0fd8b9de1ce2a9a1bd154af2432f03bd</Sha>
+      <Sha>9521db7e5f69e3e84bab147a138dbf5adf57aff9</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22261.7">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22314.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e3cbecc5b0e51374e3d71dbb976004ab9cc90430</Sha>
+      <Sha>fdd3a242bc813f371023adff4e4c05c0be705d2a</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 1c49d769671..4c92e1424a4 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -32,10 +32,10 @@
     <!-- DotNetCliVersion MUST match the dotnet version in global.json.
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22261.7</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22314.7</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.2.0-4.22255.15</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.2.0-4.22307.8</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.2.0-rc.146</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>6.0.0</SystemTextJsonVersion>
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 77f7ea45f65..06cf49477ed 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -12,14 +12,14 @@
     <PackageReference Update="LargeAddressAware" Version="1.0.5" />
     <PackageReference Update="Microsoft.CodeAnalysis.PublicApiAnalyzers" Version="3.3.3" />
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" />
-    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.1.2196" PrivateAssets="All" />
+    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.2.2146" PrivateAssets="All" />
     <PackageReference Update="Microsoft.Win32.Registry" Version="5.0.0" />
     <PackageReference Update="PdbGit" Version="3.0.41" />
     <PackageReference Update="Shouldly" Version="3.0.0" />
     <PackageReference Update="System.CodeDom" Version="6.0.0" />
     <PackageReference Update="System.Private.Uri" Version="4.3.2" />
     <PackageReference Update="System.Runtime" Version="4.3.1" />
-    <PackageReference Update="System.Security.Cryptography.Pkcs" Version="6.0.0" />
+    <PackageReference Update="System.Security.Cryptography.Pkcs" Version="6.0.1" />
     <PackageReference Update="System.Security.Cryptography.Xml" Version="6.0.0" />
     <PackageReference Update="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
   </ItemGroup>
diff --git a/global.json b/global.json
index 3c20798654a..471f88dbc9b 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22261.7"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22314.7"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index ca6d7535564..07e0760970e 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -801,6 +801,18 @@ public void TreatWarningsAsErrorWhenAllSpecified(int loggerMode, int nodeId)
             logger.Errors.ShouldHaveSingleItem();
         }
 
+        [Fact]
+        public void VerifyWarningsPromotedToErrorsAreCounted()
+        {
+            ILoggingService ls = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+            ls.WarningsAsErrors = new HashSet<string>();
+            ls.WarningsAsErrors.Add("FOR123");
+            BuildWarningEventArgs warningArgs = new("abc", "FOR123", "", 0, 0, 0, 0, "warning message", "keyword", "sender");
+            warningArgs.BuildEventContext = new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidProjectContextId, 5, 6);
+            ls.LogBuildEvent(warningArgs);
+            ls.HasBuildSubmissionLoggedErrors(1).ShouldBeTrue();
+        }
+
         /// <summary>
         /// Verifies that a warning is logged as a low importance message when it's warning code is specified.
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
index 4b14bd3537a..e8b3812ab57 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
@@ -46,7 +46,7 @@ public void AssertDefaultLoaderReturnsDefaultResolvers()
         {
             var loader = new SdkResolverLoader();
 
-            var resolvers = loader.LoadResolvers(_loggingContext, new MockElementLocation("file"));
+            var resolvers = loader.LoadAllResolvers(_loggingContext, new MockElementLocation("file"));
 
             resolvers.Select(i => i.GetType().FullName).ShouldBe(new [] { typeof(DefaultSdkResolver).FullName });
             
@@ -88,6 +88,38 @@ public void VerifySdkResolverLoaderFileDiscoveryPattern()
             }
         }
 
+        [Fact]
+        public void SdkResolverLoaderPrefersManifestFile()
+        {
+            var root = FileUtilities.GetTemporaryDirectory();
+            try
+            {
+                var testFolder = Directory.CreateDirectory(Path.Combine(root, "MyTestResolver"));
+
+                var wrongResolverDll = Path.Combine(testFolder.FullName, "MyTestResolver.dll");
+                var resolverManifest = Path.Combine(testFolder.FullName, "MyTestResolver.xml");
+                var assemblyToLoad = Path.Combine(root, "SomeOtherResolver.dll");
+
+                File.WriteAllText(wrongResolverDll, string.Empty);
+                File.WriteAllText(assemblyToLoad, string.Empty);
+
+                File.WriteAllText(resolverManifest, $@"
+                    <SdkResolver>
+                      <Path>{assemblyToLoad}</Path>
+                    </SdkResolver>");
+
+                SdkResolverLoader loader = new SdkResolverLoader();
+                var resolversFound = loader.FindPotentialSdkResolvers(root, new MockElementLocation("file"));
+
+                resolversFound.Count.ShouldBe(1);
+                resolversFound.First().ShouldBe(assemblyToLoad);
+            }
+            finally
+            {
+                FileUtilities.DeleteDirectoryNoThrow(root, true);
+            }
+        }
+
         /// <summary>
         /// Verifies that if an SDK resolver throws while creating an instance that a warning is logged.
         /// </summary>
@@ -106,7 +138,7 @@ public void VerifyThrowsWhenResolverFailsToLoad()
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
             {
-                sdkResolverLoader.LoadResolvers(_loggingContext, ElementLocation.EmptyLocation);
+                sdkResolverLoader.LoadAllResolvers(_loggingContext, ElementLocation.EmptyLocation);
             });
 
             exception.Message.ShouldBe($"The SDK resolver type \"{nameof(MockSdkResolverThatDoesNotLoad)}\" failed to load. A8BB8B3131D3475D881ACD3AF8D75BD6");
@@ -138,7 +170,7 @@ public void VerifyThrowsWhenResolverHasNoPublicConstructor()
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
             {
-                sdkResolverLoader.LoadResolvers(_loggingContext, ElementLocation.EmptyLocation);
+                sdkResolverLoader.LoadAllResolvers(_loggingContext, ElementLocation.EmptyLocation);
             });
 
             exception.Message.ShouldStartWith($"The SDK resolver type \"{nameof(MockSdkResolverNoPublicConstructor)}\" failed to load.");
@@ -169,7 +201,7 @@ public void VerifyWarningLoggedWhenResolverAssemblyCannotBeLoaded()
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
             {
-                sdkResolverLoader.LoadResolvers(_loggingContext, ElementLocation.EmptyLocation);
+                sdkResolverLoader.LoadAllResolvers(_loggingContext, ElementLocation.EmptyLocation);
             });
 
             exception.Message.ShouldBe($"The SDK resolver assembly \"{assemblyPath}\" could not be loaded. {expectedMessage}");
@@ -207,6 +239,33 @@ public void SdkResolverLoaderReadsManifestFile()
             }
         }
 
+        [Fact]
+        public void SdkResolverLoaderReadsManifestFileWithResolvableSdkPattern()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                var root = env.CreateFolder().Path;
+                var resolverPath = Path.Combine(root, "MyTestResolver");
+                var resolverManifest = Path.Combine(resolverPath, "MyTestResolver.xml");
+
+                var assemblyToLoad = env.CreateFile(".dll").Path;
+
+                Directory.CreateDirectory(resolverPath);
+                File.WriteAllText(resolverManifest, $@"
+                    <SdkResolver>
+                      <ResolvableSdkPattern>1&lt;.*</ResolvableSdkPattern>
+                      <Path>{assemblyToLoad}</Path>
+                    </SdkResolver>");
+
+                SdkResolverLoader loader = new SdkResolverLoader();
+                var resolversManifestsFound = loader.FindPotentialSdkResolversManifests(root, new MockElementLocation("file"));
+
+                resolversManifestsFound.Count.ShouldBe(1);
+                resolversManifestsFound.First().Path.ShouldBe(assemblyToLoad);
+                resolversManifestsFound.First().ResolvableSdkRegex.ToString().ShouldBe("1<.*");
+            }
+        }
+
         [Fact]
         public void SdkResolverLoaderErrorsWithInvalidManifestFile()
         {
@@ -287,7 +346,7 @@ public void SdkResolverLoaderHonorsIncludeDefaultEnvVar()
                             resolvers.Add(new MockSdkResolverWithAssemblyPath(resolverPath));
                         }
                     };
-                    IList<SdkResolverBase> resolvers = loader.LoadResolvers(_loggingContext, new MockElementLocation("file"));
+                    IList<SdkResolverBase> resolvers = loader.LoadAllResolvers(_loggingContext, new MockElementLocation("file"));
 
                     resolvers.Count.ShouldBe(0);
                 }
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index 2b86246c83f..87d3efd618d 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -17,6 +17,8 @@
 using SdkResultBase = Microsoft.Build.Framework.SdkResult;
 using SdkResultFactoryBase = Microsoft.Build.Framework.SdkResultFactory;
 using SdkResultImpl = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
+using Microsoft.Build.Shared;
+using System.Text.RegularExpressions;
 
 #nullable disable
 
@@ -39,9 +41,10 @@ public SdkResolverService_Tests()
         }
 
         [Fact]
+        // Scenario: Sdk is not resolved.
         public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
         {
-            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
+            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
 
             SdkReference sdk = new SdkReference("notfound", "referencedVersion", "minimumVersion");
 
@@ -56,8 +59,10 @@ public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
 
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver2 running");
-            _logger.Errors.Select(i => i.Message).ShouldBe(new [] { "ERROR1", "ERROR2" });
-            _logger.Warnings.Select(i => i.Message).ShouldBe(new[] { "WARNING2" });
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern2 running");
+            _logger.Errors.Select(i => i.Message).ShouldBe(new [] { "ERROR4", "ERROR1", "ERROR2" });
+            _logger.Warnings.Select(i => i.Message).ShouldBe(new[] { "WARNING4", "WARNING2" });
         }
 
         [Fact]
@@ -99,7 +104,27 @@ public void AssertResolverThrows()
             e.Sdk.Name.ShouldBe("1sdkName");
         }
 
+
+        [Fact]
+        // Scenario: MockSdkResolverWithResolvableSdkPattern2 is a specific resolver (i.e. resolver with pattern)
+        // and it successfully resolves sdk.
+        public void AssertSecondResolverWithPatternCanResolve()
+        {
+            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
+
+            SdkReference sdk = new SdkReference("2sdkName", "referencedVersion", "minimumVersion");
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+
+            result.Path.ShouldBe("resolverpathwithresolvablesdkpattern2");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern2 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolver1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolver2 running");
+        }
+
         [Fact]
+        // Scenario: MockSdkResolverWithResolvableSdkPattern1 is a specific resolver, it is loaded but did not resolve sdk.
+        // MockSdkResolver1 is a general resolver (i.e. resolver without pattern), it resolves sdk on a fallback. 
         public void AssertFirstResolverCanResolve()
         {
             SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
@@ -110,6 +135,46 @@ public void AssertFirstResolverCanResolve()
 
             result.Path.ShouldBe("resolverpath1");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
+        }
+
+        [Fact]
+        // Scenario: MockSdkResolver1 has higher priority than MockSdkResolverWithResolvableSdkPattern1 and resolves sdk.
+        public void AssertFirstResolverWithPatternCantResolveChangeWave17_4()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_4.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
+
+                SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
+
+                var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+
+                result.Path.ShouldBe("resolverpath1");
+                _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
+                _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
+                ChangeWaves.ResetStateForTests();
+            }
+        }
+
+        [Fact]
+        // Scenario: MockSdkResolver1 has higher priority than MockSdkResolverWithResolvableSdkPattern1 but MockSdkResolverWithResolvableSdkPattern1 resolves sdk,
+        // becuase MockSdkResolver1 is general and MockSdkResolverWithResolvableSdkPattern1 is specific.
+        public void AssertFirstResolverWithPatternCanResolve()
+        {
+            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
+
+            SdkReference sdk = new SdkReference("11sdkName", "referencedVersion", "minimumVersion");
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+
+            result.Path.ShouldBe("resolverpathwithresolvablesdkpattern1");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolver1 running");
         }
 
         [Fact]
@@ -539,16 +604,27 @@ public void IsRunningInVisualStudioIsSetForResolverContext()
 
         private class MockLoaderStrategy : SdkResolverLoader
         {
-            private readonly bool _includeErrorResolver;
+            private List<SdkResolver> _resolvers;
+            private List<(string ResolvableSdkPattern, SdkResolver Resolver)> _resolversWithPatterns;
+
 
-            public MockLoaderStrategy(bool includeErrorResolver = false)
+            public MockLoaderStrategy(bool includeErrorResolver = false, bool includeResolversWithPatterns = false) : this()
             {
-                _includeErrorResolver = includeErrorResolver;
+                if (includeErrorResolver)
+                {
+                    _resolvers.Add(new MockSdkResolverThrows());
+                }
+
+                if (includeResolversWithPatterns)
+                {
+                    _resolversWithPatterns.Add(("1.*", new MockSdkResolverWithResolvableSdkPattern1()));
+                    _resolversWithPatterns.Add((".*", new MockSdkResolverWithResolvableSdkPattern2()));
+                }
             }
 
-            internal override IList<SdkResolver> LoadResolvers(LoggingContext loggingContext, ElementLocation location)
+            private MockLoaderStrategy()
             {
-                List<SdkResolver> resolvers = new List<SdkResolver>
+                _resolvers = new List<SdkResolver>
                 {
                     new MockSdkResolver1(),
                     new MockSdkResolver2(),
@@ -556,12 +632,58 @@ internal override IList<SdkResolver> LoadResolvers(LoggingContext loggingContext
                     new MockSdkResolverWithState()
                 };
 
-                if (_includeErrorResolver)
+                _resolversWithPatterns = new List<(string ResolvableSdkPattern, SdkResolver Resolver)>();
+            }
+
+            internal override IList<SdkResolver> LoadAllResolvers(LoggingContext loggingContext, ElementLocation location)
+            {
+                return _resolvers.OrderBy(i => i.Priority).ToList();
+            }
+
+            internal override IList<SdkResolverManifest> GetResolversManifests(LoggingContext loggingContext,
+            ElementLocation location)
+            {
+                var manifests = new List<SdkResolverManifest>();
+                foreach(SdkResolver resolver in _resolvers)
+                {
+                    SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(resolver.Name, null, null);
+                    manifests.Add(sdkResolverManifest);
+                }
+                foreach ((string ResolvableSdkPattern, SdkResolver Resolver) pair in _resolversWithPatterns)
+                {
+                    SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(
+                        pair.Resolver.Name,
+                        null,
+                        new Regex(pair.ResolvableSdkPattern, RegexOptions.Compiled | RegexOptions.CultureInvariant, TimeSpan.FromMilliseconds(500))
+                    );
+                    manifests.Add(sdkResolverManifest);
+                }
+                return manifests;
+            }
+
+            protected internal override IList<SdkResolver> LoadResolversFromManifest(SdkResolverManifest manifest, LoggingContext loggingContext, ElementLocation location)
+            {
+                var resolvers = new List<SdkResolver>();
+                foreach (var resolver in _resolvers)
+                {
+                    if (resolver.Name == manifest.DisplayName)
+                    {
+                        resolvers.Add(resolver);
+                    }
+                }
+                foreach (var pair in _resolversWithPatterns)
                 {
-                    resolvers.Add(new MockSdkResolverThrows());
+                    if (pair.Resolver.Name == manifest.DisplayName)
+                    {
+                        resolvers.Add(pair.Resolver);
+                    }
                 }
+                return resolvers.OrderBy(t => t.Priority).ToList();
+            }
 
-                return resolvers.OrderBy(i => i.Priority).ToList();
+            internal override IList<SdkResolver> GetDefaultResolvers(LoggingContext loggingContext, ElementLocation location)
+            {
+                return new List<SdkResolver>();
             }
         }
 
@@ -587,7 +709,7 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase r
                 if (sdk.Name.StartsWith("1"))
                     return factory.IndicateSuccess("resolverpath1", "version1");
 
-                return factory.IndicateFailure(new[] {"ERROR1"});
+                return factory.IndicateFailure(new[] { "ERROR1" });
             }
         }
 
@@ -608,6 +730,40 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase r
             }
         }
 
+        private class MockSdkResolverWithResolvableSdkPattern1 : SdkResolver
+        {
+            public override string Name => nameof(MockSdkResolverWithResolvableSdkPattern1);
+
+            public override int Priority => 2;
+
+            public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase resolverContext, SdkResultFactoryBase factory)
+            {
+                resolverContext.Logger.LogMessage("MockSdkResolverWithResolvableSdkPattern1 running", MessageImportance.Normal);
+
+                if (sdk.Name.StartsWith("11"))
+                    return factory.IndicateSuccess("resolverpathwithresolvablesdkpattern1", "version3");
+
+                return factory.IndicateFailure(new[] { "ERROR3" });
+            }
+        }
+
+        private class MockSdkResolverWithResolvableSdkPattern2 : SdkResolver
+        {
+            public override string Name => nameof(MockSdkResolverWithResolvableSdkPattern2);
+
+            public override int Priority => 0;
+
+            public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase resolverContext, SdkResultFactoryBase factory)
+            {
+                resolverContext.Logger.LogMessage("MockSdkResolverWithResolvableSdkPattern2 running", MessageImportance.Normal);
+
+                if (sdk.Name.StartsWith("2"))
+                    return factory.IndicateSuccess("resolverpathwithresolvablesdkpattern2", "version4", new[] { "WARNING4" });
+
+                return factory.IndicateFailure(new[] { "ERROR4" }, new[] { "WARNING4" });
+            }
+        }
+
         private class MockSdkResolverWithState : SdkResolver
         {
             public const string Expected = "01713226A202458F97D9074168DF2618";
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 64b62861d6f..a90afeabc38 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -16,6 +16,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -919,6 +920,8 @@ bool includeOutput2
         private static readonly DateTime New = new DateTime(2002, 1, 1);
 
         [Fact(Skip = "Creating a symlink on Windows requires elevation.")]
+        [SkipOnPlatform(TestPlatforms.AnyUnix, "Windows-specific test")]
+        [SupportedOSPlatform("windows")]
         public void NewSymlinkOldDestinationIsUpToDate()
         {
             SimpleSymlinkInputCheck(symlinkWriteTime: New,
@@ -928,6 +931,8 @@ public void NewSymlinkOldDestinationIsUpToDate()
         }
 
         [Fact(Skip = "Creating a symlink on Windows requires elevation.")]
+        [SkipOnPlatform(TestPlatforms.AnyUnix, "Windows-specific test")]
+        [SupportedOSPlatform("windows")]
         public void OldSymlinkOldDestinationIsUpToDate()
         {
             SimpleSymlinkInputCheck(symlinkWriteTime: Old,
@@ -937,6 +942,8 @@ public void OldSymlinkOldDestinationIsUpToDate()
         }
 
         [Fact(Skip = "Creating a symlink on Windows requires elevation.")]
+        [SkipOnPlatform(TestPlatforms.AnyUnix, "Windows-specific test")]
+        [SupportedOSPlatform("windows")]
         public void OldSymlinkNewDestinationIsNotUpToDate()
         {
             SimpleSymlinkInputCheck(symlinkWriteTime: Old,
@@ -946,6 +953,8 @@ public void OldSymlinkNewDestinationIsNotUpToDate()
         }
 
         [Fact(Skip = "Creating a symlink on Windows requires elevation.")]
+        [SkipOnPlatform(TestPlatforms.AnyUnix, "Windows-specific test")]
+        [SupportedOSPlatform("windows")]
         public void NewSymlinkNewDestinationIsNotUpToDate()
         {
             SimpleSymlinkInputCheck(symlinkWriteTime: Middle,
@@ -956,12 +965,15 @@ public void NewSymlinkNewDestinationIsNotUpToDate()
 
         [DllImport("kernel32.dll")]
         [return: MarshalAs(UnmanagedType.Bool)]
+        [SupportedOSPlatform("windows")]
         static extern bool CreateSymbolicLink(string lpSymlinkFileName, string lpTargetFileName, UInt32 dwFlags);
 
         [DllImport("kernel32.dll", SetLastError = true)]
+        [SupportedOSPlatform("windows")]
         private static extern bool SetFileTime(SafeFileHandle hFile, ref long creationTime,
             ref long lastAccessTime, ref long lastWriteTime);
 
+        [SupportedOSPlatform("windows")]
         private void SimpleSymlinkInputCheck(DateTime symlinkWriteTime, DateTime targetWriteTime,
             DateTime outputWriteTime, bool expectedOutOfDate)
         {
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index cb255f7ae9b..4f11a043242 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -1,12 +1,13 @@
 ï»¿using System;
 using System.Collections.Generic;
+using System.IO;
 using System.Text;
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
-
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -138,6 +139,46 @@ public void BinaryLoggerShouldSupportFilePathExplicitParameter()
             ObjectModelHelpers.BuildProjectExpectSuccess(s_testProject, binaryLogger);
         }
 
+        [Fact]
+        public void UnusedEnvironmentVariablesDoNotAppearInBinaryLog()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("MSBUILDONLYLOGUSEDENVIRONMENTVARIABLES", "1");
+                env.SetEnvironmentVariable("EnvVar1", "itsValue");
+                env.SetEnvironmentVariable("EnvVar2", "value2");
+                env.SetEnvironmentVariable("EnvVar3", "value3");
+                string contents = @"
+<Project DefaultTargets=""PrintEnvVar"">
+
+<PropertyGroup>
+<MyProp1>value</MyProp1>
+<MyProp2>$(EnvVar2)</MyProp2>
+</PropertyGroup>
+
+<Target Name=""PrintEnvVar"">
+<Message Text=""Environment variable EnvVar3 has value $(EnvVar3)"" Importance=""High"" />
+</Target>
+
+</Project>";
+                TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
+                TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
+                BinaryLogger logger = new();
+                logger.Parameters = _logFile;
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -bl:{logger.Parameters}", out bool success);
+                success.ShouldBeTrue();
+                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
+                success.ShouldBeTrue();
+                string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
+                text.ShouldContain("EnvVar2");
+                text.ShouldContain("value2");
+                text.ShouldContain("EnvVar3");
+                text.ShouldContain("value3");
+                text.ShouldNotContain("EnvVar1");
+                text.ShouldNotContain("itsValue");
+            }
+        }
+
         [Fact]
         public void BinaryLoggerShouldNotThrowWhenMetadataCannotBeExpanded()
         {
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 4ad1bb35cac..9b9deeef04a 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -24,30 +24,36 @@ public BuildEventArgsSerializationTests()
             _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
         }
 
-        [Fact]
-        public void RoundtripBuildStartedEventArgs()
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripBuildStartedEventArgs(bool serializeAllEnvironmentVariables)
         {
-            var args = new BuildStartedEventArgs(
-                "Message",
-                "HelpKeyword",
-                DateTime.Parse("3/1/2017 11:11:56 AM"));
-            Roundtrip(args,
-                e => e.Message,
-                e => e.HelpKeyword,
-                e => e.Timestamp.ToString());
-
-            args = new BuildStartedEventArgs(
-                "M",
-                null,
-                new Dictionary<string, string>
-                {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES", serializeAllEnvironmentVariables ? "1" : null);
+                var args = new BuildStartedEventArgs(
+                    "Message",
+                    "HelpKeyword",
+                    DateTime.Parse("3/1/2017 11:11:56 AM"));
+                Roundtrip(args,
+                    e => e.Message,
+                    e => e.HelpKeyword,
+                    e => e.Timestamp.ToString());
+
+                args = new BuildStartedEventArgs(
+                    "M",
+                    null,
+                    new Dictionary<string, string>
+                    {
                     { "SampleName", "SampleValue" }
-                });
-            Roundtrip(args,
-                e => TranslationHelpers.ToString(e.BuildEnvironment),
-                e => e.HelpKeyword,
-                e => e.ThreadId.ToString(),
-                e => e.SenderName);
+                    });
+                Roundtrip(args,
+                    e => serializeAllEnvironmentVariables ? TranslationHelpers.ToString(e.BuildEnvironment) : null,
+                    e => e.HelpKeyword,
+                    e => e.ThreadId.ToString(),
+                    e => e.SenderName);
+            }
         }
 
         [Fact]
@@ -173,6 +179,17 @@ public void RoundtripTaskStartedEventArgs()
                 e => e.ColumnNumber.ToString());
         }
 
+        [Fact]
+        public void RoundtripEnvironmentVariableReadEventArgs()
+        {
+            EnvironmentVariableReadEventArgs args = new("VarName", "VarValue");
+            args.BuildEventContext = new BuildEventContext(4, 5, 6, 7);
+            Roundtrip(args,
+                e => e.Message,
+                e => e.EnvironmentVariableName,
+                e => e.BuildEventContext.ToString());
+        }
+
         [Fact]
         public void RoundtripTaskFinishedEventArgs()
         {
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 1a44ce8fdb0..be8dfc1cdb2 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -20,6 +20,7 @@
 using Xunit;
 using Xunit.Abstractions;
 using Microsoft.Build.Execution;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -2461,6 +2462,7 @@ public void TestNewLineAfterProjectFinished()
         /// Check to see what kind of device we are outputting the log to, is it a character device, a file, or something else
         /// this can be used by loggers to modify their outputs based on the device they are writing to
         /// </summary>
+        [SupportedOSPlatform("windows")]
         internal bool IsRunningWithCharacterFileType()
         {
             // Get the std out handle
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 997e40b8c83..51d649107b5 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -4522,7 +4522,7 @@ public void VerifyMSBuildLogsAMessageWhenLocalPropertyCannotOverrideValueOfGloba
         [Fact]
         public void VerifyPropertyTrackingLoggingDefault()
         {
-            // Having nothing defined should default to nothing being logged.
+            // Having just environment variables defined should default to nothing being logged except one environment variable read.
             this.VerifyPropertyTrackingLoggingScenario(
                 null,
                 logger =>
@@ -4535,7 +4535,9 @@ public void VerifyPropertyTrackingLoggingDefault()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
@@ -4564,7 +4566,9 @@ public void VerifyPropertyTrackingLoggingPropertyReassignment()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
@@ -4593,7 +4597,9 @@ public void VerifyPropertyTrackingLoggingNone()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
@@ -4622,7 +4628,9 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
@@ -4706,7 +4714,9 @@ public void VerifyPropertyTrackingLoggingUninitializedPropertyRead()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldBeEmpty();
+                        .ShouldHaveSingleItem()
+                        .EnvironmentVariableName
+                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
 
                     logger
                         .AllBuildEvents
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 8d4d270e51b..e77a47e5ef4 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 using System.Text;
 using System.Xml;
 
@@ -1712,8 +1713,10 @@ public void RegistryPropertyInvalidPrefixError2()
             }
            );
         }
-#if FEATURE_WIN32_REGISTRY
+
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyString()
         {
             try
@@ -1735,6 +1738,8 @@ public void RegistryPropertyString()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyBinary()
         {
             try
@@ -1759,6 +1764,8 @@ public void RegistryPropertyBinary()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyDWord()
         {
             try
@@ -1780,6 +1787,8 @@ public void RegistryPropertyDWord()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyExpandString()
         {
             try
@@ -1802,6 +1811,8 @@ public void RegistryPropertyExpandString()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyQWord()
         {
             try
@@ -1823,6 +1834,8 @@ public void RegistryPropertyQWord()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyMultiString()
         {
             try
@@ -1842,7 +1855,6 @@ public void RegistryPropertyMultiString()
                 Registry.CurrentUser.DeleteSubKey(@"Software\Microsoft\MSBuild_test");
             }
         }
-#endif
 
         [Fact]
         public void TestItemSpecModiferEscaping()
@@ -3471,8 +3483,9 @@ public void PropertySimpleSpaced()
             Assert.Equal(String.Empty, result);
         }
 
-#if FEATURE_WIN32_REGISTRY
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegitryValue()
         {
             try
@@ -3496,6 +3509,8 @@ public void PropertyFunctionGetRegitryValue()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegitryValueDefault()
         {
             try
@@ -3519,6 +3534,8 @@ public void PropertyFunctionGetRegitryValueDefault()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegistryValueFromView1()
         {
             try
@@ -3542,6 +3559,8 @@ public void PropertyFunctionGetRegistryValueFromView1()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegistryValueFromView2()
         {
             try
@@ -3563,7 +3582,6 @@ public void PropertyFunctionGetRegistryValueFromView2()
                 Registry.CurrentUser.DeleteSubKey(@"Software\Microsoft\MSBuild_test");
             }
         }
-#endif
 
         /// <summary>
         /// Expand a property function that references item metadata
@@ -3901,12 +3919,10 @@ public void Medley()
             }
 #endif
 
-#if FEATURE_WIN32_REGISTRY
             if (NativeMethodsShared.IsWindows)
             {
                 errorTests.Add("$(Registry:X)");
             }
-#endif
 
             if (!NativeMethodsShared.IsWindows)
             {
diff --git a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
new file mode 100644
index 00000000000..f198b324c2c
--- /dev/null
+++ b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
@@ -0,0 +1,286 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text.RegularExpressions;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;
+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;
+
+#nullable disable
+
+namespace Microsoft.Build.Graph.UnitTests
+{
+    /// <summary>
+    /// Performs SetPlatform negotiation for all project references when opted
+    /// in via the EnableDynamicPlatformResolution property.
+    /// 
+    /// The static graph mirrors the negotiation during build to determine plartform for each node.
+    /// These tests mirror GetCompatiblePlatform_Tests.cs in order to make sure they both are in sync.
+    /// </summary>
+    public class ProjectGraphSetPlatformTests
+    {
+
+        [Fact]
+        public void ValidateSetPlatformOverride()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                    <SetPlatform>platform=x86</SetPlatform>
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                            <Platforms>x64;AnyCPU</Platforms>
+                                                        </PropertyGroup>
+                                                        <ItemGroup>
+                                                            <ProjectReference Include=""$(MSBuildThisFileDirectory)3.proj"" >
+                                                            </ProjectReference>
+                                                        </ItemGroup>
+                                                    </Project>");
+                var proj3 = env.CreateFile("3.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <Platforms>AnyCPU;x86</Platforms>
+                                                        </PropertyGroup>
+                                                    </Project>");
+
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+            }
+        }
+
+        [Fact]
+        public void ResolvesMultipleReferencesToSameProject()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" />
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)3.proj"" />
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                            <Platforms>AnyCPU</Platforms>
+                                                        </PropertyGroup>
+                                                        <ItemGroup>
+                                                            <ProjectReference Include=""$(MSBuildThisFileDirectory)3.proj"" />
+                                                        </ItemGroup>
+                                                    </Project>");
+
+                var proj3 = env.CreateFile("3.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <Platforms>AnyCPU</Platforms>
+                                                        </PropertyGroup>
+                                                    </Project>");
+
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("AnyCPU");
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstance.GlobalProperties["Platform"].ShouldBe("AnyCPU");
+                graph.ProjectNodes.Count.ShouldBe(3);
+            }
+        }
+
+        [Fact]
+        public void ResolvesViaPlatformLookupTable()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>win32</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <Platforms>x64;x86;AnyCPU</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+                
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x64");
+            }
+        }
+
+        [Fact]
+        public void ResolvesViaProjectReferencesPlatformLookupTable()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>win32</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <Platforms>x64;x86;AnyCPU</Platforms>
+                                                        <PlatformLookupTable>win32=x86</PlatformLookupTable>
+                                                    </PropertyGroup>
+                                                    </Project>");
+               
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+            }
+        }
+
+        [Fact]
+        public void ResolvesViaAnyCPUDefault()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x86</Platform>
+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <Platforms>x64;AnyCPU</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("AnyCPU");
+            }
+        }
+
+        [Fact]
+        public void ResolvesViaSamePlatform()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x86</Platform>
+                                                                                                <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <PlatformLookupTable></PlatformLookupTable>
+                                                        <Platforms>x86;x64;AnyCPU</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+             
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+            }
+        }
+
+        [Fact]
+        public void FailsToResolve()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x86</Platform>
+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <Platforms>x64</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+              
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                // Here we are checking if platform is defined. in this case it should not be since Platorm would be set to the value this project defaults as
+                // in order to avoid dual build errors we remove platform in order to avoid the edge case where a project has global platform set and does not have global platform set
+                // yet still default to the same platform.
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+            }
+        }
+
+        [Fact]
+        public void PlatformIsChosenAsDefault()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <platform>x64</platform>
+                                                        <Platforms>x86;AnyCPU</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+              
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GetPropertyValue("Platform").ShouldBe(GetFirstNodeWithProjectNumber(graph, 1).ProjectInstance.GetPropertyValue("Platform"));
+            }
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index c6f7af84e57..6159f3af2c1 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -22,6 +22,7 @@
 using System.Collections.Generic;
 using System.IO;
 using Xunit.Abstractions;
+using Shouldly;
 
 #nullable disable
 
@@ -80,55 +81,41 @@ public UtilitiesTestReadOnlyLoad()
         [Fact]
         public void CommentsInPreprocessing()
         {
-            Microsoft.Build.Construction.XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();
+            using TestEnvironment env = TestEnvironment.Create();
+            XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();
 
-            string input = FileUtilities.GetTemporaryFile();
-            string output = FileUtilities.GetTemporaryFile();
+            TransientTestFile inputFile = env.CreateFile("tempInput.tmp", ObjectModelHelpers.CleanupFileContents(@"
+<Project DefaultTargets='Build'>
+<Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets'/>
+</Project>"));
+            TransientTestFile outputFile = env.CreateFile("tempOutput.tmp");
 
-            string _initialLoadFilesWriteable = Environment.GetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE");
-            try
-            {
-                Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
-
-                string content = ObjectModelHelpers.CleanupFileContents(@"
-<Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
-  <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets'/>
-</Project>");
-                File.WriteAllText(input, content);
+            env.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
 
 #if FEATURE_GET_COMMANDLINE
-                Assert.Equal(MSBuildApp.ExitType.Success, MSBuildApp.Execute(@"c:\bin\msbuild.exe """ + input +
-                    (NativeMethodsShared.IsUnixLike ? @""" -pp:""" : @""" /pp:""") + output + @""""));
+            MSBuildApp.Execute(@"c:\bin\msbuild.exe """ + inputFile.Path +
+                (NativeMethodsShared.IsUnixLike ? @""" -pp:""" : @""" /pp:""") + outputFile.Path + @"""")
+                .ShouldBe(MSBuildApp.ExitType.Success);
 #else
-                Assert.Equal(
-                    MSBuildApp.ExitType.Success,
-                    MSBuildApp.Execute(
-                        new[] { @"c:\bin\msbuild.exe", '"' + input + '"',
-                    '"' + (NativeMethodsShared.IsUnixLike ? "-pp:" : "/pp:") + output + '"'}));
+            Assert.Equal(
+                MSBuildApp.ExitType.Success,
+                MSBuildApp.Execute(
+                    new[] { @"c:\bin\msbuild.exe", '"' + inputFile.Path + '"',
+                '"' + (NativeMethodsShared.IsUnixLike ? "-pp:" : "/pp:") + outputFile.Path + '"'}));
 #endif
 
-                bool foundDoNotModify = false;
-                foreach (string line in File.ReadLines(output))
+            bool foundDoNotModify = false;
+            foreach (string line in File.ReadLines(outputFile.Path))
+            {
+                line.ShouldNotContain("<!---->", "This is what it will look like if we're loading read/only");
+
+                if (line.Contains("DO NOT MODIFY")) // this is in a comment in our targets
                 {
-                    if (line.Contains("<!---->")) // This is what it will look like if we're loading read/only
-                    {
-                        Assert.True(false);
-                    }
-
-                    if (line.Contains("DO NOT MODIFY")) // this is in a comment in our targets
-                    {
-                        foundDoNotModify = true;
-                    }
+                    foundDoNotModify = true;
                 }
-
-                Assert.True(foundDoNotModify);
-            }
-            finally
-            {
-                File.Delete(input);
-                File.Delete(output);
-                Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", _initialLoadFilesWriteable);
             }
+
+            foundDoNotModify.ShouldBeTrue();
         }
 
         [Fact]
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 2f08099b333..6d6a42d2d88 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -8,7 +8,6 @@
 using System.Linq;
 using System.Reflection;
 using System.Threading;
-using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
@@ -1432,20 +1431,8 @@ private void LoggingEventProcessor(object loggingEvent)
         /// </summary>
         private void RouteBuildEvent(object loggingEvent)
         {
-            BuildEventArgs buildEventArgs = null;
-
-            if (loggingEvent is BuildEventArgs bea)
-            {
-                buildEventArgs = bea;
-            }
-            else if (loggingEvent is KeyValuePair<int, BuildEventArgs> kvp)
-            {
-                buildEventArgs = kvp.Value;
-            }
-            else
-            {
-                ErrorUtilities.ThrowInternalError("Unknown logging item in queue:" + loggingEvent.GetType().FullName);
-            }
+            BuildEventArgs buildEventArgs = loggingEvent as BuildEventArgs ?? (loggingEvent as KeyValuePair<int, BuildEventArgs>?)?.Value;
+            ErrorUtilities.VerifyThrow(buildEventArgs is not null, "Unknown logging item in queue:" + loggingEvent.GetType().FullName);
 
             if (buildEventArgs is BuildWarningEventArgs warningEvent)
             {
@@ -1541,7 +1528,7 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
             TryRaiseProjectStartedEvent(eventArg);
 
             // The event has not been through a filter yet. All events must go through a filter before they make it to a logger
-            if (_filterEventSource != null)   // Loggers may not be registered
+            if (_filterEventSource != null) // Loggers may not be registered
             {
                 // Send the event to the filter, the Consume will not return until all of the loggers which have registered to the event have process
                 // them.
@@ -1562,7 +1549,7 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
                         {
                             if (!sink.HaveLoggedBuildStartedEvent)
                             {
-                                sink.Consume(eventArg, (int)pair.Key);
+                                sink.Consume(eventArg, pair.Key);
                             }
 
                             // Reset the HaveLoggedBuildStarted event because no one else will be sending a build started event to any loggers at this time.
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 214a5118c2c..b9348623878 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -388,14 +388,11 @@ public void LogBuildStarted()
                 message = ResourceUtilities.GetResourceString("BuildStarted");
             }
 
-            IDictionary<string, string> environmentProperties = null;
+            IDictionary<string, string> environmentProperties = _componentHost?.BuildParameters != null && Traits.Instance.LogAllEnvironmentVariables ?
+                _componentHost.BuildParameters.BuildProcessEnvironment
+                : null;
 
-            if (_componentHost?.BuildParameters != null)
-            {
-                environmentProperties = _componentHost.BuildParameters.BuildProcessEnvironment;
-            }
-
-            BuildStartedEventArgs buildEvent = new BuildStartedEventArgs(message, null /* no help keyword */, environmentProperties);
+            BuildStartedEventArgs buildEvent = new(message, helpKeyword: null, environmentProperties);
 
             // Raise the event with the filters
             ProcessLoggingEvent(buildEvent);
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index bc39a5ccd32..b7f2fcf4bc2 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using static Microsoft.Build.Execution.ProjectPropertyInstance;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 #nullable disable
@@ -71,6 +72,17 @@ internal ProjectLoggingContext(
         {
         }
 
+        private IEnumerable<DictionaryEntry> FilterEnvironmentDerivedProperties(PropertyDictionary<ProjectPropertyInstance> properties)
+        {
+            foreach (ProjectPropertyInstance property in properties)
+            {
+                if (property is not EnvironmentDerivedProjectPropertyInstance)
+                {
+                    yield return new DictionaryEntry(property.Name, property.EvaluatedValue);
+                }
+            }
+        }
+
         /// <summary>
         /// Constructs a project logging contexts.
         /// </summary>
@@ -100,7 +112,19 @@ private ProjectLoggingContext(
                 !LoggingService.IncludeEvaluationPropertiesAndItems &&
                 (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
             {
-                properties = projectProperties?.GetCopyOnReadEnumerable(property => new DictionaryEntry(property.Name, property.EvaluatedValue)) ?? Enumerable.Empty<DictionaryEntry>();
+                if (projectProperties is null)
+                {
+                    properties = Enumerable.Empty<DictionaryEntry>();
+                }
+                else if (Traits.Instance.LogAllEnvironmentVariables)
+                {
+                    properties = projectProperties.GetCopyOnReadEnumerable(property => new DictionaryEntry(property.Name, property.EvaluatedValue));
+                }
+                else
+                {
+                    properties = FilterEnvironmentDerivedProperties(projectProperties);
+                }
+
                 items = projectItems?.GetCopyOnReadEnumerable(item => new DictionaryEntry(item.ItemType, new TaskItem(item))) ?? Enumerable.Empty<DictionaryEntry>();
             }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 505bc1d2df1..32b7c6b1b1a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -15,6 +15,7 @@
 using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
+using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -83,7 +84,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.KeepMetadata))
                             {
-                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation).ToList();
+                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation, LoggingContext).ToList();
                                 if (keepMetadataEvaluated.Count > 0)
                                 {
                                     keepMetadata = new HashSet<string>(keepMetadataEvaluated);
@@ -92,7 +93,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.RemoveMetadata))
                             {
-                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation).ToList();
+                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation, LoggingContext).ToList();
                                 if (removeMetadataEvaluated.Count > 0)
                                 {
                                     removeMetadata = new HashSet<string>(removeMetadataEvaluated);
@@ -101,7 +102,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.MatchOnMetadata))
                             {
-                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation).ToList();
+                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation, LoggingContext).ToList();
                                 if (matchOnMetadataEvaluated.Count > 0)
                                 {
                                     matchOnMetadata = new HashSet<string>(matchOnMetadataEvaluated);
@@ -114,7 +115,7 @@ internal override void ExecuteTask(Lookup lookup)
                                 (child.Exclude.Length != 0))
                             {
                                 // It's an item -- we're "adding" items to the world
-                                ExecuteAdd(child, bucket, keepMetadata, removeMetadata);
+                                ExecuteAdd(child, bucket, keepMetadata, removeMetadata, LoggingContext);
                             }
                             else if (child.Remove.Length != 0)
                             {
@@ -124,7 +125,7 @@ internal override void ExecuteTask(Lookup lookup)
                             else
                             {
                                 // It's a modify -- changing existing items
-                                ExecuteModify(child, bucket, keepMetadata, removeMetadata);
+                                ExecuteModify(child, bucket, keepMetadata, removeMetadata, LoggingContext);
                             }
                         }
                     }
@@ -150,7 +151,8 @@ internal override void ExecuteTask(Lookup lookup)
         /// <param name="bucket">The batching bucket.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
-        private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata)
+        /// <param name="loggingContext">Context for logging</param>
+        private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata, LoggingContext loggingContext = null)
         {
             // First, collect up the appropriate metadata collections.  We need the one from the item definition, if any, and
             // the one we are using for this batching bucket.
@@ -164,7 +166,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
             bucket.Expander.Metadata = metadataTable;
 
             // Second, expand the item include and exclude, and filter existing metadata as appropriate.
-            List<ProjectItemInstance> itemsToAdd = ExpandItemIntoItems(child, bucket.Expander, keepMetadata, removeMetadata);
+            List<ProjectItemInstance> itemsToAdd = ExpandItemIntoItems(child, bucket.Expander, keepMetadata, removeMetadata, loggingContext);
 
             // Third, expand the metadata.           
             foreach (ProjectItemGroupTaskMetadataInstance metadataInstance in child.Metadata)
@@ -179,11 +181,12 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     metadataInstance.Location,
                     LoggingContext.LoggingService,
                     LoggingContext.BuildEventContext,
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    loggingContext: loggingContext);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
 
                     // This both stores the metadata so we can add it to all the items we just created later, and 
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
@@ -245,7 +248,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
             List<ProjectItemInstance> itemsToRemove;
             if (matchOnMetadata == null)
             {
-                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander);
+                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander, LoggingContext);
             }
             else
             {
@@ -277,7 +280,8 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
         /// <param name="bucket">The batching bucket.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
-        private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata)
+        /// <param name="loggingContext">Context for this operation.</param>
+        private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata, LoggingContext loggingContext = null)
         {
             ICollection<ProjectItemInstance> group = bucket.Lookup.GetItems(child.ItemType);
             if (group == null || group.Count == 0)
@@ -317,11 +321,12 @@ private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     metadataInstance.ConditionLocation,
                     LoggingContext.LoggingService,
                     LoggingContext.BuildEventContext,
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    loggingContext: loggingContext);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
                     metadataToSet[metadataInstance.Name] = Lookup.MetadataModification.CreateFromNewValue(evaluatedValue);
                 }
             }
@@ -357,6 +362,7 @@ private void GetBatchableValuesFromBuildItemGroupChild(List<string> parameterVal
         /// <param name="expander">The expander to use.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
+        /// <param name="loggingContext">Context for logging</param>
         /// <remarks>
         /// This code is very close to that which exists in the Evaluator.EvaluateItemXml method.  However, because
         /// it invokes type constructors, and those constructors take arguments of fundamentally different types, it has not
@@ -368,7 +374,8 @@ private List<ProjectItemInstance> ExpandItemIntoItems
             ProjectItemGroupTaskItemInstance originalItem,
             Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
             ISet<string> keepMetadata,
-            ISet<string> removeMetadata
+            ISet<string> removeMetadata,
+            LoggingContext loggingContext = null
         )
         {
             // todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
@@ -376,7 +383,7 @@ ISet<string> removeMetadata
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
 
             // Expand properties and metadata in Include
-            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation);
+            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation, loggingContext);
 
             if (evaluatedInclude.Length == 0)
             {
@@ -387,7 +394,7 @@ ISet<string> removeMetadata
             var excludes = ImmutableList<string>.Empty.ToBuilder();
             if (originalItem.Exclude.Length > 0)
             {
-                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation);
+                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation, loggingContext);
 
                 if (evaluatedExclude.Length > 0)
                 {
@@ -516,13 +523,15 @@ ISet<string> removeMetadata
         /// <param name="specification">The specification to match against the items.</param>
         /// <param name="specificationLocation">The specification to match against the provided items</param>
         /// <param name="expander">The expander to use</param>
+        /// <param name="loggingContext">Context for logging</param>
         /// <returns>A list of matching items</returns>
         private List<ProjectItemInstance> FindItemsMatchingSpecification
             (
             ICollection<ProjectItemInstance> items,
             string specification,
             ElementLocation specificationLocation,
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
+            LoggingContext loggingContext = null
             )
         {
             if (items.Count == 0 || specification.Length == 0)
@@ -535,7 +544,7 @@ Expander<ProjectPropertyInstance, ProjectItemInstance> expander
             HashSet<string> specificationsToFind = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             // Split by semicolons
-            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation);
+            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation, loggingContext);
 
             foreach (string piece in specificationPieces)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 49a849c4313..e1479768ff2 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -353,7 +353,8 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 _target.ConditionLocation,
                 projectLoggingContext.LoggingService,
                 projectLoggingContext.BuildEventContext,
-                FileSystems.Default);
+                FileSystems.Default,
+                loggingContext: projectLoggingContext);
 
             if (!condition)
             {
@@ -392,7 +393,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 return new List<TargetSpecification>();
             }
 
-            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation);
+            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation, projectLoggingContext);
             List<TargetSpecification> dependencyTargets = new List<TargetSpecification>();
             foreach (string escapedDependency in dependencies)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index ec05dfd174f..4835778b4c1 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -381,7 +381,8 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 _targetChildInstance.ConditionLocation,
                 _targetLoggingContext.LoggingService,
                 _targetLoggingContext.BuildEventContext,
-                FileSystems.Default);
+                FileSystems.Default,
+                loggingContext: _targetLoggingContext);
 
             if (!condition)
             {
@@ -623,7 +624,7 @@ private void LogSkippedTask(ItemBucket bucket, TaskExecutionMode howToExecuteTas
                     if (!_targetLoggingContext.LoggingService.OnlyLogCriticalEvents)
                     {
                         // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation);
+                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation, loggingContext: _targetLoggingContext);
 
                         // Whilst we are within the processing of the task, we haven't actually started executing it, so
                         // our skip task message needs to be in the context of the target. However any errors should be reported
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 04b7ad67ed0..6e1e26c4258 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -67,11 +67,10 @@ public override void PacketReceived(int node, INodePacket packet)
 
             SdkResult response = null;
 
+            // Create an SdkReference from the request; the SdkReference constructor below never throws.
+            SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);
             try
             {
-                // Create an SdkReference from the request
-                SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);
-
                 ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
 
                 // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations
@@ -90,7 +89,7 @@ public override void PacketReceived(int node, INodePacket packet)
                 // Get the node manager and send the response back to the node that requested the SDK
                 INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;
 
-                nodeManager.SendData(request.NodeId, response);
+                nodeManager.SendData(request.NodeId, response ?? new SdkResult(sdkReference, null, null));
             }
         }
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index e6f1294b28d..0ccdd796da6 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -34,7 +34,16 @@ internal class SdkResolverLoader
 #endif
             ) ?? Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
 
-        internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
+        internal virtual IList<SdkResolver> GetDefaultResolvers(LoggingContext loggingContext, ElementLocation location)
+        {
+            var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ?
+                new List<SdkResolver> {new DefaultSdkResolver()}
+                : new List<SdkResolver>();
+
+            return resolvers;
+        }
+
+        internal virtual IList<SdkResolver> LoadAllResolvers(LoggingContext loggingContext,
             ElementLocation location)
         {
             var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ?
@@ -57,6 +66,13 @@ internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
             return resolvers.OrderBy(t => t.Priority).ToList();
         }
 
+        internal virtual IList<SdkResolverManifest> GetResolversManifests(LoggingContext loggingContext,
+            ElementLocation location)
+        {
+            return FindPotentialSdkResolversManifests(
+                Path.Combine(BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot, "SdkResolvers"), location);
+        }
+
         /// <summary>
         ///     Find all files that are to be considered SDK Resolvers. Pattern will match
         ///     Root\SdkResolver\(ResolverName)\(ResolverName).dll.
@@ -66,24 +82,44 @@ internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
         /// <returns></returns>
         internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, ElementLocation location)
         {
-            var assembliesList = new List<string>();
+            var manifestsList = FindPotentialSdkResolversManifests(rootFolder, location);
+
+            return manifestsList.Select(manifest => manifest.Path).ToList();
+        }
+
+        internal virtual IList<SdkResolverManifest> FindPotentialSdkResolversManifests(string rootFolder, ElementLocation location)
+        {
+            List<SdkResolverManifest> manifestsList = new List<SdkResolverManifest>();
 
             if ((string.IsNullOrEmpty(rootFolder) || !FileUtilities.DirectoryExistsNoThrow(rootFolder)) && AdditionalResolversFolder == null)
             {
-                return assembliesList;
+                return manifestsList;
             }
 
             DirectoryInfo[] subfolders = GetSubfolders(rootFolder, AdditionalResolversFolder);
 
             foreach (var subfolder in subfolders)
             {
-                var assembly = Path.Combine(subfolder.FullName, $"{subfolder.Name}.dll");
                 var manifest = Path.Combine(subfolder.FullName, $"{subfolder.Name}.xml");
+                var assembly = Path.Combine(subfolder.FullName, $"{subfolder.Name}.dll");
+                bool assemblyAdded = false;
 
-                var assemblyAdded = TryAddAssembly(assembly, assembliesList);
-                if (!assemblyAdded)
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                {
+                    // Prefer manifest over the assembly. Try to read the xml first, and if not found then look for an assembly.
+                    assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
+                    if (!assemblyAdded)
+                    {
+                        assemblyAdded = TryAddAssemblyManifestFromDll(assembly, manifestsList);
+                    }
+                }
+                else
                 {
-                    assemblyAdded = TryAddAssemblyFromManifest(manifest, subfolder.FullName, assembliesList, location);
+                    assemblyAdded = TryAddAssemblyManifestFromDll(assembly, manifestsList);
+                    if (!assemblyAdded)
+                    {
+                        assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
+                    }
                 }
 
                 if (!assemblyAdded)
@@ -92,7 +128,7 @@ internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, Elem
                 }
             }
 
-            return assembliesList;
+            return manifestsList;
         }
 
         private DirectoryInfo[] GetSubfolders(string rootFolder, string additionalResolversFolder)
@@ -133,25 +169,25 @@ public int GetHashCode(DirectoryInfo value)
             }
         }
 
-        private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)
+        private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List<SdkResolverManifest> manifestsList, ElementLocation location)
         {
             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;
 
-            string path = null;
-
+            SdkResolverManifest manifest = null;
             try
             {
                 // <SdkResolver>
                 //   <Path>...</Path>
+                //   <ResolvableSdkPattern>(Optional field)</ResolvableSdkPattern>
                 // </SdkResolver>
-                var manifest = SdkResolverManifest.Load(pathToManifest);
+                manifest = SdkResolverManifest.Load(pathToManifest);
 
                 if (manifest == null || string.IsNullOrEmpty(manifest.Path))
                 {
                     ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), "SdkResolverDllInManifestMissing", pathToManifest, string.Empty);
                 }
 
-                path = FileUtilities.FixFilePath(manifest.Path);
+                manifest.Path = FileUtilities.FixFilePath(manifest.Path);
             }
             catch (XmlException e)
             {
@@ -159,25 +195,27 @@ private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFo
                 ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), e, "SdkResolverManifestInvalid", pathToManifest, e.Message);
             }
 
-            if (!Path.IsPathRooted(path))
+            if (!Path.IsPathRooted(manifest.Path))
             {
-                path = Path.Combine(manifestFolder, path);
-                path = Path.GetFullPath(path);
+                manifest.Path = Path.Combine(manifestFolder, manifest.Path);
+                manifest.Path = Path.GetFullPath(manifest.Path);
             }
 
-            if (!TryAddAssembly(path, assembliesList))
+            if (string.IsNullOrEmpty(manifest.Path) || !FileUtilities.FileExistsNoThrow(manifest.Path))
             {
-                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), "SdkResolverDllInManifestMissing", pathToManifest, path);
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), "SdkResolverDllInManifestMissing", pathToManifest, manifest.Path);
             }
 
+            manifestsList.Add(manifest);
+
             return true;
         }
 
-        private bool TryAddAssembly(string assemblyPath, List<string> assembliesList)
+        private bool TryAddAssemblyManifestFromDll(string assemblyPath, List<SdkResolverManifest> manifestsList)
         {
             if (string.IsNullOrEmpty(assemblyPath) || !FileUtilities.FileExistsNoThrow(assemblyPath)) return false;
 
-            assembliesList.Add(assemblyPath);
+            manifestsList.Add(new SdkResolverManifest(DisplayName: assemblyPath, Path: assemblyPath, ResolvableSdkRegex: null));
             return true;
         }
 
@@ -198,6 +236,13 @@ protected virtual Assembly LoadResolverAssembly(string resolverPath, LoggingCont
 #endif
         }
 
+        protected internal virtual IList<SdkResolver> LoadResolversFromManifest(SdkResolverManifest manifest, LoggingContext loggingContext, ElementLocation location)
+        {
+            var resolvers = new List<SdkResolver>();
+            LoadResolvers(manifest.Path, loggingContext, location, resolvers);
+            return resolvers;
+        }
+
         protected virtual void LoadResolvers(string resolverPath, LoggingContext loggingContext, ElementLocation location, List<SdkResolver> resolvers)
         {
             Assembly assembly;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
index 295ec8d7877..f8d0baf5e71 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
@@ -1,5 +1,7 @@
 ï»¿using Microsoft.Build.Shared;
+using System;
 using System.IO;
+using System.Text.RegularExpressions;
 using System.Xml;
 
 #nullable disable
@@ -11,7 +13,43 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// </summary>
     internal class SdkResolverManifest
     {
-        internal string Path { get; set; }
+        private SdkResolverManifest()
+        {
+        }
+
+        public SdkResolverManifest(string DisplayName, string Path, Regex ResolvableSdkRegex)
+        {
+            this.DisplayName = DisplayName;
+            this.Path = Path;
+            this.ResolvableSdkRegex = ResolvableSdkRegex;
+        }
+
+        /// <summary>
+        /// Sdk resolver manifest display name.
+        /// </summary>
+        /// <remarks>
+        /// This field should be used only for logging purposes. Do not use for any actual processing, unless that are tests.
+        /// </remarks>
+        public string DisplayName { get; set; }
+
+        /// <summary>
+        /// Path for resolvers dll location.
+        /// </summary>
+        public string Path { get; set; }
+
+        /// <summary>
+        /// Regex which matches all the sdk names that could be resolved by the resolvers associated with given manifest.  
+        /// </summary>
+        public Regex ResolvableSdkRegex { get; set; }
+
+        /// <summary>
+        /// The time-out interval for the name pattern regex in milliseconds.
+        /// </summary>
+        /// <remarks>
+        /// This number should notify us when the name matching regex executes unreasonable amount of time (for example, have an infinite recursive regex expression).
+        /// One should avoid to put such a regex into a resolver's xml and we want to catch this situation early. Half a second seems to be a reasonable time in which regex should finish.
+        /// </remarks>
+        private const int SdkResolverPatternRegexTimeoutMsc = 500;
 
         /// <summary>
         /// Deserialize the file into an SdkResolverManifest.
@@ -35,7 +73,7 @@ internal static SdkResolverManifest Load(string filePath)
                 {
                     if (reader.NodeType == XmlNodeType.Element && reader.Name == "SdkResolver")
                     {
-                        return ParseSdkResolverElement(reader);
+                        return ParseSdkResolverElement(reader, filePath);
                     }
                     else
                     {
@@ -47,22 +85,43 @@ internal static SdkResolverManifest Load(string filePath)
             return null;
         }
 
-        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader)
+        // This parsing code is very specific and not forward compatible, but since resolvers generally ship in the same release vehicle as MSBuild itself, only backward compatibility is required.
+        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader, string filePath)
         {
             SdkResolverManifest manifest = new SdkResolverManifest();
+            manifest.DisplayName = filePath;
 
-            while (reader.Read())
+            reader.Read();
+            while (!reader.EOF)
             {
                 switch (reader.NodeType)
                 {
                     case XmlNodeType.Element:
                         {
-                            manifest.Path = reader.Name switch
+                            switch (reader.Name)
                             {
-                                "Path" => reader.ReadElementContentAsString(),
-                                _ => throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name)),
-                            };
+                                case "Path":
+                                    manifest.Path = reader.ReadElementContentAsString();
+                                    break;
+                                case "ResolvableSdkPattern":
+                                    string pattern = reader.ReadElementContentAsString();
+                                    try
+                                    {
+                                        manifest.ResolvableSdkRegex = new Regex(pattern, RegexOptions.Compiled | RegexOptions.CultureInvariant, TimeSpan.FromMilliseconds(SdkResolverPatternRegexTimeoutMsc));
+                                    }
+                                    catch (ArgumentException ex)
+                                    {
+                                        ErrorUtilities.ThrowInternalError("A regular expression parsing error occurred while parsing {0}.", ex, filePath);
+                                    }
+                                    break;
+                                default:
+                                    throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name));
+                            }
+                            break;
                         }
+
+                    case XmlNodeType.EndElement:
+                        reader.Read();
                         break;
 
                     default:
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index f6675ba42a5..c38afed1d3b 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -12,6 +12,8 @@
 using System.Collections.Generic;
 using System.Reflection;
 using Microsoft.Build.Eventing;
+using System.Linq;
+using System.Text.RegularExpressions;
 
 #nullable disable
 
@@ -41,7 +43,25 @@ internal class SdkResolverService : ISdkResolverService
         /// <summary>
         /// Stores the list of SDK resolvers which were loaded.
         /// </summary>
-        private IList<SdkResolver> _resolvers;
+        /// <remarks>
+        /// Need it for supporting the ChangeWave less than <see cref="ChangeWaves.Wave17_4"/>. Remove when move out Wave17_4.
+        /// </remarks>
+        private IList<SdkResolver> _resolversList;
+
+        /// <summary>
+        /// Stores the loaded SDK resolvers, mapped to the manifest from which they came.
+        /// </summary>
+        private Dictionary<SdkResolverManifest, IList<SdkResolver>> _manifestToResolvers;
+
+        /// <summary>
+        /// Stores the list of manifests of specific SDK resolvers which could be loaded.
+        /// </summary>
+        private IList<SdkResolverManifest> _specificResolversManifestsRegistry;
+
+        /// <summary>
+        /// Stores the list of manifests of general SDK resolvers which could be loaded.
+        /// </summary>
+        private IList<SdkResolverManifest> _generalResolversManifestsRegistry;
 
         /// <summary>
         /// Stores an <see cref="SdkResolverLoader"/> which can load registered SDK resolvers.
@@ -92,12 +112,147 @@ public virtual void ClearCaches()
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
-            // Lazy initialize the SDK resolvers
-            if (_resolvers == null)
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+            }
+            else
+            {
+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+            }
+        }
+
+        /// <remarks>
+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.
+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.
+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.
+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.
+        /// </remarks>
+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        {
+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)
+            {
+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);
+            }
+
+            // Pick up the matching specific resolvers from the list of resolvers.
+            List<SdkResolverManifest> matchingResolversManifests = new();
+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)
+            {
+                try
+                {
+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))
+                    {
+                        matchingResolversManifests.Add(manifest);
+                    }
+                }
+                catch (RegexMatchTimeoutException ex)
+                {
+                    ErrorUtilities.ThrowInternalError("Timeout exceeded matching sdk \"{0}\" to <ResolvableSdkPattern> from sdk resolver manifest {1}.", ex, sdk.Name, manifest.DisplayName);
+                }
+            }
+
+            List<SdkResolver> resolvers;
+            SdkResult sdkResult;
+            if (matchingResolversManifests.Count != 0)
+            {
+                // First pass.
+                resolvers = GetResolvers(matchingResolversManifests, loggingContext, sdkReferenceLocation);
+
+                if (TryResolveSdkUsingSpecifiedResolvers(
+                    resolvers,
+                    submissionId,
+                    sdk,
+                    loggingContext,
+                    sdkReferenceLocation,
+                    solutionPath,
+                    projectPath,
+                    interactive,
+                    isRunningInVisualStudio,
+                    out sdkResult))
+                {
+                    return sdkResult;
+                }
+            }
+
+            // Second pass: fallback to general resolvers. 
+            resolvers = GetResolvers(
+                _generalResolversManifestsRegistry,
+                loggingContext,
+                sdkReferenceLocation).ToList();
+
+            if (TryResolveSdkUsingSpecifiedResolvers(
+                resolvers,
+                submissionId,
+                sdk,
+                loggingContext,
+                sdkReferenceLocation,
+                solutionPath,
+                projectPath,
+                interactive,
+                isRunningInVisualStudio,
+                out sdkResult))
+            {
+                return sdkResult;
+            }
+
+            // No resolvers resolved the sdk.
+            return new SdkResult(sdk, null, null);
+        }
+
+        private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation)
+        {
+            // Create a sorted by priority list of resolvers. Load them if needed.
+            List<SdkResolver> resolvers = new List<SdkResolver>();
+            foreach (var resolverManifest in resolversManifests)
+            {
+                if (!_manifestToResolvers.TryGetValue(resolverManifest, out IList<SdkResolver> newResolvers))
+                {
+                    lock (_lockObject)
+                    {
+                        if (!_manifestToResolvers.TryGetValue(resolverManifest, out newResolvers))
+                        {
+                            // Loading of the needed resolvers.
+                            MSBuildEventSource.Log.SdkResolverServiceLoadResolversStart();
+                            newResolvers = _sdkResolverLoader.LoadResolversFromManifest(resolverManifest, loggingContext, sdkReferenceLocation);
+                            _manifestToResolvers[resolverManifest] = newResolvers;
+                            MSBuildEventSource.Log.SdkResolverServiceLoadResolversStop(resolverManifest.DisplayName, newResolvers.Count);
+                        }
+                    }
+                }
+
+                resolvers.AddRange(newResolvers);
+            }
+
+            resolvers.Sort((l, r) => l.Priority.CompareTo(r.Priority));
+            return resolvers;
+        }
+
+        private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        {
+            // Lazy initialize all SDK resolvers
+            if (_resolversList == null)
             {
                 Initialize(loggingContext, sdkReferenceLocation);
             }
 
+            TryResolveSdkUsingSpecifiedResolvers(
+                _resolversList,
+                submissionId,
+                sdk,
+                loggingContext,
+                sdkReferenceLocation,
+                solutionPath,
+                projectPath,
+                interactive,
+                isRunningInVisualStudio,
+                out SdkResult sdkResult);
+
+            return sdkResult;
+        }
+
+        private bool TryResolveSdkUsingSpecifiedResolvers(IList<SdkResolver> resolvers, int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, out SdkResult sdkResult)
+        {
             List<SdkResult> results = new List<SdkResult>();
 
             // Loop through resolvers which have already been sorted by priority, returning the first result that was successful
@@ -105,7 +260,7 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
 
             loggingContext.LogComment(MessageImportance.Low, "SdkResolving", sdk.ToString());
 
-            foreach (SdkResolver sdkResolver in _resolvers)
+            foreach (SdkResolver sdkResolver in resolvers)
             {
                 SdkResolverContext context = new SdkResolverContext(buildEngineLogger, projectPath, solutionPath, ProjectCollection.Version, interactive, isRunningInVisualStudio)
                 {
@@ -157,7 +312,8 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
                     // Associate the element location of the resolved SDK reference
                     result.ElementLocation = sdkReferenceLocation;
 
-                    return result;
+                    sdkResult = result;
+                    return true;
                 }
 
                 results.Add(result);
@@ -176,7 +332,8 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
                 }
             }
 
-            return new SdkResult(sdk, null, null);
+            sdkResult = new SdkResult(sdk, null, null);
+            return false;
         }
 
         /// <summary>
@@ -191,7 +348,28 @@ internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<
                 _sdkResolverLoader = resolverLoader;
             }
 
-            _resolvers = resolvers;
+            _specificResolversManifestsRegistry = null;
+            _generalResolversManifestsRegistry = null;
+            _manifestToResolvers = null;
+            _resolversList = null;
+
+            if (resolvers != null)
+            {
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                {
+                    _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
+                    _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
+                    _manifestToResolvers = new Dictionary<SdkResolverManifest, IList<SdkResolver>>();
+
+                    SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(DisplayName: "TestResolversManifest", Path: null, ResolvableSdkRegex: null);
+                    _generalResolversManifestsRegistry.Add(sdkResolverManifest);
+                    _manifestToResolvers[sdkResolverManifest] = resolvers;
+                }
+                else
+                {
+                    _resolversList = resolvers;
+                }
+            }
         }
 
         private static void LogWarnings(LoggingContext loggingContext, ElementLocation location, SdkResult result)
@@ -232,14 +410,58 @@ private void Initialize(LoggingContext loggingContext, ElementLocation location)
         {
             lock (_lockObject)
             {
-                if (_resolvers != null)
+                if (_resolversList != null)
                 {
                     return;
                 }
 
                 MSBuildEventSource.Log.SdkResolverServiceInitializeStart();
-                _resolvers = _sdkResolverLoader.LoadResolvers(loggingContext, location);
-                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolvers.Count);
+                _resolversList = _sdkResolverLoader.LoadAllResolvers(loggingContext, location);
+                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolversList.Count);
+            }
+        }
+
+        private void RegisterResolversManifests(LoggingContext loggingContext, ElementLocation location)
+        {
+            lock (_lockObject)
+            {
+                if (_specificResolversManifestsRegistry != null && _generalResolversManifestsRegistry != null)
+                {
+                    return;
+                }
+
+                MSBuildEventSource.Log.SdkResolverServiceFindResolversManifestsStart();
+                var allResolversManifests = _sdkResolverLoader.GetResolversManifests(loggingContext, location);
+
+                _manifestToResolvers = new Dictionary<SdkResolverManifest, IList<SdkResolver>>();
+
+                // Load and add the manifest for the default resolvers, located directly in this dll.
+                IList<SdkResolver> defaultResolvers = _sdkResolverLoader.GetDefaultResolvers(loggingContext, location);
+                if (defaultResolvers.Count > 0)
+                {
+                    MSBuildEventSource.Log.SdkResolverServiceLoadResolversStart();
+                    SdkResolverManifest sdkDefaultResolversManifest = new SdkResolverManifest(DisplayName: "DefaultResolversManifest", Path: null, ResolvableSdkRegex: null);
+                    allResolversManifests.Add(sdkDefaultResolversManifest);
+                    _manifestToResolvers[sdkDefaultResolversManifest] = defaultResolvers;
+                    MSBuildEventSource.Log.SdkResolverServiceLoadResolversStop(sdkDefaultResolversManifest.DisplayName, defaultResolvers.Count);
+                }
+
+                MSBuildEventSource.Log.SdkResolverServiceFindResolversManifestsStop(allResolversManifests.Count);
+
+                // Break the list of all resolvers manifests into two parts: manifests with specific and general resolvers.
+                _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
+                _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
+                foreach (SdkResolverManifest manifest in allResolversManifests)
+                {
+                    if (manifest.ResolvableSdkRegex == null)
+                    {
+                        _generalResolversManifestsRegistry.Add(manifest);
+                    }
+                    else
+                    {
+                        _specificResolversManifestsRegistry.Add(manifest);
+                    }
+                }
             }
         }
 
@@ -250,7 +472,9 @@ private void SetResolverState(int submissionId, SdkResolver resolver, object sta
             {
                 ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(
                     submissionId,
-                    _ => new ConcurrentDictionary<SdkResolver, object>(NativeMethodsShared.GetLogicalCoreCount(), _resolvers.Count));
+                    _ => new ConcurrentDictionary<SdkResolver, object>(
+                        NativeMethodsShared.GetLogicalCoreCount(),
+                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) ? _specificResolversManifestsRegistry.Count + _generalResolversManifestsRegistry.Count : _resolversList.Count));
 
                 resolverState.AddOrUpdate(resolver, state, (sdkResolver, obj) => state);
             }
diff --git a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
index 64da2af0c03..8f951bbcab3 100644
--- a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
+++ b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
@@ -164,10 +164,9 @@ private bool InternalEquals(ConfigurationMetadata other)
             {
                 return true;
             }
-
             return ProjectFullPath.Equals(other.ProjectFullPath, StringComparison.OrdinalIgnoreCase) &&
-                   ToolsVersion.Equals(other.ToolsVersion, StringComparison.OrdinalIgnoreCase) &&
-                   GlobalProperties.Equals(other.GlobalProperties);
+                ToolsVersion.Equals(other.ToolsVersion, StringComparison.OrdinalIgnoreCase) &&
+                GlobalProperties.Equals(other.GlobalProperties);
         }
 
         private string DebugString()
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index f3b18d6a93e..f757211cad0 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -1198,7 +1198,7 @@ out bool taskParameterSet
                 else
                 {
                     // Expand out all the metadata, properties, and item vectors in the string.
-                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation);
+                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation, _targetLoggingContext);
 
                     if (expandedParameterValue.Length == 0)
                     {
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 6fb05e271d0..294b523e07e 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2924,7 +2924,7 @@ public override bool SetGlobalProperty(string name, string escapedValue)
                     string originalValue = (existing == null) ? String.Empty : ((IProperty)existing).EvaluatedValueEscaped;
 
                     _data.GlobalPropertiesDictionary.Set(ProjectPropertyInstance.Create(name, escapedValue));
-                    _data.Properties.Set(ProjectProperty.Create(Owner, name, escapedValue, true /* is global */, false /* may not be reserved name */));
+                    _data.Properties.Set(ProjectProperty.Create(Owner, name, escapedValue, isGlobalProperty: true, mayBeReserved: false, loggingContext: null));
 
                     ProjectCollection.AfterUpdateLoadedProjectGlobalProperties(Owner);
                     MarkDirty();
@@ -4394,9 +4394,9 @@ public IItemDefinition<ProjectMetadata> GetItemDefinition(string itemType)
             /// <summary>
             /// Sets a property which is not derived from Xml.
             /// </summary>
-            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
+            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
             {
-                ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
+                ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext);
                 Properties.Set(property);
 
                 AddToAllEvaluatedPropertiesList(property);
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index b3e808c3c9a..157fc4366ec 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -3,8 +3,10 @@
 
 using System;
 using System.Diagnostics;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
@@ -94,7 +96,18 @@ public string EvaluatedValue
         string IProperty.EvaluatedValueEscaped
         {
             [DebuggerStepThrough]
-            get => EvaluatedValueEscapedInternal;
+            get
+            {
+                if (this is EnvironmentDerivedProjectProperty environmentProperty && environmentProperty.loggingContext is { IsValid: true } loggingContext && !environmentProperty._loggedEnvProperty)
+                {
+                    EnvironmentVariableReadEventArgs args = new(Name, EvaluatedValueEscapedInternal);
+                    args.BuildEventContext = loggingContext.BuildEventContext;
+                    loggingContext.LogBuildEvent(args);
+                    environmentProperty._loggedEnvProperty = true;
+                }
+
+                return EvaluatedValueEscapedInternal;
+            }
         }
 
         /// <summary>
@@ -237,9 +250,10 @@ bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
         /// This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
         /// All other properties originate in XML, and should have a backing XML object.
         /// </summary>
-        internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved)
+        internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext = null)
         {
-            return new ProjectPropertyNotXmlBacked(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
+            return !isGlobalProperty && !mayBeReserved ? new EnvironmentDerivedProjectProperty(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext) :
+                new ProjectPropertyNotXmlBacked(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
         }
 
         /// <summary>
@@ -628,5 +642,18 @@ public override bool IsImported
                 get { return false; }
             }
         }
+
+        private class EnvironmentDerivedProjectProperty : ProjectPropertyNotXmlBacked
+        {
+            internal bool _loggedEnvProperty = false;
+            internal LoggingContext loggingContext;
+
+            internal EnvironmentDerivedProjectProperty(
+                Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext)
+                : base(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved)
+            {
+                this.loggingContext = loggingContext;
+            }
+        }
     }
 }
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 3f8499f4264..8887b9cca2b 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -16,6 +16,7 @@
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
+using System.Runtime.CompilerServices;
 
 #nullable disable
 
@@ -128,10 +129,22 @@ ToolsetDefinitionLocations locations
                     configurationReader = new ToolsetConfigurationReader(environmentProperties, globalProperties);
                 }
 
-                // Accumulation of properties is okay in the config file because it's deterministically ordered
-                defaultToolsVersionFromConfiguration = configurationReader.ReadToolsets(toolsets, globalProperties,
-                    initialProperties, true /* accumulate properties */, out overrideTasksPathFromConfiguration,
-                    out defaultOverrideToolsVersionFromConfiguration);
+                ReadConfigToolset();
+
+                // This is isolated into its own function in order to isolate loading of
+                // System.Configuration.ConfigurationManager.dll to codepaths that really
+                // need it as a way of mitigating the need to update references to that
+                // assembly in API consumers.
+                //
+                // https://github.com/microsoft/MSBuildLocator/issues/159
+                [MethodImplAttribute(MethodImplOptions.NoInlining)]
+                void ReadConfigToolset()
+                {
+                    // Accumulation of properties is okay in the config file because it's deterministically ordered
+                    defaultToolsVersionFromConfiguration = configurationReader.ReadToolsets(toolsets, globalProperties,
+                                    initialProperties, true /* accumulate properties */, out overrideTasksPathFromConfiguration,
+                                    out defaultOverrideToolsVersionFromConfiguration);
+                }
             }
 
             string defaultToolsVersionFromRegistry = null;
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 31dd956ed2e..183ce5117d6 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -17,6 +17,7 @@ namespace Microsoft.Build.Evaluation
     using ElementLocation = Microsoft.Build.Construction.ElementLocation;
     using Microsoft.Build.Shared;
     using Microsoft.Build.Shared.FileSystem;
+    using Microsoft.Build.BackEnd.Logging;
 
     internal static class ConditionEvaluator
     {
@@ -181,7 +182,8 @@ internal static bool EvaluateCondition<P, I>
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null)
+            ProjectRootElementCacheBase projectRootElementCache = null,
+            LoggingContext loggingContext = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -196,7 +198,8 @@ internal static bool EvaluateCondition<P, I>
                 loggingServices,
                 buildEventContext,
                 fileSystem,
-                projectRootElementCache);
+                projectRootElementCache,
+                loggingContext);
         }
 
         /// <summary>
@@ -218,7 +221,8 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null
+            ProjectRootElementCacheBase projectRootElementCache = null,
+            LoggingContext loggingContext = null
         )
             where P : class, IProperty
             where I : class, IItem
@@ -279,7 +283,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             {
                 try
                 {
-                    result = parsedExpression.Evaluate(state);
+                    result = parsedExpression.Evaluate(state, loggingContext);
                 }
                 finally
                 {
@@ -353,7 +357,7 @@ internal interface IConditionEvaluationState
             ///     May return null if the expression would expand to non-empty and it broke out early.
             ///     Otherwise, returns the correctly expanded expression.
             /// </summary>
-            string ExpandIntoStringBreakEarly(string expression);
+            string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null);
 
             /// <summary>
             ///     Expands the specified expression into a list of TaskItem's.
@@ -363,7 +367,7 @@ internal interface IConditionEvaluationState
             /// <summary>
             ///     Expands the specified expression into a string.
             /// </summary>
-            string ExpandIntoString(string expression);
+            string ExpandIntoString(string expression, LoggingContext loggingContext = null);
 
             /// <summary>
             ///     PRE cache
@@ -440,11 +444,11 @@ internal ConditionEvaluationState
             /// May return null if the expression would expand to non-empty and it broke out early.
             /// Otherwise, returns the correctly expanded expression.
             /// </summary>
-            public string ExpandIntoStringBreakEarly(string expression)
+            public string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation);
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation, loggingContext);
 
                 _expander.WarnForUninitializedProperties = originalValue;
 
@@ -471,12 +475,13 @@ public IList<TaskItem> ExpandIntoTaskItems(string expression)
             /// Expands the specified expression into a string.
             /// </summary>
             /// <param name="expression">The expression to expand.</param>
+            /// <param name="loggingContext"></param>
             /// <returns>The expanded string.</returns>
-            public string ExpandIntoString(string expression)
+            public string ExpandIntoString(string expression, LoggingContext loggingContext = null)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation);
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation, loggingContext);
 
                 _expander.WarnForUninitializedProperties = originalValue;
 
diff --git a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
index 94513436e9c..47481c625c3 100644
--- a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
@@ -1,6 +1,7 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -18,9 +19,9 @@ internal sealed class AndExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                      state.ElementLocation,
@@ -37,7 +38,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                          state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index e0b57181361..4ec222243fd 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
@@ -29,7 +30,7 @@ internal FunctionCallExpressionNode(string functionName, List<GenericExpressionN
         /// <summary>
         /// Evaluate node as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             if (String.Equals(_functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index d6007133404..50efb172cf7 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -14,9 +14,9 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class GenericExpressionNode
     {
-        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result);
-        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result);
-        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result);
+        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null);
+        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null);
+        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null);
 
         /// <summary>
         /// Returns true if this node evaluates to an empty string,
@@ -25,7 +25,7 @@ internal abstract class GenericExpressionNode
         /// to empty than to fully evaluate it.)
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
+        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             return false;
         }
@@ -34,7 +34,7 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state);
+        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
 
         /// <summary>
         /// Value before any item and property expressions are expanded
@@ -52,16 +52,17 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// The main evaluate entry point for expression trees
         /// </summary>
         /// <param name="state"></param>
+        /// <param name="loggingContext"></param>
         /// <returns></returns>
-        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            if (!TryBoolEvaluate(state, out bool boolValue))
+            if (!TryBoolEvaluate(state, out bool boolValue, loggingContext))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ConditionNotBooleanDetail",
                     state.Condition,
-                    GetExpandedValue(state));
+                    GetExpandedValue(state, loggingContext));
             }
 
             return boolValue;
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index 65e23c7718f..1ef13748bdc 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -1,6 +1,7 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -36,7 +37,7 @@ internal abstract class MultipleComparisonNode : OperatorExpressionNode
         /// Order in which comparisons are attempted is numeric, boolean, then string.
         /// Updates conditioned properties table.
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext)
         {
             ProjectErrorUtilities.VerifyThrowInvalidProject
                 (LeftChild != null && RightChild != null,
@@ -50,8 +51,8 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // and we know which do, then we already have enough information to evaluate this expression.
             // That means we don't have to fully expand a condition like " '@(X)' == '' " 
             // which is a performance advantage if @(X) is a huge item list.
-            bool leftEmpty = LeftChild.EvaluatesToEmpty(state);
-            bool rightEmpty = RightChild.EvaluatesToEmpty(state);
+            bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);
+            bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);
             if (leftEmpty || rightEmpty)
             {
                 UpdateConditionedProperties(state);
@@ -68,13 +69,13 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                 // is 17.0).
                 return Compare(leftNumericValue, rightNumericValue);
             }
-            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue))
+            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue, loggingContext) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue, loggingContext))
             {
                 return Compare(leftBoolValue, rightBoolValue);
             }
 
-            string leftExpandedValue = LeftChild.GetExpandedValue(state);
-            string rightExpandedValue = RightChild.GetExpandedValue(state);
+            string leftExpandedValue = LeftChild.GetExpandedValue(state, loggingContext);
+            string rightExpandedValue = RightChild.GetExpandedValue(state, loggingContext);
 
             ProjectErrorUtilities.VerifyThrowInvalidProject
                 (leftExpandedValue != null && rightExpandedValue != null,
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index e5b00ac781a..1d2e1d6311e 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -1,6 +1,7 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -18,9 +19,9 @@ internal sealed class NotExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue))
+            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue, loggingContext))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
@@ -44,9 +45,9 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Returns expanded value with '!' prepended. Useful for error messages.
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            return "!" + LeftChild.GetExpandedValue(state);
+            return "!" + LeftChild.GetExpandedValue(state, loggingContext);
         }
 
         internal override string DebuggerDisplay => $"(not {LeftChild.DebuggerDisplay})";
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index 02c242ceef5..f161ad5d18b 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -38,7 +38,7 @@ internal abstract class NumericComparisonExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             bool isLeftNum = LeftChild.TryNumericEvaluate(state, out double leftNum);
             bool isLeftVersion = LeftChild.TryVersionEvaluate(state, out Version leftVersion);
@@ -53,7 +53,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     state.Condition,
                     /* helpfully display unexpanded token and expanded result in error message */
                     isLeftNum ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
-                    isLeftNum ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
+                    isLeftNum ? RightChild.GetExpandedValue(state, loggingContext) : LeftChild.GetExpandedValue(state, loggingContext));
             }
 
             return (isLeftNum, isLeftVersion, isRightNum, isRightVersion) switch
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index 66fa552443d..7725d9962dc 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -3,7 +3,7 @@
 
 using System;
 using System.Diagnostics;
-
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -23,18 +23,18 @@ internal NumericExpressionNode(string value)
             _value = value;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
         {
             return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
         {
             return Version.TryParse(_value, out result);
         }
@@ -50,7 +50,7 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Get the expanded value
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             return _value;
         }
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index c6e4b4c349c..a3f76ff20ff 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -12,21 +13,21 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class OperatorExpressionNode : GenericExpressionNode
     {
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
         {
-            result = BoolEvaluate(state);
+            result = BoolEvaluate(state, loggingContext);
             return true;
         }
 
-        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
+        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
         {
             result = default;
             return false;
@@ -36,7 +37,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             return null;
         }
diff --git a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
index 250e8c9602c..fa1816c2e1d 100644
--- a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
@@ -1,6 +1,7 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -18,15 +19,15 @@ internal sealed class OrExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ExpressionDoesNotEvaluateToBoolean",
                     LeftChild.GetUnexpandedValue(state),
-                    LeftChild.GetExpandedValue(state),
+                    LeftChild.GetExpandedValue(state, loggingContext),
                     state.Condition);
             }
 
@@ -37,7 +38,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                         state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 7017b0b5023..43dd324e7a8 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Diagnostics;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -30,34 +31,34 @@ internal StringExpressionNode(string value, bool expandable)
             _expandable = expandable;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
         {
-            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state), out result);
+            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state, loggingContext), out result);
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state))
+            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
             {
                 result = ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state), out result);
+                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state, loggingContext), out result);
             }
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state))
+            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
             {
                 result = Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return Version.TryParse(GetExpandedValue(state), out result);
+                return Version.TryParse(GetExpandedValue(state, loggingContext), out result);
             }
         }
 
@@ -68,7 +69,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// to empty than to fully evaluate it.
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             if (_cachedExpandedValue == null)
             {
@@ -93,7 +94,7 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
                             break;
                     }
 
-                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value);
+                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value, loggingContext);
 
                     if (expandBreakEarly == null)
                     {
@@ -129,13 +130,13 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             if (_cachedExpandedValue == null)
             {
                 if (_expandable)
                 {
-                    _cachedExpandedValue = state.ExpandIntoString(_value);
+                    _cachedExpandedValue = state.ExpandIntoString(_value, loggingContext);
                 }
                 else
                 {
@@ -168,7 +169,7 @@ internal override void ResetState()
         /// but now cause the project to throw InvalidProjectException when
         /// ToolsVersion is "Current". https://github.com/dotnet/msbuild/issues/4150
         /// </remarks>
-        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state)
+        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
         {
             if (!_shouldBeTreatedAsVisualStudioVersion.HasValue)
             {
@@ -176,7 +177,7 @@ private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionE
 
                 // Do this check first, because if it's not (common) we can early-out and the next
                 // expansion will be cheap because this will populate the cached expanded value.
-                if (string.Equals(GetExpandedValue(state), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
+                if (string.Equals(GetExpandedValue(state, loggingContext), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
                 {
                     // and it is just an expansion of MSBuildToolsVersion
                     _shouldBeTreatedAsVisualStudioVersion = string.Equals(_value, "$(MSBuildToolsVersion)", StringComparison.OrdinalIgnoreCase);
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index b3154221e9f..ebce24983ad 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using ObjectModel = System.Collections.ObjectModel;
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
@@ -25,13 +24,15 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
-using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
-using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
+using static Microsoft.Build.Execution.ProjectPropertyInstance;
 using Constants = Microsoft.Build.Internal.Constants;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
+using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
+using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
+using ObjectModel = System.Collections.ObjectModel;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using SdkReferencePropertyExpansionMode = Microsoft.Build.Framework.EscapeHatches.SdkReferencePropertyExpansionMode;
+using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 
 #nullable disable
 
@@ -811,13 +812,30 @@ private void Evaluate()
             if (this._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
             {
                 globalProperties = _data.GlobalPropertiesDictionary;
-                properties = _data.Properties;
+                properties = Traits.Instance.LogAllEnvironmentVariables ? _data.Properties : FilterOutEnvironmentDerivedProperties(_data.Properties);
                 items = _data.Items;
             }
 
             _evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, _evaluationProfiler.ProfiledResult);
         }
 
+        private IEnumerable FilterOutEnvironmentDerivedProperties(PropertyDictionary<P> dictionary)
+        {
+            List<P> list = new(dictionary.Count);
+            foreach (P p in dictionary)
+            {
+                if (p is EnvironmentDerivedProjectPropertyInstance ||
+                    (p is ProjectProperty pp && pp.IsEnvironmentProperty))
+                {
+                    continue;
+                }
+
+                list.Add(p);
+            }
+
+            return list;
+        }
+
         private void CollectProjectCachePlugins()
         {
             foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))
@@ -1051,8 +1069,8 @@ private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<Pr
         /// </summary>
         private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement, Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets, Dictionary<string, List<TargetSpecification>> targetsWhichRunBeforeByTarget, Dictionary<string, List<TargetSpecification>> targetsWhichRunAfterByTarget)
         {
-            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation);
-            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation);
+            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation, _evaluationLoggingContext);
+            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation, _evaluationLoggingContext);
 
             foreach (string beforeTarget in beforeTargets)
             {
@@ -1197,7 +1215,7 @@ private void AddEnvironmentProperties()
         {
             foreach (ProjectPropertyInstance environmentProperty in _environmentProperties)
             {
-                _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true);
+                _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true, loggingContext: _evaluationLoggingContext);
             }
         }
 
@@ -1298,7 +1316,7 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                 // it is the same as what we are setting the value on. Note: This needs to be set before we expand the property we are currently setting.
                 _expander.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
 
-                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location);
+                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location, _evaluationLoggingContext);
 
                 // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
                 // during evaluation.
@@ -2003,7 +2021,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
         {
             imports = null;
 
-            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
+            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation, _evaluationLoggingContext);
             ElementLocation importLocationInProject = importElement.Location;
 
             if (String.IsNullOrWhiteSpace(importExpressionEscaped))
@@ -2428,7 +2446,8 @@ private bool EvaluateCondition(ProjectElement element, string condition, Expande
                     element.ConditionLocation,
                     _evaluationLoggingContext.LoggingService,
                     _evaluationLoggingContext.BuildEventContext,
-                    _evaluationContext.FileSystem
+                    _evaluationContext.FileSystem,
+                    loggingContext: _evaluationLoggingContext
                     );
 
                 return result;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 46b24084309..88e5fea6c1b 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -19,15 +19,14 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-#if FEATURE_WIN32_REGISTRY
 using Microsoft.Win32;
-#endif
 using AvailableStaticMethods = Microsoft.Build.Internal.AvailableStaticMethods;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using TaskItemFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory;
 
 using Microsoft.NET.StringTools;
+using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -420,9 +419,9 @@ internal static bool ExpressionContainsItemVector(string expression)
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation)
+        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
         {
-            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation);
+            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext);
 
             return (result == null) ? null : EscapingUtilities.UnescapeAll(result);
         }
@@ -434,7 +433,7 @@ internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions o
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
+        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
         {
             if (expression.Length == 0)
             {
@@ -444,7 +443,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
+            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem, loggingContext);
             result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
 
@@ -474,11 +473,11 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
-        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
+        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
         {
             ErrorUtilities.VerifyThrow((options & ExpanderOptions.BreakOnNotEmpty) == 0, "not supported");
 
-            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation));
+            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext));
         }
 
         /// <summary>
@@ -1078,7 +1077,8 @@ internal static string ExpandPropertiesLeaveEscaped(
                 ExpanderOptions options,
                 IElementLocation elementLocation,
                 UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem)
+                IFileSystem fileSystem,
+                LoggingContext loggingContext = null)
             {
                 return
                     ConvertToString(
@@ -1088,7 +1088,8 @@ internal static string ExpandPropertiesLeaveEscaped(
                             options,
                             elementLocation,
                             usedUninitializedProperties,
-                            fileSystem));
+                            fileSystem,
+                            loggingContext));
             }
 
             /// <summary>
@@ -1114,7 +1115,8 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 ExpanderOptions options,
                 IElementLocation elementLocation,
                 UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem)
+                IFileSystem fileSystem,
+                LoggingContext loggingContext = null)
             {
                 if (((options & ExpanderOptions.ExpandProperties) == 0) || String.IsNullOrEmpty(expression))
                 {
@@ -1190,12 +1192,11 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         }
                         else if ((expression.Length - (propertyStartIndex + 2)) > 9 && tryExtractRegistryFunction && s_invariantCompareInfo.IndexOf(expression, "Registry:", propertyStartIndex + 2, 9, CompareOptions.OrdinalIgnoreCase) == propertyStartIndex + 2)
                         {
-                            // if FEATURE_WIN32_REGISTRY is off, treat the property value as if there's no Registry value at that location, rather than fail
                             propertyBody = expression.Substring(propertyStartIndex + 2, propertyEndIndex - propertyStartIndex - 2);
 
                             // If the property body starts with any of our special objects, then deal with them
                             // This is a registry reference, like $(Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation)
-                            propertyValue = ExpandRegistryValue(propertyBody, elementLocation); // This func returns an empty string if not FEATURE_WIN32_REGISTRY
+                            propertyValue = ExpandRegistryValue(propertyBody, elementLocation); // This func returns an empty string if not on Windows
                         }
 
                         // Compat hack: as a special case, $(HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0\VSTSDB@VSTSDBDirectory) should return String.Empty
@@ -1229,7 +1230,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         }
                         else // This is a regular property
                         {
-                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties);
+                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties, loggingContext);
                         }
 
                         if (propertyValue != null)
@@ -1467,7 +1468,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties, LoggingContext loggingContext = null)
             {
                 T property = properties.GetProperty(propertyName, startIndex, endIndex);
 
@@ -1512,6 +1513,11 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                 }
                 else
                 {
+                    if (property is ProjectPropertyInstance.EnvironmentDerivedProjectPropertyInstance environmentDerivedProperty)
+                    {
+                        environmentDerivedProperty.loggingContext = loggingContext;
+                    }
+
                     propertyValue = property.EvaluatedValueEscaped;
                 }
 
@@ -1571,7 +1577,6 @@ private static object ExpandMSBuildThisFileProperty(string propertyName, IElemen
                 return value;
             }
 
-#if FEATURE_WIN32_REGISTRY
             /// <summary>
             /// Given a string like "Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation", return the value at that location
             /// in the registry. If the value isn't found, returns String.Empty.
@@ -1582,6 +1587,16 @@ private static object ExpandMSBuildThisFileProperty(string propertyName, IElemen
             /// </summary>
             private static string ExpandRegistryValue(string registryExpression, IElementLocation elementLocation)
             {
+#if RUNTIME_TYPE_NETCORE
+                // .NET Core MSBuild used to always return empty, so match that behavior
+                // on non-Windows (no registry), and with a changewave (in case someone
+                // had a registry property and it breaks when it lights up).
+                if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                {
+                    return string.Empty;
+                }
+#endif
+
                 // Remove "Registry:" prefix
                 string registryLocation = registryExpression.Substring(9);
 
@@ -1655,15 +1670,6 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
 
                 return result;
             }
-#else
-            /// <summary>
-            /// Given a string like "Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation", returns String.Empty, as FEATURE_WIN32_REGISTRY is off.
-            /// </summary>
-            private static string ExpandRegistryValue(string registryExpression, IElementLocation elementLocation)
-            {
-                return String.Empty;
-            }
-#endif
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index cf0b17d457f..497207e7024 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -267,7 +267,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false);
+        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null);
 
         /// <summary>
         /// Sets a property which comes from the Xml.
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index bd073584157..ce0f37bbd56 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 using System.Text;
 using System.Text.RegularExpressions;
 
@@ -28,11 +29,11 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal static class IntrinsicFunctions
     {
-#if FEATURE_WIN32_REGISTRY
+#pragma warning disable CA1416 // Platform compatibility: we'll only use this on Windows
         private static readonly object[] DefaultRegistryViews = new object[] { RegistryView.Default };
+#pragma warning restore CA1416
 
         private static readonly Lazy<Regex> RegistrySdkRegex = new Lazy<Regex>(() => new Regex(@"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$", RegexOptions.IgnoreCase));
-#endif // FEATURE_WIN32_REGISTRY
 
         private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => new NuGetFrameworkWrapper());
 
@@ -164,12 +165,20 @@ internal static int BitwiseNot(int first)
             return ~first;
         }
 
-#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Get the value of the registry key and value, default value is null
         /// </summary>
         internal static object GetRegistryValue(string keyName, string valueName)
         {
+#if RUNTIME_TYPE_NETCORE
+            // .NET Core MSBuild used to always return empty, so match that behavior
+            // on non-Windows (no registry), and with a changewave (in case someone
+            // had a registry property and it breaks when it lights up).
+            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return null;
+            }
+#endif
             return Registry.GetValue(keyName, valueName, null /* null to match the $(Regsitry:XYZ@ZBC) behaviour */);
         }
 
@@ -178,11 +187,30 @@ internal static object GetRegistryValue(string keyName, string valueName)
         /// </summary>
         internal static object GetRegistryValue(string keyName, string valueName, object defaultValue)
         {
+#if RUNTIME_TYPE_NETCORE
+            // .NET Core MSBuild used to always return empty, so match that behavior
+            // on non-Windows (no registry), and with a changewave (in case someone
+            // had a registry property and it breaks when it lights up).
+            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return defaultValue;
+            }
+#endif
             return Registry.GetValue(keyName, valueName, defaultValue);
         }
 
         internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, params object[] views)
         {
+#if RUNTIME_TYPE_NETCORE
+            // .NET Core MSBuild used to always return empty, so match that behavior
+            // on non-Windows (no registry), and with a changewave (in case someone
+            // had a registry property and it breaks when it lights up).
+            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return defaultValue;
+            }
+#endif
+
             if (views == null || views.Length == 0)
             {
                 views = DefaultRegistryViews;
@@ -196,6 +224,16 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
         /// </summary>
         internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, ArraySegment<object> views)
         {
+#if RUNTIME_TYPE_NETCORE
+            // .NET Core MSBuild used to always return empty, so match that behavior
+            // on non-Windows (no registry), and with a changewave (in case someone
+            // had a registry property and it breaks when it lights up).
+            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return defaultValue;
+            }
+#endif
+
             // We will take on handing of default value
             // A we need to act on the null return from the GetValue call below
             // so we can keep searching other registry views
@@ -263,33 +301,6 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
             return result;
         }
 
-#else // FEATURE_WIN32_REGISTRY is off, need to mock the function names to let scrips call these property functions and get NULLs rather than fail with errors
-
-        /// <summary>
-        /// Get the value of the registry key and value, default value is null
-        /// </summary>
-        internal static object GetRegistryValue(string keyName, string valueName)
-        {
-            return null; // FEATURE_WIN32_REGISTRY is off, need to mock the function names to let scrips call these property functions and get NULLs rather than fail with errors
-        }
-
-        /// <summary>
-        /// Get the value of the registry key and value
-        /// </summary>
-        internal static object GetRegistryValue(string keyName, string valueName, object defaultValue)
-        {
-            return defaultValue; // FEATURE_WIN32_REGISTRY is off, need to mock the function names to let scrips call these property functions and get NULLs rather than fail with errors
-        }
-
-        /// <summary>
-        /// Get the value of the registry key from one of the RegistryView's specified
-        /// </summary>
-        internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, params object[] views)
-        {
-            return defaultValue; // FEATURE_WIN32_REGISTRY is off, need to mock the function names to let scrips call these property functions and get NULLs rather than fail with errors
-        }
-#endif
-
         /// <summary>
         /// Given the absolute location of a file, and a disc location, returns relative file path to that disk location.
         /// Throws UriFormatException.
@@ -595,7 +606,6 @@ internal static List<string> __GetListTest()
 
 #endregion
 
-#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Following function will parse a keyName and returns the basekey for it.
         /// It will also store the subkey name in the out parameter.
@@ -603,6 +613,7 @@ internal static List<string> __GetListTest()
         /// The return value shouldn't be null.
         /// Taken from: \ndp\clr\src\BCL\Microsoft\Win32\Registry.cs
         /// </summary>
+        [SupportedOSPlatform("windows")]
         private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView view, out string subKeyName)
         {
             if (keyName == null)
@@ -664,6 +675,5 @@ private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView vi
 
             return basekey;
         }
-#endif
     }
 }
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 65c1fd8b486..d7f58c8088a 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Globbing;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -156,21 +157,23 @@ private bool InitReferencedItemsIfNecessary()
         /// <param name="itemSpecLocation">The xml location the itemspec comes from</param>
         /// <param name="projectDirectory">The directory that the project is in.</param>
         /// <param name="expandProperties">Expand properties before breaking down fragments. Defaults to true</param>
+        /// <param name="loggingContext">Context in which to log</param>
         public ItemSpec(
             string itemSpec,
             Expander<P, I> expander,
             IElementLocation itemSpecLocation,
             string projectDirectory,
-            bool expandProperties = true)
+            bool expandProperties = true,
+            LoggingContext loggingContext = null)
         {
             ItemSpecString = itemSpec;
             Expander = expander;
             ItemSpecLocation = itemSpecLocation;
 
-            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties);
+            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties, loggingContext);
         }
 
-        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties)
+        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties, LoggingContext loggingContext)
         {
             // Code corresponds to Evaluator.CreateItemsFromInclude
             var evaluatedItemspecEscaped = ItemSpecString;
@@ -186,7 +189,8 @@ private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocat
                 evaluatedItemspecEscaped = Expander.ExpandIntoStringLeaveEscaped(
                     ItemSpecString,
                     ExpanderOptions.ExpandProperties,
-                    itemSpecLocation);
+                    itemSpecLocation,
+                    loggingContext);
             }
 
             var semicolonCount = 0;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 0255a8fbf2d..ecae588cd20 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
+using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -307,9 +308,9 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
                 return _wrappedData.SetProperty(propertyElement, evaluatedValueEscaped);
             }
 
-            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
+            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, LoggingContext loggingContext = null)
             {
-                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
+                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext: loggingContext);
             }
         }
     }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index f78cc28be71..f0c19a5c681 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -262,7 +262,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                                 continue;
                             }
 
-                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location);
+                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location, _lazyEvaluator._loggingContext);
                             evaluatedValue = FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath);
 
                             metadataTable.SetValue(metadataElement, evaluatedValue);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 28fe97350da..871ad820e6a 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -99,7 +99,8 @@ LazyItemEvaluator<P, I, M, D> lazyEvaluator
                     element.ConditionLocation,
                     lazyEvaluator._loggingContext.LoggingService,
                     lazyEvaluator._loggingContext.BuildEventContext,
-                    lazyEvaluator.FileSystem
+                    lazyEvaluator.FileSystem,
+                    loggingContext: lazyEvaluator._loggingContext
                     );
                 MSBuildEventSource.Log.EvaluateConditionStop(condition, result);
 
@@ -624,7 +625,7 @@ private RemoveOperation BuildRemoveOperation(string rootDirectory, ProjectItemEl
 
         private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLocation itemSpecLocation, OperationBuilder builder)
         {
-            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory);
+            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory, loggingContext: _loggingContext);
 
             foreach (ItemSpecFragment fragment in builder.ItemSpec.Fragments)
             {
@@ -635,7 +636,7 @@ private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLoca
             }
         }
 
-        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander)
+        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander, LoggingContext loggingContext = null)
         {
             // Since we're just attempting to expand properties in order to find referenced items and not expanding metadata,
             // unexpected errors may occur when evaluating property functions on unexpanded metadata. Just ignore them if that happens.
@@ -649,7 +650,8 @@ private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(IColle
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Value,
                     expanderOptions,
-                    metadatumElement.Location);
+                    metadatumElement.Location,
+                    loggingContext);
 
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Condition,
@@ -664,7 +666,7 @@ private void ProcessMetadataElements(ProjectItemElement itemElement, OperationBu
             {
                 operationBuilder.Metadata.AddRange(itemElement.Metadata);
 
-                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander));
+                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander, _loggingContext));
                 if (itemsAndMetadataFound.Items != null)
                 {
                     foreach (var itemType in itemsAndMetadataFound.Items)
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index da81aaf21b5..b113e73a6ec 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -79,10 +79,10 @@ public P GetProperty(string name, int startIndex, int endIndex)
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
+        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
         {
             P originalProperty = _wrapped.GetProperty(name);
-            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable);
+            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable, loggingContext);
 
             this.TrackPropertyWrite(
                 originalProperty,
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index c419203fb47..fd84214f2d7 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -546,8 +546,9 @@ private void SubmitProjectForParsing(ConfigurationMetadata projectToEvaluate)
         private List<ProjectInterpretation.ReferenceInfo> ParseReferences(ProjectGraphNode parsedProject)
         {
             var referenceInfos = new List<ProjectInterpretation.ReferenceInfo>();
+            
 
-            foreach (var referenceInfo in _projectInterpretation.GetReferences(parsedProject.ProjectInstance))
+            foreach (var referenceInfo in _projectInterpretation.GetReferences(parsedProject.ProjectInstance, _projectCollection, _projectInstanceFactory))
             {
                 if (FileUtilities.IsSolutionFilename(referenceInfo.ReferenceConfiguration.ProjectFullPath))
                 {
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 08e0e5a56b8..6284bfdf816 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -1,4 +1,4 @@
-ï»¿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -29,6 +29,10 @@ internal sealed class ProjectInterpretation
         private const string InnerBuildReferenceItemName = "_ProjectSelfReference";
         internal static string TransitiveReferenceItemName = "_TransitiveProjectReference";
         internal const string AddTransitiveProjectReferencesInStaticGraphPropertyName = "AddTransitiveProjectReferencesInStaticGraph";
+        private const string PlatformLookupTableMetadataName = "PlatformLookupTable";
+        private const string PlatformMetadataName = "Platform";
+        private const string PlatformsMetadataName = "Platforms";
+        private const string EnableDynamicPlatformResolutionMetadataName = "EnableDynamicPlatformResolution";
 
         private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
 
@@ -38,7 +42,7 @@ private ProjectInterpretation()
         {
         }
 
-        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();
+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] { (GlobalPropertiesModifier)ProjectReferenceGlobalPropertiesModifier }.ToImmutableList();
 
         internal enum ProjectType
         {
@@ -59,7 +63,7 @@ public ReferenceInfo(ConfigurationMetadata referenceConfiguration, ProjectItemIn
             }
         }
 
-        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance)
+        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection _projectCollection, ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory)
         {
             IEnumerable<ProjectItemInstance> projectReferenceItems;
             IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;
@@ -98,6 +102,32 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
 
                 var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReferenceItem, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);
 
+                var requesterPlatform = "";
+                var requesterPlatformLookupTable = "";
+
+                if ( !projectReferenceItem.HasMetadata(SetPlatformMetadataName) && ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
+                {
+                    requesterPlatform = requesterInstance.GetPropertyValue("Platform");
+                    requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
+
+                    var  projectInstance = _projectInstanceFactory(
+                        projectReferenceFullPath,
+                        null, // Platform negotiation requires an evaluation with no global properties first
+                        _projectCollection);
+
+                    var selectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformMetadataName), projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), requesterInstance.GetPropertyValue(PlatformLookupTableMetadataName), projectInstance.FullPath, requesterInstance.GetPropertyValue(PlatformMetadataName));
+
+                    if (selectedPlatform.Equals(String.Empty))
+                    {
+                        referenceGlobalProperties.Remove(PlatformMetadataName);
+                    }
+                    else
+                    {
+                        var platformPropertyInstance = ProjectPropertyInstance.Create(PlatformMetadataName, selectedPlatform);
+                        referenceGlobalProperties[PlatformMetadataName] = platformPropertyInstance;
+                    }
+                }
+
                 var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);
 
                 yield return new ReferenceInfo(referenceConfig, projectReferenceItem);
@@ -196,7 +226,7 @@ private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(Pr
                     project: outerBuild,
                     itemType: InnerBuildReferenceItemName,
                     includeEscaped: outerBuild.FullPath,
-                    directMetadata: new[] {new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}")},
+                    directMetadata: new[] { new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}") },
                     definingFileEscaped: outerBuild.FullPath);
             }
         }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 94344843b96..0237d7f0ad8 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -1475,10 +1475,10 @@ IItemDefinition<ProjectMetadataInstance> IEvaluatorData<ProjectPropertyInstance,
         /// immutable if we are immutable.
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
-        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable)
+        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable, LoggingContext loggingContext)
         {
             // Mutability not verified as this is being populated during evaluation
-            ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable);
+            ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable, isEnvironmentVariable, loggingContext);
             _properties.Set(property);
             return property;
         }
@@ -2966,7 +2966,7 @@ private void CreatePropertiesSnapshot(ICollection<ProjectProperty> properties, b
             {
                 // Allow reserved property names, since this is how they are added to the project instance. 
                 // The caller has prevented users setting them themselves.
-                ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable);
+                ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable, property.IsEnvironmentProperty);
                 _properties.Set(instance);
             }
         }
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index e935b611067..c6fd6293e5d 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -10,6 +10,8 @@
 using Microsoft.Build.BackEnd;
 
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -84,8 +86,21 @@ public string EvaluatedValue
         /// Setter assumes caller has protected global properties, if necessary.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        string IProperty.EvaluatedValueEscaped => _escapedValue;
-
+        string IProperty.EvaluatedValueEscaped
+        {
+            get
+            {
+                if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty)
+                {
+                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue);
+                    args.BuildEventContext = envProperty.loggingContext.BuildEventContext;
+                    envProperty.loggingContext.LogBuildEvent(args);
+                    envProperty._loggedEnvProperty = true;
+                }
+
+                return _escapedValue;
+            }
+        }
         /// <summary>
         /// Implementation of IKeyed exposing the property name
         /// </summary>
@@ -182,9 +197,9 @@ internal static ProjectPropertyInstance Create(string name, string escapedValue,
         /// This flags should ONLY be set by the evaluator or by cloning; after the ProjectInstance is created, they must be illegal.
         /// If name is invalid or reserved, throws ArgumentException.
         /// </summary>
-        internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable)
+        internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable, bool isEnvironmentProperty = false, LoggingContext loggingContext = null)
         {
-            return Create(name, escapedValue, mayBeReserved, null, isImmutable);
+            return Create(name, escapedValue, mayBeReserved, null, isImmutable, isEnvironmentProperty, loggingContext);
         }
 
         /// <summary>
@@ -212,7 +227,7 @@ internal static ProjectPropertyInstance Create(string name, string escapedValue,
         /// </summary>
         internal static ProjectPropertyInstance Create(ProjectPropertyInstance that)
         {
-            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: that.IsImmutable);
+            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: that.IsImmutable, that is EnvironmentDerivedProjectPropertyInstance);
         }
 
         /// <summary>
@@ -221,7 +236,7 @@ internal static ProjectPropertyInstance Create(ProjectPropertyInstance that)
         /// </summary>
         internal static ProjectPropertyInstance Create(ProjectPropertyInstance that, bool isImmutable)
         {
-            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: isImmutable);
+            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: isImmutable, that is EnvironmentDerivedProjectPropertyInstance);
         }
 
         /// <summary>
@@ -278,7 +293,7 @@ internal ProjectPropertyElement ToProjectPropertyElement(ProjectElementContainer
         /// as it should never be needed for any subsequent messages, and is just extra bulk.
         /// Inherits mutability from project if any.
         /// </summary>
-        private static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, ElementLocation location, bool isImmutable)
+        private static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, ElementLocation location, bool isImmutable, bool isEnvironmentProperty = false, LoggingContext loggingContext = null)
         {
             // Does not check immutability as this is only called during build (which is already protected) or evaluation
             ErrorUtilities.VerifyThrowArgumentNull(escapedValue, nameof(escapedValue));
@@ -295,11 +310,10 @@ private static ProjectPropertyInstance Create(string name, string escapedValue,
                 XmlUtilities.VerifyThrowProjectValidElementName(name, location);
             }
 
-            if (isImmutable)
-            {
-                return new ProjectPropertyInstanceImmutable(name, escapedValue);
-            }
-            return new ProjectPropertyInstance(name, escapedValue);
+            ProjectPropertyInstance instance = isEnvironmentProperty ? new EnvironmentDerivedProjectPropertyInstance(name, escapedValue, loggingContext) :
+                isImmutable ? new ProjectPropertyInstanceImmutable(name, escapedValue) :
+                new ProjectPropertyInstance(name, escapedValue);
+            return instance;
         }
 
         /// <summary>
@@ -327,5 +341,27 @@ internal ProjectPropertyInstanceImmutable(string name, string escapedValue)
             /// </remarks>
             public override bool IsImmutable => true;
         }
+
+        internal class EnvironmentDerivedProjectPropertyInstance : ProjectPropertyInstance
+        {
+            internal EnvironmentDerivedProjectPropertyInstance(string name, string escapedValue, LoggingContext loggingContext)
+                : base(name, escapedValue)
+            {
+                this.loggingContext = loggingContext;
+            }
+
+            /// <summary>
+            /// Whether this object can be changed. An immutable object cannot be made mutable.
+            /// </summary>
+            /// <remarks>
+            /// The environment is captured at the start of the build, so environment-derived
+            /// properties can't change.
+            /// </remarks>
+            public override bool IsImmutable => true;
+
+            internal bool _loggedEnvProperty = false;
+
+            internal LoggingContext loggingContext;
+        }
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index e9db5412a24..1089888ff12 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -4,18 +4,14 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Globalization;
 using System.IO;
-using System.Linq;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -251,7 +247,14 @@ private void Write(BuildStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.BuildStarted);
             WriteBuildEventArgsFields(e);
-            Write(e.BuildEnvironment);
+            if (Traits.Instance.LogAllEnvironmentVariables)
+            {
+                Write(e.BuildEnvironment);
+            }
+            else
+            {
+                Write(0);
+            }
         }
 
         private void Write(BuildFinishedEventArgs e)
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index b0d0c7eb7b3..4c147958cb5 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1204,16 +1204,21 @@ private void DisplayDeferredStartedEvents(BuildEventContext e)
         /// </summary>
         private void PrintMessage(BuildMessageEventArgs e, bool lightenText)
         {
-            string nonNullMessage;
+            string nonNullMessage = null;
+
+            if (e is EnvironmentVariableReadEventArgs environmentPropertyReadEventArgs)
+            {
+                nonNullMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentPropertyReadEventArgs.EnvironmentVariableName, e.Message);
+            }
 
             // Include file information if present.
             if (e.File != null)
             {
-                nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e));
+                nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e), nonNullMessage);
             }
             else
             {
-                nonNullMessage = e.Message ?? string.Empty;
+                nonNullMessage ??= e.Message ?? string.Empty;
             }
 
             int prefixAdjustment = 0;
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index e677526406b..4404357b05e 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -511,18 +511,15 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                     setColor(ConsoleColor.DarkGray);
                 }
 
-                string nonNullMessage;
+                string nonNullMessage = e is EnvironmentVariableReadEventArgs environmentDerivedProperty ?
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentDerivedProperty.EnvironmentVariableName, e.Message)
+                    : e.Message ?? String.Empty;
 
                 // Include file information if present.
                 if (e.File != null)
                 {
                     nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile);
                 }
-                else
-                {
-                    // null messages are ok -- treat as blank line
-                    nonNullMessage = e.Message ?? String.Empty;
-                }
 
                 WriteLinePretty(nonNullMessage);
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 0101a829b26..309d14bdc83 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -121,6 +121,10 @@
     <Compile Include="..\Shared\NodeShutdown.cs" />
     <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\ProcessExtensions.cs" />
+    <Compile Include="..\Shared\PlatformNegotiation.cs">
+      <Link>PlatformNegotiation.cs</Link>
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="..\Shared\TaskLoggingHelper.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\TaskLoggingHelper.cs</Link>
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 10018e5f8f1..db8651cce57 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -142,6 +142,9 @@
   <data name="WaitingForEndOfBuild" xml:space="preserve">
     <value>The operation cannot be completed because EndBuild has already been called but existing submissions have not yet completed.</value>
   </data>
+  <data name="EnvironmentDerivedPropertyRead">
+    <value>Property '{0}' with value '{1}' expanded from the environment.</value>
+  </data>
   <data name="SubmissionAlreadyComplete" xml:space="preserve">
     <value>The operation cannot be completed because the submission has already been executed.</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index bc4f28a26e1..295e744c203 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: ZadanÃ½ vÃ½stupnÃ­ soubor mezipamÄti pro vÃ½sledky je prÃ¡zdnÃ½.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">ÄÃ­st promÄnnou prostÅedÃ­ {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 2d5371cd4e4..354bbd025b6 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: Die angegebene Cachedatei fÃ¼r Ausgabeergebnisse ist leer.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Umgebungsvariable "{0}" lesen</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index ae8a6a1e189..0ff85f2cfc1 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: El archivo de cachÃ© de resultados de salida especificado estÃ¡ vacÃ­o.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Leer la variable de entorno "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 0ffddfbe011..bd86334a1d6 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: Le fichier cache des rÃ©sultats de sortie spÃ©cifiÃ© est vide.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Lire la variable d'environnement "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 11aec49efc6..b3ffd7d5a8f 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: il file della cache dei risultati di output specificato Ã¨ vuoto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Legge la variabile di ambiente "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 1bf7a2f0d24..20194a207f9 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: æå®ãããåºåçµæã­ã£ãã·ã¥ ãã¡ã¤ã«ã¯ç©ºã§ãã</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">ç°å¢å¤æ° "{0}" ã®èª­ã¿åã</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 8f5d34f5cce..64edef66ee4 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: ì§ì í ì¶ë ¥ ê²°ê³¼ ìºì íì¼ì´ ë¹ì´ ììµëë¤.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">íê²½ ë³ì "{0}" ì½ê¸°</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b893482a44e..ef425e1af33 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: OkreÅlony plik wyjÅciowej pamiÄci podrÄcznej wynikÃ³w jest pusty.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Odczytaj zmiennÄ ÅrodowiskowÄ â{0}â</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index ad14ba37ca1..57edd51b8b6 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: o arquivo de cache do resultado de saÃ­da especificado estÃ¡ vazio.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Ler a variÃ¡vel de ambiente "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 04004fbdfe1..9355b218d8e 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¹ Ð²ÑÑÐ¾Ð´Ð½Ð¾Ð¹ ÑÐ°Ð¹Ð» ÐºÑÑÐ° ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ¾Ð² Ð¿ÑÑÑÐ¾Ð¹.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Ð§ÑÐµÐ½Ð¸Ðµ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ ÑÑÐµÐ´Ñ "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 5fc8f54ba4e..439af5cefad 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: Belirtilen Ã§Ä±kÄ±Å sonucu Ã¶nbellek dosyasÄ± boÅ.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">"{0}" ortam deÄiÅkenini oku</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 4a9d18a374e..ca550fb5c8d 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: æå®çè¾åºç»æç¼å­æä»¶ä¸ºç©ºã</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">è¯»åç¯å¢åéâ{0}â</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 214240db01c..f1f0c28e519 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -102,6 +102,11 @@
         <target state="translated">MSB4257: æå®çè¼¸åºçµæå¿«åæªæ¡æ¯ç©ºçã</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentDerivedPropertyRead">
+        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
+        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">è®åç°å¢è®æ¸ "{0}"</target>
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index e273cd9bc81..6696e3861ba 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -87,7 +87,6 @@
   <PropertyGroup Condition="'$(NetCoreBuild)'=='true'">
     <CompilerToolsDir>$([System.IO.Path]::Combine($(ToolPackagesDir)Microsoft.Net.Compilers, $(CompilerToolsVersion), "tools"))$([System.IO.Path]::DirectorySeparatorChar)</CompilerToolsDir>
     <DefineConstants>$(DefineConstants);FEATURE_ASSEMBLYLOADCONTEXT</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_PROCESSSTARTINFO_ENVIRONMENT</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_RUNTIMEINFORMATION</DefineConstants>
     <DefineConstants>$(DefineConstants);USE_MSBUILD_DLL_EXTN</DefineConstants>
     <DefineConstants>$(DefineConstants);WORKAROUND_COREFX_19110</DefineConstants>
diff --git a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
index 2bf43e98406..eca867cd1cc 100644
--- a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
@@ -27,7 +27,7 @@ public void EventArgsCtors()
             buildFinishedEvent = new BuildFinishedEventArgs("{0}", "HelpKeyword", true, new DateTime(), "Message");
             buildFinishedEvent = new BuildFinishedEventArgs(null, null, true);
             buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime());
-            buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime(), null);
+            buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime(), messageArgs: null);
         }
 
         /// <summary>
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index f1d6104ff4e..e169219952d 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -600,27 +600,51 @@ public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStop(int submis
         }
 
         [Event(81, Keywords = Keywords.All)]
-        public void CreateLoadedTypeStart(string assemblyName)
+        public void SdkResolverServiceFindResolversManifestsStart()
         {
-            WriteEvent(81, assemblyName);
+            WriteEvent(81);
         }
 
         [Event(82, Keywords = Keywords.All)]
-        public void CreateLoadedTypeStop(string assemblyName)
+        public void SdkResolverServiceFindResolversManifestsStop(int resolverManifestCount)
         {
-            WriteEvent(82, assemblyName);
+            WriteEvent(82, resolverManifestCount);
         }
 
         [Event(83, Keywords = Keywords.All)]
-        public void LoadAssemblyAndFindTypeStart()
+        public void SdkResolverServiceLoadResolversStart()
         {
             WriteEvent(83);
         }
 
         [Event(84, Keywords = Keywords.All)]
+        public void SdkResolverServiceLoadResolversStop(string manifestName, int resolverCount)
+        {
+            WriteEvent(84, manifestName, resolverCount);
+        }
+
+        [Event(85, Keywords = Keywords.All)]
+        public void CreateLoadedTypeStart(string assemblyName)
+        {
+            WriteEvent(85, assemblyName);
+        }
+
+        [Event(86, Keywords = Keywords.All)]
+        public void CreateLoadedTypeStop(string assemblyName)
+        {
+            WriteEvent(86, assemblyName);
+        }
+
+        [Event(87, Keywords = Keywords.All)]
+        public void LoadAssemblyAndFindTypeStart()
+        {
+            WriteEvent(87);
+        }
+
+        [Event(88, Keywords = Keywords.All)]
         public void LoadAssemblyAndFindTypeStop(string assemblyPath, int numberOfPublicTypesSearched)
         {
-            WriteEvent(84, assemblyPath, numberOfPublicTypesSearched);
+            WriteEvent(88, assemblyPath, numberOfPublicTypesSearched);
         }
 
         #endregion
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 9e68fc71c4e..bb17186086f 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -237,6 +237,8 @@ internal class SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid
         private SafeProcessHandle() : base(true)
         {
         }
+
+        [SupportedOSPlatform("windows")]
         protected override bool ReleaseHandle()
         {
             return CloseHandle(handle);
@@ -254,7 +256,7 @@ internal class MemoryStatus
         /// </summary>
         public MemoryStatus()
         {
-#if (CLR2COMPATIBILITY)
+#if CLR2COMPATIBILITY
             _length = (uint)Marshal.SizeOf(typeof(MemoryStatus));
 #else
             _length = (uint)Marshal.SizeOf<MemoryStatus>();
@@ -530,6 +532,7 @@ public static int GetLogicalCoreCount()
     /// as Environment.ProcessorCount has a 32-core limit in that case.
     /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210
     /// </summary>
+    [SupportedOSPlatform("windows")]
     private unsafe static int GetLogicalCoreCountOnWindows()
     {
         uint len = 0;
@@ -718,10 +721,7 @@ internal static bool IsWindows
 #else
         get
         {
-            if (_isWindows == null)
-            {
-                _isWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
-            }
+            _isWindows ??= RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
             return _isWindows.Value;
         }
 #endif
@@ -741,10 +741,7 @@ internal static bool IsOSX
 #else
         get
         {
-            if (_isOSX == null)
-            {
-                _isOSX = RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
-            }
+            _isOSX ??= RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
             return _isOSX.Value;
         }
 #endif
@@ -869,21 +866,17 @@ private static SystemInformationData SystemInformation
 
 #region Wrapper methods
 
-    /// <summary>
-    /// Really truly non pumping wait.
-    /// Raw IntPtrs have to be used, because the marshaller does not support arrays of SafeHandle, only
-    /// single SafeHandles.
-    /// </summary>
-    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
-    public static extern Int32 WaitForMultipleObjects(uint handle, IntPtr[] handles, bool waitAll, uint milliseconds);
 
     [DllImport("kernel32.dll", SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern void GetSystemInfo(ref SYSTEM_INFO lpSystemInfo);
 
     [DllImport("kernel32.dll", SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern void GetNativeSystemInfo(ref SYSTEM_INFO lpSystemInfo);
 
     [DllImport("kernel32.dll", SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, IntPtr Buffer, ref uint ReturnedLength);
 
     /// <summary>
@@ -973,6 +966,7 @@ internal static string GetShortFilePath(string path)
     /// </summary>
     /// <param name="path"></param>
     /// <returns></returns>
+    [SupportedOSPlatform("windows")]
     internal static string GetLongFilePath(string path)
     {
         if (IsUnixLike)
@@ -1112,6 +1106,7 @@ DateTime LastWriteFileUtcTime(string path)
     /// This is the most accurate timestamp-extraction mechanism, but it is too slow to use all the time.
     /// See https://github.com/dotnet/msbuild/issues/2052.
     /// </remarks>
+    [SupportedOSPlatform("windows")]
     private static DateTime GetContentLastWriteFileUtcTime(string fullPath)
     {
         DateTime fileModifiedTime = DateTime.MinValue;
@@ -1179,6 +1174,7 @@ public static void ThrowExceptionForErrorCode(int errorCode)
     /// <summary>
     /// Kills the specified process by id and all of its children recursively.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     internal static void KillTree(int processIdToKill)
     {
         // Note that GetProcessById does *NOT* internally hold on to the process handle.
@@ -1257,6 +1253,7 @@ internal static void KillTree(int processIdToKill)
     /// Returns the parent process id for the specified process.
     /// Returns zero if it cannot be gotten for some reason.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     internal static int GetParentProcessId(int processId)
     {
         int ParentID = 0;
@@ -1327,6 +1324,7 @@ internal static int GetParentProcessId(int processId)
     /// Returns an array of all the immediate child processes by id.
     /// NOTE: The IntPtr in the tuple is the handle of the child process.  CloseHandle MUST be called on this.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     internal static List<KeyValuePair<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime)
     {
         List<KeyValuePair<int, SafeProcessHandle>> myChildren = new List<KeyValuePair<int, SafeProcessHandle>>();
@@ -1391,6 +1389,7 @@ internal unsafe static string GetCurrentDirectory()
         return Directory.GetCurrentDirectory();
     }
 
+    [SupportedOSPlatform("windows")]
     private unsafe static int GetCurrentDirectoryWin32(int nBufferLength, char* lpBuffer)
     {
         int pathLength = GetCurrentDirectory(nBufferLength, lpBuffer);
@@ -1398,6 +1397,7 @@ private unsafe static int GetCurrentDirectoryWin32(int nBufferLength, char* lpBu
         return pathLength;
     }
 
+    [SupportedOSPlatform("windows")]
     internal unsafe static string GetFullPath(string path)
     {
         int bufferSize = GetFullPathWin32(path, 0, null, IntPtr.Zero);
@@ -1407,6 +1407,7 @@ internal unsafe static string GetFullPath(string path)
         return AreStringsEqual(buffer, fullPathLength, path) ? path : new string(buffer, startIndex: 0, length: fullPathLength);
     }
 
+    [SupportedOSPlatform("windows")]
     private unsafe static int GetFullPathWin32(string target, int bufferLength, char* buffer, IntPtr mustBeZero)
     {
         int pathLength = GetFullPathName(target, bufferLength, buffer, mustBeZero);
@@ -1460,20 +1461,25 @@ internal static void VerifyThrowWin32Result(int result)
     /// that needs to be used for instance when writing to batch files
     /// </summary>
     [DllImport(kernel32Dll)]
+    [SupportedOSPlatform("windows")]
     internal static extern int GetOEMCP();
 
     [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
     [return: MarshalAs(UnmanagedType.Bool)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);
 
     [DllImport("kernel32.dll", PreserveSig = true, SetLastError = true)]
     [return: MarshalAs(UnmanagedType.Bool)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool FreeLibrary([In] IntPtr module);
 
     [DllImport("kernel32.dll", PreserveSig = true, BestFitMapping = false, ThrowOnUnmappableChar = true, CharSet = CharSet.Ansi, SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern IntPtr GetProcAddress(IntPtr module, string procName);
 
     [DllImport("kernel32.dll", CharSet = CharSet.Unicode, PreserveSig = true, SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern IntPtr LoadLibrary(string fileName);
 
     /// <summary>
@@ -1483,21 +1489,26 @@ internal static void VerifyThrowWin32Result(int result)
     /// <param name="buffer">The character buffer used to return the file name.</param>
     /// <param name="length">The length of the buffer.</param>
     [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]
+    [SupportedOSPlatform("windows")]
     internal static extern int GetModuleFileName(HandleRef hModule, [Out] char[] buffer, int length);
 
     [DllImport("kernel32.dll")]
+    [SupportedOSPlatform("windows")]
     internal static extern IntPtr GetStdHandle(int nStdHandle);
 
     [DllImport("kernel32.dll")]
+    [SupportedOSPlatform("windows")]
     internal static extern uint GetFileType(IntPtr hFile);
 
     [SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Justification = "Using unmanaged equivalent for performance reasons")]
     [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+    [SupportedOSPlatform("windows")]
     internal unsafe static extern int GetCurrentDirectory(int nBufferLength, char* lpBuffer);
 
     [SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Justification = "Using unmanaged equivalent for performance reasons")]
     [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode, EntryPoint = "SetCurrentDirectory")]
     [return: MarshalAs(UnmanagedType.Bool)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool SetCurrentDirectoryWindows(string path);
 
     internal static bool SetCurrentDirectory(string path)
@@ -1519,28 +1530,36 @@ internal static bool SetCurrentDirectory(string path)
     }
 
     [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+    [SupportedOSPlatform("windows")]
     internal static unsafe extern int GetFullPathName(string target, int bufferLength, char* buffer, IntPtr mustBeZero);
 
     [DllImport("KERNEL32.DLL")]
+    [SupportedOSPlatform("windows")]
     private static extern SafeProcessHandle OpenProcess(eDesiredAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, int dwProcessId);
 
     [DllImport("NTDLL.DLL")]
+    [SupportedOSPlatform("windows")]
     private static extern int NtQueryInformationProcess(SafeProcessHandle hProcess, PROCESSINFOCLASS pic, ref PROCESS_BASIC_INFORMATION pbi, uint cb, ref int pSize);
 
     [return: MarshalAs(UnmanagedType.Bool)]
     [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     private static extern bool GlobalMemoryStatusEx([In, Out] MemoryStatus lpBuffer);
 
     [DllImport("kernel32.dll", CharSet = CharSet.Unicode, BestFitMapping = false)]
+    [SupportedOSPlatform("windows")]
     internal static extern int GetShortPathName(string path, [Out] char[] fullpath, [In] int length);
 
     [DllImport("kernel32.dll", CharSet = CharSet.Unicode, BestFitMapping = false)]
+    [SupportedOSPlatform("windows")]
     internal static extern int GetLongPathName([In] string path, [Out] char[] fullpath, [In] int length);
 
     [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool CreatePipe(out SafeFileHandle hReadPipe, out SafeFileHandle hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
 
     [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool ReadFile(SafeFileHandle hFile, byte[] lpBuffer, uint nNumberOfBytesToRead, out uint lpNumberOfBytesRead, IntPtr lpOverlapped);
 
     /// <summary>
@@ -1549,6 +1568,7 @@ internal static bool SetCurrentDirectory(string path)
     /// build thread which the main thread (blocked on BuildSubmission.Execute) must service.
     /// </summary>
     [DllImport("ole32.dll")]
+    [SupportedOSPlatform("windows")]
     public static extern int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, [MarshalAs(UnmanagedType.LPArray)] IntPtr[] pHandles, out int pdwIndex);
 
     internal const uint GENERIC_READ = 0x80000000;
@@ -1559,6 +1579,7 @@ internal static bool SetCurrentDirectory(string path)
 
     [DllImport("kernel32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall,
         SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern SafeFileHandle CreateFile(
         string lpFileName,
         uint dwDesiredAccess,
@@ -1570,6 +1591,7 @@ IntPtr hTemplateFile
         );
 
     [DllImport("kernel32.dll", SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool GetFileTime(
         SafeFileHandle hFile,
         out FILETIME lpCreationTime,
@@ -1579,58 +1601,15 @@ out FILETIME lpLastWriteTime
 
     [DllImport("kernel32.dll", SetLastError = true)]
     [return: MarshalAs(UnmanagedType.Bool)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool CloseHandle(IntPtr hObject);
 
     [DllImport("kernel32.dll", SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool SetThreadErrorMode(int newMode, out int oldMode);
 
 #endregion
 
-#region Extensions
-
-    /// <summary>
-    /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
-    /// servicing COM calls from other threads.
-    /// </summary>
-    [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Runtime.InteropServices.SafeHandle.DangerousGetHandle", Scope = "member", Target = "Microsoft.Build.Shared.NativeMethodsShared.#MsgWaitOne(System.Threading.WaitHandle,System.Int32)", Justification = "This is necessary and it has been used for a long time. No need to change it now.")]
-    internal static bool MsgWaitOne(this WaitHandle handle)
-    {
-        return handle.MsgWaitOne(Timeout.Infinite);
-    }
-
-    /// <summary>
-    /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
-    /// servicing COM calls from other threads.
-    /// </summary>
-    internal static bool MsgWaitOne(this WaitHandle handle, TimeSpan timeout)
-    {
-        return MsgWaitOne(handle, (int)timeout.TotalMilliseconds);
-    }
-
-    /// <summary>
-    /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
-    /// servicing COM calls from other threads.
-    /// </summary>
-    [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Runtime.InteropServices.SafeHandle.DangerousGetHandle", Justification = "Necessary to avoid pumping")]
-    internal static bool MsgWaitOne(this WaitHandle handle, int timeout)
-    {
-        // CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
-        // VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
-        // build thread which the main thread (blocked on BuildSubmission.Execute) must service.
-        int waitIndex;
-        IntPtr handlePtr = handle.SafeWaitHandle.DangerousGetHandle();
-        int returnValue = CoWaitForMultipleHandles(COWAIT_FLAGS.COWAIT_NONE, timeout, 1, new IntPtr[] { handlePtr }, out waitIndex);
-
-        if (!(returnValue == 0 || ((uint)returnValue == RPC_S_CALLPENDING && timeout != Timeout.Infinite)))
-        {
-            throw new InternalErrorException($"Received {returnValue} from CoWaitForMultipleHandles, but expected 0 (S_OK)");
-        }
-
-        return returnValue == 0;
-    }
-
-#endregion
-
 #region helper methods
 
     internal static bool DirectoryExists(string fullPath)
@@ -1640,6 +1619,7 @@ internal static bool DirectoryExists(string fullPath)
             : Directory.Exists(fullPath);
     }
 
+    [SupportedOSPlatform("windows")]
     internal static bool DirectoryExistsWindows(string fullPath)
     {
         WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
@@ -1654,6 +1634,7 @@ internal static bool FileExists(string fullPath)
             : File.Exists(fullPath);
     }
 
+    [SupportedOSPlatform("windows")]
     internal static bool FileExistsWindows(string fullPath)
     {
         WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
@@ -1668,6 +1649,7 @@ internal static bool FileOrDirectoryExists(string path)
             : File.Exists(path) || Directory.Exists(path);
     }
 
+    [SupportedOSPlatform("windows")]
     internal static bool FileOrDirectoryExistsWindows(string path)
     {
         WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index cf60eb140c9..23735453ed0 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -92,6 +91,15 @@ public Traits()
         /// </summary>
         public readonly bool LogPropertyFunctionsRequiringReflection = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildLogPropertyFunctionsRequiringReflection"));
 
+        /// <summary>
+        /// Log all environment variables whether or not they are used in a build in the binary log.
+        /// </summary>
+        public bool LogAllEnvironmentVariables => string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDONLYLOGUSEDENVIRONMENTVARIABLES"))
+#if !TASKHOST
+            && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4)
+#endif
+            ;
+
         /// <summary>
         /// Log property tracking information.
         /// </summary>
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index c69053daa0c..8bf7155cbac 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -86,10 +86,8 @@
     <value>MSBUILD : error MSB1027: The -noAutoResponse switch cannot be specified in the MSBuild.rsp auto-response file, nor in any response file that is referenced by the auto-response file.</value>
     <comment>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</comment>
   </data>
-  <data name="CopyrightMessage" UESanitized="true" Visibility="Public">
-    <value>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</value>
+  <data name="MSBuildVersionMessage" UESanitized="true" Visibility="Public">
+    <value>MSBuild version {0} for {1}</value>
     <comment>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</comment>
   </data>
   <data name="DuplicateProjectSwitchError" UESanitized="true" Visibility="Public">
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 7ccdc9ab43e..6119ea4e085 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: PÅepÃ­naÄ -noAutoResponse nelze zadat v souboru automatickÃ½ch odpovÄdÃ­ MSBuild.rsp ani v Å¾Ã¡dnÃ©m jinÃ©m souboru odpovÄdÃ­, na kterÃ½ se v souboru automatickÃ½ch odpovÄdÃ­ odkazuje.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine verze {0} pro {1}
-Copyright (C) Microsoft Corporation. VÅ¡echna prÃ¡va vyhrazena.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index e2c30e3ac4f..2b6914c41b7 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: Der Schalter "-noAutoResponse" kann weder in der automatischen Antwortdatei "MSBuild.rsp" noch in einer anderen Antwortdatei verwendet werden, auf die die automatische Antwortdatei verweist.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R)-Build-Engine, Version {0} fÃ¼r {1}
-Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 0195e35549f..e0d7c14e8ad 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: El modificador -noAutoResponse no puede especificarse en el archivo de respuesta automÃ¡tica MSBuild.rsp ni en ningÃºn archivo de respuesta al que el archivo de respuesta automÃ¡tica haga referencia.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine versiÃ³n {0} para {1}
-Copyright (C) Microsoft Corporation. Todos los derechos reservados.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 3065aadd997..0372c4900f0 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: Impossible de spÃ©cifier le commutateur -noAutoResponse dans le fichier rÃ©ponse automatique MSBuild.rsp, ni dans aucun autre fichier rÃ©ponse rÃ©fÃ©rencÃ© par le fichier rÃ©ponse automatique.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine version {0} pour {1}
-Copyright (C) Microsoft Corporation. Tous droits rÃ©servÃ©s.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 9c59271398b..4721ca9afcb 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: non Ã¨ possibile specificare l'opzione -noAutoResponse nel file di risposta automatica MSBuild.rsp o in file di risposta a cui il file di risposta automatica fa riferimento.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine versione {0} per {1}
-Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 9c2bee6bc61..e3fd2d55895 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp èªåå¿ç­ãã¡ã¤ã«ããèªåå¿ç­ãã¡ã¤ã«ã«ãã£ã¦åç§ãããå¿ç­ãã¡ã¤ã«ã« -noAutoResponse ã¹ã¤ãããæå®ãããã¨ã¯ã§ãã¾ããã</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">{1} åã Microsoft (R) Build Engine ãã¼ã¸ã§ã³ {0}
-Copyright (C) Microsoft Corporation.All rights reserved.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 3d3b611cc74..c15244ecb8c 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp ìë ì§ì íì¼ê³¼ ìë ì§ì íì¼ìì ì°¸ì¡°íë ëª¨ë  ì§ì íì¼ìë -noAutoResponse ì¤ìì¹ë¥¼ ì§ì í  ì ììµëë¤.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">{1}ì© Microsoft (R) Build Engine ë²ì  {0}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 2c2f7464b68..b170f13dc44 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: przeÅÄcznika -noAutoResponse nie moÅ¼na okreÅliÄ w pliku autoodpowiedzi MSBuild.rsp ani w Å¼adnym pliku odpowiedzi, do ktÃ³rego odwoÅuje siÄ plik autoodpowiedzi.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine {0} dla platformy {1}
-Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeÅ¼one.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 6dc052fc5bd..0d41ea796de 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: A opÃ§Ã£o /noAutoResponse nÃ£o pode ser especificada no arquivo de resposta automÃ¡tica MSBuild.rsp nem em qualquer arquivo de resposta usado como referÃªncia para o arquivo de resposta automÃ¡tica.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft(R) Build Engine versÃ£o {0} para {1} 
-Copyright (C) Microsoft Corporation. Todos os direitos reservados.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index b39acf70142..9f729cfd401 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: ÐºÐ»ÑÑ noAutoResponse Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ ÑÐºÐ°Ð·Ð°Ð½ Ð² ÑÐ°Ð¹Ð»Ðµ Ð°Ð²ÑÐ¾Ð¾ÑÐ²ÐµÑÐ° MSBuild.rsp Ð¸Ð»Ð¸ Ð² Ð»ÑÐ±Ð¾Ð¼ Ð´ÑÑÐ³Ð¾Ð¼ ÑÐ°Ð¹Ð»Ðµ Ð¾ÑÐ²ÐµÑÐ°, Ð½Ð° ÐºÐ¾ÑÐ¾ÑÑÐ¹ ÑÐ°Ð¹Ð» Ð°Ð²ÑÐ¾Ð¾ÑÐ²ÐµÑÐ° ÑÑÑÐ»Ð°ÐµÑÑÑ.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine Ð²ÐµÑÑÐ¸Ð¸ {0} Ð´Ð»Ñ {1}
-(C) ÐÐ¾ÑÐ¿Ð¾ÑÐ°ÑÐ¸Ñ ÐÐ°Ð¹ÐºÑÐ¾ÑÐ¾ÑÑ (Microsoft Corporation). ÐÑÐµ Ð¿ÑÐ°Ð²Ð° Ð·Ð°ÑÐ¸ÑÐµÐ½Ñ.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index eb65858ec3a..9d761e71fdf 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse anahtarÄ±, MSBuild.rsp otomatik yanÄ±t dosyasÄ±nda ve bu dosyanÄ±n baÅvuruda bulunduÄu herhangi bir yanÄ±t dosyasÄ±nda belirtilemez.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">{1} iÃ§in Microsoft (R) Build Engine sÃ¼rÃ¼m {0}
-Telif HakkÄ± (C) Microsoft Corporation. TÃ¼m haklarÄ± saklÄ±dÄ±r.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.xlf b/src/MSBuild/Resources/xlf/Strings.xlf
index c9f006f4aba..a16ca1ca45e 100644
--- a/src/MSBuild/Resources/xlf/Strings.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.xlf
@@ -21,10 +21,8 @@
         <source>MSBUILD : error MSB1027: The /noautoresponse switch cannot be specified in the MSBuild.rsp auto-response file, nor in any response file that is referenced by the auto-response file.</source>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "/noautoresponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="DuplicateProjectSwitchError">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index a4fc1ecdd32..98030b258e3 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: ä¸è½å¨ MSBuild.rsp èªå¨ååºæä»¶ä¸­æç±è¯¥èªå¨ååºæä»¶å¼ç¨çä»»ä½ååºæä»¶ä¸­æå® -noAutoResponse å¼å³ã</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">ç¨äº {1} ç Microsoft (R) çæå¼æçæ¬ {0}
-çæææ(C) Microsoft Corporationãä¿çæææå©ã
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 2dc040b10b9..1ea6492f634 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse åæ¸ä¸è½å¨ MSBuild.rsp èªååææªä¸­æå®ï¼ä¹ä¸è½å¨èªååææªæåèçä»»ä½åææªä¸­æå®ã</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine for {1} {0} ç
-Copyright (C) Microsoft Corporation. èä½æ¬ææï¼ä¸¦ä¿çä¸åæ¬å©ã
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="new">MSBuild version {0} for {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 42251449d2a..c5f21d2b46d 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2074,7 +2074,7 @@ string commandLine
             // NOTE: we heed the nologo switch even if there are switch errors
             if (!recursing && !commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoLogo] && !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Preprocess))
             {
-                DisplayCopyrightMessage();
+                DisplayVersionMessage();
             }
 
 
@@ -3664,9 +3664,9 @@ private static void ThrowInvalidToolsVersionInitializationException(IEnumerable<
         }
 
         /// <summary>
-        /// Displays the application copyright message/logo.
+        /// Displays the application version message/logo.
         /// </summary>
-        private static void DisplayCopyrightMessage()
+        private static void DisplayVersionMessage()
         {
 #if RUNTIME_TYPE_NETCORE
             const string frameworkName = ".NET";
@@ -3676,7 +3676,7 @@ private static void DisplayCopyrightMessage()
             const string frameworkName = ".NET Framework";
 #endif
 
-            Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CopyrightMessage", ProjectCollection.DisplayVersion, frameworkName));
+            Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("MSBuildVersionMessage", ProjectCollection.DisplayVersion, frameworkName));
         }
 
         /// <summary>
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 5a010aae1f1..4cdef2986d2 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -83,8 +83,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.1.1" newVersion="4.0.1.1" />
-          <codeBase version="4.0.1.1" href="..\System.Memory.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.0.1.2" newVersion="4.0.1.2" />
+          <codeBase version="4.0.1.2" href="..\System.Memory.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 1acf31b136c..3f412c2716a 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -62,7 +62,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.1.1" newVersion="4.0.1.1" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.1.2" newVersion="4.0.1.2" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index beca5404f56..ec7f04055ae 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -1,4 +1,4 @@
-ï»¿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -39,6 +39,10 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
+    <!-- EnvironmentVariableReadEventArgs shouldn't be used in TaskHosts, but it means we need fewer ifdefs. -->
+    <Compile Include="..\Framework\EnvironmentVariableReadEventArgs.cs">
+      <Link>EnvironmentVariableReadEventArgs.cs</Link>
+    </Compile>
     <Compile Include="..\Framework\BuildEnvironmentState.cs">
       <Link>BuildEnvironmentState.cs</Link>
     </Compile>
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 0bf416196af..b2579ae8610 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -526,6 +526,7 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,
                 CurrentMSBuildConfigurationFile = string.Concat(currentMSBuildExePath, ".config");
                 MSBuildToolsDirectory32 = CurrentMSBuildToolsDirectory;
                 MSBuildToolsDirectory64 = CurrentMSBuildToolsDirectory;
+                MSBuildToolsDirectoryRoot = CurrentMSBuildToolsDirectory;
             }
 
             // We can't detect an environment, don't try to set other paths.
diff --git a/src/Shared/EnvironmentUtilities.cs b/src/Shared/EnvironmentUtilities.cs
index e9e0482619f..01cf349f2f8 100644
--- a/src/Shared/EnvironmentUtilities.cs
+++ b/src/Shared/EnvironmentUtilities.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Runtime.InteropServices;
 
-#nullable disable
-
 namespace Microsoft.Build.Shared
 {
     internal static partial class EnvironmentUtilities
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index e3bcdf9fcba..7c0db803f70 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -53,10 +53,11 @@ internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProj
         /// <param name="e">Message to format</param>
         /// <param name="showProjectFile"><code>true</code> to show the project file which issued the event, otherwise <code>false</code>.</param>
         /// <param name="projectConfigurationDescription">Properties to Print along with message</param>
+        /// <param name="nonNullMessage">The complete message (including property name) for an environment-derived property</param>
         /// <returns>The formatted message string.</returns>
-        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription)
+        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription, string nonNullMessage = null)
         {
-            return FormatEventMessage("message", e.Subcategory, e.Message,
+            return FormatEventMessage("message", e.Subcategory, nonNullMessage ?? e.Message,
                             e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber,
                             e.ColumnNumber, e.EndColumnNumber, e.ThreadId, projectConfigurationDescription);
         }
@@ -144,13 +145,14 @@ internal static string FormatEventMessage(BuildMessageEventArgs e)
         /// </summary>
         /// <param name="e">Message to format</param>
         /// <param name="showProjectFile">Show project file or not</param>
+        /// <param name="nonNullMessage">For an EnvironmentVariableReadEventArgs, adds an explanatory note and the name of the variable.</param>
         /// <returns>The formatted message string.</returns>
-        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile)
+        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string nonNullMessage = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             // "message" should not be localized
-            return FormatEventMessage("message", e.Subcategory, e.Message,
+            return FormatEventMessage("message", e.Subcategory, nonNullMessage ?? e.Message,
                 e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber, e.ColumnNumber, e.EndColumnNumber, e.ThreadId, null);
         }
 
diff --git a/src/Shared/FileSystem/IFileSystem.cs b/src/Shared/FileSystem/IFileSystem.cs
index 3b08f7ff451..52d37af1d08 100644
--- a/src/Shared/FileSystem/IFileSystem.cs
+++ b/src/Shared/FileSystem/IFileSystem.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Shared.FileSystem
      * Any new code should depend on MSBuildFileSystemBase instead of IFileSystem, if possible.
      *
      * MSBuild uses IFileSystem internally and adapts MSBuildFileSystemBase instances received from the outside to IFileSystem.
-     * Ideally there should be only one, public interface. However, such an interface would need to be put into the 
+     * Ideally there should be only one, public interface. However, such an interface would need to be put into the
      * Microsoft.Build.Framework assembly, but that assembly cannot take new types because it breaks some old version of Nuget.exe.
      * IFileSystem cannot be deleted for the same reason.
      */
diff --git a/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs b/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
index 3dd41850342..8ba84cebe03 100644
--- a/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
+++ b/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -13,6 +14,7 @@ namespace Microsoft.Build.Shared.FileSystem
     /// Implementation of file system operations on windows. Combination of native and managed implementations.
     /// TODO Remove this class and replace with WindowsFileSystem. Test perf to ensure no regressions.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     internal class MSBuildOnWindowsFileSystem : IFileSystem
     {
         private static readonly MSBuildOnWindowsFileSystem Instance = new MSBuildOnWindowsFileSystem();
diff --git a/src/Shared/FileSystem/WindowsFileSystem.cs b/src/Shared/FileSystem/WindowsFileSystem.cs
index 03c739e6710..60867009993 100644
--- a/src/Shared/FileSystem/WindowsFileSystem.cs
+++ b/src/Shared/FileSystem/WindowsFileSystem.cs
@@ -6,6 +6,7 @@
 using System.Diagnostics;
 using System.IO;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -28,9 +29,10 @@ internal enum FileArtifactType : byte
     /// Windows-specific implementation of file system operations using Windows native invocations.
     /// TODO For potential extra perf gains, provide native implementations for all IFileSystem methods and stop inheriting from ManagedFileSystem
     /// </summary>
+    [SupportedOSPlatform("windows")]
     internal class WindowsFileSystem : ManagedFileSystem
     {
-        private static readonly WindowsFileSystem Instance = new WindowsFileSystem();
+        private static readonly WindowsFileSystem Instance = new();
 
         public new static WindowsFileSystem Singleton() => WindowsFileSystem.Instance;
 
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 7e592d7513d..bd010ed294f 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -130,6 +130,11 @@ internal enum LoggingEventType : int
         /// Event is a TelemetryEventArgs
         /// </summary>
         Telemetry = 18,
+
+        /// <summary>
+        /// Event is an EnvironmentVariableReadEventArgs
+        /// </summary>
+        EnvironmentVariableReadEvent = 19,
     }
     #endregion
 
@@ -323,7 +328,8 @@ internal void WriteToStream(ITranslator translator)
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
                 if (_buildEvent is ProjectEvaluationStartedEventArgs ||
-                    _buildEvent is ProjectEvaluationFinishedEventArgs)
+                    _buildEvent is ProjectEvaluationFinishedEventArgs ||
+                    _buildEvent is EnvironmentVariableReadEventArgs)
                 {
                     // switch to serialization methods that we provide in this file
                     // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
@@ -403,6 +409,7 @@ internal void ReadFromStream(ITranslator translator)
                 else
                 {
                     _buildEvent = ReadEventFromStream(_eventType, translator);
+                    ErrorUtilities.VerifyThrow(_buildEvent is not null, "Not Supported LoggingEventType {0}", _eventType.ToString());
                 }
             }
             else
@@ -509,6 +516,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.TaskStartedEvent => new TaskStartedEventArgs(null, null, null, null, null),
                 LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
                 LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
+                LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
                 LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
                 LoggingEventType.ProjectEvaluationStartedEvent => new ProjectEvaluationStartedEventArgs(),
@@ -607,6 +615,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildErrorEvent;
             }
+            else if (eventType == typeof(EnvironmentVariableReadEventArgs))
+            {
+                return LoggingEventType.EnvironmentVariableReadEvent;
+            }
             else
             {
                 return LoggingEventType.CustomEvent;
@@ -661,12 +673,29 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
                 case LoggingEventType.ProjectFinishedEvent:
                     WriteExternalProjectFinishedEventToStream((ExternalProjectFinishedEventArgs)buildEvent, translator);
                     break;
+                case LoggingEventType.EnvironmentVariableReadEvent:
+                    WriteEnvironmentVariableReadEventArgs((EnvironmentVariableReadEventArgs)buildEvent, translator);
+                    break;
                 default:
                     ErrorUtilities.ThrowInternalError("Not Supported LoggingEventType {0}", eventType.ToString());
                     break;
             }
         }
 
+        /// <summary>
+        /// Serializes EnvironmentVariableRead Event argument to the stream. Does not work properly on TaskHosts due to BuildEventContext serialization not being
+        /// enabled on TaskHosts, but that shouldn't matter, as this should never be called from a TaskHost anyway.
+        /// </summary>
+        private void WriteEnvironmentVariableReadEventArgs(EnvironmentVariableReadEventArgs environmentVariableReadEventArgs, ITranslator translator)
+        {
+            string name = environmentVariableReadEventArgs.EnvironmentVariableName;
+            translator.Translate(ref name);
+            BuildEventContext context = environmentVariableReadEventArgs.BuildEventContext;
+#if !CLR2COMPATIBILITY
+            translator.Translate(ref context);
+#endif
+        }
+
         /// <summary>
         /// Serialize ExternalProjectFinished Event Argument to the stream
         /// </summary>
@@ -1001,33 +1030,33 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
             translator.Translate(ref helpKeyword);
             translator.Translate(ref senderName);
 
-            BuildEventArgs buildEvent = null;
-            switch (eventType)
+            return eventType switch
             {
-                case LoggingEventType.TaskCommandLineEvent:
-                    buildEvent = ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.BuildErrorEvent:
-                    buildEvent = ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.ProjectStartedEvent:
-                    buildEvent = ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.ProjectFinishedEvent:
-                    buildEvent = ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.BuildMessageEvent:
-                    buildEvent = ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                case LoggingEventType.BuildWarningEvent:
-                    buildEvent = ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName);
-                    break;
-                default:
-                    ErrorUtilities.ThrowInternalError("Not Supported LoggingEventType {0}", eventType.ToString());
-                    break;
-            }
+                LoggingEventType.TaskCommandLineEvent => ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.BuildErrorEvent => ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),
+                _ => null,
+            };
+        }
 
-            return buildEvent;
+        /// <summary>
+        /// Read and reconstruct an EnvironmentVariableReadEventArgs from the stream. This message should never be called from a TaskHost, so although the context translation does not work, that's ok.
+        /// </summary>
+        private EnvironmentVariableReadEventArgs ReadEnvironmentVariableReadEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
+        {
+            string environmentVariableName = null;
+            translator.Translate(ref environmentVariableName);
+            BuildEventContext context = null;
+#if !CLR2COMPATIBILITY
+            translator.Translate(ref context);
+#endif
+            EnvironmentVariableReadEventArgs args = new(environmentVariableName, message);
+            args.BuildEventContext = context;
+            return args;
         }
 
         /// <summary>
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index fbe9d5e00fb..8d1e1c38e7a 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -1,7 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
+
+using System;
 using System.Collections.Immutable;
 using System.IO;
 using System.Reflection;
@@ -15,6 +18,8 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal class MSBuildLoadContext : AssemblyLoadContext
     {
+        private AssemblyDependencyResolver? _resolver;
+
         private readonly string _directory;
 
         internal static readonly ImmutableHashSet<string> WellKnownAssemblyNames =
@@ -31,6 +36,16 @@ public MSBuildLoadContext(string assemblyPath)
             : base($"MSBuild plugin {assemblyPath}")
         {
             _directory = Directory.GetParent(assemblyPath)!.FullName;
+
+            // We check for the assemblyPath because it will fail with an AssemblyDependencyResolver-specific error
+            // if it does not exist. We should instead fall back to the standard failure.
+            // The second check is because AssemblyDependencyResolver loads assemblies differently than we do by default.
+            // We should maintain previous behavior in the absence of new data (a .deps.json file) indicating that we
+            // should do something different.
+            // Setting the _resolver to null essentially just opts out of the new behavior.
+            _resolver = File.Exists(assemblyPath) && File.Exists(Path.ChangeExtension(assemblyPath, ".deps.json"))
+                ? new AssemblyDependencyResolver(assemblyPath) :
+                null;
         }
 
         protected override Assembly? Load(AssemblyName assemblyName)
@@ -42,6 +57,19 @@ public MSBuildLoadContext(string assemblyPath)
                 return null;
             }
 
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                // respect plugin.dll.json with the AssemblyDependencyResolver
+                string? assemblyPath = _resolver?.ResolveAssemblyToPath(assemblyName);
+                if (assemblyPath != null)
+                {
+                    return LoadFromAssemblyPath(assemblyPath);
+                }
+            }
+
+            // Fall back to the older MSBuild-on-Core behavior to continue to support
+            // plugins that don't ship a .deps.json
+
             foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
                 // If no culture is specified, attempt to load directly from
                 // the known dependency paths.
@@ -73,7 +101,6 @@ public MSBuildLoadContext(string assemblyPath)
             // - the assembly from the user specified path is loaded, if it exists, into the custom ALC, or
             // - if the simple name of the assembly exists in the same folder as msbuild.exe, then that assembly gets loaded
             //   into the default ALC (so it's shared with other uses).
-
             var assemblyNameInExecutableDirectory = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
                 $"{assemblyName.Name}.dll");
 
@@ -84,5 +111,19 @@ public MSBuildLoadContext(string assemblyPath)
 
             return null;
         }
+
+        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
+        {
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                string? libraryPath = _resolver?.ResolveUnmanagedDllToPath(unmanagedDllName);
+                if (libraryPath != null)
+                {
+                    return LoadUnmanagedDllFromPath(libraryPath);
+                }
+            }
+
+            return base.LoadUnmanagedDll(unmanagedDllName);
+        }
     }
 }
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
new file mode 100644
index 00000000000..a0389604db3
--- /dev/null
+++ b/src/Shared/PlatformNegotiation.cs
@@ -0,0 +1,110 @@
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Evaluation;
+
+namespace Microsoft.Build.Shared
+{
+    /// <summary>
+    /// This class contains only static methods, which are used in both the 
+    /// tasks and graph projects in order for two projects to negotiate which platform a projectreference
+    /// should be built as.
+    /// </summary>
+    internal static class PlatformNegotiation
+    {
+        internal static string GetNearestPlatform(string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, string platformLookupTable, string projectPath, string currentProjectPlatform, TaskLoggingHelper? log = null)
+        {
+            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(platformLookupTable, log);
+
+            if (string.IsNullOrEmpty(projectReferencePlatformsMetadata) && string.IsNullOrEmpty(referencedProjectPlatform))
+                {
+                    log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoPlatformsListed", projectPath);
+                    return string.Empty;
+                }
+
+                // Pull platformLookupTable metadata from the referenced project. This allows custom
+                // mappings on a per-ProjectReference basis.
+                Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata, log);
+
+                HashSet<string> projectReferencePlatforms = new HashSet<string>();
+                foreach (string s in projectReferencePlatformsMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
+                {
+                    projectReferencePlatforms.Add(s);
+                }
+
+                string buildProjectReferenceAs = string.Empty;
+
+                // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
+                // Don't set `buildProjectReferenceAs` and the `_GetProjectReferencePlatformProperties` target will handle the rest.
+                if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(currentProjectPlatform, StringComparison.OrdinalIgnoreCase))
+                {
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", projectPath, referencedProjectPlatform);
+                }
+                // Prefer matching platforms
+                else if (projectReferencePlatforms.Contains(currentProjectPlatform))
+                {
+                    buildProjectReferenceAs = currentProjectPlatform;
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.SamePlatform");
+                }
+                // Prioritize platformLookupTable **metadata** attached to the ProjectReference item
+                // before the current project's table. We do this to allow per-ProjectReference fine tuning.
+                else if (projectReferenceLookupTable != null &&
+                        projectReferenceLookupTable.ContainsKey(currentProjectPlatform) &&
+                        projectReferencePlatforms.Contains(projectReferenceLookupTable[currentProjectPlatform]))
+                {
+                    buildProjectReferenceAs = projectReferenceLookupTable[currentProjectPlatform];
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, projectReferenceLookupTableMetadata);
+                }
+                // Current project's translation table follows
+                else if (currentProjectLookupTable != null &&
+                        currentProjectLookupTable.ContainsKey(currentProjectPlatform) &&
+                        projectReferencePlatforms.Contains(currentProjectLookupTable[currentProjectPlatform]))
+                {
+                    buildProjectReferenceAs = currentProjectLookupTable[currentProjectPlatform];
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, platformLookupTable);
+                }
+                // AnyCPU if possible
+                else if (projectReferencePlatforms.Contains("AnyCPU"))
+                {
+                    buildProjectReferenceAs = "AnyCPU";
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.AnyCPUDefault");
+                }
+                else
+                {
+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine 
+                    // Platform/PlatformTarget when this is the case.
+                    log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", projectPath);
+                }
+            return buildProjectReferenceAs;
+        }
+        internal static Dictionary<string, string>? ExtractLookupTable(string stringTable, TaskLoggingHelper? log = null)
+        {
+            if (string.IsNullOrEmpty(stringTable))
+            {
+                return null;
+            }
+
+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+
+            foreach (string s in stringTable.Trim().Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
+            {
+                string[] keyVal = s.Trim().Split(MSBuildConstants.EqualsChar);
+
+                // Invalid table, don't use it.
+                if (keyVal.Length != 2 || string.IsNullOrEmpty(keyVal[0]) || string.IsNullOrEmpty(keyVal[1]))
+                {
+                    log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.InvalidLookupTableFormat", stringTable);
+                    return null;
+                }
+
+                table[keyVal[0]] = keyVal[1];
+            }
+
+            log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.LookupTableParsed", stringTable);
+
+            return table;
+        }
+    }
+}
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 6ede3f2d7fb..49e86433de5 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -258,17 +258,6 @@ public TransientTestFile ExpectFile(string extension = ".tmp")
             return WithTransientTestState(new TransientTestFile(extension, createFile: false, expectedAsOutput: true));
         }
 
-        /// <summary>
-        /// Create a temp file name under a specific temporary folder. The file is expected to exist when the test completes.
-        /// </summary>
-        /// <param name="transientTestFolder">Temp folder</param>
-        /// <param name="extension">Extension of the file (defaults to '.tmp')</param>
-        /// <returns></returns>
-        public TransientTestFile ExpectFile(TransientTestFolder transientTestFolder, string extension = ".tmp")
-        {
-            return WithTransientTestState(new TransientTestFile(transientTestFolder.Path, extension, createFile: false, expectedAsOutput: true));
-        }
-
         /// <summary>
         ///     Creates a test variant used to add a unique temporary folder during a test. Will be deleted when the test
         ///     completes.
diff --git a/src/Shared/UnitTests/TypeLoader_Tests.cs b/src/Shared/UnitTests/TypeLoader_Tests.cs
index bf1501860b8..509f4c01565 100644
--- a/src/Shared/UnitTests/TypeLoader_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Tests.cs
@@ -6,8 +6,10 @@
 using System.IO;
 using Microsoft.Build.Shared;
 using System.Reflection;
-using Xunit;
 using Microsoft.Build.UnitTests.Shared;
+using Xunit;
+using Xunit.Abstractions;
+using Shouldly;
 
 #nullable disable
 
@@ -19,6 +21,13 @@ public class TypeLoader_Tests
         private const string ProjectFileName = "portableTaskTest.proj";
         private const string DLLFileName = "PortableTask.dll";
 
+        private readonly ITestOutputHelper _output;
+
+        public TypeLoader_Tests(ITestOutputHelper testOutputHelper)
+        {
+            _output = testOutputHelper;
+        }
+
         [Fact]
         public void Basic()
         {
@@ -50,19 +59,18 @@ public void Regress_Mutation_ParameterOrderDoesntMatter()
         [Fact]
         public void LoadNonExistingAssembly()
         {
-            using (var dir = new FileUtilities.TempWorkingDirectory(ProjectFileFolder))
-            {
-                string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
+            using var dir = new FileUtilities.TempWorkingDirectory(ProjectFileFolder);
 
-                string dllName = "NonExistent.dll";
+            string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + dllName, out successfulExit);
-                Assert.False(successfulExit);
+            string dllName = "NonExistent.dll";
 
-                string dllPath = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, dllName);
-                CheckIfCorrectAssemblyLoaded(output, dllPath, false);
-            }
+            bool successfulExit;
+            string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + dllName, out successfulExit, _output);
+            successfulExit.ShouldBeFalse();
+
+            string dllPath = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, dllName);
+            CheckIfCorrectAssemblyLoaded(output, dllPath, false);
         }
 
         [Fact]
@@ -73,7 +81,7 @@ public void LoadInsideAsssembly()
                 string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
 
                 bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag", out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag", out successfulExit, _output);
                 Assert.True(successfulExit);
 
                 string dllPath = Path.Combine(dir.Path, DLLFileName);
@@ -95,7 +103,7 @@ public void LoadOutsideAssembly()
                 try
                 {
                     bool successfulExit;
-                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + movedDLLPath, out successfulExit);
+                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + movedDLLPath, out successfulExit, _output);
                     Assert.True(successfulExit);
 
                     CheckIfCorrectAssemblyLoaded(output, movedDLLPath);
@@ -119,7 +127,7 @@ public void LoadInsideAssemblyWhenGivenOutsideAssemblyWithSameName()
                 try
                 {
                     bool successfulExit;
-                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + copiedDllPath, out successfulExit);
+                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + copiedDllPath, out successfulExit, _output);
                     Assert.True(successfulExit);
 
                     CheckIfCorrectAssemblyLoaded(output, originalDLLPath);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index beec4a1d226..0a520b9f82b 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3306,7 +3306,7 @@ public void ParentAssemblyResolvedFromAForGac()
             Assert.Single(parentReferenceFolders);
             Assert.Equal(reference2.ResolvedSearchPath, parentReferenceFolders[0]);
         }
-        
+
         /// <summary>
         /// Generate a fake reference which has been resolved from the gac. We will use it to verify the creation of the exclusion list.
         /// </summary>
@@ -3652,7 +3652,7 @@ public void ConflictBetweenCopyLocalDependenciesRegress444809UnResolvedPrimaryRe
         ///   References - D, version 1
         ///
         /// Both D1 and D2 are CopyLocal. This is a warning because D1 is a lower version
-        /// than both D2 so that can't unify. These means that eventually when 
+        /// than both D2 so that can't unify. These means that eventually when
         /// they're copied to the output directory they'll conflict.
         /// </summary>
         [Fact]
@@ -5982,7 +5982,7 @@ public void RedistListNoAssembliesinRedistList()
         [Fact]
         public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
         {
-            string redistFile = CreateGenericRedistList(); 
+            string redistFile = CreateGenericRedistList();
             string goodSubsetFile = FileUtilities.GetTemporaryFile();
             try
             {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
index 36e646d5526..e5eddbe032a 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
@@ -77,7 +77,7 @@ public void DependeeDirectoryIsProbedForDependency()
                 bool succeeded = Execute(t);
 
                 Assert.True(succeeded);
-                
+
                 uniqueFileExists[s_dependsOnNuGet_NWinMdPath].ShouldBe(1);
                 uniqueFileExists[s_dependsOnNuGet_NDllPath].ShouldBe(1);
                 uniqueFileExists[s_dependsOnNuGet_NExePath].ShouldBe(1);
@@ -109,7 +109,7 @@ public void DependeeDirectoryShouldNotBeProbedForDependencyWhenDependencyResolve
                         new Dictionary<string, string>
                         {
                             {"ExternallyResolved", "true"}
-                        }) 
+                        })
                 };
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index 242e6a95380..db5d30bda9d 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -113,7 +113,7 @@ sealed internal class Reference
         private bool _isManagedWinMDFile;
 
         /// <summary>
-        /// The imageruntime version for this reference. 
+        /// The imageruntime version for this reference.
         /// </summary>
         private string _imageRuntimeVersion;
 
@@ -358,7 +358,7 @@ internal bool ResolvedFromGac
 
         /// <summary>
         /// Determines if a given reference or its parent primary references have specific version metadata set to true.
-        /// If anyParentHasMetadata is set to true then we will return true if any parent primary reference has the specific version metadata set to true, 
+        /// If anyParentHasMetadata is set to true then we will return true if any parent primary reference has the specific version metadata set to true,
         /// if the value is false we will return true ONLY if all parent primary references have the metadata set to true.
         /// </summary>
         internal bool CheckForSpecificVersionMetadataOnParentsReference(bool anyParentHasMetadata)
@@ -373,7 +373,7 @@ internal bool CheckForSpecificVersionMetadataOnParentsReference(bool anyParentHa
             }
             else
             {
-                // Go through all of the primary items which lead to this dependency, if they all have specificVersion set to true then 
+                // Go through all of the primary items which lead to this dependency, if they all have specificVersion set to true then
                 // hasSpecificVersionMetadata will be true. If any item has the metadata set to false or not set then the value will be false.
                 foreach (ITaskItem item in GetSourceItems())
                 {
@@ -589,7 +589,7 @@ internal string FullPathWithoutExtension
         internal string AssemblyFolderKey { get; set; } = String.Empty;
 
         /// <summary>
-        /// Whether this assembly came from the project. If 'false' then this reference was deduced 
+        /// Whether this assembly came from the project. If 'false' then this reference was deduced
         /// through the reference resolution process.
         /// </summary>
         /// <value>'true' if this reference is a primary assembly.</value>
@@ -629,7 +629,7 @@ internal ITaskItem PrimarySourceItem
 
         /// <summary>
         /// If 'true' then the path that this item points to is known to be a bad image.
-        /// This item shouldn't be passed to compilers and so forth. 
+        /// This item shouldn't be passed to compilers and so forth.
         /// </summary>
         /// <value>'true' if this reference points to a bad image.</value>
         internal bool IsBadImage { get; private set; } = false;
@@ -721,7 +721,7 @@ internal HashSet<AssemblyRemapping> RemappedAssemblyNames()
         }
 
         /// <summary>
-        /// Add a new version number for a version of this reference 
+        /// Add a new version number for a version of this reference
         /// </summary>
         internal void AddPreUnificationVersion(String referencePath, Version version, UnificationReason reason)
         {
@@ -819,7 +819,7 @@ internal void AddAssembliesConsideredAndRejected(List<ResolutionSearchLocation>
         }
 
         /// <summary>
-        /// Returns a collection of strings. Each string is the full path to an assembly that was 
+        /// Returns a collection of strings. Each string is the full path to an assembly that was
         /// considered for resolution but then rejected because it wasn't a complete match.
         /// </summary>
         internal List<ResolutionSearchLocation> AssembliesConsideredAndRejected { get; private set; } = new List<ResolutionSearchLocation>();
@@ -835,7 +835,7 @@ internal void AddAssembliesConsideredAndRejected(List<ResolutionSearchLocation>
         internal FrameworkName FrameworkNameAttribute { get; set; }
 
         /// <summary>
-        /// Indicates that the reference is primary and has ExternallyResolved=true metadata to denote that 
+        /// Indicates that the reference is primary and has ExternallyResolved=true metadata to denote that
         /// it was resolved by an external system (commonly from nuget). Such a system has already provided a
         /// resolved closure as primary references and therefore we can skip the expensive closure walk.
         /// </summary>
@@ -846,7 +846,7 @@ internal void AddAssembliesConsideredAndRejected(List<ResolutionSearchLocation>
         ///
         /// For example, if 'sourceReference' is MyAssembly.dll then a dependent assembly file
         /// might be en\MyAssembly.resources.dll
-        /// 
+        ///
         /// Assembly references do not have their own dependencies, therefore they are
         /// </summary>
         /// <param name="sourceReference">The source reference that this reference will be dependent on</param>
@@ -871,7 +871,7 @@ internal void MakeDependentAssemblyReference(Reference sourceReference)
         }
 
         /// <summary>
-        /// Make this reference a primary assembly reference. 
+        /// Make this reference a primary assembly reference.
         /// This is a refrence that is an assembly and is primary.
         /// </summary>
         /// <param name="sourceItem">The source item.</param>
@@ -1144,7 +1144,7 @@ public override string ToString()
         }
 
         /// <summary>
-        /// There are a number of properties which are set when we generate exclusion lists and it is useful to have this information on the references so that 
+        /// There are a number of properties which are set when we generate exclusion lists and it is useful to have this information on the references so that
         /// the correct reasons can be logged for these references being in the black list.
         /// </summary>
         internal class ExclusionListProperties
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 85a5643f5c9..706749d4953 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1061,7 +1061,7 @@ List<Exception> generalResolutionExceptions
             {
                 /*
                 PERF NOTE: The Silent flag turns off logging completely from the task side. This means
-                we avoid the String.Formats that would normally occur even if the verbosity was set to 
+                we avoid the String.Formats that would normally occur even if the verbosity was set to
                 quiet at the engine level.
                 */
                 if (!Silent)
@@ -1119,7 +1119,7 @@ quiet at the engine level.
                             string details = string.Empty;
                             if (logWarning)
                             {
-                                // This warning is logged regardless of AutoUnify since it means a conflict existed where the reference	
+                                // This warning is logged regardless of AutoUnify since it means a conflict existed where the reference
                                 // chosen was not the conflict victor in a version comparison. In other words, the victor was older.
                                 Log.LogWarningWithCodeFromResources("ResolveAssemblyReference.FoundConflicts", assemblyName.Name, output);
                             }
@@ -1164,15 +1164,15 @@ quiet at the engine level.
                             {
                                 foreach (AssemblyNameExtension conflictVictim in conflictVictims)
                                 {
-                                    // Make note we only output a conflict suggestion if the reference has at 
-                                    // least one conflict victim - that way we don't suggest redirects to 
+                                    // Make note we only output a conflict suggestion if the reference has at
+                                    // least one conflict victim - that way we don't suggest redirects to
                                     // assemblies that don't exist at runtime. For example, this avoids us suggesting
                                     // a redirect from Foo 1.0.0.0 -> 2.0.0.0 in the following:
                                     //
                                     //      Project -> Foo, 1.0.0.0
                                     //      Project -> Bar -> Foo, 2.0.0.0
                                     //
-                                    // Above, Foo, 1.0.0.0 wins out and is copied to the output directory because 
+                                    // Above, Foo, 1.0.0.0 wins out and is copied to the output directory because
                                     // it is a primary reference.
                                     foundAtLeastOneValidBindingRedirect = true;
 
@@ -2227,7 +2227,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             if (targetingProfile)
                             {
                                 // When targeting a profile we want the redist list to be the full framework redist list, since this is what should be used
-                                // when unifying assemblies ect. 
+                                // when unifying assemblies ect.
                                 AssemblyTableInfo[] fullRedistAssemblyTableInfo = null;
                                 RedistList fullFrameworkRedistList = null;
 
@@ -2403,7 +2403,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             dependencyTable.RemoveReferencesMarkedForExclusion(true /* Remove the reference and do not warn*/, subsetOrProfileName);
                         }
 
-                        // Based on the closure, get a table of ideal remappings needed to 
+                        // Based on the closure, get a table of ideal remappings needed to
                         // produce zero conflicts.
                         dependencyTable.ResolveConflicts
                         (
@@ -2464,8 +2464,8 @@ out _copyLocalFiles
                     // If we're not finding dependencies, then don't suggest redirects (they're only about dependencies).
                     if (FindDependencies)
                     {
-                        // Build the table of suggested redirects. If we're auto-unifying, we want to output all the 
-                        // assemblies that we auto-unified so that GenerateBindingRedirects can consume them, 
+                        // Build the table of suggested redirects. If we're auto-unifying, we want to output all the
+                        // assemblies that we auto-unified so that GenerateBindingRedirects can consume them,
                         // not just the required ones for build to succeed
                         List<DependentAssembly> remappings = AutoUnify ? autoUnifiedRemappedAssemblies : idealAssemblyRemappings;
                         List<AssemblyNameReference> remappedReferences = AutoUnify ? autoUnifiedRemappedAssemblyReferences : idealAssemblyRemappingsIdentities;
@@ -2559,7 +2559,7 @@ out _copyLocalFiles
                                 {
                                     // Its pretty hard to get here, you need an assembly that contains a valid reference
                                     // to a dependent assembly that, in turn, throws a FileLoadException during GetAssemblyName.
-                                    // Still it happened once, with an older version of the CLR. 
+                                    // Still it happened once, with an older version of the CLR.
 
                                     // ...falling through and relying on the targetAssemblyName==null behavior below...
                                 }
@@ -2636,7 +2636,7 @@ private AssemblyNameExtension[] GetDependencies(Reference resolvedReference, Fil
             {
                 try
                 {
-                    // in case of P2P that have not build the reference can be resolved but file does not exist on disk. 
+                    // in case of P2P that have not build the reference can be resolved but file does not exist on disk.
                     if (fileExists(resolvedReference.FullPath))
                     {
                         FrameworkNameVersioning frameworkName;
@@ -2910,7 +2910,7 @@ private bool ShouldUseSubsetExclusionList()
                 return false;
             }
 
-            // No subset names were passed in to search for in the targetframework directories and no installed subset tables were provided, we have nothing to use to 
+            // No subset names were passed in to search for in the targetframework directories and no installed subset tables were provided, we have nothing to use to
             // generate the exclusion list with, so do not continue.
             if (_targetFrameworkSubsets.Length == 0 && _installedAssemblySubsetTables.Length == 0)
             {
diff --git a/src/Tasks/CombineTargetFrameworkInfoProperties.cs b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
index 2db3b55580b..4108feb5246 100644
--- a/src/Tasks/CombineTargetFrameworkInfoProperties.cs
+++ b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
@@ -39,8 +39,7 @@ public override bool Execute()
         {
             if (PropertiesAndValues != null)
             {
-                // When removing the change wave, also remove UseAttributeForTargetFrameworkInfoPropertyNames.
-                XElement root = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) || UseAttributeForTargetFrameworkInfoPropertyNames ?
+                XElement root = UseAttributeForTargetFrameworkInfoPropertyNames ?
                     new("TargetFramework", new XAttribute("Name", EscapingUtilities.Escape(RootElementName))) :
                     new(RootElementName);
 
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index fff6c863cf8..45a3a11ae8d 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -304,7 +304,7 @@ FileState destinationFileState  // The destination file
 
                 File.Copy(sourceFileState.Name, destinationFileState.Name, true);
             }
-            
+
             // Files were successfully copied or linked. Those are equivalent here.
             WroteAtLeastOneFile = true;
 
@@ -587,7 +587,11 @@ private bool CopyParallel(
             foreach (List<int> partition in partitionsByDestination.Values)
             {
                 bool partitionAccepted = partitionCopyActionBlock.Post(partition);
-                if (!partitionAccepted)
+                if (_cancellationTokenSource.IsCancellationRequested)
+                {
+                    break;
+                }
+                else if (!partitionAccepted)
                 {
                     // Retail assert...
                     ErrorUtilities.ThrowInternalError("Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity.");
@@ -941,17 +945,17 @@ private static bool PathsAreIdentical(string source, string destination)
             return String.Equals(fullSourcePath, fullDestinationPath, filenameComparison);
         }
 
-    	private static int GetParallelismFromEnvironment()
-	    {
-	        int parallelism = Traits.Instance.CopyTaskParallelism;
-	        if (parallelism < 0)
-	        {
-	            parallelism = DefaultCopyParallelism;
-	        }
+        private static int GetParallelismFromEnvironment()
+        {
+            int parallelism = Traits.Instance.CopyTaskParallelism;
+            if (parallelism < 0)
+            {
+                parallelism = DefaultCopyParallelism;
+            }
             else if (parallelism == 0)
-	        {
-	            parallelism = int.MaxValue;
-	        }
+            {
+                parallelism = int.MaxValue;
+            }
             return parallelism;
         }
     }
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
index 8bb05df15dd..9787b51e366 100644
--- a/src/Tasks/GetCompatiblePlatform.cs
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -51,8 +51,7 @@ public GetCompatiblePlatform()
 
         public override bool Execute()
         {
-            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(PlatformLookupTable);
-
+            
             AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];
             for (int i = 0; i < AnnotatedProjects.Length; i++)
             {
@@ -62,65 +61,7 @@ public override bool Execute()
                 string projectReferencePlatformsMetadata = AssignedProjectsWithPlatform[i].GetMetadata("Platforms");
                 string projectReferenceLookupTableMetadata = AssignedProjectsWithPlatform[i].GetMetadata("PlatformLookupTable");
 
-                if (string.IsNullOrEmpty(projectReferencePlatformsMetadata) && string.IsNullOrEmpty(referencedProjectPlatform))
-                {
-                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoPlatformsListed", AssignedProjectsWithPlatform[i].ItemSpec);
-                    continue;
-                }
-
-                // Pull platformlookuptable metadata from the referenced project. This allows custom
-                // mappings on a per-ProjectReference basis.
-                Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata);
-
-                HashSet<string> projectReferencePlatforms = new HashSet<string>();
-                foreach (string s in projectReferencePlatformsMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
-                {
-                    projectReferencePlatforms.Add(s);
-                }
-
-                string buildProjectReferenceAs = string.Empty;
-
-                // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
-                // Don't set `buildProjectReferenceAs` and the `_GetProjectReferencePlatformProperties` target will handle the rest.
-                if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(CurrentProjectPlatform, StringComparison.OrdinalIgnoreCase))
-                {
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", AssignedProjectsWithPlatform[i].ItemSpec, referencedProjectPlatform);
-                }
-                // Prefer matching platforms
-                else if (projectReferencePlatforms.Contains(CurrentProjectPlatform))
-                {
-                    buildProjectReferenceAs = CurrentProjectPlatform;
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.SamePlatform");
-                }
-                // Prioritize PlatformLookupTable **metadata** attached to the ProjectReference item
-                // before the current project's table. We do this to allow per-ProjectReference fine tuning.
-                else if (projectReferenceLookupTable != null &&
-                        projectReferenceLookupTable.ContainsKey(CurrentProjectPlatform) &&
-                        projectReferencePlatforms.Contains(projectReferenceLookupTable[CurrentProjectPlatform]))
-                {
-                    buildProjectReferenceAs = projectReferenceLookupTable[CurrentProjectPlatform];
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", CurrentProjectPlatform, buildProjectReferenceAs, projectReferenceLookupTableMetadata);
-                }
-                // Current project's translation table follows
-                else if (currentProjectLookupTable != null &&
-                        currentProjectLookupTable.ContainsKey(CurrentProjectPlatform) &&
-                        projectReferencePlatforms.Contains(currentProjectLookupTable[CurrentProjectPlatform]))
-                {
-                    buildProjectReferenceAs = currentProjectLookupTable[CurrentProjectPlatform];
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", CurrentProjectPlatform, buildProjectReferenceAs, PlatformLookupTable);
-                }
-                // AnyCPU if possible
-                else if (projectReferencePlatforms.Contains("AnyCPU"))
-                {
-                    buildProjectReferenceAs = "AnyCPU";
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.AnyCPUDefault");
-                }
-                else
-                {
-                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine 
-                    // Platform/PlatformTarget when this is the case.
-                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", AssignedProjectsWithPlatform[i].ItemSpec);
-                }
+                string? buildProjectReferenceAs = PlatformNegotiation.GetNearestPlatform(referencedProjectPlatform, projectReferencePlatformsMetadata, projectReferenceLookupTableMetadata, PlatformLookupTable, AssignedProjectsWithPlatform[i].ItemSpec, CurrentProjectPlatform, Log);
 
                 AssignedProjectsWithPlatform[i].SetMetadata("NearestPlatform", buildProjectReferenceAs);
                 Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.DisplayChosenPlatform", AssignedProjectsWithPlatform[i].ItemSpec, buildProjectReferenceAs);
@@ -128,33 +69,5 @@ public override bool Execute()
 
             return !Log.HasLoggedErrors;
         }
-
-        private Dictionary<string, string>? ExtractLookupTable(string stringTable)
-        {
-            if (string.IsNullOrEmpty(stringTable))
-            {
-                return null;
-            }
-
-            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-
-            foreach (string s in stringTable.Trim().Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
-            {
-                string[] keyVal = s.Trim().Split(MSBuildConstants.EqualsChar);
-
-                // Invalid table, don't use it.
-                if (keyVal.Length != 2 || string.IsNullOrEmpty(keyVal[0]) || string.IsNullOrEmpty(keyVal[1]))
-                {
-                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.InvalidLookupTableFormat", stringTable);
-                    return null;
-                }
-
-                table[keyVal[0]] = keyVal[1];
-            }
-
-            Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.LookupTableParsed", stringTable);
-
-            return table;
-        }
     }
 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 46a0c77b3e5..c08a5129001 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+ï»¿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -191,6 +191,10 @@
     <Compile Include="..\Shared\LanguageParser\VisualBasictokenizer.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\PlatformNegotiation.cs">
+      <Link>PlatformNegotiation.cs</Link>
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="..\Shared\XMakeAttributes.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Tasks/Microsoft.CSharp.CrossTargeting.targets b/src/Tasks/Microsoft.CSharp.CrossTargeting.targets
index 62d284b87e2..8407654f98d 100644
--- a/src/Tasks/Microsoft.CSharp.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.CSharp.CrossTargeting.targets
@@ -9,7 +9,6 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
   <!-- Import design time targets for Roslyn Project System. These are only available if Visual Studio is installed. -->
@@ -22,4 +21,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="Microsoft.Common.CrossTargeting.targets" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
index 6e68b0dd542..772d1bbcf8e 100644
--- a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.CSharp.CurrentVersion.targets
 
@@ -14,7 +14,6 @@ this file.
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
     <PropertyGroup>
@@ -370,4 +369,4 @@ using System.Reflection%3b
     <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter')"/>
     <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter')"/>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.CSharp.targets b/src/Tasks/Microsoft.CSharp.targets
index 9aceb4e3813..eda6bea88ab 100644
--- a/src/Tasks/Microsoft.CSharp.targets
+++ b/src/Tasks/Microsoft.CSharp.targets
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.CSharp.targets
 
@@ -14,26 +14,25 @@ this file.
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
-   <Choose>
-      <When Condition="'$(IsCrossTargetingBuild)' == 'true'">
-         <PropertyGroup>
-            <CSharpTargetsPath>$(MSBuildToolsPath)\Microsoft.CSharp.CrossTargeting.targets</CSharpTargetsPath>
-          </PropertyGroup>
-      </When>
-      <Otherwise>
-         <PropertyGroup>
-            <CSharpTargetsPath>$(MSBuildToolsPath)\Microsoft.CSharp.CurrentVersion.targets</CSharpTargetsPath>
-         </PropertyGroup>
-      </Otherwise>
-   </Choose>
+  <Choose>
+    <When Condition="'$(IsCrossTargetingBuild)' == 'true'">
+      <PropertyGroup>
+        <CSharpTargetsPath>$(MSBuildToolsPath)\Microsoft.CSharp.CrossTargeting.targets</CSharpTargetsPath>
+      </PropertyGroup>
+    </When>
+    <Otherwise>
+      <PropertyGroup>
+        <CSharpTargetsPath>$(MSBuildToolsPath)\Microsoft.CSharp.CurrentVersion.targets</CSharpTargetsPath>
+      </PropertyGroup>
+    </Otherwise>
+  </Choose>
 
-   <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets" />
+  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets" />
 
-   <Import Project="$(CSharpTargetsPath)" />
+  <Import Project="$(CSharpTargetsPath)" />
 
-   <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.After.targets" />
+  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.After.targets" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 13d74133003..5096427a963 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.Common.CrossTargeting.targets
 
@@ -9,7 +9,6 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project DefaultTargets="Build">
 
   <PropertyGroup>
@@ -221,4 +220,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')"/>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 01a2850ca17..7819000499b 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.Common.CurrentVersion.targets
 
@@ -13,7 +13,6 @@ Visual Basic, and Visual C#.
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project DefaultTargets="Build" TreatAsLocalProperty="OutDir">
 
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="'$(MicrosoftCommonPropsHasBeenImported)' != 'true' and Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
@@ -1907,9 +1906,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </_AdditionalTargetFrameworkInfoPropertyWithValue>
     </ItemGroup>
 
+    <PropertyGroup>
+      <_UseAttributeForTargetFrameworkInfoPropertyNames Condition="'$(_UseAttributeForTargetFrameworkInfoPropertyNames)' == ''">false</_UseAttributeForTargetFrameworkInfoPropertyNames>
+    </PropertyGroup>
+
     <CombineTargetFrameworkInfoProperties
         RootElementName="$(TargetFramework)"
-        PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)">
+        PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)"
+        UseAttributeForTargetFrameworkInfoPropertyNames="$(_UseAttributeForTargetFrameworkInfoPropertyNames)">
       <Output TaskParameter="Result"
               PropertyName="_AdditionalTargetFrameworkInfoProperties"/>
     </CombineTargetFrameworkInfoProperties>
@@ -6666,4 +6670,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')"/>
   <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')"/>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Common.overridetasks b/src/Tasks/Microsoft.Common.overridetasks
index c63abe19d52..6032f7ccf9a 100644
--- a/src/Tasks/Microsoft.Common.overridetasks
+++ b/src/Tasks/Microsoft.Common.overridetasks
@@ -1,39 +1,40 @@
-ï»¿<Project>
+<Project>
 
-    <!-- This file lists UsingTask elements that we wish to override
-         any other UsingTask elements -->
+  <!-- This file lists UsingTask elements that we wish to override
+        any other UsingTask elements -->
 
-    <!-- NOTE: Listing a <UsingTask> tag in a *.tasks file like this one rather than in a project or targets file
-               can give a significant performance advantage in a large build, because every time a <UsingTask> tag
-               is encountered, it will cause the task to be rediscovered next time the task is used. -->
-    <!-- NOTE: Using the fully qualified class name in a <UsingTask> tag is faster than using a partially qualified name. -->
+  <!-- NOTE: Listing a <UsingTask> tag in a *.tasks file like this one rather than in a project or targets file
+             can give a significant performance advantage in a large build, because every time a <UsingTask> tag
+             is encountered, it will cause the task to be rediscovered next time the task is used. -->
 
-    <UsingTask TaskName="Microsoft.Build.Tasks.ResolveComReference"  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5'" />
+  <!-- NOTE: Using the fully qualified class name in a <UsingTask> tag is faster than using a partially qualified name. -->
 
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"     AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveComReference"  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5'" />
 
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"     AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"     AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
 
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"   AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"     AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
 
-    <UsingTask TaskName="ResolveComReference"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0'" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"   AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
 
-    <UsingTask TaskName="GenerateResource"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
-    <UsingTask TaskName="GenerateResource"                           AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+  <UsingTask TaskName="ResolveComReference"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0'" />
 
-    <UsingTask TaskName="RegisterAssembly"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
-    <UsingTask TaskName="RegisterAssembly"                           AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+  <UsingTask TaskName="GenerateResource"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
+  <UsingTask TaskName="GenerateResource"                           AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
 
-    <UsingTask TaskName="UnregisterAssembly"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
-    <UsingTask TaskName="UnregisterAssembly"                         AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+  <UsingTask TaskName="RegisterAssembly"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
+  <UsingTask TaskName="RegisterAssembly"                           AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
 
-    <UsingTask TaskName="ReadLinesFromFile"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
-    <UsingTask TaskName="FindUnderPath"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
-    <UsingTask TaskName="ConvertToAbsolutePath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
-    <UsingTask TaskName="MSBuild"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
-    <UsingTask TaskName="ResolveAssemblyReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '4.0'" />
+  <UsingTask TaskName="UnregisterAssembly"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
+  <UsingTask TaskName="UnregisterAssembly"                         AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
 
-</Project>
+  <UsingTask TaskName="ReadLinesFromFile"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
+  <UsingTask TaskName="FindUnderPath"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
+  <UsingTask TaskName="ConvertToAbsolutePath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
+  <UsingTask TaskName="MSBuild"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
+  <UsingTask TaskName="ResolveAssemblyReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '4.0'" />
+
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Common.props b/src/Tasks/Microsoft.Common.props
index 4385c405f61..a14fea277c2 100644
--- a/src/Tasks/Microsoft.Common.props
+++ b/src/Tasks/Microsoft.Common.props
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.Common.props
 
@@ -9,7 +9,6 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
   <PropertyGroup>
@@ -21,9 +20,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <!--
-        Determine the path to the directory build props file if the user did not disable $(ImportDirectoryBuildProps) and
-        they did not already specify an absolute path to use via $(DirectoryBuildPropsPath)
-    -->
+      Determine the path to the directory build props file if the user did not disable $(ImportDirectoryBuildProps) and
+      they did not already specify an absolute path to use via $(DirectoryBuildPropsPath)
+  -->
   <PropertyGroup Condition="'$(ImportDirectoryBuildProps)' == 'true' and '$(DirectoryBuildPropsPath)' == ''">
     <_DirectoryBuildPropsFile Condition="'$(_DirectoryBuildPropsFile)' == ''">Directory.Build.props</_DirectoryBuildPropsFile>
     <_DirectoryBuildPropsBasePath Condition="'$(_DirectoryBuildPropsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildPropsFile)'))</_DirectoryBuildPropsBasePath>
@@ -33,17 +32,17 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Import Project="$(DirectoryBuildPropsPath)" Condition="'$(ImportDirectoryBuildProps)' == 'true' and exists('$(DirectoryBuildPropsPath)')"/>
 
   <!--
-        Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
-          $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.props
+      Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
+        $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.props
 
-        Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
-        management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
-    -->
+      Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
+      management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
+  -->
   <PropertyGroup>
     <!--
-            The declaration of $(BaseIntermediateOutputPath) had to be moved up from Microsoft.Common.CurrentVersion.targets
-            in order for the $(MSBuildProjectExtensionsPath) to use it as a default.
-        -->
+        The declaration of $(BaseIntermediateOutputPath) had to be moved up from Microsoft.Common.CurrentVersion.targets
+        in order for the $(MSBuildProjectExtensionsPath) to use it as a default.
+    -->
     <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)'=='' ">obj\</BaseIntermediateOutputPath>
     <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
     <_InitialBaseIntermediateOutputPath>$(BaseIntermediateOutputPath)</_InitialBaseIntermediateOutputPath>
@@ -53,7 +52,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Import paths that are relative default to be relative to the importing file.  However, since MSBuildExtensionsPath
         defaults to BaseIntermediateOutputPath we expect it to be relative to the project directory.  So if the path is relative
         it needs to be made absolute based on the project directory.
-      -->
+    -->
     <MSBuildProjectExtensionsPath Condition="'$([System.IO.Path]::IsPathRooted($(MSBuildProjectExtensionsPath)))' == 'false'">$([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(MSBuildProjectExtensionsPath)'))</MSBuildProjectExtensionsPath>
     <MSBuildProjectExtensionsPath Condition="!HasTrailingSlash('$(MSBuildProjectExtensionsPath)')">$(MSBuildProjectExtensionsPath)\</MSBuildProjectExtensionsPath>
     <ImportProjectExtensionProps Condition="'$(ImportProjectExtensionProps)' == ''">true</ImportProjectExtensionProps>
@@ -63,12 +62,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Import Project="$(MSBuildProjectExtensionsPath)$(MSBuildProjectFile).*.props" Condition="'$(ImportProjectExtensionProps)' == 'true' and exists('$(MSBuildProjectExtensionsPath)')" />
 
   <!--
-          Wildcard imports come from $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ directory.
-          This is very similar to the same extension point used in Microsoft.Common.targets, which is located in
-          the $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ directory.
-          Unfortunately, there is already a file named "Microsoft.Common.props" in this directory,
-          so we have to have a slightly different directory name to hold extensions.
-    -->
+      Wildcard imports come from $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ directory.
+      This is very similar to the same extension point used in Microsoft.Common.targets, which is located in
+      the $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ directory.
+
+      Unfortunately, there is already a file named "Microsoft.Common.props" in this directory,
+      so we have to have a slightly different directory name to hold extensions.
+  -->
   <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')"/>
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')"/>
 
@@ -80,8 +80,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Import Project="$(CustomBeforeMicrosoftCommonProps)" Condition="'$(CustomBeforeMicrosoftCommonProps)' != '' and Exists('$(CustomBeforeMicrosoftCommonProps)')" />
 
   <!-- This is used to determine whether Microsoft.Common.targets needs to import
-         Microsoft.Common.props itself, or whether it has been imported previously,
-         e.g. by the project itself. -->
+      Microsoft.Common.props itself, or whether it has been imported previously,
+      e.g. by the project itself. -->
   <PropertyGroup>
     <MicrosoftCommonPropsHasBeenImported>true</MicrosoftCommonPropsHasBeenImported>
   </PropertyGroup>
@@ -104,8 +104,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')"/>
 
   <!--
-        Import NuGet.props file.
-    -->
+      Import NuGet.props file.
+  -->
   <PropertyGroup>
     <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
     <NuGetPropsFile Condition="'$(NuGetPropsFile)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.props</NuGetPropsFile>
@@ -130,4 +130,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>true</DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>
   </PropertyGroup>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Common.targets b/src/Tasks/Microsoft.Common.targets
index a2e63d0c48d..e4f83cd7640 100644
--- a/src/Tasks/Microsoft.Common.targets
+++ b/src/Tasks/Microsoft.Common.targets
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.Common.targets
 
@@ -13,12 +13,12 @@ Visual Basic, and Visual C#.
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project DefaultTargets="Build">
 
   <PropertyGroup>
     <CommonTargetsPath>$(MSBuildToolsPath)\Microsoft.Common.CurrentVersion.targets</CommonTargetsPath>
   </PropertyGroup>
+
   <Import Project="$(CommonTargetsPath)" />
 
   <!--
@@ -27,7 +27,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
         Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
         management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
-    -->
+  -->
   <PropertyGroup>
     <ImportProjectExtensionTargets Condition="'$(ImportProjectExtensionTargets)' == ''">true</ImportProjectExtensionTargets>
   </PropertyGroup>
@@ -39,9 +39,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <!--
-        Determine the path to the directory build targets file if the user did not disable $(ImportDirectoryBuildTargets) and
-        they did not already specify an absolute path to use via $(DirectoryBuildTargetsPath)
-    -->
+      Determine the path to the directory build targets file if the user did not disable $(ImportDirectoryBuildTargets) and
+      they did not already specify an absolute path to use via $(DirectoryBuildTargetsPath)
+  -->
   <PropertyGroup Condition="'$(ImportDirectoryBuildTargets)' == 'true' and '$(DirectoryBuildTargetsPath)' == ''">
     <_DirectoryBuildTargetsFile Condition="'$(_DirectoryBuildTargetsFile)' == ''">Directory.Build.targets</_DirectoryBuildTargetsFile>
     <_DirectoryBuildTargetsBasePath Condition="'$(_DirectoryBuildTargetsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildTargetsFile)'))</_DirectoryBuildTargetsBasePath>
@@ -50,4 +50,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')"/>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index 3be5690920c..8bcaa32b507 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -1,108 +1,109 @@
-ï»¿<Project>
+<Project>
 
-    <!-- This file lists all the tasks that ship by default with MSBuild -->
+  <!-- This file lists all the tasks that ship by default with MSBuild -->
 
-    <!-- NOTE: Listing a <UsingTask> tag in a *.tasks file like this one rather than in a project or targets file
-               can give a significant performance advantage in a large build, because every time a <UsingTask> tag
-               is encountered, it will cause the task to be rediscovered next time the task is used. -->
-    <!-- NOTE: Using the fully qualified class name in a <UsingTask> tag is faster than using a partially qualified name. -->
+  <!-- NOTE: Listing a <UsingTask> tag in a *.tasks file like this one rather than in a project or targets file
+             can give a significant performance advantage in a large build, because every time a <UsingTask> tag
+             is encountered, it will cause the task to be rediscovered next time the task is used. -->
 
-    <UsingTask TaskName="Microsoft.Build.Tasks.AL"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.AspNetCompiler"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.AssignCulture"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.AssignLinkMetadata"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.AssignProjectConfiguration"            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.AssignTargetPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.CallTarget"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.CombinePath"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ConvertToAbsolutePath"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties"  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.CombineXmlElements"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.Copy"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.CreateCSharpManifestResourceName"      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.CreateItem"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.CreateProperty"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName" AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.Delete"                                AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.DownloadFile"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.Error"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ErrorFromResources"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.Exec"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.FindAppConfigFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.FindInList"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.FindInvalidProjectReferences"          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <!-- NOTE: Using the fully qualified class name in a <UsingTask> tag is faster than using a partially qualified name. -->
 
-    <UsingTask TaskName="Microsoft.Build.Tasks.FindUnderPath"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.FormatUrl"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.FormatVersion"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateApplicationManifest"           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateBindingRedirects"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateBootstrapper"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateDeploymentManifest"            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateLauncher"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.AL"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.AspNetCompiler"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.AssignCulture"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.AssignLinkMetadata"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.AssignProjectConfiguration"            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.AssignTargetPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.CallTarget"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.CombinePath"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ConvertToAbsolutePath"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties"  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.CombineXmlElements"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.Copy"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.CreateCSharpManifestResourceName"      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.CreateItem"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.CreateProperty"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName" AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.Delete"                                AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.DownloadFile"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.Error"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ErrorFromResources"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.Exec"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.FindAppConfigFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.FindInList"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.FindInvalidProjectReferences"          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="NET" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' == 'Core'" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == ''  and '$(MSBuildRuntimeType)' != 'Core'" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.FindUnderPath"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.FormatUrl"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.FormatVersion"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateApplicationManifest"           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateBindingRedirects"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateBootstrapper"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateDeploymentManifest"            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateLauncher"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateTrustInfo"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GetCompatiblePlatform"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GetFileHash"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GetReferenceAssemblyPaths"             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.Hash"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.LC"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.MakeDir"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.Message"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.Move"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.MSBuild"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(DisableOutOfProcTaskHost)' != ''" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="NET" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' == 'Core'" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == ''  and '$(MSBuildRuntimeType)' != 'Core'" />
 
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GenerateTrustInfo"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetCompatiblePlatform"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetFileHash"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetReferenceAssemblyPaths"             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.Hash"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.LC"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.MakeDir"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.Message"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.Move"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.MSBuild"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
-    <UsingTask TaskName="Microsoft.Build.Tasks.RemoveDir"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RemoveDuplicates"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RequiresFramework35SP1Assembly"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ResolveAssemblyReference"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet"            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GetInstalledSDKLocations"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GetSDKReferenceFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ResolveComReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ResolveKeySource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ResolveManifestFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ResolveNativeReference"                AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.SGen"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.SignFile"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.Telemetry"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.Touch"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(DisableOutOfProcTaskHost)' != ''" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RemoveDir"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RemoveDuplicates"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RequiresFramework35SP1Assembly"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveAssemblyReference"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet"            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetInstalledSDKLocations"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetSDKReferenceFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveComReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveKeySource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveManifestFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveNativeReference"                AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.SGen"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.SignFile"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.Telemetry"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.Touch"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
-    <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.Unzip"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.VerifyFileHash"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.Warning"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.WriteCodeFragment"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.WriteLinesToFile"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.XmlPeek"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.XmlPoke"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.XslTransformation"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.WinMDExp"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.ZipDirectory"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(DisableOutOfProcTaskHost)' != ''" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
-    <!-- Roslyn tasks are now in an assembly owned and shipped by Roslyn -->
-    <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Csc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
-    <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
-    <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.Unzip"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.VerifyFileHash"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.Warning"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.WriteCodeFragment"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.WriteLinesToFile"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.XmlPeek"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.XmlPoke"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.XslTransformation"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.WinMDExp"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ZipDirectory"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
-</Project>
+  <!-- Roslyn tasks are now in an assembly owned and shipped by Roslyn -->
+  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Csc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
+  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
+  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
+
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Data.Entity.targets b/src/Tasks/Microsoft.Data.Entity.targets
index 80d43afd2be..6ebf8cdb6ea 100644
--- a/src/Tasks/Microsoft.Data.Entity.targets
+++ b/src/Tasks/Microsoft.Data.Entity.targets
@@ -1,15 +1,15 @@
-ï»¿<Project>
+<Project>
 
-   <!--
-        With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
+  <!--
+      With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
+      outside of the .NET Framework.  As a result of this, there were several targets files, of which
+      this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
-        consumers of them are not broken, but since the targets files themselves are still part of .NET,
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
-   -->
+      Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+      consumers of them are not broken, but since the targets files themselves are still part of .NET,
+      the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
+  -->
 
-   <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.Data.Entity.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.Data.Entity.targets')" />
+  <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.Data.Entity.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.Data.Entity.targets')" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
index a5dfd1da0ff..a10bf7c0784 100644
--- a/src/Tasks/Microsoft.Managed.After.targets
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
           created a backup copy.  Incorrect changes to this file will make it
@@ -10,32 +10,31 @@ It is imported after the common targets have been imported.
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
-   <!-- Define crosstargeting for static graph, so it can identify inner and outer build graph nodes -->
-   <PropertyGroup>
-      <InnerBuildProperty>TargetFramework</InnerBuildProperty>
-      <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>
-   </PropertyGroup>
+  <!-- Define crosstargeting for static graph, so it can identify inner and outer build graph nodes -->
+  <PropertyGroup>
+    <InnerBuildProperty>TargetFramework</InnerBuildProperty>
+    <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>
+  </PropertyGroup>
 
-   <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
-      <AddTransitiveProjectReferencesInStaticGraph Condition="'$(AddTransitiveProjectReferencesInStaticGraph)' == '' and '$(UsingMicrosoftNETSdk)' == 'true' and '$(DisableTransitiveProjectReferences)' != 'true'">true</AddTransitiveProjectReferencesInStaticGraph>
-   </PropertyGroup>
+  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
+    <AddTransitiveProjectReferencesInStaticGraph Condition="'$(AddTransitiveProjectReferencesInStaticGraph)' == '' and '$(UsingMicrosoftNETSdk)' == 'true' and '$(DisableTransitiveProjectReferences)' != 'true'">true</AddTransitiveProjectReferencesInStaticGraph>
+  </PropertyGroup>
 
-   <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
-      <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.
-           Detect WPF, and exclude the generated project from static graph isolation constraint checking.
-           Escape the item to avoid eager evaluation of the wildcards.
-      -->
-      <GraphIsolationExemptReference
-         Condition="'$(UseWPF)' == 'true' or '@(Page)' != '' or '@(ApplicationDefinition)' != '' or '@(XamlPage)' != '' or '@(XamlAppDef)' != ''"
-         Include="$([MSBuild]::Escape('$(MSBuildProjectDirectory)\$(MSBuildProjectName)*_wpftmp$(MSBuildProjectExtension)'))" />
-   </ItemGroup>
+  <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
+    <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.
+        Detect WPF, and exclude the generated project from static graph isolation constraint checking.
+        Escape the item to avoid eager evaluation of the wildcards.
+    -->
+    <GraphIsolationExemptReference
+        Condition="'$(UseWPF)' == 'true' or '@(Page)' != '' or '@(ApplicationDefinition)' != '' or '@(XamlPage)' != '' or '@(XamlAppDef)' != ''"
+        Include="$([MSBuild]::Escape('$(MSBuildProjectDirectory)\$(MSBuildProjectName)*_wpftmp$(MSBuildProjectExtension)'))" />
+  </ItemGroup>
 
   <!--
-    Properties for extension of ProjectReferenceTargets.
-    Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.
+      Properties for extension of ProjectReferenceTargets.
+      Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.
   -->
   <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
     <!-- Empty case is for outer builds which do not import the target files that set BuildProjectReferences -->
@@ -69,4 +68,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ProjectReferenceTargets Include="GetCopyToPublishDirectoryItems" Targets="$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)" Condition=" '$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)' != '' " />
   </ItemGroup>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Managed.Before.targets b/src/Tasks/Microsoft.Managed.Before.targets
index d8bde6bb9a2..01f2f5ee3de 100644
--- a/src/Tasks/Microsoft.Managed.Before.targets
+++ b/src/Tasks/Microsoft.Managed.Before.targets
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
           created a backup copy.  Incorrect changes to this file will make it
@@ -10,16 +10,15 @@ It is imported before the common targets have been imported.
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
-   <!--
-        We are doing a cross-targeting build if there is a non-empty list of target frameworks specified
-        and there is no current target framework being built individually. In that case, a multitargeting
-        project file like Microsoft.<language>.CrossTargeting.targets gets imported.
-   -->
-   <PropertyGroup Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''">
-      <IsCrossTargetingBuild>true</IsCrossTargetingBuild>
-   </PropertyGroup>
+  <!--
+      We are doing a cross-targeting build if there is a non-empty list of target frameworks specified
+      and there is no current target framework being built individually. In that case, a multitargeting
+      project file like Microsoft.<language>.CrossTargeting.targets gets imported.
+  -->
+  <PropertyGroup Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''">
+    <IsCrossTargetingBuild>true</IsCrossTargetingBuild>
+  </PropertyGroup>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Managed.targets b/src/Tasks/Microsoft.Managed.targets
index 25d1e7528c2..49696addc04 100644
--- a/src/Tasks/Microsoft.Managed.targets
+++ b/src/Tasks/Microsoft.Managed.targets
@@ -1,16 +1,15 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 This file is deprecated and left here for back compat reasons. It is replaced by Microsoft.Managed.<Before|After>.targets
 
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
   <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets" />
 
-   <!-- Item copied from Microsoft.Common.Currentversion.targets   -->
+  <!-- Item copied from Microsoft.Common.Currentversion.targets   -->
   <PropertyGroup>
     <_RecursiveTargetForContentCopying>GetCopyToOutputDirectoryItems</_RecursiveTargetForContentCopying>
     <_RecursiveTargetForContentCopying Condition=" '$(MSBuildCopyContentTransitively)' == 'false' ">_GetCopyToOutputDirectoryItemsFromThisProject</_RecursiveTargetForContentCopying>
@@ -18,4 +17,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.After.targets" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.NET.props b/src/Tasks/Microsoft.NET.props
index 41f25145c5d..b983647d821 100644
--- a/src/Tasks/Microsoft.NET.props
+++ b/src/Tasks/Microsoft.NET.props
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.NET.props
 
@@ -12,7 +12,6 @@ these two files are used to encapsulate the multi-targeting and framework specif
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
   <!--
@@ -21,7 +20,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     Get the paths for the .NET Framework and .NET Core tools and sdk tools directories.
     This does not need to be a target since all of the values are availiable at project evaluation time.
     ============================================================
-    -->
+  -->
   <PropertyGroup>
     <TargetFrameworkSDKToolsDirectory Condition=" '$(TargetFrameworkSDKToolsDirectory)' == '' ">$(SDK40ToolsPath)</TargetFrameworkSDKToolsDirectory>
   </PropertyGroup>
@@ -31,7 +30,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                                         SetHighEntropyVA
     Set HighEntropyVA according to the TargetFramework
     ============================================================
-    -->
+  -->
 
   <PropertyGroup Condition="('$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0') or '$(TargetFrameworkIdentifier)' == '.NETCoreApp' or '$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <HighEntropyVA Condition="'$(HighEntropyVA)' == ''">true</HighEntropyVA>
@@ -41,4 +40,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <HighEntropyVA Condition="'$(HighEntropyVA)' == ''">false</HighEntropyVA>
   </PropertyGroup>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.NETFramework.CurrentVersion.props b/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
index f08677fe9b8..0f03f04dfef 100644
--- a/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
+++ b/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.NETFramework.CurrentVersion.props
 
@@ -12,7 +12,6 @@ these two files are used to encapsulate the multi-targeting and framework specif
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
   <PropertyGroup>
@@ -40,9 +39,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetFrameworkVersion)' == 'v4.0' and '$(FrameworkPathOverride)' == ''">
     <!-- The FrameworkPathOverride property is required for the IDE Visual Basic compiler to initialize.
-             This location contains reference assemblies for mscorlib.dll and other key VB assemblies.
-             This property is required during project evaluation, since the IDE compilers need to initialize before
-             any targets have had a chance to run, hence the use of a function to retrieve the location.
+        This location contains reference assemblies for mscorlib.dll and other key VB assemblies.
+        This property is required during project evaluation, since the IDE compilers need to initialize before
+        any targets have had a chance to run, hence the use of a function to retrieve the location.
      -->
     <!-- Hard code for the most common TargetFrameworkVersion of v4.0 with no profile: this enables us to avoid calling the GetReferenceAssemblyPaths task -->
     <_FullFrameworkReferenceAssemblyPaths Condition="Exists('$(MSBuildProgramFiles32)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\RedistList\FrameworkList.xml')">$(MSBuildProgramFiles32)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0</_FullFrameworkReferenceAssemblyPaths>
@@ -60,7 +59,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <MSBuildFrameworkToolsRoot Condition="'$(MSBuildFrameworkToolsRoot)' == '' and '$(MSBuildRuntimeType)' != 'Core'">$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\.NETFramework@InstallRoot)</MSBuildFrameworkToolsRoot>
     <_DeploymentSignClickOnceManifests Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(SignManifests)' == 'true'">true</_DeploymentSignClickOnceManifests>
     <!-- Assembly names added to the AdditionalExplicitAssemblyReferences property will be added as references to the resolve assembly reference call by default this is done because when upgrading from
-         a project targeting 2.0 to 3.5 the system.core reference is not added, therefore we need to add it automatically -->
+        a project targeting 2.0 to 3.5 the system.core reference is not added, therefore we need to add it automatically -->
     <AddAdditionalExplicitAssemblyReferences Condition="'$(AddAdditionalExplicitAssemblyReferences)' == ''">true</AddAdditionalExplicitAssemblyReferences>
     <AdditionalExplicitAssemblyReferences Condition="'$(AddAdditionalExplicitAssemblyReferences)' == 'true' and '$(TargetCompactFramework)' != 'true' and ('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.0')">System.Core;$(AdditionalExplicitAssemblyReferences)</AdditionalExplicitAssemblyReferences>
   </PropertyGroup>
@@ -71,15 +70,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     Get the paths for the .NET Framework tools and sdk tools directories.
     This does not need to be a target since all of the values are availiable at project evaluation time.
     ============================================================
-    -->
+  -->
 
   <PropertyGroup>
     <TargetingClr2Framework Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'">true</TargetingClr2Framework>
     <MSBuildManagedCompilerPath Condition="'$(TargetingClr2Framework)' == 'true'">$(MSBuildFrameworkToolsRoot)\v3.5</MSBuildManagedCompilerPath >
     <TargetFrameworkSDKToolsDirectory Condition="'$(TargetingClr2Framework)' == 'true'">$(SDK35ToolsPath)</TargetFrameworkSDKToolsDirectory>
     <!-- If the sdk path is not 3.5 or lower set it to the 40 sdk tools path. This will allow future target framework versions to use the 4.0 sdk tool set
-             When a new windows SDK revs they will inplace update the location pointed to by this property. When a new sdk is release this target will have to be
-             revised along with another toolsversion. -->
+        When a new windows SDK revs they will inplace update the location pointed to by this property. When a new sdk is release this target will have to be
+        revised along with another toolsversion. -->
     <TargetedRuntimeVersion Condition="'$(TargetedRuntimeVersion)' == '' and ('$(TargetingClr2Framework)' == 'true')">v2.0.50727</TargetedRuntimeVersion>
     <TargetedRuntimeVersion Condition="'$(TargetedRuntimeVersion)' == ''">v$(MSBuildRuntimeVersion)</TargetedRuntimeVersion>
   </PropertyGroup>
@@ -119,10 +118,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <!--Import props that are common for both full framework and core.
-    And before the ImportAfter\* , so users can override it-->
+      And before the ImportAfter\* , so users can override it-->
   <Import Project="$(MSBuildToolsPath)\Microsoft.NET.props" />
 
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.props\ImportAfter')"/>
   <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.props\ImportAfter')"/>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets b/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
index 6145e82de80..985f36bfbe9 100644
--- a/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.NETFramework.CurrentVersion.targets
 
@@ -12,7 +12,6 @@ these two files are used to encapsulate the multi-targeting and framework specif
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
   <PropertyGroup>
@@ -30,7 +29,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       DependsOnTargets="$(GetFrameworkPathsDependsOn)">
 
     <!-- For backwards compatibility of targets who replaced this target we cannot move these values outside the target even though they
-             now only depend on statically availiable values-->
+        now only depend on statically availiable values-->
 
     <ItemGroup>
       <_TargetFramework40DirectoryItem Include="$(MSBuildFrameworkToolsRoot)v4.0.30319"/>
@@ -134,4 +133,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter')"/>
   <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter')"/>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.NETFramework.props b/src/Tasks/Microsoft.NETFramework.props
index 805a6081510..a66a0d25e2b 100644
--- a/src/Tasks/Microsoft.NETFramework.props
+++ b/src/Tasks/Microsoft.NETFramework.props
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.NetFramework.props
 
@@ -12,12 +12,12 @@ these two files are used to encapsulate the multi-targeting and framework specif
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project DefaultTargets="Build">
 
   <PropertyGroup>
     <NetFrameworkPropsPath>$(MSBuildToolsPath)\Microsoft.NETFramework.CurrentVersion.props</NetFrameworkPropsPath>
   </PropertyGroup>
+
   <Import Project="$(NetFrameworkPropsPath)" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.NETFramework.targets b/src/Tasks/Microsoft.NETFramework.targets
index 4d17decc15c..d0ff2425a82 100644
--- a/src/Tasks/Microsoft.NETFramework.targets
+++ b/src/Tasks/Microsoft.NETFramework.targets
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.NetFramework.targets
 
@@ -12,12 +12,12 @@ these two files are used to encapsulate the multi-targeting and framework specif
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project DefaultTargets="Build">
 
     <PropertyGroup>
       <NetFrameworkTargetsPath>$(MSBuildToolsPath)\Microsoft.NETFramework.CurrentVersion.targets</NetFrameworkTargetsPath>
     </PropertyGroup>
-   <Import Project="$(NetFrameworkTargetsPath)" />
 
-</Project>
+  <Import Project="$(NetFrameworkTargetsPath)" />
+
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.ServiceModel.targets b/src/Tasks/Microsoft.ServiceModel.targets
index 41d4b1f3d59..f65d5c6e3f9 100644
--- a/src/Tasks/Microsoft.ServiceModel.targets
+++ b/src/Tasks/Microsoft.ServiceModel.targets
@@ -1,15 +1,15 @@
-ï»¿<Project>
+<Project>
 
-   <!--
-        With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
+  <!--
+      With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
+      outside of the .NET Framework.  As a result of this, there were several targets files, of which
+      this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
-        consumers of them are not broken, but since the targets files themselves are still part of .NET,
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
-   -->
+      Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+      consumers of them are not broken, but since the targets files themselves are still part of .NET,
+      the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
+  -->
 
-   <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.ServiceModel.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.ServiceModel.targets')" />
+  <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.ServiceModel.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.ServiceModel.targets')" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualBasic.CrossTargeting.targets b/src/Tasks/Microsoft.VisualBasic.CrossTargeting.targets
index d397da71c95..ceb30bc1a02 100644
--- a/src/Tasks/Microsoft.VisualBasic.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.VisualBasic.CrossTargeting.targets
@@ -9,7 +9,6 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
   <!-- Import design time targets for Roslyn Project System. These are only available if Visual Studio is installed. -->
@@ -22,4 +21,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="Microsoft.Common.CrossTargeting.targets" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets b/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
index daebf98475b..1d83c4a6327 100644
--- a/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.VisualBasic.CurrentVersion.targets
 
@@ -14,7 +14,6 @@ this file.
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
     <PropertyGroup>
@@ -375,4 +374,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualBasic.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftVisualBasicTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualBasic.targets\ImportAfter')"/>
     <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualBasic.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualBasic.targets\ImportAfter')"/>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualBasic.targets b/src/Tasks/Microsoft.VisualBasic.targets
index 3616981103c..aa7a6f812fd 100644
--- a/src/Tasks/Microsoft.VisualBasic.targets
+++ b/src/Tasks/Microsoft.VisualBasic.targets
@@ -1,4 +1,3 @@
-<?xml version="1.0" encoding="utf-8"?>
 <!--
 ***********************************************************************************************
 Microsoft.VisualBasic.targets
@@ -15,7 +14,6 @@ this file.
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
   <Choose>
@@ -37,4 +35,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.After.targets" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v11.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v11.Common.props
index 858e86ecee9..9ef50e92c14 100644
--- a/src/Tasks/Microsoft.VisualStudioVersion.v11.Common.props
+++ b/src/Tasks/Microsoft.VisualStudioVersion.v11.Common.props
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.VisualStudio.v11.Common.props
 
@@ -9,12 +9,11 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0">
 
   <PropertyGroup>
     <VisualStudioVersion>11.0</VisualStudioVersion>
     <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
   </PropertyGroup>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v12.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v12.Common.props
index 6fb9cfdbfa4..428a5c1d571 100644
--- a/src/Tasks/Microsoft.VisualStudioVersion.v12.Common.props
+++ b/src/Tasks/Microsoft.VisualStudioVersion.v12.Common.props
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.VisualStudio.v11.Common.props
 
@@ -9,12 +9,11 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0">
 
   <PropertyGroup>
     <VisualStudioVersion>12.0</VisualStudioVersion>
     <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
   </PropertyGroup>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v14.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v14.Common.props
index 1f0a2830339..c2e2af3ad8e 100644
--- a/src/Tasks/Microsoft.VisualStudioVersion.v14.Common.props
+++ b/src/Tasks/Microsoft.VisualStudioVersion.v14.Common.props
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.VisualStudio.v14.Common.props
 
@@ -9,12 +9,11 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="4.0">
 
   <PropertyGroup>
     <VisualStudioVersion>14.0</VisualStudioVersion>
     <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
   </PropertyGroup>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v15.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v15.Common.props
index 355652bffd0..9d9e0f62d71 100644
--- a/src/Tasks/Microsoft.VisualStudioVersion.v15.Common.props
+++ b/src/Tasks/Microsoft.VisualStudioVersion.v15.Common.props
@@ -9,7 +9,6 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
   <PropertyGroup>
@@ -17,4 +16,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
   </PropertyGroup>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v16.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v16.Common.props
index 832c3d55387..1843227e760 100644
--- a/src/Tasks/Microsoft.VisualStudioVersion.v16.Common.props
+++ b/src/Tasks/Microsoft.VisualStudioVersion.v16.Common.props
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.VisualStudio.v16.Common.props
 
@@ -9,7 +9,6 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
   <PropertyGroup>
@@ -17,4 +16,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
   </PropertyGroup>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v17.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v17.Common.props
index 452a3fe9cd4..94031c33888 100644
--- a/src/Tasks/Microsoft.VisualStudioVersion.v17.Common.props
+++ b/src/Tasks/Microsoft.VisualStudioVersion.v17.Common.props
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.VisualStudio.v17.Common.props
 
@@ -9,7 +9,6 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
   <PropertyGroup>
@@ -17,4 +16,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
   </PropertyGroup>
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.WinFx.targets b/src/Tasks/Microsoft.WinFx.targets
index a2e5e8be195..0c942235926 100644
--- a/src/Tasks/Microsoft.WinFx.targets
+++ b/src/Tasks/Microsoft.WinFx.targets
@@ -1,15 +1,15 @@
-ï»¿<Project>
+<Project>
 
-   <!--
-        With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
+  <!--
+      With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
+      outside of the .NET Framework.  As a result of this, there were several targets files, of which
+      this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
-        consumers of them are not broken, but since the targets files themselves are still part of .NET,
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
-   -->
+      Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+      consumers of them are not broken, but since the targets files themselves are still part of .NET,
+      the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
+  -->
 
-   <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.WinFx.targets" Condition="'$(ImportFrameworkWinFXTargets)' != 'false' and Exists('$(MSBuildFrameworkToolsPath)\Microsoft.WinFx.targets')" />
+  <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.WinFx.targets" Condition="'$(ImportFrameworkWinFXTargets)' != 'false' and Exists('$(MSBuildFrameworkToolsPath)\Microsoft.WinFx.targets')" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.WorkflowBuildExtensions.targets b/src/Tasks/Microsoft.WorkflowBuildExtensions.targets
index 64cbed76b63..580e2f75bc2 100644
--- a/src/Tasks/Microsoft.WorkflowBuildExtensions.targets
+++ b/src/Tasks/Microsoft.WorkflowBuildExtensions.targets
@@ -1,4 +1,4 @@
-ï»¿<!--
+<!--
 ***********************************************************************************************
 Microsoft.WorkflowBuildExtensions.targets
 
@@ -9,31 +9,30 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
-
 <Project>
 
-   <!--
-        With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
+  <!--
+      With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
+      outside of the .NET Framework.  As a result of this, there were several targets files, of which
+      this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
-        consumers of them are not broken, but since the targets files themselves are still part of .NET,
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
-   -->
+      Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+      consumers of them are not broken, but since the targets files themselves are still part of .NET,
+      the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
+  -->
 
-   <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets')" />
+  <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets')" />
 
-   <!--
-         This target in $(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets does bad
-         things to builds inside Visual Studio. Specifically, it generates files *only* when building from
-         within VS, for both real and design-time builds. This leads to all kinds of build problems.
+  <!--
+      This target in $(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets does bad
+      things to builds inside Visual Studio. Specifically, it generates files *only* when building from
+      within VS, for both real and design-time builds. This leads to all kinds of build problems.
 
-         In Dev16 we no longer need these files to exist on disk for Workflow Designer scenarios. We can't
-         modify $(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets because that would
-         break the Workflow Designer for older versions of VS. Instead, we effectively turn it off by
-         overriding it with a no-op implementation here.
-   -->
-   <Target Name="GenerateCompiledExpressionsTempFile" />
+      In Dev16 we no longer need these files to exist on disk for Workflow Designer scenarios. We can't
+      modify $(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets because that would
+      break the Workflow Designer for older versions of VS. Instead, we effectively turn it off by
+      overriding it with a no-op implementation here.
+  -->
+  <Target Name="GenerateCompiledExpressionsTempFile" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.Xaml.targets b/src/Tasks/Microsoft.Xaml.targets
index c8a743e39e3..de6672bd427 100644
--- a/src/Tasks/Microsoft.Xaml.targets
+++ b/src/Tasks/Microsoft.Xaml.targets
@@ -1,22 +1,22 @@
-ï»¿<Project>
+<Project>
 
-   <!--
-        With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
+  <!--
+      With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
+      outside of the .NET Framework.  As a result of this, there were several targets files, of which
+      this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
-        consumers of them are not broken, but since the targets files themselves are still part of .NET,
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
-   -->
+      Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+      consumers of them are not broken, but since the targets files themselves are still part of .NET,
+      the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
+  -->
 
-   <!-- In the original Microsoft.Xaml.targets this is mapped to MSBuildBinPath, which is no longer
-        the .NET Framework directory and thus will no longer be the right answer. Override it to point
-        to the correct .NET Framework location. -->
-   <PropertyGroup>
-      <XamlBuildTaskPath Condition="'$(XamlBuildTaskPath)' == ''">$(MSBuildToolsPath64)</XamlBuildTaskPath>
-   </PropertyGroup>
+  <!-- In the original Microsoft.Xaml.targets this is mapped to MSBuildBinPath, which is no longer
+      the .NET Framework directory and thus will no longer be the right answer. Override it to point
+      to the correct .NET Framework location. -->
+  <PropertyGroup>
+    <XamlBuildTaskPath Condition="'$(XamlBuildTaskPath)' == ''">$(MSBuildToolsPath64)</XamlBuildTaskPath>
+  </PropertyGroup>
 
-   <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.Xaml.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.Xaml.targets')" />
+  <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.Xaml.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.Xaml.targets')" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 58640172d76..e04d5d27e05 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -288,7 +288,7 @@ private ITaskItem CreateFileItem(ITaskItem item, string group, string targetPath
                 // .NETCore Launcher.exe based deployment: If the file is apphost.exe, we need to set 'TargetPath' metadata
                 // to {assemblyname}.exe so that the file gets published as {assemblyname}.exe and not apphost.exe.
                 //
-                if (LauncherBasedDeployment && 
+                if (LauncherBasedDeployment &&
                     targetPath.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) &&
                     !String.IsNullOrEmpty(AssemblyName))
                 {
@@ -752,7 +752,7 @@ private bool IsFiltered(ITaskItem item)
             if (item.ItemSpec.EndsWith(".dll") && identity == null && !isDotNetCore)
             {
                 // It is possible that a native dll gets passed in here that was declared as a content file
-                // in a referenced nuget package, which will yield null here. We just need to ignore those 
+                // in a referenced nuget package, which will yield null here. We just need to ignore those
                 // for .NET FX case since those aren't actually references we care about. For .NET Core, native
                 // dll can be passed as a reference so we won't ignore it if isDotNetCore is true.
                 return true;
@@ -877,7 +877,7 @@ public void Add(ITaskItem item)
                     }
                 }
             }
-            
+
             IEnumerator IEnumerable.GetEnumerator()
             {
                 return _dictionary.Values.GetEnumerator();
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 76d1ac83455..8814629bec1 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution je true, ale odkazovanÃ½ projekt {0} nemÃ¡ nastavenÃ¡ metadata pro platformy. SestavÃ­ se bez zadanÃ© platformy.</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 8e5b3b15220..34a490ed1d1 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution ist "true". Das referenzierte Projekt "{0}" enthÃ¤lt jedoch keine Metadaten fÃ¼r "Platforms". Es wird ohne eine angegebene Plattform erstellt.</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index d670df974c0..f8474cd8820 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution es true, pero el proyecto al que se hace referencia, "{0}", no tiene establecido ningÃºn conjunto de metadatos "Platforms". Se compilarÃ¡ sin una plataforma especificada.</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 598042e2274..fb4965cc9e3 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution a la valeur true, mais le projet rÃ©fÃ©rencÃ© '{0}' nâa pas de mÃ©tadonnÃ©es âPlatformsâ dÃ©finies. Il sera gÃ©nÃ©rÃ© sans une plateforme spÃ©cifiÃ©e.</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index f5324d1486b..a00f3a2e2de 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution Ã¨ true ma il progetto di riferimento '{0}' non ha un set di metadati 'Platforms'. VerrÃ  compilato senza una piattaforma specificata.</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 05e3749d224..b4dd3d4c9e0 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution ã¯ true ã§ãããåç§å¯¾è±¡ãã­ã¸ã§ã¯ã '{0}' ã« 'ãã©ãããã©ã¼ã ' ã¡ã¿ãã¼ã¿ãè¨­å®ããã¦ãã¾ãããããã¯ãæå®ããããã©ãããã©ã¼ã ãªãã§ãã«ãããã¾ãã</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 9e79c469a64..90b1ad0ff3b 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolutionì´ trueì´ì§ë§ ì°¸ì¡°ë íë¡ì í¸ '{0}'ì 'íë«í¼' ë©íë°ì´í° ì¸í¸ê° ììµëë¤. ì§ì ë íë«í¼ ìì´ êµ¬ì¶ë©ëë¤.</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index c4425be1017..57e040f6e97 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: element EnableDynamicPlatformResolution ma wartoÅÄ true, ale projekt "{0}", do ktÃ³rego siÄ odnosi, nie ma ustawionych metadanych "Platformy". Zostanie on skompilowany bez okreÅlonej platformy.</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 9e8ae3a173a..5f825ffffa4 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution Ã© verdadeiro, mas o projeto referenciado '{0}' nÃ£o tem nenhum conjunto de metadados de 'Plataformas'. Ele serÃ¡ criado sem uma plataforma especificada.</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 9f678d815a9..0c7a66933a5 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution Ð¸Ð¼ÐµÐµÑ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ true, Ð½Ð¾ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¿ÑÐ¾ÐµÐºÑÐ° "{0}" Ð½ÐµÑ Ð·Ð°Ð´Ð°Ð½Ð½ÑÑ Ð¼ÐµÑÐ°Ð´Ð°Ð½Ð½ÑÑ "Platforms". Ð¡Ð±Ð¾ÑÐºÐ° Ð±ÑÐ´ÐµÑ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð° Ð±ÐµÐ· ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¹ Ð¿Ð»Ð°ÑÑÐ¾ÑÐ¼Ñ.</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index b50eb2c00de..077758b4edd 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution doÄru ancak baÅvurulan proje '{0}', 'Platforms' meta veri kÃ¼mesine sahip deÄil. Belirli bir platform olmadan oluÅturulacak.</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index ab943eeff47..26b89d23285 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution ä¸º trueï¼ä½å¼ç¨çé¡¹ç® "{0}" æ²¡æè®¾ç½® "Platforms" åæ°æ®ãå®å°å¨æ²¡ææå®å¹³å°çæåµä¸çæã</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index f79344992ae..ad011ed8d31 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -1363,7 +1363,7 @@
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
         <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</source>
-        <target state="needs-review-translation">MSB3982: EnableDynamicPlatformResolution çº trueï¼ä½åèçå°æ¡ '{0}' æªè¨­å® 'Platforms' ä¸­ç¹¼è³æãå®å°å¨æ²ææå®å¹³å°çææ³ä¸å»ºç½®ã</target>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' or 'Platform' metadata set. It will be built without a specified platform.</target>
         <note>{StrBegin="MSB3982: "}</note>
       </trans-unit>
       <trans-unit id="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
diff --git a/src/Tasks/Workflow.VisualBasic.targets b/src/Tasks/Workflow.VisualBasic.targets
index b6212e40864..2002517eaf9 100644
--- a/src/Tasks/Workflow.VisualBasic.targets
+++ b/src/Tasks/Workflow.VisualBasic.targets
@@ -1,15 +1,15 @@
-ï»¿<Project>
+<Project>
 
-   <!--
-        With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
+  <!--
+      With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
+      outside of the .NET Framework.  As a result of this, there were several targets files, of which
+      this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
-        consumers of them are not broken, but since the targets files themselves are still part of .NET,
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
-   -->
+      Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+      consumers of them are not broken, but since the targets files themselves are still part of .NET,
+      the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
+  -->
 
-   <Import Project="$(MSBuildFrameworkToolsPath)\Workflow.VisualBasic.targets" />
+  <Import Project="$(MSBuildFrameworkToolsPath)\Workflow.VisualBasic.targets" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/Workflow.targets b/src/Tasks/Workflow.targets
index e9eb61cf94e..96f52c81d1e 100644
--- a/src/Tasks/Workflow.targets
+++ b/src/Tasks/Workflow.targets
@@ -1,15 +1,15 @@
-ï»¿<Project>
+<Project>
 
-   <!--
-        With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
+  <!--
+      With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
+      outside of the .NET Framework.  As a result of this, there were several targets files, of which
+      this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
-        consumers of them are not broken, but since the targets files themselves are still part of .NET,
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
-   -->
+      Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+      consumers of them are not broken, but since the targets files themselves are still part of .NET,
+      the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
+  -->
 
-   <Import Project="$(MSBuildFrameworkToolsPath)\Workflow.targets" />
+  <Import Project="$(MSBuildFrameworkToolsPath)\Workflow.targets" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/CSharp.BrowseObject.xaml b/src/Tasks/XamlRules/CSharp.BrowseObject.xaml
index b5151a4ebf8..ccefe984455 100644
--- a/src/Tasks/XamlRules/CSharp.BrowseObject.xaml
+++ b/src/Tasks/XamlRules/CSharp.BrowseObject.xaml
@@ -1,4 +1,3 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
   Name="CSharp"
@@ -17,50 +16,50 @@
   </Rule.Categories>
 
   <DynamicEnumProperty
-      Name="{}{ItemType}"
-      DisplayName="Build Action"
-      Category="Advanced"
-      Description="How the file relates to the build and deployment processes."
-      EnumProvider="ItemTypes" />
+    Name="{}{ItemType}"
+    DisplayName="Build Action"
+    Category="Advanced"
+    Description="How the file relates to the build and deployment processes."
+    EnumProvider="ItemTypes" />
 
   <EnumProperty
-      Name="CopyToOutputDirectory"
-      DisplayName="Copy to Output Directory"
-      Category="Advanced"
-      Description="Specifies the source file will be copied to the output directory.">
+    Name="CopyToOutputDirectory"
+    DisplayName="Copy to Output Directory"
+    Category="Advanced"
+    Description="Specifies the source file will be copied to the output directory.">
     <EnumValue Name="Never" DisplayName="Do not copy" />
     <EnumValue Name="Always" DisplayName="Copy always" />
     <EnumValue Name="PreserveNewest" DisplayName="Copy if newer" />
   </EnumProperty>
 
   <StringProperty
-      Name="Identity"
-      Visible="false"
-      ReadOnly="true"
-      Category="Misc"
-      Description="The item specified in the Include attribute.">
+    Name="Identity"
+    Visible="false"
+    ReadOnly="true"
+    Category="Misc"
+    Description="The item specified in the Include attribute.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="Identity" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FullPath"
-      DisplayName="Full Path"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Location of the file.">
+    Name="FullPath"
+    DisplayName="Full Path"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Location of the file.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="FullPath" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FileNameAndExtension"
-      DisplayName="File Name"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Name of the file or folder.">
+    Name="FileNameAndExtension"
+    DisplayName="File Name"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Name of the file or folder.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="FileNameAndExtension" />
     </StringProperty.DataSource>
@@ -85,4 +84,4 @@
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="Extension" />
     </StringProperty.DataSource>
   </StringProperty>
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/CSharp.ProjectItemsSchema.xaml b/src/Tasks/XamlRules/CSharp.ProjectItemsSchema.xaml
index a8b8e008446..dd51a5ece27 100644
--- a/src/Tasks/XamlRules/CSharp.ProjectItemsSchema.xaml
+++ b/src/Tasks/XamlRules/CSharp.ProjectItemsSchema.xaml
@@ -1,16 +1,14 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <ProjectSchemaDefinitions
-    xmlns="http://schemas.microsoft.com/build/2009/properties">
+  xmlns="http://schemas.microsoft.com/build/2009/properties">
 
-    <ContentType
-        Name="CSharpFile"
-        DisplayName="C# file"
-        ItemType="Compile">
-    </ContentType>
+  <ContentType
+      Name="CSharpFile"
+      DisplayName="C# file"
+      ItemType="Compile">
+  </ContentType>
 
-    <ItemType Name="Compile" DisplayName="C# compiler"/>
-
-	<FileExtension Name=".cs" ContentType="CSharpFile"/>
-</ProjectSchemaDefinitions>
+  <ItemType Name="Compile" DisplayName="C# compiler"/>
 
+  <FileExtension Name=".cs" ContentType="CSharpFile"/>
+</ProjectSchemaDefinitions>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/CSharp.xaml b/src/Tasks/XamlRules/CSharp.xaml
index 899420f7674..39168f14adf 100644
--- a/src/Tasks/XamlRules/CSharp.xaml
+++ b/src/Tasks/XamlRules/CSharp.xaml
@@ -1,4 +1,3 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
   Name="CSharp"
@@ -17,50 +16,50 @@
   </Rule.Categories>
 
   <DynamicEnumProperty
-      Name="{}{ItemType}"
-      DisplayName="Build Action"
-      Category="Advanced"
-      Description="How the file relates to the build and deployment processes."
-      EnumProvider="ItemTypes" />
+    Name="{}{ItemType}"
+    DisplayName="Build Action"
+    Category="Advanced"
+    Description="How the file relates to the build and deployment processes."
+    EnumProvider="ItemTypes" />
 
   <EnumProperty
-      Name="CopyToOutputDirectory"
-      DisplayName="Copy to Output Directory"
-      Category="Advanced"
-      Description="Specifies the source file will be copied to the output directory.">
+    Name="CopyToOutputDirectory"
+    DisplayName="Copy to Output Directory"
+    Category="Advanced"
+    Description="Specifies the source file will be copied to the output directory.">
     <EnumValue Name="Never" DisplayName="Do not copy" />
     <EnumValue Name="Always" DisplayName="Copy always" />
     <EnumValue Name="PreserveNewest" DisplayName="Copy if newer" />
   </EnumProperty>
 
   <StringProperty
-      Name="Identity"
-      Visible="false"
-      ReadOnly="true"
-      Category="Misc"
-      Description="The item specified in the Include attribute.">
+    Name="Identity"
+    Visible="false"
+    ReadOnly="true"
+    Category="Misc"
+    Description="The item specified in the Include attribute.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="Identity" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FullPath"
-      DisplayName="Full Path"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Location of the file.">
+    Name="FullPath"
+    DisplayName="Full Path"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Location of the file.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="FullPath" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FileNameAndExtension"
-      DisplayName="File Name"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Name of the file or folder.">
+    Name="FileNameAndExtension"
+    DisplayName="File Name"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Name of the file or folder.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="FileNameAndExtension" />
     </StringProperty.DataSource>
@@ -81,4 +80,4 @@
   <StringProperty Name="LastGenOutput" Visible="false" Description="The filename of the last file generated as a result of the SFG." />
   <BoolProperty Name="DesignTime" Visible="false" Description="A value indicating whether this file has a designer." />
   <BoolProperty Name="AutoGen" Visible="false" Description="A value indicating whether this is a generated file." />
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/Content.xaml b/src/Tasks/XamlRules/Content.xaml
index cfa3cf78836..10943a217c9 100644
--- a/src/Tasks/XamlRules/Content.xaml
+++ b/src/Tasks/XamlRules/Content.xaml
@@ -1,4 +1,3 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
   Name="Content"
@@ -77,4 +76,4 @@
       <NameValuePair Name="DoNotCopyAcrossProjects" Value="true" />
     </StringProperty.Metadata>
   </StringProperty>
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/Debugger_General.xaml b/src/Tasks/XamlRules/Debugger_General.xaml
index 49089861e8d..e0eb4c94934 100644
--- a/src/Tasks/XamlRules/Debugger_General.xaml
+++ b/src/Tasks/XamlRules/Debugger_General.xaml
@@ -1,23 +1,22 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule Name="DebuggerGeneralProperties"
-      DisplayName="Debugger General Properties"
-      Description="General Debugger options"
-      xmlns="http://schemas.microsoft.com/build/2009/properties">
+  DisplayName="Debugger General Properties"
+  Description="General Debugger options"
+  xmlns="http://schemas.microsoft.com/build/2009/properties">
   <Rule.DataSource>
     <DataSource Persistence="UserFile" />
   </Rule.DataSource>
-  
+
   <StringProperty Name="SymbolsPath" DisplayName="Symbol Search Path"
-                  Description="The search path used by the debugger to locate symbols.">
+    Description="The search path used by the debugger to locate symbols.">
   </StringProperty>
 
   <StringProperty Name="DebuggerFlavor" Visible="false"
-                  Description="The debug rule selected as the active debugger.">
+    Description="The debug rule selected as the active debugger.">
   </StringProperty>
 
   <EnumProperty Name="ImageClrType" Visible="false"
-                  Description="The 'hidden' property we pass to debuggers to let them know if this is a managed project.">
+    Description="The 'hidden' property we pass to debuggers to let them know if this is a managed project.">
     <EnumProperty.DataSource>
       <DataSource Persistence="UserFile" HasConfigurationCondition="false" PersistedName="_TargetImageClrType" />
     </EnumProperty.DataSource>
@@ -25,4 +24,4 @@
     <EnumValue Name="Mixed" DisplayName="Mixed Image" Description="The executable image to debug is a mixture of native and managed code." />
     <EnumValue Name="Managed" DisplayName="Managed Image" Description="The executable image to debug is a fully managed application." />
   </EnumProperty>
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/EmbeddedResource.xaml b/src/Tasks/XamlRules/EmbeddedResource.xaml
index 32924484fc0..39020789a57 100644
--- a/src/Tasks/XamlRules/EmbeddedResource.xaml
+++ b/src/Tasks/XamlRules/EmbeddedResource.xaml
@@ -1,11 +1,10 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
-	Name="EmbeddedResource"
-	DisplayName="Embedded Resource"
-	PageTemplate="generic"
-	Description="Embedded resources"
-	xmlns="http://schemas.microsoft.com/build/2009/properties">
+  Name="EmbeddedResource"
+  DisplayName="Embedded Resource"
+  PageTemplate="generic"
+  Description="Embedded resources"
+  xmlns="http://schemas.microsoft.com/build/2009/properties">
   <Rule.DataSource>
     <DataSource Persistence="ProjectFile" HasConfigurationCondition="False" ItemType="EmbeddedResource" />
   </Rule.DataSource>
@@ -15,8 +14,8 @@
   </Rule.Categories>
 
   <DynamicEnumProperty Name="{}{ItemType}" DisplayName="Build Action"  Category="Advanced"
-                     Description="How the file relates to the build and deployment processes."
-                     EnumProvider="ItemTypes" />
+    Description="How the file relates to the build and deployment processes."
+    EnumProvider="ItemTypes" />
   <EnumProperty
       Name="CopyToOutputDirectory"
       DisplayName="Copy to Output Directory"
@@ -28,44 +27,44 @@
   </EnumProperty>
 
   <StringProperty
-      Name="Generator"
-      Category="Advanced"
-      DisplayName="Custom Tool"
-      Description="Specifies the tool that transforms a file at design time and places the output of that transformation into another file. For example, a dataset (.xsd) file comes with a default custom tool." />
+    Name="Generator"
+    Category="Advanced"
+    DisplayName="Custom Tool"
+    Description="Specifies the tool that transforms a file at design time and places the output of that transformation into another file. For example, a dataset (.xsd) file comes with a default custom tool." />
   <StringProperty
-      Name="CustomToolNamespace"
-      Category="Advanced"
-      DisplayName="Custom Tool Namespace"
-      Description="The namespace into which the output of the custom tool is placed." />
+    Name="CustomToolNamespace"
+    Category="Advanced"
+    DisplayName="Custom Tool Namespace"
+    Description="The namespace into which the output of the custom tool is placed." />
 
   <StringProperty
-      Name="Identity"
-      Visible="false"
-      ReadOnly="true"
-      Category="Misc"
-      Description="The item specified in the Include attribute.">
+    Name="Identity"
+    Visible="false"
+    ReadOnly="true"
+    Category="Misc"
+    Description="The item specified in the Include attribute.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="EmbeddedResource" PersistedName="Identity" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FullPath"
-      DisplayName="Full Path"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Location of the file.">
+    Name="FullPath"
+    DisplayName="Full Path"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Location of the file.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="EmbeddedResource" PersistedName="FullPath" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FileNameAndExtension"
-      DisplayName="File Name"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Name of the file or folder.">
+    Name="FileNameAndExtension"
+    DisplayName="File Name"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Name of the file or folder.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="EmbeddedResource" PersistedName="FileNameAndExtension" />
     </StringProperty.DataSource>
@@ -92,4 +91,4 @@
       <DataSource Persistence="ProjectFile" ItemType="EmbeddedResource" PersistedName="Generator" HasConfigurationCondition="False" />
     </StringProperty.DataSource>
   </StringProperty>
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/Folder.xaml b/src/Tasks/XamlRules/Folder.xaml
index 98fec3edb19..713e5ffee8a 100644
--- a/src/Tasks/XamlRules/Folder.xaml
+++ b/src/Tasks/XamlRules/Folder.xaml
@@ -1,4 +1,3 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
   Name="Folder"
@@ -13,8 +12,8 @@
   <StringProperty Name="Identity" Visible="false" ReadOnly="true" Category="Misc" />
   <StringProperty Name="FullPath" DisplayName="Full Path" ReadOnly="true" Category="Misc" />
   <StringProperty Name="FileNameAndExtension" DisplayName="Folder Name" ReadOnly="true" Category="Misc">
-      <StringProperty.DataSource>
-            <DataSource Persistence="ProjectInstance" ItemType="Folder" PersistedName="FileNameAndExtension" />
-      </StringProperty.DataSource>
+    <StringProperty.DataSource>
+        <DataSource Persistence="ProjectInstance" ItemType="Folder" PersistedName="FileNameAndExtension" />
+    </StringProperty.DataSource>
   </StringProperty>
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/General.BrowseObject.xaml b/src/Tasks/XamlRules/General.BrowseObject.xaml
index 61eeb693f0d..cda0f1a70aa 100644
--- a/src/Tasks/XamlRules/General.BrowseObject.xaml
+++ b/src/Tasks/XamlRules/General.BrowseObject.xaml
@@ -1,4 +1,3 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
   Name="ConfigurationGeneralBrowseObject"
@@ -52,4 +51,4 @@
       <DataSource Persistence="ProjectFile" PersistedName="MSBuildProjectDirectory" />
     </StringProperty.DataSource>
   </StringProperty>
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/General.xaml b/src/Tasks/XamlRules/General.xaml
index 1080a5e4d4c..27a7bffab75 100644
--- a/src/Tasks/XamlRules/General.xaml
+++ b/src/Tasks/XamlRules/General.xaml
@@ -1,4 +1,3 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
   Name="ConfigurationGeneral"
@@ -90,4 +89,4 @@
       <DataSource Persistence="ProjectFile" PersistedName="MSBuildProjectDirectory" />
     </StringProperty.DataSource>
   </StringProperty>
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/General_File.xaml b/src/Tasks/XamlRules/General_File.xaml
index 68e5ae5d1b2..901e8f1ec51 100644
--- a/src/Tasks/XamlRules/General_File.xaml
+++ b/src/Tasks/XamlRules/General_File.xaml
@@ -1,4 +1,3 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
   Name="ConfigurationGeneralFile"
@@ -24,43 +23,43 @@
     EnumProvider="ItemTypes" />
 
   <EnumProperty
-      Name="CopyToOutputDirectory"
-      DisplayName="Copy to Output Directory"
-      Category="Advanced"
-      Description="Specifies the source file will be copied to the output directory.">
+    Name="CopyToOutputDirectory"
+    DisplayName="Copy to Output Directory"
+    Category="Advanced"
+    Description="Specifies the source file will be copied to the output directory.">
     <EnumValue Name="Never" DisplayName="Do not copy" />
     <EnumValue Name="Always" DisplayName="Copy always" />
     <EnumValue Name="PreserveNewest" DisplayName="Copy if newer" />
   </EnumProperty>
 
   <StringProperty
-      Name="Identity"
-      Visible="false"
-      ReadOnly="true"
-      Category="Misc"
-      Description="The item specified in the Include attribute.">
+    Name="Identity"
+    Visible="false"
+    ReadOnly="true"
+    Category="Misc"
+    Description="The item specified in the Include attribute.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="{}{AnyType}" PersistedName="Identity" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FullPath"
-      DisplayName="Full Path"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Location of the file.">
+    Name="FullPath"
+    DisplayName="Full Path"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Location of the file.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="{}{AnyType}" PersistedName="FullPath" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FileNameAndExtension"
-      DisplayName="File Name"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Name of the file or folder.">
+    Name="FileNameAndExtension"
+    DisplayName="File Name"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Name of the file or folder.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="{}{AnyType}" PersistedName="FileNameAndExtension" />
     </StringProperty.DataSource>
@@ -91,4 +90,4 @@
   <StringProperty Name="LastGenOutput" Visible="false" Description="The filename of the last file generated as a result of the SFG." />
   <BoolProperty Name="DesignTime" Visible="false" Description="A value indicating whether this file has a designer." />
   <BoolProperty Name="AutoGen" Visible="false" Description="A value indicating whether this is a generated file." />
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/None.xaml b/src/Tasks/XamlRules/None.xaml
index 2b82f066ef1..acc74c7eed8 100644
--- a/src/Tasks/XamlRules/None.xaml
+++ b/src/Tasks/XamlRules/None.xaml
@@ -1,4 +1,3 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
   Name="None"
@@ -17,50 +16,50 @@
   </Rule.Categories>
 
   <DynamicEnumProperty
-      Name="{}{ItemType}"
-      DisplayName="Build Action"
-      Category="Advanced"
-      Description="How the file relates to the build and deployment processes."
-      EnumProvider="ItemTypes" />
+    Name="{}{ItemType}"
+    DisplayName="Build Action"
+    Category="Advanced"
+    Description="How the file relates to the build and deployment processes."
+    EnumProvider="ItemTypes" />
 
   <EnumProperty
-      Name="CopyToOutputDirectory"
-      DisplayName="Copy to Output Directory"
-      Category="Advanced"
-      Description="Specifies the source file will be copied to the output directory.">
+    Name="CopyToOutputDirectory"
+    DisplayName="Copy to Output Directory"
+    Category="Advanced"
+    Description="Specifies the source file will be copied to the output directory.">
     <EnumValue Name="Never" DisplayName="Do not copy" />
     <EnumValue Name="Always" DisplayName="Copy always" />
     <EnumValue Name="PreserveNewest" DisplayName="Copy if newer" />
   </EnumProperty>
 
   <StringProperty
-      Name="Identity"
-      Visible="false"
-      ReadOnly="true"
-      Category="Misc"
-      Description="The item specified in the Include attribute.">
+    Name="Identity"
+    Visible="false"
+    ReadOnly="true"
+    Category="Misc"
+    Description="The item specified in the Include attribute.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="None" PersistedName="Identity" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FullPath"
-      DisplayName="Full Path"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Location of the file.">
+    Name="FullPath"
+    DisplayName="Full Path"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Location of the file.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="None" PersistedName="FullPath" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FileNameAndExtension"
-      DisplayName="File Name"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Name of the file or folder.">
+    Name="FileNameAndExtension"
+    DisplayName="File Name"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Name of the file or folder.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="None" PersistedName="FileNameAndExtension" />
     </StringProperty.DataSource>
@@ -90,4 +89,4 @@
   <StringProperty Name="LastGenOutput" Visible="false" Description="The filename of the last file generated as a result of the SFG." />
   <BoolProperty Name="DesignTime" Visible="false" Description="A value indicating whether this file has a designer." />
   <BoolProperty Name="AutoGen" Visible="false" Description="A value indicating whether this is a generated file." />
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/ProjectItemsSchema.xaml b/src/Tasks/XamlRules/ProjectItemsSchema.xaml
index 28f54055052..efd8d6946cc 100644
--- a/src/Tasks/XamlRules/ProjectItemsSchema.xaml
+++ b/src/Tasks/XamlRules/ProjectItemsSchema.xaml
@@ -1,139 +1,137 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <ProjectSchemaDefinitions
-    xmlns="http://schemas.microsoft.com/build/2009/properties">
+  xmlns="http://schemas.microsoft.com/build/2009/properties">
 
-    <ContentType
-        Name="Text"
-        DisplayName="Text file"
-        ItemType="Content">
-    </ContentType>
+  <ContentType
+    Name="Text"
+    DisplayName="Text file"
+    ItemType="Content">
+  </ContentType>
 
-    <ContentType
-        Name="XML"
-        DisplayName="Xml file"
-        ItemType="Content">
-    </ContentType>
+  <ContentType
+    Name="XML"
+    DisplayName="Xml file"
+    ItemType="Content">
+  </ContentType>
 
-    <ContentType
-        Name="HTML"
-        DisplayName="Html file"
-        ItemType="Content">
-    </ContentType>
+  <ContentType
+    Name="HTML"
+    DisplayName="Html file"
+    ItemType="Content">
+  </ContentType>
 
-    <ContentType
-        Name="CSS"
-        DisplayName="Cascading style sheet"
-        ItemType="Content">
-    </ContentType>
+  <ContentType
+    Name="CSS"
+    DisplayName="Cascading style sheet"
+    ItemType="Content">
+  </ContentType>
 
-    <ContentType
-        Name="Json"
-        DisplayName="Json file"
-        ItemType="Content">
-    </ContentType>
+  <ContentType
+    Name="Json"
+    DisplayName="Json file"
+    ItemType="Content">
+  </ContentType>
 
-    <ContentType
-      Name="Font"
-      DisplayName="Font file"
-      ItemType="Content">
-    </ContentType>
+  <ContentType
+    Name="Font"
+    DisplayName="Font file"
+    ItemType="Content">
+  </ContentType>
 
-    <ContentType
-      Name="Media"
-      DisplayName="Media file"
-      ItemType="Content">
-    </ContentType>
-    
-    <ContentType
-      Name="Image"
-      DisplayName="Image file"
-      ItemType="Content">
-    </ContentType>
-    
-    <ContentType
-      Name="EmbeddedResource"
-      DisplayName="Embedded resource"
-      ItemType="EmbeddedResource">
-      <NameValuePair Name="DefaultMetadata_Generator" Value="ResXFileCodeGenerator" />
-    </ContentType>
+  <ContentType
+    Name="Media"
+    DisplayName="Media file"
+    ItemType="Content">
+  </ContentType>
 
-    <ItemType Name="None" DisplayName="None"/>
-    <ItemType Name="Content" DisplayName="Content" />
-    <ItemType Name="EmbeddedResource" DisplayName="Embedded resource "/>
+  <ContentType
+    Name="Image"
+    DisplayName="Image file"
+    ItemType="Content">
+  </ContentType>
 
-    <FileExtension Name=".asax" ContentType="Asax" />
-    <FileExtension Name=".asmx" ContentType="HTML" />
-    <FileExtension Name=".asp" ContentType="AspPage" />
-    <FileExtension Name=".txt" ContentType="Text" />
-    <FileExtension Name=".resx" ContentType="EmbeddedResource" />
-    <FileExtension Name=".html" ContentType="HTML" />
-    <FileExtension Name=".htm" ContentType="HTML" />
-    <FileExtension Name=".css" ContentType="CSS" />
-    <FileExtension Name=".cur" ContentType="CUR" />
-    <FileExtension Name=".vbS" ContentType="Script" />
-    <FileExtension Name=".jS" ContentType="Script" />
-    <FileExtension Name=".xml" ContentType="XML" />
-    <FileExtension Name=".mht" ContentType="MHT" />
-    <FileExtension Name=".manifest" ContentType="Manifest" />
-    <FileExtension Name=".rdlc" ContentType="RDLC" />
-    <FileExtension Name=".cd" ContentType="ClassDiagram" />
-    <FileExtension Name=".licenses" ContentType="Licenses" />
-    <FileExtension Name=".json" ContentType="Json" />
+  <ContentType
+    Name="EmbeddedResource"
+    DisplayName="Embedded resource"
+    ItemType="EmbeddedResource">
+    <NameValuePair Name="DefaultMetadata_Generator" Value="ResXFileCodeGenerator" />
+  </ContentType>
 
-    <!-- Image formats -->
-    <FileExtension Name=".jpeg" ContentType="Image" />
-    <FileExtension Name=".jpe" ContentType="Image" />
-    <FileExtension Name=".jpg" ContentType="Image" />
-    <FileExtension Name=".jfif" ContentType="Image" />
-    <FileExtension Name=".exif" ContentType="Image" />
-    <FileExtension Name=".gif" ContentType="Image" />
-    <FileExtension Name=".tiff" ContentType="Image" />
-    <FileExtension Name=".tif" ContentType="Image" />
-    <FileExtension Name=".png" ContentType="Image" />
-    <FileExtension Name=".bmp" ContentType="Image" />
-    <FileExtension Name=".dib" ContentType="Image" />
-    <FileExtension Name=".rle" ContentType="Image" />
-    <FileExtension Name=".ico" ContentType="Image" />
-    <FileExtension Name=".wdp" ContentType="Image" />
-    <FileExtension Name=".dds" ContentType="Image" />
-    <FileExtension Name=".tga" ContentType="Image" />
+  <ItemType Name="None" DisplayName="None"/>
+  <ItemType Name="Content" DisplayName="Content" />
+  <ItemType Name="EmbeddedResource" DisplayName="Embedded resource "/>
 
-    <!-- Audio formats-->
-    <FileExtension Name=".wav" ContentType="Media" />
-    <FileExtension Name=".wma" ContentType="Media" />
-    <FileExtension Name=".au" ContentType="Media" />
-    <FileExtension Name=".aif" ContentType="Media" />
-    <FileExtension Name=".aiff" ContentType="Media" />
-    <FileExtension Name=".aifc" ContentType="Media" />
-    <FileExtension Name=".mid" ContentType="Media" />
-    <FileExtension Name=".midi" ContentType="Media" />
-    <FileExtension Name=".mp3" ContentType="Media" />
-    <FileExtension Name=".snd" ContentType="Media" />
-    <FileExtension Name=".rmi" ContentType="Media" />
+  <FileExtension Name=".asax" ContentType="Asax" />
+  <FileExtension Name=".asmx" ContentType="HTML" />
+  <FileExtension Name=".asp" ContentType="AspPage" />
+  <FileExtension Name=".txt" ContentType="Text" />
+  <FileExtension Name=".resx" ContentType="EmbeddedResource" />
+  <FileExtension Name=".html" ContentType="HTML" />
+  <FileExtension Name=".htm" ContentType="HTML" />
+  <FileExtension Name=".css" ContentType="CSS" />
+  <FileExtension Name=".cur" ContentType="CUR" />
+  <FileExtension Name=".vbS" ContentType="Script" />
+  <FileExtension Name=".jS" ContentType="Script" />
+  <FileExtension Name=".xml" ContentType="XML" />
+  <FileExtension Name=".mht" ContentType="MHT" />
+  <FileExtension Name=".manifest" ContentType="Manifest" />
+  <FileExtension Name=".rdlc" ContentType="RDLC" />
+  <FileExtension Name=".cd" ContentType="ClassDiagram" />
+  <FileExtension Name=".licenses" ContentType="Licenses" />
+  <FileExtension Name=".json" ContentType="Json" />
 
-    <!-- Video formats-->
-    <FileExtension Name=".avi" ContentType="Media" />
-    <FileExtension Name=".wmv" ContentType="Media" />
-    <FileExtension Name=".mov" ContentType="Media" />
-    <FileExtension Name=".qt" ContentType="Media" />
-    <FileExtension Name=".mpe" ContentType="Media" />
-    <FileExtension Name=".mpeg" ContentType="Media" />
-    <FileExtension Name=".mpg" ContentType="Media" />
-    <FileExtension Name=".mp2" ContentType="Media" />
-    <FileExtension Name=".mp4" ContentType="Media" />
-    <FileExtension Name=".asx" ContentType="Media" />
-    <FileExtension Name=".asf" ContentType="Media" />
-    <FileExtension Name=".webm" ContentType="Media" />
+  <!-- Image formats -->
+  <FileExtension Name=".jpeg" ContentType="Image" />
+  <FileExtension Name=".jpe" ContentType="Image" />
+  <FileExtension Name=".jpg" ContentType="Image" />
+  <FileExtension Name=".jfif" ContentType="Image" />
+  <FileExtension Name=".exif" ContentType="Image" />
+  <FileExtension Name=".gif" ContentType="Image" />
+  <FileExtension Name=".tiff" ContentType="Image" />
+  <FileExtension Name=".tif" ContentType="Image" />
+  <FileExtension Name=".png" ContentType="Image" />
+  <FileExtension Name=".bmp" ContentType="Image" />
+  <FileExtension Name=".dib" ContentType="Image" />
+  <FileExtension Name=".rle" ContentType="Image" />
+  <FileExtension Name=".ico" ContentType="Image" />
+  <FileExtension Name=".wdp" ContentType="Image" />
+  <FileExtension Name=".dds" ContentType="Image" />
+  <FileExtension Name=".tga" ContentType="Image" />
 
-    <!-- Font formats -->
-    <FileExtension Name=".ttf" ContentType="Font" />
-    <FileExtension Name=".odttf" ContentType="Font" />
-    <FileExtension Name=".otf" ContentType="Font" />
-    <FileExtension Name=".compositefont" ContentType="Font" />
-    <FileExtension Name=".ttc" ContentType="Font" />
-    <FileExtension Name=".tte" ContentType="Font" />
-    <FileExtension Name=".woff" ContentType="Font" />
-    <FileExtension Name=".eot" ContentType="Font" />
-</ProjectSchemaDefinitions>
+  <!-- Audio formats-->
+  <FileExtension Name=".wav" ContentType="Media" />
+  <FileExtension Name=".wma" ContentType="Media" />
+  <FileExtension Name=".au" ContentType="Media" />
+  <FileExtension Name=".aif" ContentType="Media" />
+  <FileExtension Name=".aiff" ContentType="Media" />
+  <FileExtension Name=".aifc" ContentType="Media" />
+  <FileExtension Name=".mid" ContentType="Media" />
+  <FileExtension Name=".midi" ContentType="Media" />
+  <FileExtension Name=".mp3" ContentType="Media" />
+  <FileExtension Name=".snd" ContentType="Media" />
+  <FileExtension Name=".rmi" ContentType="Media" />
 
+  <!-- Video formats-->
+  <FileExtension Name=".avi" ContentType="Media" />
+  <FileExtension Name=".wmv" ContentType="Media" />
+  <FileExtension Name=".mov" ContentType="Media" />
+  <FileExtension Name=".qt" ContentType="Media" />
+  <FileExtension Name=".mpe" ContentType="Media" />
+  <FileExtension Name=".mpeg" ContentType="Media" />
+  <FileExtension Name=".mpg" ContentType="Media" />
+  <FileExtension Name=".mp2" ContentType="Media" />
+  <FileExtension Name=".mp4" ContentType="Media" />
+  <FileExtension Name=".asx" ContentType="Media" />
+  <FileExtension Name=".asf" ContentType="Media" />
+  <FileExtension Name=".webm" ContentType="Media" />
+
+  <!-- Font formats -->
+  <FileExtension Name=".ttf" ContentType="Font" />
+  <FileExtension Name=".odttf" ContentType="Font" />
+  <FileExtension Name=".otf" ContentType="Font" />
+  <FileExtension Name=".compositefont" ContentType="Font" />
+  <FileExtension Name=".ttc" ContentType="Font" />
+  <FileExtension Name=".tte" ContentType="Font" />
+  <FileExtension Name=".woff" ContentType="Font" />
+  <FileExtension Name=".eot" ContentType="Font" />
+</ProjectSchemaDefinitions>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/ResolvedAssemblyReference.xaml b/src/Tasks/XamlRules/ResolvedAssemblyReference.xaml
index 41de81596b9..00a031357fd 100644
--- a/src/Tasks/XamlRules/ResolvedAssemblyReference.xaml
+++ b/src/Tasks/XamlRules/ResolvedAssemblyReference.xaml
@@ -1,122 +1,121 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
-    Name="ResolvedAssemblyReference"
-    DisplayName="Resolved Assembly Reference"
-    PageTemplate="generic"
-    Description="Resolved reference"
-    xmlns="http://schemas.microsoft.com/build/2009/properties">
-    <Rule.DataSource>
-        <DataSource Persistence="ResolvedReference" ItemType="Reference" HasConfigurationCondition="False" 
-                    SourceType="TargetResults" MSBuildTarget="ResolveAssemblyReferencesDesignTime" />
-    </Rule.DataSource>
+  Name="ResolvedAssemblyReference"
+  DisplayName="Resolved Assembly Reference"
+  PageTemplate="generic"
+  Description="Resolved reference"
+  xmlns="http://schemas.microsoft.com/build/2009/properties">
+  <Rule.DataSource>
+    <DataSource Persistence="ResolvedReference" ItemType="Reference" HasConfigurationCondition="False"
+      SourceType="TargetResults" MSBuildTarget="ResolveAssemblyReferencesDesignTime" />
+  </Rule.DataSource>
 
-    <StringListProperty Name="Aliases"
-                        DisplayName="Aliases"
-                        Description="A comma-delimited list of aliases to this reference."
-                        Separator=",">
-        <StringListProperty.DataSource>
-            <DataSource Persistence="ProjectFile" ItemType="Reference" HasConfigurationCondition="False" />
-        </StringListProperty.DataSource>
-    </StringListProperty>
+  <StringListProperty Name="Aliases"
+    DisplayName="Aliases"
+    Description="A comma-delimited list of aliases to this reference."
+    Separator=",">
+    <StringListProperty.DataSource>
+      <DataSource Persistence="ProjectFile" ItemType="Reference" HasConfigurationCondition="False" />
+    </StringListProperty.DataSource>
+  </StringListProperty>
 
-    <BoolProperty Name="CopyLocal"
-                  DisplayName="Copy Local"
-                  Description="Indicates whether the reference will be copied to the output directory.">
-        <BoolProperty.DataSource>
-            <DataSource Persistence="ProjectFile" ItemType="Reference" HasConfigurationCondition="False" PersistedName="Private" />
-        </BoolProperty.DataSource>
-    </BoolProperty>
+  <BoolProperty Name="CopyLocal"
+    DisplayName="Copy Local"
+    Description="Indicates whether the reference will be copied to the output directory.">
+    <BoolProperty.DataSource>
+      <DataSource Persistence="ProjectFile" ItemType="Reference" HasConfigurationCondition="False" PersistedName="Private" />
+    </BoolProperty.DataSource>
+  </BoolProperty>
 
-    <StringProperty Name="Culture" 
-                    ReadOnly="True"
-                    Visible="False"
-                    DisplayName="Culture" 
-                    Description="The value of the culture field from the assembly metadata." />
+  <StringProperty Name="Culture"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="Culture"
+    Description="The value of the culture field from the assembly metadata." />
 
-    <StringProperty Name="Description" 
-                    ReadOnly="True" 
-                    Visible="False"
-                    DisplayName="Description" 
-                    Description="The value of the Title field from the assembly metadata." />
+  <StringProperty Name="Description"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="Description"
+    Description="The value of the Title field from the assembly metadata." />
 
-    <BoolProperty Name="EmbedInteropTypes"
-                  DisplayName="Embed Interop Types"
-                  Description="Indicates whether types defined in this assembly will be embedded into the target assembly.">
-        <BoolProperty.DataSource>
-            <DataSource Persistence="ProjectFile" ItemType="Reference" HasConfigurationCondition="False" />
-        </BoolProperty.DataSource>
-    </BoolProperty>
+  <BoolProperty Name="EmbedInteropTypes"
+    DisplayName="Embed Interop Types"
+    Description="Indicates whether types defined in this assembly will be embedded into the target assembly.">
+    <BoolProperty.DataSource>
+      <DataSource Persistence="ProjectFile" ItemType="Reference" HasConfigurationCondition="False" />
+    </BoolProperty.DataSource>
+  </BoolProperty>
 
-    <EnumProperty Name="FileType"
-                  ReadOnly="True"
-                  Visible="False"
-                  DisplayName="File Type"
-                  Description="The file type of the reference.">
-        <EnumValue Name="Assembly" DisplayName=".NET assembly" />
-        <EnumValue Name="ActiveX" DisplayName="COM type library" />
-        <EnumValue Name="Native Assembly" DisplayName="Native Assembly" />
-    </EnumProperty>
+  <EnumProperty Name="FileType"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="File Type"
+    Description="The file type of the reference.">
+    <EnumValue Name="Assembly" DisplayName=".NET assembly" />
+    <EnumValue Name="ActiveX" DisplayName="COM type library" />
+    <EnumValue Name="Native Assembly" DisplayName="Native Assembly" />
+  </EnumProperty>
 
-    <StringProperty Name="Identity"
-                    ReadOnly="True"
-                    DisplayName="Identity"
-                    Description="Security identity of the referenced assembly (see System.Reflection.Assembly.Evidence or System.Security.Policy.Evidence).">
-        <StringProperty.DataSource>
-            <DataSource PersistedName="{}{Identity}" />
-        </StringProperty.DataSource>
-    </StringProperty>
+  <StringProperty Name="Identity"
+    ReadOnly="True"
+    DisplayName="Identity"
+    Description="Security identity of the referenced assembly (see System.Reflection.Assembly.Evidence or System.Security.Policy.Evidence).">
+    <StringProperty.DataSource>
+      <DataSource PersistedName="{}{Identity}" />
+    </StringProperty.DataSource>
+  </StringProperty>
 
-    <StringProperty Name="ResolvedPath"
-                    ReadOnly="True"
-                    DisplayName="Path"
-                    Description="Location of the file being referenced.">
-        <StringProperty.DataSource>
-            <DataSource PersistedName="Identity" />
-        </StringProperty.DataSource>
-    </StringProperty>
+  <StringProperty Name="ResolvedPath"
+    ReadOnly="True"
+    DisplayName="Path"
+    Description="Location of the file being referenced.">
+    <StringProperty.DataSource>
+      <DataSource PersistedName="Identity" />
+    </StringProperty.DataSource>
+  </StringProperty>
 
-    <StringProperty Name="RuntimeVersion"
-                    ReadOnly="True"
-                    Visible="False"
-                    DisplayName="Runtime Version"
-                    Description="Version of the .NET runtime this assembly was compiled against.">
-    </StringProperty>
+  <StringProperty Name="RuntimeVersion"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="Runtime Version"
+    Description="Version of the .NET runtime this assembly was compiled against.">
+  </StringProperty>
 
-    <BoolProperty Name="SpecificVersion" 
-                  DisplayName="Specific Version"
-                  Description="Indicates whether this assembly can be resolved without regard to multi-targeting rules for assembly resolution.">
-        <BoolProperty.DataSource>
-            <DataSource Persistence="AssemblyReference" ItemType="Reference" HasConfigurationCondition="False" />
-        </BoolProperty.DataSource>
-    </BoolProperty>
+  <BoolProperty Name="SpecificVersion"
+    DisplayName="Specific Version"
+    Description="Indicates whether this assembly can be resolved without regard to multi-targeting rules for assembly resolution.">
+    <BoolProperty.DataSource>
+      <DataSource Persistence="AssemblyReference" ItemType="Reference" HasConfigurationCondition="False" />
+    </BoolProperty.DataSource>
+  </BoolProperty>
 
-    <BoolProperty Name="StrongName"
-                  ReadOnly="True"
-                  Visible="False"
-                  DisplayName="Strong Name"
-                  Description="True indicates that the reference has been signed with a key-pair.">
-    </BoolProperty>
+  <BoolProperty Name="StrongName"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="Strong Name"
+    Description="True indicates that the reference has been signed with a key-pair.">
+  </BoolProperty>
 
-    <StringProperty Name="Version"
-                    ReadOnly="True"
-                    DisplayName="Version"
-                    Description="Version of reference.">
-    </StringProperty>
+  <StringProperty Name="Version"
+    ReadOnly="True"
+    DisplayName="Version"
+    Description="Version of reference.">
+  </StringProperty>
 
-    <StringProperty Name="RequiredTargetFramework" DisplayName="Required Target Framework" Visible="False" />
-    <StringProperty Name="HintPath" Visible="false" />
-    <StringProperty Name="SDKIdentity" Visible="false" />
+  <StringProperty Name="RequiredTargetFramework" DisplayName="Required Target Framework" Visible="False" />
+  <StringProperty Name="HintPath" Visible="false" />
+  <StringProperty Name="SDKIdentity" Visible="false" />
 
-    <!-- This is the metadata we store on the reference item when we add it. -->
-    <BoolProperty Name="IsWinMDFile" Visible="false" Description="Indicates whether the project system ascertained that this is a WinMD (as opposed to an assembly)" />
+  <!-- This is the metadata we store on the reference item when we add it. -->
+  <BoolProperty Name="IsWinMDFile" Visible="false" Description="Indicates whether the project system ascertained that this is a WinMD (as opposed to an assembly)" />
 
-    <!-- These are metadata added to the resolved item by MSBuild that we don't show to the user but use internally. -->
-    <BoolProperty Name="WinMDFile" Visible="false" ReadOnly="True" Description="Indicates whether the build system ascertained that this is a WinMD (as opposed to an assembly)" />
-    <StringProperty Name="Name" Visible="false" ReadOnly="True" />
-    <StringProperty Name="OriginalItemSpec" Visible="False" ReadOnly="True" Description="The evaluated item name of the original reference item whose resolution resulted in this resolved reference item." />
-    <StringProperty Name="ReferenceFromSDK" Visible="False" ReadOnly="True" Description="The SDK that this reference came from when using the expand SDK target." />
-    <StringProperty Name="FusionName" Visible="False" ReadOnly="True" Description="The full fusion name of the resolved assembly." />
-    <StringProperty Name="ResolvedFrom" Visible="False" ReadOnly="True" Description="{}What repository held the reference that was used to resolve this.  (&quot;{GAC}&quot; if it was in the GAC)." />
-    <StringProperty Name="FrameworkFile" Visible="False" ReadOnly="True" Description="Is this file a framework file. Ie Found in the target framework directory or in the redist list." />
-</Rule>
+  <!-- These are metadata added to the resolved item by MSBuild that we don't show to the user but use internally. -->
+  <BoolProperty Name="WinMDFile" Visible="false" ReadOnly="True" Description="Indicates whether the build system ascertained that this is a WinMD (as opposed to an assembly)" />
+  <StringProperty Name="Name" Visible="false" ReadOnly="True" />
+  <StringProperty Name="OriginalItemSpec" Visible="False" ReadOnly="True" Description="The evaluated item name of the original reference item whose resolution resulted in this resolved reference item." />
+  <StringProperty Name="ReferenceFromSDK" Visible="False" ReadOnly="True" Description="The SDK that this reference came from when using the expand SDK target." />
+  <StringProperty Name="FusionName" Visible="False" ReadOnly="True" Description="The full fusion name of the resolved assembly." />
+  <StringProperty Name="ResolvedFrom" Visible="False" ReadOnly="True" Description="{}What repository held the reference that was used to resolve this.  (&quot;{GAC}&quot; if it was in the GAC)." />
+  <StringProperty Name="FrameworkFile" Visible="False" ReadOnly="True" Description="Is this file a framework file. Ie Found in the target framework directory or in the redist list." />
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/ResolvedCOMReference.xaml b/src/Tasks/XamlRules/ResolvedCOMReference.xaml
index 1aff28d9d8d..6abdc97990c 100644
--- a/src/Tasks/XamlRules/ResolvedCOMReference.xaml
+++ b/src/Tasks/XamlRules/ResolvedCOMReference.xaml
@@ -1,124 +1,123 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
-    Name="ResolvedCOMReference"
-    DisplayName="Resolved COM Reference"
-    PageTemplate="generic"
-    Description="Resolved reference"
-    xmlns="http://schemas.microsoft.com/build/2009/properties">
-    <Rule.DataSource>
-        <DataSource Persistence="ResolvedReference" ItemType="COMReference" HasConfigurationCondition="False" 
-                    SourceType="TargetResults" MSBuildTarget="ResolveComReferencesDesignTime" />
-    </Rule.DataSource>
-
-    <StringProperty Name="Guid"
-                    DisplayName="CLSID"
-                    Description="The GUID of the COM server."
-                    Visible="False" />
-    <IntProperty Name="VersionMajor" Visible="False" />
-    <IntProperty Name="VersionMinor" Visible="False" />
-    <StringProperty Name="WrapperTool" Visible="False" />
-
-    <StringListProperty Name="Aliases"
-                        DisplayName="Aliases"
-                        Description="A comma-delimited list of aliases to this reference."
-                        Separator=",">
-        <StringListProperty.DataSource>
-            <DataSource Persistence="ProjectFile" ItemType="COMReference" HasConfigurationCondition="False" />
-        </StringListProperty.DataSource>
-    </StringListProperty>
-
-    <BoolProperty Name="CopyLocal"
-                  DisplayName="Copy Local"
-                  Description="Indicates whether the reference will be copied to the output directory.">
-        <BoolProperty.DataSource>
-            <DataSource Persistence="ProjectFile" ItemType="COMReference" HasConfigurationCondition="False" PersistedName="Private" />
-        </BoolProperty.DataSource>
-    </BoolProperty>
-
-    <StringProperty Name="Culture" 
-                    ReadOnly="True"
-                    Visible="False"
-                    DisplayName="Culture" 
-                    Description="The value of the culture field from the assembly metadata." />
-
-    <StringProperty Name="Description" 
-                    ReadOnly="True" 
-                    Visible="False"
-                    DisplayName="Description" 
-                    Description="The value of the Title field from the assembly metadata." />
-
-    <BoolProperty Name="EmbedInteropTypes"
-                  DisplayName="Embed Interop Types"
-                  Description="Indicates whether types defined in this assembly will be embedded into the target assembly.">
-        <BoolProperty.DataSource>
-            <DataSource Persistence="ProjectFile" ItemType="COMReference" HasConfigurationCondition="False" />
-        </BoolProperty.DataSource>
-    </BoolProperty>
-
-    <EnumProperty Name="FileType"
-                  ReadOnly="True"
-                  Visible="False"
-                  DisplayName="File Type"
-                  Description="The file type of the reference.">
-        <EnumValue Name="Assembly" DisplayName=".NET assembly" />
-        <EnumValue Name="ActiveX" DisplayName="COM type library" />
-        <EnumValue Name="Native Assembly" DisplayName="Native Assembly" />
-    </EnumProperty>
-
-    <StringProperty Name="Identity"
-                    ReadOnly="True"
-                    DisplayName="Identity"
-                    Description="Security identity of the referenced assembly (see System.Reflection.Assembly.Evidence or System.Security.Policy.Evidence).">
-        <StringProperty.DataSource>
-            <DataSource PersistedName="{}{Identity}" />
-        </StringProperty.DataSource>
-    </StringProperty>
-
-    <StringProperty Name="ResolvedPath"
-                    ReadOnly="True"
-                    DisplayName="Path"
-                    Description="Location of the file being referenced.">
-        <StringProperty.DataSource>
-            <DataSource PersistedName="Identity" />
-        </StringProperty.DataSource>
-    </StringProperty>
-
-    <StringProperty Name="RuntimeVersion"
-                    ReadOnly="True"
-                    Visible="False"
-                    DisplayName="Runtime Version"
-                    Description="Version of the .NET runtime this assembly was compiled against.">
-    </StringProperty>
-
-    <BoolProperty Name="SpecificVersion" 
-                  DisplayName="Specific Version"
-                  Visible="False"
-                  Description="Indicates whether this assembly can be resolved without regard to multi-targeting rules for assembly resolution." />
-
-    <BoolProperty Name="StrongName"
-                  ReadOnly="True"
-                  Visible="False"
-                  DisplayName="Strong Name"
-                  Description="True indicates that the reference has been signed with a key-pair.">
-    </BoolProperty>
-
-    <StringProperty Name="Version"
-                    ReadOnly="True"
-                    DisplayName="Version"
-                    Description="Version of reference.">
-    </StringProperty>
-
-    <StringProperty Name="RequiredTargetFramework" DisplayName="Required Target Framework" Visible="False" />
-    <StringProperty Name="HintPath" Visible="false" />
-    <StringProperty Name="SDKIdentity" Visible="false" />
-
-    <!-- This is the metadata we store on the reference item when we add it. -->
-    <BoolProperty Name="IsWinMDFile" Visible="false" Description="Indicates whether the project system ascertained that this is a WinMD (as opposed to an assembly)" />
-
-    <!-- These are metadata added to the resolved item by MSBuild that we don't show to the user but use internally. -->
-    <BoolProperty Name="WinMDFile" Visible="false" ReadOnly="True" Description="Indicates whether the build system ascertained that this is a WinMD (as opposed to an assembly)" />
-    <StringProperty Name="OriginalItemSpec" Visible="False" ReadOnly="True" Description="The evaluated item name of the original reference item whose resolution resulted in this resolved reference item." />
-    <StringProperty Name="FusionName" Visible="False" ReadOnly="True" />
-    <StringProperty Name="Name" Visible="false" ReadOnly="True" />
-</Rule>
+  Name="ResolvedCOMReference"
+  DisplayName="Resolved COM Reference"
+  PageTemplate="generic"
+  Description="Resolved reference"
+  xmlns="http://schemas.microsoft.com/build/2009/properties">
+  <Rule.DataSource>
+    <DataSource Persistence="ResolvedReference" ItemType="COMReference" HasConfigurationCondition="False"
+      SourceType="TargetResults" MSBuildTarget="ResolveComReferencesDesignTime" />
+  </Rule.DataSource>
+
+  <StringProperty Name="Guid"
+    DisplayName="CLSID"
+    Description="The GUID of the COM server."
+    Visible="False" />
+  <IntProperty Name="VersionMajor" Visible="False" />
+  <IntProperty Name="VersionMinor" Visible="False" />
+  <StringProperty Name="WrapperTool" Visible="False" />
+
+  <StringListProperty Name="Aliases"
+    DisplayName="Aliases"
+    Description="A comma-delimited list of aliases to this reference."
+    Separator=",">
+    <StringListProperty.DataSource>
+      <DataSource Persistence="ProjectFile" ItemType="COMReference" HasConfigurationCondition="False" />
+    </StringListProperty.DataSource>
+  </StringListProperty>
+
+  <BoolProperty Name="CopyLocal"
+    DisplayName="Copy Local"
+    Description="Indicates whether the reference will be copied to the output directory.">
+    <BoolProperty.DataSource>
+      <DataSource Persistence="ProjectFile" ItemType="COMReference" HasConfigurationCondition="False" PersistedName="Private" />
+    </BoolProperty.DataSource>
+  </BoolProperty>
+
+  <StringProperty Name="Culture"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="Culture"
+    Description="The value of the culture field from the assembly metadata." />
+
+  <StringProperty Name="Description"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="Description"
+    Description="The value of the Title field from the assembly metadata." />
+
+  <BoolProperty Name="EmbedInteropTypes"
+    DisplayName="Embed Interop Types"
+    Description="Indicates whether types defined in this assembly will be embedded into the target assembly.">
+    <BoolProperty.DataSource>
+      <DataSource Persistence="ProjectFile" ItemType="COMReference" HasConfigurationCondition="False" />
+    </BoolProperty.DataSource>
+  </BoolProperty>
+
+  <EnumProperty Name="FileType"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="File Type"
+    Description="The file type of the reference.">
+    <EnumValue Name="Assembly" DisplayName=".NET assembly" />
+    <EnumValue Name="ActiveX" DisplayName="COM type library" />
+    <EnumValue Name="Native Assembly" DisplayName="Native Assembly" />
+  </EnumProperty>
+
+  <StringProperty Name="Identity"
+    ReadOnly="True"
+    DisplayName="Identity"
+    Description="Security identity of the referenced assembly (see System.Reflection.Assembly.Evidence or System.Security.Policy.Evidence).">
+    <StringProperty.DataSource>
+      <DataSource PersistedName="{}{Identity}" />
+    </StringProperty.DataSource>
+  </StringProperty>
+
+  <StringProperty Name="ResolvedPath"
+    ReadOnly="True"
+    DisplayName="Path"
+    Description="Location of the file being referenced.">
+    <StringProperty.DataSource>
+      <DataSource PersistedName="Identity" />
+    </StringProperty.DataSource>
+  </StringProperty>
+
+  <StringProperty Name="RuntimeVersion"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="Runtime Version"
+    Description="Version of the .NET runtime this assembly was compiled against.">
+  </StringProperty>
+
+  <BoolProperty Name="SpecificVersion"
+    DisplayName="Specific Version"
+    Visible="False"
+    Description="Indicates whether this assembly can be resolved without regard to multi-targeting rules for assembly resolution." />
+
+  <BoolProperty Name="StrongName"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="Strong Name"
+    Description="True indicates that the reference has been signed with a key-pair.">
+  </BoolProperty>
+
+  <StringProperty Name="Version"
+    ReadOnly="True"
+    DisplayName="Version"
+    Description="Version of reference.">
+  </StringProperty>
+
+  <StringProperty Name="RequiredTargetFramework" DisplayName="Required Target Framework" Visible="False" />
+  <StringProperty Name="HintPath" Visible="false" />
+  <StringProperty Name="SDKIdentity" Visible="false" />
+
+  <!-- This is the metadata we store on the reference item when we add it. -->
+  <BoolProperty Name="IsWinMDFile" Visible="false" Description="Indicates whether the project system ascertained that this is a WinMD (as opposed to an assembly)" />
+
+  <!-- These are metadata added to the resolved item by MSBuild that we don't show to the user but use internally. -->
+  <BoolProperty Name="WinMDFile" Visible="false" ReadOnly="True" Description="Indicates whether the build system ascertained that this is a WinMD (as opposed to an assembly)" />
+  <StringProperty Name="OriginalItemSpec" Visible="False" ReadOnly="True" Description="The evaluated item name of the original reference item whose resolution resulted in this resolved reference item." />
+  <StringProperty Name="FusionName" Visible="False" ReadOnly="True" />
+  <StringProperty Name="Name" Visible="false" ReadOnly="True" />
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/ResolvedProjectReference.xaml b/src/Tasks/XamlRules/ResolvedProjectReference.xaml
index 8f1ceda99f4..087e5b332cf 100644
--- a/src/Tasks/XamlRules/ResolvedProjectReference.xaml
+++ b/src/Tasks/XamlRules/ResolvedProjectReference.xaml
@@ -1,119 +1,118 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
-    Name="ResolvedProjectReference"
-    DisplayName="Resolved Project Reference"
-    PageTemplate="generic"
-    Description="Resolved reference"
-    xmlns="http://schemas.microsoft.com/build/2009/properties">
-    <Rule.DataSource>
-        <DataSource Persistence="ResolvedReference" ItemType="ProjectReference" HasConfigurationCondition="False" 
-                    SourceType="TargetResults" MSBuildTarget="ResolveProjectReferencesDesignTime" />
-    </Rule.DataSource>
+  Name="ResolvedProjectReference"
+  DisplayName="Resolved Project Reference"
+  PageTemplate="generic"
+  Description="Resolved reference"
+  xmlns="http://schemas.microsoft.com/build/2009/properties">
+  <Rule.DataSource>
+    <DataSource Persistence="ResolvedReference" ItemType="ProjectReference" HasConfigurationCondition="False"
+      SourceType="TargetResults" MSBuildTarget="ResolveProjectReferencesDesignTime" />
+  </Rule.DataSource>
 
-    <StringListProperty Name="Aliases"
-                        DisplayName="Aliases"
-                        Description="A comma-delimited list of aliases to this reference."
-                        Separator=",">
-        <StringListProperty.DataSource>
-            <DataSource Persistence="ProjectFile" ItemType="ProjectReference" HasConfigurationCondition="False" />
-        </StringListProperty.DataSource>
-    </StringListProperty>
+  <StringListProperty Name="Aliases"
+    DisplayName="Aliases"
+    Description="A comma-delimited list of aliases to this reference."
+    Separator=",">
+    <StringListProperty.DataSource>
+      <DataSource Persistence="ProjectFile" ItemType="ProjectReference" HasConfigurationCondition="False" />
+    </StringListProperty.DataSource>
+  </StringListProperty>
 
-    <BoolProperty Name="CopyLocal"
-                  DisplayName="Copy Local"
-                  Description="Indicates whether the reference will be copied to the output directory.">
-        <BoolProperty.DataSource>
-            <DataSource Persistence="ProjectFile" ItemType="ProjectReference" HasConfigurationCondition="False" PersistedName="Private" />
-        </BoolProperty.DataSource>
-    </BoolProperty>
+  <BoolProperty Name="CopyLocal"
+    DisplayName="Copy Local"
+    Description="Indicates whether the reference will be copied to the output directory.">
+    <BoolProperty.DataSource>
+      <DataSource Persistence="ProjectFile" ItemType="ProjectReference" HasConfigurationCondition="False" PersistedName="Private" />
+    </BoolProperty.DataSource>
+  </BoolProperty>
 
-    <StringProperty Name="Culture" 
-                    ReadOnly="True"
-                    DisplayName="Culture" 
-                    Description="The value of the culture field from the assembly metadata.">
-    </StringProperty>
+  <StringProperty Name="Culture"
+    ReadOnly="True"
+    DisplayName="Culture"
+    Description="The value of the culture field from the assembly metadata.">
+  </StringProperty>
 
-    <StringProperty Name="Description" 
-                    ReadOnly="True" 
-                    DisplayName="Description" 
-                    Description="The value of the Title field from the assembly metadata.">
-    </StringProperty>
+  <StringProperty Name="Description"
+    ReadOnly="True"
+    DisplayName="Description"
+    Description="The value of the Title field from the assembly metadata.">
+  </StringProperty>
 
-    <BoolProperty Name="EmbedInteropTypes"
-                  DisplayName="Embed Interop Types"
-                  Description="Indicates whether types defined in this assembly will be embedded into the target assembly.">
-        <BoolProperty.DataSource>
-            <DataSource Persistence="ProjectFile" ItemType="ProjectReference" HasConfigurationCondition="False" />
-        </BoolProperty.DataSource>
-    </BoolProperty>
+  <BoolProperty Name="EmbedInteropTypes"
+    DisplayName="Embed Interop Types"
+    Description="Indicates whether types defined in this assembly will be embedded into the target assembly.">
+    <BoolProperty.DataSource>
+      <DataSource Persistence="ProjectFile" ItemType="ProjectReference" HasConfigurationCondition="False" />
+    </BoolProperty.DataSource>
+  </BoolProperty>
 
-    <EnumProperty Name="FileType"
-                  ReadOnly="True"
-                  Visible="False"
-                  DisplayName="File Type"
-                  Description="The file type of the reference.">
-        <EnumValue Name="Assembly" DisplayName=".NET assembly" />
-        <EnumValue Name="ActiveX" DisplayName="COM type library" />
-        <EnumValue Name="Native Assembly" DisplayName="Native Assembly" />
-    </EnumProperty>
+  <EnumProperty Name="FileType"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="File Type"
+    Description="The file type of the reference.">
+    <EnumValue Name="Assembly" DisplayName=".NET assembly" />
+    <EnumValue Name="ActiveX" DisplayName="COM type library" />
+    <EnumValue Name="Native Assembly" DisplayName="Native Assembly" />
+  </EnumProperty>
 
-    <StringProperty Name="Identity"
-                    ReadOnly="True"
-                    DisplayName="Identity"
-                    Description="Security identity of the referenced assembly (see System.Reflection.Assembly.Evidence or System.Security.Policy.Evidence).">
-        <StringProperty.DataSource>
-            <DataSource PersistedName="{}{Identity}" />
-        </StringProperty.DataSource>
-    </StringProperty>
+  <StringProperty Name="Identity"
+    ReadOnly="True"
+    DisplayName="Identity"
+    Description="Security identity of the referenced assembly (see System.Reflection.Assembly.Evidence or System.Security.Policy.Evidence).">
+    <StringProperty.DataSource>
+      <DataSource PersistedName="{}{Identity}" />
+    </StringProperty.DataSource>
+  </StringProperty>
 
-    <StringProperty Name="ResolvedPath"
-                    ReadOnly="True"
-                    DisplayName="Path"
-                    Description="Location of the file being referenced.">
-        <StringProperty.DataSource>
-            <DataSource PersistedName="Identity" />
-        </StringProperty.DataSource>
-    </StringProperty>
+  <StringProperty Name="ResolvedPath"
+    ReadOnly="True"
+    DisplayName="Path"
+    Description="Location of the file being referenced.">
+    <StringProperty.DataSource>
+      <DataSource PersistedName="Identity" />
+    </StringProperty.DataSource>
+  </StringProperty>
 
-    <StringProperty Name="RuntimeVersion"
-                    ReadOnly="True"
-                    Visible="False"
-                    DisplayName="Runtime Version"
-                    Description="Version of the .NET runtime this assembly was compiled against.">
-    </StringProperty>
+  <StringProperty Name="RuntimeVersion"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="Runtime Version"
+    Description="Version of the .NET runtime this assembly was compiled against.">
+  </StringProperty>
 
-    <BoolProperty Name="SpecificVersion" 
-                  DisplayName="Specific Version"
-                  Visible="False"
-                  Description="Indicates whether this assembly can be resolved without regard to multi-targeting rules for assembly resolution." />
+  <BoolProperty Name="SpecificVersion"
+    DisplayName="Specific Version"
+    Visible="False"
+    Description="Indicates whether this assembly can be resolved without regard to multi-targeting rules for assembly resolution." />
 
-    <BoolProperty Name="StrongName"
-                  ReadOnly="True"
-                  Visible="False"
-                  DisplayName="Strong Name"
-                  Description="True indicates that the reference has been signed with a key-pair.">
-    </BoolProperty>
+  <BoolProperty Name="StrongName"
+    ReadOnly="True"
+    Visible="False"
+    DisplayName="Strong Name"
+    Description="True indicates that the reference has been signed with a key-pair.">
+  </BoolProperty>
 
-    <StringProperty Name="Version"
-                    ReadOnly="True"
-                    DisplayName="Version"
-                    Description="Version of reference.">
-    </StringProperty>
+  <StringProperty Name="Version"
+    ReadOnly="True"
+    DisplayName="Version"
+    Description="Version of reference.">
+  </StringProperty>
 
-    <StringProperty Name="RequiredTargetFramework" DisplayName="Required Target Framework" Visible="False" />
-    <StringProperty Name="HintPath" Visible="false" />
-    <StringProperty Name="SDKIdentity" Visible="false" />
+  <StringProperty Name="RequiredTargetFramework" DisplayName="Required Target Framework" Visible="False" />
+  <StringProperty Name="HintPath" Visible="false" />
+  <StringProperty Name="SDKIdentity" Visible="false" />
 
-    <!-- This is the metadata we store on the reference item when we add it. -->
-    <BoolProperty Name="IsWinMDFile" Visible="false" Description="Indicates whether the project system ascertained that this is a WinMD (as opposed to an assembly)" />
-    <StringProperty Name="Project" 
-                    Visible="False"
-                    Description="the Guid the solution tracks an individual project reference target with" />
+  <!-- This is the metadata we store on the reference item when we add it. -->
+  <BoolProperty Name="IsWinMDFile" Visible="false" Description="Indicates whether the project system ascertained that this is a WinMD (as opposed to an assembly)" />
+  <StringProperty Name="Project"
+    Visible="False"
+    Description="the Guid the solution tracks an individual project reference target with" />
 
-    <!-- These are metadata added to the resolved item by MSBuild that we don't show to the user but use internally. -->
-    <BoolProperty Name="WinMDFile" Visible="false" ReadOnly="True" Description="Indicates whether the build system ascertained that this is a WinMD (as opposed to an assembly)" />
-    <StringProperty Name="OriginalItemSpec" Visible="False" ReadOnly="True" Description="The evaluated item name of the original reference item whose resolution resulted in this resolved reference item." />
-    <StringProperty Name="FusionName" Visible="False" ReadOnly="True" />
-    <StringProperty Name="Name" Visible="false" ReadOnly="True" />
-</Rule>
+  <!-- These are metadata added to the resolved item by MSBuild that we don't show to the user but use internally. -->
+  <BoolProperty Name="WinMDFile" Visible="false" ReadOnly="True" Description="Indicates whether the build system ascertained that this is a WinMD (as opposed to an assembly)" />
+  <StringProperty Name="OriginalItemSpec" Visible="False" ReadOnly="True" Description="The evaluated item name of the original reference item whose resolution resulted in this resolved reference item." />
+  <StringProperty Name="FusionName" Visible="False" ReadOnly="True" />
+  <StringProperty Name="Name" Visible="false" ReadOnly="True" />
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/Scc.xaml b/src/Tasks/XamlRules/Scc.xaml
index 155f08b65da..1c07a54454d 100644
--- a/src/Tasks/XamlRules/Scc.xaml
+++ b/src/Tasks/XamlRules/Scc.xaml
@@ -1,4 +1,3 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
   Name="SourceControl"
@@ -13,4 +12,4 @@
   <StringProperty Name="SccProvider" />
   <StringProperty Name="SccAuxPath" />
   <StringProperty Name="SccLocalPath" />
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/SpecialFolder.xaml b/src/Tasks/XamlRules/SpecialFolder.xaml
index 9cbbebef564..cbeb1cc0d71 100644
--- a/src/Tasks/XamlRules/SpecialFolder.xaml
+++ b/src/Tasks/XamlRules/SpecialFolder.xaml
@@ -1,24 +1,23 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
-	Name="SpecialFolder"
-	DisplayName="General"
-	PageTemplate="generic"
-	Description="Special folders"
-	xmlns="http://schemas.microsoft.com/build/2009/properties">
-	<Rule.DataSource>
-		<DataSource Persistence="ProjectInstance" HasConfigurationCondition="False" ItemType="SpecialFolder" />
-	</Rule.DataSource>
+  Name="SpecialFolder"
+  DisplayName="General"
+  PageTemplate="generic"
+  Description="Special folders"
+  xmlns="http://schemas.microsoft.com/build/2009/properties">
+  <Rule.DataSource>
+    <DataSource Persistence="ProjectInstance" HasConfigurationCondition="False" ItemType="SpecialFolder" />
+  </Rule.DataSource>
 
-	<StringProperty Name="Identity" Visible="false" ReadOnly="true" Category="Misc" />
-	<StringProperty Name="FullPath" DisplayName="Full Path" ReadOnly="true" Category="Misc" />
+  <StringProperty Name="Identity" Visible="false" ReadOnly="true" Category="Misc" />
+  <StringProperty Name="FullPath" DisplayName="Full Path" ReadOnly="true" Category="Misc" />
     <StringProperty Name="FileNameAndExtension" DisplayName="Folder Name" ReadOnly="true" Category="Misc">
-        <StringProperty.DataSource>
-            <DataSource Persistence="ProjectInstance" ItemType="SpecialFolder" PersistedName="FileNameAndExtension" />
-        </StringProperty.DataSource>
+      <StringProperty.DataSource>
+        <DataSource Persistence="ProjectInstance" ItemType="SpecialFolder" PersistedName="FileNameAndExtension" />
+      </StringProperty.DataSource>
     </StringProperty>
     <EnumProperty Name="DisableAddItem" Visible="False">
-        <EnumValue Name="Recursive" />
-        <EnumValue Name="TopDirectoryOnly" />
+      <EnumValue Name="Recursive" />
+      <EnumValue Name="TopDirectoryOnly" />
     </EnumProperty>
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/SubProject.xaml b/src/Tasks/XamlRules/SubProject.xaml
index bc479db7729..a887c54313f 100644
--- a/src/Tasks/XamlRules/SubProject.xaml
+++ b/src/Tasks/XamlRules/SubProject.xaml
@@ -1,4 +1,3 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
   Name="SubProject"
@@ -13,4 +12,4 @@
   <StringProperty Name="ProjectTypeGuid" Visible="False" />
   <StringProperty Name="ProjectId" Visible="False" />
   <BoolProperty Name="VirtualProject" Visible="False" />
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/VisualBasic.BrowseObject.xaml b/src/Tasks/XamlRules/VisualBasic.BrowseObject.xaml
index 6da44dd8555..266cb074fdb 100644
--- a/src/Tasks/XamlRules/VisualBasic.BrowseObject.xaml
+++ b/src/Tasks/XamlRules/VisualBasic.BrowseObject.xaml
@@ -1,4 +1,3 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
   Name="VisualBasic"
@@ -17,50 +16,50 @@
   </Rule.Categories>
 
   <DynamicEnumProperty
-      Name="{}{ItemType}"
-      DisplayName="Build Action"
-      Category="Advanced"
-      Description="How the file relates to the build and deployment processes."
-      EnumProvider="ItemTypes" />
+    Name="{}{ItemType}"
+    DisplayName="Build Action"
+    Category="Advanced"
+    Description="How the file relates to the build and deployment processes."
+    EnumProvider="ItemTypes" />
 
   <EnumProperty
-      Name="CopyToOutputDirectory"
-      DisplayName="Copy to Output Directory"
-      Category="Advanced"
-      Description="Specifies the source file will be copied to the output directory.">
+    Name="CopyToOutputDirectory"
+    DisplayName="Copy to Output Directory"
+    Category="Advanced"
+    Description="Specifies the source file will be copied to the output directory.">
     <EnumValue Name="Never" DisplayName="Do not copy" />
     <EnumValue Name="Always" DisplayName="Copy always" />
     <EnumValue Name="PreserveNewest" DisplayName="Copy if newer" />
   </EnumProperty>
 
   <StringProperty
-      Name="Identity"
-      Visible="false"
-      ReadOnly="true"
-      Category="Misc"
-      Description="The item specified in the Include attribute.">
+    Name="Identity"
+    Visible="false"
+    ReadOnly="true"
+    Category="Misc"
+    Description="The item specified in the Include attribute.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="Identity" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FullPath"
-      DisplayName="Full Path"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Location of the file.">
+    Name="FullPath"
+    DisplayName="Full Path"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Location of the file.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="FullPath" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FileNameAndExtension"
-      DisplayName="File Name"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Name of the file or folder.">
+    Name="FileNameAndExtension"
+    DisplayName="File Name"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Name of the file or folder.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="FileNameAndExtension" />
     </StringProperty.DataSource>
@@ -85,4 +84,4 @@
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="Extension" />
     </StringProperty.DataSource>
   </StringProperty>
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/VisualBasic.ProjectItemsSchema.xaml b/src/Tasks/XamlRules/VisualBasic.ProjectItemsSchema.xaml
index 4010206fbc5..08fd874b0d5 100644
--- a/src/Tasks/XamlRules/VisualBasic.ProjectItemsSchema.xaml
+++ b/src/Tasks/XamlRules/VisualBasic.ProjectItemsSchema.xaml
@@ -1,16 +1,14 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <ProjectSchemaDefinitions
-    xmlns="http://schemas.microsoft.com/build/2009/properties">
+  xmlns="http://schemas.microsoft.com/build/2009/properties">
 
-    <ContentType
-        Name="VisualBasicFile"
-        DisplayName="VB file"
-        ItemType="Compile">
-    </ContentType>
+  <ContentType
+    Name="VisualBasicFile"
+    DisplayName="VB file"
+    ItemType="Compile">
+  </ContentType>
 
-    <ItemType Name="Compile" DisplayName="VB compiler"/>
-
-	<FileExtension Name=".vb" ContentType="VisualBasicFile"/>
-</ProjectSchemaDefinitions>
+  <ItemType Name="Compile" DisplayName="VB compiler"/>
 
+  <FileExtension Name=".vb" ContentType="VisualBasicFile"/>
+</ProjectSchemaDefinitions>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/VisualBasic.xaml b/src/Tasks/XamlRules/VisualBasic.xaml
index b2ed3dfa33c..596eee397f4 100644
--- a/src/Tasks/XamlRules/VisualBasic.xaml
+++ b/src/Tasks/XamlRules/VisualBasic.xaml
@@ -1,4 +1,3 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
   Name="VisualBasic"
@@ -17,50 +16,50 @@
   </Rule.Categories>
 
   <DynamicEnumProperty
-      Name="{}{ItemType}"
-      DisplayName="Build Action"
-      Category="Advanced"
-      Description="How the file relates to the build and deployment processes."
-      EnumProvider="ItemTypes" />
+    Name="{}{ItemType}"
+    DisplayName="Build Action"
+    Category="Advanced"
+    Description="How the file relates to the build and deployment processes."
+    EnumProvider="ItemTypes" />
 
   <EnumProperty
-      Name="CopyToOutputDirectory"
-      DisplayName="Copy to Output Directory"
-      Category="Advanced"
-      Description="Specifies the source file will be copied to the output directory.">
+    Name="CopyToOutputDirectory"
+    DisplayName="Copy to Output Directory"
+    Category="Advanced"
+    Description="Specifies the source file will be copied to the output directory.">
     <EnumValue Name="Never" DisplayName="Do not copy" />
     <EnumValue Name="Always" DisplayName="Copy always" />
     <EnumValue Name="PreserveNewest" DisplayName="Copy if newer" />
   </EnumProperty>
 
   <StringProperty
-      Name="Identity"
-      Visible="false"
-      ReadOnly="true"
-      Category="Misc"
-      Description="The item specified in the Include attribute.">
+    Name="Identity"
+    Visible="false"
+    ReadOnly="true"
+    Category="Misc"
+    Description="The item specified in the Include attribute.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="Identity" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FullPath"
-      DisplayName="Full Path"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Location of the file.">
+    Name="FullPath"
+    DisplayName="Full Path"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Location of the file.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="FullPath" />
     </StringProperty.DataSource>
   </StringProperty>
 
   <StringProperty
-      Name="FileNameAndExtension"
-      DisplayName="File Name"
-      ReadOnly="true"
-      Category="Misc"
-      Description="Name of the file or folder.">
+    Name="FileNameAndExtension"
+    DisplayName="File Name"
+    ReadOnly="true"
+    Category="Misc"
+    Description="Name of the file or folder.">
     <StringProperty.DataSource>
       <DataSource Persistence="Intrinsic" ItemType="Compile" PersistedName="FileNameAndExtension" />
     </StringProperty.DataSource>
@@ -81,4 +80,4 @@
   <StringProperty Name="LastGenOutput" Visible="false" Description="The filename of the last file generated as a result of the SFG." />
   <BoolProperty Name="DesignTime" Visible="false" Description="A value indicating whether this file has a designer." />
   <BoolProperty Name="AutoGen" Visible="false" Description="A value indicating whether this is a generated file." />
-</Rule>
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/assemblyreference.xaml b/src/Tasks/XamlRules/assemblyreference.xaml
index a7eb69ee710..95d4aaf4fae 100644
--- a/src/Tasks/XamlRules/assemblyreference.xaml
+++ b/src/Tasks/XamlRules/assemblyreference.xaml
@@ -1,47 +1,46 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
-    Name="AssemblyReference"
-    DisplayName="Assembly Reference"
-    PageTemplate="generic"
-    Description="Assembly reference properties"
-    xmlns="http://schemas.microsoft.com/build/2009/properties">
-    <Rule.DataSource>
-        <DataSource Persistence="ProjectFile" ItemType="Reference" HasConfigurationCondition="False" />
-    </Rule.DataSource>
+  Name="AssemblyReference"
+  DisplayName="Assembly Reference"
+  PageTemplate="generic"
+  Description="Assembly reference properties"
+  xmlns="http://schemas.microsoft.com/build/2009/properties">
+  <Rule.DataSource>
+    <DataSource Persistence="ProjectFile" ItemType="Reference" HasConfigurationCondition="False" />
+  </Rule.DataSource>
 
-    <StringListProperty Name="Aliases"
-                        DisplayName="Aliases"
-                        Description="A comma-delimited list of aliases to this reference."
-                        Separator="," />
+  <StringListProperty Name="Aliases"
+    DisplayName="Aliases"
+    Description="A comma-delimited list of aliases to this reference."
+    Separator="," />
 
-    <BoolProperty Name="CopyLocal"
-                DisplayName="Copy Local"
-                Description="Indicates whether the reference will be copied to the output directory.">
-        <BoolProperty.DataSource>
-            <DataSource Persistence="ProjectFile" ItemType="Reference" HasConfigurationCondition="False" PersistedName="Private" />
-        </BoolProperty.DataSource>
-    </BoolProperty>
+  <BoolProperty Name="CopyLocal"
+    DisplayName="Copy Local"
+    Description="Indicates whether the reference will be copied to the output directory.">
+    <BoolProperty.DataSource>
+      <DataSource Persistence="ProjectFile" ItemType="Reference" HasConfigurationCondition="False" PersistedName="Private" />
+    </BoolProperty.DataSource>
+  </BoolProperty>
 
-    <BoolProperty Name="EmbedInteropTypes"
-                  DisplayName="Embed Interop Types"
-                  Description="Indicates whether types defined in this assembly will be embedded into the target assembly." />
+  <BoolProperty Name="EmbedInteropTypes"
+    DisplayName="Embed Interop Types"
+    Description="Indicates whether types defined in this assembly will be embedded into the target assembly." />
 
-    <BoolProperty Name="SpecificVersion" 
-                  DisplayName="Specific Version"
-                  Description="Indicates whether this assembly can be resolved without regard to multi-targeting rules for assembly resolution.">
-        <BoolProperty.DataSource>
-            <DataSource Persistence="AssemblyReference" ItemType="Reference" HasConfigurationCondition="False"/>
-        </BoolProperty.DataSource>
-    </BoolProperty>
+  <BoolProperty Name="SpecificVersion"
+    DisplayName="Specific Version"
+    Description="Indicates whether this assembly can be resolved without regard to multi-targeting rules for assembly resolution.">
+    <BoolProperty.DataSource>
+      <DataSource Persistence="AssemblyReference" ItemType="Reference" HasConfigurationCondition="False"/>
+    </BoolProperty.DataSource>
+  </BoolProperty>
 
-    <StringProperty Name="RequiredTargetFramework" DisplayName="Required Target Framework" Visible="False" />
-    <StringProperty Name="HintPath" Visible="false" />
-    <StringProperty Name="SDKName" Visible="false" />
-    <BoolProperty Name="IsWinMDFile" Visible="false" />
-    <StringProperty Name="ImageRuntime"
-                    DisplayName="Runtime Version"
-                    Description="The CLR runtime version targeted by this assembly."
-                    Visible="False"
-                    ReadOnly="True" />
-</Rule>
+  <StringProperty Name="RequiredTargetFramework" DisplayName="Required Target Framework" Visible="False" />
+  <StringProperty Name="HintPath" Visible="false" />
+  <StringProperty Name="SDKName" Visible="false" />
+  <BoolProperty Name="IsWinMDFile" Visible="false" />
+  <StringProperty Name="ImageRuntime"
+    DisplayName="Runtime Version"
+    Description="The CLR runtime version targeted by this assembly."
+    Visible="False"
+    ReadOnly="True" />
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/comreference.xaml b/src/Tasks/XamlRules/comreference.xaml
index 164f0e736be..0cea2c8e4c3 100644
--- a/src/Tasks/XamlRules/comreference.xaml
+++ b/src/Tasks/XamlRules/comreference.xaml
@@ -1,20 +1,19 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
-	Name="ComReference"
-	DisplayName="COM Reference"
-	PageTemplate="generic"
-	Description="COM reference properties"
-	xmlns="http://schemas.microsoft.com/build/2009/properties">
-	<Rule.DataSource>
-		<DataSource Persistence="ProjectFile" ItemType="COMReference" HasConfigurationCondition="False" />
-	</Rule.DataSource>
-	<StringProperty Name="Guid" DisplayName="CLSID"
-					Description="The GUID of the COM server." />
-	<StringProperty Name="Lcid" DisplayName="Locale"
-					Description="The LCID of the COM server." />
-	<IntProperty Name="VersionMajor" />
-	<IntProperty Name="VersionMinor" />
-	<BoolProperty Name="Isolated" />
-	<StringProperty Name="WrapperTool" />
-</Rule>
+  Name="ComReference"
+  DisplayName="COM Reference"
+  PageTemplate="generic"
+  Description="COM reference properties"
+  xmlns="http://schemas.microsoft.com/build/2009/properties">
+  <Rule.DataSource>
+    <DataSource Persistence="ProjectFile" ItemType="COMReference" HasConfigurationCondition="False" />
+  </Rule.DataSource>
+  <StringProperty Name="Guid" DisplayName="CLSID"
+          Description="The GUID of the COM server." />
+  <StringProperty Name="Lcid" DisplayName="Locale"
+          Description="The LCID of the COM server." />
+  <IntProperty Name="VersionMajor" />
+  <IntProperty Name="VersionMinor" />
+  <BoolProperty Name="Isolated" />
+  <StringProperty Name="WrapperTool" />
+</Rule>
\ No newline at end of file
diff --git a/src/Tasks/XamlRules/projectreference.xaml b/src/Tasks/XamlRules/projectreference.xaml
index 1526db5784b..c00b40058b9 100644
--- a/src/Tasks/XamlRules/projectreference.xaml
+++ b/src/Tasks/XamlRules/projectreference.xaml
@@ -1,46 +1,45 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
 <!--Copyright, Microsoft Corporation, All rights reserved.-->
 <Rule
-	Name="ProjectReference"
-	DisplayName="Project Reference"
-	PageTemplate="generic"
-	Description="Project reference properties"
-	xmlns="http://schemas.microsoft.com/build/2009/properties">
-
-    <Rule.DataSource>
-        <DataSource Persistence="ProjectFile" ItemType="ProjectReference" HasConfigurationCondition="False" />
-    </Rule.DataSource>
-
-    <BoolProperty Name="ReferenceOutputAssembly"
-                  DisplayName="Reference Output Assembly"
-				  Description="A value indicating whether the compiler should include a reference to the target project's primary output assembly." />
-
-    <BoolProperty Name="Private"
-                  DisplayName="Copy Local"
-				  Description="Indicates whether the primary output of the reference target should be copied into this project's output directory, when that metadata is set on an unresolved reference." />
-
-    <BoolProperty Name="CopyLocalSatelliteAssemblies"
-                  DisplayName="Copy Local Satellite Assemblies"
-				  Description="Indicates whether the satellite assemblies of the reference target should be copied into this project's output directory." />
-
-    <BoolProperty Name="LinkLibraryDependencies" Visible="False" />
-
-    <BoolProperty Name="UseLibraryDependencyInputs" Visible="False" />
-
-    <StringProperty Name="Project" 
-                    Visible="False"
-                    Description="the Guid the solution tracks an individual project reference target with" />
-
-    <StringProperty Name="ReferencedProjectIdentifier" Visible="False" Description="The old (VS2010 beta) way to store the Guid the solution tracks an individual project reference target with" />
-
-    <BoolProperty Name="CopyLocal"
-                  DisplayName="Copy Local"
-                  Description="Indicates whether the reference will be copied to the output directory.">
-        <BoolProperty.DataSource>
-            <DataSource Persistence="ProjectFile"
-                        ItemType="ProjectReference"
-                        HasConfigurationCondition="False"
-                        PersistedName="Private" />
-        </BoolProperty.DataSource>
-    </BoolProperty>
-</Rule>
+  Name="ProjectReference"
+  DisplayName="Project Reference"
+  PageTemplate="generic"
+  Description="Project reference properties"
+  xmlns="http://schemas.microsoft.com/build/2009/properties">
+
+  <Rule.DataSource>
+    <DataSource Persistence="ProjectFile" ItemType="ProjectReference" HasConfigurationCondition="False" />
+  </Rule.DataSource>
+
+  <BoolProperty Name="ReferenceOutputAssembly"
+    DisplayName="Reference Output Assembly"
+    Description="A value indicating whether the compiler should include a reference to the target project's primary output assembly." />
+
+  <BoolProperty Name="Private"
+    DisplayName="Copy Local"
+    Description="Indicates whether the primary output of the reference target should be copied into this project's output directory, when that metadata is set on an unresolved reference." />
+
+  <BoolProperty Name="CopyLocalSatelliteAssemblies"
+    DisplayName="Copy Local Satellite Assemblies"
+    Description="Indicates whether the satellite assemblies of the reference target should be copied into this project's output directory." />
+
+  <BoolProperty Name="LinkLibraryDependencies" Visible="False" />
+
+  <BoolProperty Name="UseLibraryDependencyInputs" Visible="False" />
+
+  <StringProperty Name="Project"
+    Visible="False"
+    Description="the Guid the solution tracks an individual project reference target with" />
+
+  <StringProperty Name="ReferencedProjectIdentifier" Visible="False" Description="The old (VS2010 beta) way to store the Guid the solution tracks an individual project reference target with" />
+
+  <BoolProperty Name="CopyLocal"
+    DisplayName="Copy Local"
+    Description="Indicates whether the reference will be copied to the output directory.">
+    <BoolProperty.DataSource>
+      <DataSource Persistence="ProjectFile"
+        ItemType="ProjectReference"
+        HasConfigurationCondition="False"
+        PersistedName="Private" />
+    </BoolProperty.DataSource>
+  </BoolProperty>
+</Rule>
\ No newline at end of file
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 1ced49c9b63..b5df279597a 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -191,7 +191,7 @@ public void HandleExecutionErrorsWhenToolDoesntLogError()
 
                 // We just tried to run "cmd.exe /C garbagegarbagegarbagegarbage.exe".  This should fail,
                 // but since "cmd.exe" doesn't log its errors in canonical format, no errors got
-                // logged by the tool itself.  Therefore, ToolTask's default implementation of 
+                // logged by the tool itself.  Therefore, ToolTask's default implementation of
                 // HandleTaskExecutionErrors should have logged error MSB6006.
                 engine.AssertLogContains("MSB6006");
             }
@@ -227,7 +227,7 @@ public void HandleExecutionErrorsWhenToolLogsError()
         }
 
         /// <summary>
-        /// ToolTask should never run String.Format on strings that are 
+        /// ToolTask should never run String.Format on strings that are
         /// not meant to be formatted.
         /// </summary>
         [Fact]
@@ -524,27 +524,16 @@ public void EnvironmentVariablesToToolTask()
 
             ProcessStartInfo startInfo = task.StartInfo;
 
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
             startInfo.Environment["a"].ShouldBe("b");
             startInfo.Environment["c"].ShouldBe("d");
             startInfo.Environment[userVarName].ShouldBe("x");
             startInfo.Environment["path"].ShouldBe(String.Empty);
-#else
-            startInfo.EnvironmentVariables["a"].ShouldBe("b");
-            startInfo.EnvironmentVariables["c"].ShouldBe("d");
-            startInfo.EnvironmentVariables[userVarName].ShouldBe("x");
-            startInfo.EnvironmentVariables["path"].ShouldBe(string.Empty);
-#endif
 
             if (NativeMethodsShared.IsWindows)
             {
                 Assert.Equal(
                         Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles),
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
                         startInfo.Environment["programfiles"],
-#else
-                        startInfo.EnvironmentVariables["programfiles"],
-#endif
                         true);
             }
         }
@@ -562,11 +551,7 @@ public void EnvironmentVariablesToToolTaskEqualsSign()
             bool result = task.Execute();
 
             result.ShouldBe(true);
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
             task.StartInfo.Environment["a"].ShouldBe("b=c");
-#else
-            task.StartInfo.EnvironmentVariables["a"].ShouldBe("b=c");
-#endif
         }
 
         /// <summary>
@@ -628,12 +613,7 @@ public void EnvironmentVariablesToToolTaskNotSet()
 
             result.ShouldBe(true);
             task.ExecuteCalled.ShouldBe(true);
-            Assert.True(
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
-                task.StartInfo.Environment["PATH"].Length > 0);
-#else
-                task.StartInfo.EnvironmentVariables["PATH"].Length > 0);
-#endif
+            Assert.True(task.StartInfo.Environment["PATH"].Length > 0);
         }
 
         /// <summary>
@@ -707,22 +687,14 @@ public void FindOnPathSucceeds()
         public void GetProcessStartInfoCanOverrideEnvironmentVariables()
         {
             MyTool task = new MyTool();
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
             task.DoProcessStartInfoMutation = (p) => p.Environment.Remove("a");
-#else
-            task.DoProcessStartInfoMutation = (p) => p.EnvironmentVariables.Remove("a");
-#endif
-            
+
             task.BuildEngine = new MockEngine();
             task.EnvironmentVariables = new[] { "a=b" };
             bool result = task.Execute();
 
             result.ShouldBe(true);
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
             task.StartInfo.Environment.ContainsKey("a").ShouldBe(false);
-#else
-            task.StartInfo.EnvironmentVariables.ContainsKey("a").ShouldBe(false);
-#endif
         }
 
         [Fact]
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 2629634f436..f9532864e15 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -862,7 +862,7 @@ private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs bui
                         _firstProjectStartedEventContext = buildEvent.BuildEventContext;
 
                         // We've never seen a project started event, so raise the build started event and save this project started event.
-                        BuildStartedEventArgs startedEvent = new BuildStartedEventArgs(_buildStartedEvent.Message, _buildStartedEvent.HelpKeyword, _buildStartedEvent.BuildEnvironment);
+                        BuildStartedEventArgs startedEvent = new BuildStartedEventArgs(_buildStartedEvent.Message, _buildStartedEvent.HelpKeyword, Traits.Instance.LogAllEnvironmentVariables ? _buildStartedEvent.BuildEnvironment : null);
                         RaiseBuildStartedEvent(sender, startedEvent);
                     }
 
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 6eb42bff3ff..cc316e7ad5e 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -33,7 +33,7 @@ public enum HostObjectInitializationStatus
         UseHostObjectToExecute,
 
         /// <summary>
-        /// This means that either there is no host object available, or that the host object is 
+        /// This means that either there is no host object available, or that the host object is
         /// not capable of supporting all of the features required for this build.  Therefore,
         /// ToolTask should fallback to an alternate means of doing the build, such as invoking
         /// the command-line tool.
@@ -56,7 +56,7 @@ public enum HostObjectInitializationStatus
     /// Base class used for tasks that spawn an executable. This class implements the ToolPath property which can be used to
     /// override the default path.
     /// </summary>
-    // INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and 
+    // INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and
     // we want to use resources from Utilities. Use LogPrivate (for private Utilities resources) and LogShared (for shared MSBuild resources)
     public abstract class ToolTask : Task, ICancelableTask
     {
@@ -65,7 +65,7 @@ public abstract class ToolTask : Task, ICancelableTask
         #region Constructors
 
         /// <summary>
-        /// Protected constructor 
+        /// Protected constructor
         /// </summary>
         protected ToolTask()
         {
@@ -87,7 +87,7 @@ protected ToolTask()
         }
 
         /// <summary>
-        /// Protected constructor 
+        /// Protected constructor
         /// </summary>
         /// <param name="taskResources">The resource manager for task resources</param>
         protected ToolTask(ResourceManager taskResources)
@@ -97,7 +97,7 @@ protected ToolTask(ResourceManager taskResources)
         }
 
         /// <summary>
-        /// Protected constructor 
+        /// Protected constructor
         /// </summary>
         /// <param name="taskResources">The resource manager for task resources</param>
         /// <param name="helpKeywordPrefix">The help keyword prefix for task's messages</param>
@@ -112,7 +112,7 @@ protected ToolTask(ResourceManager taskResources, string helpKeywordPrefix)
         #region Properties
 
         /// <summary>
-        /// The return code of the spawned process. If the task logged any errors, but the process 
+        /// The return code of the spawned process. If the task logged any errors, but the process
         /// had an exit code of 0 (success), this will be set to -1.
         /// </summary>
         [Output]
@@ -187,7 +187,7 @@ public virtual string ToolExe
         /// <summary>
         /// Whether or not to use UTF8 encoding for the cmd file and console window.
         /// Values: Always, Never, Detect
-        /// If set to Detect, the current code page will be used unless it cannot represent 
+        /// If set to Detect, the current code page will be used unless it cannot represent
         /// the Command string. In that case, UTF-8 is used.
         /// </summary>
         public string UseUtf8Encoding { get; set; } = EncodingUtilities.UseUtf8Detect;
@@ -205,7 +205,7 @@ public virtual string ToolExe
 
         /// <summary>
         /// Project visible property that allows the user to specify an amount of time after which the task executable
-        /// is terminated. 
+        /// is terminated.
         /// </summary>
         /// <value>Time-out in milliseconds. Default is <see cref="System.Threading.Timeout.Infinite"/> (no time-out).</value>
         public virtual int Timeout { set; get; } = System.Threading.Timeout.Infinite;
@@ -326,7 +326,7 @@ public virtual string ToolExe
         protected virtual void ProcessStarted() { }
 
         /// <summary>
-        /// Gets the fully qualified tool name. Should return ToolExe if ToolTask should search for the tool 
+        /// Gets the fully qualified tool name. Should return ToolExe if ToolTask should search for the tool
         /// in the system path. If ToolPath is set, this is ignored.
         /// </summary>
         /// <returns>Path string.</returns>
@@ -334,7 +334,7 @@ protected virtual void ProcessStarted() { }
 
         /// <summary>
         /// Gets the working directory to use for the process. Should return null if ToolTask should use the
-        /// current directory. 
+        /// current directory.
         /// </summary>
         /// <remarks>This is a method rather than a property so that derived classes (like Exec) can choose to
         /// expose a public WorkingDirectory property, and it would be confusing to have two properties.</remarks>
@@ -413,7 +413,7 @@ protected virtual bool HandleTaskExecutionErrors()
 
         /// <summary>
         /// We expect tasks to override this method if they support host objects.  The implementation should
-        /// make sure that the host object is ready to perform the real work of the task.  
+        /// make sure that the host object is ready to perform the real work of the task.
         /// </summary>
         /// <returns>The return value indicates what steps to take next.  The default is to assume that there
         /// is no host object provided, and therefore we should fallback to calling the command-line tool.</returns>
@@ -480,7 +480,7 @@ private string ComputePathToTool()
                 }
             }
 
-            // only look for the file if we have a path to it. If we have just the file name, we'll 
+            // only look for the file if we have a path to it. If we have just the file name, we'll
             // look for it in the path
             if (pathToTool != null)
             {
@@ -627,12 +627,7 @@ string responseFileSwitch
             {
                 foreach (KeyValuePair<string, string> entry in envOverrides)
                 {
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
                     startInfo.Environment[entry.Key] = entry.Value;
-#else
-                    startInfo.EnvironmentVariables[entry.Key] = entry.Value;
-#endif
-
                 }
 #pragma warning restore 0618
             }
@@ -642,11 +637,7 @@ string responseFileSwitch
             {
                 foreach (KeyValuePair<string, string> variable in _environmentVariablePairs)
                 {
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
                     startInfo.Environment[variable.Key] = variable.Value;
-#else
-                    startInfo.EnvironmentVariables[variable.Key] = variable.Value;
-#endif
                 }
             }
 
@@ -807,7 +798,7 @@ protected void DeleteTempFile(string fileName)
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                // Warn only -- occasionally temp files fail to delete because of virus checkers; we 
+                // Warn only -- occasionally temp files fail to delete because of virus checkers; we
                 // don't want the build to fail in such cases
                 LogShared.LogWarningWithCodeFromResources("Shared.FailedDeletingTempFile", fileName, e.Message);
             }
@@ -1225,7 +1216,7 @@ private bool AssignStandardStreamLoggingImportance()
             {
                 try
                 {
-                    // Parse the raw importance string into a strongly typed enumeration.  
+                    // Parse the raw importance string into a strongly typed enumeration.
                     _standardErrorImportanceToUse = (MessageImportance)Enum.Parse(typeof(MessageImportance), StandardErrorImportance, true /* case-insensitive */);
                 }
                 catch (ArgumentException)
@@ -1245,7 +1236,7 @@ private bool AssignStandardStreamLoggingImportance()
             {
                 try
                 {
-                    // Parse the raw importance string into a strongly typed enumeration.  
+                    // Parse the raw importance string into a strongly typed enumeration.
                     _standardOutputImportanceToUse = (MessageImportance)Enum.Parse(typeof(MessageImportance), StandardOutputImportance, true /* case-insensitive */);
                 }
                 catch (ArgumentException)
@@ -1386,7 +1377,7 @@ public override bool Execute()
 
                             if (encoding.CodePage != EncodingUtilities.CurrentSystemOemEncoding.CodePage)
                             {
-                                // cmd.exe reads the first line in the console CP, 
+                                // cmd.exe reads the first line in the console CP,
                                 // which for a new console (as here) is OEMCP
                                 // this string should ideally always be ASCII
                                 // and the same in any OEMCP.
@@ -1433,7 +1424,7 @@ public override bool Execute()
 
                 // Initialize the host object.  At this point, the task may elect
                 // to not proceed.  Compiler tasks do this for purposes of up-to-date
-                // checking in the IDE.  
+                // checking in the IDE.
                 HostObjectInitializationStatus nextAction = InitializeHostObject();
                 if (nextAction == HostObjectInitializationStatus.NoActionReturnSuccess)
                 {
@@ -1483,13 +1474,13 @@ public override bool Execute()
 
                 if (UseCommandProcessor)
                 {
-                    // Log that we are about to invoke the specified command.  
+                    // Log that we are about to invoke the specified command.
                     LogToolCommand(pathToTool + commandLineCommands);
                     LogToolCommand(batchFileContents);
                 }
                 else
                 {
-                    // Log that we are about to invoke the specified command.  
+                    // Log that we are about to invoke the specified command.
                     LogToolCommand(pathToTool + commandLineCommands + " " + responseFileCommands);
                 }
                 ExitCode = 0;
@@ -1497,7 +1488,7 @@ public override bool Execute()
                 if (nextAction == HostObjectInitializationStatus.UseHostObjectToExecute)
                 {
                     // The hosting IDE passed in a host object to this task.  Give the task
-                    // a chance to call this host object to do the actual work.  
+                    // a chance to call this host object to do the actual work.
                     try
                     {
                         if (!CallHostObjectToExecute())
@@ -1632,12 +1623,12 @@ private bool LogEnvironmentVariable(bool alreadyLoggedEnvironmentHeader, string
         private static readonly char[] s_equalsSplitter = MSBuildConstants.EqualsChar;
 
         /// <summary>
-        /// The actual importance at which standard out messages will be logged 
+        /// The actual importance at which standard out messages will be logged
         /// </summary>
         private MessageImportance _standardOutputImportanceToUse = MessageImportance.Low;
 
         /// <summary>
-        /// The actual importance at which standard error messages will be logged 
+        /// The actual importance at which standard error messages will be logged
         /// </summary>
         private MessageImportance _standardErrorImportanceToUse = MessageImportance.Normal;
 
@@ -1669,7 +1660,7 @@ private bool LogEnvironmentVariable(bool alreadyLoggedEnvironmentHeader, string
         private ManualResetEvent _toolExited;
 
         /// <summary>
-        /// Set to true if the tool process was terminated, 
+        /// Set to true if the tool process was terminated,
         /// either because the timeout was reached or it was canceled.
         /// </summary>
         private bool _terminatedTool;
