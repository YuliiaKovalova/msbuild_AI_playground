diff --git a/.github/workflows/copilot-setup-steps.yml b/.github/workflows/copilot-setup-steps.yml
new file mode 100644
index 00000000000..1cc553480d6
--- /dev/null
+++ b/.github/workflows/copilot-setup-steps.yml
@@ -0,0 +1,25 @@
+name: "Copilot Setup Steps"
+
+# Allow testing of the setup steps from your repository's "Actions" tab.
+on: workflow_dispatch
+
+jobs:
+  # The job MUST be called `copilot-setup-steps` or it will not be picked up by Copilot.
+  # See https://docs.github.com/en/copilot/customizing-copilot/customizing-the-development-environment-for-copilot-coding-agent
+  copilot-setup-steps:
+    runs-on: ubuntu-latest
+
+    permissions:
+      contents: read
+
+    # You can define any steps you want, and they will run before the agent starts.
+    # If you do not check out your code, Copilot will do this for you.
+    steps:
+      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
+
+      - uses: actions/setup-dotnet@67a3573c9a986a3f9c594539f4ab511d57bb3ce9 # 4.3.1
+        with:
+          global-json-file: global.json
+
+      - name: Restore MSBuild
+        run: ./eng/common/build.sh --restore
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index f8f6e6e69a0..03d6b6d9b64 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -110,11 +110,15 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: eq(variables.onlyDocChanged, 0)
-  - task: CmdLine@2
-    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
-    condition: failed()
+  - task: PowerShell@2
     inputs:
-      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
+      targetType: 'inline'
+      script: |
+        $files = Get-ChildItem -Path . -Recurse -Include *.received.*
+        if ($files.Count -gt 0) {
+          echo "##vso[task.setvariable variable=publishverify]Yes"
+        }
+    displayName: 'Set flag to publish *.received.* files when Verify test fails'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
@@ -308,11 +312,15 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: eq(variables.onlyDocChanged, 0)
-  - task: CmdLine@2
-    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
-    condition: failed()
+  - task: PowerShell@2
     inputs:
-      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
+      targetType: 'inline'
+      script: |
+        $files = Get-ChildItem -Path . -Recurse -Include *.received.*
+        if ($files.Count -gt 0) {
+          echo "##vso[task.setvariable variable=publishverify]Yes"
+        }
+    displayName: 'Set flag to publish *.received.* files when Verify test fails'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
@@ -375,11 +383,15 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: eq(variables.onlyDocChanged, 0)
-  - task: CmdLine@2
-    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
-    condition: failed()
+  - task: PowerShell@2
     inputs:
-      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
+      targetType: 'inline'
+      script: |
+        $files = Get-ChildItem -Path . -Recurse -Include *.received.*
+        if ($files.Count -gt 0) {
+          echo "##vso[task.setvariable variable=publishverify]Yes"
+        }
+    displayName: 'Set flag to publish *.received.* files when Verify test fails'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 6a162d2f160..b1062fa803e 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -112,21 +112,21 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25266.2">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25271.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>c62eeb5b5432f9eaa034fbd641ccd9fd0d928fb3</Sha>
+      <Sha>086a1771875b63404b4a710d27250fe384dc2810</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.15.0-preview.1.56">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.15.0-preview.1.65">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>cd2f5c4be1dfd21e7331aebebbbbee14111f348d</Sha>
+      <Sha>58c248e36695c9586c486e8876a43046e0817d41</Sha>
     </Dependency>
     <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="5.0.0-1.25274.2">
       <Uri>https://github.com/dotnet/roslyn</Uri>
       <Sha>392fbb66a16ca3d34abdfa93cc5a3717f447d25e</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25266.2">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25271.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>c62eeb5b5432f9eaa034fbd641ccd9fd0d928fb3</Sha>
+      <Sha>086a1771875b63404b4a710d27250fe384dc2810</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 63093448716..4208d1c75a6 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -80,8 +80,8 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25266.2</MicrosoftDotNetXUnitExtensionsVersion>
-    <NuGetBuildTasksVersion>6.15.0-preview.1.56</NuGetBuildTasksVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25271.1</MicrosoftDotNetXUnitExtensionsVersion>
+    <NuGetBuildTasksVersion>6.15.0-preview.1.65</NuGetBuildTasksVersion>
     <MicrosoftNetCompilersToolsetVersion>5.0.0-1.25274.2</MicrosoftNetCompilersToolsetVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
diff --git a/global.json b/global.json
index 854434d36d6..4b3d71ef4a0 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.12.0"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25266.2"
+    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25271.1"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
index e470f6be153..c8a163318f0 100644
--- a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
@@ -101,7 +101,7 @@ public void Dispose()
         /// <summary>
         /// Verify that when a single request is submitted, we get a request assigned back out.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestSimpleRequest()
         {
             CreateConfiguration(1, "foo.proj");
@@ -117,7 +117,7 @@ public void TestSimpleRequest()
         /// <summary>
         /// Verify that when we submit a request and we already have results, we get the results back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestSimpleRequestWithCachedResultsSuccess()
         {
             CreateConfiguration(1, "foo.proj");
@@ -141,7 +141,7 @@ public void TestSimpleRequestWithCachedResultsSuccess()
         /// <summary>
         /// Verify that when we submit a request with failing results, we get the results back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestSimpleRequestWithCachedResultsFail()
         {
             CreateConfiguration(1, "foo.proj");
@@ -165,7 +165,7 @@ public void TestSimpleRequestWithCachedResultsFail()
         /// <summary>
         /// Verify that when we submit a child request with results cached, we get those results back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestChildRequest()
         {
             CreateConfiguration(1, "foo.proj");
@@ -195,7 +195,7 @@ public void TestChildRequest()
         /// <summary>
         /// Verify that when multiple requests are submitted, the first one in is the first one out.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMultipleRequests()
         {
             CreateConfiguration(1, "foo.proj");
@@ -213,7 +213,7 @@ public void TestMultipleRequests()
         /// <summary>
         /// Verify that when multiple requests are submitted with results cached, we get the results back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMultipleRequestsWithSomeResults()
         {
             CreateConfiguration(1, "foo.proj");
@@ -235,7 +235,7 @@ public void TestMultipleRequestsWithSomeResults()
         /// <summary>
         /// Verify that when multiple requests are submitted with results cached, we get the results back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMultipleRequestsWithAllResults()
         {
             CreateConfiguration(1, "foo.proj");
@@ -266,7 +266,7 @@ public void TestMultipleRequestsWithAllResults()
         /// Verify that if the affinity of one of the requests is out-of-proc, we create an out-of-proc node (but only one)
         /// even if the max node count = 1.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestOutOfProcNodeCreatedWhenAffinityIsOutOfProc()
         {
             CreateConfiguration(1, "foo.proj");
@@ -288,7 +288,7 @@ public void TestOutOfProcNodeCreatedWhenAffinityIsOutOfProc()
         /// Verify that if the affinity of our requests is out-of-proc, that many out-of-proc nodes will
         /// be made (assuming it does not exceed MaxNodeCount)
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestOutOfProcNodesCreatedWhenAffinityIsOutOfProc()
         {
             _host.BuildParameters.MaxNodeCount = 4;
@@ -313,7 +313,7 @@ public void TestOutOfProcNodesCreatedWhenAffinityIsOutOfProc()
         /// we still won't create any new nodes if they're all for the same configuration --
         /// they'd end up all being assigned to the same node.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestNoNewNodesCreatedForMultipleRequestsWithSameConfiguration()
         {
             _host.BuildParameters.MaxNodeCount = 3;
@@ -336,7 +336,7 @@ public void TestNoNewNodesCreatedForMultipleRequestsWithSameConfiguration()
         /// Verify that if the affinity of our requests is "any", we will not create more than
         /// MaxNodeCount nodes (1 IP node + MaxNodeCount - 1 OOP nodes)
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMaxNodeCountNotExceededWithRequestsOfAffinityAny()
         {
             _host.BuildParameters.MaxNodeCount = 3;
@@ -366,7 +366,7 @@ public void TestMaxNodeCountNotExceededWithRequestsOfAffinityAny()
         /// node will service an Any request instead of an inproc request, leaving only one non-inproc request for the second round
         /// of node creation.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void VerifyRequestOrderingDoesNotAffectNodeCreationCountWithInProcAndAnyRequests()
         {
             // Since we're creating our own BuildManager, we need to make sure that the default
@@ -414,7 +414,7 @@ public void VerifyRequestOrderingDoesNotAffectNodeCreationCountWithInProcAndAnyR
         /// Verify that if the affinity of our requests is out-of-proc, we will create as many as
         /// MaxNodeCount out-of-proc nodes
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMaxNodeCountOOPNodesCreatedForOOPAffinitizedRequests()
         {
             _host.BuildParameters.MaxNodeCount = 3;
@@ -444,7 +444,7 @@ public void TestMaxNodeCountOOPNodesCreatedForOOPAffinitizedRequests()
         /// is less than MaxNodeCount, that we only create MaxNodeCount - 1 OOP nodes (for a total of MaxNodeCount
         /// nodes, when the inproc node is included)
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMaxNodeCountNodesNotExceededWithSomeOOPRequests1()
         {
             _host.BuildParameters.MaxNodeCount = 3;
@@ -474,7 +474,7 @@ public void TestMaxNodeCountNodesNotExceededWithSomeOOPRequests1()
         /// is less than MaxNodeCount, that we only create MaxNodeCount - 1 OOP nodes (for a total of MaxNodeCount
         /// nodes, when the inproc node is included)
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMaxNodeCountNodesNotExceededWithSomeOOPRequests2()
         {
             _host.BuildParameters.MaxNodeCount = 3;
@@ -511,7 +511,7 @@ public void SchedulerShouldHonorDisableInprocNode()
         /// Make sure that traversal projects are marked with an affinity of "InProc", which means that
         /// even if multiple are available, we should still only have the single inproc node.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestTraversalAffinityIsInProc()
         {
             _host.BuildParameters.MaxNodeCount = 3;
@@ -560,7 +560,7 @@ public void TestProxyAffinityIsInProc()
         /// With something approximating the BuildManager's build loop, make sure that we don't end up
         /// trying to create more nodes than we can actually support.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void VerifyNoOverCreationOfNodesWithBuildLoop()
         {
             // Since we're creating our own BuildManager, we need to make sure that the default
@@ -615,7 +615,7 @@ public void BuildResultNotPlacedInCurrentCacheIfConfigExistsInOverrideCache()
         /// <summary>
         /// Verify that if we get two requests but one of them is a failure, we only get the failure result back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestTwoRequestsWithFirstFailure()
         {
             CreateConfiguration(1, "foo.proj");
@@ -634,7 +634,7 @@ public void TestTwoRequestsWithFirstFailure()
         /// <summary>
         /// Verify that if we get two requests but one of them is a failure, we only get the failure result back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestTwoRequestsWithSecondFailure()
         {
             CreateConfiguration(1, "foo.proj");
@@ -653,7 +653,7 @@ public void TestTwoRequestsWithSecondFailure()
         /// <summary>
         /// Verify that if we get three requests but one of them is a failure, we only get the failure result back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestThreeRequestsWithOneFailure()
         {
             CreateConfiguration(1, "foo.proj");
@@ -673,7 +673,7 @@ public void TestThreeRequestsWithOneFailure()
         /// <summary>
         /// Verify that providing a result to the only outstanding request results in build complete.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestResult()
         {
             CreateConfiguration(1, "foo.proj");
@@ -697,7 +697,7 @@ public void TestResult()
         /// <summary>
         /// Tests that the detailed summary setting causes the summary to be produced.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestDetailedSummary()
         {
             string contents = ObjectModelHelpers.CleanupFileContents(@"
diff --git a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
index f500c937ab9..bc5f79f7ac9 100644
--- a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
+++ b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
@@ -259,8 +259,9 @@ public void BuildEnvironmentDetectsVisualStudioByMSBuildProcessAmd64()
         }
 
         [WindowsFullFrameworkOnlyTheory(additionalMessage: "No Visual Studio installed for .NET.")]
-        [InlineData("17.0", true)]
-        [InlineData("17.3", true)]
+        [InlineData("18.0", true)]
+        [InlineData("17.0", false)]
+        [InlineData("17.3", false)]
         [InlineData("16.0", false)]
         public void BuildEnvironmentDetectsVisualStudioFromSetupInstance(string visualStudioVersion, bool shouldBeValid)
         {
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index fa6ae4bbbfd..40d303360c4 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -560,6 +560,21 @@ public void BeginBuild(BuildParameters parameters)
                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath("msbuild-cache");
                 }
 
+                // Launch the RAR node before the detoured launcher overrides the default node launcher.
+                if (_buildParameters.EnableRarNode)
+                {
+                    NodeLauncher nodeLauncher = ((IBuildComponentHost)this).GetComponent<NodeLauncher>(BuildComponentType.NodeLauncher);
+                    _ = Task.Run(() =>
+                    {
+                        RarNodeLauncher rarNodeLauncher = new(nodeLauncher);
+
+                        if (!rarNodeLauncher.Start())
+                        {
+                            _buildParameters.EnableRarNode = false;
+                        }
+                    });
+                }
+
 #if FEATURE_REPORTFILEACCESSES
                 if (_buildParameters.ReportFileAccesses)
                 {
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 1bfab1b0e52..9ae5c5f5bde 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -124,6 +124,8 @@ public class BuildParameters : ITranslatable
         private bool _enableNodeReuse = false;
 #endif
 
+        private bool _enableRarNode;
+
         /// <summary>
         /// The original process environment.
         /// </summary>
@@ -277,6 +279,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             _culture = other._culture;
             _defaultToolsVersion = other._defaultToolsVersion;
             _enableNodeReuse = other._enableNodeReuse;
+            _enableRarNode = other._enableRarNode;
             _buildProcessEnvironment = resetEnvironment
                 ? CommunicationsUtilities.GetEnvironmentVariables()
                 : other._buildProcessEnvironment != null
@@ -424,6 +427,15 @@ public bool EnableNodeReuse
             set => _enableNodeReuse = Environment.GetEnvironmentVariable("MSBUILDDISABLENODEREUSE") == "1" ? false : value;
         }
 
+        /// <summary>
+        /// When true, the ResolveAssemblyReferences task executes in an out-of-proc node which persists across builds.
+        /// </summary>
+        public bool EnableRarNode
+        {
+            get => _enableRarNode;
+            set => _enableRarNode = value;
+        }
+
         /// <summary>
         /// Gets an immutable collection of environment properties.
         /// </summary>
@@ -915,6 +927,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _defaultToolsVersion);
             translator.Translate(ref _disableInProcNode);
             translator.Translate(ref _enableNodeReuse);
+            translator.Translate(ref _enableRarNode);
             translator.TranslateProjectPropertyInstanceDictionary(ref _environmentProperties);
             /* No forwarding logger information sent here - that goes with the node configuration */
             translator.TranslateProjectPropertyInstanceDictionary(ref _globalProperties);
diff --git a/src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs b/src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs
new file mode 100644
index 00000000000..1c3d3b0208a
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs
@@ -0,0 +1,79 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal sealed class RarNodeLauncher
+    {
+        private readonly INodeLauncher _nodeLauncher;
+
+        private readonly string _pipeName;
+
+        internal RarNodeLauncher(INodeLauncher nodeLauncher)
+        {
+            _nodeLauncher = nodeLauncher;
+            _pipeName = NamedPipeUtil.GetRarNodePipeName(new(HandshakeOptions.None));
+        }
+
+        /// <summary>
+        /// Creates a new MSBuild process with the RAR nodemode.
+        /// </summary>
+        public bool Start()
+        {
+            if (IsRarNodeRunning())
+            {
+                CommunicationsUtilities.Trace("Existing RAR node found.");
+                return true;
+            }
+
+            CommunicationsUtilities.Trace("Launching RAR node...");
+
+            try
+            {
+                LaunchNode();
+            }
+            catch (NodeFailedToLaunchException ex)
+            {
+                CommunicationsUtilities.Trace("Failed to launch RAR node: {0}", ex);
+                return false;
+            }
+
+            return true;
+        }
+
+        private bool IsRarNodeRunning()
+        {
+            // Determine if the node is running by checking if the expected named pipe exists.
+            if (NativeMethodsShared.IsWindows)
+            {
+                const string NamedPipeRoot = @"\\.\pipe\";
+
+                // File.Exists() will crash the pipe server, as the underlying Windows APIs have undefined behavior
+                // when used with pipe objects. Enumerating the pipe directory avoids this issue.
+                IEnumerable<string> pipeNames = FileSystems.Default.EnumerateFiles(NamedPipeRoot);
+
+                return pipeNames.Contains(Path.Combine(NamedPipeRoot, _pipeName));
+            }
+            else
+            {
+                // On Unix, named pipes are implemented via sockets, and the pipe name is simply the file path.
+                return FileSystems.Default.FileExists(_pipeName);
+            }
+        }
+
+        private void LaunchNode()
+        {
+            string msbuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
+            string commandLineArgs = string.Join(" ", ["/nologo", "/nodemode:3"]);
+            _ = _nodeLauncher.Start(msbuildLocation, commandLineArgs, nodeId: 0);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index a262028f9f9..0cb83e34bed 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -940,6 +940,8 @@ public override bool LogsMessagesOfImportance(MessageImportance importance)
             /// <inheritdoc/>
             public override bool IsTaskInputLoggingEnabled => _taskHost._host.BuildParameters.LogTaskInputs;
 
+            public override bool IsOutOfProcRarNodeEnabled => _taskHost._host.BuildParameters.EnableRarNode;
+
 #if FEATURE_REPORTFILEACCESSES
             /// <summary>
             /// Reports a file access from a task.
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 6bcb954c1f3..a3141a4dc87 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -2239,49 +2239,55 @@ private bool RequestOrAnyItIsBlockedByCanBeServiced(SchedulableRequest request)
         }
 
         /// <summary>
-        /// Determines if we have a matching request somewhere, and if so, assigns the same request ID.  Otherwise
-        /// assigns a new request id.
+        /// Determines if we have a matching request somewhere, and if so, assigns the same request ID.
+        /// Otherwise assigns a new request id.
         /// </summary>
-        /// <remarks>
-        /// UNDONE: (Performance) This algorithm should be modified so we don't have to iterate over all of the
-        /// requests to find a matching one.  A HashSet with proper equality semantics and a good hash code for the BuildRequest
-        /// would speed this considerably, especially for large numbers of projects in a build.
-        /// </remarks>
         /// <param name="request">The request whose ID should be assigned</param>
         private void AssignGlobalRequestId(BuildRequest request)
         {
-            bool assignNewId = false;
-            if (request.GlobalRequestId == BuildRequest.InvalidGlobalRequestId && _schedulingData.GetRequestsAssignedToConfigurationCount(request.ConfigurationId) > 0)
+            // Quick exit if already assigned or if there are no requests for this configuration
+            if (request.GlobalRequestId != BuildRequest.InvalidGlobalRequestId
+                || _schedulingData.GetRequestsAssignedToConfigurationCount(request.ConfigurationId) == 0)
+            {
+                request.GlobalRequestId = _nextGlobalRequestId++;
+                return;
+            }
+
+            HashSet<string> requestTargetsSet = new(request.Targets, StringComparer.OrdinalIgnoreCase);
+
+            // Look for matching requests in the configuration
+            foreach (SchedulableRequest existingRequest in _schedulingData.GetRequestsAssignedToConfiguration(request.ConfigurationId))
             {
-                foreach (SchedulableRequest existingRequest in _schedulingData.GetRequestsAssignedToConfiguration(request.ConfigurationId))
+                if (TargetsMatch(requestTargetsSet, existingRequest.BuildRequest.Targets))
                 {
-                    if (existingRequest.BuildRequest.Targets.Count == request.Targets.Count)
-                    {
-                        List<string> leftTargets = new List<string>(existingRequest.BuildRequest.Targets);
-                        List<string> rightTargets = new List<string>(request.Targets);
+                    request.GlobalRequestId = existingRequest.BuildRequest.GlobalRequestId;
+                    return;
+                }
+            }
 
-                        leftTargets.Sort(StringComparer.OrdinalIgnoreCase);
-                        rightTargets.Sort(StringComparer.OrdinalIgnoreCase);
-                        for (int i = 0; i < leftTargets.Count; i++)
-                        {
-                            if (!leftTargets[i].Equals(rightTargets[i], StringComparison.OrdinalIgnoreCase))
-                            {
-                                assignNewId = true;
-                                break;
-                            }
-                        }
+            // No matching request found, assign a new ID
+            request.GlobalRequestId = _nextGlobalRequestId++;
+        }
 
-                        if (!assignNewId)
-                        {
-                            request.GlobalRequestId = existingRequest.BuildRequest.GlobalRequestId;
-                            return;
-                        }
-                    }
+        /// <summary>
+        /// Determines if two target collections contain the same targets, ignoring order and case.
+        /// </summary>
+        private bool TargetsMatch(HashSet<string> firstTargetsSet, List<string> secondTargetsList)
+        {
+            if (firstTargetsSet.Count != secondTargetsList.Count)
+            {
+                return false;
+            }
+
+            foreach (string target in secondTargetsList)
+            {
+                if (!firstTargetsSet.Contains(target))
+                {
+                    return false;
                 }
             }
 
-            request.GlobalRequestId = _nextGlobalRequestId;
-            _nextGlobalRequestId++;
+            return true;
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 8e8f26a1233..ae6988de3e4 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -7,7 +7,11 @@
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
+#if NET
 using System.IO;
+#else
+using Microsoft.IO;
+#endif
 using System.Linq;
 using System.Reflection;
 using System.Runtime.CompilerServices;
@@ -1369,7 +1373,7 @@ internal static object ExpandPropertyBody(
                 // if what we have is a function
                 if (!IsValidPropertyName(propertyBody))
                 {
-                    if (propertyBody.Contains(".") || propertyBody[0] == '[')
+                    if (propertyBody.Contains('.') || propertyBody[0] == '[')
                     {
                         if (BuildParameters.DebugExpansion)
                         {
@@ -1400,7 +1404,7 @@ internal static object ExpandPropertyBody(
                             return null;
                         }
                     }
-                    else if (propertyValue == null && propertyBody.Contains("[")) // a single property indexer
+                    else if (propertyValue == null && propertyBody.Contains('[')) // a single property indexer
                     {
                         int indexerStart = propertyBody.IndexOf('[');
                         int indexerEnd = propertyBody.IndexOf(']');
@@ -4092,7 +4096,7 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                         {
                             coercedArguments[n] = args[n].ToString().ToCharArray();
                         }
-                        else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string v && v.Contains("."))
+                        else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string v && v.Contains('.'))
                         {
                             Type enumType = parameters[n].ParameterType;
                             string typeLeafName = $"{enumType.Name}.";
diff --git a/src/Build/Evaluation/Expander/ArgumentParser.cs b/src/Build/Evaluation/Expander/ArgumentParser.cs
index c2dd113d5ff..2d9fa7954a0 100644
--- a/src/Build/Evaluation/Expander/ArgumentParser.cs
+++ b/src/Build/Evaluation/Expander/ArgumentParser.cs
@@ -3,8 +3,9 @@
 
 using System;
 using System.Globalization;
+
 #if NETFRAMEWORK
-using System.Linq;
+using Microsoft.IO;
 #endif
 
 namespace Microsoft.Build.Evaluation.Expander
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index b28ac113cd2..144e09f128a 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -361,6 +361,7 @@
     <Compile Include="BackEnd\Components\Communications\NodeInfo.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeProviderInProc.cs" />
+    <Compile Include="BackEnd\Components\Communications\RarNodeLauncher.cs" />
     <Compile Include="BackEnd\Components\IBuildComponent.cs" />
     <Compile Include="BackEnd\Components\IBuildComponentHost.cs" />
     <Compile Include="BackEnd\Components\Scheduler\IScheduler.cs" />
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index cf5b6ae383e..3df7fd23a1f 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -5,7 +5,11 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if NET
 using System.IO;
+#else
+using Microsoft.IO;
+#endif
 using System.Linq;
 using System.Text;
 using System.Text.RegularExpressions;
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 3bbcfe6f6f2..84e325912c2 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -140,7 +140,7 @@ internal static void ApplyChangeWave()
                 ConversionState = ChangeWaveConversionState.InvalidFormat;
                 _cachedWave = ChangeWaves.EnableAllFeatures;
             }
-            else if (_cachedWave == EnableAllFeatures || AllWaves.Contains(_cachedWave))
+            else if (_cachedWave == EnableAllFeatures || Array.IndexOf(AllWaves, _cachedWave) >= 0)
             {
                 ConversionState = ChangeWaveConversionState.Valid;
             }
@@ -172,7 +172,7 @@ internal static bool AreFeaturesEnabled(Version wave)
             ApplyChangeWave();
 
 #if DEBUG
-            Debug.Assert(_runningTests || AllWaves.Contains(wave), $"Change wave version {wave} is invalid");
+            Debug.Assert(_runningTests || Array.IndexOf(AllWaves, wave) >= 0, $"Change wave version {wave} is invalid");
 #endif
 
             return wave < _cachedWave;
diff --git a/src/Framework/EngineServices.cs b/src/Framework/EngineServices.cs
index 491604c7827..76b3ccb839c 100644
--- a/src/Framework/EngineServices.cs
+++ b/src/Framework/EngineServices.cs
@@ -20,6 +20,11 @@ public abstract class EngineServices
         /// </summary>
         public const int Version1 = 1;
 
+        /// <summary>
+        /// Version 2 with IsOutOfProcRarNodeEnabled().
+        /// </summary>
+        public const int Version2 = 2;
+
         /// <summary>
         /// Gets an explicit version of this class.
         /// </summary>
@@ -27,7 +32,7 @@ public abstract class EngineServices
         /// Must be incremented whenever new members are added. Derived classes should override
         /// the property to return the version actually being implemented.
         /// </remarks>
-        public virtual int Version => Version1;
+        public virtual int Version => Version2;
 
         /// <summary>
         /// Returns <see langword="true"/> if the given message importance is not guaranteed to be ignored by registered loggers.
@@ -48,5 +53,7 @@ public abstract class EngineServices
         /// This is a performance optimization allowing tasks to skip expensive double-logging.
         /// </remarks>
         public virtual bool IsTaskInputLoggingEnabled => throw new NotImplementedException();
+
+        public virtual bool IsOutOfProcRarNodeEnabled => throw new NotImplementedException();
     }
 }
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index e355761d9fd..da8da210b3c 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -121,6 +121,12 @@ public Traits()
         /// </summary>
         public readonly int DictionaryBasedItemRemoveThreshold = ParseIntFromEnvironmentVariableOrDefault("MSBUILDDICTIONARYBASEDITEMREMOVETHRESHOLD", 100);
 
+        /// <summary>
+        /// Launches a persistent RAR process.
+        /// </summary>
+        /// TODO: Replace with command line flag when feature is completed. The environment variable is intented to avoid exposing the flag early.
+        public readonly bool EnableRarNode = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildRarNode"));
+
         /// <summary>
         /// Name of environment variables used to enable MSBuild server.
         /// </summary>
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 56c53a3af4d..a21af6ba0a0 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -450,7 +450,7 @@ elementFormDefault="qualified">
             <xs:element name="BasicRuntimeChecks" />
             <xs:element name="RuntimeLibrary" />
             <xs:element name="FunctionLevelLinking" />
-            <xs:element name="FloatingPointModel " />
+            <xs:element name="FloatingPointModel" />
             <xs:element name="IntrinsicFunctions" />
             <xs:element name="PrecompiledHeaderFile"/>
             <xs:element name="MultiProcessorCompilation" />
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 691ded85c3a..17649c98a14 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -712,6 +712,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 17f88bf1e8b..46f4539dd56 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -2005,6 +2005,14 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2038,42 +2046,50 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Serializuje všechny události sestavení do komprimovaného binárního souboru.
-                     Tento soubor se standardně nachází v aktuálním adresáři a má název msbuild.binlog.
-                     Binární protokol je podrobný popis procesu sestavení, který se
-                     dá později použít k rekonstrukci textových protokolů
-                     a který můžou používat jiné nástroje pro analýzu.
-                     Binární protokol má obvykle 10–20krát menší velikost než
-                     nejpodrobnější textový protokol na úrovni diagnostiky, ale obsahuje více informací.
-                     (Krátký tvar: -bl)
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
+
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                     Binární protokolovací nástroj standardně shromažďuje
-                     zdrojový text projektových souborů včetně všech
-                     importovaných projektů a cílových souborů zjištěných
-                     při sestavování. Toto chování řídí volitelný parametr ProjectImports:
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
 
-                     ProjectImports=None     - Neshromažďovat importované
-                                                 projekty.
-                      ProjectImports=Embed    - Vložit importované projekty
-                     do souboru protokolu.
-                      ProjectImports=ZipFile  - Uložit projektové soubory
-                                                do output.projectimports.zip,
-                                                kde output je stejný název
-                                                jako název souboru binárního protokolu.
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
+                                                output.projectimports.zip
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     Výchozí nastavení pro ProjectImports je Embed.
-                     Poznámka: Protokolovací nástroj neshromažďuje zdrojové
-                     soubory nepatřící pod MSBuild, jako .cs, .cpp atd.
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     Soubor .binlog se dá znovu přehrát“ tak, že se předá
-                     souboru msbuild.exe jako argument místo projektu/řešení.
-                     Jiné protokolovací nástroje obdrží informace obsažené
-                     v souboru protokolu, jako by šlo o původní sestavení.
-                     Více o binárním protokolu a jeho použití si můžete přečíst na stránce:
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
                      https://aka.ms/msbuild/binlog
 
-                     Příklady:
+                     Examples:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 03c2ca750fb..87503286149 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1993,6 +1993,14 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2026,42 +2034,50 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Serialisiert alle Buildereignisse in eine komprimierte Binärdatei.
-                     Standardmäßig befindet sich die Datei im aktuellen Verzeichnis und hat den Namen
-                     „msbuild.binlog“. Das binäre Protokoll ist eine detaillierte Beschreibung
-                     des Buildprozesses, der später zum Rekonstruieren von
-                     Textprotokollen dient und der von anderen Analysetools verwendet wird. Detaillierte
-                     Textprotokolle auf Diagnoseebene sind in der Regel 10–20-mal so groß wie
-                     binäre Protokolle, letztere enthalten jedoch mehr Informationen.
-                     (Kurzform: -bl)
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
+
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                     Die binäre Protokollierung erfasst standardmäßig den Quelltext von
-                     Projektdateien, einschließlich aller beim Buildvorgang aufgetretenen importierten
-                     Projekte und Zieldateien. Der optionale Schalter
-                     ProjectImports steuert dieses Verhalten:
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
 
-                      ProjectImports=None:      – Projektimporte nicht
-                                                erfassen
-                      ProjectImports=Embed:     – Projektimporte in die
-                                                Protokolldatei einbetten
-                      ProjectImports=ZipFile:   – Projektdateien in
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
                                                 output.projectimports.zip
-                                                speichern, wobei „output“ dem Namen
-                                                der binären Protokolldatei entspricht.
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     Die Standardeinstellung für „ProjectImports“ ist „Embed“.
-                     Hinweis: Die Protokollierung erfasst nur MSBuild-Quelldateien.
-                     Andere Dateien wie etwa CS, CPP usw. werden nicht erfasst.
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     Eine BINLOG-Datei kann „wiedergegeben“ werden, indem sie an
-                     „msbuild.exe“ als Argument und nicht als Projekt/Lösung übergeben wird.
-                     Andere Protokollierungen erhalten die Informationen, die
-                     wie beim ursprünglichen Buildvorgang in der Protokolldatei enthalten sind.
-                     Weitere Informationen zu binären Protokollen und ihrer Verwendung erhalten Sie unter:
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
                      https://aka.ms/msbuild/binlog
 
-                     Beispiele:
+                     Examples:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index d8d6d837bb7..c2804fb60c9 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1999,6 +1999,14 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2032,49 +2040,57 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Serializa todos los eventos de compilación en un archivo                     binario comprimido.
- De manera predeterminada, el archivo se encuentra en el directorio actual y tiene
-                     el nombre "msbuild.binlog". El registro binario es una
-                     descripción detallada del proceso de compilación que
-                     se puede utilizar más adelante para reconstruir registros
-                     de texto y que otras herramientas de análisis pueden emplear. Un registro binario suele ser de 10 a 20 veces
-                     más pequeño que el registro de nivel de diagnóstico de texto más detallado, pero contiene más información
-                    (Forma corta: -bl).
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
 
-                     De manera predeterminada, el registrador binario recopila
-                     el texto de origen de los archivos del proyecto, incluidos
-                     todos los proyectos y archivos de destino importados que se encuentren durante la compilación. El modificador
-                     opcional ProjectImports controla este comportamiento:
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                      ProjectImports=None     - No recopilar importaciones
-                                                de proyecto.
-                      ProjectImports=Embed    - Insertar importaciones de
-                                                proyecto en el archivo de registro.
-                      ProjectImports=ZipFile  - Guardar los archivos del
-                                                proyecto en salida.projectimports.zip,
-                                                donde "salida" es el mismo nombre que
-                                                el del archivo de registro binario.
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
+
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
+                                                output.projectimports.zip
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     La configuración predeterminada de ProjectImports es Embed.
-                     Nota: El registrador no recopila archivos de código fuente
-                     que no sean de MSBuild, como .cs, .cpp, etc.
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     Un archivo .binlog se puede "reproducir" pasándolo a
-                     msbuild.exe como argumento en lugar de proyecto o                     solución.
- Otros registradores recibirán la información
-                     que contiene el archivo de registro como si se estuviera
-                     ejecutando la compilación original. Encontrará más información sobre el registro binario y su uso en:
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
                      https://aka.ms/msbuild/binlog
 
-                     Ejemplos:
+                     Examples:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
-                      -bl:output.binlog;ProjectImports=ZipFile
+                       -bl:output.binlog;ProjectImports=ZipFile
                        -bl:..\..\custom.binlog
-                     -binaryLogger
-   </target>
+                       -binaryLogger
+    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "msbuild"
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index ac46ff96a7d..2035fa38c81 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1994,6 +1994,14 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2027,66 +2035,57 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Sérialise tous les événements de build dans un fichier binaire compressé.
-                     Par défaut, le fichier se trouve dans le répertoire actif et se nomme
-                     "msbuild.binlog". Le journal binaire est une description détaillée
-                     du processus de génération, qui peut servir plus tard à reconstruire
-                     les journaux texte et être utilisé par d'autres outils d'analyse. Un journal binaire
-                     est généralement
-10 à 20
-fois plus petit que le journal
-                     de diagnostic de type texte le plus détaillé, mais il contient plus d'informations.
-                     (Forme abrégée
-: -bl)
-
-
-                     Le journaliseur binaire par défaut collecte le texte source
-
-                     des fichiers projet, notamment tous les projets importés et les
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
 
-                     fichiers cibles rencontrés pendant la build. Le commutateur
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                     ProjectImports facultatif contrôle ce comportement
-:
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
 
-                      ProjectImports=None     - Ne collecte pas les importations
-                                                du projet.
-                      ProjectImports=Embed    - Incorpore les importations du projet dans
-                                                le fichier journal.
-                      ProjectImports=ZipFile  - Enregistre les fichiers projet dans
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
                                                 output.projectimports.zip
-                                                où la sortie porte le même nom que
-                                                le fichier journal binaire.
-
-                     Le paramètre par défaut de ProjectImports est Embed.
-                     Remarque
-: Le journaliseur ne collecte pas les
-
-                     fichiers sources non MSBuild tels que .cs, .cpp etc.
-
-
-                     Vous pouvez "lire" un fichier .binlog en le passant à
-
-                     msbuild.exe en tant qu'argument plutôt qu'en tant que projet/solution.
-
-                     D'autres enregistreurs d'événements reçoivent les informations
-
-                     contenues dans le fichier journal comme si la build d'origine était en cours de création.
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     Pour plus d'informations sur le journal binaire et ses usages, consultez
-:
-                    https://aka.ms/msbuild/binlog
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     Exemples
-:
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
+                     https://aka.ms/msbuild/binlog
 
+                     Examples:
                        -bl
-
                        -bl:output.binlog
-
                        -bl:output.binlog;ProjectImports=None
-                       -bl:output.binlog;ProjectImports=ZipFile                       -bl:..\..\custom.binlog                       -binaryLogger    </target>
+                       -bl:output.binlog;ProjectImports=ZipFile
+                       -bl:..\..\custom.binlog
+                       -binaryLogger
+    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "msbuild"
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 842cdf22a24..7629d5db226 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -2006,6 +2006,14 @@ Nota: livello di dettaglio dei logger di file
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2039,42 +2047,50 @@ Nota: livello di dettaglio dei logger di file
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Serializza tutti gli eventi di compilazione in un file binario compresso.
-                     Per impostazione predefinita, il file csi trova nella directory corrente e si chiama
-                     "msbuild.binlog". Il log binario è una descrizione
-                     dettagliata del processo di compilazione utilizzabile in
-                     seguito per ricostruire i log di testo e viene usato da altri strumenti di analisi. Un log binario è in genere
-                     10-20 volte più piccolo del più dettagliato log di testo
-                     di livello diagnostico, ma contiene maggiori informazioni.
-                     (Froma breve: -bl)
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
+
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                     Per impostazione predefinita, il logger binario raccoglie il testo di origine di
-                     file di progetto, inclusi tutti i
-                     progetti importati e i file di destinazione rilevati durante la compilazione. L'opzione facoltativa
-                     ProjectImports controlla questo comportamento:
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
 
-                      ProjectImports=None     - Non viene eseguita la raccolta
-                                                delle importazioni del progetto.
-                      ProjectImports=Embed    - Le importazioni del progetto vengono incorporate nel
-                                                file di log.
-                      ProjectImports=ZipFile  - I file del progetto vengono salvati in
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
                                                 output.projectimports.zip
-                                                dove output corrisponde allo
-                                                as stesso nome del file di log binario.
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     L'impostazione predefinita di ProjectImports è Embed.
-                     Nota: il logger non raccoglie i file di origine non-MSBuild,
-                     ad esempio quelli con estensione .cs, .cpp e così via.
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     È possibile riprodurre un file con estensione binlog
-                     passandolo a msbuild.exe come argomento invece di un progetto o di una soluzione.
-                     Altri logger riceveranno le
-                     informazioni contenute nel file di log come se fosse in corso la compilazione originale.
-                     Per maggiori informazioni sul file di log e su come usarlo, vedere:
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
                      https://aka.ms/msbuild/binlog
 
-                     Esempi:
+                     Examples:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 4dad67e4fa9..f68b82c28e9 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1993,6 +1993,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2026,42 +2034,50 @@
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     すべてのビルド イベントを圧縮バイナリ ファイルにシリアル化します。
-                     既定では、このファイルは "msbuild.binlog" という名前で
-                     現在のディレクトリに置かれます。バイナリ ログはビルド プロセスの
-                     詳細な説明であり、後でテキスト ログを再構築するために使用でき、
-                     他の分析ツールでも使用できます。バイナリ ログは通常、
-                     ほとんどの詳細なテキスト診断レベル ログと比べて 10 分の 1 から
-                     20 分の 1 の大きさですが、より多くの情報を含んでいます。
-                     (短い形式: -bl)
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
 
-                     既定では、バイナリ ロガーはプロジェクト ファイルのソース テキストを
-                     収集します。それには、ビルド中に検出された、すべてのインポート済み
-                     プロジェクトとターゲット ファイルが含まれます。オプションの
-                     ProjectImports スイッチは次のように動作を制御します。
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                      ProjectImports=None     - プロジェクト インポートを収集しません。
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
 
-                      ProjectImports=Embed    - プロジェクト インポートをログ ファイルに
-                                                組み込みます。
-                      ProjectImports=ZipFile  - プロジェクト ファイルを
-                                                output.projectimports.zip に保存します。
-                                                ここで、output はバイナリ ログ
-                                                ファイル名と同じ名前です。
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
+                                                output.projectimports.zip
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     ProjectImports の既定の設定は Embed です。
-                     メモ: ロガーは、MSBuild 以外のソース ファイルを収集しません
-                     (.cs、.cpp など)。
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     プロジェクト/ソリューションの代わりに、引数として .binlog ファイルを
-                     msbuild.exe に渡すと、そのファイルを "再生" することができます。
-                     他のロガーは、オリジナルのビルドが行われたときのように、
-                     ログ ファイルに含まれる情報を受け取ることができます。
-                     バイナリ ログとその使用法の詳細については、以下をお読みください。
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
                      https://aka.ms/msbuild/binlog
 
-                     例:
+                     Examples:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index b4c9c4b26fe..5765fff72a9 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1993,6 +1993,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2026,42 +2034,50 @@
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     모든 빌드 이벤트를 압축된 이진 파일로 직렬화합니다.
-                     기본적으로 이 파일은 현재 디렉터리에 있으며 이름은
-                     "msbuild.binlog"입니다. 이진 로그는 빌드 프로세스를
-                     자세히 설명하는 것으로, 나중에 텍스트 로그를 다시
-                     구성하기 위해 사용할 수 있고 다른 분석 도구에 의해
-                     사용될 수 있습니다. 이진 로그는 일반적으로 가장
-                     상세한 텍스트 진단 수준 로그보다 10~20배 작지만,
-                     더 자세한 정보를 포함하고 있습니다.
-                     (약식: -bl)
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
+
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                     이진 로거는 기본적으로 빌드 중에 가져온 모든 프로젝트와
-                     발생한 대상 파일을 비롯한 프로젝트 파일의 소스 텍스트를
-                     수집합니다. 선택적 ProjectImports 스위치는 이 동작을 제어합니다.
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
 
-                      ProjectImports=None     - 프로젝트 가져오기를 수집하지
-                                                않습니다.
-                      ProjectImports=Embed    - 로그 파일에 프로젝트 가져오기를
-                                                포함합니다.
-                      ProjectImports=ZipFile  - 프로젝트 파일을
-                                                output.projectimports.zip에 저장합니다.
-                                                여기서 output은 이진 로그 파일 이름과
-                                                같은 이름입니다.
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
+                                                output.projectimports.zip
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     ProjectImports의 기본 설정은 Embed입니다.
-                     참고: 로거는 .cs, .cpp 등과 같은 MSBuild가 아닌 소스 파일은
-                     수집하지 않습니다.
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     .binlog 파일을 프로젝트/솔루션 대신 인수로 msbuild.exe에
-                     전달하여 "재생"할 수 있습니다. 다른 로거는 원본 빌드가
-		     발생하고 있는 것처럼 로그 파일에 포함된 정보를 받게 됩니다.
-                     이진 로그 및 해당 사용법에 대한 자세한 내용은
-                     다음 위치에서 확인할 수 있습니다.
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
                      https://aka.ms/msbuild/binlog
 
-                     예:
+                     Examples:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 5d20dcb3b21..12c55ded106 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -2003,6 +2003,14 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2036,42 +2044,50 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]wyjście.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Serializuje wszystkie zdarzenia kompilacji do skompresowanego pliku binarnego.
-                     Domyślnie plik znajduje się w bieżącym katalogu i ma nazwę
-                     „msbuild.binlog”. Dziennik binarny to szczegółowy opis procesu
-                     kompilacji, którego można później użyć do odtworzenia
-dzienników                     tekstowych i wykorzystać w innych narzędziach do analizy. Dziennik binarny
-                     jest zwykle 10–20 razy mniejszy od najbardziej szczegółowych
-                     tekstowych dzienników na poziomie diagnostycznym, ale zawiera więcej informacji.
-                     (Krótka forma: -bl)
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
+
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                     Rejestrator binarny domyślnie zbiera tekst źródłowy
-                     plików projektu, w tym wszystkie zaimportowane projekty i pliki
-                     docelowe napotkane podczas kompilowania. Tym zachowaniem
-                     steruje opcjonalny przełącznik ProjectImports:
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
 
-                      ProjectImports=None     — Nie zbieraj importów
-                                                projektu.
-                      ProjectImports=Embed    — Osadź importy projektu w
-                                                pliku dziennika.
-                      ProjectImports=ZipFile  — Zapisz pliki projektu w pliku
-                                                output.projectimports.zip,
-                                                gdzie wyjście to ciąg podany
-                                                dla nazwy pliku dziennika binarnego.
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
+                                                output.projectimports.zip
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     Domyślne ustawienie przełącznika ProjectImports to Embed.
-                     Uwaga: rejestrator nie zbiera plików źródłowych
-                     niepochodzących z programu MSBuild, np. cs, cpp itd.
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     Plik binlog można „odtworzyć”, przekazując go do programu
-                     msbuild.exe jako argument zamiast projektu/rozwiązania.
-                     Inne rejestratory otrzymają informacje zawarte w pliku
-                     dziennika tak, jak podczas wykonywania pierwotnej kompilacji.
-                     Więcej informacji o dzienniku binarnym i jego zastosowaniach można uzyskać na stronie:
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
                      https://aka.ms/msbuild/binlog
 
-                     Przykłady:
+                     Examples:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 873f8078d9d..5e69b2ed4dd 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1993,6 +1993,14 @@ arquivo de resposta.
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2026,42 +2034,50 @@ arquivo de resposta.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Serializa todos os eventos da compilação em um arquivo binário compactado.
-                     Por padrão, o arquivo está no diretório atual e é chamado de
-                     "msbuild.binlog". O log binário é uma descrição detalhada
-                     do processo de compilação que pode mais tarde ser usado para reconstruir
-                     logs de texto e usados por outras ferramentas de análise. Um log binário
-                     normalmente é 10 a 20x menor do que os log de nível
-                     de diagnóstico do texto mais detalhado, mas contém mais informações.
-                     (Forma abreviada: -bl)
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
+
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                     O agente binário, por padrão, coleta o texto fonte dos
-                     arquivos de projeto, incluindo todos os projetos importados e arquivos
-                     de destino encontrados durante a compilação. A opção
-                     ProjectImports opcional controla este comportamento:
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
 
-                      ProjectImports=None     - Não coletar as importações
-                                                do projeto.
-                      ProjectImports=Embed    - Inserir as importações do projeto no
-                                                arquivo de log.
-                      ProjectImports=ZipFile  - Salvar os arquivos de projeto em
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
                                                 output.projectimports.zip
-                                                em que a saída tem o mesmo nome que o
-                                                nome do arquivo de log binário.
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     A configuração padrão para ProjectImports é Embed.
-                     Observação: o agente não coleta arquivos de origem não MSBuild
-                     tais como .cs, .cpp etc.
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     Um arquivo .binlog pode ser "reproduzido novamente", passando-o para
-                     msbuild.exe como um argumento em vez de um projeto/solução.
-                     Outros agentes receberão as informações contidas
-                     no arquivo de log como se a compilação original estivesse acontecendo.
-                     Você pode ler mais sobre o log binário e seus usos em:
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
                      https://aka.ms/msbuild/binlog
 
-                     Exemplos:
+                     Examples:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 53e8695e09b..13cd41c8bd0 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1993,6 +1993,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2026,42 +2034,50 @@
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Сериализует все события сборки в сжатый двоичный файл.
-                     По умолчанию файл находится в текущем каталоге и называется
-                     "msbuild.binlog". Двоичный журнал включает подробное описание
-                     процесса сборки, которое затем можно использовать для воссоздания
-                     текстовых журналов. Он также может использоваться другими средствами анализа. Двоичный журнал
-                     обычно в 10–20 раз меньше самого подробного текстового
-                     журнала уровня диагностики, но содержит больше информации.
-                     (Краткая форма: -bl)
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
+
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                     Средство ведения двоичного журнала по умолчанию собирает исходный текст
-                     файлов проекта, включая все импортированные проекты и целевые
-                     файлы, найденные во время сборки. Дополнительный
-                     параметр ProjectImports управляет этим поведением:
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
 
-                      ProjectImports=None     — не собирать импортированные файлы
-                                                проекта.
-                      ProjectImports=Embed    — внедрять импортированные файлы проекта в
-                                                файл журнала.
-                      ProjectImports=ZipFile  — сохранять файлы проекта в
-                                                вывод.projectimports.zip,
-                                                где вывод — это то же имя,
-                                                что и у двоичного файла журнала.
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
+                                                output.projectimports.zip
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     Значение по умолчанию для ProjectImports — Embed.
-                     Примечание. Средство ведения журнала не собирает исходные файлы, не от MSBuild,
-                     например с расширениями CS, CPP и др.
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     BINLOG-файл можно "воспроизвести", передав его в
-                     msbuild.exe в качестве аргумента вместо проекта или решения.
-                     Другие средства ведения журнала получат содержащиеся
-                     в файле журнала сведения, как если бы происходила собственно сборка.
-                     Дополнительные сведения о двоичных журналах и их использовании:
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
                      https://aka.ms/msbuild/binlog
 
-                     Примеры:
+                     Examples:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index f01b080e37d..a52796290f5 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1996,6 +1996,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2029,42 +2037,50 @@
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Tüm derleme olaylarını sıkıştırılmış bir ikili dosyada seri hale getirir.
-                     Varsayılan olarak, dosya geçerli dizinde bulunur ve "msbuild.binlog"
-                     olarak adlandırılır. Daha sonra metin günlüklerini yeniden
-                     yapılandırmak için kullanılabilen ve diğer analiz araçları tarafından
-                     kullanılan ikili günlüğü, derleme işleminin ayrıntılı bir açıklamasıdır.
-                     İkili günlüğü genellikle, en ayrıntılı metin tanılama düzeyi günlüklerden
-                     10-20 kat küçüktür ancak daha fazla bilgi içerir.
-                     (Kısa biçim: -bl)
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
+
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                     İkili günlükçü varsayılan olarak, derleme sırasında karşılaşılan
-                     tüm içeri aktarılmış projeler ve hedef dosyalar dahil olmak üzere
-                     proje dosyalarının kaynak dosyalarını toplar. İsteğe bağlı
-                     ProjectImports anahtarı bu davranışı denetler:
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
 
-                      ProjectImports=None     - Proje içeri aktarmalarını
-                                                toplama.
-                      ProjectImports=Embed    - Proje içeri aktarmalarını günlük dosyasına
-                                                ekler.
-                      ProjectImports=ZipFile  - Proje dosyalarını
-                                                çıkış.projectimports.zip
-                                                dosyasına kaydeder (burada çıkış, ikili
-                                                günlük dosyası adıyla aynı ada sahiptir).
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
+                                                output.projectimports.zip
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     ProjectImports için varsayılan ayar Embed’dir.
-                     Not: Günlükçü .cs, .cpp vb. MSBuild olmayan kaynak
-                     dosyaları toplamaz.
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     Bir .binlog dosyası msbuild.exe’ye bir proje/çözüm
-                     yerine bağımsız değişken olarak geçirilerek “yeniden oynatılabilir”.
-                     Diğer günlükçüler, günlük dosyasındaki bilgileri özgün
-                     derleme gerçekleşiyormuş gibi alır.
-                     İkili günlük ve kullanımı hakkında daha fazla bilgiyi aşağıdaki adreste bulabilirsiniz:
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
                      https://aka.ms/msbuild/binlog
 
-                     Örnekler:
+                     Examples:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 0968a8a75fb..a525c7adf0d 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1992,6 +1992,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2025,49 +2033,57 @@
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     将所有生成事件序列化为压缩的二进制文件。
-                     默认情况下该文件位于当前目录并且名为 "msbuild.binlog"。
-                     二进制日志是生成过程的详细描述，
-                     以后可将其于重新构建文本日志
-                     并由其他分析工具所使用。
-                     二进制日志通常比大多数详细的文本诊断级日志小 10 到 20 倍，
-                     但它可以包含更多信息。
-                     (缩写: -bl)
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
 
-                     默认情况下，二进制记录器收集项目文件的源文本，
-                     包括生成期间所有导入的
-                     项目和目标文件。可选的
-                     ProjectImports 开关控制此行为:
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                      ProjectImports=None     - 不收集项目
-                                                导入项。
-                     ProjectImports=Embed    - 在日志文件中
-                                                 嵌入项目导入项。
-                    ProjectImports=ZipFile  - 将项目文件保存到
-                                              output.projectimports.zip，
-                                                其中输出的名称
-                                                与二进制日志文件名称相同。
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
 
-                    ProjectImports 的默认设置为 Embed。
-                    注意: 记录器不会收集非 MSBuild 源文件，
-                    例如 .cs、.cpp 等。
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
+                                                output.projectimports.zip
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     可将 .binlog 文件以参数(而不是项目/解决方案)的形式传递给
-                   msbuild.exe 对其进行“播放”。
-                     其他记录器将接收日志文件中的信息，
-                    就像原始的生成正在发生一样。
-                    你可以通过以下网址阅读有关二进制文件及其用法的详细信息:
-                    https://aka.ms/msbuild/binlog
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     示例:
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
+                     https://aka.ms/msbuild/binlog
+
+                     Examples:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
                        -bl:output.binlog;ProjectImports=ZipFile
                        -bl:..\..\custom.binlog
                        -binaryLogger
-</target>
+    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "msbuild"
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index b2b8fb45067..4bec527be35 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1993,6 +1993,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2026,42 +2034,50 @@
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                    將所有建置事件序列化成壓縮的二進位檔案。
-                     根據預設，此檔案存放在目前的目錄下，並會命名為
-                     「msbuild.binlog」。此二進位記錄檔是
-                     建置程序的詳細描述，之後可用於重建文字記錄，
-                     以及供其他分析工具使用。二進位記錄檔
-                     的大小通常會比大部分的詳細文字
-                     診斷層級記錄小 10-20 倍，但包含了更多資訊。
-                     (簡短形式: -bl)
+        <target state="new">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+                     Serializes all build events to a compressed binary file.
+                     By default the file is in the current directory and named
+                     "msbuild.binlog". The binary log is a detailed description
+                     of the build process that can later be used to reconstruct
+                     text logs and used by other analysis tools. A binary log
+                     is usually 10-20x smaller than the most detailed text
+                     diagnostic-level log, but it contains more information.
+                     (Short form: -bl)
+
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
 
-                     根據預設，二進位記錄器會收集專案檔的
-                     原始程式文字，包括在建置期間遇到的
-                     所有匯入專案及目標檔案。選擇性的 ProjectImports 參數
-                     會控制此行為:
+                     The binary logger by default collects the source text of
+                     project files, including all imported projects and target
+                     files encountered during the build. The optional
+                     ProjectImports switch controls this behavior:
 
-                      ProjectImports=None     - 不收集專案
-                                                匯入。
-                      ProjectImports=Embed    - 在記錄檔中內嵌
-                                                專案匯入。
-                      ProjectImports=ZipFile  - 將專案檔儲存到
-                                                output.projectimports.zip，
-                                                其中輸出的名稱與
-                                                二進位記錄檔名稱相同。
+                      ProjectImports=None     - Don't collect the project
+                                                imports.
+                      ProjectImports=Embed    - Embed project imports in the
+                                                log file.
+                      ProjectImports=ZipFile  - Save project files to
+                                                output.projectimports.zip
+                                                where output is the same name
+                                                as the binary log file name.
 
-                     ProjectImports 的預設設定為 Embed。
-                     注意: 記錄器不會收集非 MSBuild 的來源檔案，
-                     例如 .cs、.cpp 等。
+                     The default setting for ProjectImports is Embed.
+                     Note: the logger does not collect non-MSBuild source files
+                     such as .cs, .cpp etc.
 
-                     將 .binlog 檔案傳遞到 msbuild.exe 作為引數而非
-                     專案/解決方案，即可加以「播放」。
-                     其他記錄器會收到記錄檔中包含的資訊，
-                     就如同原始組建發生時的情況。
-                     若要深入閱讀二進位記錄檔及其使用方式，請前往:
+                     A .binlog file can be "played back" by passing it to
+                     msbuild.exe as an argument instead of a project/solution.
+                     Other loggers will receive the information contained
+                     in the log file as if the original build was happening.
+                     You can read more about the binary log and its usages at:
                      https://aka.ms/msbuild/binlog
 
-                     範例:
+                     Examples:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 77637578738..f9006a5b5b2 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -35,6 +35,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Tasks.AssemblyDependency;
 using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
 using ConsoleLogger = Microsoft.Build.Logging.ConsoleLogger;
 using FileLogger = Microsoft.Build.Logging.FileLogger;
@@ -655,6 +656,9 @@ public static ExitType Execute(
         {
             DebuggerLaunchCheck();
 
+            // Resets the build completion event, signaling that a new build process is starting.
+            s_buildComplete.Reset();
+
             // Initialize new build telemetry and record start of this build, if not initialized already
             KnownTelemetry.PartialBuildTelemetry ??= new BuildTelemetry { StartAt = DateTime.UtcNow };
 
@@ -1536,6 +1540,11 @@ internal static bool BuildProject(
                         }
                     }
 
+                    if (Traits.Instance.EnableRarNode)
+                    {
+                        parameters.EnableRarNode = true;
+                    }
+
                     List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
 
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
@@ -3439,6 +3448,21 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches, bool
                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();
                     shutdownReason = node.Run(out nodeException);
                 }
+                else if (nodeModeNumber == 3)
+                {
+                    // The RAR service persists between builds, and will continue to process requests until terminated.
+                    OutOfProcRarNode rarNode = new();
+                    RarNodeShutdownReason rarShutdownReason = rarNode.Run(out nodeException, s_buildCancellationSource.Token);
+
+                    shutdownReason = rarShutdownReason switch
+                    {
+                        RarNodeShutdownReason.Complete => NodeEngineShutdownReason.BuildComplete,
+                        RarNodeShutdownReason.Error => NodeEngineShutdownReason.Error,
+                        RarNodeShutdownReason.AlreadyRunning => NodeEngineShutdownReason.Error,
+                        RarNodeShutdownReason.ConnectionTimedOut => NodeEngineShutdownReason.ConnectionFailed,
+                        _ => throw new ArgumentOutOfRangeException(nameof(rarShutdownReason), $"Unexpected value: {rarShutdownReason}"),
+                    };
+                }
                 else if (nodeModeNumber == 8)
                 {
                     // Since build function has to reuse code from *this* class and OutOfProcServerNode is in different assembly
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 528707c3e22..4540c95d966 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -314,7 +314,7 @@
         <property name="RoslynTargetsPath" value="$([MSBuild]::GetToolsDirectory32())\Roslyn" />
 
         <!-- VC Specific Paths -->
-        <property name="VCTargetsPath" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath)','$(MSBuildExtensionsPath32)\Microsoft\VC\v170\'))" />
+        <property name="VCTargetsPath" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath)','$(MSBuildExtensionsPath32)\Microsoft\VC\v180\'))" />
         <property name="VCTargetsPath14" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath14)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V140\'))" />
         <property name="VCTargetsPath12" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath12)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V120\'))" />
         <property name="VCTargetsPath11" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath11)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V110\'))" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index cd0059bd3db..52cc9fa2af0 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -188,7 +188,7 @@
         <property name="RoslynTargetsPath" value="$([MSBuild]::GetToolsDirectory32())\Roslyn" />
 
         <!-- VC Specific Paths -->
-        <property name="VCTargetsPath" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath)','$(MSBuildExtensionsPath32)\Microsoft\VC\v170\'))" />
+        <property name="VCTargetsPath" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath)','$(MSBuildExtensionsPath32)\Microsoft\VC\v180\'))" />
         <property name="VCTargetsPath14" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath14)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V140\'))" />
         <property name="VCTargetsPath12" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath12)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V120\'))" />
         <property name="VCTargetsPath11" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath11)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V110\'))" />
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index f93696c6aba..b5071af538e 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -17,7 +17,7 @@ internal sealed class BuildEnvironmentHelper
     {
         // Since this class is added as 'link' to shared source in multiple projects,
         // MSBuildConstants.CurrentVisualStudioVersion is not available in all of them.
-        private const string CurrentVisualStudioVersion = "17.0";
+        private const string CurrentVisualStudioVersion = "18.0";
 
         // MSBuildConstants.CurrentToolsVersion
         private const string CurrentToolsVersion = "Current";
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index fe93672dee4..13d4f1bef25 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -91,7 +91,12 @@ internal class Handshake
         protected readonly int fileVersionPrivate;
         private readonly int sessionId;
 
-        protected internal Handshake(HandshakeOptions nodeType)
+        internal Handshake(HandshakeOptions nodeType)
+            : this(nodeType, includeSessionId: true)
+        {
+        }
+
+        protected Handshake(HandshakeOptions nodeType, bool includeSessionId)
         {
             const int handshakeVersion = (int)CommunicationsUtilities.handshakeVersion;
 
@@ -110,8 +115,13 @@ protected internal Handshake(HandshakeOptions nodeType)
             fileVersionMinor = fileVersion.Minor;
             fileVersionBuild = fileVersion.Build;
             fileVersionPrivate = fileVersion.Revision;
-            using Process currentProcess = Process.GetCurrentProcess();
-            sessionId = currentProcess.SessionId;
+
+            // This reaches out to NtQuerySystemInformation. Due to latency, allow skipping for derived handshake if unused.
+            if (includeSessionId)
+            {
+                using Process currentProcess = Process.GetCurrentProcess();
+                sessionId = currentProcess.SessionId;
+            }
         }
 
         // This is used as a key, so it does not need to be human readable.
@@ -149,7 +159,7 @@ internal sealed class ServerNodeHandshake : Handshake
         public override byte? ExpectedVersionInFirstByte => null;
 
         internal ServerNodeHandshake(HandshakeOptions nodeType)
-            : base(nodeType)
+            : base(nodeType, includeSessionId: false)
         {
         }
 
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 4aa800ef2d2..3418ad8b214 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -63,7 +63,7 @@ internal static class MSBuildConstants
         /// <summary>
         /// The most current Visual Studio Version known to this version of MSBuild.
         /// </summary>
-        internal const string CurrentVisualStudioVersion = "17.0";
+        internal const string CurrentVisualStudioVersion = "18.0";
 
         /// <summary>
         /// The most current ToolsVersion known to this version of MSBuild.
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 9d97c12de8d..56f9e88cba2 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -6,7 +6,11 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if !NETFRAMEWORK
 using System.IO;
+#else
+using Microsoft.IO;
+#endif
 using System.Linq;
 using System.Text;
 using System.Text.RegularExpressions;
@@ -2633,13 +2637,13 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent
 
             // Ensure that the prefix match wasn't to a distinct directory, so that
             // x\y\prefix doesn't falsely match x\y\prefixmatch.
-            if (directorySeparatorCharacters.Contains(possibleParent[possibleParent.Length - 1]))
+            if (Array.IndexOf(directorySeparatorCharacters, possibleParent[possibleParent.Length - 1]) >= 0)
             {
                 return true;
             }
             else
             {
-                return directorySeparatorCharacters.Contains(possibleChild[possibleParent.Length]);
+                return Array.IndexOf(directorySeparatorCharacters, possibleChild[possibleParent.Length]) >= 0;
             }
         }
 
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 506ba750ab3..cd6e22d4b6f 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -73,9 +73,10 @@ internal static class FrameworkLocationHelper
         internal static readonly Version visualStudioVersion150 = new Version(15, 0);
         internal static readonly Version visualStudioVersion160 = new Version(16, 0);
         internal static readonly Version visualStudioVersion170 = new Version(17, 0);
+        internal static readonly Version visualStudioVersion180 = new Version(18, 0);
 
         // keep this up-to-date; always point to the latest visual studio version.
-        internal static readonly Version visualStudioVersionLatest = visualStudioVersion170;
+        internal static readonly Version visualStudioVersionLatest = visualStudioVersion180;
 
         private const string dotNetFrameworkRegistryPath = "SOFTWARE\\Microsoft\\.NETFramework";
         private const string dotNetFrameworkSetupRegistryPath = "SOFTWARE\\Microsoft\\NET Framework Setup\\NDP";
@@ -335,6 +336,26 @@ private static DotNetFrameworkSpec[] DotNetFrameworkSpecs() =>
                 dotNetFrameworkVersion48,
                 dotNetFrameworkVersion481,
             ]),
+
+             // VS18
+            new VisualStudioSpec(visualStudioVersion180, "NETFXSDK\\{0}", "v10.0", "InstallationFolder",
+            [
+                dotNetFrameworkVersion11,
+                dotNetFrameworkVersion20,
+                dotNetFrameworkVersion35,
+                dotNetFrameworkVersion40,
+                dotNetFrameworkVersion45,
+                dotNetFrameworkVersion451,
+                dotNetFrameworkVersion452,
+                dotNetFrameworkVersion46,
+                dotNetFrameworkVersion461,
+                dotNetFrameworkVersion462,
+                dotNetFrameworkVersion47,
+                dotNetFrameworkVersion471,
+                dotNetFrameworkVersion472,
+                dotNetFrameworkVersion48,
+                dotNetFrameworkVersion481,
+            ]),
         ]);
 
 #if FEATURE_WIN32_REGISTRY
@@ -392,6 +413,18 @@ private static readonly (Version, Version)[,] s_explicitFallbackRulesForPathToDo
             { (dotNetFrameworkVersion472, visualStudioVersion170), (dotNetFrameworkVersion471, visualStudioVersion170) },
             { (dotNetFrameworkVersion48, visualStudioVersion170), (dotNetFrameworkVersion472, visualStudioVersion170) },
             { (dotNetFrameworkVersion481, visualStudioVersion170), (dotNetFrameworkVersion48, visualStudioVersion170) },
+
+            // VS 18
+            { (dotNetFrameworkVersion451, visualStudioVersion180), (dotNetFrameworkVersion45, visualStudioVersion180) },
+            { (dotNetFrameworkVersion452, visualStudioVersion180), (dotNetFrameworkVersion451, visualStudioVersion180) },
+            { (dotNetFrameworkVersion46, visualStudioVersion180), (dotNetFrameworkVersion451, visualStudioVersion180) },
+            { (dotNetFrameworkVersion461, visualStudioVersion180), (dotNetFrameworkVersion46, visualStudioVersion180) },
+            { (dotNetFrameworkVersion462, visualStudioVersion180), (dotNetFrameworkVersion461, visualStudioVersion180) },
+            { (dotNetFrameworkVersion47, visualStudioVersion180), (dotNetFrameworkVersion462, visualStudioVersion180) },
+            { (dotNetFrameworkVersion471, visualStudioVersion180), (dotNetFrameworkVersion47, visualStudioVersion180) },
+            { (dotNetFrameworkVersion472, visualStudioVersion180), (dotNetFrameworkVersion471, visualStudioVersion180) },
+            { (dotNetFrameworkVersion48, visualStudioVersion180), (dotNetFrameworkVersion472, visualStudioVersion180) },
+            { (dotNetFrameworkVersion481, visualStudioVersion180), (dotNetFrameworkVersion48, visualStudioVersion180) },
         };
 #endif // FEATURE_WIN32_REGISTRY
 
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index 42b6a8d6ab6..b72e32efb4c 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -200,6 +200,16 @@ internal enum NodePacketType : byte
         /// </summary>
         ProcessReport,
 
+        /// <summary>
+        /// A request contains the inputs to the RAR task.
+        /// </summary>
+        RarNodeExecuteRequest,
+
+        /// <summary>
+        /// A request contains the outputs and log events of a completed RAR task.
+        /// </summary>
+        RarNodeExecuteResponse,
+
         /// <summary>
         /// Command in form of MSBuild command line for server node - MSBuild Server.
         /// Keep this enum value constant intact as this is part of contract with dotnet CLI
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index 25094e59035..0b85b05bacd 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.IO;
+using Microsoft.Build.Internal;
 
 namespace Microsoft.Build.Shared
 {
@@ -42,5 +43,11 @@ internal static string GetPlatformSpecificPipeName(string pipeName)
                 return pipeName;
             }
         }
+
+        internal static string GetRarNodePipeName(ServerNodeHandshake handshake)
+            => GetPlatformSpecificPipeName($"MSBuildRarNode-{handshake.ComputeHash()}");
+
+        internal static string GetRarNodeEndpointPipeName(ServerNodeHandshake handshake)
+            => GetPlatformSpecificPipeName($"MSBuildRarNodeEndpoint-{handshake.ComputeHash()}");
     }
 }
diff --git a/src/Shared/NodePipeBase.cs b/src/Shared/NodePipeBase.cs
index fd1d08efe9c..2ee91e536c1 100644
--- a/src/Shared/NodePipeBase.cs
+++ b/src/Shared/NodePipeBase.cs
@@ -69,6 +69,14 @@ protected NodePipeBase(string pipeName, Handshake handshake)
             _writeTranslator = BinaryTranslator.GetWriteTranslator(_writeBuffer);
         }
 
+        /// <summary>
+        /// Gets a value indicating whether the pipe is in the connected state. Note that this is not real-time and
+        /// will only be updated when an operation on the pipe fails.
+        /// When a pipe is broken, Disconnect() must be called for the pipe to be reused - otherwise any attempts to
+        /// connect to a new client will throw.
+        /// </summary>
+        internal bool IsConnected => NodeStream.IsConnected;
+
         protected abstract PipeStream NodeStream { get; }
 
         protected string PipeName { get; }
diff --git a/src/Shared/NodePipeServer.cs b/src/Shared/NodePipeServer.cs
index eb932d973aa..0b9855f2a1c 100644
--- a/src/Shared/NodePipeServer.cs
+++ b/src/Shared/NodePipeServer.cs
@@ -47,7 +47,14 @@ internal NodePipeServer(string pipeName, Handshake handshake, int maxNumberOfSer
             // SIDs or the client will reject this server.  This is used to avoid attacks where a
             // hacked server creates a less restricted pipe in an attempt to lure us into using it and
             // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
-            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, PipeAccessRights.ReadWrite, AccessControlType.Allow);
+            PipeAccessRights pipeAccessRights = PipeAccessRights.ReadWrite;
+            if (maxNumberOfServerInstances > 1)
+            {
+                // Multi-instance pipes will fail without this flag.
+                pipeAccessRights |= PipeAccessRights.CreateNewInstance;
+            }
+
+            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, pipeAccessRights, AccessControlType.Allow);
             PipeSecurity security = new();
             security.AddAccessRule(rule);
             security.SetOwner(rule.IdentityReference);
diff --git a/src/Tasks.UnitTests/OutputPathTests.cs b/src/Tasks.UnitTests/OutputPathTests.cs
index 1bf85cccef8..b1b897c20dc 100644
--- a/src/Tasks.UnitTests/OutputPathTests.cs
+++ b/src/Tasks.UnitTests/OutputPathTests.cs
@@ -43,19 +43,21 @@ public void BothBaseOutputPathAndOutputPathWereNotSpecified()
             var baseOutputPath = "bin";
 
             var projectFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath,
-$@"<Project DefaultTargets=`Build` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>
+            $"""
+            <Project DefaultTargets="Build" xmlns="msbuildnamespace" ToolsVersion="msbuilddefaulttoolsversion">
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.props`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.props"/>
 
-    <PropertyGroup>
-        <Platform>AnyCPU</Platform>
-        <Configuration>Debug</Configuration>
-    </PropertyGroup>
+                <PropertyGroup>
+                    <Platform>AnyCPU</Platform>
+                    <Configuration>Debug</Configuration>
+                </PropertyGroup>
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.targets`/>
-    <Target Name=`Build`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.targets"/>
+                <Target Name="Build"/>
 
-</Project>");
+            </Project>
+            """);
 
             // Act
             Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectFilePath, touchProject: false);
@@ -78,20 +80,22 @@ public void BaseOutputPathWasSpecifiedAndIsOverridable()
             var baseOutputPath = Path.Combine("build", "bin");
 
             var projectFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath,
-$@"<Project DefaultTargets=`Build` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>
+            $"""
+            <Project DefaultTargets="Build" xmlns="msbuildnamespace" ToolsVersion="msbuilddefaulttoolsversion">
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.props`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.props"/>
 
-    <PropertyGroup>
-        <Platform>AnyCPU</Platform>
-        <Configuration>Debug</Configuration>
-        <BaseOutputPath>{baseOutputPath}</BaseOutputPath>
-    </PropertyGroup>
+                <PropertyGroup>
+                    <Platform>AnyCPU</Platform>
+                    <Configuration>Debug</Configuration>
+                    <BaseOutputPath>{baseOutputPath}</BaseOutputPath>
+                </PropertyGroup>
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.targets`/>
-    <Target Name=`Build`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.targets"/>
+                <Target Name="Build"/>
 
-</Project>");
+            </Project>
+            """);
 
             // Act
             Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectFilePath, touchProject: false);
@@ -116,25 +120,27 @@ public void BothBaseOutputPathAndOutputPathWereSpecified()
             var outputPathAlt = Path.Combine("bin", "Release");
 
             var projectFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath,
-$@"<Project DefaultTargets=`Build` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>
+            $"""
+            <Project DefaultTargets="Build" xmlns="msbuildnamespace" ToolsVersion="msbuilddefaulttoolsversion">
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.props`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.props"/>
 
-    <PropertyGroup>
-        <Platform>AnyCPU</Platform>
-        <Configuration>Debug</Configuration>
-    </PropertyGroup>
+                <PropertyGroup>
+                    <Platform>AnyCPU</Platform>
+                    <Configuration>Debug</Configuration>
+                </PropertyGroup>
 
-    <PropertyGroup>
-        <BaseOutputPath>{baseOutputPath}</BaseOutputPath>
-        <OutputPath Condition=`'$(Platform)|$(Configuration)' == 'AnyCPU|Debug'`>{outputPath}</OutputPath>
-        <OutputPath Condition=`'$(Platform)|$(Configuration)' == 'AnyCPU|Release'`>{outputPathAlt}</OutputPath>
-    </PropertyGroup>
+                <PropertyGroup>
+                    <BaseOutputPath>{baseOutputPath}</BaseOutputPath>
+                    <OutputPath Condition="'$(Platform)|$(Configuration)' == 'AnyCPU|Debug'">{outputPath}</OutputPath>
+                    <OutputPath Condition="'$(Platform)|$(Configuration)' == 'AnyCPU|Release'">{outputPathAlt}</OutputPath>
+                </PropertyGroup>
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.targets`/>
-    <Target Name=`Build`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.targets"/>
+                <Target Name="Build"/>
 
-</Project>");
+            </Project>
+            """);
 
             // Act
             Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectFilePath, touchProject: false);
@@ -159,18 +165,20 @@ public void MSBuildNormalizePathShouldReturnProjectDirectory()
             var baseOutputPath = "bin";
 
             var projectFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath,
-$@"<Project DefaultTargets=`Build` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>
+            $"""
+            <Project DefaultTargets="Build" xmlns="msbuildnamespace" ToolsVersion="msbuilddefaulttoolsversion">
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.props`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.props"/>
 
-    <PropertyGroup Condition=`'$(OutputPath)' == ''`>
-        <OutputPath>$([MSBuild]::NormalizeDirectory('{baseOutputPath}', '{configuration}'))</OutputPath>
-    </PropertyGroup>
+                <PropertyGroup Condition="'$(OutputPath)' == ''">
+                    <OutputPath>$([MSBuild]::NormalizeDirectory('{baseOutputPath}', '{configuration}'))</OutputPath>
+                </PropertyGroup>
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.targets`/>
-    <Target Name=`Build`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.targets"/>
+                <Target Name="Build"/>
 
-</Project>");
+            </Project>
+            """);
 
             // Act
             Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectFilePath, touchProject: false);
diff --git a/src/Tasks/AssemblyDependency/Node/OutOfProcRarClient.cs b/src/Tasks/AssemblyDependency/Node/OutOfProcRarClient.cs
new file mode 100644
index 00000000000..4cfd2f053ee
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/OutOfProcRarClient.cs
@@ -0,0 +1,70 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Implements a client for sending the ResolveAssemblyReference task to an out-of-proc node.
+    /// This is intended to be reused for all RAR tasks across a single build.
+    /// </summary>
+    internal sealed class OutOfProcRarClient : IDisposable
+    {
+        private readonly NodePipeClient _pipeClient;
+
+        private OutOfProcRarClient()
+        {
+            ServerNodeHandshake handshake = new(HandshakeOptions.None);
+            _pipeClient = new NodePipeClient(NamedPipeUtil.GetRarNodeEndpointPipeName(handshake), handshake);
+
+            NodePacketFactory packetFactory = new();
+            packetFactory.RegisterPacketHandler(NodePacketType.RarNodeExecuteResponse, RarNodeExecuteResponse.FactoryForDeserialization, null);
+            _pipeClient.RegisterPacketFactory(packetFactory);
+        }
+
+        public void Dispose() => _pipeClient.Dispose();
+
+        internal static OutOfProcRarClient GetInstance(IBuildEngine10 buildEngine)
+        {
+            // Create a single cached instance for this build.
+            const string OutOfProcRarClientKey = "OutOfProcRarClient";
+
+            // We want to reuse the pipe client across all RAR invocations within a build, but release the connection once
+            // the MSBuild node is idle. Using RegisteredTaskObjectLifetime.Build ensures that the RAR client is disposed between
+            // builds, freeing the server to run other requests.
+            OutOfProcRarClient rarClient = (OutOfProcRarClient)buildEngine.GetRegisteredTaskObject(OutOfProcRarClientKey, RegisteredTaskObjectLifetime.Build);
+
+            if (rarClient == null)
+            {
+                rarClient = new OutOfProcRarClient();
+                buildEngine.RegisterTaskObject(OutOfProcRarClientKey, rarClient, RegisteredTaskObjectLifetime.Build, allowEarlyCollection: false);
+                CommunicationsUtilities.Trace("Initialized new RAR client.");
+            }
+
+            return rarClient;
+        }
+
+        internal bool Execute(ResolveAssemblyReference rarTask)
+        {
+            // This should only be true at the start of a build.
+            if (!_pipeClient.IsConnected)
+            {
+                // Don't set a timeout since the build manager already blocks until the server is running.
+                _pipeClient.ConnectToServer(0);
+            }
+
+            // TODO: Use RAR task to create the request packet.
+            _pipeClient.WritePacket(new RarNodeExecuteRequest());
+
+            // TODO: Use response packet to set RAR task outputs.
+            _ = (RarNodeExecuteResponse)_pipeClient.ReadPacket();
+
+            return true;
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs
new file mode 100644
index 00000000000..12d03329609
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs
@@ -0,0 +1,179 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Implements a persistent node for the ResolveAssemblyReferences task.
+    /// This manages the lifecycle of the multi-instance pipe server which executes RAR requests
+    /// and does not invoke the task itself.
+    /// </summary>
+    public sealed class OutOfProcRarNode
+    {
+        private readonly ServerNodeHandshake _handshake = new(HandshakeOptions.None);
+
+        private readonly int _maxNumberOfConcurrentTasks;
+
+        public OutOfProcRarNode()
+            : this(Environment.ProcessorCount)
+        {
+        }
+
+        public OutOfProcRarNode(int maxNumberOfConcurrentTasks) => _maxNumberOfConcurrentTasks = maxNumberOfConcurrentTasks;
+
+        /// <summary>
+        /// Starts the node and begins processing RAR execution requests until cancelled.
+        /// </summary>
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
+        /// <param name="cancellationToken">A cancellation token to observe while running the node loop.</param>
+        /// <returns>The reason for the node shutdown.</returns>
+        public RarNodeShutdownReason Run(out Exception? shutdownException, CancellationToken cancellationToken = default)
+        {
+            RarNodeShutdownReason shutdownReason;
+            shutdownException = null;
+
+            try
+            {
+                shutdownReason = RunNodeAsync(cancellationToken).GetAwaiter().GetResult();
+            }
+            catch (OperationCanceledException)
+            {
+                // Consider cancellation as an intentional shutdown of the node.
+                shutdownReason = RarNodeShutdownReason.Complete;
+            }
+            catch (UnauthorizedAccessException ex)
+            {
+                // Access to the path is denied if the named pipe already exists or is owned by a different user.
+                shutdownException = new InvalidOperationException("RAR node is already running.", ex);
+                shutdownReason = RarNodeShutdownReason.AlreadyRunning;
+            }
+            catch (Exception ex)
+            {
+                shutdownException = ex;
+                shutdownReason = RarNodeShutdownReason.Error;
+            }
+
+            if (shutdownException == null)
+            {
+                CommunicationsUtilities.Trace("Shutting down with reason: {0}");
+            }
+            else
+            {
+                CommunicationsUtilities.Trace("Shutting down with reason: {0}, and exception: {1}", shutdownReason, shutdownException);
+            }
+
+            return shutdownReason;
+        }
+
+        private async Task<RarNodeShutdownReason> RunNodeAsync(CancellationToken cancellationToken)
+        {
+            // The RAR node uses two sets of pipe servers:
+            // 1. A single instance pipe to manage the lifecycle of the node.
+            // 2. A multi-instance pipe to execute concurrent RAR requests.
+            // Because multi-instance pipes can live across multiple processes, we can't rely on the instance cap to preven
+            // multiple nodes from running in the event of a race condition.
+            // This also simplifies tearing down all active pipe servers when shutdown is requested.
+            using NodePipeServer pipeServer = new(NamedPipeUtil.GetRarNodePipeName(_handshake), _handshake);
+
+            NodePacketFactory packetFactory = new();
+            packetFactory.RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, null);
+            pipeServer.RegisterPacketFactory(packetFactory);
+
+            using CancellationTokenSource linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
+
+            Task nodeEndpointTasks = Task.Run(() => RunNodeEndpointsAsync(linkedCts.Token), linkedCts.Token);
+
+            // Run any static initializers which will add latency to the first task run.
+            _ = new ResolveAssemblyReference();
+
+            while (!cancellationToken.IsCancellationRequested)
+            {
+                LinkStatus linkStatus = await WaitForConnection(pipeServer, cancellationToken);
+
+                if (linkStatus == LinkStatus.Active)
+                {
+                    NodeBuildComplete buildComplete = (NodeBuildComplete)pipeServer.ReadPacket();
+
+                    if (!buildComplete.PrepareForReuse)
+                    {
+                        break;
+                    }
+                }
+
+                pipeServer.Disconnect();
+            }
+
+            // Gracefully shutdown the node endpoints.
+            linkedCts.Cancel();
+
+            try
+            {
+                await nodeEndpointTasks;
+            }
+            catch (OperationCanceledException)
+            {
+                // Ignore since cancellation is expected.
+            }
+
+            return RarNodeShutdownReason.Complete;
+
+            // WaitForConnection does not currently accept cancellation, so use Wait to watch for cancellation.
+            // Cancellation is only expected when MSBuild is gracefully shutting down the node or running in unit tests.
+            static async Task<LinkStatus> WaitForConnection(NodePipeServer pipeServer, CancellationToken cancellationToken)
+            {
+                Task<LinkStatus> linkStatusTask = Task.Run(pipeServer.WaitForConnection);
+                linkStatusTask.Wait(cancellationToken);
+                return await linkStatusTask;
+            }
+        }
+
+        private async Task RunNodeEndpointsAsync(CancellationToken cancellationToken)
+        {
+            // Setup data shared between all endpoints.
+            string pipeName = NamedPipeUtil.GetRarNodeEndpointPipeName(_handshake);
+            NodePacketFactory packetFactory = new();
+            packetFactory.RegisterPacketHandler(NodePacketType.RarNodeExecuteRequest, RarNodeExecuteRequest.FactoryForDeserialization, null);
+
+            OutOfProcRarNodeEndpoint[] endpoints = new OutOfProcRarNodeEndpoint[_maxNumberOfConcurrentTasks];
+
+            // Validate all endpoint pipe handles successfully initialize before running any read loops.
+            // This allows us to bail out in the event where we can't control every pipe instance.
+            for (int i = 0; i < endpoints.Length; i++)
+            {
+                endpoints[i] = new OutOfProcRarNodeEndpoint(
+                        endpointId: i + 1,
+                        pipeName,
+                        _handshake,
+                        _maxNumberOfConcurrentTasks,
+                        packetFactory);
+            }
+
+            Task[] endpointTasks = new Task[endpoints.Length];
+
+            for (int i = 0; i < endpoints.Length; i++)
+            {
+                // Avoid capturing the indexer in the closure.
+                OutOfProcRarNodeEndpoint endpoint = endpoints[i];
+                endpointTasks[i] = Task.Run(() => endpoint.RunAsync(cancellationToken), cancellationToken);
+            }
+
+            CommunicationsUtilities.Trace("{0} RAR endpoints started.", _maxNumberOfConcurrentTasks);
+
+            await Task.WhenAll(endpointTasks);
+
+            foreach (OutOfProcRarNodeEndpoint endpoint in endpoints)
+            {
+                endpoint.Dispose();
+            }
+
+            CommunicationsUtilities.Trace("All endpoints successfully stopped. Exiting.");
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs
new file mode 100644
index 00000000000..666ce49b5c5
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs
@@ -0,0 +1,97 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Implements a single instance of a pipe server which executes the ResolveAssemblyReference task.
+    /// </summary>
+    internal sealed class OutOfProcRarNodeEndpoint : IDisposable
+    {
+        private readonly int _endpointId;
+
+        private readonly NodePipeServer _pipeServer;
+
+        internal OutOfProcRarNodeEndpoint(
+            int endpointId,
+            string pipeName,
+            ServerNodeHandshake handshake,
+            int maxNumberOfServerInstances,
+            NodePacketFactory packetFactory)
+        {
+            _endpointId = endpointId;
+            _pipeServer = new NodePipeServer(pipeName, handshake, maxNumberOfServerInstances);
+            _pipeServer.RegisterPacketFactory(packetFactory);
+        }
+
+        public void Dispose() => _pipeServer.Dispose();
+
+        internal async Task RunAsync(CancellationToken cancellationToken = default)
+        {
+            CommunicationsUtilities.Trace("({0}) Starting RAR endpoint.", _endpointId);
+
+            try
+            {
+                await RunInternalAsync(cancellationToken);
+            }
+            catch (OperationCanceledException)
+            {
+                // Swallow cancellation excpetions for now. We're using this as a simple way to gracefully shutdown the
+                // endpoint, instead of having to implement separate Start / Stop methods and deferring to the caller.
+                // Can reevaluate if we need more granular control over cancellation vs shutdown.
+                CommunicationsUtilities.Trace("({0}) RAR endpoint stopped due to cancellation.", _endpointId);
+            }
+        }
+
+        private async Task RunInternalAsync(CancellationToken cancellationToken)
+        {
+            while (!cancellationToken.IsCancellationRequested)
+            {
+                while (!_pipeServer.IsConnected)
+                {
+                    _ = _pipeServer.WaitForConnection();
+                }
+
+                CommunicationsUtilities.Trace("({0}) Received RAR request.", _endpointId);
+
+                try
+                {
+                    INodePacket packet = await _pipeServer.ReadPacketAsync(cancellationToken);
+
+                    if (packet.Type == NodePacketType.NodeShutdown)
+                    {
+                        // Although the client has already disconnected, it is still necessary to Diconnect() so the
+                        // pipe can transition into PipeState.Disonnected, which is treated as an intentional pipe break.
+                        // Otherwise, all future operations on the pipe will throw an exception.
+                        CommunicationsUtilities.Trace("({0}) RAR client disconnected.", _endpointId);
+                        _pipeServer.Disconnect();
+                        continue;
+                    }
+
+                    RarNodeExecuteRequest request = (RarNodeExecuteRequest)packet;
+
+                    // TODO: Use request packet to set inputs on the RAR task.
+                    ResolveAssemblyReference rarTask = new();
+
+                    // TODO: bool success = rarTask.ExecuteInProcess();
+                    // TODO: Use RAR task outputs to create response packet.
+                    await _pipeServer.WritePacketAsync(new RarNodeExecuteResponse(), cancellationToken);
+
+                    CommunicationsUtilities.Trace("({0}) Completed RAR request.", _endpointId);
+                }
+                catch (Exception e) when (e is not OperationCanceledException)
+                {
+                    CommunicationsUtilities.Trace("({0}) Exception while executing RAR request: {1}", _endpointId, e);
+                }
+            }
+
+            _pipeServer.Disconnect();
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/RarNodeExecuteRequest.cs b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteRequest.cs
new file mode 100644
index 00000000000..a129bd56748
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteRequest.cs
@@ -0,0 +1,23 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    internal sealed class RarNodeExecuteRequest : INodePacket
+    {
+        public NodePacketType Type => NodePacketType.RarNodeExecuteRequest;
+
+        public void Translate(ITranslator translator)
+        {
+        }
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            RarNodeExecuteRequest request = new();
+            request.Translate(translator);
+            return request;
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/RarNodeExecuteResponse.cs b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteResponse.cs
new file mode 100644
index 00000000000..9611897fc82
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteResponse.cs
@@ -0,0 +1,23 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    internal sealed class RarNodeExecuteResponse : INodePacket
+    {
+        public NodePacketType Type => NodePacketType.RarNodeExecuteResponse;
+
+        public void Translate(ITranslator translator)
+        {
+        }
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            RarNodeExecuteResponse response = new();
+            response.Translate(translator);
+            return response;
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/RarNodeShutdownReason.cs b/src/Tasks/AssemblyDependency/Node/RarNodeShutdownReason.cs
new file mode 100644
index 00000000000..67b37177e4a
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/RarNodeShutdownReason.cs
@@ -0,0 +1,31 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Reasons why the RAR node shutdown.
+    /// </summary>
+    public enum RarNodeShutdownReason
+    {
+        /// <summary>
+        /// The RAR node was instructed to terminate and gracefully shut down.
+        /// </summary>
+        Complete,
+
+        /// <summary>
+        /// The RAR node is already running.
+        /// </summary>
+        AlreadyRunning,
+
+        /// <summary>
+        /// The RAR node timed out waiting for a connection.
+        /// </summary>
+        ConnectionTimedOut,
+
+        /// <summary>
+        /// The RAR node encountered an unrecoverable error.
+        /// </summary>
+        Error,
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 8a42269ce14..21c3811e476 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -16,6 +16,7 @@
 
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyDependency;
@@ -920,6 +921,11 @@ public string[] FullFrameworkFolders
 
         public bool FailIfNotIncremental { get; set; }
 
+        /// <summary>
+        /// Allow the task to run on the out-of-proc node if enabled for this build.
+        /// </summary>
+        public bool AllowOutOfProcNode { get; set; }
+
         /// <summary>
         /// This is a list of all primary references resolved to full paths.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
@@ -3243,6 +3249,25 @@ private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, SystemPr
         /// <returns>True if there was success.</returns>
         public override bool Execute()
         {
+            if (AllowOutOfProcNode
+                && BuildEngine is IBuildEngine10 buildEngine10
+                && buildEngine10.EngineServices.IsOutOfProcRarNodeEnabled)
+            {
+                try
+                {
+#pragma warning disable CA2000 // The OutOfProcRarClient is disposable but its disposal is handled by RegisterTaskObject.
+                    _ = OutOfProcRarClient.GetInstance(buildEngine10).Execute(this);
+#pragma warning restore CA2000 // Dispose objects before losing scope
+                    CommunicationsUtilities.Trace("RAR out-of-proc test connection completed. Executing task in-proc.");
+                }
+                catch (Exception ex)
+                {
+                    // If the out-of-proc connection failed, fall back to in-proc.
+                    // TODO: Disable out-of-proc for the remainder of the build if any connection fails.
+                    CommunicationsUtilities.Trace("RAR out-of-proc connection failed, failing back to in-proc. Exception: {0}", ex);
+                }
+            }
+
             return Execute(
                 p => FileUtilities.FileExistsNoThrow(p),
                 p => FileUtilities.DirectoryExistsNoThrow(p),
@@ -3265,7 +3290,6 @@ public override bool Execute()
                     => AssemblyInformation.IsWinMDFile(fullPath, getAssemblyRuntimeVersion, fileExists, out imageRuntimeVersion, out isManagedWinmd),
                 p => ReferenceTable.ReadMachineTypeFromPEHeader(p));
         }
-
         #endregion
     }
 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index a518f22fe8b..48d3df90c79 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -34,6 +34,20 @@
     <!-- Binary serialization by ITranslatable -->
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
+
+    <!-- Node communication -->
+    <Compile Include="..\Shared\CommunicationsUtilities.cs" />
+    <Compile Include="..\Shared\INodeEndpoint.cs" />
+    <Compile Include="..\Shared\INodePacket.cs" />
+    <Compile Include="..\Shared\INodePacketFactory.cs" />
+    <Compile Include="..\Shared\INodePacketHandler.cs" />
+    <Compile Include="..\Shared\NodeBuildComplete.cs" />
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
+    <Compile Include="..\Shared\NodePacketFactory.cs" />
+    <Compile Include="..\Shared\NodePipeBase.cs" />
+    <Compile Include="..\Shared\NodePipeClient.cs" />
+    <Compile Include="..\Shared\NodePipeServer.cs" />
+    <Compile Include="..\Shared\NodeShutdown.cs" />
   </ItemGroup>
   <ItemGroup>
     <!-- Source Files -->
@@ -183,6 +197,12 @@
     <Compile Include="AssemblyDependency\UnificationVersion.cs" />
     <Compile Include="AssemblyDependency\UnifiedAssemblyName.cs" />
     <Compile Include="AssemblyDependency\WarnOrErrorOnTargetArchitectureMismatchBehavior.cs" />
+    <Compile Include="AssemblyDependency\Node\OutOfProcRarClient.cs" />
+    <Compile Include="AssemblyDependency\Node\OutOfProcRarNode.cs" />
+    <Compile Include="AssemblyDependency\Node\OutOfProcRarNodeEndpoint.cs" />
+    <Compile Include="AssemblyDependency\Node\RarNodeExecuteRequest.cs" />
+    <Compile Include="AssemblyDependency\Node\RarNodeExecuteResponse.cs" />
+    <Compile Include="AssemblyDependency\Node\RarNodeShutdownReason.cs" />
     <Compile Include="AssemblyFolder.cs" />
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="AssemblyRemapping.cs" />
@@ -676,6 +696,7 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="Microsoft.Win32.Registry" />
     <PackageReference Include="System.Reflection.Metadata" />
+    <PackageReference Include="System.Threading.Channels" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 0c4ce55ad13..b0ffa3fa5b6 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -2385,6 +2385,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <ResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>
     </PropertyGroup>
 
+    <PropertyGroup>
+      <AllowResolveAssemblyReferencesOutOfProcNode Condition="'$(AllowResolveAssemblyReferencesOutOfProcNode)' == ''">false</AllowResolveAssemblyReferencesOutOfProcNode>
+    </PropertyGroup>
+
     <!-- Make an App.Config item that exists when AutoUnify is false. -->
     <ItemGroup>
       <_ResolveAssemblyReferencesApplicationConfigFileForExes Include="@(AppConfigWithTargetPath)" Condition="'$(AutoGenerateBindingRedirects)'=='true' or '$(AutoUnifyAssemblyReferences)'=='false'"/>
@@ -2476,6 +2480,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         OutputUnresolvedAssemblyConflicts="$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)"
         NonCultureResourceDirectories="@(NonCultureResourceDirectory)"
         EnableCustomCulture="$(EnableCustomCulture)"
+        AllowOutOfProcNode="$(AllowResolveAssemblyReferencesOutOfProcNode)"
         Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!='' or '@(_ExplicitReference)' != ''"
         >
 
@@ -2580,24 +2585,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <AppConfig Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
     </PropertyGroup>
 
-    <PropertyGroup>
-      <ConfigFileExists Condition="Exists('@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')')">true</ConfigFileExists>
-      <HasNoBindingRedirects Condition="'@(SuggestedBindingRedirects)' == ''">true</HasNoBindingRedirects>
-    </PropertyGroup>
-
-    <!-- Overwrites .config file with a App.config content if RAR returned empty @(SuggestedBindingRedirects). -->
-    <Copy
-      SourceFiles="@(AppConfigWithTargetPath->'%(FullPath)')"
-      DestinationFiles="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-      SkipUnchangedFiles="true"
-      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'">
-      <Output TaskParameter="CopiedFiles" ItemName="FileWrites"/>
-    </Copy>
-    <Touch
-      Files="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-      AlwaysCreate="true"
-      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'"/>
-
     <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
       <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
       <AppConfigWithTargetPath Include="$(AppConfig)">
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index f2fbe04a6b2..f9eb9441801 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -6,6 +6,11 @@
 using System.Linq;
 using System.Text;
 using System.Text.RegularExpressions;
+
+#if NETFRAMEWORK
+using Microsoft.IO;
+#endif
+
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.XamlTypes;
 using Microsoft.Build.Shared;
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 25ae27e63d0..59385e6446b 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -168,6 +168,11 @@ public enum VisualStudioVersion
         /// </summary>
         Version170,
 
+        /// <summary>
+        /// Dev18
+        /// </summary>
+        Version180,
+
         // keep this up-to-date; always point to the last entry.
         /// <summary>
         /// The latest version available at the time of release
@@ -2067,6 +2072,7 @@ private static Version VisualStudioVersionToSystemVersion(VisualStudioVersion ve
                 VisualStudioVersion.Version150 => FrameworkLocationHelper.visualStudioVersion150,
                 VisualStudioVersion.Version160 => FrameworkLocationHelper.visualStudioVersion160,
                 VisualStudioVersion.Version170 => FrameworkLocationHelper.visualStudioVersion170,
+                VisualStudioVersion.Version180 => FrameworkLocationHelper.visualStudioVersion180,
                 _ => Unsupported()
             };
 
@@ -3583,7 +3589,7 @@ public static string GetPathToBuildToolsFile(string fileName, string toolsVersio
             {
                 toolPath = Path.Combine(toolPath, fileName);
 
-                // Rollback see https://developercommunity.visualstudio.com/t/Unable-to-locate-MSBuild-path-with-Lates/10824132 
+                // Rollback see https://developercommunity.visualstudio.com/t/Unable-to-locate-MSBuild-path-with-Lates/10824132
                 if (!File.Exists(toolPath))
                 {
                     toolPath = null;
