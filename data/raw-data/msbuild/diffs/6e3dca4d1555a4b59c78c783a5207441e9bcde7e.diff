diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index f1311c25d5c..a9edfebe54b 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -22,6 +22,7 @@
 using Shouldly;
 using Xunit;
 using Microsoft.Build.Framework;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -883,11 +884,9 @@ public void ItemsEnumerator()
 
 #if FEATURE_SECURITY_PRINCIPAL_WINDOWS
         /// <summary>
-        /// Build a solution file that can't be accessed
+        /// Build a solution file that can't be accessed.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]  // Security classes are not supported on Unix
-
+        [WindowsOnlyFact(additionalMessage: "Security classes are not supported on Unix.")]
         public void SolutionCanNotBeOpened()
         {
             Assert.Throws<InvalidProjectFileException>(() =>
@@ -930,11 +929,9 @@ public void SolutionCanNotBeOpened()
         }
 
         /// <summary>
-        /// Build a project file that can't be accessed
+        /// Build a project file that can't be accessed.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        // FileSecurity class is not supported on Unix
+        [WindowsOnlyFact(additionalMessage: "FileSecurity class is not supported on Unix.")]
         public void ProjectCanNotBeOpened()
         {
             Assert.Throws<InvalidProjectFileException>(() =>
@@ -1005,8 +1002,7 @@ public void SolutionCorrupt()
         /// <summary>
         /// Open lots of projects concurrently to try to trigger problems
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]  // This test is platform specific for Windows
+        [WindowsOnlyFact]
         public void ConcurrentProjectOpenAndCloseThroughProject()
         {
             int iterations = 500;
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 293cdb4ff05..406ad017571 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -16,6 +16,7 @@
 using Shouldly;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -703,8 +704,7 @@ public void ExcludeAndIncludeConsideredAsLiteralsWhenFilespecIsIllegal(string pr
             TestIncludeExclude(projectContents, inputFiles, expectedInclude, includeString, excludeString, normalizeSlashes: true);
         }
 
-        [Theory]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyTheory]
         [InlineData(ItemWithIncludeAndExclude,
             @"src/**/*.cs",
             new[]
@@ -793,8 +793,7 @@ public void ProjectGetterResultsInDriveEnumerationException(string unevaluatedIn
         /// Project getter that renames an item to a drive enumerating wildcard that results in a logged warning.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(@"z:\**\*.log")]
         [InlineData(@"z:$(empty)\**\*.log")]
         [InlineData(@"z:\**")]
@@ -807,8 +806,7 @@ public void ProjectGetterResultsInWindowsDriveEnumerationWarning(string unevalua
         }
 
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(@"/**/*.log")]
         [InlineData(@"$(empty)/**/*.log")]
         [InlineData(@"/$(empty)**/*.log")]
@@ -878,8 +876,7 @@ public void ThrowExceptionUponProjectInstanceCreationFromDriveEnumeratingContent
         /// Project instance created from a file that contains a drive enumerating wildcard results in a logged warning on the Windows platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(
             ImportProjectElement,
             @"z:\**\*.targets",
@@ -903,8 +900,7 @@ public void LogWindowsWarningUponProjectInstanceCreationFromDriveEnumeratingCont
         }
 
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(
             ImportProjectElement,
             @"\**\*.targets",
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index 3e8f8a63a0e..96bee6d7db8 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -17,6 +17,7 @@
 using Xunit;
 using Shouldly;
 using System.Linq;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -908,8 +909,7 @@ public void ThrowExceptionUponBuildingProjectWithDriveEnumeration(string content
         /// Log warning for drive enumerating wildcards that exist in projects on Windows platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(
             TargetItemWithIncludeAndExclude,
             @"z:$(Microsoft_WindowsAzure_EngSys)\**\*",
@@ -950,8 +950,7 @@ public void LogWindowsWarningUponBuildingProjectWithDriveEnumeration(string cont
         /// Log warning for drive enumerating wildcards that exist in projects on Unix platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(
             TargetWithDefinedPropertyAndItemWithInclude,
             @"$(Microsoft_WindowsAzure_EngSys)**",
@@ -981,8 +980,7 @@ public void LogUnixWarningUponBuildingProjectWithDriveEnumeration(string content
         /// <summary>
         /// Tests target item evaluation resulting in no build failures.
         /// </summary>
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(
             TargetWithDefinedPropertyAndItemWithInclude,
             @"$(Microsoft_WindowsAzure_EngSys)*.cs",
diff --git a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
index 9ba42506c30..2090f4c4807 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Framework;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -136,8 +137,7 @@ public void TestTranslation()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestTranslationRemoteHostObjects()
         {
diff --git a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
index 1394e76a11b..6c0955626c9 100644
--- a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
+++ b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -371,9 +372,8 @@ public void BuildEnvironmentFindsAmd64()
             }
         }
 
-        [Fact]
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void BuildEnvironmentFindsAmd64RunningInAmd64NoVS()
         {
             using (var env = new EmptyStandaloneEnviroment(MSBuildExeName, writeFakeFiles: true, includeAmd64Folder: true))
@@ -389,9 +389,8 @@ public void BuildEnvironmentFindsAmd64RunningInAmd64NoVS()
             }
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentFindsAmd64NoVS()
         {
             using (var env = new EmptyStandaloneEnviroment(MSBuildExeName, writeFakeFiles: true, includeAmd64Folder: true))
@@ -438,9 +437,8 @@ public void BuildEnvironmentNoneWhenNotAvailable()
             }
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentVSFromMSBuildAssembly()
         {
             using (var env = new EmptyVSEnviroment())
@@ -457,9 +455,8 @@ public void BuildEnvironmentVSFromMSBuildAssembly()
             }
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentVSFromMSBuildAssemblyAmd64()
         {
             using (var env = new EmptyVSEnviroment())
diff --git a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
index f37d6c7329c..3e2a54d69e7 100644
--- a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
@@ -20,6 +20,7 @@
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 using InternalUtilities = Microsoft.Build.Internal.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -30,7 +31,6 @@ namespace Microsoft.Build.UnitTests.Definition
     /// <summary>
     /// Unit tests for ToolsetReader class and its derived classes
     /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class ToolsetReaderTests : IDisposable
     {
         // The registry key that is passed as the baseKey parameter to the ToolsetRegistryReader class
@@ -92,7 +92,7 @@ private void DeleteTestRegistryKey()
         /// Test to make sure machine.config file has the section registered
         /// and we are picking it up from there.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_SectionNotRegisteredInConfigFile()
         {
             if (!NativeMethodsShared.IsWindows)
@@ -131,7 +131,7 @@ public void GetToolsetDataFromConfiguration_SectionNotRegisteredInConfigFile()
         /// <summary>
         /// Tests that the data is correctly populated using function GetToolsetDataFromConfiguration
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_Basic()
         {
             string v2Folder = NativeMethodsShared.IsWindows
@@ -175,7 +175,7 @@ public void GetToolsetDataFromConfiguration_Basic()
         /// <summary>
         /// Relative paths can be used in a config file value
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void RelativePathInValue()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -216,7 +216,7 @@ public void RelativePathInValue()
         /// <summary>
         /// Invalid relative path in msbuildbinpath value
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InvalidRelativePath()
         {
             if (NativeMethodsShared.IsLinux)
@@ -253,7 +253,7 @@ public void InvalidRelativePath()
         /// <summary>
         /// Tests the case where application configuration file is invalid
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_InvalidXmlFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -272,7 +272,7 @@ public void GetToolsetDataFromConfiguration_InvalidXmlFile()
         /// <summary>
         /// Tests the case where application configuration file is invalid
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_InvalidConfigFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -301,7 +301,7 @@ public void GetToolsetDataFromConfiguration_InvalidConfigFile()
         /// <summary>
         /// Tests the case where application configuration file is empty
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_FileEmpty()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -321,7 +321,7 @@ public void GetToolsetDataFromConfiguration_FileEmpty()
         /// Tests the case when ReadConfiguration throws exception
         /// Make sure that we don't eat it and always throw ConfigurationErrorsException
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_ConfigurationExceptionThrown()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -342,7 +342,7 @@ public void GetToolsetDataFromConfiguration_ConfigurationExceptionThrown()
         /// Tests the case when ReadConfiguration throws exception
         /// Make sure that we don't eat it and always throw ConfigurationErrorsException
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_ConfigurationErrorsExceptionThrown()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -362,7 +362,7 @@ public void GetToolsetDataFromConfiguration_ConfigurationErrorsExceptionThrown()
         /// <summary>
         /// Tests the case where default attribute is not specified in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_DefaultAttributeNotSpecified()
         {
             string v2Folder = NativeMethodsShared.IsWindows
@@ -397,7 +397,7 @@ public void GetToolsetDataFromConfiguration_DefaultAttributeNotSpecified()
         /// <summary>
         /// Default toolset has no toolsVersion element definition
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_DefaultToolsetUndefined()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -427,7 +427,7 @@ public void GetToolsetDataFromConfiguration_DefaultToolsetUndefined()
         /// Tests the case where msbuildToolsets is not specified in the config file
         /// Basically in the code we should be checking if config.GetSection("msbuildToolsets") returns a null
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_MSBuildToolsetsNodeNotPresent()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -451,7 +451,7 @@ public void GetToolsetDataFromConfiguration_MSBuildToolsetsNodeNotPresent()
         /// <summary>
         /// Tests that we handle empty MSBuildToolsets element correctly
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_EmptyMSBuildToolsetsNode()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -476,7 +476,7 @@ public void GetToolsetDataFromConfiguration_EmptyMSBuildToolsetsNode()
         /// <summary>
         /// Tests the case where only default ToolsVersion is specified in the application configuration file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_OnlyDefaultSpecified()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -503,7 +503,7 @@ public void GetToolsetDataFromConfiguration_OnlyDefaultSpecified()
         /// <summary>
         /// Tests the case where only one ToolsVersion data is specified in the application configuration file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_OneToolsVersionNode()
         {
             string v2Folder = NativeMethodsShared.IsWindows
@@ -537,7 +537,7 @@ public void GetToolsetDataFromConfiguration_OneToolsVersionNode()
         /// <summary>
         /// Tests the case when an invalid value of ToolsVersion is specified
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_ToolsVersionIsEmptyString()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -570,7 +570,7 @@ public void GetToolsetDataFromConfiguration_ToolsVersionIsEmptyString()
         /// <summary>
         /// If both MSBuildToolsPath and MSBuildBinPath are present, they must match
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_ToolsPathAndBinPathDiffer()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -600,7 +600,7 @@ public void GetToolsetDataFromConfiguration_ToolsPathAndBinPathDiffer()
         /// <summary>
         /// Tests the case when a blank value of PropertyName is specified in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyNameInConfigFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -634,7 +634,7 @@ public void BlankPropertyNameInConfigFile()
         /// <summary>
         /// Tests the case when a blank property name is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyNameInRegistry()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -661,7 +661,7 @@ public void BlankPropertyNameInRegistry()
         /// Tests the case when a blank property name is specified in the registry in a
         /// sub-toolset.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyNameInRegistrySubToolset()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -694,7 +694,7 @@ public void BlankPropertyNameInRegistrySubToolset()
         /// <summary>
         /// Tests the case when a blank property value is specified in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyValueInConfigFile()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -725,7 +725,7 @@ public void BlankPropertyValueInConfigFile()
         /// <summary>
         /// Tests the case when a blank property value is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyValueInRegistry()
         {
             RegistryKey rk = _toolsVersionsRegistryKey.CreateSubKey("2.0");
@@ -749,7 +749,7 @@ public void BlankPropertyValueInRegistry()
         /// <summary>
         /// Tests the case when a blank property value is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BlankPropertyValueInRegistrySubToolset()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"c:\someBinPath" : "/someBinPath";
@@ -783,7 +783,7 @@ public void BlankPropertyValueInRegistrySubToolset()
         /// <summary>
         /// Tests the case when an invalid value of PropertyName is specified in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InvalidPropertyNameInConfigFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -816,7 +816,7 @@ public void InvalidPropertyNameInConfigFile()
         /// <summary>
         /// Tests the case when an invalid value of PropertyName is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InvalidPropertyNameInRegistry()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -842,7 +842,7 @@ public void InvalidPropertyNameInRegistry()
         /// <summary>
         /// Tests the case when an invalid value of PropertyName is specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InvalidPropertyNameInRegistrySubToolset()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -872,7 +872,7 @@ public void InvalidPropertyNameInRegistrySubToolset()
         /// <summary>
         /// Tests that empty string is an invalid value for MSBuildBinPath
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString1()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -901,7 +901,7 @@ public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString1()
         /// <summary>
         /// Tests that empty string is a valid property value for an arbitrary property
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString2()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -935,7 +935,7 @@ public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString2()
         /// Note that this comes for free with the current implementation using the
         /// framework api to access section in the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetDataFromConfiguration_XmlEscapedCharacters()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -972,7 +972,7 @@ public void GetToolsetDataFromConfiguration_XmlEscapedCharacters()
         /// <summary>
         /// Tests the case where registry and config file contains different toolsVersion
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_NoConflict()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -1031,7 +1031,7 @@ public void GetToolsetData_NoConflict()
         /// <summary>
         /// Tests that ToolsetInitialization are respected.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsetInitializationFlagsSetToNone()
         {
             // Set up registry with two tools versions and one property each
@@ -1085,7 +1085,7 @@ public void ToolsetInitializationFlagsSetToNone()
         /// <summary>
         /// Tests that ToolsetInitialization are respected.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsetInitializationFlagsSetToRegistry()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -1132,7 +1132,7 @@ public void ToolsetInitializationFlagsSetToRegistry()
             Assert.Equal(binPath2, values["4.0"].ToolsPath);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ThrowOnNonStringRegistryValueTypes()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1157,7 +1157,7 @@ public void ThrowOnNonStringRegistryValueTypes()
                                                                ToolsetDefinitionLocations.Registry);
             });
         }
-        [Fact]
+        [WindowsOnlyFact]
         public void PropertiesInRegistryCannotReferToOtherPropertiesInRegistry()
         {
             string binPath = NativeMethodsShared.IsWindows ? "c:\\x" : "/x";
@@ -1186,7 +1186,7 @@ public void PropertiesInRegistryCannotReferToOtherPropertiesInRegistry()
             Assert.Equal(binPath, values["2.0"].ToolsPath);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SubToolsetPropertiesInRegistryCannotReferToOtherPropertiesInRegistry()
         {
             RegistryKey rk = _toolsVersionsRegistryKey.CreateSubKey("2.0");
@@ -1216,7 +1216,7 @@ public void SubToolsetPropertiesInRegistryCannotReferToOtherPropertiesInRegistry
             Assert.Equal("c:\\x", values["2.0"].SubToolsets["dogfood"].Properties["p3"].EvaluatedValue);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SubToolsetsCannotDefineMSBuildToolsPath()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1246,7 +1246,7 @@ public void SubToolsetsCannotDefineMSBuildToolsPath()
         /// <summary>
         /// Tests that ToolsetInitialization are respected.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsetInitializationFlagsSetToConfigurationFile()
         {
             string v2Dir = NativeMethodsShared.IsWindows ? "D:\\windows\\Microsoft.NET\\Framework\\v2.0.x86ret" : "/windows/Microsoft.NET/Framework/v2.0.x86ret";
@@ -1301,7 +1301,7 @@ public void ToolsetInitializationFlagsSetToConfigurationFile()
         /// "TaskLocation" is the name of the value.  The name of the value and the preceding "@" may be omitted if
         /// the default value is desired.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PropertyInConfigurationFileReferencesRegistryLocation()
         {
             if (!NativeMethodsShared.IsWindows)
@@ -1353,7 +1353,7 @@ public void PropertyInConfigurationFileReferencesRegistryLocation()
             Registry.CurrentUser.DeleteSubKeyTree(@"Software\Vendor");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsPathInRegistryHasInvalidPathChars()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1378,7 +1378,7 @@ public void ToolsPathInRegistryHasInvalidPathChars()
         }
 
 #if FEATURE_SYSTEM_CONFIGURATION
-        [Fact]
+        [WindowsOnlyFact]
         public void SamePropertyDefinedMultipleTimesForSingleToolsVersionInConfigurationFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1410,7 +1410,7 @@ public void SamePropertyDefinedMultipleTimesForSingleToolsVersionInConfiguration
             });
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SamePropertyDifferentCaseDefinedMultipleTimesForSingleToolsVersionInConfigurationFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1443,7 +1443,7 @@ public void SamePropertyDifferentCaseDefinedMultipleTimesForSingleToolsVersionIn
         }
 
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SameToolsVersionDefinedMultipleTimesInConfigurationFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1481,7 +1481,7 @@ public void SameToolsVersionDefinedMultipleTimesInConfigurationFile()
             });
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void SameToolsVersionDifferentCaseDefinedMultipleTimesInConfigurationFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1519,7 +1519,7 @@ public void SameToolsVersionDifferentCaseDefinedMultipleTimesInConfigurationFile
             });
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void CannotSetReservedPropertyInConfigFile()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1550,7 +1550,7 @@ public void CannotSetReservedPropertyInConfigFile()
         }
 #endif
 
-        [Fact]
+        [WindowsOnlyFact]
         public void CannotSetReservedPropertyInRegistry()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1574,7 +1574,7 @@ public void CannotSetReservedPropertyInRegistry()
             });
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void CannotSetReservedPropertyInRegistrySubToolset()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -1604,7 +1604,7 @@ public void CannotSetReservedPropertyInRegistrySubToolset()
         /// Properties defined in previously processed toolset definitions should
         /// not affect the evaluation of subsequent toolset definitions.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NoInterferenceBetweenToolsetDefinitions()
         {
             string v20Dir = NativeMethodsShared.IsWindows ? @"D:\20\some\folder\on\disk" : "/20/some/folder/on/disk";
@@ -1659,7 +1659,7 @@ public void NoInterferenceBetweenToolsetDefinitions()
         /// "TaskLocation" is the name of the value.  The name of the value and the preceding "@" may be omitted if
         /// the default value is desired.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression1()
         {
             if (!NativeMethodsShared.IsWindows)
@@ -1671,7 +1671,7 @@ public void ConfigFileInvalidRegistryExpression1()
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression2()
         {
             if (!NativeMethodsShared.IsWindows)
@@ -1683,7 +1683,7 @@ public void ConfigFileInvalidRegistryExpression2()
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:__bogus__)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression3()
         {
             if (!NativeMethodsShared.IsWindows)
@@ -1695,28 +1695,28 @@ public void ConfigFileInvalidRegistryExpression3()
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:@)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression4()
         {
             // Double @
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:HKEY_CURRENT_USER\Software\Vendor\Tools@@TaskLocation)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression5()
         {
             // Trailing @
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:HKEY_CURRENT_USER\Software\Vendor\Tools@TaskLocation@)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression6()
         {
             // Leading @
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:@HKEY_CURRENT_USER\Software\Vendor\Tools@TaskLocation)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileInvalidRegistryExpression7()
         {
             if (!NativeMethodsShared.IsWindows)
@@ -1728,7 +1728,7 @@ public void ConfigFileInvalidRegistryExpression7()
             ConfigFileInvalidRegistryExpressionHelper(@"<property name=""p"" value=""$(Registry:BOGUS_HIVE\Software\Vendor\Tools@TaskLocation)""/>");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileStringEmptyRegistryExpression1()
         {
             // Regular undefined property beginning with "Registry"
@@ -1736,7 +1736,7 @@ public void ConfigFileStringEmptyRegistryExpression1()
                                           String.Empty);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileStringEmptyRegistryExpression2()
         {
             // Nonexistent key
@@ -1744,7 +1744,7 @@ public void ConfigFileStringEmptyRegistryExpression2()
                                           String.Empty);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileNonPropertyRegistryExpression1()
         {
             // Property not terminated with paren, does not look like property
@@ -1752,7 +1752,7 @@ public void ConfigFileNonPropertyRegistryExpression1()
                                           @"$(Registry:HKEY_CURRENT_USER\Software\Vendor\Tools@TaskLocation");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileNonPropertyRegistryExpression2()
         {
             // Missing colon, looks like regular property (but with invalid property name chars, we will return blank as a result)
@@ -1760,7 +1760,7 @@ public void ConfigFileNonPropertyRegistryExpression2()
                                           String.Empty);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void ConfigFileItemExpressionsDoNotExpandInConfigurationProperties()
         {
             // Expect that item expressions such as '@(SomeItem)' are not evaluated in any way, e.g., they are treated literally
@@ -1768,7 +1768,7 @@ public void ConfigFileItemExpressionsDoNotExpandInConfigurationProperties()
                                           @"@(SomeItem)");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void RegistryInvalidRegistryExpression1()
         {
             if (!NativeMethodsShared.IsWindows)
@@ -1780,7 +1780,7 @@ public void RegistryInvalidRegistryExpression1()
             RegistryInvalidRegistryExpressionHelper("$(Registry:__bogus__)");
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void RegistryValidRegistryExpression1()
         {
             // Regular undefined property beginning with "Registry"
@@ -1890,7 +1890,7 @@ private void ConfigFileValidRegistryExpressionHelper(string propertyExpression,
         /// <summary>
         /// Tests the case where application configuration file overrides a value already specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ConflictingPropertyValuesSameCase()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -1935,7 +1935,7 @@ public void GetToolsetData_ConflictingPropertyValuesSameCase()
         /// where that registry value is bogus and would otherwise throw.  However, since the config file also
         /// contains an entry for that toolset, the registry toolset never gets read, and thus never throws.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ConflictingPropertyValuesRegistryThrows()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -1979,7 +1979,7 @@ public void GetToolsetData_ConflictingPropertyValuesRegistryThrows()
         /// well as in the config file for the same tools version.
         /// We should not merge them; we should take the config file ones only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_NoMerging()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somepath" : "/somepath";
@@ -2028,7 +2028,7 @@ public void GetToolsetData_NoMerging()
         /// The absence of the ToolsVersion attribute on the main Project element in a project file means
         /// that the engine's default tools version should be used.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ToolsVersionAttributeNotSpecifiedOnProjectElementAndDefaultVersionSpecifiedInRegistry()
         {
             string oldValue = Environment.GetEnvironmentVariable("MSBUILDLEGACYDEFAULTTOOLSVERSION");
@@ -2070,7 +2070,7 @@ public void ToolsVersionAttributeNotSpecifiedOnProjectElementAndDefaultVersionSp
         /// <summary>
         /// Tests the case when no values are specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_RegistryNotPresent()
         {
             string binPath = NativeMethodsShared.IsWindows ? @"D:\somedifferentpath" : "/somedifferentpath";
@@ -2110,7 +2110,7 @@ public void GetToolsetData_RegistryNotPresent()
         /// Note that config file not present is same as config file
         /// with no MSBuildToolsets Section
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ConfigFileNotPresent()
         {
             // Registry Read
@@ -2138,7 +2138,7 @@ public void GetToolsetData_ConfigFileNotPresent()
         /// <summary>
         /// Tests the case where nothing is specified in registry and config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_RegistryAndConfigNotPresent()
         {
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
@@ -2168,7 +2168,7 @@ public void GetToolsetData_RegistryAndConfigNotPresent()
         /// <summary>
         /// Tests the case when reading config file throws an exception
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ReadConfigThrowsException()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -2198,7 +2198,7 @@ public void GetToolsetData_ReadConfigThrowsException()
         /// <summary>
         /// Tests the case where reading from registry throws exception
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetToolsetData_ReadRegistryOpenSubKeyThrowsException()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -2242,7 +2242,7 @@ public void GetToolsetData_ReadRegistryOpenSubKeyThrowsException()
         /// Tests that the default ToolsVersion is correctly resolved when specified
         /// in registry and config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultToolsetVersion_SpecifiedInRegistryAndConfigFile()
         {
             // Set up registry with two tools versions and one property each
@@ -2287,7 +2287,7 @@ public void SetDefaultToolsetVersion_SpecifiedInRegistryAndConfigFile()
         /// <summary>
         /// Tests that the default ToolsVersion is correctly resolved when specified in registry only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultToolsetVersion_SpecifiedOnlyInRegistry()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -2330,7 +2330,7 @@ public void SetDefaultToolsetVersion_SpecifiedOnlyInRegistry()
         /// <summary>
         /// Tests that the override task path is correctly resolved when specified in registry only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetOverrideTasks_SpecifiedOnlyInRegistry()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -2380,7 +2380,7 @@ public void SetOverrideTasks_SpecifiedOnlyInRegistry()
         /// <summary>
         /// Tests that the override default toolsversion is correctly resolved when specified in registry only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultOverrideToolsVersion_SpecifiedOnlyInRegistry()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -2427,7 +2427,7 @@ public void SetDefaultOverrideToolsVersion_SpecifiedOnlyInRegistry()
         /// Tests that the default ToolsVersion is correctly resolved
         /// when specified in config file only
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultToolsetVersion_SpecifiedOnlyInConfigFile()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -2466,7 +2466,7 @@ public void SetDefaultToolsetVersion_SpecifiedOnlyInConfigFile()
         /// when specified in config file only.
         /// Also, that MSBuildOverrideTasksPath can be overridden.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetOverrideTaskPath_SpecifiedOnlyInConfigFile()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -2507,7 +2507,7 @@ public void SetOverrideTaskPath_SpecifiedOnlyInConfigFile()
         /// Tests that the override default ToolsVersion is correctly resolved
         /// when specified in config file only.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultOverrideToolsVersion_SpecifiedOnlyInConfigFile()
         {
             ToolsetConfigurationReaderTestHelper.WriteConfigFile(@"
@@ -2545,7 +2545,7 @@ public void SetDefaultOverrideToolsVersion_SpecifiedOnlyInConfigFile()
         /// <summary>
         /// Tests that the default ToolsVersion is correctly resolved when specified nowhere
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SetDefaultToolsetVersion_SpecifiedNowhere()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
@@ -2592,7 +2592,7 @@ public void SetDefaultToolsetVersion_SpecifiedNowhere()
         /// <summary>
         /// Tests that properties are properly expanded when reading them from the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PropertiesInToolsetsFromConfigFileAreExpanded()
         {
             // $(COMPUTERNAME) is just a convenient env var. $(NUMBER_OF_PROCESSORS) isn't defined on Longhorn
@@ -2632,7 +2632,7 @@ public void PropertiesInToolsetsFromConfigFileAreExpanded()
         /// <summary>
         /// Tests that properties in MSBuildToolsPath are properly expanded when reading them from the config file
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PropertiesInToolsetsFromConfigFileAreExpandedInToolsPath()
         {
             string binPathConfig = NativeMethodsShared.IsWindows ?
@@ -2686,7 +2686,7 @@ public void PropertiesInToolsetsFromConfigFileAreExpandedInToolsPath()
         /// Global properties are available, but they cannot be overwritten by other toolset properties, just as they cannot
         /// be overwritten by project file properties.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GlobalPropertiesInToolsetsAreExpandedButAreNotOverwritten()
         {
 #if FEATURE_SYSTEM_CONFIGURATION
diff --git a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
index a39a6b336b0..213b448ec14 100644
--- a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
@@ -10,10 +10,10 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Internal;
-using Microsoft.Build.Shared;
 using Microsoft.Win32;
 
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 
@@ -24,7 +24,6 @@ namespace Microsoft.Build.UnitTests.Definition
     /// <summary>
     /// Unit test for ToolsetRegistryReader class
     /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class ToolsetRegistryReader_Tests : IDisposable
     {
         // The registry key that is passed as the baseKey parameter to the ToolsetRegistryReader class
@@ -79,7 +78,7 @@ private void DeleteTestRegistryKey()
         /// <summary>
         /// If the base key has been deleted, then we just don't get any information (no exception)
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_DeletedKey()
         {
             DeleteTestRegistryKey();
@@ -119,7 +118,7 @@ public void DefaultValuesInRegistryCreatedBySetup()
         /// <summary>
         /// Tests we handle no default toolset specified in the registry
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void DefaultValueInRegistryDoesNotExist()
         {
             ToolsetReader reader = new ToolsetRegistryReader(new ProjectCollection().EnvironmentProperties, new PropertyDictionary<ProjectPropertyInstance>(), new MockRegistryKey(testRegistryPath, "3.5" /* fail to find subkey 3.5 */));
@@ -138,7 +137,7 @@ public void DefaultValueInRegistryDoesNotExist()
         /// <summary>
         /// The base key exists but contains no subkey or values: this is okay
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_NoSubkeyNoValues()
         {
             ToolsetReader reader = GetStandardRegistryReader();
@@ -155,7 +154,7 @@ public void ReadRegistry_NoSubkeyNoValues()
         /// Here we validate that MSBuild does not fail when there are unrecognized values underneath
         /// the ToolsVersion key.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_NoSubkeysOnlyValues()
         {
             _toolsVersionsRegistryKey.SetValue("Name1", "Value1");
@@ -174,7 +173,7 @@ public void ReadRegistry_NoSubkeysOnlyValues()
         /// <summary>
         /// Basekey has only 1 subkey
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_OnlyOneSubkey()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -197,7 +196,7 @@ public void ReadRegistry_OnlyOneSubkey()
         /// <summary>
         /// Basic case
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_Basic()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -227,7 +226,7 @@ public void ReadRegistry_Basic()
         /// <summary>
         /// baseKey contains some non-String data
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_NonStringData()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -256,7 +255,7 @@ public void ReadRegistry_NonStringData()
         ///        SubKey2
         ///        SubKey3
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_HasSubToolsets()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -312,7 +311,7 @@ public void ReadRegistry_HasSubToolsets()
         ///        SubKey1
         ///            SubSubKey1
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_IgnoreSubToolsetSubKeys()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -347,7 +346,7 @@ public void ReadRegistry_IgnoreSubToolsetSubKeys()
         /// selected subtoolset, the subtoolset value overrides -- even if that
         /// value is empty.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_SubToolsetOverridesBaseToolsetEntries()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -387,7 +386,7 @@ public void ReadRegistry_SubToolsetOverridesBaseToolsetEntries()
         /// selected subtoolset, the subtoolset value overrides -- even if that
         /// value is empty.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadRegistry_UnselectedSubToolsetIsIgnored()
         {
             string xdir = NativeMethodsShared.IsWindows ? "c:\\xxx" : "/xxx";
@@ -416,7 +415,7 @@ public void ReadRegistry_UnselectedSubToolsetIsIgnored()
         /// <summary>
         /// Regular case of getting default tools version
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultToolsVersionFromRegistry_Basic()
         {
             _currentVersionRegistryKey.SetValue("DefaultToolsVersion", "tv1");
@@ -435,7 +434,7 @@ public void GetDefaultToolsVersionFromRegistry_Basic()
         /// <summary>
         /// Default value is not set
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultToolsVersionFromRegistry_DefaultValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
@@ -450,7 +449,7 @@ public void GetDefaultToolsVersionFromRegistry_DefaultValueNotSet()
         /// <summary>
         /// "DefaultToolsVersion" has non-String data
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultToolsVersionFromRegistry_NonStringData()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -473,7 +472,7 @@ private ToolsetRegistryReader GetStandardRegistryReader()
         /// <summary>
         /// Regular case of getting overridetaskspath
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetOverrideTasksPathFromRegistry_Basic()
         {
             if (NativeMethodsShared.IsUnixLike)
@@ -495,7 +494,7 @@ public void GetOverrideTasksPathFromRegistry_Basic()
         /// <summary>
         /// OverrideTasksPath is not set
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetOverrideTasksPathFromRegistry_ValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
@@ -510,7 +509,7 @@ public void GetOverrideTasksPathFromRegistry_ValueNotSet()
         /// <summary>
         /// "OverrideTasksPath" has non-String data
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetOverrideTasksPathFromRegistry_NonStringData()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -527,7 +526,7 @@ public void GetOverrideTasksPathFromRegistry_NonStringData()
         /// <summary>
         /// Regular case of getting the default override toolsversion
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultOverrideToolsVersionFromRegistry_Basic()
         {
             _currentVersionRegistryKey.SetValue("DefaultOverrideToolsVersion", "Current");
@@ -544,7 +543,7 @@ public void GetDefaultOverrideToolsVersionFromRegistry_Basic()
         /// <summary>
         /// DefaultOverrideToolsVersion is not set
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultOverrideToolsVersionFromRegistry_ValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
@@ -559,7 +558,7 @@ public void GetDefaultOverrideToolsVersionFromRegistry_ValueNotSet()
         /// <summary>
         /// "DefaultOverrideToolsVersion" has non-String data
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetDefaultOverrideToolsVersionFromRegistry_NonStringData()
         {
             Assert.Throws<InvalidToolsetDefinitionException>(() =>
@@ -573,7 +572,7 @@ public void GetDefaultOverrideToolsVersionFromRegistry_NonStringData()
                 reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
             });
         }
-        [Fact]
+        [WindowsOnlyFact]
         public void ReadToolsets_NoBinPathOrToolsPath()
         {
             RegistryKey key1 = _toolsVersionsRegistryKey.CreateSubKey("tv1");
diff --git a/src/Build.UnitTests/Definition/Toolset_Tests.cs b/src/Build.UnitTests/Definition/Toolset_Tests.cs
index aaaade0b2b2..2bf6e660b37 100644
--- a/src/Build.UnitTests/Definition/Toolset_Tests.cs
+++ b/src/Build.UnitTests/Definition/Toolset_Tests.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -173,8 +174,7 @@ public void TestDefaultSubToolset()
             Assert.Equal("v13.0", t.DefaultSubToolsetVersion);
         }
 
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/4363")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/4363")]
         public void TestDefaultSubToolsetFor40()
         {
             Toolset t = ProjectCollection.GlobalProjectCollection.GetToolset("4.0");
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 82aadfa05a2..0834f39395a 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -32,6 +32,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared.FileSystem;
 using Shouldly;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -1710,8 +1711,7 @@ public void RegistryPropertyInvalidPrefixError2()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyString()
         {
@@ -1733,8 +1733,7 @@ public void RegistryPropertyString()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyBinary()
         {
@@ -1759,8 +1758,7 @@ public void RegistryPropertyBinary()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyDWord()
         {
@@ -1782,8 +1780,7 @@ public void RegistryPropertyDWord()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyExpandString()
         {
@@ -1806,8 +1803,7 @@ public void RegistryPropertyExpandString()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyQWord()
         {
@@ -1829,8 +1825,7 @@ public void RegistryPropertyQWord()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void RegistryPropertyMultiString()
         {
@@ -3466,8 +3461,7 @@ public void PropertySimpleSpaced()
             Assert.Equal(String.Empty, result);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegitryValue()
         {
@@ -3491,8 +3485,7 @@ public void PropertyFunctionGetRegitryValue()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegitryValueDefault()
         {
@@ -3516,8 +3509,7 @@ public void PropertyFunctionGetRegitryValueDefault()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegistryValueFromView1()
         {
@@ -3541,8 +3533,7 @@ public void PropertyFunctionGetRegistryValueFromView1()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegistryValueFromView2()
         {
diff --git a/src/Build.UnitTests/FixPathOnUnix_Tests.cs b/src/Build.UnitTests/FixPathOnUnix_Tests.cs
index e74cfd7b14e..f3f635df854 100644
--- a/src/Build.UnitTests/FixPathOnUnix_Tests.cs
+++ b/src/Build.UnitTests/FixPathOnUnix_Tests.cs
@@ -6,15 +6,15 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
 namespace Microsoft.Build.UnitTests
 {
-    [PlatformSpecific(TestPlatforms.AnyUnix)]
     public class FixPathOnUnixTests
     {
-        [Fact]
+        [UnixOnlyFact]
         public void TestPathFixupInMetadata()
         {
             string buildProjectContents = @"
diff --git a/src/Build.UnitTests/Instance/HostServices_Tests.cs b/src/Build.UnitTests/Instance/HostServices_Tests.cs
index 3a9ebdb07c2..cab5c0b40e1 100644
--- a/src/Build.UnitTests/Instance/HostServices_Tests.cs
+++ b/src/Build.UnitTests/Instance/HostServices_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.UnitTests.BackEnd;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -241,8 +242,7 @@ public void TestContradictoryAffinityCausesException_Any()
         /// <summary>
         /// Test which ensures that setting an Any affinity for a project with a remote host object does not throws.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestNoContradictoryRemoteHostObjectAffinity()
         {
@@ -295,8 +295,7 @@ public void TestNonContraditcoryHostObjectAllowed_Any()
         /// <summary>
         /// Test which ensures the remote host object cannot affect a project which has the Any affinity specifically set.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestRegisterRemoteHostObjectNoAffect_Any2()
         {
@@ -334,8 +333,7 @@ public void TestNonContraditcoryHostObjectAllowed_InProc()
         /// <summary>
         /// Test which ensures the affinity for a project can be changed once the in process host object is registered
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestAffinityChangeAfterRegisterInprocessHostObject()
         {
@@ -444,8 +442,7 @@ public void UnloadedProjectDiscardsHostServices()
         /// <summary>
         /// Tests that register overrides existing reigsted remote host object.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [SupportedOSPlatform("windows")]
         public void TestRegisterOverrideExistingRegisted()
         {
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index b29b4238e8e..99d98e9f404 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Shared.FileSystem;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -1338,7 +1339,6 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
             }
         }
 
-        [PlatformSpecific(TestPlatforms.Any)]
         [Theory]
         [InlineData(@"\", "**")]
         [InlineData(@"\\", "**")]
@@ -1350,8 +1350,7 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
         public void DriveEnumeratingWildcardIsObservedOnAnyPlatform(string directoryPart, string wildcardPart) =>
             DriveEnumeratingWildcardIsObserved(directoryPart, wildcardPart);
 
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(@"\", "**")]
         [InlineData(@"c:\", "**")]
         [InlineData(@"c:\\", "**")]
@@ -1366,8 +1365,7 @@ public void DriveEnumeratingWildcardIsObservedOnWindows(string directoryPart, st
         private void DriveEnumeratingWildcardIsObserved(string directoryPart, string wildcardPart) =>
             FileMatcher.IsDriveEnumeratingWildcardPattern(directoryPart, wildcardPart).ShouldBeTrue();
 
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(@"\", "**")]
         [InlineData("/", "**/*.cs")]
         [InlineData("/", "**")]
@@ -1415,8 +1413,7 @@ private void DriveEnumeratingWildcardFailsAndReturns(string directoryPart, strin
         }
 
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(@"z:\**")]
         [InlineData(@"z:\\**")]
         [InlineData(@"z:\\\\\\\\**")]
@@ -1453,7 +1450,6 @@ public void DriveEnumeratingWildcardIsLoggedOnWindows(string driveEnumeratingWil
             }
         }
 
-        [PlatformSpecific(TestPlatforms.Any)]
         [Theory]
         [InlineData(@"\", @"*\*.cs")]
         [InlineData(@"\\", @"*\*.cs")]
@@ -1464,8 +1460,7 @@ public void DriveEnumeratingWildcardIsLoggedOnWindows(string driveEnumeratingWil
         public void DriveEnumeratingWildcardIsNotObservedOnAnyPlatform(string directoryPart, string wildcardPart) =>
             DriveEnumeratingWildcardIsNotObserved(directoryPart, wildcardPart);
 
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(@"c:\", "**")]
         [InlineData(@"c:\\", "**")]
         [InlineData(@"c:\\\\\\\\", "**")]
@@ -1899,8 +1894,7 @@ public void GetFileSpecInfoCommon(
                 expectedIsLegalFileSpec);
         }
 
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         // Escape pecial regex characters valid in Windows paths
         [InlineData(
             @"$()+.[^{\?$()+.[^{\$()+.[^{",
@@ -1938,8 +1932,7 @@ public void GetFileSpecInfoWindows(
                 expectedIsLegalFileSpec);
         }
 
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         // Escape regex characters valid in Unix paths
         [InlineData(
             @"$()+.[^{|\?$()+.[^{|\$()+.[^{|",
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index 199b46c85f1..bfe11f27c1e 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -417,8 +418,7 @@ public void CheckDerivableItemSpecModifiers()
             Assert.False(FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier("recursivedir"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void NormalizePathThatFitsIntoMaxPath()
         {
             string currentDirectory = @"c:\aardvark\aardvark\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890";
@@ -445,8 +445,7 @@ public void NormalizePathThatDoesntFitIntoMaxPath()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetItemSpecModifierRootDirThatFitsIntoMaxPath()
         {
             string currentDirectory = @"c:\aardvark\aardvark\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890\1234567890";
@@ -507,15 +506,13 @@ public void NormalizePathBadUNC3()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void NormalizePathGoodUNC()
         {
             Assert.Equal(@"\\localhost\share", FileUtilities.NormalizePath(@"\\localhost\share"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void NormalizePathTooLongWithDots()
         {
             string longPart = new string('x', 300);
@@ -523,8 +520,7 @@ public void NormalizePathTooLongWithDots()
         }
 
 #if FEATURE_LEGACY_GETFULLPATH
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/4205")]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/4205")]
         public void NormalizePathBadGlobalroot()
         {
             Assert.Throws<ArgumentException>(() =>
@@ -555,8 +551,7 @@ public void NormalizePathInvalid()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void CannotNormalizePathWithNewLineAndSpace()
         {
             string filePath = "\r\n      C:\\work\\sdk3\\artifacts\\tmp\\Debug\\SimpleNamesWi---6143883E\\NETFrameworkLibrary\\bin\\Debug\\net462\\NETFrameworkLibrary.dll\r\n      ";
@@ -910,8 +905,7 @@ public void GenerateTempBatchFileWithBadDirectory()
             });
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void AbsolutePathLooksLikeUnixPathOnUnix()
         {
             var secondSlash = SystemSpecificAbsolutePath.Substring(1).IndexOf(Path.DirectorySeparatorChar) + 1;
@@ -921,8 +915,7 @@ public void AbsolutePathLooksLikeUnixPathOnUnix()
             Assert.True(FileUtilities.LooksLikeUnixFilePath(rootLevelPath));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void PathDoesNotLookLikeUnixPathOnWindows()
         {
             Assert.False(FileUtilities.LooksLikeUnixFilePath(SystemSpecificAbsolutePath));
@@ -930,8 +923,7 @@ public void PathDoesNotLookLikeUnixPathOnWindows()
             Assert.False(FileUtilities.LooksLikeUnixFilePath("/root"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void RelativePathLooksLikeUnixPathOnUnixWithBaseDirectory()
         {
             string filePath = ObjectModelHelpers.CreateFileInTempProjectDirectory("first/second/file.txt", String.Empty);
@@ -961,8 +953,7 @@ public void RelativePathLooksLikeUnixPathOnUnixWithBaseDirectory()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void RelativePathMaybeAdjustFilePathWithBaseDirectory()
         {
             // <tmp_dir>/first/second/file.txt
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 750c73b673e..f664d50091e 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -18,6 +18,7 @@
 using Xunit.Abstractions;
 using Shouldly;
 using Microsoft.Build.UnitTests.Shared;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -1303,8 +1304,7 @@ public void Regress200872()
         /// <summary>
         /// Do the most basic AssemblyFoldersEx resolve.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExBasic()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1324,8 +1324,7 @@ public void AssemblyFoldersExBasic()
         /// <summary>
         /// Verify that higher alphabetical values for a component are chosen over lower alphabetic values of a component.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExVerifyComponentFolderSorting()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1346,8 +1345,7 @@ public void AssemblyFoldersExVerifyComponentFolderSorting()
         /// If the target framework version provided by the targets file doesn't begin
         /// with the letter "v", we should tolerate it and treat it as if it does.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExTargetFrameworkVersionDoesNotBeginWithV()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1371,8 +1369,7 @@ public void AssemblyFoldersExTargetFrameworkVersionDoesNotBeginWithV()
         /// Expect it not to resolve and get a message on the console
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchDoesNotMatch()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1397,8 +1394,7 @@ public void AssemblyFoldersExProcessorArchDoesNotMatch()
         /// Target MSIL and get an assembly out of the X86 directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchMSILX86()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1420,8 +1416,7 @@ public void AssemblyFoldersExProcessorArchMSILX86()
         /// <summary>
         /// Verify if there is a mismatch between what the project targets and the architecture of the resolved primary reference log a warning.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-windows-failing")]
         public void VerifyProcessArchitectureMismatchWarning()
         {
@@ -1446,8 +1441,7 @@ public void VerifyProcessArchitectureMismatchWarning()
         /// <summary>
         /// Verify if there is a mismatch between what the project targets and the architecture of the resolved primary reference log a warning.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-windows-failing")]
         public void VerifyProcessArchitectureMismatchWarningDefault()
         {
@@ -1471,8 +1465,7 @@ public void VerifyProcessArchitectureMismatchWarningDefault()
         /// <summary>
         /// Verify if there is a mismatch between what the project targets and the architecture of the resolved primary reference log a error.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-windows-failing")]
         public void VerifyProcessArchitectureMismatchError()
         {
@@ -1500,8 +1493,7 @@ public void VerifyProcessArchitectureMismatchError()
         /// Target None and get an assembly out of the X86 directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneX86()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1521,8 +1513,7 @@ public void AssemblyFoldersExProcessorArchNoneX86()
         /// If we are targeting NONE and there are two assemblies with the same name then we want to pick the first one rather than look for an assembly which
         /// has a MSIL architecture or a NONE architecture. NONE means you do not care what architecture is picked.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneMix()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1550,8 +1541,7 @@ public void AssemblyFoldersExProcessorArchNoneMix()
         /// Target MSIL and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchMSILLastFolder()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1576,8 +1566,7 @@ public void AssemblyFoldersExProcessorArchMSILLastFolder()
         /// Target None and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneLastFolder()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1601,8 +1590,7 @@ public void AssemblyFoldersExProcessorArchNoneLastFolder()
         /// Target MSIL and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchX86FirstFolder()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1625,8 +1613,7 @@ public void AssemblyFoldersExProcessorArchX86FirstFolder()
         /// Target X86 and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchX86MSIL()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1648,8 +1635,7 @@ public void AssemblyFoldersExProcessorArchX86MSIL()
         /// Target X86 and get an assembly out of the None directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchX86None()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1671,8 +1657,7 @@ public void AssemblyFoldersExProcessorArchX86None()
         /// Target None and get an assembly out of the None directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneNone()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1693,8 +1678,7 @@ public void AssemblyFoldersExProcessorArchNoneNone()
         /// Target MSIL and get an assembly out of the None directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArcMSILNone()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1715,8 +1699,7 @@ public void AssemblyFoldersExProcessorArcMSILNone()
         /// Target None and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchNoneMSIL()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1738,8 +1721,7 @@ public void AssemblyFoldersExProcessorArchNoneMSIL()
         /// Target MSIL and get an assembly out of the MSIL directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchMSILMSIL()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1761,8 +1743,7 @@ public void AssemblyFoldersExProcessorArchMSILMSIL()
         /// Target X86 and get an assembly out of the X86 directory.
         ///
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExProcessorArchMatches()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1786,8 +1767,7 @@ public void AssemblyFoldersExProcessorArchMatches()
         /// This means if there are remaining search paths to inspect, we should
         /// carry on and inspect those.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExTargetFrameworkVersionBogusValue()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1808,8 +1788,7 @@ public void AssemblyFoldersExTargetFrameworkVersionBogusValue()
         /// <summary>
         /// Tolerate keys like v2.0.x86chk.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void Regress357227_AssemblyFoldersExAgainstRawDrop()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1829,8 +1808,7 @@ public void Regress357227_AssemblyFoldersExAgainstRawDrop()
         /// <summary>
         /// Matches that exist only in the HKLM hive.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExHKLM()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1849,8 +1827,7 @@ public void AssemblyFoldersExHKLM()
         /// <summary>
         /// Matches that exist in both HKLM and HKCU should favor HKCU
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExHKCUTrumpsHKLM()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -1874,8 +1851,7 @@ public void AssemblyFoldersExHKCUTrumpsHKLM()
         /// <summary>
         /// When matches that have v3.0 (future) and v2.0 (current) versions, the 2.0 version wins.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExFutureTargetNDPVersionsDontMatch()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1894,8 +1870,7 @@ public void AssemblyFoldersExFutureTargetNDPVersionsDontMatch()
         /// <summary>
         /// If there is no v2.0 (current target NDP) match, then v1.0 should match.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExMatchBackVersion()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1914,8 +1889,7 @@ public void AssemblyFoldersExMatchBackVersion()
         /// <summary>
         /// If there is a 2.0 and a 1.0 then match 2.0.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExCurrentTargetVersionTrumpsPastTargetVersion()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1934,8 +1908,7 @@ public void AssemblyFoldersExCurrentTargetVersionTrumpsPastTargetVersion()
         /// <summary>
         /// If a control has a service pack then that wins over the control itself
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExServicePackTrumpsBaseVersion()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -1955,8 +1928,7 @@ public void AssemblyFoldersExServicePackTrumpsBaseVersion()
         /// Conditions (OSVersion/Platform) can be passed in SearchPaths to filter the result.
         /// Test MaxOSVersion condition
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExConditionFilterMaxOS()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -1999,8 +1971,7 @@ public void AssemblyFoldersExConditionFilterMaxOS()
         /// Conditions (OSVersion/Platform) can be passed in SearchPaths to filter the result.
         /// Test MinOSVersion condition
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExConditionFilterMinOS()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -2313,8 +2284,7 @@ public void GatherVersions35x86chkDotNet()
         /// Conditions (OSVersion/Platform) can be passed in SearchPaths to filter the result.
         /// Test Platform condition
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void AssemblyFoldersExConditionFilterPlatform()
         {
             ResolveAssemblyReference t = new ResolveAssemblyReference();
diff --git a/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
index e845e40d540..cb8146d2403 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
@@ -9,6 +9,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -35,8 +36,7 @@ public SpecificVersionPrimary(ITestOutputHelper output) : base(output)
         ///     dependencies anyway to make things work consistently. This would be a significant
         ///     perf hit when loading large solutions.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void Exists()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 49a635d1385..498e4eb5772 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -19,6 +19,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -1177,8 +1178,7 @@ public void CopyFileOnItself()
         /// Copying a file on top of itself should be a success (no-op) whether
         /// or not skipUnchangedFiles is true or false. Variation with different casing/relativeness.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "File names under Unix are case-sensitive and this test is not useful"
+        [WindowsOnlyFact(additionalMessage: "File names under Unix are case-sensitive and this test is not useful.")]
         public void CopyFileOnItself2()
         {
             string currdir = Directory.GetCurrentDirectory();
@@ -2189,8 +2189,7 @@ public void CopyToDestinationFolderWithHardLinkCheck()
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // SMB share paths only work on Windows
+        [WindowsOnlyFact(additionalMessage: "SMB share paths only work on Windows.")]
         public void CopyToDestinationFolderWithHardLinkFallbackNetwork()
         {
             // Workaround: For some reason when this test runs with all other tests we are getting
@@ -2295,8 +2294,7 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // Only Windows has a (small) link limit, and this tests for an HRESULT
+        [WindowsOnlyFact(additionalMessage: "Only Windows has a (small) link limit, and this tests for an HRESULT.")]
         public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
         {
             // Workaround: For some reason when this test runs with all other tests we are getting
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index 44ac891a76d..c9edcec199b 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -13,6 +13,7 @@
 using Xunit;
 using Xunit.Abstractions;
 using Shouldly;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -313,8 +314,7 @@ public void WildcardDriveEnumerationTaskItemLogsError(string itemSpec)
         /// Logs warning when encountering wildcard drive enumeration during task item creation on Windows platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(@"z:\**")]
         [InlineData(@"z:\**\*.log")]
         [InlineData(@"z:\\\\**\*.log")]
@@ -327,8 +327,7 @@ public void LogWindowsWarningUponCreateItemExecution(string itemSpec)
         /// Logs warning when encountering wildcard drive enumeration during task item creation on Unix platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(@"\**")]
         [InlineData(@"\**\*.log")]
         public void LogUnixWarningUponCreateItemExecution(string itemSpec)
@@ -393,8 +392,7 @@ public void ThrowExceptionUponItemCreationWithDriveEnumeration(string content, s
         /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Windows platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData(
             CreateItemWithInclude,
             @"z:\**")]
@@ -421,8 +419,7 @@ public void LogWindowsWarningUponItemCreationWithDriveEnumeration(string content
         /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Unix platform.
         /// </summary>
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
-        [Theory]
+        [UnixOnlyTheory]
         [InlineData(
             CreateItemWithInclude,
             @"\**")]
diff --git a/src/Tasks.UnitTests/Delete_Tests.cs b/src/Tasks.UnitTests/Delete_Tests.cs
index b752d309728..d404c63246f 100644
--- a/src/Tasks.UnitTests/Delete_Tests.cs
+++ b/src/Tasks.UnitTests/Delete_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -41,8 +42,7 @@ public void AttributeForwarding()
         /// <summary>
         /// Retry Delete. Specify windows since readonly not working on others
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void DeleteWithRetries()
         {
             string source = FileUtilities.GetTemporaryFile();
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 5c78ff468a7..889d83c2cd5 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -15,6 +15,7 @@
 using Xunit.Abstractions;
 using System.Collections.Generic;
 using Microsoft.Build.Evaluation;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -168,8 +169,7 @@ public void TimeoutFailsEvenWhenExitCodeIsIgnored()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void WindowsNewLineCharactersInCommandOnUnix()
         {
             var exec = PrepareExec("echo hello\r\n\r\n");
@@ -246,8 +246,7 @@ public void NonUNCWorkingDirectoryUsed()
             ((MockEngine)exec.BuildEngine).AssertLogContains("[" + working + "]");
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]   // UNC is Windows-Only
+        [WindowsOnlyFact(additionalMessage: "UNC is Windows-Only.")]
         public void UNCWorkingDirectoryUsed()
         {
             Exec exec = PrepareExec("echo [%cd%]");
@@ -475,10 +474,9 @@ public void ExecTaskUtf8AlwaysWithAnsi()
         /// Exec task will NOT use UTF8 when UTF8 Never is specified and non-ANSI characters are in the Command
         /// <remarks>Exec task will fail as the cmd processor will not be able to run the command.</remarks>
         /// </summary>
-        [Theory]
+        [WindowsOnlyTheory]
         [InlineData("Never")]
         [InlineData("System")]
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void ExecTaskUtf8NeverWithNonAnsi(string useUtf8)
         {
             RunExec(true, EncodingUtilities.CurrentSystemOemEncoding.EncodingName, useUtf8, false);
@@ -903,8 +901,7 @@ public void ConsoleToMSBuild()
         /// Test the CanEncode method with and without ANSI characters to determine if they can be encoded 
         /// in the current system encoding.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void CanEncodeTest()
         {
             var defaultEncoding = EncodingUtilities.CurrentSystemOemEncoding;
diff --git a/src/Tasks.UnitTests/FormatUrl_Tests.cs b/src/Tasks.UnitTests/FormatUrl_Tests.cs
index de622591d23..5260d22e642 100644
--- a/src/Tasks.UnitTests/FormatUrl_Tests.cs
+++ b/src/Tasks.UnitTests/FormatUrl_Tests.cs
@@ -7,6 +7,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -66,8 +67,7 @@ public void NoInputTest()
         /// From the documentation, Path.GetFullPath(" ") should throw an ArgumentException, but it doesn't on macOS and Linux
         /// where whitespace characters are valid characters for filenames.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void WhitespaceTestOnUnix()
         {
             var t = new FormatUrl();
@@ -81,8 +81,7 @@ public void WhitespaceTestOnUnix()
         /// <summary>
         /// The URL to format is white space.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void WhitespaceTestOnWindows()
         {
             var t = new FormatUrl();
@@ -139,8 +138,7 @@ public void LocalRelativePathTest()
         /// <summary>
         /// The URL to format is a *nix-style (macOS, Linux) local absolute file path.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void LocalUnixAbsolutePathTest()
         {
             var t = new FormatUrl();
@@ -154,8 +152,7 @@ public void LocalUnixAbsolutePathTest()
         /// <summary>
         /// The URL to format is a Windows-style local absolute file path.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void LocalWindowsAbsolutePathTest()
         {
             var t = new FormatUrl();
diff --git a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
index 0763674cfd8..f4c311c11ce 100644
--- a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
+++ b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Shared;
 using Xunit;
 using Microsoft.Build.Tasks;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -148,8 +149,7 @@ private static string MakeFakeSDKStructure2()
 
     /// <summary>
     /// Test the GetInstalledSDKLocations task
-    /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
+    /// </summary>W
     public class GetInstalledSDKLocationsTestFixture : IClassFixture<FakeSDKStructure>
     {
         private readonly string _fakeSDKStructureRoot;
@@ -165,7 +165,7 @@ public GetInstalledSDKLocationsTestFixture(FakeSDKStructure fakeSDKStructure)
         /// <summary>
         /// Make sure we get a ArgumentException if null is passed into the target platform version.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NullTargetPlatformVersion()
         {
             Assert.Throws<ArgumentNullException>(() =>
@@ -179,7 +179,7 @@ public void NullTargetPlatformVersion()
         /// <summary>
         /// Make sure we get a ArgumentException if null is passed into the target platform version.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NullTargetPlatformIdentifier()
         {
             Assert.Throws<ArgumentNullException>(() =>
@@ -193,7 +193,7 @@ public void NullTargetPlatformIdentifier()
         /// <summary>
         /// Make sure we get an error message if an empty platform identifier is passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptyTargetPlatformIdentifier()
         {
             MockEngine engine = new MockEngine();
@@ -211,7 +211,7 @@ public void EmptyTargetPlatformIdentifier()
         /// <summary>
         /// Make sure we get an error message if an empty platform Version is passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptyTargetPlatformVersion()
         {
             MockEngine engine = new MockEngine();
@@ -230,7 +230,7 @@ public void EmptyTargetPlatformVersion()
         /// <summary>
         /// Make sure we get an error message if an empty platform Version is passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void BadTargetPlatformVersion()
         {
             MockEngine engine = new MockEngine();
@@ -249,7 +249,7 @@ public void BadTargetPlatformVersion()
         /// <summary>
         /// Make sure we get an Warning if no SDKs were found.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NoSDKsFound()
         {
             MockEngine engine = new MockEngine();
@@ -267,7 +267,7 @@ public void NoSDKsFound()
         /// <summary>
         /// Get a good set of SDKS installed on the machine from the fake SDK location.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetSDKVersions()
         {
             try
@@ -314,7 +314,7 @@ public void GetSDKVersions()
         /// <summary>
         /// Get a good set of SDKS installed on the machine from the fake SDK location.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetGoodSDKs()
         {
             try
@@ -388,7 +388,7 @@ public void GetGoodSDKs()
         /// <summary>
         /// Get a good set of SDKS installed on the machine from the fake SDK location.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetGoodSDKs2()
         {
             try
diff --git a/src/Tasks.UnitTests/GetSDKReference_Tests.cs b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
index cd5316b3e03..9c3a318b72e 100644
--- a/src/Tasks.UnitTests/GetSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
@@ -14,6 +13,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -180,7 +180,6 @@ private static string CreateFakeSDKReferenceAssemblyDirectory2(out string sdkDir
     /// <summary>
     /// Test the expansion of sdk reference assemblies.
     /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class GetSDKReferenceFilesTestFixture : IDisposable, IClassFixture<FakeSdkStructure>
     {
         private readonly ITestOutputHelper _output;
@@ -223,7 +222,7 @@ public void Dispose()
         /// <summary>
         /// Make sure there are no outputs if no resolved sdk files are passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PassReferenceWithNoReferenceDirectory()
         {
             var engine = new MockEngine(_output);
@@ -253,7 +252,7 @@ public void PassReferenceWithNoReferenceDirectory()
         /// <summary>
         /// Make sure we get the correct folder list when asking for it.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void GetSDKReferenceFolders()
         {
@@ -263,7 +262,7 @@ public void GetSDKReferenceFolders()
             VerifySDKFolders(getReferenceFolders, getReferenceFolders2, "References", _sdkDirectory);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyGetSdkReferenceTranslator()
         {
             Dictionary<string, GetSDKReferenceFiles.SdkReferenceInfo> pathToReferenceMetadata = new();
@@ -321,7 +320,7 @@ private static void VerifySDKFolders(GetSDKFolders singleParamDelegate, GetSDKFo
         /// <summary>
         /// Make sure we get the correct folder list when asking for it.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void GetSDKRedistFolders()
         {
@@ -334,7 +333,7 @@ public void GetSDKRedistFolders()
         /// <summary>
         /// Make sure we get the correct folder list when asking for it.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void GetSDKDesignTimeFolders()
         {
@@ -347,7 +346,7 @@ public void GetSDKDesignTimeFolders()
         /// <summary>
         /// Make sure there are no outputs if an sdk which does not exist is passed in.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PassNoSDKReferences()
         {
             var engine = new MockEngine(_output);
@@ -365,7 +364,7 @@ public void PassNoSDKReferences()
         /// <summary>
         /// Make sure there are no outputs if expand sdks is not true.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PassReferenceWithExpandFalse()
         {
             var engine = new MockEngine(_output);
@@ -390,7 +389,7 @@ public void PassReferenceWithExpandFalse()
         /// <summary>
         /// Make sure there are no redist outputs if CopyRedist is false
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void PassReferenceWithCopyRedistFalse()
         {
             var engine = new MockEngine(_output);
@@ -416,7 +415,7 @@ public void PassReferenceWithCopyRedistFalse()
         /// <summary>
         /// Verify we get the correct set of reference assemblies and copy local files when the CopyLocal flag is true
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void GetReferenceAssembliesWhenExpandTrueCopyLocalTrue()
         {
@@ -482,7 +481,7 @@ public void GetReferenceAssembliesWhenExpandTrueCopyLocalTrue()
         /// <summary>
         /// Verify reference is not processed by GetSDKReferenceFiles when "ReferenceOnly" metadata is set.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void VerifyNoCopyWhenReferenceOnlyIsTrue()
         {
@@ -539,7 +538,7 @@ public void VerifyNoCopyWhenReferenceOnlyIsTrue()
         /// <summary>
         /// Verify we get the correct set of reference assemblies and copy local files when the CopyLocal flag is false
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         [Trait("Category", "mono-windows-failing")]
         public void GetReferenceAssembliesWhenExpandTrueCopyLocalFalse()
@@ -596,7 +595,7 @@ public void GetReferenceAssembliesWhenExpandTrueCopyLocalFalse()
         /// Verify that different cache files are created and used correctly for assemblies with the same identity but with files in different directories
         /// Also verifies that when
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyCacheFileNames()
         {
             var engine = new MockEngine(_output);
@@ -662,7 +661,7 @@ public void VerifyCacheFileNames()
         /// Verify the correct reference files are found and that by default we do log the reference files
         /// added.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void VerifyReferencesLogged()
         {
@@ -711,7 +710,7 @@ public void VerifyReferencesLogged()
         /// Verify the correct reference files are found and that by default we do log the reference files
         /// added.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void VerifyReferencesLoggedFilterOutWinmd()
         {
@@ -757,7 +756,7 @@ public void VerifyReferencesLoggedFilterOutWinmd()
         /// <summary>
         /// Verify we log an error if no configuration is on the sdk reference
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void LogErrorWhenNoConfiguration()
         {
@@ -781,7 +780,7 @@ public void LogErrorWhenNoConfiguration()
         /// <summary>
         /// Verify we log an error if no configuration is on the sdk reference
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void LogErrorWhenNoArchitecture()
         {
@@ -807,8 +806,7 @@ public void LogErrorWhenNoArchitecture()
         /// Verify the correct reference files are found and that by default we do log the reference files
         /// added.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyReferencesLoggedAmd64()
         {
             var engine = new MockEngine(_output);
@@ -859,7 +857,7 @@ public void VerifyReferencesLoggedAmd64()
         /// Verify the correct reference files are found and that by default we do log the reference files
         /// added.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void VerifyReferencesLoggedX64()
         {
@@ -911,7 +909,7 @@ public void VerifyReferencesLoggedX64()
         /// <summary>
         /// Verify the correct reference files are found and that if we do not want to log them we can set a property to do so.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void VerifyLogReferencesFalse()
         {
@@ -947,7 +945,7 @@ public void VerifyLogReferencesFalse()
         /// Verify the correct redist files are found and that by default we do not log the redist files
         /// added.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void VerifyRedistFilesLogRedistFalse()
         {
@@ -1013,7 +1011,7 @@ public void VerifyRedistFilesLogRedistFalse()
         /// Verify the correct redist files are found and that by default we do not log the redist files
         /// added.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void VerifyRedistFilesLogRedistTrue()
         {
@@ -1045,7 +1043,7 @@ public void VerifyRedistFilesLogRedistTrue()
         /// Verify the correct redist files are found and that by default we do not log the redist files
         /// added.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void VerifyRedistFilesLogRedistTrueX64()
         {
@@ -1078,7 +1076,7 @@ public void VerifyRedistFilesLogRedistTrueX64()
         /// Verify the correct redist files are found and that by default we do not log the redist files
         /// added.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void VerifyRedistFilesLogRedistTrueAmd64()
         {
@@ -1110,7 +1108,7 @@ public void VerifyRedistFilesLogRedistTrueAmd64()
         /// <summary>
         /// Make sure by default conflicts between references are logged as a comment if they are within the sdk itself
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void LogNoWarningForReferenceConflictWithinSDK()
         {
@@ -1139,7 +1137,7 @@ public void LogNoWarningForReferenceConflictWithinSDK()
         /// <summary>
         /// Make sure that if the LogReferenceConflictsWithinSDKAsWarning is set log a warning for conflicts within an SDK for references.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void LogWarningForReferenceConflictWithinSDK()
         {
@@ -1169,7 +1167,7 @@ public void LogWarningForReferenceConflictWithinSDK()
         /// <summary>
         /// Make sure by default conflicts between references are logged as a comment if they are within the sdk itself
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void LogNoWarningForRedistConflictWithinSDK()
         {
@@ -1197,7 +1195,7 @@ public void LogNoWarningForRedistConflictWithinSDK()
         /// <summary>
         /// Make sure that if the LogRedistConflictsWithinSDKAsWarning is set log a warning for conflicts within an SDK for redist files.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void LogWarningForRedistConflictWithinSDK()
         {
@@ -1226,7 +1224,7 @@ public void LogWarningForRedistConflictWithinSDK()
         /// <summary>
         /// Verify if there are conflicts between references or redist files between sdks that we log a warning by default.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void LogReferenceAndRedistConflictBetweenSdks()
         {
@@ -1272,7 +1270,7 @@ public void LogReferenceAndRedistConflictBetweenSdks()
         /// <summary>
         /// If a user create a target path that causes a conflict between two sdks then we want to warn
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void LogReferenceAndRedistConflictBetweenSdksDueToCustomTargetPath()
         {
@@ -1315,7 +1313,7 @@ public void LogReferenceAndRedistConflictBetweenSdksDueToCustomTargetPath()
         /// <summary>
         /// Verify if there are conflicts between references or redist files between sdks that we do not log a warning if a certain property (LogxxxConflictBetweenSDKsAsWarning is set to false.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void LogReferenceAndRedistConflictBetweenSdksNowarning()
         {
@@ -1362,7 +1360,7 @@ public void LogReferenceAndRedistConflictBetweenSdksNowarning()
         /// <summary>
         /// If there are conflicting redist files between two sdks but their target paths are different then we should copy both to the appx
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void TwoSDKSConflictRedistButDifferentTargetPaths()
         {
diff --git a/src/Tasks.UnitTests/HintPathResolver_Tests.cs b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
index eb80da45cf8..a62b711cf18 100644
--- a/src/Tasks.UnitTests/HintPathResolver_Tests.cs
+++ b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
@@ -8,6 +8,7 @@
 using System.Collections.Generic;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -36,8 +37,7 @@ public void CanResolveHintPath()
             result.ShouldBe(true);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void CanResolveLongNonNormalizedHintPath()
         {
             var tempfolder = _env.DefaultTestDirectory.CreateDirectory("tempfolder_for_CanResolveLongHintPath");
diff --git a/src/Tasks.UnitTests/MakeDir_Tests.cs b/src/Tasks.UnitTests/MakeDir_Tests.cs
index b05bd654604..2eb1c473196 100644
--- a/src/Tasks.UnitTests/MakeDir_Tests.cs
+++ b/src/Tasks.UnitTests/MakeDir_Tests.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -59,8 +60,7 @@ public void AttributeForwarding()
         /// Check that if we fail to create a folder, we don't pass
         /// through the input.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "Under Unix all filenames are valid and this test is not useful"
+        [WindowsOnlyFact(additionalMessage: "Under Unix all filenames are valid and this test is not useful.")]
         public void SomeInputsFailToCreate()
         {
             string temp = Path.GetTempPath();
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index d76e34bd350..0132e5a36bf 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -413,8 +414,7 @@ public void MoveOverExistingFileOverwriteReadOnlyOverWriteReadOnlyFilesTrue()
         /// MovedFiles should only include files that were successfully moved 
         /// (or skipped), not files for which there was an error.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "Under Unix all filenames are valid and this test is not useful"
+        [WindowsOnlyFact(additionalMessage: "Under Unix all filenames are valid and this test is not useful.")]
         public void OutputsOnlyIncludeSuccessfulMoves()
         {
             string temp = Path.GetTempPath();
@@ -493,8 +493,7 @@ public void OutputsOnlyIncludeSuccessfulMoves()
         /// <summary>
         /// Moving a locked file will fail
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "File locking Unix differs significantly from Windows"
+        [WindowsOnlyFact(additionalMessage: "File locking Unix differs significantly from Windows.")]
         public void MoveLockedFile()
         {
             string file = null;
@@ -588,8 +587,7 @@ public void SourceFileIsDirectory()
         /// Moving a file on top of itself should be a success (no-op).
         /// Variation with different casing/relativeness.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "File names under Unix are case-sensitive and this test is not useful"
+        [WindowsOnlyFact(additionalMessage: "File names under Unix are case-sensitive and this test is not useful.")]
         public void MoveFileOnItself2()
         {
             string currdir = Directory.GetCurrentDirectory();
diff --git a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
index 8fd537d5c4f..2d5fb861cd8 100644
--- a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
@@ -8,20 +8,17 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
-
-
-
 using SDKReference = Microsoft.Build.Tasks.ResolveSDKReference.SDKReference;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Xunit;
+using Xunit.NetCore.Extensions;
 using Shouldly;
 
 #nullable disable
 
 namespace Microsoft.Build.UnitTests.ResolveSDKReference_Tests
 {
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class ResolveSDKReferenceTestFixture
     {
         private Microsoft.Build.UnitTests.MockEngine.GetStringDelegate _resourceDelegate = new Microsoft.Build.UnitTests.MockEngine.GetStringDelegate(AssemblyResources.GetString);
@@ -35,7 +32,7 @@ public class ResolveSDKReferenceTestFixture
         /// <summary>
         /// Make sure that SDK reference which should be good are parsed correctly.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ParseItemSpecGood()
         {
             TestGoodSDKReferenceIncludes(new TaskItem("Cat, Version=8.0"), "Cat", "8.0");
@@ -51,7 +48,7 @@ public void ParseItemSpecGood()
         /// <summary>
         /// Make sure ones which are incorrect and log the correct error.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ParseItemSpecBadNames()
         {
             // These should all be bad the format must be   <SDKName>, Version=<SDKVersion>.
@@ -72,7 +69,7 @@ public void ParseItemSpecBadNames()
         /// <summary>
         /// Make sure ones which are incorrect and log the correct error.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ParseDependsOnString()
         {
             Assert.Empty(ResolveSDKReference.ParseDependsOnSDK(null));
@@ -93,7 +90,7 @@ public void ParseDependsOnString()
         /// <summary>
         /// Make sure ones which are incorrect and log the correct error.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GetUnResolvedDependentSDKs()
         {
             HashSet<SDKReference> resolvedSDKsEmpty = new HashSet<SDKReference>();
@@ -121,7 +118,7 @@ public void GetUnResolvedDependentSDKs()
             Assert.Equal("\"baz, Version=2.0\"", result[1]);
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyBuildWarningForESDKWithoutMaxPlatformVersionOnBlueOrAbove()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "TestMaxPlatformVersionWithTargetFrameworkVersion");
@@ -312,7 +309,7 @@ public void VerifyBuildWarningForESDKWithoutMaxPlatformVersionOnBlueOrAbove()
         /// <summary>
         /// Verify "RuntimeReferenceOnly" equals to "true" is set for specified references
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyAddMetadataToReferences()
         {
             MockEngine engine = new MockEngine();
@@ -354,7 +351,7 @@ public void VerifyAddMetadataToReferences()
         /// <summary>
         /// Make sure ones which are incorrect and log the correct warning.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyUnResolvedSDKMessage()
         {
             MockEngine engine = new MockEngine();
@@ -429,7 +426,7 @@ public void VerifyUnResolvedSDKMessage()
         /// <summary>
         /// Verify if the DependsOn metadata is set on the reference item and that dependency is not resolved then cause the warning to happen.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyDependencyWarningFromMetadata()
         {
             // Create the engine.
@@ -460,7 +457,7 @@ public void VerifyDependencyWarningFromMetadata()
         /// <summary>
         /// Verify we get the correct dependson warning
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void VerifyDependsOnWarningFromManifest()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "VerifyDependsOnWarningFromManifest");
@@ -527,7 +524,7 @@ public void VerifyDependsOnWarningFromManifest()
         /// <summary>
         /// Make sure the equals works on the SDKReference.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void TestSDkReferenceEquals()
         {
             ITaskItem dummyItem = new TaskItem();
@@ -575,7 +572,7 @@ private static void TestBadSDKReferenceIncludes(ITaskItem referenceInclude)
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:true Target:msil Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit1()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit1");
@@ -630,7 +627,7 @@ public void Prefer32bit1()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:false Target:AnyCPU Expect: error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit2()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit2");
@@ -688,7 +685,7 @@ public void Prefer32bit2()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:false Target:x86 Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit3()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit3");
@@ -743,7 +740,7 @@ public void Prefer32bit3()
         /// <summary>
         /// Project: Prefer32bit false  Manifest:SupportPrefer32Bit:false Target:msil Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit4()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit4");
@@ -798,7 +795,7 @@ public void Prefer32bit4()
         /// <summary>
         /// Project: Prefer32bit false  Manifest:SupportPrefer32Bit:false Target:x86 Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit5()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit5");
@@ -853,7 +850,7 @@ public void Prefer32bit5()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:FOO Target:msil Expect: error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit6()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit6");
@@ -910,7 +907,7 @@ public void Prefer32bit6()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:empty Target:msil Expect: No error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit7()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit7");
@@ -965,7 +962,7 @@ public void Prefer32bit7()
         /// <summary>
         /// Project: Prefer32bit true  Manifest:SupportPrefer32Bit:missing Target:msil Expect: No Error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit8()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit8");
@@ -1019,7 +1016,7 @@ public void Prefer32bit8()
         /// <summary>
         /// Project: Prefer32bit false  Manifest:SupportPrefer32Bit:true Target:msil Expect: No Error
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void Prefer32bit9()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "Prefer32bit9");
@@ -1075,7 +1072,7 @@ public void Prefer32bit9()
         /// Resolve from an SDK which exists and is not a framework SDK. This means there is no frameworkIdentity or APPXLocation.
         /// Also since no configuration or architecture were passed in we expect the defaults.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ResolveFromNonFrameworkNoManifest()
         {
             // Create the engine.
@@ -1112,7 +1109,7 @@ public void ResolveFromNonFrameworkNoManifest()
         /// Resolve from an SDK which exists and is not a framework SDK. This means there is no frameworkIdentity or APPXLocation.
         /// Also since no configuration or architecture were passed in we expect the defaults.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ResolveFromNonFrameworkPassInConfigAndArch()
         {
             // Create the engine.
@@ -1150,7 +1147,7 @@ public void ResolveFromNonFrameworkPassInConfigAndArch()
         /// Resolve from an SDK which exists and is not a framework SDK. This means there is no frameworkIdentity or APPXLocation.
         /// Also since no configuration or architecture were passed in we expect the defaults.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ResolveFromNonFrameworkPassInConfigAndArchOverrideByMetadata()
         {
             // Create the engine.
@@ -1191,7 +1188,7 @@ public void ResolveFromNonFrameworkPassInConfigAndArchOverrideByMetadata()
         /// <summary>
         /// When duplicate references are passed in we only want the first one.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void DuplicateSDKReferences()
         {
             // Create the engine.
@@ -1227,7 +1224,7 @@ public void DuplicateSDKReferences()
         /// Verify that if references have SDKName metadata on them that matches a resolved SDK then that SDK should
         /// not have its reference assemblies expanded.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void DoNotExpandSDKsWhichAreAlsoTargetedByReferences()
         {
             // Create the engine.
@@ -1299,7 +1296,7 @@ public void DoNotExpandSDKsWhichAreAlsoTargetedByReferences()
         /// <summary>
         /// When InstalledSDK is empty we should log a message and succeed.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void InstalledSDKEmpty()
         {
             // Create the engine.
@@ -1323,7 +1320,7 @@ public void InstalledSDKEmpty()
         /// <summary>
         /// Lets have a mix of install sdk items, some are good, some are bad (missing item spec) others are bad (missing SDKName)
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MixOfInstalledSDKItemsGoodDuplicateAndBad()
         {
             // Create the engine.
@@ -1373,7 +1370,7 @@ public void MixOfInstalledSDKItemsGoodDuplicateAndBad()
         /// <summary>
         /// Make sure when no sdks are resolved there are no problems and that the names of the sdks which were not resolved are logged.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NOSDKResolved()
         {
             // Create the engine.
@@ -1401,7 +1398,7 @@ public void NOSDKResolved()
         /// When there is a mix of resolved and unresolved SDKs make sure that the resolved ones are correctly found
         /// and the unresolved ones are logged.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MixOfResolvedAndUnResolved()
         {
             // Create the engine.
@@ -1432,7 +1429,7 @@ public void MixOfResolvedAndUnResolved()
         /// <summary>
         /// When a null is passed into the SDKReferences property make sure we get the correct exception out.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NullSDKReferences()
         {
             Assert.Throws<ArgumentNullException>(() =>
@@ -1448,7 +1445,7 @@ public void NullSDKReferences()
         /// <summary>
         /// When a null is passed into the set of InstalledSDKS property make sure we get the correct exception out.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NullInstalledSDKs()
         {
             Assert.Throws<ArgumentNullException>(() =>
@@ -1465,7 +1462,7 @@ public void NullInstalledSDKs()
         /// <summary>
         /// If no SDKReferences are passed in then we should get nothing out.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptySDKReferencesList()
         {
             // Create the engine.
@@ -1489,7 +1486,7 @@ public void EmptySDKReferencesList()
         /// When we find the SDKManifest it may be poorly formatted. If that happens we need to log the error
         /// and not resolve the SDK. We also add a good one as well to make sure resolution continues.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SDKFoundButBadlyFormattedSDKManifestWarnings()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SDKFoundButBadlyFormattedSDKManifestWarnings");
@@ -1548,7 +1545,7 @@ public void SDKFoundButBadlyFormattedSDKManifestWarnings()
         /// When we find the SDKManifest it may be poorly formatted. If that happens we need to log the error
         /// and not resolve the SDK. We also add a good one as well to make sure resolution continues.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-osx-failing")]
         public void SDKFoundButBadlyFormattedSDKManifestErrors()
         {
@@ -1600,7 +1597,7 @@ public void SDKFoundButBadlyFormattedSDKManifestErrors()
             }
         }
 
-        [Fact]
+        [WindowsOnlyFact]
         public void TestMaxPlatformVersionWithTargetFrameworkVersion()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "TestMaxPlatformVersionWithTargetFrameworkVersion");
@@ -1706,7 +1703,7 @@ public void TestMaxPlatformVersionWithTargetFrameworkVersion()
         /// <summary>
         /// Test the case where the manifest attributes are empty.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptySDKManifestAttributes()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "EmptySDKManifestAttributes");
@@ -1791,7 +1788,7 @@ public void EmptySDKManifestAttributes()
         /// <summary>
         /// Test the case where we override ALL of the manifest properties with ones on the metadata
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void OverrideManifestAttributes()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "OverrideManifestAttributes");
@@ -1889,7 +1886,7 @@ public void OverrideManifestAttributes()
         /// <summary>
         /// Test the case where we Have a good manifest that had framework and appx locations that exactly match the targeted sdk configuration and architecture.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GoodManifestMatchingConfigAndArch()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GoodManifestMatchingConfigAndArch");
@@ -1962,7 +1959,7 @@ public void GoodManifestMatchingConfigAndArch()
         /// <summary>
         /// Test the case where we Have a good manifest that had framework and appx locations that only match the targeted sdk configuration.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GoodManifestMatchingConfigOnly()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GoodManifestMatchingConfigOnly");
@@ -2031,7 +2028,7 @@ public void GoodManifestMatchingConfigOnly()
         /// <summary>
         /// TVerify that when a platform identity is found that we do not copy the references or redist
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void NoCopyOnPlatformIdentityFound()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "NoCopyOnPlatformIdentityFound");
@@ -2098,7 +2095,7 @@ public void NoCopyOnPlatformIdentityFound()
         /// Test the case where we Have a good manifest that had framework and appx locations that does not match any of the config arch combinations but does match
         /// and entry name simply FrameworkIdentity or APPX
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void GoodManifestMatchingBaseNameOnly()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GoodManifestMatchingConfigOnly");
@@ -2172,7 +2169,7 @@ public void GoodManifestMatchingBaseNameOnly()
         /// <summary>
         /// Test the case where we only have the arm APPX and it can be found
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ManifestOnlyHasArmLocation()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ManifestOnlyHasArmLocation");
@@ -2240,7 +2237,7 @@ public void ManifestOnlyHasArmLocation()
         /// <summary>
         /// Test the case where we have a number of locations and arm APPX and can be found
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ManifestArmLocationWithOthers()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ManifestArmLocationWithOthers");
@@ -2311,7 +2308,7 @@ public void ManifestArmLocationWithOthers()
         /// Test the case where there are framework identity attributes but none of the match and there is no base FrameworkIdentity, the
         /// same is true for APPX.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MatchNoNamesButNamesExistWarning()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "MatchNoNamesButNamesExistWarning");
@@ -2383,7 +2380,7 @@ public void MatchNoNamesButNamesExistWarning()
         /// Test the case where there are framework identity attributes but none of the match and there is no base FrameworkIdentity, the
         /// same is true for APPX.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MatchNoNamesButNamesExistError()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "MatchNoNamesButNamesExistError");
@@ -2452,7 +2449,7 @@ public void MatchNoNamesButNamesExistError()
         /// <summary>
         /// Test the case where there is a single supported architecture and the project targets that architecture
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SingleSupportedArchitectureMatchesProject()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SingleSupportedArchitectureMatchesProject");
@@ -2525,7 +2522,7 @@ public void SingleSupportedArchitectureMatchesProject()
         /// <summary>
         /// Test the case where the productfamily is set in the manifest and not as metadata on the reference item.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ProductFamilySetInManifest()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ProductFamilySetInManifest");
@@ -2590,7 +2587,7 @@ public void ProductFamilySetInManifest()
         /// <summary>
         /// Test the case where the productfamily is set in the manifest and as metadata on the reference item. Expect the metadata to win.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ProductFamilySetInManifestAndMetadata()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ProductFamilySetInManifestAndMetadata");
@@ -2657,7 +2654,7 @@ public void ProductFamilySetInManifestAndMetadata()
         /// <summary>
         /// Test the case where the SupportsMultipleVersions is NOT in the manifest or on metadata
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SupportsMultipleVersionsNotInManifest()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SupportsMultipleVersionsNotInManifest");
@@ -2721,7 +2718,7 @@ public void SupportsMultipleVersionsNotInManifest()
         /// <summary>
         /// Test the case where metadata on the item is bad, we should then read from the manifest.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SupportsMultipleVersionsBadMetadata()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SupportsMultipleVersionsBadMetadata");
@@ -2789,7 +2786,7 @@ public void SupportsMultipleVersionsBadMetadata()
         /// <summary>
         /// Test the case where there are conflicts between sdks of the same product family
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConflictsBetweenSameProductFamilySameName()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ConflictsBetweenSameProductFamilySameName");
@@ -2887,7 +2884,7 @@ public void ConflictsBetweenSameProductFamilySameName()
         /// <summary>
         /// Test the case where there are conflicts between sdks of the same product family
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConflictsBetweenSameProductFamilyDiffName()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ConflictsBetweenSameProductFamilyDiffName");
@@ -2985,7 +2982,7 @@ public void ConflictsBetweenSameProductFamilyDiffName()
         /// <summary>
         /// Test the case where there are conflicts between sdks of the same product family
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConflictsBetweenMIXPFAndName()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ConflictsBetweenSameProductFamilyDiffName");
@@ -3098,7 +3095,7 @@ public void ConflictsBetweenMIXPFAndName()
         /// <summary>
         /// Test the case where there are conflicts between sdks of the same SDK Name
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void ConflictsBetweenSameSDKName()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "ConflictsBetweenSameSDKName");
@@ -3196,7 +3193,7 @@ public void ConflictsBetweenSameSDKName()
         /// <summary>
         /// Test the case where metadata on the item is bad, we should then read from the manifest.
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SupportsMultipleVersionsReadManifest()
         {
             SupportsMultipleVersionsVerifyManifestReading("Error");
@@ -3278,7 +3275,7 @@ private void SupportsMultipleVersionsVerifyManifestReading(string manifestEntry)
         /// <summary>
         /// Test the case where the supportedArchitectures are empty
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void EmptyArchitectures()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "OverrideManifestWithMetadata");
@@ -3355,7 +3352,7 @@ public void EmptyArchitectures()
         /// <summary>
         /// Test the case where the metadata on the reference overrides what is in the manifest but it does not match what is being targeted
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void OverrideManifestWithMetadataButMetadataDoesNotMatch()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "OverrideManifestWithMetadataButMetadataDoesNotMatch");
@@ -3421,7 +3418,7 @@ public void OverrideManifestWithMetadataButMetadataDoesNotMatch()
         /// <summary>
         /// Test the case where the metadata on the reference overrides what is in the manifest
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void OverrideManifestWithMetadata()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "OverrideManifestWithMetadata");
@@ -3499,7 +3496,7 @@ public void OverrideManifestWithMetadata()
         /// <summary>
         /// Test the case where there is a single supported architecture and the project does not target that architecture
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void SingleSupportedArchitectureDoesNotMatchProject()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "SingleSupportedArchitectureDoesNotMatchProject");
@@ -3563,7 +3560,7 @@ public void SingleSupportedArchitectureDoesNotMatchProject()
         /// <summary>
         /// Test the case where there is are multiple supported architecture and the project targets one of those architectures
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MultipleSupportedArchitectureMatchesProject()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "MultipleSupportedArchitectureMatchesProject");
@@ -3635,7 +3632,7 @@ public void MultipleSupportedArchitectureMatchesProject()
         /// <summary>
         /// Test the case where there is are multiple supported architecture and the project does not match one of those architectures
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         public void MultipleSupportedArchitectureDoesNotMatchProject()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "MultipleSupportedArchitectureMatchesProject");
@@ -3701,11 +3698,9 @@ public void MultipleSupportedArchitectureDoesNotMatchProject()
     /// <summary>
     /// Test the output groups which will be used to generate the recipe fileGatherSDKOutputGroups
     /// </summary>
-    [PlatformSpecific(TestPlatforms.Windows)]
     public class GatherSDKOutputGroupsTestFixture
     {
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void GatherSDKOutputGroupsTargetArchitectureExists()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GatherSDKOutputGroupsWithFramework");
@@ -3848,8 +3843,7 @@ public void GatherSDKOutputGroupsTargetArchitectureExists()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void GatherSDKOutputGroupsTargetArchitectureExists2()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GatherSDKOutputGroupsWithFramework");
@@ -3993,8 +3987,7 @@ public void GatherSDKOutputGroupsTargetArchitectureExists2()
         }
 
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void GatherSDKOutputGroupsTargetArchitectureDoesNotExists()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "GatherSDKOutputGroupsTargetArchitectureDoesNotExists");
@@ -4103,8 +4096,7 @@ public void GatherSDKOutputGroupsTargetArchitectureDoesNotExists()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void CheckDefaultingOfTargetConfigAndArchitecture()
         {
             string testDirectoryRoot = Path.Combine(Path.GetTempPath(), "CheckDefaultingOfTargetConfigAndArchitecture");
@@ -4201,8 +4193,7 @@ public void CheckDefaultingOfTargetConfigAndArchitecture()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyPlatformAliasesWork()
         {
             // This verifies that UAP is an alias for windows, so verifying the target platforms align. Other parts of the reference don't matter here.
@@ -4224,8 +4215,7 @@ public void VerifyPlatformAliasesWork()
             reference.TargetPlatform.ShouldBe("UAP");
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
+        [WindowsOnlyFact(additionalMessage: "No GetResolvedSDKReferences target in Unix.")]
         public void CheckAttributesFromManifestArePassedToResolvedAssemblies()
         {
             /* \Microsoft SDKs\Windows\v8.0\ExtensionSDKs */
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index f2c6b9d0524..01850264119 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Shared;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 using System.IO;
 using System.Threading;
 using Shouldly;
@@ -2123,9 +2124,8 @@ public void SourceItemMissing()
         /// <summary>
         ///  Non-existent StateFile yields message
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact]
         [Trait("Category", "mono-windows-failing")]
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void StateFileUnwritable()
         {
             GenerateResource t = Utilities.CreateTaskOutOfProc(_output);
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 1a62accb608..882e9c40189 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -16,6 +16,7 @@
 using Xunit.Abstractions;
 using System.Collections.Generic;
 using System.Text.RegularExpressions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -2520,8 +2521,7 @@ public void SourceItemMissing()
         /// <summary>
         ///  Read-only StateFile yields message
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void StateFileUnwritable()
         {
             GenerateResource t = Utilities.CreateTask(_output);
diff --git a/src/Tasks.UnitTests/Unzip_Tests.cs b/src/Tasks.UnitTests/Unzip_Tests.cs
index 3e74d5ef77c..26de13ddc87 100644
--- a/src/Tasks.UnitTests/Unzip_Tests.cs
+++ b/src/Tasks.UnitTests/Unzip_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -110,8 +111,7 @@ public void CanUnzip_ExplicitDirectoryEntries()
             }
         }
 
-        [PlatformSpecific(TestPlatforms.Windows)] // Can't figure out how to make CreateDirectory throw on non-Windows
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "Can't figure out how to make CreateDirectory throw on non-Windows.")]
         public void LogsErrorIfDirectoryCannotBeCreated()
         {
             Unzip unzip = new Unzip
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index 962dd1ec0a4..a8578ce7c08 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -10,6 +10,7 @@
 using System.Linq;
 using System.Runtime.InteropServices;
 using Shouldly;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -194,8 +195,7 @@ public void InvalidFilePath()
         /// <summary>
         /// Bad directory path
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "No invalid characters on Unix"
+        [WindowsOnlyFact(additionalMessage: "No invalid characters on Unix.")]
         public void InvalidDirectoryPath()
         {
             WriteCodeFragment task = new WriteCodeFragment();
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index 8c961c597f1..832d431fb67 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -23,6 +23,7 @@
 using SharedDotNetFrameworkArchitecture = Microsoft.Build.Shared.DotNetFrameworkArchitecture;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -68,8 +69,7 @@ public void GetApiContractReferencesHandlesNonExistingLocation()
             returnValue.Length.ShouldBe(0);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetApiContractReferencesFindsWinMDs()
         {
             string tempDirectory = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
@@ -93,8 +93,7 @@ public void GetApiContractReferencesFindsWinMDs()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetApiContractReferencesFindsVersionedWinMDs()
         {
             string tempDirectory = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
@@ -117,8 +116,7 @@ public void GetApiContractReferencesFindsVersionedWinMDs()
             }
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetWinBlueSDKLocation()
         {
             string sdkRootPath = ToolLocationHelper.GetPlatformSDKLocation("Windows", "8.1");
@@ -127,8 +125,7 @@ public void GetWinBlueSDKLocation()
             returnValue.ShouldBe(sdkRootPath);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetWinBlueContentFolderPath()
         {
             string sdkRootPath = ToolLocationHelper.GetPlatformSDKLocation("Windows", "8.1");
@@ -137,8 +134,7 @@ public void GetWinBlueContentFolderPath()
             returnValue.ShouldBe(Path.Combine(sdkRootPath, @"DesignTime\CommonConfiguration\Neutral"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetSDKRootLocation()
         {
             string expectedValue = ToolLocationHelper.GetPlatformSDKLocation("Windows", "10.0");
@@ -151,11 +147,10 @@ public void GetSDKRootLocation()
         }
 
 #if RUNTIME_TYPE_NETCORE
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/1250")]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/1250")]
 #else
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/2569")]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/2569")]
 #endif
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void GetUnversionedSDKUnionMetadataLocation()
         {
             string sdkRootPath = ToolLocationHelper.GetPlatformSDKLocation("Windows", "10.0");
@@ -165,8 +160,7 @@ public void GetUnversionedSDKUnionMetadataLocation()
             returnValue.ShouldBe(Path.Combine(sdkRootPath, "UnionMetadata"));
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetVersionedSDKUnionMetadataLocation()
         {
             // Create manifest file
@@ -533,8 +527,7 @@ public void FindFrameworksPathRunningThisTest()
          *
          * Search for a whidbey when whidbey is the current version.
          */
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void FindFrameworksPathRunningUnderWhidbey()
         {
             string path = FrameworkLocationHelper.FindDotNetFrameworkPath(
@@ -551,8 +544,7 @@ public void FindFrameworksPathRunningUnderWhidbey()
         *
         * Search for a whidbey when orcas is the current version.
         */
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void FindFrameworksPathRunningUnderOrcas()
         {
             string path = FrameworkLocationHelper.FindDotNetFrameworkPath(
@@ -569,8 +561,7 @@ public void FindFrameworksPathRunningUnderOrcas()
         *
         * Search for a whidbey when orcas is the current version.
         */
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void FindFrameworksPathRunningUnderEverett()
         {
             string path = FrameworkLocationHelper.FindDotNetFrameworkPath(
@@ -907,11 +898,10 @@ public void TestGetDotNetFrameworkSdkInstallKeyValue()
         }
 
 #if FEATURE_REGISTRY_SDKS
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/995")]
+        [WindowsOnlyFact(Skip = "https://github.com/dotnet/msbuild/issues/995")]
 #else
-        [Fact(Skip = "Registry SDKs not supported")]
+        [WindowsOnlyFact(Skip = "Registry SDKs not supported")]
 #endif
-        [PlatformSpecific(TestPlatforms.Windows)]
         public void GetPathToDotNetFrameworkSdk()
         {
             // Test out of range .net version.
@@ -990,8 +980,7 @@ public void GetPathToDotNetFrameworkSdk()
 
 #pragma warning disable 618 //The test below tests a deprecated API. We disable the warning for obsolete methods for this particular test
 #if FEATURE_WIN32_REGISTRY
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetPathToWindowsSdk()
         {
             // Test out of range .net version.
@@ -1219,8 +1208,7 @@ public void VerifyToolsetAndToolLocationHelperAgreeWhenVisualStudioVersionIs10()
             success.ShouldBeTrue(); // "Build Failed.  See Std Out for details."
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyToolsetAndToolLocationHelperAgreeWhenVisualStudioVersionIs11()
         {
             string projectContents = @"
@@ -1971,8 +1959,7 @@ public void GetPathToReferenceAssembliesDefaultLocation99()
         /// <summary>
         /// Make sure we choose the correct path for program files based on the operating system
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void TestGenerateProgramFiles32()
         {
             Environment.SpecialFolder folder = Environment.Is64BitOperatingSystem ? Environment.SpecialFolder.ProgramFilesX86 : Environment.SpecialFolder.ProgramFiles;
@@ -1987,8 +1974,7 @@ public void TestGenerateProgramFiles32()
         /// <summary>
         /// Verify we get the correct reference assembly path out of the framework location helper
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // "No ProgramFiles known location outside Windows"
+        [WindowsOnlyFact(additionalMessage: "No ProgramFiles known location outside Windows.")]
         public void TestGeneratedReferenceAssemblyPath()
         {
             string programFiles32 = FrameworkLocationHelper.GenerateProgramFiles32();
@@ -2476,8 +2462,7 @@ public void GetAssemblyFoldersExInfoTestNullTargetRuntimeVersion()
         /// <summary>
         /// Verify we can get a list of directories out of the public API.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void GetAssemblyFoldersExInfoTest()
         {
             SetupAssemblyFoldersExTestConditionRegistryKey();
@@ -3175,8 +3160,7 @@ public void VerifySDKManifestWithNullOrEmptyParameter()
         /// Verify SDKManifest defaults values for MaxPlatformVersion, MinOSVersion, MaxOSVersion when these are not
         /// present in the manifest and the SDK is a framework extension SDK
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyFrameworkSdkWithOldManifest()
         {
             string tmpRootDirectory = Path.GetTempPath();
@@ -4147,15 +4131,13 @@ public void GetALLTargetPlatformSDKs()
         /// <summary>
         /// Verify that the list of platforms is empty if we ask for an sdk that is not installed.
         /// </summary>
-        [Fact]
-        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [UnixOnlyFact]
         public void VerifyGetFoldersInVSInstalls_Unix()
         {
             ToolLocationHelper.GetFoldersInVSInstalls(null, null, "relativePath").Count().ShouldBe(0);
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)]
+        [WindowsOnlyFact]
         public void VerifyFindRootFolderWhereAllFilesExist()
         {
             // create directories and files in them
diff --git a/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs
new file mode 100644
index 00000000000..e85350b1417
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs
@@ -0,0 +1,25 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    /// This test should be run only on Unix (Linux, OSX platforms).
+    /// </summary>
+    public class UnixOnlyFactAttribute : FactAttribute
+    {
+        public UnixOnlyFactAttribute(string? additionalMessage = null)
+        {
+            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test requires Unix to run.";
+                if (!string.IsNullOrWhiteSpace(additionalMessage))
+                {
+                    this.Skip += " " + additionalMessage;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs
new file mode 100644
index 00000000000..5be21bfb7aa
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs
@@ -0,0 +1,25 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    /// This test should be run only on Unix (Linux, OSX platforms).
+    /// </summary>
+    public class UnixOnlyTheoryAttribute : TheoryAttribute
+    {
+        public UnixOnlyTheoryAttribute(string? additionalMessage = null)
+        {
+            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test requires Unix to run.";
+                if (!string.IsNullOrWhiteSpace(additionalMessage))
+                {
+                    this.Skip += " " + additionalMessage;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs
new file mode 100644
index 00000000000..660e30188a0
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs
@@ -0,0 +1,25 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    /// This test should be run only on Windows.
+    /// </summary>
+    public class WindowsOnlyFactAttribute : FactAttribute
+    {
+        public WindowsOnlyFactAttribute(string? additionalMessage = null)
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test requires Windows to run.";
+                if (!string.IsNullOrWhiteSpace(additionalMessage))
+                {
+                    this.Skip += " " + additionalMessage;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs
new file mode 100644
index 00000000000..dfc474c3876
--- /dev/null
+++ b/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs
@@ -0,0 +1,25 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+
+namespace Xunit.NetCore.Extensions
+{
+    /// <summary>
+    /// This test should be run only on Windows.
+    /// </summary>
+    public class WindowsOnlyTheoryAttribute : TheoryAttribute
+    {
+        public WindowsOnlyTheoryAttribute(string? additionalMessage = null)
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                this.Skip = "This test requires Windows to run.";
+                if (!string.IsNullOrWhiteSpace(additionalMessage))
+                {
+                    this.Skip += " " + additionalMessage;
+                }
+            }
+        }
+    }
+}
