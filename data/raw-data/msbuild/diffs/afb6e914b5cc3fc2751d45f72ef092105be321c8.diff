diff --git a/src/Build/BackEnd/Components/Communications/EntryNodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/EntryNodeEndpointOutOfProc.cs
new file mode 100644
index 00000000000..8db6ff6d165
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/EntryNodeEndpointOutOfProc.cs
@@ -0,0 +1,46 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// This is an implementation of INodeEndpoint for the out-of-proc nodes.  It acts only as a client.
+    /// </summary>
+    internal class EntryNodeEndpointOutOfProc : NodeEndpointOutOfProcBase
+    {
+        #region Private Data
+
+        private readonly IHandshake _handshake;
+
+        #endregion
+
+        #region Constructors and Factories
+
+        /// <summary>
+        /// Instantiates an endpoint to act as a client
+        /// </summary>
+        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
+        /// <param name="handshake"></param>
+        internal EntryNodeEndpointOutOfProc(
+            string pipeName,
+            IHandshake handshake)
+        {
+            _handshake = handshake;
+
+            InternalConstruct(pipeName);
+        }
+
+        #endregion
+
+        /// <summary>
+        /// Returns the host handshake for this node endpoint
+        /// </summary>
+        protected override IHandshake GetHandshake()
+        {
+            return _handshake;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/EntryNodeHandshake.cs b/src/Build/BackEnd/Components/Communications/EntryNodeHandshake.cs
new file mode 100644
index 00000000000..e1784499c62
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/EntryNodeHandshake.cs
@@ -0,0 +1,94 @@
+﻿using System;
+using System.Diagnostics;
+using System.Globalization;
+using System.IO;
+using System.Security.Cryptography;
+using System.Text;
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal class EntryNodeHandshake : IHandshake
+    {
+        /// <summary>
+        /// The version of the handshake. This should be updated each time the handshake is altered.
+        /// </summary>
+        readonly int _version = 0x101;
+
+        readonly int _options;
+        readonly int _salt;
+        readonly int _fileVersionMajor;
+        readonly int _fileVersionMinor;
+        readonly int _fileVersionBuild;
+        readonly int _fileVersionRevision;
+
+        internal EntryNodeHandshake(HandshakeOptions nodeType, string msBuildLocation)
+        {
+            // We currently use 6 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
+            // This indicates in the first byte that we are a modern build.
+            _options = (int)nodeType;
+            string? handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
+            var msBuildFile = new FileInfo(msBuildLocation);
+            var msBuildDirectory = msBuildFile.DirectoryName;
+            _salt = ComputeHandshakeHash(handshakeSalt + msBuildDirectory);
+            Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(msBuildLocation).FileVersion ?? string.Empty);
+            _fileVersionMajor = fileVersion.Major;
+            _fileVersionMinor = fileVersion.Minor;
+            _fileVersionBuild = fileVersion.Build;
+            _fileVersionRevision = fileVersion.Revision;
+        }
+
+        internal const int EndOfHandshakeSignal = -0x2a2a2a2a;
+
+        /// <summary>
+        /// Compute stable hash as integer
+        /// </summary>
+        private static int ComputeHandshakeHash(string fromString)
+        {
+            using var sha = SHA256.Create();
+            var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(fromString));
+
+            return BitConverter.ToInt32(bytes, 0);
+        }
+
+        internal static int AvoidEndOfHandshakeSignal(int x)
+        {
+            return x == EndOfHandshakeSignal ? ~x : x;
+        }
+
+        public int[] RetrieveHandshakeComponents()
+        {
+            return new int[]
+            {
+                AvoidEndOfHandshakeSignal(_version),
+                AvoidEndOfHandshakeSignal(_options),
+                AvoidEndOfHandshakeSignal(_salt),
+                AvoidEndOfHandshakeSignal(_fileVersionMajor),
+                AvoidEndOfHandshakeSignal(_fileVersionMinor),
+                AvoidEndOfHandshakeSignal(_fileVersionBuild),
+                AvoidEndOfHandshakeSignal(_fileVersionRevision),
+            };
+        }
+
+        public string GetKey()
+        {
+            return $"{_version} {_options} {_salt} {_fileVersionMajor} {_fileVersionMinor} {_fileVersionBuild} {_fileVersionRevision}"
+                .ToString(CultureInfo.InvariantCulture);
+        }
+
+        public byte? ExpectedVersionInFirstByte => null;
+
+        /// <summary>
+        /// Computes Handshake stable hash string representing whole state of handshake.
+        /// </summary>
+        public string ComputeHash()
+        {
+            var input = GetKey();
+            using var sha = SHA256.Create();
+            var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(input));
+            return Convert.ToBase64String(bytes)
+                .Replace("/", "_")
+                .Replace("=", string.Empty);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index 45303ac6d30..491724c630d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -52,7 +52,7 @@ internal NodeEndpointOutOfProc(
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected override Handshake GetHandshake()
+        protected override IHandshake GetHandshake()
         {
             return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess, nodeReuse: _enableReuse, lowPriority: _lowPriority));
         }
diff --git a/src/Build/BackEnd/Node/EntryNodeCommand.cs b/src/Build/BackEnd/Node/EntryNodeCommand.cs
new file mode 100644
index 00000000000..1329e6018ef
--- /dev/null
+++ b/src/Build/BackEnd/Node/EntryNodeCommand.cs
@@ -0,0 +1,109 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// EntryNodeCommand contains all of the information necessary for a entry node to run a command line.
+    /// </summary>
+    internal class EntryNodeCommand : INodePacket
+    {
+        public EntryNodeCommand(string commandLine, string startupDirectory, Dictionary<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture)
+        {
+            CommandLine = commandLine;
+            StartupDirectory = startupDirectory;
+            BuildProcessEnvironment = buildProcessEnvironment;
+            Culture = culture;
+            UICulture = uiCulture;
+        }
+
+        /// <summary>
+        /// Private constructor for deserialization
+        /// </summary>
+        private EntryNodeCommand()
+        {
+        }
+
+        #region INodePacket Members
+
+        /// <summary>
+        /// Retrieves the packet type.
+        /// </summary>
+        public NodePacketType Type => NodePacketType.EntryNodeCommand;
+
+        #endregion
+
+        /// <summary>
+        /// The startup directory
+        /// </summary>
+        public string CommandLine { get; private set; } = default!;
+
+        /// <summary>
+        /// The startup directory
+        /// </summary>
+        public string StartupDirectory { get; private set; } = default!;
+
+        /// <summary>
+        /// The process environment.
+        /// </summary>
+        public Dictionary<string, string> BuildProcessEnvironment { get; private set; } = default!;
+
+        /// <summary>
+        /// The culture
+        /// </summary>
+        public CultureInfo Culture { get; private set; } = default!;
+
+        /// <summary>
+        /// The UI culture.
+        /// </summary>
+        public CultureInfo UICulture { get; private set; } = default!;
+
+        #region INodePacketTranslatable Members
+
+        /// <summary>
+        /// Translates the packet to/from binary form.
+        /// </summary>
+        /// <param name="translator">The translator to use.</param>
+        public void Translate(ITranslator translator)
+        {
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                var br = translator.Reader;
+
+                CommandLine = br.ReadString();
+                StartupDirectory = br.ReadString();
+                int count = br.ReadInt32();
+                BuildProcessEnvironment = new Dictionary<string, string>(count, StringComparer.OrdinalIgnoreCase);
+                for (int i = 0; i < count; ++i)
+                {
+                    var key = br.ReadString();
+                    var value = br.ReadString();
+                    BuildProcessEnvironment.Add(key, value);
+                }
+                Culture = new CultureInfo(br.ReadString());
+                UICulture = new CultureInfo(br.ReadString());
+            }
+            else
+            {
+                throw new InvalidOperationException("Writing into stream not supported");
+            }
+        }
+
+        /// <summary>
+        /// Factory for deserialization.
+        /// </summary>
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            EntryNodeCommand command = new();
+            command.Translate(translator);
+
+            return command;
+        }
+        #endregion
+    }
+}
diff --git a/src/Build/BackEnd/Node/EntryNodeConsoleWrite.cs b/src/Build/BackEnd/Node/EntryNodeConsoleWrite.cs
new file mode 100644
index 00000000000..30767540962
--- /dev/null
+++ b/src/Build/BackEnd/Node/EntryNodeConsoleWrite.cs
@@ -0,0 +1,56 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal class EntryNodeConsoleWrite : INodePacket
+    {
+        public string Text { get; }
+
+        public ConsoleColor Foreground { get; }
+
+        public ConsoleColor Background { get; }
+
+        /// <summary>
+        /// 1 = stdout, 2 = stderr
+        /// </summary>
+        public byte OutputType { get; }
+
+        public EntryNodeConsoleWrite(string text, byte outputType)
+        {
+            Text = text;
+            OutputType = outputType;
+        }
+
+        #region INodePacket Members
+
+        /// <summary>
+        /// Packet type.
+        /// This has to be in sync with Microsoft.Build.BackEnd.NodePacketType.EntryNodeInfo
+        /// </summary>
+        public NodePacketType Type => NodePacketType.EntryNodeConsole;
+
+        #endregion
+
+        public void Translate(ITranslator translator)
+        {
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                var bw = translator.Writer;
+
+                bw.Write(Text);
+                bw.Write((int)Foreground);
+                bw.Write((int)Background);
+                bw.Write(OutputType);
+            }
+            else
+            {
+                throw new InvalidOperationException("Read from stream not supported");
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Node/EntryNodeResponse.cs b/src/Build/BackEnd/Node/EntryNodeResponse.cs
new file mode 100644
index 00000000000..9bed736a065
--- /dev/null
+++ b/src/Build/BackEnd/Node/EntryNodeResponse.cs
@@ -0,0 +1,46 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal class EntryNodeResponse : INodePacket
+    {
+        public EntryNodeResponse(int exitCode, string exitType)
+        {
+            ExitCode = exitCode;
+            ExitType = exitType;
+        }
+
+        #region INodePacket Members
+
+        /// <summary>
+        /// Packet type.
+        /// This has to be in sync with Microsoft.Build.BackEnd.NodePacketType.EntryNodeCommand
+        /// </summary>
+        public NodePacketType Type => NodePacketType.EntryNodeResponse;
+
+        #endregion
+
+        public int ExitCode { get; }
+
+        public string ExitType { get; }
+
+        public void Translate(ITranslator translator)
+        {
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                var bw = translator.Writer;
+
+                bw.Write(ExitCode);
+                bw.Write(ExitType);
+            }
+            else
+            {
+                throw new InvalidOperationException("Read from stream not supported");
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Node/OutOfProcEntryNode.cs b/src/Build/BackEnd/Node/OutOfProcEntryNode.cs
new file mode 100644
index 00000000000..0c604b769d8
--- /dev/null
+++ b/src/Build/BackEnd/Node/OutOfProcEntryNode.cs
@@ -0,0 +1,539 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Concurrent;
+using System.IO;
+using System.Linq;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Internal;
+using System.Diagnostics;
+
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// This class represents an implementation of INode for out-of-proc entry nodes aka MSBuild server 
+    /// </summary>
+    public class OutOfProcEntryNode : INode, INodePacketFactory, INodePacketHandler
+    {
+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;
+
+        /// <summary>
+        /// The endpoint used to talk to the host.
+        /// </summary>
+        private INodeEndpoint _nodeEndpoint = default!;
+
+        /// <summary>
+        /// The packet factory.
+        /// </summary>
+        private readonly NodePacketFactory _packetFactory;
+
+        /// <summary>
+        /// The queue of packets we have received but which have not yet been processed.
+        /// </summary>
+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;
+
+        /// <summary>
+        /// The event which is set when we receive packets.
+        /// </summary>
+        private readonly AutoResetEvent _packetReceivedEvent;
+
+        /// <summary>
+        /// The event which is set when we should shut down.
+        /// </summary>
+        private readonly ManualResetEvent _shutdownEvent;
+
+        /// <summary>
+        /// The reason we are shutting down.
+        /// </summary>
+        private NodeEngineShutdownReason _shutdownReason;
+
+        /// <summary>
+        /// The exception, if any, which caused shutdown.
+        /// </summary>
+        private Exception? _shutdownException = null;
+
+        /// <summary>
+        /// Flag indicating if we should debug communications or not.
+        /// </summary>
+        private readonly bool _debugCommunications;
+
+        private string _serverBusyMutexName = default!;
+
+        public OutOfProcEntryNode(Func<string, (int exitCode, string exitType)> buildFunction)
+        {
+            _buildFunction = buildFunction;
+            new Dictionary<string, string>();
+            _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
+
+            _receivedPackets = new ConcurrentQueue<INodePacket>();
+            _packetReceivedEvent = new AutoResetEvent(false);
+            _shutdownEvent = new ManualResetEvent(false);
+            _packetFactory = new NodePacketFactory();
+
+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.EntryNodeCommand, EntryNodeCommand.FactoryForDeserialization, this);
+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);
+        }
+
+        #region INode Members
+
+        /// <summary>
+        /// Starts up the node and processes messages until the node is requested to shut down.
+        /// Assumes no node reuse.
+        /// Assumes low priority is disabled.
+        /// </summary>
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
+        /// <returns>The reason for shutting down.</returns>
+        public NodeEngineShutdownReason Run(out Exception? shutdownException)
+        {
+            return Run(false, false, out shutdownException);
+        }
+
+        /// <summary>
+        /// Starts up the node and processes messages until the node is requested to shut down.
+        /// Assumes low priority is disabled.
+        /// </summary>
+        /// <param name="enableReuse">Whether this node is eligible for reuse later.</param>
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
+        /// <returns>The reason for shutting down.</returns>
+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception? shutdownException)
+        {
+            return Run(enableReuse, false, out shutdownException);
+        }
+
+        /// <summary>
+        /// Starts up the node and processes messages until the node is requested to shut down.
+        /// </summary>
+        /// <param name="enableReuse">Whether this node is eligible for reuse later.</param>
+        /// <param name="lowPriority">Whether this node should be running with low priority.</param>
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
+        /// <returns>The reason for shutting down.</returns>
+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception? shutdownException)
+        {
+            Debugger.Launch();
+            // Console.WriteLine("Run called at {0}", DateTime.Now);
+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
+            var handshake = new EntryNodeHandshake(
+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),
+                msBuildLocation);
+
+            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuildServer-" + handshake.ComputeHash());
+
+            string serverRunningMutexName = $@"Global\server-running-{pipeName}";
+            _serverBusyMutexName = $@"Global\server-busy-{pipeName}";
+
+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning
+            // and of two processes will become victim and fails, build will not be affected
+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);
+            if (!mutexCreatedNew)
+            {
+                Debugger.Launch();
+                shutdownException = new InvalidOperationException("MSBuild server is already running!");
+                return NodeEngineShutdownReason.Error;
+            }
+
+            _nodeEndpoint = new EntryNodeEndpointOutOfProc(pipeName, handshake);
+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
+            _nodeEndpoint.Listen(this);
+
+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
+
+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.
+            while (true)
+            {
+                int index = WaitHandle.WaitAny(waitHandles);
+                switch (index)
+                {
+                    case 0:
+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);
+                        return shutdownReason;
+
+                    case 1:
+
+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))
+                        {
+                            if (packet != null)
+                            {
+                                HandlePacket(packet);
+                            }
+                        }
+
+                        break;
+                }
+            }
+
+            // UNREACHABLE
+        }
+
+        #endregion
+
+        #region INodePacketFactory Members
+
+        /// <summary>
+        /// Registers a packet handler.
+        /// </summary>
+        /// <param name="packetType">The packet type for which the handler should be registered.</param>
+        /// <param name="factory">The factory used to create packets.</param>
+        /// <param name="handler">The handler for the packets.</param>
+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)
+        {
+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);
+        }
+
+        /// <summary>
+        /// Unregisters a packet handler.
+        /// </summary>
+        /// <param name="packetType">The type of packet for which the handler should be unregistered.</param>
+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)
+        {
+            _packetFactory.UnregisterPacketHandler(packetType);
+        }
+
+        /// <summary>
+        /// Deserializes and routes a packer to the appropriate handler.
+        /// </summary>
+        /// <param name="nodeId">The node from which the packet was received.</param>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator to use as a source for packet data.</param>
+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        {
+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
+        }
+
+        /// <summary>
+        /// Routes a packet to the appropriate handler.
+        /// </summary>
+        /// <param name="nodeId">The node id from which the packet was received.</param>
+        /// <param name="packet">The packet to route.</param>
+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)
+        {
+            _packetFactory.RoutePacket(nodeId, packet);
+        }
+
+        #endregion
+
+        #region INodePacketHandler Members
+
+        /// <summary>
+        /// Called when a packet has been received.
+        /// </summary>
+        /// <param name="node">The node from which the packet was received.</param>
+        /// <param name="packet">The packet.</param>
+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)
+        {
+            _receivedPackets.Enqueue(packet);
+            _packetReceivedEvent.Set();
+        }
+
+        #endregion
+
+        /// <summary>
+        /// Perform necessary actions to shut down the node.
+        /// </summary>
+        // TODO: it is too complicated, for simple role of entry node it needs to be simplified
+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)
+        {
+            CommunicationsUtilities.Trace("Shutting down with reason: {0}, and exception: {1}.", _shutdownReason, _shutdownException);
+
+            exception = _shutdownException;
+
+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
+            {
+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;
+            }
+
+            _nodeEndpoint.Disconnect();
+
+            CommunicationsUtilities.Trace("Shut down complete.");
+
+            return _shutdownReason;
+        }
+
+        /// <summary>
+        /// Event handler for the node endpoint's LinkStatusChanged event.
+        /// </summary>
+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)
+        {
+            switch (status)
+            {
+                case LinkStatus.ConnectionFailed:
+                case LinkStatus.Failed:
+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;
+                    _shutdownEvent.Set();
+                    break;
+
+                case LinkStatus.Inactive:
+                    break;
+
+                case LinkStatus.Active:
+                    break;
+
+                default:
+                    break;
+            }
+        }
+
+        /// <summary>
+        /// Callback for logging packets to be sent.
+        /// </summary>
+        private void SendPacket(INodePacket packet)
+        {
+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
+            {
+                _nodeEndpoint.SendData(packet);
+            }
+        }
+
+        /// <summary>
+        /// Dispatches the packet to the correct handler.
+        /// </summary>
+        private void HandlePacket(INodePacket packet)
+        {
+            switch (packet.Type)
+            {
+                case NodePacketType.EntryNodeCommand:
+                    HandleEntryNodeCommand((EntryNodeCommand)packet);
+                    break;
+                case NodePacketType.NodeBuildComplete:
+                    HandleNodeBuildComplete((NodeBuildComplete)packet);
+                    break;
+            }
+        }
+
+        private void HandleEntryNodeCommand(EntryNodeCommand command)
+        {
+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);
+            if (!holdsMutex)
+            {
+                // Client must have send request message to server even though serer is busy.
+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.
+                _shutdownException = new InvalidOperationException("Client requested build while server is busy processing previous client build request.");
+                _shutdownReason = NodeEngineShutdownReason.Error;
+                _shutdownEvent.Set();
+            }
+
+            // set build process context
+            Directory.SetCurrentDirectory(command.StartupDirectory);
+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);
+            Thread.CurrentThread.CurrentCulture = command.Culture;
+            Thread.CurrentThread.CurrentUICulture = command.UICulture;
+
+            // configure console output redirection
+            var oldOut = Console.Out;
+            var oldErr = Console.Error;
+
+            using var outWriter = new RedirectConsoleWriter((text, foreground, background) =>
+            {
+                SendPacket(new EntryNodeConsoleWrite(text, 1));
+            });
+            using var errWriter = new RedirectConsoleWriter((text, foreground, background) =>
+            {
+                SendPacket(new EntryNodeConsoleWrite(text, 2));
+            });
+
+            Console.SetOut(outWriter);
+            Console.SetError(errWriter);
+
+            var (exitCode, exitType) = _buildFunction(command.CommandLine);
+
+            Console.SetOut(oldOut);
+            Console.SetError(oldErr);
+            outWriter.Dispose();
+            errWriter.Dispose();
+
+            // On Windows, a process holds a handle to the current directory,
+            // so reset it away from a user-requested folder that may get deleted.
+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);
+
+            var response = new EntryNodeResponse(exitCode, exitType);
+            SendPacket(response);
+
+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;
+            _shutdownEvent.Set();
+        }
+
+        // TODO: unit tests
+        internal class RedirectConsoleWriter : StringWriter
+        {
+            private readonly string _newLineString;
+
+            private readonly Action<string, ConsoleColor, ConsoleColor> _writeCallback;
+            private ConsoleColor _lastBackgroundColor;
+            private ConsoleColor _lastForegroundColor;
+
+            public RedirectConsoleWriter(Action<string, ConsoleColor, ConsoleColor> writeCallback)
+            {
+                _newLineString = new String(CoreNewLine);
+                _writeCallback = writeCallback;
+
+                _lastBackgroundColor = Console.BackgroundColor;
+                _lastForegroundColor = Console.ForegroundColor;
+            }
+
+            private void FlushIfColorChanged()
+            {
+                if (Console.ForegroundColor != _lastForegroundColor || Console.BackgroundColor != _lastBackgroundColor)
+                {
+                    Flush();
+                }
+            }
+
+            private void MaybeFlushCaptured(bool force)
+            {
+                if (force || GetStringBuilder().Length > 200)
+                {
+                    Flush();
+                }
+            }
+
+            protected override void Dispose(bool disposing)
+            {
+                if (disposing)
+                {
+                    Flush();
+                }
+
+                base.Dispose(disposing);
+            }
+
+            public override void Flush()
+            {
+                var sb = GetStringBuilder();
+                var captured = sb.ToString();
+                sb.Clear();
+                _writeCallback(captured, _lastForegroundColor, _lastBackgroundColor);
+
+                _lastForegroundColor = Console.ForegroundColor;
+                _lastBackgroundColor = Console.BackgroundColor;
+
+                base.Flush();
+            }
+
+            public override void Write(char value)
+            {
+                FlushIfColorChanged();
+                base.Write(value);
+                MaybeFlushCaptured(false);
+            }
+
+            public override void Write(char[] buffer, int index, int count)
+            {
+                FlushIfColorChanged();
+                base.Write(buffer, index, count);
+                MaybeFlushCaptured(buffer.SequenceEqual(CoreNewLine));
+            }
+
+            public override void Write(string? value)
+            {
+                if (value is null)
+                {
+                    return;
+                }
+
+                FlushIfColorChanged();
+                base.Write(value);
+                MaybeFlushCaptured(value.Contains(_newLineString));
+            }
+        }
+
+        /// <summary>
+        /// Handles the NodeBuildComplete packet.
+        /// </summary>
+        private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
+        {
+            _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;
+            _shutdownEvent.Set();
+        }
+
+        internal sealed class ServerNamedMutex : IDisposable
+        {
+            public readonly Mutex _serverMutex;
+
+            public bool IsDisposed { get; private set; }
+
+            public bool IsLocked { get; private set; }
+
+            public ServerNamedMutex(string mutexName, out bool createdNew)
+            {
+                _serverMutex = new Mutex(
+                    initiallyOwned: true,
+                    name: mutexName,
+                    createdNew: out createdNew);
+
+                if (createdNew)
+                {
+                    IsLocked = true;
+                }
+            }
+
+            internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)
+            {
+                // TODO: verify it is not needed anymore
+                // if (PlatformInformation.IsRunningOnMono)
+                // {
+                //     return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);
+                // }
+                // else
+
+                return new ServerNamedMutex(name, out createdNew);
+            }
+
+            public static bool WasOpen(string mutexName)
+            {
+                try
+                {
+                    // we can't use TryOpenExisting as it is not supported in net3.5
+                    using var m = Mutex.OpenExisting(mutexName);
+                    return true;
+                }
+                catch
+                {
+                    // In the case an exception occurred trying to open the Mutex then 
+                    // the assumption is that it's not open.
+                    return false;
+                }
+            }
+
+            public bool TryLock(int timeoutMs)
+            {
+                if (IsDisposed)
+                {
+                    throw new ObjectDisposedException(nameof(ServerNamedMutex));
+                }
+
+                if (IsLocked)
+                {
+                    throw new InvalidOperationException("Lock already held");
+                }
+
+                return IsLocked = _serverMutex.WaitOne(timeoutMs);
+            }
+
+            public void Dispose()
+            {
+                if (IsDisposed)
+                {
+                    return;
+                }
+
+                IsDisposed = true;
+
+                try
+                {
+                    if (IsLocked)
+                    {
+                        _serverMutex.ReleaseMutex();
+                    }
+                }
+                finally
+                {
+                    _serverMutex.Dispose();
+                    IsLocked = false;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index c25e4dc39fe..ee6ceed31e5 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -147,9 +147,15 @@
     <Compile Include="BackEnd\Components\Caching\ConfigCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\ProjectCache\*.cs" />
+    <Compile Include="BackEnd\Components\Communications\EntryNodeEndpointOutOfProc.cs" />
+    <Compile Include="BackEnd\Components\Communications\EntryNodeHandshake.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
+    <Compile Include="BackEnd\Node\EntryNodeCommand.cs" />
+    <Compile Include="BackEnd\Node\EntryNodeConsoleWrite.cs" />
+    <Compile Include="BackEnd\Node\EntryNodeResponse.cs" />
+    <Compile Include="BackEnd\Node\OutOfProcEntryNode.cs" />
     <Compile Include="Utilities\ImmutableCollectionsExtensions.cs" />
     <Compile Include="Utilities\NuGetFrameworkWrapper.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectUsingTaskParameterElementLink.cs" />
diff --git a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
index c5e7790c0a3..afc42aa9e16 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -3,3 +3,8 @@ Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
 Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
 Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
 Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
+Microsoft.Build.Execution.OutOfProcEntryNode
+Microsoft.Build.Execution.OutOfProcEntryNode.OutOfProcEntryNode(System.Func<string, (int exitCode, string exitType)> buildFunction) -> void
+Microsoft.Build.Execution.OutOfProcEntryNode.Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.OutOfProcEntryNode.Run(bool enableReuse, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.OutOfProcEntryNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index fdbce5593f6..aac50573d88 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -5,3 +5,8 @@ Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.get -> System.Thre
 Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.set -> void
 Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
 Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
+Microsoft.Build.Execution.OutOfProcEntryNode
+Microsoft.Build.Execution.OutOfProcEntryNode.OutOfProcEntryNode(System.Func<string, (int exitCode, string exitType)> buildFunction) -> void
+Microsoft.Build.Execution.OutOfProcEntryNode.Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.OutOfProcEntryNode.Run(bool enableReuse, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+Microsoft.Build.Execution.OutOfProcEntryNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
diff --git a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
index 36ea494b383..0f1e1eacb05 100644
--- a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
+++ b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
@@ -28,7 +28,7 @@ internal NodeEndpointOutOfProcTaskHost()
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected override Handshake GetHandshake()
+        protected override IHandshake GetHandshake()
         {
             return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
         }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 2289c4b7fcc..8f75c1fae05 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2614,6 +2614,46 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();
                     shutdownReason = node.Run(out nodeException);
                 }
+                else if (nodeModeNumber == 8)
+                {
+                    // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False
+                    bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);
+                    string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];
+                    bool lowpriority = lowPriorityInput.Length > 0 && lowPriorityInput[0].Equals("true");
+
+                    // Since build function has to reuse code from *this* class and OutOfProcEntryNode is in different assembly
+                    // we have to pass down xmake build invocation to avoid circular dependency
+                    Func<string, (int exitCode, string exitType)> buildFunction = (commandLine) =>
+                    {
+                        int exitCode;
+                        ExitType exitType;
+
+                        if (!s_initialized)
+                        {
+                            exitType = ExitType.InitializationError;
+                        }
+                        else
+                        {
+                            exitType = Execute(
+#if FEATURE_GET_COMMANDLINE
+                                    commandLine
+#else
+                                    QuotingUtilities.SplitUnquoted(commandLine).ToArray()
+#endif
+                                );
+                            exitCode = exitType == ExitType.Success ? 0 : 1;
+                        }
+                        exitCode = exitType == ExitType.Success ? 0 : 1;
+
+                        return (exitCode, exitType.ToString());
+                    };
+
+                    OutOfProcEntryNode node = new(buildFunction);
+
+                    shutdownReason = node.Run(nodeReuse, lowpriority, out nodeException);
+
+                    FileUtilities.ClearCacheDirectory();
+                }
                 else
                 {
                     CommandLineSwitchException.Throw("InvalidNodeNumberValue", nodeModeNumber.ToString());
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 670ba076324..ac0fa1943b8 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -70,7 +70,24 @@ internal enum HandshakeOptions
         NET = 64,
     }
 
-    internal readonly struct Handshake
+    internal interface IHandshake
+    {
+        int[] RetrieveHandshakeComponents();
+
+        /// <summary>
+        /// Get string key representing all handshake values. It does not need to be human readable.
+        /// </summary>
+        string GetKey();
+
+        /// <summary>
+        /// Some handshakes uses very 1st byte to encode version of handshake in it,
+        /// so if it does not match it can reject it early based on very first byte.
+        /// Null means that no such encoding is used
+        /// </summary>
+        byte? ExpectedVersionInFirstByte { get; }
+    }
+
+    internal readonly struct Handshake : IHandshake
     {
         readonly int options;
         readonly int salt;
@@ -104,7 +121,7 @@ public override string ToString()
             return String.Format("{0} {1} {2} {3} {4} {5} {6}", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);
         }
 
-        internal int[] RetrieveHandshakeComponents()
+        public int[] RetrieveHandshakeComponents()
         {
             return new int[]
             {
@@ -117,6 +134,10 @@ internal int[] RetrieveHandshakeComponents()
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)
             };
         }
+
+        public string GetKey() => $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}".ToString(CultureInfo.InvariantCulture);
+
+        public byte? ExpectedVersionInFirstByte => CommunicationsUtilities.handshakeVersion;
     }
 
     /// <summary>
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index 481a99bfce9..80c2b4c085c 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -189,6 +189,24 @@ internal enum NodePacketType : byte
         /// Message sent back to a node informing it about the resource that were granted by the scheduler.
         /// </summary>
         ResourceResponse,
+
+        /// <summary>
+        /// Command in form of MSBuild command line for entry node - MSBuild Server.
+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI
+        /// </summary>
+        EntryNodeCommand = 0xF0,
+
+        /// <summary>
+        /// Response from Entry node command
+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI
+        /// </summary>
+        EntryNodeResponse = 0xF1,
+
+        /// <summary>
+        /// Info about server console activity. 
+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI
+        /// </summary>
+        EntryNodeConsole = 0xF2,
     }
     #endregion
 
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index 4fbe37002a4..9db07e16722 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -17,6 +17,11 @@ internal static string GetPipeNameOrPath(int? processId = null)
 
             string pipeName = $"MSBuild{processId}";
 
+            return GetPipeNameOrPath(pipeName);
+        }
+
+        internal static string GetPipeNameOrPath(string pipeName)
+        {
             if (NativeMethodsShared.IsUnixLike)
             {
                 // If we're on a Unix machine then named pipes are implemented using Unix Domain Sockets.
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index ea696a53ec3..3589785563f 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -185,7 +185,7 @@ public void SendData(INodePacket packet)
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        internal void InternalConstruct()
+        internal void InternalConstruct(string pipeName = null)
         {
             _status = LinkStatus.Inactive;
             _asyncDataMonitor = new object();
@@ -194,7 +194,7 @@ internal void InternalConstruct()
             _packetStream = new MemoryStream();
             _binaryWriter = new BinaryWriter(_packetStream);
 
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath();
+            pipeName ??= NamedPipeUtil.GetPipeNameOrPath();
 
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
             if (!NativeMethodsShared.IsMono)
@@ -245,7 +245,7 @@ internal void InternalConstruct()
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected abstract Handshake GetHandshake();
+        protected abstract IHandshake GetHandshake();
 
         /// <summary>
         /// Updates the current link status if it has changed and notifies any registered delegates.
@@ -373,7 +373,7 @@ private void PacketPumpProc()
                     // The handshake protocol is a series of int exchanges.  The host sends us a each component, and we
                     // verify it. Afterwards, the host sends an "End of Handshake" signal, to which we respond in kind.
                     // Once the handshake is complete, both sides can be assured the other is ready to accept data.
-                    Handshake handshake = GetHandshake();
+                    IHandshake handshake = GetHandshake();
                     try
                     {
                         int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
