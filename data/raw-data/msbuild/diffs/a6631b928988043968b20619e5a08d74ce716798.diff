diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index fa6ae4bbbfd..40d303360c4 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -560,6 +560,21 @@ public void BeginBuild(BuildParameters parameters)
                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath("msbuild-cache");
                 }
 
+                // Launch the RAR node before the detoured launcher overrides the default node launcher.
+                if (_buildParameters.EnableRarNode)
+                {
+                    NodeLauncher nodeLauncher = ((IBuildComponentHost)this).GetComponent<NodeLauncher>(BuildComponentType.NodeLauncher);
+                    _ = Task.Run(() =>
+                    {
+                        RarNodeLauncher rarNodeLauncher = new(nodeLauncher);
+
+                        if (!rarNodeLauncher.Start())
+                        {
+                            _buildParameters.EnableRarNode = false;
+                        }
+                    });
+                }
+
 #if FEATURE_REPORTFILEACCESSES
                 if (_buildParameters.ReportFileAccesses)
                 {
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 1bfab1b0e52..9ae5c5f5bde 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -124,6 +124,8 @@ public class BuildParameters : ITranslatable
         private bool _enableNodeReuse = false;
 #endif
 
+        private bool _enableRarNode;
+
         /// <summary>
         /// The original process environment.
         /// </summary>
@@ -277,6 +279,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             _culture = other._culture;
             _defaultToolsVersion = other._defaultToolsVersion;
             _enableNodeReuse = other._enableNodeReuse;
+            _enableRarNode = other._enableRarNode;
             _buildProcessEnvironment = resetEnvironment
                 ? CommunicationsUtilities.GetEnvironmentVariables()
                 : other._buildProcessEnvironment != null
@@ -424,6 +427,15 @@ public bool EnableNodeReuse
             set => _enableNodeReuse = Environment.GetEnvironmentVariable("MSBUILDDISABLENODEREUSE") == "1" ? false : value;
         }
 
+        /// <summary>
+        /// When true, the ResolveAssemblyReferences task executes in an out-of-proc node which persists across builds.
+        /// </summary>
+        public bool EnableRarNode
+        {
+            get => _enableRarNode;
+            set => _enableRarNode = value;
+        }
+
         /// <summary>
         /// Gets an immutable collection of environment properties.
         /// </summary>
@@ -915,6 +927,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _defaultToolsVersion);
             translator.Translate(ref _disableInProcNode);
             translator.Translate(ref _enableNodeReuse);
+            translator.Translate(ref _enableRarNode);
             translator.TranslateProjectPropertyInstanceDictionary(ref _environmentProperties);
             /* No forwarding logger information sent here - that goes with the node configuration */
             translator.TranslateProjectPropertyInstanceDictionary(ref _globalProperties);
diff --git a/src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs b/src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs
new file mode 100644
index 00000000000..1c3d3b0208a
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs
@@ -0,0 +1,79 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal sealed class RarNodeLauncher
+    {
+        private readonly INodeLauncher _nodeLauncher;
+
+        private readonly string _pipeName;
+
+        internal RarNodeLauncher(INodeLauncher nodeLauncher)
+        {
+            _nodeLauncher = nodeLauncher;
+            _pipeName = NamedPipeUtil.GetRarNodePipeName(new(HandshakeOptions.None));
+        }
+
+        /// <summary>
+        /// Creates a new MSBuild process with the RAR nodemode.
+        /// </summary>
+        public bool Start()
+        {
+            if (IsRarNodeRunning())
+            {
+                CommunicationsUtilities.Trace("Existing RAR node found.");
+                return true;
+            }
+
+            CommunicationsUtilities.Trace("Launching RAR node...");
+
+            try
+            {
+                LaunchNode();
+            }
+            catch (NodeFailedToLaunchException ex)
+            {
+                CommunicationsUtilities.Trace("Failed to launch RAR node: {0}", ex);
+                return false;
+            }
+
+            return true;
+        }
+
+        private bool IsRarNodeRunning()
+        {
+            // Determine if the node is running by checking if the expected named pipe exists.
+            if (NativeMethodsShared.IsWindows)
+            {
+                const string NamedPipeRoot = @"\\.\pipe\";
+
+                // File.Exists() will crash the pipe server, as the underlying Windows APIs have undefined behavior
+                // when used with pipe objects. Enumerating the pipe directory avoids this issue.
+                IEnumerable<string> pipeNames = FileSystems.Default.EnumerateFiles(NamedPipeRoot);
+
+                return pipeNames.Contains(Path.Combine(NamedPipeRoot, _pipeName));
+            }
+            else
+            {
+                // On Unix, named pipes are implemented via sockets, and the pipe name is simply the file path.
+                return FileSystems.Default.FileExists(_pipeName);
+            }
+        }
+
+        private void LaunchNode()
+        {
+            string msbuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
+            string commandLineArgs = string.Join(" ", ["/nologo", "/nodemode:3"]);
+            _ = _nodeLauncher.Start(msbuildLocation, commandLineArgs, nodeId: 0);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index a262028f9f9..0cb83e34bed 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -940,6 +940,8 @@ public override bool LogsMessagesOfImportance(MessageImportance importance)
             /// <inheritdoc/>
             public override bool IsTaskInputLoggingEnabled => _taskHost._host.BuildParameters.LogTaskInputs;
 
+            public override bool IsOutOfProcRarNodeEnabled => _taskHost._host.BuildParameters.EnableRarNode;
+
 #if FEATURE_REPORTFILEACCESSES
             /// <summary>
             /// Reports a file access from a task.
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 8e8f26a1233..ae6988de3e4 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -7,7 +7,11 @@
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
+#if NET
 using System.IO;
+#else
+using Microsoft.IO;
+#endif
 using System.Linq;
 using System.Reflection;
 using System.Runtime.CompilerServices;
@@ -1369,7 +1373,7 @@ internal static object ExpandPropertyBody(
                 // if what we have is a function
                 if (!IsValidPropertyName(propertyBody))
                 {
-                    if (propertyBody.Contains(".") || propertyBody[0] == '[')
+                    if (propertyBody.Contains('.') || propertyBody[0] == '[')
                     {
                         if (BuildParameters.DebugExpansion)
                         {
@@ -1400,7 +1404,7 @@ internal static object ExpandPropertyBody(
                             return null;
                         }
                     }
-                    else if (propertyValue == null && propertyBody.Contains("[")) // a single property indexer
+                    else if (propertyValue == null && propertyBody.Contains('[')) // a single property indexer
                     {
                         int indexerStart = propertyBody.IndexOf('[');
                         int indexerEnd = propertyBody.IndexOf(']');
@@ -4092,7 +4096,7 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                         {
                             coercedArguments[n] = args[n].ToString().ToCharArray();
                         }
-                        else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string v && v.Contains("."))
+                        else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string v && v.Contains('.'))
                         {
                             Type enumType = parameters[n].ParameterType;
                             string typeLeafName = $"{enumType.Name}.";
diff --git a/src/Build/Evaluation/Expander/ArgumentParser.cs b/src/Build/Evaluation/Expander/ArgumentParser.cs
index c2dd113d5ff..2d9fa7954a0 100644
--- a/src/Build/Evaluation/Expander/ArgumentParser.cs
+++ b/src/Build/Evaluation/Expander/ArgumentParser.cs
@@ -3,8 +3,9 @@
 
 using System;
 using System.Globalization;
+
 #if NETFRAMEWORK
-using System.Linq;
+using Microsoft.IO;
 #endif
 
 namespace Microsoft.Build.Evaluation.Expander
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index b28ac113cd2..144e09f128a 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -361,6 +361,7 @@
     <Compile Include="BackEnd\Components\Communications\NodeInfo.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeProviderInProc.cs" />
+    <Compile Include="BackEnd\Components\Communications\RarNodeLauncher.cs" />
     <Compile Include="BackEnd\Components\IBuildComponent.cs" />
     <Compile Include="BackEnd\Components\IBuildComponentHost.cs" />
     <Compile Include="BackEnd\Components\Scheduler\IScheduler.cs" />
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index cf5b6ae383e..3df7fd23a1f 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -5,7 +5,11 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if NET
 using System.IO;
+#else
+using Microsoft.IO;
+#endif
 using System.Linq;
 using System.Text;
 using System.Text.RegularExpressions;
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 3bbcfe6f6f2..84e325912c2 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -140,7 +140,7 @@ internal static void ApplyChangeWave()
                 ConversionState = ChangeWaveConversionState.InvalidFormat;
                 _cachedWave = ChangeWaves.EnableAllFeatures;
             }
-            else if (_cachedWave == EnableAllFeatures || AllWaves.Contains(_cachedWave))
+            else if (_cachedWave == EnableAllFeatures || Array.IndexOf(AllWaves, _cachedWave) >= 0)
             {
                 ConversionState = ChangeWaveConversionState.Valid;
             }
@@ -172,7 +172,7 @@ internal static bool AreFeaturesEnabled(Version wave)
             ApplyChangeWave();
 
 #if DEBUG
-            Debug.Assert(_runningTests || AllWaves.Contains(wave), $"Change wave version {wave} is invalid");
+            Debug.Assert(_runningTests || Array.IndexOf(AllWaves, wave) >= 0, $"Change wave version {wave} is invalid");
 #endif
 
             return wave < _cachedWave;
diff --git a/src/Framework/EngineServices.cs b/src/Framework/EngineServices.cs
index 491604c7827..76b3ccb839c 100644
--- a/src/Framework/EngineServices.cs
+++ b/src/Framework/EngineServices.cs
@@ -20,6 +20,11 @@ public abstract class EngineServices
         /// </summary>
         public const int Version1 = 1;
 
+        /// <summary>
+        /// Version 2 with IsOutOfProcRarNodeEnabled().
+        /// </summary>
+        public const int Version2 = 2;
+
         /// <summary>
         /// Gets an explicit version of this class.
         /// </summary>
@@ -27,7 +32,7 @@ public abstract class EngineServices
         /// Must be incremented whenever new members are added. Derived classes should override
         /// the property to return the version actually being implemented.
         /// </remarks>
-        public virtual int Version => Version1;
+        public virtual int Version => Version2;
 
         /// <summary>
         /// Returns <see langword="true"/> if the given message importance is not guaranteed to be ignored by registered loggers.
@@ -48,5 +53,7 @@ public abstract class EngineServices
         /// This is a performance optimization allowing tasks to skip expensive double-logging.
         /// </remarks>
         public virtual bool IsTaskInputLoggingEnabled => throw new NotImplementedException();
+
+        public virtual bool IsOutOfProcRarNodeEnabled => throw new NotImplementedException();
     }
 }
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index e355761d9fd..da8da210b3c 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -121,6 +121,12 @@ public Traits()
         /// </summary>
         public readonly int DictionaryBasedItemRemoveThreshold = ParseIntFromEnvironmentVariableOrDefault("MSBUILDDICTIONARYBASEDITEMREMOVETHRESHOLD", 100);
 
+        /// <summary>
+        /// Launches a persistent RAR process.
+        /// </summary>
+        /// TODO: Replace with command line flag when feature is completed. The environment variable is intented to avoid exposing the flag early.
+        public readonly bool EnableRarNode = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildRarNode"));
+
         /// <summary>
         /// Name of environment variables used to enable MSBuild server.
         /// </summary>
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 56c53a3af4d..a21af6ba0a0 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -450,7 +450,7 @@ elementFormDefault="qualified">
             <xs:element name="BasicRuntimeChecks" />
             <xs:element name="RuntimeLibrary" />
             <xs:element name="FunctionLevelLinking" />
-            <xs:element name="FloatingPointModel " />
+            <xs:element name="FloatingPointModel" />
             <xs:element name="IntrinsicFunctions" />
             <xs:element name="PrecompiledHeaderFile"/>
             <xs:element name="MultiProcessorCompilation" />
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 77637578738..f9006a5b5b2 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -35,6 +35,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Tasks.AssemblyDependency;
 using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
 using ConsoleLogger = Microsoft.Build.Logging.ConsoleLogger;
 using FileLogger = Microsoft.Build.Logging.FileLogger;
@@ -655,6 +656,9 @@ public static ExitType Execute(
         {
             DebuggerLaunchCheck();
 
+            // Resets the build completion event, signaling that a new build process is starting.
+            s_buildComplete.Reset();
+
             // Initialize new build telemetry and record start of this build, if not initialized already
             KnownTelemetry.PartialBuildTelemetry ??= new BuildTelemetry { StartAt = DateTime.UtcNow };
 
@@ -1536,6 +1540,11 @@ internal static bool BuildProject(
                         }
                     }
 
+                    if (Traits.Instance.EnableRarNode)
+                    {
+                        parameters.EnableRarNode = true;
+                    }
+
                     List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
 
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
@@ -3439,6 +3448,21 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches, bool
                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();
                     shutdownReason = node.Run(out nodeException);
                 }
+                else if (nodeModeNumber == 3)
+                {
+                    // The RAR service persists between builds, and will continue to process requests until terminated.
+                    OutOfProcRarNode rarNode = new();
+                    RarNodeShutdownReason rarShutdownReason = rarNode.Run(out nodeException, s_buildCancellationSource.Token);
+
+                    shutdownReason = rarShutdownReason switch
+                    {
+                        RarNodeShutdownReason.Complete => NodeEngineShutdownReason.BuildComplete,
+                        RarNodeShutdownReason.Error => NodeEngineShutdownReason.Error,
+                        RarNodeShutdownReason.AlreadyRunning => NodeEngineShutdownReason.Error,
+                        RarNodeShutdownReason.ConnectionTimedOut => NodeEngineShutdownReason.ConnectionFailed,
+                        _ => throw new ArgumentOutOfRangeException(nameof(rarShutdownReason), $"Unexpected value: {rarShutdownReason}"),
+                    };
+                }
                 else if (nodeModeNumber == 8)
                 {
                     // Since build function has to reuse code from *this* class and OutOfProcServerNode is in different assembly
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index fe93672dee4..13d4f1bef25 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -91,7 +91,12 @@ internal class Handshake
         protected readonly int fileVersionPrivate;
         private readonly int sessionId;
 
-        protected internal Handshake(HandshakeOptions nodeType)
+        internal Handshake(HandshakeOptions nodeType)
+            : this(nodeType, includeSessionId: true)
+        {
+        }
+
+        protected Handshake(HandshakeOptions nodeType, bool includeSessionId)
         {
             const int handshakeVersion = (int)CommunicationsUtilities.handshakeVersion;
 
@@ -110,8 +115,13 @@ protected internal Handshake(HandshakeOptions nodeType)
             fileVersionMinor = fileVersion.Minor;
             fileVersionBuild = fileVersion.Build;
             fileVersionPrivate = fileVersion.Revision;
-            using Process currentProcess = Process.GetCurrentProcess();
-            sessionId = currentProcess.SessionId;
+
+            // This reaches out to NtQuerySystemInformation. Due to latency, allow skipping for derived handshake if unused.
+            if (includeSessionId)
+            {
+                using Process currentProcess = Process.GetCurrentProcess();
+                sessionId = currentProcess.SessionId;
+            }
         }
 
         // This is used as a key, so it does not need to be human readable.
@@ -149,7 +159,7 @@ internal sealed class ServerNodeHandshake : Handshake
         public override byte? ExpectedVersionInFirstByte => null;
 
         internal ServerNodeHandshake(HandshakeOptions nodeType)
-            : base(nodeType)
+            : base(nodeType, includeSessionId: false)
         {
         }
 
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 9d97c12de8d..56f9e88cba2 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -6,7 +6,11 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if !NETFRAMEWORK
 using System.IO;
+#else
+using Microsoft.IO;
+#endif
 using System.Linq;
 using System.Text;
 using System.Text.RegularExpressions;
@@ -2633,13 +2637,13 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent
 
             // Ensure that the prefix match wasn't to a distinct directory, so that
             // x\y\prefix doesn't falsely match x\y\prefixmatch.
-            if (directorySeparatorCharacters.Contains(possibleParent[possibleParent.Length - 1]))
+            if (Array.IndexOf(directorySeparatorCharacters, possibleParent[possibleParent.Length - 1]) >= 0)
             {
                 return true;
             }
             else
             {
-                return directorySeparatorCharacters.Contains(possibleChild[possibleParent.Length]);
+                return Array.IndexOf(directorySeparatorCharacters, possibleChild[possibleParent.Length]) >= 0;
             }
         }
 
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index 42b6a8d6ab6..b72e32efb4c 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -200,6 +200,16 @@ internal enum NodePacketType : byte
         /// </summary>
         ProcessReport,
 
+        /// <summary>
+        /// A request contains the inputs to the RAR task.
+        /// </summary>
+        RarNodeExecuteRequest,
+
+        /// <summary>
+        /// A request contains the outputs and log events of a completed RAR task.
+        /// </summary>
+        RarNodeExecuteResponse,
+
         /// <summary>
         /// Command in form of MSBuild command line for server node - MSBuild Server.
         /// Keep this enum value constant intact as this is part of contract with dotnet CLI
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index 25094e59035..0b85b05bacd 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.IO;
+using Microsoft.Build.Internal;
 
 namespace Microsoft.Build.Shared
 {
@@ -42,5 +43,11 @@ internal static string GetPlatformSpecificPipeName(string pipeName)
                 return pipeName;
             }
         }
+
+        internal static string GetRarNodePipeName(ServerNodeHandshake handshake)
+            => GetPlatformSpecificPipeName($"MSBuildRarNode-{handshake.ComputeHash()}");
+
+        internal static string GetRarNodeEndpointPipeName(ServerNodeHandshake handshake)
+            => GetPlatformSpecificPipeName($"MSBuildRarNodeEndpoint-{handshake.ComputeHash()}");
     }
 }
diff --git a/src/Shared/NodePipeBase.cs b/src/Shared/NodePipeBase.cs
index fd1d08efe9c..2ee91e536c1 100644
--- a/src/Shared/NodePipeBase.cs
+++ b/src/Shared/NodePipeBase.cs
@@ -69,6 +69,14 @@ protected NodePipeBase(string pipeName, Handshake handshake)
             _writeTranslator = BinaryTranslator.GetWriteTranslator(_writeBuffer);
         }
 
+        /// <summary>
+        /// Gets a value indicating whether the pipe is in the connected state. Note that this is not real-time and
+        /// will only be updated when an operation on the pipe fails.
+        /// When a pipe is broken, Disconnect() must be called for the pipe to be reused - otherwise any attempts to
+        /// connect to a new client will throw.
+        /// </summary>
+        internal bool IsConnected => NodeStream.IsConnected;
+
         protected abstract PipeStream NodeStream { get; }
 
         protected string PipeName { get; }
diff --git a/src/Shared/NodePipeServer.cs b/src/Shared/NodePipeServer.cs
index eb932d973aa..0b9855f2a1c 100644
--- a/src/Shared/NodePipeServer.cs
+++ b/src/Shared/NodePipeServer.cs
@@ -47,7 +47,14 @@ internal NodePipeServer(string pipeName, Handshake handshake, int maxNumberOfSer
             // SIDs or the client will reject this server.  This is used to avoid attacks where a
             // hacked server creates a less restricted pipe in an attempt to lure us into using it and
             // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
-            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, PipeAccessRights.ReadWrite, AccessControlType.Allow);
+            PipeAccessRights pipeAccessRights = PipeAccessRights.ReadWrite;
+            if (maxNumberOfServerInstances > 1)
+            {
+                // Multi-instance pipes will fail without this flag.
+                pipeAccessRights |= PipeAccessRights.CreateNewInstance;
+            }
+
+            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, pipeAccessRights, AccessControlType.Allow);
             PipeSecurity security = new();
             security.AddAccessRule(rule);
             security.SetOwner(rule.IdentityReference);
diff --git a/src/Tasks/AssemblyDependency/Node/OutOfProcRarClient.cs b/src/Tasks/AssemblyDependency/Node/OutOfProcRarClient.cs
new file mode 100644
index 00000000000..4cfd2f053ee
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/OutOfProcRarClient.cs
@@ -0,0 +1,70 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Implements a client for sending the ResolveAssemblyReference task to an out-of-proc node.
+    /// This is intended to be reused for all RAR tasks across a single build.
+    /// </summary>
+    internal sealed class OutOfProcRarClient : IDisposable
+    {
+        private readonly NodePipeClient _pipeClient;
+
+        private OutOfProcRarClient()
+        {
+            ServerNodeHandshake handshake = new(HandshakeOptions.None);
+            _pipeClient = new NodePipeClient(NamedPipeUtil.GetRarNodeEndpointPipeName(handshake), handshake);
+
+            NodePacketFactory packetFactory = new();
+            packetFactory.RegisterPacketHandler(NodePacketType.RarNodeExecuteResponse, RarNodeExecuteResponse.FactoryForDeserialization, null);
+            _pipeClient.RegisterPacketFactory(packetFactory);
+        }
+
+        public void Dispose() => _pipeClient.Dispose();
+
+        internal static OutOfProcRarClient GetInstance(IBuildEngine10 buildEngine)
+        {
+            // Create a single cached instance for this build.
+            const string OutOfProcRarClientKey = "OutOfProcRarClient";
+
+            // We want to reuse the pipe client across all RAR invocations within a build, but release the connection once
+            // the MSBuild node is idle. Using RegisteredTaskObjectLifetime.Build ensures that the RAR client is disposed between
+            // builds, freeing the server to run other requests.
+            OutOfProcRarClient rarClient = (OutOfProcRarClient)buildEngine.GetRegisteredTaskObject(OutOfProcRarClientKey, RegisteredTaskObjectLifetime.Build);
+
+            if (rarClient == null)
+            {
+                rarClient = new OutOfProcRarClient();
+                buildEngine.RegisterTaskObject(OutOfProcRarClientKey, rarClient, RegisteredTaskObjectLifetime.Build, allowEarlyCollection: false);
+                CommunicationsUtilities.Trace("Initialized new RAR client.");
+            }
+
+            return rarClient;
+        }
+
+        internal bool Execute(ResolveAssemblyReference rarTask)
+        {
+            // This should only be true at the start of a build.
+            if (!_pipeClient.IsConnected)
+            {
+                // Don't set a timeout since the build manager already blocks until the server is running.
+                _pipeClient.ConnectToServer(0);
+            }
+
+            // TODO: Use RAR task to create the request packet.
+            _pipeClient.WritePacket(new RarNodeExecuteRequest());
+
+            // TODO: Use response packet to set RAR task outputs.
+            _ = (RarNodeExecuteResponse)_pipeClient.ReadPacket();
+
+            return true;
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs
new file mode 100644
index 00000000000..12d03329609
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs
@@ -0,0 +1,179 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Implements a persistent node for the ResolveAssemblyReferences task.
+    /// This manages the lifecycle of the multi-instance pipe server which executes RAR requests
+    /// and does not invoke the task itself.
+    /// </summary>
+    public sealed class OutOfProcRarNode
+    {
+        private readonly ServerNodeHandshake _handshake = new(HandshakeOptions.None);
+
+        private readonly int _maxNumberOfConcurrentTasks;
+
+        public OutOfProcRarNode()
+            : this(Environment.ProcessorCount)
+        {
+        }
+
+        public OutOfProcRarNode(int maxNumberOfConcurrentTasks) => _maxNumberOfConcurrentTasks = maxNumberOfConcurrentTasks;
+
+        /// <summary>
+        /// Starts the node and begins processing RAR execution requests until cancelled.
+        /// </summary>
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
+        /// <param name="cancellationToken">A cancellation token to observe while running the node loop.</param>
+        /// <returns>The reason for the node shutdown.</returns>
+        public RarNodeShutdownReason Run(out Exception? shutdownException, CancellationToken cancellationToken = default)
+        {
+            RarNodeShutdownReason shutdownReason;
+            shutdownException = null;
+
+            try
+            {
+                shutdownReason = RunNodeAsync(cancellationToken).GetAwaiter().GetResult();
+            }
+            catch (OperationCanceledException)
+            {
+                // Consider cancellation as an intentional shutdown of the node.
+                shutdownReason = RarNodeShutdownReason.Complete;
+            }
+            catch (UnauthorizedAccessException ex)
+            {
+                // Access to the path is denied if the named pipe already exists or is owned by a different user.
+                shutdownException = new InvalidOperationException("RAR node is already running.", ex);
+                shutdownReason = RarNodeShutdownReason.AlreadyRunning;
+            }
+            catch (Exception ex)
+            {
+                shutdownException = ex;
+                shutdownReason = RarNodeShutdownReason.Error;
+            }
+
+            if (shutdownException == null)
+            {
+                CommunicationsUtilities.Trace("Shutting down with reason: {0}");
+            }
+            else
+            {
+                CommunicationsUtilities.Trace("Shutting down with reason: {0}, and exception: {1}", shutdownReason, shutdownException);
+            }
+
+            return shutdownReason;
+        }
+
+        private async Task<RarNodeShutdownReason> RunNodeAsync(CancellationToken cancellationToken)
+        {
+            // The RAR node uses two sets of pipe servers:
+            // 1. A single instance pipe to manage the lifecycle of the node.
+            // 2. A multi-instance pipe to execute concurrent RAR requests.
+            // Because multi-instance pipes can live across multiple processes, we can't rely on the instance cap to preven
+            // multiple nodes from running in the event of a race condition.
+            // This also simplifies tearing down all active pipe servers when shutdown is requested.
+            using NodePipeServer pipeServer = new(NamedPipeUtil.GetRarNodePipeName(_handshake), _handshake);
+
+            NodePacketFactory packetFactory = new();
+            packetFactory.RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, null);
+            pipeServer.RegisterPacketFactory(packetFactory);
+
+            using CancellationTokenSource linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
+
+            Task nodeEndpointTasks = Task.Run(() => RunNodeEndpointsAsync(linkedCts.Token), linkedCts.Token);
+
+            // Run any static initializers which will add latency to the first task run.
+            _ = new ResolveAssemblyReference();
+
+            while (!cancellationToken.IsCancellationRequested)
+            {
+                LinkStatus linkStatus = await WaitForConnection(pipeServer, cancellationToken);
+
+                if (linkStatus == LinkStatus.Active)
+                {
+                    NodeBuildComplete buildComplete = (NodeBuildComplete)pipeServer.ReadPacket();
+
+                    if (!buildComplete.PrepareForReuse)
+                    {
+                        break;
+                    }
+                }
+
+                pipeServer.Disconnect();
+            }
+
+            // Gracefully shutdown the node endpoints.
+            linkedCts.Cancel();
+
+            try
+            {
+                await nodeEndpointTasks;
+            }
+            catch (OperationCanceledException)
+            {
+                // Ignore since cancellation is expected.
+            }
+
+            return RarNodeShutdownReason.Complete;
+
+            // WaitForConnection does not currently accept cancellation, so use Wait to watch for cancellation.
+            // Cancellation is only expected when MSBuild is gracefully shutting down the node or running in unit tests.
+            static async Task<LinkStatus> WaitForConnection(NodePipeServer pipeServer, CancellationToken cancellationToken)
+            {
+                Task<LinkStatus> linkStatusTask = Task.Run(pipeServer.WaitForConnection);
+                linkStatusTask.Wait(cancellationToken);
+                return await linkStatusTask;
+            }
+        }
+
+        private async Task RunNodeEndpointsAsync(CancellationToken cancellationToken)
+        {
+            // Setup data shared between all endpoints.
+            string pipeName = NamedPipeUtil.GetRarNodeEndpointPipeName(_handshake);
+            NodePacketFactory packetFactory = new();
+            packetFactory.RegisterPacketHandler(NodePacketType.RarNodeExecuteRequest, RarNodeExecuteRequest.FactoryForDeserialization, null);
+
+            OutOfProcRarNodeEndpoint[] endpoints = new OutOfProcRarNodeEndpoint[_maxNumberOfConcurrentTasks];
+
+            // Validate all endpoint pipe handles successfully initialize before running any read loops.
+            // This allows us to bail out in the event where we can't control every pipe instance.
+            for (int i = 0; i < endpoints.Length; i++)
+            {
+                endpoints[i] = new OutOfProcRarNodeEndpoint(
+                        endpointId: i + 1,
+                        pipeName,
+                        _handshake,
+                        _maxNumberOfConcurrentTasks,
+                        packetFactory);
+            }
+
+            Task[] endpointTasks = new Task[endpoints.Length];
+
+            for (int i = 0; i < endpoints.Length; i++)
+            {
+                // Avoid capturing the indexer in the closure.
+                OutOfProcRarNodeEndpoint endpoint = endpoints[i];
+                endpointTasks[i] = Task.Run(() => endpoint.RunAsync(cancellationToken), cancellationToken);
+            }
+
+            CommunicationsUtilities.Trace("{0} RAR endpoints started.", _maxNumberOfConcurrentTasks);
+
+            await Task.WhenAll(endpointTasks);
+
+            foreach (OutOfProcRarNodeEndpoint endpoint in endpoints)
+            {
+                endpoint.Dispose();
+            }
+
+            CommunicationsUtilities.Trace("All endpoints successfully stopped. Exiting.");
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs
new file mode 100644
index 00000000000..666ce49b5c5
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs
@@ -0,0 +1,97 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Implements a single instance of a pipe server which executes the ResolveAssemblyReference task.
+    /// </summary>
+    internal sealed class OutOfProcRarNodeEndpoint : IDisposable
+    {
+        private readonly int _endpointId;
+
+        private readonly NodePipeServer _pipeServer;
+
+        internal OutOfProcRarNodeEndpoint(
+            int endpointId,
+            string pipeName,
+            ServerNodeHandshake handshake,
+            int maxNumberOfServerInstances,
+            NodePacketFactory packetFactory)
+        {
+            _endpointId = endpointId;
+            _pipeServer = new NodePipeServer(pipeName, handshake, maxNumberOfServerInstances);
+            _pipeServer.RegisterPacketFactory(packetFactory);
+        }
+
+        public void Dispose() => _pipeServer.Dispose();
+
+        internal async Task RunAsync(CancellationToken cancellationToken = default)
+        {
+            CommunicationsUtilities.Trace("({0}) Starting RAR endpoint.", _endpointId);
+
+            try
+            {
+                await RunInternalAsync(cancellationToken);
+            }
+            catch (OperationCanceledException)
+            {
+                // Swallow cancellation excpetions for now. We're using this as a simple way to gracefully shutdown the
+                // endpoint, instead of having to implement separate Start / Stop methods and deferring to the caller.
+                // Can reevaluate if we need more granular control over cancellation vs shutdown.
+                CommunicationsUtilities.Trace("({0}) RAR endpoint stopped due to cancellation.", _endpointId);
+            }
+        }
+
+        private async Task RunInternalAsync(CancellationToken cancellationToken)
+        {
+            while (!cancellationToken.IsCancellationRequested)
+            {
+                while (!_pipeServer.IsConnected)
+                {
+                    _ = _pipeServer.WaitForConnection();
+                }
+
+                CommunicationsUtilities.Trace("({0}) Received RAR request.", _endpointId);
+
+                try
+                {
+                    INodePacket packet = await _pipeServer.ReadPacketAsync(cancellationToken);
+
+                    if (packet.Type == NodePacketType.NodeShutdown)
+                    {
+                        // Although the client has already disconnected, it is still necessary to Diconnect() so the
+                        // pipe can transition into PipeState.Disonnected, which is treated as an intentional pipe break.
+                        // Otherwise, all future operations on the pipe will throw an exception.
+                        CommunicationsUtilities.Trace("({0}) RAR client disconnected.", _endpointId);
+                        _pipeServer.Disconnect();
+                        continue;
+                    }
+
+                    RarNodeExecuteRequest request = (RarNodeExecuteRequest)packet;
+
+                    // TODO: Use request packet to set inputs on the RAR task.
+                    ResolveAssemblyReference rarTask = new();
+
+                    // TODO: bool success = rarTask.ExecuteInProcess();
+                    // TODO: Use RAR task outputs to create response packet.
+                    await _pipeServer.WritePacketAsync(new RarNodeExecuteResponse(), cancellationToken);
+
+                    CommunicationsUtilities.Trace("({0}) Completed RAR request.", _endpointId);
+                }
+                catch (Exception e) when (e is not OperationCanceledException)
+                {
+                    CommunicationsUtilities.Trace("({0}) Exception while executing RAR request: {1}", _endpointId, e);
+                }
+            }
+
+            _pipeServer.Disconnect();
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/RarNodeExecuteRequest.cs b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteRequest.cs
new file mode 100644
index 00000000000..a129bd56748
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteRequest.cs
@@ -0,0 +1,23 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    internal sealed class RarNodeExecuteRequest : INodePacket
+    {
+        public NodePacketType Type => NodePacketType.RarNodeExecuteRequest;
+
+        public void Translate(ITranslator translator)
+        {
+        }
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            RarNodeExecuteRequest request = new();
+            request.Translate(translator);
+            return request;
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/RarNodeExecuteResponse.cs b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteResponse.cs
new file mode 100644
index 00000000000..9611897fc82
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteResponse.cs
@@ -0,0 +1,23 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    internal sealed class RarNodeExecuteResponse : INodePacket
+    {
+        public NodePacketType Type => NodePacketType.RarNodeExecuteResponse;
+
+        public void Translate(ITranslator translator)
+        {
+        }
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            RarNodeExecuteResponse response = new();
+            response.Translate(translator);
+            return response;
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/RarNodeShutdownReason.cs b/src/Tasks/AssemblyDependency/Node/RarNodeShutdownReason.cs
new file mode 100644
index 00000000000..67b37177e4a
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/RarNodeShutdownReason.cs
@@ -0,0 +1,31 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Reasons why the RAR node shutdown.
+    /// </summary>
+    public enum RarNodeShutdownReason
+    {
+        /// <summary>
+        /// The RAR node was instructed to terminate and gracefully shut down.
+        /// </summary>
+        Complete,
+
+        /// <summary>
+        /// The RAR node is already running.
+        /// </summary>
+        AlreadyRunning,
+
+        /// <summary>
+        /// The RAR node timed out waiting for a connection.
+        /// </summary>
+        ConnectionTimedOut,
+
+        /// <summary>
+        /// The RAR node encountered an unrecoverable error.
+        /// </summary>
+        Error,
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 8a42269ce14..21c3811e476 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -16,6 +16,7 @@
 
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyDependency;
@@ -920,6 +921,11 @@ public string[] FullFrameworkFolders
 
         public bool FailIfNotIncremental { get; set; }
 
+        /// <summary>
+        /// Allow the task to run on the out-of-proc node if enabled for this build.
+        /// </summary>
+        public bool AllowOutOfProcNode { get; set; }
+
         /// <summary>
         /// This is a list of all primary references resolved to full paths.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
@@ -3243,6 +3249,25 @@ private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, SystemPr
         /// <returns>True if there was success.</returns>
         public override bool Execute()
         {
+            if (AllowOutOfProcNode
+                && BuildEngine is IBuildEngine10 buildEngine10
+                && buildEngine10.EngineServices.IsOutOfProcRarNodeEnabled)
+            {
+                try
+                {
+#pragma warning disable CA2000 // The OutOfProcRarClient is disposable but its disposal is handled by RegisterTaskObject.
+                    _ = OutOfProcRarClient.GetInstance(buildEngine10).Execute(this);
+#pragma warning restore CA2000 // Dispose objects before losing scope
+                    CommunicationsUtilities.Trace("RAR out-of-proc test connection completed. Executing task in-proc.");
+                }
+                catch (Exception ex)
+                {
+                    // If the out-of-proc connection failed, fall back to in-proc.
+                    // TODO: Disable out-of-proc for the remainder of the build if any connection fails.
+                    CommunicationsUtilities.Trace("RAR out-of-proc connection failed, failing back to in-proc. Exception: {0}", ex);
+                }
+            }
+
             return Execute(
                 p => FileUtilities.FileExistsNoThrow(p),
                 p => FileUtilities.DirectoryExistsNoThrow(p),
@@ -3265,7 +3290,6 @@ public override bool Execute()
                     => AssemblyInformation.IsWinMDFile(fullPath, getAssemblyRuntimeVersion, fileExists, out imageRuntimeVersion, out isManagedWinmd),
                 p => ReferenceTable.ReadMachineTypeFromPEHeader(p));
         }
-
         #endregion
     }
 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index a518f22fe8b..48d3df90c79 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -34,6 +34,20 @@
     <!-- Binary serialization by ITranslatable -->
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
+
+    <!-- Node communication -->
+    <Compile Include="..\Shared\CommunicationsUtilities.cs" />
+    <Compile Include="..\Shared\INodeEndpoint.cs" />
+    <Compile Include="..\Shared\INodePacket.cs" />
+    <Compile Include="..\Shared\INodePacketFactory.cs" />
+    <Compile Include="..\Shared\INodePacketHandler.cs" />
+    <Compile Include="..\Shared\NodeBuildComplete.cs" />
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
+    <Compile Include="..\Shared\NodePacketFactory.cs" />
+    <Compile Include="..\Shared\NodePipeBase.cs" />
+    <Compile Include="..\Shared\NodePipeClient.cs" />
+    <Compile Include="..\Shared\NodePipeServer.cs" />
+    <Compile Include="..\Shared\NodeShutdown.cs" />
   </ItemGroup>
   <ItemGroup>
     <!-- Source Files -->
@@ -183,6 +197,12 @@
     <Compile Include="AssemblyDependency\UnificationVersion.cs" />
     <Compile Include="AssemblyDependency\UnifiedAssemblyName.cs" />
     <Compile Include="AssemblyDependency\WarnOrErrorOnTargetArchitectureMismatchBehavior.cs" />
+    <Compile Include="AssemblyDependency\Node\OutOfProcRarClient.cs" />
+    <Compile Include="AssemblyDependency\Node\OutOfProcRarNode.cs" />
+    <Compile Include="AssemblyDependency\Node\OutOfProcRarNodeEndpoint.cs" />
+    <Compile Include="AssemblyDependency\Node\RarNodeExecuteRequest.cs" />
+    <Compile Include="AssemblyDependency\Node\RarNodeExecuteResponse.cs" />
+    <Compile Include="AssemblyDependency\Node\RarNodeShutdownReason.cs" />
     <Compile Include="AssemblyFolder.cs" />
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="AssemblyRemapping.cs" />
@@ -676,6 +696,7 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="Microsoft.Win32.Registry" />
     <PackageReference Include="System.Reflection.Metadata" />
+    <PackageReference Include="System.Threading.Channels" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 0c4ce55ad13..b0ffa3fa5b6 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -2385,6 +2385,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <ResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>
     </PropertyGroup>
 
+    <PropertyGroup>
+      <AllowResolveAssemblyReferencesOutOfProcNode Condition="'$(AllowResolveAssemblyReferencesOutOfProcNode)' == ''">false</AllowResolveAssemblyReferencesOutOfProcNode>
+    </PropertyGroup>
+
     <!-- Make an App.Config item that exists when AutoUnify is false. -->
     <ItemGroup>
       <_ResolveAssemblyReferencesApplicationConfigFileForExes Include="@(AppConfigWithTargetPath)" Condition="'$(AutoGenerateBindingRedirects)'=='true' or '$(AutoUnifyAssemblyReferences)'=='false'"/>
@@ -2476,6 +2480,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         OutputUnresolvedAssemblyConflicts="$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)"
         NonCultureResourceDirectories="@(NonCultureResourceDirectory)"
         EnableCustomCulture="$(EnableCustomCulture)"
+        AllowOutOfProcNode="$(AllowResolveAssemblyReferencesOutOfProcNode)"
         Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!='' or '@(_ExplicitReference)' != ''"
         >
 
@@ -2580,24 +2585,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <AppConfig Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
     </PropertyGroup>
 
-    <PropertyGroup>
-      <ConfigFileExists Condition="Exists('@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')')">true</ConfigFileExists>
-      <HasNoBindingRedirects Condition="'@(SuggestedBindingRedirects)' == ''">true</HasNoBindingRedirects>
-    </PropertyGroup>
-
-    <!-- Overwrites .config file with a App.config content if RAR returned empty @(SuggestedBindingRedirects). -->
-    <Copy
-      SourceFiles="@(AppConfigWithTargetPath->'%(FullPath)')"
-      DestinationFiles="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-      SkipUnchangedFiles="true"
-      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'">
-      <Output TaskParameter="CopiedFiles" ItemName="FileWrites"/>
-    </Copy>
-    <Touch
-      Files="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-      AlwaysCreate="true"
-      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'"/>
-
     <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
       <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
       <AppConfigWithTargetPath Include="$(AppConfig)">
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index f2fbe04a6b2..f9eb9441801 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -6,6 +6,11 @@
 using System.Linq;
 using System.Text;
 using System.Text.RegularExpressions;
+
+#if NETFRAMEWORK
+using Microsoft.IO;
+#endif
+
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.XamlTypes;
 using Microsoft.Build.Shared;
