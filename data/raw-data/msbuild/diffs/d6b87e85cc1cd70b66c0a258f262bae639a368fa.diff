diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 3bc916aa4bb..5033b018ce7 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.Linq;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Exceptions;
@@ -523,6 +524,20 @@ public void SolutionsCanInjectEdgesIntoTheProjectGraph(Dictionary<int, int[]> ed
 
             var graphFromSolutionEdges = graphFromSolution.TestOnly_Edges.TestOnly_AsConfigurationMetadata();
 
+            // Solutions add the CurrentSolutionConfigurationContents global property for platform resolution
+            foreach ((ConfigurationMetadata, ConfigurationMetadata) graphFromSolutionEdge in graphFromSolutionEdges.Keys)
+            {
+                graphFromSolutionEdge.Item1.GlobalProperties.ShouldContainKey("CurrentSolutionConfigurationContents");
+                graphFromSolutionEdge.Item2.GlobalProperties.ShouldContainKey("CurrentSolutionConfigurationContents");
+            }
+
+            // Remove CurrentSolutionConfigurationContents for comparison purposes. This is done as a separate pass since some edges may be sharing an instance.
+            foreach ((ConfigurationMetadata, ConfigurationMetadata) graphFromSolutionEdge in graphFromSolutionEdges.Keys)
+            {
+                graphFromSolutionEdge.Item1.GlobalProperties.Remove("CurrentSolutionConfigurationContents");
+                graphFromSolutionEdge.Item2.GlobalProperties.Remove("CurrentSolutionConfigurationContents");
+            }
+
             // Original edges get preserved.
             foreach (var graphEdge in graphEdges)
             {
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 644738a81fe..57cc996a27c 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
@@ -674,6 +675,130 @@ public void ConstructGraphWithDifferentEntryPointsAndGraphRoots()
             }
         }
 
+        [Fact]
+        public void ConstructGraphWithSolution()
+        {
+            // This test exercises two key features of solution-based builds from AssignProjectConfiguration:
+            // 1. Adding synthetic project references
+            // 2. Resolving project configuration based on the sln
+            using (var env = TestEnvironment.Create())
+            {
+                const string SolutionFileContents = """
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 17
+                    VisualStudioVersion = 17.0.31903.59
+                    MinimumVisualStudioVersion = 17.0.31903.59
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project1", "Project1.csproj", "{8761499A-7280-43C4-A32F-7F41C47CA6DF}"
+                        ProjectSection(ProjectDependencies) = postProject
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98} = {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}
+                        EndProjectSection
+                    EndProject
+                    Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Project2", "Project2.vcxproj", "{D638A8EF-3A48-45F2-913C-88B29FED03CB}"
+                    EndProject
+                    Project("{13B669BE-BB05-4DDF-9536-439F39A36129}") = "Project3", "Project3.vcxproj", "{52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|Win32 = Debug|Win32
+                            Debug|x64 = Debug|x64
+                            Debug|x86 = Debug|x86
+                            Release|Win32 = Release|Win32
+                            Release|x64 = Release|x64
+                            Release|x86 = Release|x86
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|Win32.ActiveCfg = Debug|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|Win32.Build.0 = Debug|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.ActiveCfg = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.Build.0 = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x86.ActiveCfg = Debug|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x86.Build.0 = Debug|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|Win32.ActiveCfg = Release|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|Win32.Build.0 = Release|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.ActiveCfg = Release|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.Build.0 = Release|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x86.ActiveCfg = Release|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x86.Build.0 = Release|x86
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Debug|Win32.ActiveCfg = Debug|Win32
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Debug|Win32.Build.0 = Debug|Win32
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Debug|x64.ActiveCfg = Debug|x64
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Debug|x64.Build.0 = Debug|x64
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Release|Win32.ActiveCfg = Release|Win32
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Release|Win32.Build.0 = Release|Win32
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Release|x64.ActiveCfg = Release|x64
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Release|x64.Build.0 = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|Win32.ActiveCfg = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|Win32.Build.0 = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x64.ActiveCfg = Debug|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x64.Build.0 = Debug|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x86.ActiveCfg = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x86.Build.0 = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|Win32.ActiveCfg = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|Win32.Build.0 = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.ActiveCfg = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.Build.0 = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.ActiveCfg = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.Build.0 = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|Win32.ActiveCfg = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|Win32.Build.0 = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x64.ActiveCfg = Debug|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x64.Build.0 = Debug|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x86.ActiveCfg = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x86.Build.0 = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|Win32.ActiveCfg = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|Win32.Build.0 = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.ActiveCfg = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.Build.0 = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.ActiveCfg = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.Build.0 = Release|Win32
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                    EndGlobal
+                    """;
+                TransientTestFile slnFile = env.CreateFile(@"Solution.sln", SolutionFileContents);
+                SolutionFile solutionFile = SolutionFile.Parse(slnFile.Path);
+
+                ProjectRootElement project1Xml = ProjectRootElement.Create();
+
+                // Project 1 depends on Project 2 using ProjectReference but there is a sln-based dependency defined on Project 3 as well.
+                project1Xml.AddItem("ProjectReference", "Project2.vcxproj");
+
+                ProjectRootElement project2Xml = ProjectRootElement.Create();
+                ProjectRootElement project3Xml = ProjectRootElement.Create();
+
+                string project1Path = Path.Combine(env.DefaultTestDirectory.Path, "Project1.csproj");
+                string project2Path = Path.Combine(env.DefaultTestDirectory.Path, "Project2.vcxproj");
+                string project3Path = Path.Combine(env.DefaultTestDirectory.Path, "Project3.vcxproj");
+
+                project1Xml.Save(project1Path);
+                project2Xml.Save(project2Path);
+                project3Xml.Save(project3Path);
+
+                var projectGraph = new ProjectGraph(slnFile.Path);
+                projectGraph.EntryPointNodes.Count.ShouldBe(3);
+                projectGraph.GraphRoots.Count.ShouldBe(1);
+                projectGraph.GraphRoots.First().ProjectInstance.FullPath.ShouldBe(project1Path);
+                projectGraph.ProjectNodes.Count.ShouldBe(3);
+
+                ProjectGraphNode project1Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project1Path);
+                project1Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project1Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                project1Node.ProjectReferences.Count.ShouldBe(2);
+
+                ProjectGraphNode project2Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project2Path);
+                project2Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project2Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
+                project2Node.ProjectReferences.Count.ShouldBe(0);
+
+                ProjectGraphNode project3Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project3Path);
+                project3Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project3Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
+                project3Node.ProjectReferences.Count.ShouldBe(0);
+            }
+        }
+
         [Fact]
         public void GetTargetListsAggregatesFromMultipleEdges()
         {
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 1e11e628e65..7b3d3c05b43 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -239,6 +239,23 @@ internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement
             msbuildProject.AppendChild(solutionConfigurationProperties);
             solutionConfigurationProperties.Condition = GetConditionStringForConfiguration(solutionConfiguration);
 
+            string escapedSolutionConfigurationContents = GetSolutionConfiguration(solutionFile, solutionConfiguration);
+
+            solutionConfigurationProperties.AddProperty("CurrentSolutionConfigurationContents", escapedSolutionConfigurationContents);
+
+            msbuildProject.AddItem(
+                "SolutionConfiguration",
+                solutionConfiguration.FullName,
+                new Dictionary<string, string>
+                {
+                    { "Configuration", solutionConfiguration.ConfigurationName },
+                    { "Platform", solutionConfiguration.PlatformName },
+                    { "Content", escapedSolutionConfigurationContents },
+                });
+        }
+
+        internal static string GetSolutionConfiguration(SolutionFile solutionFile, SolutionConfigurationInSolution solutionConfiguration)
+        {
             var solutionConfigurationContents = new StringBuilder(1024);
             var settings = new XmlWriterSettings
             {
@@ -292,19 +309,8 @@ internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement
                 xw.WriteEndElement(); // </SolutionConfiguration>
             }
 
-            var escapedSolutionConfigurationContents = EscapingUtilities.Escape(solutionConfigurationContents.ToString());
-
-            solutionConfigurationProperties.AddProperty("CurrentSolutionConfigurationContents", escapedSolutionConfigurationContents);
-
-            msbuildProject.AddItem(
-                "SolutionConfiguration",
-                solutionConfiguration.FullName,
-                new Dictionary<string, string>
-                {
-                    { "Configuration", solutionConfiguration.ConfigurationName },
-                    { "Platform", solutionConfiguration.PlatformName },
-                    { "Content", escapedSolutionConfigurationContents },
-                });
+            string escapedSolutionConfigurationContents = EscapingUtilities.Escape(solutionConfigurationContents.ToString());
+            return escapedSolutionConfigurationContents;
         }
 
         /// <summary>
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index a226c96acdf..ec977d2f474 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -254,11 +254,15 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
 
             ErrorUtilities.VerifyThrowArgument(entryPoints.Count == 1, "StaticGraphAcceptsSingleSolutionEntryPoint");
 
-            var solutionEntryPoint = entryPoints.Single();
-            var solutionGlobalProperties = ImmutableDictionary.CreateRange(
+            ProjectGraphEntryPoint solutionEntryPoint = entryPoints.Single();
+            ImmutableDictionary<string, string>.Builder solutionGlobalPropertiesBuilder = ImmutableDictionary.CreateBuilder(
                 keyComparer: StringComparer.OrdinalIgnoreCase,
-                valueComparer: StringComparer.OrdinalIgnoreCase,
-                items: solutionEntryPoint.GlobalProperties ?? ImmutableDictionary<string, string>.Empty);
+                valueComparer: StringComparer.OrdinalIgnoreCase);
+
+            if (solutionEntryPoint.GlobalProperties != null)
+            {
+                solutionGlobalPropertiesBuilder.AddRange(solutionEntryPoint.GlobalProperties);
+            }
 
             var solution = SolutionFile.Parse(solutionEntryPoint.ProjectFile);
 
@@ -272,29 +276,39 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                         string.Join(";", solution.SolutionParserErrorCodes)));
             }
 
-            var projectsInSolution = GetBuildableProjects(solution);
+            IReadOnlyCollection<ProjectInSolution> projectsInSolution = GetBuildableProjects(solution);
+
+            SolutionConfigurationInSolution currentSolutionConfiguration = SelectSolutionConfiguration(solution, solutionEntryPoint.GlobalProperties);
+
+            string solutionConfigurationXml = SolutionProjectGenerator.GetSolutionConfiguration(solution, currentSolutionConfiguration);
+            solutionGlobalPropertiesBuilder["CurrentSolutionConfigurationContents"] = solutionConfigurationXml;
 
-            var currentSolutionConfiguration = SelectSolutionConfiguration(solution, solutionGlobalProperties);
+            // Project configurations are reused heavily, so cache the global properties for each
+            Dictionary<string, ImmutableDictionary<string, string>> globalPropertiesForProjectConfiguration = new(StringComparer.OrdinalIgnoreCase);
 
             var newEntryPoints = new List<ProjectGraphEntryPoint>(projectsInSolution.Count);
 
-            foreach (var project in projectsInSolution)
+            foreach (ProjectInSolution project in projectsInSolution)
             {
                 if (project.ProjectConfigurations.Count == 0)
                 {
                     continue;
                 }
 
-                var projectConfiguration = SelectProjectConfiguration(currentSolutionConfiguration, project.ProjectConfigurations);
+                ProjectConfigurationInSolution projectConfiguration = SelectProjectConfiguration(currentSolutionConfiguration, project.ProjectConfigurations);
 
                 if (projectConfiguration.IncludeInBuild)
                 {
-                    newEntryPoints.Add(
-                        new ProjectGraphEntryPoint(
-                            project.AbsolutePath,
-                            solutionGlobalProperties
-                                .SetItem("Configuration", projectConfiguration.ConfigurationName)
-                                .SetItem("Platform", projectConfiguration.PlatformName)));
+                    if (!globalPropertiesForProjectConfiguration.TryGetValue(projectConfiguration.FullName, out ImmutableDictionary<string, string> projectGlobalProperties))
+                    {
+                        solutionGlobalPropertiesBuilder["Configuration"] = projectConfiguration.ConfigurationName;
+                        solutionGlobalPropertiesBuilder["Platform"] = projectConfiguration.PlatformName;
+
+                        projectGlobalProperties = solutionGlobalPropertiesBuilder.ToImmutable();
+                        globalPropertiesForProjectConfiguration.Add(projectConfiguration.FullName, projectGlobalProperties);
+                    }
+
+                    newEntryPoints.Add(new ProjectGraphEntryPoint(project.AbsolutePath, projectGlobalProperties));
                 }
             }
 
@@ -307,13 +321,13 @@ IReadOnlyCollection<ProjectInSolution> GetBuildableProjects(SolutionFile solutio
                 return solutionFile.ProjectsInOrder.Where(p => p.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat && solutionFile.ProjectShouldBuild(p.RelativePath)).ToImmutableArray();
             }
 
-            SolutionConfigurationInSolution SelectSolutionConfiguration(SolutionFile solutionFile, ImmutableDictionary<string, string> globalProperties)
+            SolutionConfigurationInSolution SelectSolutionConfiguration(SolutionFile solutionFile, IDictionary<string, string> globalProperties)
             {
-                var solutionConfiguration = globalProperties.TryGetValue("Configuration", out string configuration)
+                var solutionConfiguration = globalProperties != null && globalProperties.TryGetValue("Configuration", out string configuration)
                     ? configuration
                     : solutionFile.GetDefaultConfigurationName();
 
-                var solutionPlatform = globalProperties.TryGetValue("Platform", out string platform)
+                var solutionPlatform = globalProperties != null && globalProperties.TryGetValue("Platform", out string platform)
                     ? platform
                     : solutionFile.GetDefaultPlatformName();
 
@@ -545,7 +559,6 @@ private void SubmitProjectForParsing(ConfigurationMetadata projectToEvaluate)
         {
             var referenceInfos = new List<ProjectInterpretation.ReferenceInfo>();
 
-
             foreach (var referenceInfo in _projectInterpretation.GetReferences(parsedProject.ProjectInstance, _projectCollection, _projectInstanceFactory))
             {
                 if (FileUtilities.IsSolutionFilename(referenceInfo.ReferenceConfiguration.ProjectFullPath))
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 23b0fc15ad9..93eb29782fd 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -6,8 +6,10 @@
 using System.Collections.Immutable;
 using System.Globalization;
 using System.Linq;
+using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
@@ -34,6 +36,8 @@ internal sealed class ProjectInterpretation
         private const string PlatformsMetadataName = "Platforms";
         private const string EnableDynamicPlatformResolutionMetadataName = "EnableDynamicPlatformResolution";
         private const string OverridePlatformNegotiationValue = "OverridePlatformNegotiationValue";
+        private const string ProjectMetadataName = "Project";
+        private const string ConfigurationMetadataName = "Configuration";
 
         private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
 
@@ -52,17 +56,7 @@ internal enum ProjectType
             NonMultitargeting,
         }
 
-        internal readonly struct ReferenceInfo
-        {
-            public ConfigurationMetadata ReferenceConfiguration { get; }
-            public ProjectItemInstance ProjectReferenceItem { get; }
-
-            public ReferenceInfo(ConfigurationMetadata referenceConfiguration, ProjectItemInstance projectReferenceItem)
-            {
-                ReferenceConfiguration = referenceConfiguration;
-                ProjectReferenceItem = projectReferenceItem;
-            }
-        }
+        internal readonly record struct ReferenceInfo(ConfigurationMetadata ReferenceConfiguration, ProjectItemInstance ProjectReferenceItem);
 
         private readonly struct TargetSpecification
         {
@@ -83,7 +77,7 @@ public TargetSpecification(string target, bool skipIfNonexistent)
             public bool SkipIfNonexistent { get; }
         }
 
-        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection _projectCollection, ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory)
+        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection projectCollection, ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory)
         {
             IEnumerable<ProjectItemInstance> projectReferenceItems;
             IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;
@@ -105,7 +99,14 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                     throw new ArgumentOutOfRangeException();
             }
 
-            foreach (var projectReferenceItem in projectReferenceItems)
+            SolutionConfiguration solutionConfiguration = null;
+            string solutionConfigurationXml = requesterInstance.GetPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents);
+            if (!string.IsNullOrWhiteSpace(solutionConfigurationXml))
+            {
+                solutionConfiguration = new SolutionConfiguration(solutionConfigurationXml);
+            }
+
+            foreach (ProjectItemInstance projectReferenceItem in projectReferenceItems)
             {
                 if (!String.IsNullOrEmpty(projectReferenceItem.GetMetadataValue(ToolsVersionMetadataName)))
                 {
@@ -118,22 +119,55 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                             requesterInstance.FullPath));
                 }
 
-                var projectReferenceFullPath = projectReferenceItem.GetMetadataValue(FullPathMetadataName);
+                string projectReferenceFullPath = projectReferenceItem.GetMetadataValue(FullPathMetadataName);
+                bool enableDynamicPlatformResolution = ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));
+
+                PropertyDictionary<ProjectPropertyInstance> referenceGlobalProperties = GetGlobalPropertiesForItem(
+                    projectReferenceItem,
+                    requesterInstance.GlobalPropertiesDictionary,
+                    // Only allow reuse in scenarios where we will not mutate the collection.
+                    // TODO: Should these mutations be moved to globalPropertiesModifiers in the future?
+                    allowCollectionReuse: solutionConfiguration == null && !enableDynamicPlatformResolution,
+                    globalPropertiesModifiers);
 
-                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReferenceItem, requesterInstance.GlobalPropertiesDictionary, ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)), globalPropertiesModifiers);
+                // Match what AssignProjectConfiguration does to resolve project references.
+                if (solutionConfiguration != null)
+                {
+                    string projectGuid = projectReferenceItem.GetMetadataValue(ProjectMetadataName);
+                    if (solutionConfiguration.TryGetProjectByGuid(projectGuid, out XmlElement projectElement)
+                        || solutionConfiguration.TryGetProjectByAbsolutePath(projectReferenceFullPath, out projectElement))
+                    {
+                        // Note: AssignProjectConfiguration sets various metadata on the ProjectReference item, but ultimately it just translates to the Configuration and Platform global properties on the MSBuild task.
+                        string projectConfiguration = projectElement.InnerText;
+                        string[] configurationPlatformParts = projectConfiguration.Split(SolutionConfiguration.ConfigPlatformSeparator[0]);
+                        SetProperty(referenceGlobalProperties, ConfigurationMetadataName, configurationPlatformParts[0]);
 
-                var requesterPlatform = "";
-                var requesterPlatformLookupTable = "";
+                        if (configurationPlatformParts.Length > 1)
+                        {
+                            SetProperty(referenceGlobalProperties, PlatformMetadataName, configurationPlatformParts[1]);
+                        }
+                        else
+                        {
+                            referenceGlobalProperties.Remove(PlatformMetadataName);
+                        }
+                    }
+                    else
+                    {
+                        referenceGlobalProperties.Remove(ConfigurationMetadataName);
+                        referenceGlobalProperties.Remove(PlatformMetadataName);
+                    }
+                }
 
-                if (!projectReferenceItem.HasMetadata(SetPlatformMetadataName) && ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
+                // Note: Dynamic platform resolution is not enabled for sln-based builds.
+                else if (!projectReferenceItem.HasMetadata(SetPlatformMetadataName) && enableDynamicPlatformResolution)
                 {
-                    requesterPlatform = requesterInstance.GetPropertyValue("Platform");
-                    requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
+                    string requesterPlatform = requesterInstance.GetPropertyValue("Platform");
+                    string requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
 
-                    var projectInstance = _projectInstanceFactory(
+                    var projectInstance = projectInstanceFactory(
                         projectReferenceFullPath,
                         null, // Platform negotiation requires an evaluation with no global properties first
-                        _projectCollection);
+                        projectCollection);
 
                     string overridePlatformNegotiationMetadataValue = projectReferenceItem.GetMetadataValue(OverridePlatformNegotiationValue);
 
@@ -145,14 +179,19 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                     }
                     else
                     {
-                        var platformPropertyInstance = ProjectPropertyInstance.Create(PlatformMetadataName, selectedPlatform);
-                        referenceGlobalProperties[PlatformMetadataName] = platformPropertyInstance;
+                        SetProperty(referenceGlobalProperties, PlatformMetadataName, selectedPlatform);
                     }
                 }
 
                 var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);
 
                 yield return new ReferenceInfo(referenceConfig, projectReferenceItem);
+
+                static void SetProperty(PropertyDictionary<ProjectPropertyInstance> properties, string propertyName, string propertyValue)
+                {
+                    ProjectPropertyInstance propertyInstance = ProjectPropertyInstance.Create(propertyName, propertyValue);
+                    properties[propertyName] = propertyInstance;
+                }
             }
         }
 
@@ -327,8 +366,8 @@ public GlobalPropertyPartsForMSBuildTask AddPropertyToUndefine(string propertyTo
         private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesForItem(
             ProjectItemInstance projectReference,
             PropertyDictionary<ProjectPropertyInstance> requesterGlobalProperties,
-            bool dynamicPlatformEnabled,
-            IEnumerable<GlobalPropertiesModifier> globalPropertyModifiers = null)
+            bool allowCollectionReuse,
+            IEnumerable<GlobalPropertiesModifier> globalPropertyModifiers)
         {
             ErrorUtilities.VerifyThrowInternalNull(projectReference, nameof(projectReference));
             ErrorUtilities.VerifyThrowArgumentNull(requesterGlobalProperties, nameof(requesterGlobalProperties));
@@ -341,7 +380,7 @@ private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesFo
 
             var globalPropertyParts = globalPropertyModifiers?.Aggregate(defaultParts, (currentProperties, modifier) => modifier(currentProperties, projectReference)) ?? defaultParts;
 
-            if (globalPropertyParts.AllEmpty() && !dynamicPlatformEnabled)
+            if (globalPropertyParts.AllEmpty() && allowCollectionReuse)
             {
                 return requesterGlobalProperties;
             }
diff --git a/src/Shared/SolutionConfiguration.cs b/src/Shared/SolutionConfiguration.cs
index 99c5b0a33fc..a271f2645f4 100644
--- a/src/Shared/SolutionConfiguration.cs
+++ b/src/Shared/SolutionConfiguration.cs
@@ -17,6 +17,8 @@ internal sealed class SolutionConfiguration
 
         public const string BuildProjectInSolutionAttribute = "BuildProjectInSolution";
 
+        public static readonly char[] ConfigPlatformSeparator = { '|' };
+
         // This field stores pre-cached project elements for project guids for quicker access by project guid
         private readonly Dictionary<string, XmlElement> _cachedProjectElements = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
 
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 0832273c79b..9ca06387a18 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -2255,87 +2255,6 @@ public void InvalidErrorIfLinkFailed()
             Assert.False(result);
             engine.AssertLogContains("MSB3892");
         }
-
-        /// <summary>
-        /// An existing link source should not be modified.
-        /// </summary>
-        /// <remarks>
-        /// Related to issue [#8273](https://github.com/dotnet/msbuild/issues/8273)
-        /// </remarks>
-        [Theory]
-        [InlineData(false, false)]
-        [InlineData(false, true)]
-        [InlineData(true, false)]
-        public void DoNotCorruptSourceOfLink(bool useHardLink, bool useSymbolicLink)
-        {
-            string sourceFile1 = FileUtilities.GetTemporaryFile();
-            string sourceFile2 = FileUtilities.GetTemporaryFile();
-            string temp = Path.GetTempPath();
-            string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
-            string destFile = Path.Combine(destFolder, "The Destination");
-
-            try
-            {
-                File.WriteAllText(sourceFile1, "This is the first source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
-                File.WriteAllText(sourceFile2, "This is the second source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
-
-                // Don't create the dest folder, let task do that
-
-                ITaskItem[] sourceFiles = { new TaskItem(sourceFile1) };
-                ITaskItem[] destinationFiles = { new TaskItem(destFile) };
-
-                var me = new MockEngine(true);
-                var t = new Copy
-                {
-                    RetryDelayMilliseconds = 1, // speed up tests!
-                    BuildEngine = me,
-                    SourceFiles = sourceFiles,
-                    DestinationFiles = destinationFiles,
-                    SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = useHardLink,
-                    UseSymboliclinksIfPossible = useSymbolicLink,
-                };
-
-                bool success = t.Execute();
-
-                Assert.True(success); // "success"
-                Assert.True(File.Exists(destFile)); // "destination exists"
-
-                string destinationFileContents = File.ReadAllText(destFile);
-                Assert.Equal("This is the first source temp file.", destinationFileContents);
-
-                sourceFiles = new TaskItem[] { new TaskItem(sourceFile2) };
-
-                t = new Copy
-                {
-                    RetryDelayMilliseconds = 1, // speed up tests!
-                    BuildEngine = me,
-                    SourceFiles = sourceFiles,
-                    DestinationFiles = destinationFiles,
-                    SkipUnchangedFiles = true,
-                    UseHardlinksIfPossible = false,
-                    UseSymboliclinksIfPossible = false,
-                };
-
-                success = t.Execute();
-
-                Assert.True(success); // "success"
-                Assert.True(File.Exists(destFile)); // "destination exists"
-
-                destinationFileContents = File.ReadAllText(destFile);
-                Assert.Equal("This is the second source temp file.", destinationFileContents);
-
-                // Read the source file (it should not have been overwritten)
-                string sourceFileContents = File.ReadAllText(sourceFile1);
-                Assert.Equal("This is the first source temp file.", sourceFileContents);
-
-                ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
-            }
-            finally
-            {
-                Helpers.DeleteFiles(sourceFile1, sourceFile2, destFile);
-            }
-        }
     }
 
     public class CopyHardLink_Tests : Copy_Tests
diff --git a/src/Tasks/AssignProjectConfiguration.cs b/src/Tasks/AssignProjectConfiguration.cs
index 2a47fce7737..74894b3aa5e 100644
--- a/src/Tasks/AssignProjectConfiguration.cs
+++ b/src/Tasks/AssignProjectConfiguration.cs
@@ -157,8 +157,6 @@ public string VcxToDefaultPlatformMapping
         private const string attrSetConfiguration = "SetConfiguration";
         private const string attrSetPlatform = "SetPlatform";
 
-        private static readonly char[] s_configPlatformSeparator = { '|' };
-
         private IDictionary<string, string> _vcxToDefaultMap;
         private IDictionary<string, string> _defaultToVcxMap;
         private bool _mappingsPopulated;
@@ -287,14 +285,14 @@ internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedProject
                 {
                     if (_defaultToVcxMap.TryGetValue(CurrentProjectPlatform, out transformedPlatform))
                     {
-                        projectConfiguration = CurrentProjectConfiguration + s_configPlatformSeparator[0] + transformedPlatform;
+                        projectConfiguration = CurrentProjectConfiguration + SolutionConfiguration.ConfigPlatformSeparator[0] + transformedPlatform;
                     }
                 }
                 else
                 {
                     if (_vcxToDefaultMap.TryGetValue(CurrentProjectPlatform, out transformedPlatform))
                     {
-                        projectConfiguration = CurrentProjectConfiguration + s_configPlatformSeparator[0] + transformedPlatform;
+                        projectConfiguration = CurrentProjectConfiguration + SolutionConfiguration.ConfigPlatformSeparator[0] + transformedPlatform;
                     }
                 }
             }
@@ -306,7 +304,7 @@ internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedProject
                 resolvedProjectWithConfiguration = projectRef;
                 resolvedProjectWithConfiguration.SetMetadata(attrFullConfiguration, projectConfiguration);
 
-                string[] configurationPlatformParts = projectConfiguration.Split(s_configPlatformSeparator);
+                string[] configurationPlatformParts = projectConfiguration.Split(SolutionConfiguration.ConfigPlatformSeparator);
                 resolvedProjectWithConfiguration.SetMetadata(attrSetConfiguration, "Configuration=" + configurationPlatformParts[0]);
                 resolvedProjectWithConfiguration.SetMetadata(attrConfiguration, configurationPlatformParts[0]);
 
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 979c9652291..24921740b27 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -228,6 +228,8 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             FileState sourceFileState,      // The source file
             FileState destinationFileState)  // The destination file
         {
+            bool destinationFileExists = false;
+
             if (destinationFileState.DirectoryExists)
             {
                 Log.LogErrorWithCodeFromResources("Copy.DestinationIsDirectory", sourceFileState.Name, destinationFileState.Name);
@@ -285,14 +287,7 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             if (OverwriteReadOnlyFiles)
             {
                 MakeFileWriteable(destinationFileState, true);
-            }
-
-            // If the destination file is a hard or symbolic link, File.Copy would overwrite the source.
-            // To prevent this, we need to delete the existing entry before we Copy or create a link.
-            // We could try to figure out if the file is a link, but I can't think of a reason to not simply delete it always.
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && destinationFileState.FileExists && !destinationFileState.IsReadOnly)
-            {
-                FileUtilities.DeleteNoThrow(destinationFileState.Name);
+                destinationFileExists = destinationFileState.FileExists;
             }
 
             bool symbolicLinkCreated = false;
@@ -302,7 +297,7 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             // Create hard links if UseHardlinksIfPossible is true
             if (UseHardlinksIfPossible)
             {
-                TryCopyViaLink(HardLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, out hardLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeHardLink(destination, source, ref errorMessage, Log));
+                TryCopyViaLink(HardLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out hardLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeHardLink(destination, source, ref errorMessage, Log));
                 if (!hardLinkCreated)
                 {
                     if (UseSymboliclinksIfPossible)
@@ -320,14 +315,13 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             // Create symbolic link if UseSymboliclinksIfPossible is true and hard link is not created
             if (!hardLinkCreated && UseSymboliclinksIfPossible)
             {
-                TryCopyViaLink(SymbolicLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, out symbolicLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethodsShared.MakeSymbolicLink(destination, source, ref errorMessage));
+                TryCopyViaLink(SymbolicLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out symbolicLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethodsShared.MakeSymbolicLink(destination, source, ref errorMessage));
+                if (!NativeMethodsShared.IsWindows)
+                {
+                    errorMessage = Log.FormatResourceString("Copy.NonWindowsLinkErrorMessage", "symlink()", errorMessage);
+                }
                 if (!symbolicLinkCreated)
                 {
-                    if (!NativeMethodsShared.IsWindows)
-                    {
-                        errorMessage = Log.FormatResourceString("Copy.NonWindowsLinkErrorMessage", "symlink()", errorMessage);
-                    }
-
                     Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.Name, destinationFileState.Name, errorMessage);
                 }
             }
@@ -348,28 +342,41 @@ private void LogDiagnostic(string message, params object[] messageArgs)
                 Log.LogMessage(MessageImportance.Normal, FileComment, sourceFilePath, destinationFilePath);
 
                 File.Copy(sourceFileState.Name, destinationFileState.Name, true);
-
-                // If the destinationFile file exists, then make sure it's read-write.
-                // The File.Copy command copies attributes, but our copy needs to
-                // leave the file writeable.
-                if (sourceFileState.IsReadOnly)
-                {
-                    destinationFileState.Reset();
-                    MakeFileWriteable(destinationFileState, false);
-                }
             }
 
             // Files were successfully copied or linked. Those are equivalent here.
             WroteAtLeastOneFile = true;
 
+            destinationFileState.Reset();
+
+            // If the destinationFile file exists, then make sure it's read-write.
+            // The File.Copy command copies attributes, but our copy needs to
+            // leave the file writeable.
+            if (sourceFileState.IsReadOnly)
+            {
+                MakeFileWriteable(destinationFileState, false);
+            }
+
             return true;
         }
 
-        private void TryCopyViaLink(string linkComment, MessageImportance messageImportance, FileState sourceFileState, FileState destinationFileState, out bool linkCreated, ref string errorMessage, Func<string, string, string, bool> createLink)
+        private void TryCopyViaLink(string linkComment, MessageImportance messageImportance, FileState sourceFileState, FileState destinationFileState, ref bool destinationFileExists, out bool linkCreated, ref string errorMessage, Func<string, string, string, bool> createLink)
         {
             // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
             Log.LogMessage(MessageImportance.Normal, linkComment, sourceFileState.Name, destinationFileState.Name);
 
+            if (!OverwriteReadOnlyFiles)
+            {
+                destinationFileExists = destinationFileState.FileExists;
+            }
+
+            // CreateHardLink and CreateSymbolicLink cannot overwrite an existing file or link
+            // so we need to delete the existing entry before we create the hard or symbolic link.
+            if (destinationFileExists)
+            {
+                FileUtilities.DeleteNoThrow(destinationFileState.Name);
+            }
+
             linkCreated = createLink(sourceFileState.Name, destinationFileState.Name, errorMessage);
         }
 
@@ -847,11 +854,6 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                                     LogDiagnostic("Retrying on ERROR_ACCESS_DENIED because MSBUILDALWAYSRETRY = 1");
                                 }
                             }
-                            else if (code == NativeMethods.ERROR_INVALID_FILENAME)
-                            {
-                                // Invalid characters used in file name, no point retrying.
-                                throw;
-                            }
 
                             if (e is UnauthorizedAccessException)
                             {
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 86faefd4fb7..c173abab5b9 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -537,7 +537,6 @@ internal static class NativeMethods
 
         internal const int HRESULT_E_CLASSNOTREGISTERED = -2147221164;
 
-        internal const int ERROR_INVALID_FILENAME = -2147024773; // Illegal characters in name
         internal const int ERROR_ACCESS_DENIED = -2147024891; // ACL'd or r/o
         internal const int ERROR_SHARING_VIOLATION = -2147024864; // File locked by another use
 
