diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index 18936da2249..664a32ac397 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -33,7 +33,9 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 | ReusableStringBuilderFactoryUnbalanced | Identifies improper usage from multiple threads or buggy code: multiple Gets were called without a Relase. |
 | Save | Saves a project to the file system if dirty, creating directories as necessary. |
 | SdkResolverResolveSdk | A single SDK resolver is called. |
-| SdkResolverServiceInitialize | Initializes SDK resolvers. |
+| SdkResolverServiceFindResolversManifests | Find all resolvers manifests. (Only appear under Changewave 17.4.) |
+| SdkResolverServiceInitialize | Initializes SDK resolvers. (Only appear before Changewave 17.4.) |
+| SdkResolverServiceLoadResolvers | Load resolvers given a resolver manifest. (Only appear under Changewave 17.4.) |
 | SdkResolverEvent | An SDK resolver logs an event. |
 | Target | Executes a target. |
 | TargetUpToDate | Checks whether a particular target needs to run or is up-to-date. |
diff --git a/documentation/specs/sdk-resolvers-algorithm.md b/documentation/specs/sdk-resolvers-algorithm.md
new file mode 100644
index 00000000000..eb962ad2644
--- /dev/null
+++ b/documentation/specs/sdk-resolvers-algorithm.md
@@ -0,0 +1,28 @@
+## SDK Resolution Algorithm
+In 17.3 under ChangeWave 17.4 the sdk resolution algorithm is changed.
+
+### Reason for change
+Previously (before ChangeWave 17.4) all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavior in 17.3 under ChangeWave 17.4.
+
+### New SDK Resolution Algorithm
+Under ChangeWave 17.4 all the resolvers divides into two groups:
+- Specific resolvers, i.e. resolvers with specified sdk name pattern `ResolvableSdkPattern`
+- General resolvers, i.e. resolvers without specified sdk name pattern `ResolvableSdkPattern`
+
+The resolving algorithm works in two passes. 
+- On the first pass all the specific resolvers that match the given sdk name would be loaded, ordered by priority and tried one after one. 
+- If the sdk is not found, on the second pass all general resolvers would be loaded, ordered by priority and tried one after one.
+
+By default the resolvers are general. To make all the resolvers from some dll specific, in the corresponding manifest (xml file) one need to specify the `ResolvableSdkPattern` using C# regex format:
+```
+<SdkResolver>
+  <Path>MySdkResolver.dll</Path>
+  <ResolvableSdkPattern>MySdk.*</ResolvableSdkPattern>
+</SdkResolver>
+```
+
+Note, that the manifest file, if exists, from ChangeWave 17.4 would have preference over the dll.
+The sdk discovery works according to the following algorithm:
+- First try locate the manifest file and use it. 
+- If it is not found, we try to locate the dll in the resolver's folder. 
+Both xml and dll name should match the following name pattern `...\SdkResolvers\(ResolverName)\(ResolverName).(xml/dll)`.
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index e489729fad6..2158cd2a8a5 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -25,8 +25,8 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 
 ### 17.4
 - [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
-- [Remove opt in for new schema for CombineTargetFrameworkInfoProperties](https://github.com/dotnet/msbuild/pull/6928)
 - [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
+- [Adding accepted SDK name match pattern to SDK manifests](https://github.com/dotnet/msbuild/pull/7597)
 
 ### 17.0
 - [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
diff --git a/eng/Packages.props b/eng/Packages.props
index 9a05592d032..6511b043564 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -16,16 +16,16 @@
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
-    <PackageReference Update="System.Collections.Immutable" Version="5.0.0" />
-    <PackageReference Update="System.Configuration.ConfigurationManager" Version="4.7.0" />
+    <PackageReference Update="System.Collections.Immutable" Version="6.0.0" />
+    <PackageReference Update="System.Configuration.ConfigurationManager" Version="6.0.0" />
     <PackageReference Update="System.Net.Http" Version="4.3.4" />
     <PackageReference Update="System.Memory" Version="4.5.5" />
-    <PackageReference Update="System.Reflection.Metadata" Version="1.6.0" />
+    <PackageReference Update="System.Reflection.Metadata" Version="6.0.0" />
     <PackageReference Update="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
     <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
-    <PackageReference Update="System.Security.Permissions" Version="4.7.0" />
+    <PackageReference Update="System.Security.Permissions" Version="6.0.0" />
     <PackageReference Update="System.Security.Principal.Windows" Version="5.0.0" />
-    <PackageReference Update="System.Text.Encoding.CodePages" Version="4.0.1" />
+    <PackageReference Update="System.Text.Encoding.CodePages" Version="6.0.0" />
     <PackageReference Update="System.Text.Json" Version="$(SystemTextJsonVersion)" />
     <PackageReference Update="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
     <PackageReference Update="xunit.assert" Version="$(XUnitVersion)" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 523ce5fd8ef..5ba194b642a 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22218.4">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22261.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>095ae444583627c1f0575967529107fd1e1d6913</Sha>
+      <Sha>e3cbecc5b0e51374e3d71dbb976004ab9cc90430</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="6.2.0-rc.146">
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>b8a61266d9a6780cb7eb9c1942695cf813fdef0a</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.2.0-4.22223.6">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.2.0-4.22266.5">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>68ce7949a2ac960994374d387ec3c840523f2a44</Sha>
+      <Sha>5886de67259d3fe055e48985ba5cefb9d089a840</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22218.4">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22261.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>095ae444583627c1f0575967529107fd1e1d6913</Sha>
+      <Sha>e3cbecc5b0e51374e3d71dbb976004ab9cc90430</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 0fa13c065ec..773a480d037 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -25,17 +25,17 @@
   </PropertyGroup>
   <!-- Production Dependencies -->
   <PropertyGroup>
-    <SystemResourcesExtensionsPackageVersion>4.6.0</SystemResourcesExtensionsPackageVersion>
+    <SystemResourcesExtensionsPackageVersion>6.0.0</SystemResourcesExtensionsPackageVersion>
   </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
     <!-- DotNetCliVersion MUST match the dotnet version in global.json.
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22218.4</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22261.7</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.2.0-4.22223.6</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.2.0-4.22266.5</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.2.0-rc.146</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>6.0.0</SystemTextJsonVersion>
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 67e2983d6fd..06cf49477ed 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -12,21 +12,21 @@
     <PackageReference Update="LargeAddressAware" Version="1.0.5" />
     <PackageReference Update="Microsoft.CodeAnalysis.PublicApiAnalyzers" Version="3.3.3" />
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" />
-    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.1.2196" PrivateAssets="All" />
+    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.2.2146" PrivateAssets="All" />
     <PackageReference Update="Microsoft.Win32.Registry" Version="5.0.0" />
     <PackageReference Update="PdbGit" Version="3.0.41" />
     <PackageReference Update="Shouldly" Version="3.0.0" />
     <PackageReference Update="System.CodeDom" Version="6.0.0" />
     <PackageReference Update="System.Private.Uri" Version="4.3.2" />
     <PackageReference Update="System.Runtime" Version="4.3.1" />
-    <PackageReference Update="System.Security.Cryptography.Pkcs" Version="6.0.0" />
+    <PackageReference Update="System.Security.Cryptography.Pkcs" Version="6.0.1" />
     <PackageReference Update="System.Security.Cryptography.Xml" Version="6.0.0" />
     <PackageReference Update="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
     <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="3.3.3" />
-    <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.406" PrivateAssets="all"/>
+    <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.435" PrivateAssets="all"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/global.json b/global.json
index 9433b51dca5..3c20798654a 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22218.4"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22261.7"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
index 4b14bd3537a..e8b3812ab57 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
@@ -46,7 +46,7 @@ public void AssertDefaultLoaderReturnsDefaultResolvers()
         {
             var loader = new SdkResolverLoader();
 
-            var resolvers = loader.LoadResolvers(_loggingContext, new MockElementLocation("file"));
+            var resolvers = loader.LoadAllResolvers(_loggingContext, new MockElementLocation("file"));
 
             resolvers.Select(i => i.GetType().FullName).ShouldBe(new [] { typeof(DefaultSdkResolver).FullName });
             
@@ -88,6 +88,38 @@ public void VerifySdkResolverLoaderFileDiscoveryPattern()
             }
         }
 
+        [Fact]
+        public void SdkResolverLoaderPrefersManifestFile()
+        {
+            var root = FileUtilities.GetTemporaryDirectory();
+            try
+            {
+                var testFolder = Directory.CreateDirectory(Path.Combine(root, "MyTestResolver"));
+
+                var wrongResolverDll = Path.Combine(testFolder.FullName, "MyTestResolver.dll");
+                var resolverManifest = Path.Combine(testFolder.FullName, "MyTestResolver.xml");
+                var assemblyToLoad = Path.Combine(root, "SomeOtherResolver.dll");
+
+                File.WriteAllText(wrongResolverDll, string.Empty);
+                File.WriteAllText(assemblyToLoad, string.Empty);
+
+                File.WriteAllText(resolverManifest, $@"
+                    <SdkResolver>
+                      <Path>{assemblyToLoad}</Path>
+                    </SdkResolver>");
+
+                SdkResolverLoader loader = new SdkResolverLoader();
+                var resolversFound = loader.FindPotentialSdkResolvers(root, new MockElementLocation("file"));
+
+                resolversFound.Count.ShouldBe(1);
+                resolversFound.First().ShouldBe(assemblyToLoad);
+            }
+            finally
+            {
+                FileUtilities.DeleteDirectoryNoThrow(root, true);
+            }
+        }
+
         /// <summary>
         /// Verifies that if an SDK resolver throws while creating an instance that a warning is logged.
         /// </summary>
@@ -106,7 +138,7 @@ public void VerifyThrowsWhenResolverFailsToLoad()
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
             {
-                sdkResolverLoader.LoadResolvers(_loggingContext, ElementLocation.EmptyLocation);
+                sdkResolverLoader.LoadAllResolvers(_loggingContext, ElementLocation.EmptyLocation);
             });
 
             exception.Message.ShouldBe($"The SDK resolver type \"{nameof(MockSdkResolverThatDoesNotLoad)}\" failed to load. A8BB8B3131D3475D881ACD3AF8D75BD6");
@@ -138,7 +170,7 @@ public void VerifyThrowsWhenResolverHasNoPublicConstructor()
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
             {
-                sdkResolverLoader.LoadResolvers(_loggingContext, ElementLocation.EmptyLocation);
+                sdkResolverLoader.LoadAllResolvers(_loggingContext, ElementLocation.EmptyLocation);
             });
 
             exception.Message.ShouldStartWith($"The SDK resolver type \"{nameof(MockSdkResolverNoPublicConstructor)}\" failed to load.");
@@ -169,7 +201,7 @@ public void VerifyWarningLoggedWhenResolverAssemblyCannotBeLoaded()
 
             InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
             {
-                sdkResolverLoader.LoadResolvers(_loggingContext, ElementLocation.EmptyLocation);
+                sdkResolverLoader.LoadAllResolvers(_loggingContext, ElementLocation.EmptyLocation);
             });
 
             exception.Message.ShouldBe($"The SDK resolver assembly \"{assemblyPath}\" could not be loaded. {expectedMessage}");
@@ -207,6 +239,33 @@ public void SdkResolverLoaderReadsManifestFile()
             }
         }
 
+        [Fact]
+        public void SdkResolverLoaderReadsManifestFileWithResolvableSdkPattern()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                var root = env.CreateFolder().Path;
+                var resolverPath = Path.Combine(root, "MyTestResolver");
+                var resolverManifest = Path.Combine(resolverPath, "MyTestResolver.xml");
+
+                var assemblyToLoad = env.CreateFile(".dll").Path;
+
+                Directory.CreateDirectory(resolverPath);
+                File.WriteAllText(resolverManifest, $@"
+                    <SdkResolver>
+                      <ResolvableSdkPattern>1&lt;.*</ResolvableSdkPattern>
+                      <Path>{assemblyToLoad}</Path>
+                    </SdkResolver>");
+
+                SdkResolverLoader loader = new SdkResolverLoader();
+                var resolversManifestsFound = loader.FindPotentialSdkResolversManifests(root, new MockElementLocation("file"));
+
+                resolversManifestsFound.Count.ShouldBe(1);
+                resolversManifestsFound.First().Path.ShouldBe(assemblyToLoad);
+                resolversManifestsFound.First().ResolvableSdkRegex.ToString().ShouldBe("1<.*");
+            }
+        }
+
         [Fact]
         public void SdkResolverLoaderErrorsWithInvalidManifestFile()
         {
@@ -287,7 +346,7 @@ public void SdkResolverLoaderHonorsIncludeDefaultEnvVar()
                             resolvers.Add(new MockSdkResolverWithAssemblyPath(resolverPath));
                         }
                     };
-                    IList<SdkResolverBase> resolvers = loader.LoadResolvers(_loggingContext, new MockElementLocation("file"));
+                    IList<SdkResolverBase> resolvers = loader.LoadAllResolvers(_loggingContext, new MockElementLocation("file"));
 
                     resolvers.Count.ShouldBe(0);
                 }
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index 2b86246c83f..87d3efd618d 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -17,6 +17,8 @@
 using SdkResultBase = Microsoft.Build.Framework.SdkResult;
 using SdkResultFactoryBase = Microsoft.Build.Framework.SdkResultFactory;
 using SdkResultImpl = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
+using Microsoft.Build.Shared;
+using System.Text.RegularExpressions;
 
 #nullable disable
 
@@ -39,9 +41,10 @@ public SdkResolverService_Tests()
         }
 
         [Fact]
+        // Scenario: Sdk is not resolved.
         public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
         {
-            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
+            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
 
             SdkReference sdk = new SdkReference("notfound", "referencedVersion", "minimumVersion");
 
@@ -56,8 +59,10 @@ public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
 
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver2 running");
-            _logger.Errors.Select(i => i.Message).ShouldBe(new [] { "ERROR1", "ERROR2" });
-            _logger.Warnings.Select(i => i.Message).ShouldBe(new[] { "WARNING2" });
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern2 running");
+            _logger.Errors.Select(i => i.Message).ShouldBe(new [] { "ERROR4", "ERROR1", "ERROR2" });
+            _logger.Warnings.Select(i => i.Message).ShouldBe(new[] { "WARNING4", "WARNING2" });
         }
 
         [Fact]
@@ -99,7 +104,27 @@ public void AssertResolverThrows()
             e.Sdk.Name.ShouldBe("1sdkName");
         }
 
+
+        [Fact]
+        // Scenario: MockSdkResolverWithResolvableSdkPattern2 is a specific resolver (i.e. resolver with pattern)
+        // and it successfully resolves sdk.
+        public void AssertSecondResolverWithPatternCanResolve()
+        {
+            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
+
+            SdkReference sdk = new SdkReference("2sdkName", "referencedVersion", "minimumVersion");
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+
+            result.Path.ShouldBe("resolverpathwithresolvablesdkpattern2");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern2 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolver1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolver2 running");
+        }
+
         [Fact]
+        // Scenario: MockSdkResolverWithResolvableSdkPattern1 is a specific resolver, it is loaded but did not resolve sdk.
+        // MockSdkResolver1 is a general resolver (i.e. resolver without pattern), it resolves sdk on a fallback. 
         public void AssertFirstResolverCanResolve()
         {
             SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
@@ -110,6 +135,46 @@ public void AssertFirstResolverCanResolve()
 
             result.Path.ShouldBe("resolverpath1");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
+        }
+
+        [Fact]
+        // Scenario: MockSdkResolver1 has higher priority than MockSdkResolverWithResolvableSdkPattern1 and resolves sdk.
+        public void AssertFirstResolverWithPatternCantResolveChangeWave17_4()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_4.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
+
+                SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
+
+                var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+
+                result.Path.ShouldBe("resolverpath1");
+                _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
+                _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
+                ChangeWaves.ResetStateForTests();
+            }
+        }
+
+        [Fact]
+        // Scenario: MockSdkResolver1 has higher priority than MockSdkResolverWithResolvableSdkPattern1 but MockSdkResolverWithResolvableSdkPattern1 resolves sdk,
+        // becuase MockSdkResolver1 is general and MockSdkResolverWithResolvableSdkPattern1 is specific.
+        public void AssertFirstResolverWithPatternCanResolve()
+        {
+            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
+
+            SdkReference sdk = new SdkReference("11sdkName", "referencedVersion", "minimumVersion");
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+
+            result.Path.ShouldBe("resolverpathwithresolvablesdkpattern1");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolver1 running");
         }
 
         [Fact]
@@ -539,16 +604,27 @@ public void IsRunningInVisualStudioIsSetForResolverContext()
 
         private class MockLoaderStrategy : SdkResolverLoader
         {
-            private readonly bool _includeErrorResolver;
+            private List<SdkResolver> _resolvers;
+            private List<(string ResolvableSdkPattern, SdkResolver Resolver)> _resolversWithPatterns;
+
 
-            public MockLoaderStrategy(bool includeErrorResolver = false)
+            public MockLoaderStrategy(bool includeErrorResolver = false, bool includeResolversWithPatterns = false) : this()
             {
-                _includeErrorResolver = includeErrorResolver;
+                if (includeErrorResolver)
+                {
+                    _resolvers.Add(new MockSdkResolverThrows());
+                }
+
+                if (includeResolversWithPatterns)
+                {
+                    _resolversWithPatterns.Add(("1.*", new MockSdkResolverWithResolvableSdkPattern1()));
+                    _resolversWithPatterns.Add((".*", new MockSdkResolverWithResolvableSdkPattern2()));
+                }
             }
 
-            internal override IList<SdkResolver> LoadResolvers(LoggingContext loggingContext, ElementLocation location)
+            private MockLoaderStrategy()
             {
-                List<SdkResolver> resolvers = new List<SdkResolver>
+                _resolvers = new List<SdkResolver>
                 {
                     new MockSdkResolver1(),
                     new MockSdkResolver2(),
@@ -556,12 +632,58 @@ internal override IList<SdkResolver> LoadResolvers(LoggingContext loggingContext
                     new MockSdkResolverWithState()
                 };
 
-                if (_includeErrorResolver)
+                _resolversWithPatterns = new List<(string ResolvableSdkPattern, SdkResolver Resolver)>();
+            }
+
+            internal override IList<SdkResolver> LoadAllResolvers(LoggingContext loggingContext, ElementLocation location)
+            {
+                return _resolvers.OrderBy(i => i.Priority).ToList();
+            }
+
+            internal override IList<SdkResolverManifest> GetResolversManifests(LoggingContext loggingContext,
+            ElementLocation location)
+            {
+                var manifests = new List<SdkResolverManifest>();
+                foreach(SdkResolver resolver in _resolvers)
+                {
+                    SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(resolver.Name, null, null);
+                    manifests.Add(sdkResolverManifest);
+                }
+                foreach ((string ResolvableSdkPattern, SdkResolver Resolver) pair in _resolversWithPatterns)
+                {
+                    SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(
+                        pair.Resolver.Name,
+                        null,
+                        new Regex(pair.ResolvableSdkPattern, RegexOptions.Compiled | RegexOptions.CultureInvariant, TimeSpan.FromMilliseconds(500))
+                    );
+                    manifests.Add(sdkResolverManifest);
+                }
+                return manifests;
+            }
+
+            protected internal override IList<SdkResolver> LoadResolversFromManifest(SdkResolverManifest manifest, LoggingContext loggingContext, ElementLocation location)
+            {
+                var resolvers = new List<SdkResolver>();
+                foreach (var resolver in _resolvers)
+                {
+                    if (resolver.Name == manifest.DisplayName)
+                    {
+                        resolvers.Add(resolver);
+                    }
+                }
+                foreach (var pair in _resolversWithPatterns)
                 {
-                    resolvers.Add(new MockSdkResolverThrows());
+                    if (pair.Resolver.Name == manifest.DisplayName)
+                    {
+                        resolvers.Add(pair.Resolver);
+                    }
                 }
+                return resolvers.OrderBy(t => t.Priority).ToList();
+            }
 
-                return resolvers.OrderBy(i => i.Priority).ToList();
+            internal override IList<SdkResolver> GetDefaultResolvers(LoggingContext loggingContext, ElementLocation location)
+            {
+                return new List<SdkResolver>();
             }
         }
 
@@ -587,7 +709,7 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase r
                 if (sdk.Name.StartsWith("1"))
                     return factory.IndicateSuccess("resolverpath1", "version1");
 
-                return factory.IndicateFailure(new[] {"ERROR1"});
+                return factory.IndicateFailure(new[] { "ERROR1" });
             }
         }
 
@@ -608,6 +730,40 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase r
             }
         }
 
+        private class MockSdkResolverWithResolvableSdkPattern1 : SdkResolver
+        {
+            public override string Name => nameof(MockSdkResolverWithResolvableSdkPattern1);
+
+            public override int Priority => 2;
+
+            public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase resolverContext, SdkResultFactoryBase factory)
+            {
+                resolverContext.Logger.LogMessage("MockSdkResolverWithResolvableSdkPattern1 running", MessageImportance.Normal);
+
+                if (sdk.Name.StartsWith("11"))
+                    return factory.IndicateSuccess("resolverpathwithresolvablesdkpattern1", "version3");
+
+                return factory.IndicateFailure(new[] { "ERROR3" });
+            }
+        }
+
+        private class MockSdkResolverWithResolvableSdkPattern2 : SdkResolver
+        {
+            public override string Name => nameof(MockSdkResolverWithResolvableSdkPattern2);
+
+            public override int Priority => 0;
+
+            public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase resolverContext, SdkResultFactoryBase factory)
+            {
+                resolverContext.Logger.LogMessage("MockSdkResolverWithResolvableSdkPattern2 running", MessageImportance.Normal);
+
+                if (sdk.Name.StartsWith("2"))
+                    return factory.IndicateSuccess("resolverpathwithresolvablesdkpattern2", "version4", new[] { "WARNING4" });
+
+                return factory.IndicateFailure(new[] { "ERROR4" }, new[] { "WARNING4" });
+            }
+        }
+
         private class MockSdkResolverWithState : SdkResolver
         {
             public const string Expected = "01713226A202458F97D9074168DF2618";
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 0c3c65b0f20..997e40b8c83 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -4244,6 +4244,7 @@ public void VerifyDTDProcessingIsDisabled()
         /// If DTD processing is disabled, the server should not receive any connection request.
         /// </summary>
         [Fact]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7623")]
         public async void VerifyDTDProcessingIsDisabled2()
         {
             string projectContents = ObjectModelHelpers.CleanupFileContents(@"<?xml version=""1.0"" encoding=""utf-8""?>
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 8d4d270e51b..e77a47e5ef4 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 using System.Text;
 using System.Xml;
 
@@ -1712,8 +1713,10 @@ public void RegistryPropertyInvalidPrefixError2()
             }
            );
         }
-#if FEATURE_WIN32_REGISTRY
+
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyString()
         {
             try
@@ -1735,6 +1738,8 @@ public void RegistryPropertyString()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyBinary()
         {
             try
@@ -1759,6 +1764,8 @@ public void RegistryPropertyBinary()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyDWord()
         {
             try
@@ -1780,6 +1787,8 @@ public void RegistryPropertyDWord()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyExpandString()
         {
             try
@@ -1802,6 +1811,8 @@ public void RegistryPropertyExpandString()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyQWord()
         {
             try
@@ -1823,6 +1834,8 @@ public void RegistryPropertyQWord()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void RegistryPropertyMultiString()
         {
             try
@@ -1842,7 +1855,6 @@ public void RegistryPropertyMultiString()
                 Registry.CurrentUser.DeleteSubKey(@"Software\Microsoft\MSBuild_test");
             }
         }
-#endif
 
         [Fact]
         public void TestItemSpecModiferEscaping()
@@ -3471,8 +3483,9 @@ public void PropertySimpleSpaced()
             Assert.Equal(String.Empty, result);
         }
 
-#if FEATURE_WIN32_REGISTRY
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegitryValue()
         {
             try
@@ -3496,6 +3509,8 @@ public void PropertyFunctionGetRegitryValue()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegitryValueDefault()
         {
             try
@@ -3519,6 +3534,8 @@ public void PropertyFunctionGetRegitryValueDefault()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegistryValueFromView1()
         {
             try
@@ -3542,6 +3559,8 @@ public void PropertyFunctionGetRegistryValueFromView1()
         }
 
         [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [SupportedOSPlatform("windows")]
         public void PropertyFunctionGetRegistryValueFromView2()
         {
             try
@@ -3563,7 +3582,6 @@ public void PropertyFunctionGetRegistryValueFromView2()
                 Registry.CurrentUser.DeleteSubKey(@"Software\Microsoft\MSBuild_test");
             }
         }
-#endif
 
         /// <summary>
         /// Expand a property function that references item metadata
@@ -3901,12 +3919,10 @@ public void Medley()
             }
 #endif
 
-#if FEATURE_WIN32_REGISTRY
             if (NativeMethodsShared.IsWindows)
             {
                 errorTests.Add("$(Registry:X)");
             }
-#endif
 
             if (!NativeMethodsShared.IsWindows)
             {
diff --git a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
new file mode 100644
index 00000000000..f1a31f7dbe6
--- /dev/null
+++ b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
@@ -0,0 +1,245 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text.RegularExpressions;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;
+using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;
+
+#nullable disable
+
+namespace Microsoft.Build.Graph.UnitTests
+{
+    /// <summary>
+    /// Performs SetPlatform negotiation for all project references when opted
+    /// in via the EnableDynamicPlatformResolution property.
+    /// 
+    /// The static graph mirrors the negotiation during build to determine plartform for each node.
+    /// These tests mirror GetCompatiblePlatform_Tests.cs in order to make sure they both are in sync.
+    /// </summary>
+    public class ProjectGraphSetPlatformTests
+    {
+
+        [Fact]
+        public void ValidateSetPlatformOverride()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                    <SetPlatform>platform=x86</SetPlatform>
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                            <Platforms>x64;AnyCPU</Platforms>
+                                                        </PropertyGroup>
+                                                        <ItemGroup>
+                                                            <ProjectReference Include=""$(MSBuildThisFileDirectory)3.proj"" >
+                                                            </ProjectReference>
+                                                        </ItemGroup>
+                                                    </Project>");
+                var proj3 = env.CreateFile("3.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <Platforms>AnyCPU;x86</Platforms>
+                                                        </PropertyGroup>
+                                                    </Project>");
+
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+            }
+        }
+
+        [Fact]
+        public void ResolvesViaPlatformLookupTable()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>win32</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <Platforms>x64;x86;AnyCPU</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+                
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x64");
+            }
+        }
+
+        [Fact]
+        public void ResolvesViaProjectReferencesPlatformLookupTable()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>win32</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <Platforms>x64;x86;AnyCPU</Platforms>
+                                                        <PlatformLookupTable>win32=x86</PlatformLookupTable>
+                                                    </PropertyGroup>
+                                                    </Project>");
+               
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+            }
+        }
+
+        [Fact]
+        public void ResolvesViaAnyCPUDefault()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x86</Platform>
+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <Platforms>x64;AnyCPU</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("AnyCPU");
+            }
+        }
+
+        [Fact]
+        public void ResolvesViaSamePlatform()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x86</Platform>
+                                                                                                <PlatformLookupTable>x86=AnyCPU</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <PlatformLookupTable></PlatformLookupTable>
+                                                        <Platforms>x86;x64;AnyCPU</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+             
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+            }
+        }
+
+        [Fact]
+        public void FailsToResolve()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x86</Platform>
+                                                                                                <PlatformLookupTable>AnyCPU=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <Platforms>x64</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+              
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                // Here we are checking if platform is defined. in this case it should not be since Platorm would be set to the value this project defaults as
+                // in order to avoid dual build errors we remove platform in order to avoid the edge case where a project has global platform set and does not have global platform set
+                // yet still default to the same platform.
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+            }
+        }
+
+        [Fact]
+        public void PlatformIsChosenAsDefault()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                    <PropertyGroup>
+                                                        <platform>x64</platform>
+                                                        <Platforms>x86;AnyCPU</Platforms>
+                                                    </PropertyGroup>
+                                                    </Project>");
+              
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GetPropertyValue("Platform").ShouldBe(GetFirstNodeWithProjectNumber(graph, 1).ProjectInstance.GetPropertyValue("Platform"));
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 04b7ad67ed0..6e1e26c4258 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -67,11 +67,10 @@ public override void PacketReceived(int node, INodePacket packet)
 
             SdkResult response = null;
 
+            // Create an SdkReference from the request; the SdkReference constructor below never throws.
+            SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);
             try
             {
-                // Create an SdkReference from the request
-                SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);
-
                 ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
 
                 // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations
@@ -90,7 +89,7 @@ public override void PacketReceived(int node, INodePacket packet)
                 // Get the node manager and send the response back to the node that requested the SDK
                 INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;
 
-                nodeManager.SendData(request.NodeId, response);
+                nodeManager.SendData(request.NodeId, response ?? new SdkResult(sdkReference, null, null));
             }
         }
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index e6f1294b28d..0ccdd796da6 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -34,7 +34,16 @@ internal class SdkResolverLoader
 #endif
             ) ?? Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
 
-        internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
+        internal virtual IList<SdkResolver> GetDefaultResolvers(LoggingContext loggingContext, ElementLocation location)
+        {
+            var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ?
+                new List<SdkResolver> {new DefaultSdkResolver()}
+                : new List<SdkResolver>();
+
+            return resolvers;
+        }
+
+        internal virtual IList<SdkResolver> LoadAllResolvers(LoggingContext loggingContext,
             ElementLocation location)
         {
             var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ?
@@ -57,6 +66,13 @@ internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
             return resolvers.OrderBy(t => t.Priority).ToList();
         }
 
+        internal virtual IList<SdkResolverManifest> GetResolversManifests(LoggingContext loggingContext,
+            ElementLocation location)
+        {
+            return FindPotentialSdkResolversManifests(
+                Path.Combine(BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot, "SdkResolvers"), location);
+        }
+
         /// <summary>
         ///     Find all files that are to be considered SDK Resolvers. Pattern will match
         ///     Root\SdkResolver\(ResolverName)\(ResolverName).dll.
@@ -66,24 +82,44 @@ internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
         /// <returns></returns>
         internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, ElementLocation location)
         {
-            var assembliesList = new List<string>();
+            var manifestsList = FindPotentialSdkResolversManifests(rootFolder, location);
+
+            return manifestsList.Select(manifest => manifest.Path).ToList();
+        }
+
+        internal virtual IList<SdkResolverManifest> FindPotentialSdkResolversManifests(string rootFolder, ElementLocation location)
+        {
+            List<SdkResolverManifest> manifestsList = new List<SdkResolverManifest>();
 
             if ((string.IsNullOrEmpty(rootFolder) || !FileUtilities.DirectoryExistsNoThrow(rootFolder)) && AdditionalResolversFolder == null)
             {
-                return assembliesList;
+                return manifestsList;
             }
 
             DirectoryInfo[] subfolders = GetSubfolders(rootFolder, AdditionalResolversFolder);
 
             foreach (var subfolder in subfolders)
             {
-                var assembly = Path.Combine(subfolder.FullName, $"{subfolder.Name}.dll");
                 var manifest = Path.Combine(subfolder.FullName, $"{subfolder.Name}.xml");
+                var assembly = Path.Combine(subfolder.FullName, $"{subfolder.Name}.dll");
+                bool assemblyAdded = false;
 
-                var assemblyAdded = TryAddAssembly(assembly, assembliesList);
-                if (!assemblyAdded)
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                {
+                    // Prefer manifest over the assembly. Try to read the xml first, and if not found then look for an assembly.
+                    assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
+                    if (!assemblyAdded)
+                    {
+                        assemblyAdded = TryAddAssemblyManifestFromDll(assembly, manifestsList);
+                    }
+                }
+                else
                 {
-                    assemblyAdded = TryAddAssemblyFromManifest(manifest, subfolder.FullName, assembliesList, location);
+                    assemblyAdded = TryAddAssemblyManifestFromDll(assembly, manifestsList);
+                    if (!assemblyAdded)
+                    {
+                        assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
+                    }
                 }
 
                 if (!assemblyAdded)
@@ -92,7 +128,7 @@ internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, Elem
                 }
             }
 
-            return assembliesList;
+            return manifestsList;
         }
 
         private DirectoryInfo[] GetSubfolders(string rootFolder, string additionalResolversFolder)
@@ -133,25 +169,25 @@ public int GetHashCode(DirectoryInfo value)
             }
         }
 
-        private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)
+        private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List<SdkResolverManifest> manifestsList, ElementLocation location)
         {
             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;
 
-            string path = null;
-
+            SdkResolverManifest manifest = null;
             try
             {
                 // <SdkResolver>
                 //   <Path>...</Path>
+                //   <ResolvableSdkPattern>(Optional field)</ResolvableSdkPattern>
                 // </SdkResolver>
-                var manifest = SdkResolverManifest.Load(pathToManifest);
+                manifest = SdkResolverManifest.Load(pathToManifest);
 
                 if (manifest == null || string.IsNullOrEmpty(manifest.Path))
                 {
                     ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), "SdkResolverDllInManifestMissing", pathToManifest, string.Empty);
                 }
 
-                path = FileUtilities.FixFilePath(manifest.Path);
+                manifest.Path = FileUtilities.FixFilePath(manifest.Path);
             }
             catch (XmlException e)
             {
@@ -159,25 +195,27 @@ private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFo
                 ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), e, "SdkResolverManifestInvalid", pathToManifest, e.Message);
             }
 
-            if (!Path.IsPathRooted(path))
+            if (!Path.IsPathRooted(manifest.Path))
             {
-                path = Path.Combine(manifestFolder, path);
-                path = Path.GetFullPath(path);
+                manifest.Path = Path.Combine(manifestFolder, manifest.Path);
+                manifest.Path = Path.GetFullPath(manifest.Path);
             }
 
-            if (!TryAddAssembly(path, assembliesList))
+            if (string.IsNullOrEmpty(manifest.Path) || !FileUtilities.FileExistsNoThrow(manifest.Path))
             {
-                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), "SdkResolverDllInManifestMissing", pathToManifest, path);
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), "SdkResolverDllInManifestMissing", pathToManifest, manifest.Path);
             }
 
+            manifestsList.Add(manifest);
+
             return true;
         }
 
-        private bool TryAddAssembly(string assemblyPath, List<string> assembliesList)
+        private bool TryAddAssemblyManifestFromDll(string assemblyPath, List<SdkResolverManifest> manifestsList)
         {
             if (string.IsNullOrEmpty(assemblyPath) || !FileUtilities.FileExistsNoThrow(assemblyPath)) return false;
 
-            assembliesList.Add(assemblyPath);
+            manifestsList.Add(new SdkResolverManifest(DisplayName: assemblyPath, Path: assemblyPath, ResolvableSdkRegex: null));
             return true;
         }
 
@@ -198,6 +236,13 @@ protected virtual Assembly LoadResolverAssembly(string resolverPath, LoggingCont
 #endif
         }
 
+        protected internal virtual IList<SdkResolver> LoadResolversFromManifest(SdkResolverManifest manifest, LoggingContext loggingContext, ElementLocation location)
+        {
+            var resolvers = new List<SdkResolver>();
+            LoadResolvers(manifest.Path, loggingContext, location, resolvers);
+            return resolvers;
+        }
+
         protected virtual void LoadResolvers(string resolverPath, LoggingContext loggingContext, ElementLocation location, List<SdkResolver> resolvers)
         {
             Assembly assembly;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
index 295ec8d7877..f8d0baf5e71 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
@@ -1,5 +1,7 @@
 ﻿using Microsoft.Build.Shared;
+using System;
 using System.IO;
+using System.Text.RegularExpressions;
 using System.Xml;
 
 #nullable disable
@@ -11,7 +13,43 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// </summary>
     internal class SdkResolverManifest
     {
-        internal string Path { get; set; }
+        private SdkResolverManifest()
+        {
+        }
+
+        public SdkResolverManifest(string DisplayName, string Path, Regex ResolvableSdkRegex)
+        {
+            this.DisplayName = DisplayName;
+            this.Path = Path;
+            this.ResolvableSdkRegex = ResolvableSdkRegex;
+        }
+
+        /// <summary>
+        /// Sdk resolver manifest display name.
+        /// </summary>
+        /// <remarks>
+        /// This field should be used only for logging purposes. Do not use for any actual processing, unless that are tests.
+        /// </remarks>
+        public string DisplayName { get; set; }
+
+        /// <summary>
+        /// Path for resolvers dll location.
+        /// </summary>
+        public string Path { get; set; }
+
+        /// <summary>
+        /// Regex which matches all the sdk names that could be resolved by the resolvers associated with given manifest.  
+        /// </summary>
+        public Regex ResolvableSdkRegex { get; set; }
+
+        /// <summary>
+        /// The time-out interval for the name pattern regex in milliseconds.
+        /// </summary>
+        /// <remarks>
+        /// This number should notify us when the name matching regex executes unreasonable amount of time (for example, have an infinite recursive regex expression).
+        /// One should avoid to put such a regex into a resolver's xml and we want to catch this situation early. Half a second seems to be a reasonable time in which regex should finish.
+        /// </remarks>
+        private const int SdkResolverPatternRegexTimeoutMsc = 500;
 
         /// <summary>
         /// Deserialize the file into an SdkResolverManifest.
@@ -35,7 +73,7 @@ internal static SdkResolverManifest Load(string filePath)
                 {
                     if (reader.NodeType == XmlNodeType.Element && reader.Name == "SdkResolver")
                     {
-                        return ParseSdkResolverElement(reader);
+                        return ParseSdkResolverElement(reader, filePath);
                     }
                     else
                     {
@@ -47,22 +85,43 @@ internal static SdkResolverManifest Load(string filePath)
             return null;
         }
 
-        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader)
+        // This parsing code is very specific and not forward compatible, but since resolvers generally ship in the same release vehicle as MSBuild itself, only backward compatibility is required.
+        private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader, string filePath)
         {
             SdkResolverManifest manifest = new SdkResolverManifest();
+            manifest.DisplayName = filePath;
 
-            while (reader.Read())
+            reader.Read();
+            while (!reader.EOF)
             {
                 switch (reader.NodeType)
                 {
                     case XmlNodeType.Element:
                         {
-                            manifest.Path = reader.Name switch
+                            switch (reader.Name)
                             {
-                                "Path" => reader.ReadElementContentAsString(),
-                                _ => throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name)),
-                            };
+                                case "Path":
+                                    manifest.Path = reader.ReadElementContentAsString();
+                                    break;
+                                case "ResolvableSdkPattern":
+                                    string pattern = reader.ReadElementContentAsString();
+                                    try
+                                    {
+                                        manifest.ResolvableSdkRegex = new Regex(pattern, RegexOptions.Compiled | RegexOptions.CultureInvariant, TimeSpan.FromMilliseconds(SdkResolverPatternRegexTimeoutMsc));
+                                    }
+                                    catch (ArgumentException ex)
+                                    {
+                                        ErrorUtilities.ThrowInternalError("A regular expression parsing error occurred while parsing {0}.", ex, filePath);
+                                    }
+                                    break;
+                                default:
+                                    throw new XmlException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnrecognizedElement", reader.Name));
+                            }
+                            break;
                         }
+
+                    case XmlNodeType.EndElement:
+                        reader.Read();
                         break;
 
                     default:
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index f6675ba42a5..c38afed1d3b 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -12,6 +12,8 @@
 using System.Collections.Generic;
 using System.Reflection;
 using Microsoft.Build.Eventing;
+using System.Linq;
+using System.Text.RegularExpressions;
 
 #nullable disable
 
@@ -41,7 +43,25 @@ internal class SdkResolverService : ISdkResolverService
         /// <summary>
         /// Stores the list of SDK resolvers which were loaded.
         /// </summary>
-        private IList<SdkResolver> _resolvers;
+        /// <remarks>
+        /// Need it for supporting the ChangeWave less than <see cref="ChangeWaves.Wave17_4"/>. Remove when move out Wave17_4.
+        /// </remarks>
+        private IList<SdkResolver> _resolversList;
+
+        /// <summary>
+        /// Stores the loaded SDK resolvers, mapped to the manifest from which they came.
+        /// </summary>
+        private Dictionary<SdkResolverManifest, IList<SdkResolver>> _manifestToResolvers;
+
+        /// <summary>
+        /// Stores the list of manifests of specific SDK resolvers which could be loaded.
+        /// </summary>
+        private IList<SdkResolverManifest> _specificResolversManifestsRegistry;
+
+        /// <summary>
+        /// Stores the list of manifests of general SDK resolvers which could be loaded.
+        /// </summary>
+        private IList<SdkResolverManifest> _generalResolversManifestsRegistry;
 
         /// <summary>
         /// Stores an <see cref="SdkResolverLoader"/> which can load registered SDK resolvers.
@@ -92,12 +112,147 @@ public virtual void ClearCaches()
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
-            // Lazy initialize the SDK resolvers
-            if (_resolvers == null)
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+            }
+            else
+            {
+                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+            }
+        }
+
+        /// <remarks>
+        /// Resolves the sdk in two passes. First pass consists of all specific resolvers (i.e. resolvers with pattern), which match the sdk name.
+        /// The resolvers are ordered by the priority in first pass and are tried until one of them succeeds.
+        /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.
+        /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.
+        /// </remarks>
+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        {
+            if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)
+            {
+                RegisterResolversManifests(loggingContext, sdkReferenceLocation);
+            }
+
+            // Pick up the matching specific resolvers from the list of resolvers.
+            List<SdkResolverManifest> matchingResolversManifests = new();
+            foreach (SdkResolverManifest manifest in _specificResolversManifestsRegistry)
+            {
+                try
+                {
+                    if (manifest.ResolvableSdkRegex.IsMatch(sdk.Name))
+                    {
+                        matchingResolversManifests.Add(manifest);
+                    }
+                }
+                catch (RegexMatchTimeoutException ex)
+                {
+                    ErrorUtilities.ThrowInternalError("Timeout exceeded matching sdk \"{0}\" to <ResolvableSdkPattern> from sdk resolver manifest {1}.", ex, sdk.Name, manifest.DisplayName);
+                }
+            }
+
+            List<SdkResolver> resolvers;
+            SdkResult sdkResult;
+            if (matchingResolversManifests.Count != 0)
+            {
+                // First pass.
+                resolvers = GetResolvers(matchingResolversManifests, loggingContext, sdkReferenceLocation);
+
+                if (TryResolveSdkUsingSpecifiedResolvers(
+                    resolvers,
+                    submissionId,
+                    sdk,
+                    loggingContext,
+                    sdkReferenceLocation,
+                    solutionPath,
+                    projectPath,
+                    interactive,
+                    isRunningInVisualStudio,
+                    out sdkResult))
+                {
+                    return sdkResult;
+                }
+            }
+
+            // Second pass: fallback to general resolvers. 
+            resolvers = GetResolvers(
+                _generalResolversManifestsRegistry,
+                loggingContext,
+                sdkReferenceLocation).ToList();
+
+            if (TryResolveSdkUsingSpecifiedResolvers(
+                resolvers,
+                submissionId,
+                sdk,
+                loggingContext,
+                sdkReferenceLocation,
+                solutionPath,
+                projectPath,
+                interactive,
+                isRunningInVisualStudio,
+                out sdkResult))
+            {
+                return sdkResult;
+            }
+
+            // No resolvers resolved the sdk.
+            return new SdkResult(sdk, null, null);
+        }
+
+        private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation)
+        {
+            // Create a sorted by priority list of resolvers. Load them if needed.
+            List<SdkResolver> resolvers = new List<SdkResolver>();
+            foreach (var resolverManifest in resolversManifests)
+            {
+                if (!_manifestToResolvers.TryGetValue(resolverManifest, out IList<SdkResolver> newResolvers))
+                {
+                    lock (_lockObject)
+                    {
+                        if (!_manifestToResolvers.TryGetValue(resolverManifest, out newResolvers))
+                        {
+                            // Loading of the needed resolvers.
+                            MSBuildEventSource.Log.SdkResolverServiceLoadResolversStart();
+                            newResolvers = _sdkResolverLoader.LoadResolversFromManifest(resolverManifest, loggingContext, sdkReferenceLocation);
+                            _manifestToResolvers[resolverManifest] = newResolvers;
+                            MSBuildEventSource.Log.SdkResolverServiceLoadResolversStop(resolverManifest.DisplayName, newResolvers.Count);
+                        }
+                    }
+                }
+
+                resolvers.AddRange(newResolvers);
+            }
+
+            resolvers.Sort((l, r) => l.Priority.CompareTo(r.Priority));
+            return resolvers;
+        }
+
+        private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        {
+            // Lazy initialize all SDK resolvers
+            if (_resolversList == null)
             {
                 Initialize(loggingContext, sdkReferenceLocation);
             }
 
+            TryResolveSdkUsingSpecifiedResolvers(
+                _resolversList,
+                submissionId,
+                sdk,
+                loggingContext,
+                sdkReferenceLocation,
+                solutionPath,
+                projectPath,
+                interactive,
+                isRunningInVisualStudio,
+                out SdkResult sdkResult);
+
+            return sdkResult;
+        }
+
+        private bool TryResolveSdkUsingSpecifiedResolvers(IList<SdkResolver> resolvers, int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, out SdkResult sdkResult)
+        {
             List<SdkResult> results = new List<SdkResult>();
 
             // Loop through resolvers which have already been sorted by priority, returning the first result that was successful
@@ -105,7 +260,7 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
 
             loggingContext.LogComment(MessageImportance.Low, "SdkResolving", sdk.ToString());
 
-            foreach (SdkResolver sdkResolver in _resolvers)
+            foreach (SdkResolver sdkResolver in resolvers)
             {
                 SdkResolverContext context = new SdkResolverContext(buildEngineLogger, projectPath, solutionPath, ProjectCollection.Version, interactive, isRunningInVisualStudio)
                 {
@@ -157,7 +312,8 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
                     // Associate the element location of the resolved SDK reference
                     result.ElementLocation = sdkReferenceLocation;
 
-                    return result;
+                    sdkResult = result;
+                    return true;
                 }
 
                 results.Add(result);
@@ -176,7 +332,8 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
                 }
             }
 
-            return new SdkResult(sdk, null, null);
+            sdkResult = new SdkResult(sdk, null, null);
+            return false;
         }
 
         /// <summary>
@@ -191,7 +348,28 @@ internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<
                 _sdkResolverLoader = resolverLoader;
             }
 
-            _resolvers = resolvers;
+            _specificResolversManifestsRegistry = null;
+            _generalResolversManifestsRegistry = null;
+            _manifestToResolvers = null;
+            _resolversList = null;
+
+            if (resolvers != null)
+            {
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                {
+                    _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
+                    _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
+                    _manifestToResolvers = new Dictionary<SdkResolverManifest, IList<SdkResolver>>();
+
+                    SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(DisplayName: "TestResolversManifest", Path: null, ResolvableSdkRegex: null);
+                    _generalResolversManifestsRegistry.Add(sdkResolverManifest);
+                    _manifestToResolvers[sdkResolverManifest] = resolvers;
+                }
+                else
+                {
+                    _resolversList = resolvers;
+                }
+            }
         }
 
         private static void LogWarnings(LoggingContext loggingContext, ElementLocation location, SdkResult result)
@@ -232,14 +410,58 @@ private void Initialize(LoggingContext loggingContext, ElementLocation location)
         {
             lock (_lockObject)
             {
-                if (_resolvers != null)
+                if (_resolversList != null)
                 {
                     return;
                 }
 
                 MSBuildEventSource.Log.SdkResolverServiceInitializeStart();
-                _resolvers = _sdkResolverLoader.LoadResolvers(loggingContext, location);
-                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolvers.Count);
+                _resolversList = _sdkResolverLoader.LoadAllResolvers(loggingContext, location);
+                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolversList.Count);
+            }
+        }
+
+        private void RegisterResolversManifests(LoggingContext loggingContext, ElementLocation location)
+        {
+            lock (_lockObject)
+            {
+                if (_specificResolversManifestsRegistry != null && _generalResolversManifestsRegistry != null)
+                {
+                    return;
+                }
+
+                MSBuildEventSource.Log.SdkResolverServiceFindResolversManifestsStart();
+                var allResolversManifests = _sdkResolverLoader.GetResolversManifests(loggingContext, location);
+
+                _manifestToResolvers = new Dictionary<SdkResolverManifest, IList<SdkResolver>>();
+
+                // Load and add the manifest for the default resolvers, located directly in this dll.
+                IList<SdkResolver> defaultResolvers = _sdkResolverLoader.GetDefaultResolvers(loggingContext, location);
+                if (defaultResolvers.Count > 0)
+                {
+                    MSBuildEventSource.Log.SdkResolverServiceLoadResolversStart();
+                    SdkResolverManifest sdkDefaultResolversManifest = new SdkResolverManifest(DisplayName: "DefaultResolversManifest", Path: null, ResolvableSdkRegex: null);
+                    allResolversManifests.Add(sdkDefaultResolversManifest);
+                    _manifestToResolvers[sdkDefaultResolversManifest] = defaultResolvers;
+                    MSBuildEventSource.Log.SdkResolverServiceLoadResolversStop(sdkDefaultResolversManifest.DisplayName, defaultResolvers.Count);
+                }
+
+                MSBuildEventSource.Log.SdkResolverServiceFindResolversManifestsStop(allResolversManifests.Count);
+
+                // Break the list of all resolvers manifests into two parts: manifests with specific and general resolvers.
+                _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
+                _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
+                foreach (SdkResolverManifest manifest in allResolversManifests)
+                {
+                    if (manifest.ResolvableSdkRegex == null)
+                    {
+                        _generalResolversManifestsRegistry.Add(manifest);
+                    }
+                    else
+                    {
+                        _specificResolversManifestsRegistry.Add(manifest);
+                    }
+                }
             }
         }
 
@@ -250,7 +472,9 @@ private void SetResolverState(int submissionId, SdkResolver resolver, object sta
             {
                 ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(
                     submissionId,
-                    _ => new ConcurrentDictionary<SdkResolver, object>(NativeMethodsShared.GetLogicalCoreCount(), _resolvers.Count));
+                    _ => new ConcurrentDictionary<SdkResolver, object>(
+                        NativeMethodsShared.GetLogicalCoreCount(),
+                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) ? _specificResolversManifestsRegistry.Count + _generalResolversManifestsRegistry.Count : _resolversList.Count));
 
                 resolverState.AddOrUpdate(resolver, state, (sdkResolver, obj) => state);
             }
diff --git a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
index 64da2af0c03..83b3218f3fe 100644
--- a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
+++ b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
@@ -58,6 +58,12 @@ public ConfigurationMetadata(string projectFullPath, PropertyDictionary<ProjectP
             _toolsVersion = MSBuildConstants.CurrentToolsVersion;
             _globalProperties = globalProperties;
         }
+        public ConfigurationMetadata(string projectFullPath, PropertyDictionary<ProjectPropertyInstance> globalProperties, string previousPlatform, string previousPlatformLookupTable, bool isSetPlatformHardCoded) : this(projectFullPath, globalProperties)
+        {
+            PreviousPlatform = previousPlatform;
+            PreviousPlatformLookupTable = previousPlatformLookupTable;
+            IsSetPlatformHardCoded = isSetPlatformHardCoded;
+        }
 
         public ConfigurationMetadata(ITranslator translator)
         {
@@ -81,6 +87,11 @@ public ConfigurationMetadata(ITranslator translator)
         /// </summary>
         public string ToolsVersion => _toolsVersion;
 
+        public string PreviousPlatform { get; } = "";
+
+        public string PreviousPlatformLookupTable { get; } = "";
+        public bool IsSetPlatformHardCoded { get; } = false;
+
         private PropertyDictionary<ProjectPropertyInstance> _globalProperties;
 
         /// <summary>
@@ -167,7 +178,9 @@ private bool InternalEquals(ConfigurationMetadata other)
 
             return ProjectFullPath.Equals(other.ProjectFullPath, StringComparison.OrdinalIgnoreCase) &&
                    ToolsVersion.Equals(other.ToolsVersion, StringComparison.OrdinalIgnoreCase) &&
-                   GlobalProperties.Equals(other.GlobalProperties);
+                   GlobalProperties.Equals(other.GlobalProperties) &&
+                   PreviousPlatform.Equals(other.PreviousPlatform, StringComparison.OrdinalIgnoreCase) &&
+                   PreviousPlatformLookupTable.Equals(other.PreviousPlatformLookupTable, StringComparison.OrdinalIgnoreCase);
         }
 
         private string DebugString()
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 46b24084309..9bc57cab1ed 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -19,9 +19,7 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-#if FEATURE_WIN32_REGISTRY
 using Microsoft.Win32;
-#endif
 using AvailableStaticMethods = Microsoft.Build.Internal.AvailableStaticMethods;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
@@ -1190,12 +1188,11 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         }
                         else if ((expression.Length - (propertyStartIndex + 2)) > 9 && tryExtractRegistryFunction && s_invariantCompareInfo.IndexOf(expression, "Registry:", propertyStartIndex + 2, 9, CompareOptions.OrdinalIgnoreCase) == propertyStartIndex + 2)
                         {
-                            // if FEATURE_WIN32_REGISTRY is off, treat the property value as if there's no Registry value at that location, rather than fail
                             propertyBody = expression.Substring(propertyStartIndex + 2, propertyEndIndex - propertyStartIndex - 2);
 
                             // If the property body starts with any of our special objects, then deal with them
                             // This is a registry reference, like $(Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation)
-                            propertyValue = ExpandRegistryValue(propertyBody, elementLocation); // This func returns an empty string if not FEATURE_WIN32_REGISTRY
+                            propertyValue = ExpandRegistryValue(propertyBody, elementLocation); // This func returns an empty string if not on Windows
                         }
 
                         // Compat hack: as a special case, $(HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\9.0\VSTSDB@VSTSDBDirectory) should return String.Empty
@@ -1571,7 +1568,6 @@ private static object ExpandMSBuildThisFileProperty(string propertyName, IElemen
                 return value;
             }
 
-#if FEATURE_WIN32_REGISTRY
             /// <summary>
             /// Given a string like "Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation", return the value at that location
             /// in the registry. If the value isn't found, returns String.Empty.
@@ -1582,6 +1578,16 @@ private static object ExpandMSBuildThisFileProperty(string propertyName, IElemen
             /// </summary>
             private static string ExpandRegistryValue(string registryExpression, IElementLocation elementLocation)
             {
+#if RUNTIME_TYPE_NETCORE
+                // .NET Core MSBuild used to always return empty, so match that behavior
+                // on non-Windows (no registry), and with a changewave (in case someone
+                // had a registry property and it breaks when it lights up).
+                if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                {
+                    return string.Empty;
+                }
+#endif
+
                 // Remove "Registry:" prefix
                 string registryLocation = registryExpression.Substring(9);
 
@@ -1655,15 +1661,6 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
 
                 return result;
             }
-#else
-            /// <summary>
-            /// Given a string like "Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation", returns String.Empty, as FEATURE_WIN32_REGISTRY is off.
-            /// </summary>
-            private static string ExpandRegistryValue(string registryExpression, IElementLocation elementLocation)
-            {
-                return String.Empty;
-            }
-#endif
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index bd073584157..ce0f37bbd56 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 using System.Text;
 using System.Text.RegularExpressions;
 
@@ -28,11 +29,11 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal static class IntrinsicFunctions
     {
-#if FEATURE_WIN32_REGISTRY
+#pragma warning disable CA1416 // Platform compatibility: we'll only use this on Windows
         private static readonly object[] DefaultRegistryViews = new object[] { RegistryView.Default };
+#pragma warning restore CA1416
 
         private static readonly Lazy<Regex> RegistrySdkRegex = new Lazy<Regex>(() => new Regex(@"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$", RegexOptions.IgnoreCase));
-#endif // FEATURE_WIN32_REGISTRY
 
         private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => new NuGetFrameworkWrapper());
 
@@ -164,12 +165,20 @@ internal static int BitwiseNot(int first)
             return ~first;
         }
 
-#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Get the value of the registry key and value, default value is null
         /// </summary>
         internal static object GetRegistryValue(string keyName, string valueName)
         {
+#if RUNTIME_TYPE_NETCORE
+            // .NET Core MSBuild used to always return empty, so match that behavior
+            // on non-Windows (no registry), and with a changewave (in case someone
+            // had a registry property and it breaks when it lights up).
+            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return null;
+            }
+#endif
             return Registry.GetValue(keyName, valueName, null /* null to match the $(Regsitry:XYZ@ZBC) behaviour */);
         }
 
@@ -178,11 +187,30 @@ internal static object GetRegistryValue(string keyName, string valueName)
         /// </summary>
         internal static object GetRegistryValue(string keyName, string valueName, object defaultValue)
         {
+#if RUNTIME_TYPE_NETCORE
+            // .NET Core MSBuild used to always return empty, so match that behavior
+            // on non-Windows (no registry), and with a changewave (in case someone
+            // had a registry property and it breaks when it lights up).
+            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return defaultValue;
+            }
+#endif
             return Registry.GetValue(keyName, valueName, defaultValue);
         }
 
         internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, params object[] views)
         {
+#if RUNTIME_TYPE_NETCORE
+            // .NET Core MSBuild used to always return empty, so match that behavior
+            // on non-Windows (no registry), and with a changewave (in case someone
+            // had a registry property and it breaks when it lights up).
+            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return defaultValue;
+            }
+#endif
+
             if (views == null || views.Length == 0)
             {
                 views = DefaultRegistryViews;
@@ -196,6 +224,16 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
         /// </summary>
         internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, ArraySegment<object> views)
         {
+#if RUNTIME_TYPE_NETCORE
+            // .NET Core MSBuild used to always return empty, so match that behavior
+            // on non-Windows (no registry), and with a changewave (in case someone
+            // had a registry property and it breaks when it lights up).
+            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                return defaultValue;
+            }
+#endif
+
             // We will take on handing of default value
             // A we need to act on the null return from the GetValue call below
             // so we can keep searching other registry views
@@ -263,33 +301,6 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
             return result;
         }
 
-#else // FEATURE_WIN32_REGISTRY is off, need to mock the function names to let scrips call these property functions and get NULLs rather than fail with errors
-
-        /// <summary>
-        /// Get the value of the registry key and value, default value is null
-        /// </summary>
-        internal static object GetRegistryValue(string keyName, string valueName)
-        {
-            return null; // FEATURE_WIN32_REGISTRY is off, need to mock the function names to let scrips call these property functions and get NULLs rather than fail with errors
-        }
-
-        /// <summary>
-        /// Get the value of the registry key and value
-        /// </summary>
-        internal static object GetRegistryValue(string keyName, string valueName, object defaultValue)
-        {
-            return defaultValue; // FEATURE_WIN32_REGISTRY is off, need to mock the function names to let scrips call these property functions and get NULLs rather than fail with errors
-        }
-
-        /// <summary>
-        /// Get the value of the registry key from one of the RegistryView's specified
-        /// </summary>
-        internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, params object[] views)
-        {
-            return defaultValue; // FEATURE_WIN32_REGISTRY is off, need to mock the function names to let scrips call these property functions and get NULLs rather than fail with errors
-        }
-#endif
-
         /// <summary>
         /// Given the absolute location of a file, and a disc location, returns relative file path to that disk location.
         /// Throws UriFormatException.
@@ -595,7 +606,6 @@ internal static List<string> __GetListTest()
 
 #endregion
 
-#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Following function will parse a keyName and returns the basekey for it.
         /// It will also store the subkey name in the out parameter.
@@ -603,6 +613,7 @@ internal static List<string> __GetListTest()
         /// The return value shouldn't be null.
         /// Taken from: \ndp\clr\src\BCL\Microsoft\Win32\Registry.cs
         /// </summary>
+        [SupportedOSPlatform("windows")]
         private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView view, out string subKeyName)
         {
             if (keyName == null)
@@ -664,6 +675,5 @@ private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView vi
 
             return basekey;
         }
-#endif
     }
 }
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index c419203fb47..28387389e8c 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -22,6 +22,10 @@ namespace Microsoft.Build.Graph
 {
     internal class GraphBuilder
     {
+        private const string PlatformLookupTableMetadataName = "PlatformLookupTable";
+        private const string PlatformMetadataName = "Platform";
+        private const string PlatformsMetadataName = "Platforms";
+        private const string EnableDynamicPlatformResolutionMetadataName = "EnableDynamicPlatformResolution";
         internal const string SolutionItemReference = "_SolutionReference";
         
         /// <summary>
@@ -48,6 +52,8 @@ internal class GraphBuilder
         private readonly ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory;
         private IReadOnlyDictionary<string, IReadOnlyCollection<string>> _solutionDependencies;
 
+        private bool PlatformNegotiationEnabled = false;
+
         public GraphBuilder(
             IEnumerable<ProjectGraphEntryPoint> entryPoints,
             ProjectCollection projectCollection,
@@ -499,18 +505,44 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)
         {
             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.
             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();
+            ProjectGraphNode graphNode;
+            ProjectInstance projectInstance;
+            var negotiatePlatform = PlatformNegotiationEnabled && !configurationMetadata.IsSetPlatformHardCoded;
+
+            projectInstance = _projectInstanceFactory(
+                                configurationMetadata.ProjectFullPath,
+                                negotiatePlatform ? null : globalProperties, // Platform negotiation requires an evaluation with no global properties first
+                                _projectCollection);
 
-            var projectInstance = _projectInstanceFactory(
-                configurationMetadata.ProjectFullPath,
-                globalProperties,
-                _projectCollection);
+            if (ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
+            {
+                PlatformNegotiationEnabled = true;
+            }
 
             if (projectInstance == null)
             {
                 throw new InvalidOperationException(ResourceUtilities.GetResourceString("NullReferenceFromProjectInstanceFactory"));
             }
 
-            var graphNode = new ProjectGraphNode(projectInstance);
+            if (negotiatePlatform)
+            {
+                var selectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformMetadataName), projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), configurationMetadata.PreviousPlatformLookupTable, projectInstance.FullPath, configurationMetadata.PreviousPlatform);
+
+                if (selectedPlatform.Equals(String.Empty))
+                {
+                    globalProperties.Remove(PlatformMetadataName);
+                }
+                else
+                {
+                    globalProperties[PlatformMetadataName] = selectedPlatform;
+                }
+                projectInstance = _projectInstanceFactory(
+                                configurationMetadata.ProjectFullPath,
+                                globalProperties,
+                                _projectCollection);           
+            }
+
+            graphNode = new ProjectGraphNode(projectInstance);
 
             var referenceInfos = ParseReferences(graphNode);
 
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 08e0e5a56b8..a838844f160 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -38,7 +38,7 @@ private ProjectInterpretation()
         {
         }
 
-        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();
+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] { (GlobalPropertiesModifier)ProjectReferenceGlobalPropertiesModifier }.ToImmutableList();
 
         internal enum ProjectType
         {
@@ -98,7 +98,16 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
 
                 var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReferenceItem, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);
 
-                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);
+                var requesterPlatform = "";
+                var requesterPlatformLookupTable = "";
+
+                if (ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue("EnableDynamicPlatformResolution")))
+                {
+                    requesterPlatform = requesterInstance.GetPropertyValue("Platform");
+                    requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
+                }
+
+                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties, requesterPlatform, requesterPlatformLookupTable, projectReferenceItem.HasMetadata("SetPlatform"));
 
                 yield return new ReferenceInfo(referenceConfig, projectReferenceItem);
             }
@@ -196,7 +205,7 @@ private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(Pr
                     project: outerBuild,
                     itemType: InnerBuildReferenceItemName,
                     includeEscaped: outerBuild.FullPath,
-                    directMetadata: new[] {new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}")},
+                    directMetadata: new[] { new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}") },
                     definingFileEscaped: outerBuild.FullPath);
             }
         }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index db86e8cbc7a..30c38da91e5 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -120,6 +120,10 @@
     <Compile Include="..\Shared\NodeShutdown.cs" />
     <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\ProcessExtensions.cs" />
+    <Compile Include="..\Shared\PlatformNegotiation.cs">
+      <Link>PlatformNegotiation.cs</Link>
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="..\Shared\TaskLoggingHelper.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\TaskLoggingHelper.cs</Link>
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index e273cd9bc81..6696e3861ba 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -87,7 +87,6 @@
   <PropertyGroup Condition="'$(NetCoreBuild)'=='true'">
     <CompilerToolsDir>$([System.IO.Path]::Combine($(ToolPackagesDir)Microsoft.Net.Compilers, $(CompilerToolsVersion), "tools"))$([System.IO.Path]::DirectorySeparatorChar)</CompilerToolsDir>
     <DefineConstants>$(DefineConstants);FEATURE_ASSEMBLYLOADCONTEXT</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_PROCESSSTARTINFO_ENVIRONMENT</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_RUNTIMEINFORMATION</DefineConstants>
     <DefineConstants>$(DefineConstants);USE_MSBUILD_DLL_EXTN</DefineConstants>
     <DefineConstants>$(DefineConstants);WORKAROUND_COREFX_19110</DefineConstants>
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index b4e335f7849..f2f4cc9070f 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -599,6 +599,30 @@ public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStop(int submis
             WriteEvent(80, submissionId, sdkName, solutionPath, projectPath, success, wasResultCached);
         }
 
+        [Event(81, Keywords = Keywords.All)]
+        public void SdkResolverServiceFindResolversManifestsStart()
+        {
+            WriteEvent(81);
+        }
+
+        [Event(82, Keywords = Keywords.All)]
+        public void SdkResolverServiceFindResolversManifestsStop(int resolverManifestCount)
+        {
+            WriteEvent(82, resolverManifestCount);
+        }
+
+        [Event(83, Keywords = Keywords.All)]
+        public void SdkResolverServiceLoadResolversStart()
+        {
+            WriteEvent(83);
+        }
+
+        [Event(84, Keywords = Keywords.All)]
+        public void SdkResolverServiceLoadResolversStop(string manifestName, int resolverCount)
+        {
+            WriteEvent(84, manifestName, resolverCount);
+        }
+
         #endregion
     }
 }
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index c69053daa0c..8bf7155cbac 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -86,10 +86,8 @@
     <value>MSBUILD : error MSB1027: The -noAutoResponse switch cannot be specified in the MSBuild.rsp auto-response file, nor in any response file that is referenced by the auto-response file.</value>
     <comment>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</comment>
   </data>
-  <data name="CopyrightMessage" UESanitized="true" Visibility="Public">
-    <value>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</value>
+  <data name="MSBuildVersionMessage" UESanitized="true" Visibility="Public">
+    <value>MSBuild version {0} for {1}</value>
     <comment>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</comment>
   </data>
   <data name="DuplicateProjectSwitchError" UESanitized="true" Visibility="Public">
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 7ccdc9ab43e..bd1cd1bdadb 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: Přepínač -noAutoResponse nelze zadat v souboru automatických odpovědí MSBuild.rsp ani v žádném jiném souboru odpovědí, na který se v souboru automatických odpovědí odkazuje.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine verze {0} pro {1}
-Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">MSBuild verze {0} pro {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index e2c30e3ac4f..3bd8832ef24 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: Der Schalter "-noAutoResponse" kann weder in der automatischen Antwortdatei "MSBuild.rsp" noch in einer anderen Antwortdatei verwendet werden, auf die die automatische Antwortdatei verweist.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R)-Build-Engine, Version {0} für {1}
-Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">MSBuild, Version {0} für {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 0195e35549f..f32a83120a6 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: El modificador -noAutoResponse no puede especificarse en el archivo de respuesta automática MSBuild.rsp ni en ningún archivo de respuesta al que el archivo de respuesta automática haga referencia.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine versión {0} para {1}
-Copyright (C) Microsoft Corporation. Todos los derechos reservados.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">MSBuild versión {0} para {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 3065aadd997..11682e905cd 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: Impossible de spécifier le commutateur -noAutoResponse dans le fichier réponse automatique MSBuild.rsp, ni dans aucun autre fichier réponse référencé par le fichier réponse automatique.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine version {0} pour {1}
-Copyright (C) Microsoft Corporation. Tous droits réservés.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">MSBuild version {0} pour {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 9c59271398b..a428d1d5a0b 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: non è possibile specificare l'opzione -noAutoResponse nel file di risposta automatica MSBuild.rsp o in file di risposta a cui il file di risposta automatica fa riferimento.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine versione {0} per {1}
-Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">MSBuild versione {0} per {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 9c2bee6bc61..4be4c877016 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp 自動応答ファイルや、自動応答ファイルによって参照される応答ファイルに -noAutoResponse スイッチを指定することはできません。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">{1} 向け Microsoft (R) Build Engine バージョン {0}
-Copyright (C) Microsoft Corporation.All rights reserved.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">{1} 向け MSBuild バージョン {0}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 3d3b611cc74..bec3bfa7737 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp 자동 지시 파일과 자동 지시 파일에서 참조하는 모든 지시 파일에는 -noAutoResponse 스위치를 지정할 수 없습니다.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">{1}용 Microsoft (R) Build Engine 버전 {0}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">{1}용 MSBuild 버전 {0}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 2c2f7464b68..860285ca583 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: przełącznika -noAutoResponse nie można określić w pliku autoodpowiedzi MSBuild.rsp ani w żadnym pliku odpowiedzi, do którego odwołuje się plik autoodpowiedzi.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine {0} dla platformy {1}
-Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">MSBuild {0} dla platformy {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 6dc052fc5bd..1be1bc214f3 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: A opção /noAutoResponse não pode ser especificada no arquivo de resposta automática MSBuild.rsp nem em qualquer arquivo de resposta usado como referência para o arquivo de resposta automática.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft(R) Build Engine versão {0} para {1} 
-Copyright (C) Microsoft Corporation. Todos os direitos reservados.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">MSBuild versão {0} para {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index b39acf70142..16a6ce9c36d 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: ключ noAutoResponse не может быть указан в файле автоответа MSBuild.rsp или в любом другом файле ответа, на который файл автоответа ссылается.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine версии {0} для {1}
-(C) Корпорация Майкрософт (Microsoft Corporation). Все права защищены.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">MSBuild версии {0} для {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index eb65858ec3a..688d9d20c99 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse anahtarı, MSBuild.rsp otomatik yanıt dosyasında ve bu dosyanın başvuruda bulunduğu herhangi bir yanıt dosyasında belirtilemez.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">{1} için Microsoft (R) Build Engine sürüm {0}
-Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">{1} için MSBuild sürüm {0}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.xlf b/src/MSBuild/Resources/xlf/Strings.xlf
index c9f006f4aba..a16ca1ca45e 100644
--- a/src/MSBuild/Resources/xlf/Strings.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.xlf
@@ -21,10 +21,8 @@
         <source>MSBUILD : error MSB1027: The /noautoresponse switch cannot be specified in the MSBuild.rsp auto-response file, nor in any response file that is referenced by the auto-response file.</source>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "/noautoresponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="DuplicateProjectSwitchError">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index a4fc1ecdd32..a9084ac4168 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: 不能在 MSBuild.rsp 自动响应文件中或由该自动响应文件引用的任何响应文件中指定 -noAutoResponse 开关。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">用于 {1} 的 Microsoft (R) 生成引擎版本 {0}
-版权所有(C) Microsoft Corporation。保留所有权利。
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">用于 {1} 的 生成引擎版本 {0}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 2dc040b10b9..7c5855909bd 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -28,13 +28,9 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse 參數不能在 MSBuild.rsp 自動回應檔中指定，也不能在自動回應檔所參考的任何回應檔中指定。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="CopyrightMessage">
-        <source>Microsoft (R) Build Engine version {0} for {1}
-Copyright (C) Microsoft Corporation. All rights reserved.
-</source>
-        <target state="translated">Microsoft (R) Build Engine for {1} {0} 版
-Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
-</target>
+      <trans-unit id="MSBuildVersionMessage">
+        <source>MSBuild version {0} for {1}</source>
+        <target state="needs-review-translation">MSBuild for {1} {0} 版</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 42251449d2a..c5f21d2b46d 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2074,7 +2074,7 @@ string commandLine
             // NOTE: we heed the nologo switch even if there are switch errors
             if (!recursing && !commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoLogo] && !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Preprocess))
             {
-                DisplayCopyrightMessage();
+                DisplayVersionMessage();
             }
 
 
@@ -3664,9 +3664,9 @@ private static void ThrowInvalidToolsVersionInitializationException(IEnumerable<
         }
 
         /// <summary>
-        /// Displays the application copyright message/logo.
+        /// Displays the application version message/logo.
         /// </summary>
-        private static void DisplayCopyrightMessage()
+        private static void DisplayVersionMessage()
         {
 #if RUNTIME_TYPE_NETCORE
             const string frameworkName = ".NET";
@@ -3676,7 +3676,7 @@ private static void DisplayCopyrightMessage()
             const string frameworkName = ".NET Framework";
 #endif
 
-            Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CopyrightMessage", ProjectCollection.DisplayVersion, frameworkName));
+            Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("MSBuildVersionMessage", ProjectCollection.DisplayVersion, frameworkName));
         }
 
         /// <summary>
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 31918e3e620..941490997b3 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -52,7 +52,7 @@
           <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="6.0.0.0" />
           <codeBase version="6.0.0.0" href="..\Microsoft.IO.Redist.dll"/>
         </dependentAssembly>
-        
+
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -78,8 +78,8 @@
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
-          <codeBase version="5.0.0.0" href="..\System.Collections.Immutable.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\System.Collections.Immutable.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -93,8 +93,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
-          <codeBase version="4.0.0.0" href="..\System.Resources.Extensions.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\System.Resources.Extensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 0f762dab90c..ad07688b88f 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -58,7 +58,7 @@
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -70,7 +70,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 0bf416196af..b2579ae8610 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -526,6 +526,7 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,
                 CurrentMSBuildConfigurationFile = string.Concat(currentMSBuildExePath, ".config");
                 MSBuildToolsDirectory32 = CurrentMSBuildToolsDirectory;
                 MSBuildToolsDirectory64 = CurrentMSBuildToolsDirectory;
+                MSBuildToolsDirectoryRoot = CurrentMSBuildToolsDirectory;
             }
 
             // We can't detect an environment, don't try to set other paths.
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index fbe9d5e00fb..8d1e1c38e7a 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -1,7 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
+
+using System;
 using System.Collections.Immutable;
 using System.IO;
 using System.Reflection;
@@ -15,6 +18,8 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal class MSBuildLoadContext : AssemblyLoadContext
     {
+        private AssemblyDependencyResolver? _resolver;
+
         private readonly string _directory;
 
         internal static readonly ImmutableHashSet<string> WellKnownAssemblyNames =
@@ -31,6 +36,16 @@ public MSBuildLoadContext(string assemblyPath)
             : base($"MSBuild plugin {assemblyPath}")
         {
             _directory = Directory.GetParent(assemblyPath)!.FullName;
+
+            // We check for the assemblyPath because it will fail with an AssemblyDependencyResolver-specific error
+            // if it does not exist. We should instead fall back to the standard failure.
+            // The second check is because AssemblyDependencyResolver loads assemblies differently than we do by default.
+            // We should maintain previous behavior in the absence of new data (a .deps.json file) indicating that we
+            // should do something different.
+            // Setting the _resolver to null essentially just opts out of the new behavior.
+            _resolver = File.Exists(assemblyPath) && File.Exists(Path.ChangeExtension(assemblyPath, ".deps.json"))
+                ? new AssemblyDependencyResolver(assemblyPath) :
+                null;
         }
 
         protected override Assembly? Load(AssemblyName assemblyName)
@@ -42,6 +57,19 @@ public MSBuildLoadContext(string assemblyPath)
                 return null;
             }
 
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                // respect plugin.dll.json with the AssemblyDependencyResolver
+                string? assemblyPath = _resolver?.ResolveAssemblyToPath(assemblyName);
+                if (assemblyPath != null)
+                {
+                    return LoadFromAssemblyPath(assemblyPath);
+                }
+            }
+
+            // Fall back to the older MSBuild-on-Core behavior to continue to support
+            // plugins that don't ship a .deps.json
+
             foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
                 // If no culture is specified, attempt to load directly from
                 // the known dependency paths.
@@ -73,7 +101,6 @@ public MSBuildLoadContext(string assemblyPath)
             // - the assembly from the user specified path is loaded, if it exists, into the custom ALC, or
             // - if the simple name of the assembly exists in the same folder as msbuild.exe, then that assembly gets loaded
             //   into the default ALC (so it's shared with other uses).
-
             var assemblyNameInExecutableDirectory = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
                 $"{assemblyName.Name}.dll");
 
@@ -84,5 +111,19 @@ public MSBuildLoadContext(string assemblyPath)
 
             return null;
         }
+
+        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
+        {
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                string? libraryPath = _resolver?.ResolveUnmanagedDllToPath(unmanagedDllName);
+                if (libraryPath != null)
+                {
+                    return LoadUnmanagedDllFromPath(libraryPath);
+                }
+            }
+
+            return base.LoadUnmanagedDll(unmanagedDllName);
+        }
     }
 }
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
new file mode 100644
index 00000000000..a0389604db3
--- /dev/null
+++ b/src/Shared/PlatformNegotiation.cs
@@ -0,0 +1,110 @@
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Evaluation;
+
+namespace Microsoft.Build.Shared
+{
+    /// <summary>
+    /// This class contains only static methods, which are used in both the 
+    /// tasks and graph projects in order for two projects to negotiate which platform a projectreference
+    /// should be built as.
+    /// </summary>
+    internal static class PlatformNegotiation
+    {
+        internal static string GetNearestPlatform(string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, string platformLookupTable, string projectPath, string currentProjectPlatform, TaskLoggingHelper? log = null)
+        {
+            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(platformLookupTable, log);
+
+            if (string.IsNullOrEmpty(projectReferencePlatformsMetadata) && string.IsNullOrEmpty(referencedProjectPlatform))
+                {
+                    log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoPlatformsListed", projectPath);
+                    return string.Empty;
+                }
+
+                // Pull platformLookupTable metadata from the referenced project. This allows custom
+                // mappings on a per-ProjectReference basis.
+                Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata, log);
+
+                HashSet<string> projectReferencePlatforms = new HashSet<string>();
+                foreach (string s in projectReferencePlatformsMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
+                {
+                    projectReferencePlatforms.Add(s);
+                }
+
+                string buildProjectReferenceAs = string.Empty;
+
+                // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
+                // Don't set `buildProjectReferenceAs` and the `_GetProjectReferencePlatformProperties` target will handle the rest.
+                if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(currentProjectPlatform, StringComparison.OrdinalIgnoreCase))
+                {
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", projectPath, referencedProjectPlatform);
+                }
+                // Prefer matching platforms
+                else if (projectReferencePlatforms.Contains(currentProjectPlatform))
+                {
+                    buildProjectReferenceAs = currentProjectPlatform;
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.SamePlatform");
+                }
+                // Prioritize platformLookupTable **metadata** attached to the ProjectReference item
+                // before the current project's table. We do this to allow per-ProjectReference fine tuning.
+                else if (projectReferenceLookupTable != null &&
+                        projectReferenceLookupTable.ContainsKey(currentProjectPlatform) &&
+                        projectReferencePlatforms.Contains(projectReferenceLookupTable[currentProjectPlatform]))
+                {
+                    buildProjectReferenceAs = projectReferenceLookupTable[currentProjectPlatform];
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, projectReferenceLookupTableMetadata);
+                }
+                // Current project's translation table follows
+                else if (currentProjectLookupTable != null &&
+                        currentProjectLookupTable.ContainsKey(currentProjectPlatform) &&
+                        projectReferencePlatforms.Contains(currentProjectLookupTable[currentProjectPlatform]))
+                {
+                    buildProjectReferenceAs = currentProjectLookupTable[currentProjectPlatform];
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, platformLookupTable);
+                }
+                // AnyCPU if possible
+                else if (projectReferencePlatforms.Contains("AnyCPU"))
+                {
+                    buildProjectReferenceAs = "AnyCPU";
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.AnyCPUDefault");
+                }
+                else
+                {
+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine 
+                    // Platform/PlatformTarget when this is the case.
+                    log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", projectPath);
+                }
+            return buildProjectReferenceAs;
+        }
+        internal static Dictionary<string, string>? ExtractLookupTable(string stringTable, TaskLoggingHelper? log = null)
+        {
+            if (string.IsNullOrEmpty(stringTable))
+            {
+                return null;
+            }
+
+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+
+            foreach (string s in stringTable.Trim().Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
+            {
+                string[] keyVal = s.Trim().Split(MSBuildConstants.EqualsChar);
+
+                // Invalid table, don't use it.
+                if (keyVal.Length != 2 || string.IsNullOrEmpty(keyVal[0]) || string.IsNullOrEmpty(keyVal[1]))
+                {
+                    log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.InvalidLookupTableFormat", stringTable);
+                    return null;
+                }
+
+                table[keyVal[0]] = keyVal[1];
+            }
+
+            log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.LookupTableParsed", stringTable);
+
+            return table;
+        }
+    }
+}
diff --git a/src/Shared/UnitTests/TypeLoader_Tests.cs b/src/Shared/UnitTests/TypeLoader_Tests.cs
index bf1501860b8..509f4c01565 100644
--- a/src/Shared/UnitTests/TypeLoader_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Tests.cs
@@ -6,8 +6,10 @@
 using System.IO;
 using Microsoft.Build.Shared;
 using System.Reflection;
-using Xunit;
 using Microsoft.Build.UnitTests.Shared;
+using Xunit;
+using Xunit.Abstractions;
+using Shouldly;
 
 #nullable disable
 
@@ -19,6 +21,13 @@ public class TypeLoader_Tests
         private const string ProjectFileName = "portableTaskTest.proj";
         private const string DLLFileName = "PortableTask.dll";
 
+        private readonly ITestOutputHelper _output;
+
+        public TypeLoader_Tests(ITestOutputHelper testOutputHelper)
+        {
+            _output = testOutputHelper;
+        }
+
         [Fact]
         public void Basic()
         {
@@ -50,19 +59,18 @@ public void Regress_Mutation_ParameterOrderDoesntMatter()
         [Fact]
         public void LoadNonExistingAssembly()
         {
-            using (var dir = new FileUtilities.TempWorkingDirectory(ProjectFileFolder))
-            {
-                string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
+            using var dir = new FileUtilities.TempWorkingDirectory(ProjectFileFolder);
 
-                string dllName = "NonExistent.dll";
+            string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + dllName, out successfulExit);
-                Assert.False(successfulExit);
+            string dllName = "NonExistent.dll";
 
-                string dllPath = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, dllName);
-                CheckIfCorrectAssemblyLoaded(output, dllPath, false);
-            }
+            bool successfulExit;
+            string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + dllName, out successfulExit, _output);
+            successfulExit.ShouldBeFalse();
+
+            string dllPath = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, dllName);
+            CheckIfCorrectAssemblyLoaded(output, dllPath, false);
         }
 
         [Fact]
@@ -73,7 +81,7 @@ public void LoadInsideAsssembly()
                 string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
 
                 bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag", out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag", out successfulExit, _output);
                 Assert.True(successfulExit);
 
                 string dllPath = Path.Combine(dir.Path, DLLFileName);
@@ -95,7 +103,7 @@ public void LoadOutsideAssembly()
                 try
                 {
                     bool successfulExit;
-                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + movedDLLPath, out successfulExit);
+                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + movedDLLPath, out successfulExit, _output);
                     Assert.True(successfulExit);
 
                     CheckIfCorrectAssemblyLoaded(output, movedDLLPath);
@@ -119,7 +127,7 @@ public void LoadInsideAssemblyWhenGivenOutsideAssemblyWithSameName()
                 try
                 {
                     bool successfulExit;
-                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + copiedDllPath, out successfulExit);
+                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + copiedDllPath, out successfulExit, _output);
                     Assert.True(successfulExit);
 
                     CheckIfCorrectAssemblyLoaded(output, originalDLLPath);
diff --git a/src/Tasks.UnitTests/RemoveDir_Tests.cs b/src/Tasks.UnitTests/RemoveDir_Tests.cs
index 723ec9df7c3..2becb7a889d 100644
--- a/src/Tasks.UnitTests/RemoveDir_Tests.cs
+++ b/src/Tasks.UnitTests/RemoveDir_Tests.cs
@@ -72,5 +72,32 @@ public void SimpleDelete()
                 }
             }
         }
+
+        /// <summary>
+        /// Regression test: https://github.com/dotnet/msbuild/issues/7563
+        /// </summary>
+        [Fact]
+        public void DeleteEmptyDirectory_WarnsAndContinues()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+               List<TaskItem> list = new List<TaskItem>();
+
+                for (int i = 0; i < 20; i++)
+               {
+                    list.Add(new TaskItem(""));
+               }
+
+               RemoveDir t = new RemoveDir();
+               t.Directories = list.ToArray();
+               t.BuildEngine = new MockEngine(_output);
+               t.Execute().ShouldBeTrue();
+
+                t.RemovedDirectories.Length.ShouldBe(0);
+                ((MockEngine)t.BuildEngine).Warnings.ShouldBe(20);
+               ((MockEngine)t.BuildEngine).AssertLogContains("MSB3232");
+            }
+        }
     }
 }
diff --git a/src/Tasks/CombineTargetFrameworkInfoProperties.cs b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
index 2db3b55580b..4108feb5246 100644
--- a/src/Tasks/CombineTargetFrameworkInfoProperties.cs
+++ b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
@@ -39,8 +39,7 @@ public override bool Execute()
         {
             if (PropertiesAndValues != null)
             {
-                // When removing the change wave, also remove UseAttributeForTargetFrameworkInfoPropertyNames.
-                XElement root = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) || UseAttributeForTargetFrameworkInfoPropertyNames ?
+                XElement root = UseAttributeForTargetFrameworkInfoPropertyNames ?
                     new("TargetFramework", new XAttribute("Name", EscapingUtilities.Escape(RootElementName))) :
                     new(RootElementName);
 
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
index 8bb05df15dd..9787b51e366 100644
--- a/src/Tasks/GetCompatiblePlatform.cs
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -51,8 +51,7 @@ public GetCompatiblePlatform()
 
         public override bool Execute()
         {
-            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(PlatformLookupTable);
-
+            
             AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];
             for (int i = 0; i < AnnotatedProjects.Length; i++)
             {
@@ -62,65 +61,7 @@ public override bool Execute()
                 string projectReferencePlatformsMetadata = AssignedProjectsWithPlatform[i].GetMetadata("Platforms");
                 string projectReferenceLookupTableMetadata = AssignedProjectsWithPlatform[i].GetMetadata("PlatformLookupTable");
 
-                if (string.IsNullOrEmpty(projectReferencePlatformsMetadata) && string.IsNullOrEmpty(referencedProjectPlatform))
-                {
-                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoPlatformsListed", AssignedProjectsWithPlatform[i].ItemSpec);
-                    continue;
-                }
-
-                // Pull platformlookuptable metadata from the referenced project. This allows custom
-                // mappings on a per-ProjectReference basis.
-                Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata);
-
-                HashSet<string> projectReferencePlatforms = new HashSet<string>();
-                foreach (string s in projectReferencePlatformsMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
-                {
-                    projectReferencePlatforms.Add(s);
-                }
-
-                string buildProjectReferenceAs = string.Empty;
-
-                // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
-                // Don't set `buildProjectReferenceAs` and the `_GetProjectReferencePlatformProperties` target will handle the rest.
-                if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(CurrentProjectPlatform, StringComparison.OrdinalIgnoreCase))
-                {
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", AssignedProjectsWithPlatform[i].ItemSpec, referencedProjectPlatform);
-                }
-                // Prefer matching platforms
-                else if (projectReferencePlatforms.Contains(CurrentProjectPlatform))
-                {
-                    buildProjectReferenceAs = CurrentProjectPlatform;
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.SamePlatform");
-                }
-                // Prioritize PlatformLookupTable **metadata** attached to the ProjectReference item
-                // before the current project's table. We do this to allow per-ProjectReference fine tuning.
-                else if (projectReferenceLookupTable != null &&
-                        projectReferenceLookupTable.ContainsKey(CurrentProjectPlatform) &&
-                        projectReferencePlatforms.Contains(projectReferenceLookupTable[CurrentProjectPlatform]))
-                {
-                    buildProjectReferenceAs = projectReferenceLookupTable[CurrentProjectPlatform];
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", CurrentProjectPlatform, buildProjectReferenceAs, projectReferenceLookupTableMetadata);
-                }
-                // Current project's translation table follows
-                else if (currentProjectLookupTable != null &&
-                        currentProjectLookupTable.ContainsKey(CurrentProjectPlatform) &&
-                        projectReferencePlatforms.Contains(currentProjectLookupTable[CurrentProjectPlatform]))
-                {
-                    buildProjectReferenceAs = currentProjectLookupTable[CurrentProjectPlatform];
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", CurrentProjectPlatform, buildProjectReferenceAs, PlatformLookupTable);
-                }
-                // AnyCPU if possible
-                else if (projectReferencePlatforms.Contains("AnyCPU"))
-                {
-                    buildProjectReferenceAs = "AnyCPU";
-                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.AnyCPUDefault");
-                }
-                else
-                {
-                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine 
-                    // Platform/PlatformTarget when this is the case.
-                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", AssignedProjectsWithPlatform[i].ItemSpec);
-                }
+                string? buildProjectReferenceAs = PlatformNegotiation.GetNearestPlatform(referencedProjectPlatform, projectReferencePlatformsMetadata, projectReferenceLookupTableMetadata, PlatformLookupTable, AssignedProjectsWithPlatform[i].ItemSpec, CurrentProjectPlatform, Log);
 
                 AssignedProjectsWithPlatform[i].SetMetadata("NearestPlatform", buildProjectReferenceAs);
                 Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.DisplayChosenPlatform", AssignedProjectsWithPlatform[i].ItemSpec, buildProjectReferenceAs);
@@ -128,33 +69,5 @@ public override bool Execute()
 
             return !Log.HasLoggedErrors;
         }
-
-        private Dictionary<string, string>? ExtractLookupTable(string stringTable)
-        {
-            if (string.IsNullOrEmpty(stringTable))
-            {
-                return null;
-            }
-
-            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-
-            foreach (string s in stringTable.Trim().Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
-            {
-                string[] keyVal = s.Trim().Split(MSBuildConstants.EqualsChar);
-
-                // Invalid table, don't use it.
-                if (keyVal.Length != 2 || string.IsNullOrEmpty(keyVal[0]) || string.IsNullOrEmpty(keyVal[1]))
-                {
-                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.InvalidLookupTableFormat", stringTable);
-                    return null;
-                }
-
-                table[keyVal[0]] = keyVal[1];
-            }
-
-            Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.LookupTableParsed", stringTable);
-
-            return table;
-        }
     }
 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 46a0c77b3e5..c08a5129001 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -191,6 +191,10 @@
     <Compile Include="..\Shared\LanguageParser\VisualBasictokenizer.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\PlatformNegotiation.cs">
+      <Link>PlatformNegotiation.cs</Link>
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="..\Shared\XMakeAttributes.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 01a2850ca17..7b51494d4ed 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1907,9 +1907,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </_AdditionalTargetFrameworkInfoPropertyWithValue>
     </ItemGroup>
 
+    <PropertyGroup>
+      <_UseAttributeForTargetFrameworkInfoPropertyNames Condition="'$(_UseAttributeForTargetFrameworkInfoPropertyNames)' == ''">false</_UseAttributeForTargetFrameworkInfoPropertyNames>
+    </PropertyGroup>
+
     <CombineTargetFrameworkInfoProperties
         RootElementName="$(TargetFramework)"
-        PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)">
+        PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)"
+        UseAttributeForTargetFrameworkInfoPropertyNames="$(_UseAttributeForTargetFrameworkInfoPropertyNames)">
       <Output TaskParameter="Result"
               PropertyName="_AdditionalTargetFrameworkInfoProperties"/>
     </CombineTargetFrameworkInfoProperties>
diff --git a/src/Tasks/RemoveDir.cs b/src/Tasks/RemoveDir.cs
index a88b74eb659..4e94778a998 100644
--- a/src/Tasks/RemoveDir.cs
+++ b/src/Tasks/RemoveDir.cs
@@ -51,6 +51,14 @@ public override bool Execute()
 
             foreach (ITaskItem directory in Directories)
             {
+                if (string.IsNullOrEmpty(directory.ItemSpec))
+                {
+                    // Skip any empty ItemSpecs, otherwise RemoveDir will wipe the root of the current drive (!).
+                    // https://github.com/dotnet/msbuild/issues/7563
+                    Log.LogWarningWithCodeFromResources("RemoveDir.EmptyPath");
+                    continue;
+                }
+
                 if (FileSystems.Default.DirectoryExists(directory.ItemSpec))
                 {
                     // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 07e6d050acb..a128fd658e2 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -1338,6 +1338,10 @@
   <data name="RemoveDir.SkippingNonexistentDirectory">
     <value>Directory "{0}" doesn't exist. Skipping.</value>
   </data>
+  <data name="RemoveDir.EmptyPath">
+    <value>MSB3232: An empty directory was passed to RemoveDir and was ignored.</value>
+    <comment>{StrBegin="MSB3232: "}</comment>
+  </data>
   <!--
         The ResGen message bucket is: MSB3451 - MSB3460
 
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 5cd63bb5ed1..76d1ac83455 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: Nelze zaregistrovat sestavení {0}. Byl odepřen přístup. Zkontrolujte, zda spouštíte aplikaci jako správce. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: Nelze odebrat adresář {0}. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 29eec204738..8e5b3b15220 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: Die "{0}"-Assembly kann nicht registriert werden – Zugriff verweigert. Stellen Sie sicher, dass Sie die Anwendung als Administrator ausführen. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: Das Verzeichnis "{0}" kann nicht entfernt werden. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index a5f49b7e9b2..d670df974c0 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: No se puede registrar el ensamblado "{0}": acceso denegado. Asegúrese de que está ejecutando la aplicación como administrador. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: No se puede quitar el directorio "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 8b68712903b..598042e2274 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: Impossible d'inscrire l'assembly "{0}", car l'accès est refusé. Assurez-vous d'exécuter l'application comme administrateur. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: Impossible de supprimer le répertoire "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 5e4059e6022..f5324d1486b 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: non è possibile registrare l'assembly "{0}". Accesso negato. Assicurarsi di eseguire l'applicazione come amministratore. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: non è possibile rimuovere la directory "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 171785f8d83..05e3749d224 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: アセンブリ "{0}" を登録できません - アクセスが拒否されました。管理者としてアプリケーションを実行しているか確認してください。{1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: ディレクトリ "{0}" を削除できません。{1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 917b998a69e..9e79c469a64 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: "{0}" 어셈블리를 등록할 수 없습니다. 액세스가 거부되었습니다. 관리자로 애플리케이션을 실행하고 있는지 확인하세요. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: "{0}" 디렉터리를 제거할 수 없습니다. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 491c23d7f83..c4425be1017 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: Nie można zarejestrować zestawu „{0}” — odmowa dostępu. Upewnij się, że aplikacja została uruchomiona z uprawnieniami administratora. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: Nie można usunąć katalogu „{0}”. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 179d47b7e4f..9e8ae3a173a 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: Não é possível registrar o assembly "{0}"; acesso negado. Verifique se você está executando o aplicativo como administrador. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: Não é possível remover o diretório "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 151515cc8d6..9f678d815a9 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: невозможно зарегистрировать сборку "{0}" — отказано в доступе. Убедитесь, что приложение запущено с правами администратора. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: Не удалось удалить каталог "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index fe4a852bdf9..b50eb2c00de 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: "{0}" bütünleştirilmiş kodu kaydedilemiyor - erişim reddedildi. Lütfen uygulamayı yönetici olarak çalıştırdığınızdan emin olun. {1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: "{0}" dizini kaldırılamıyor. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 6e05a986ebd..ab943eeff47 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: 无法注册程序集“{0}”- 拒绝访问。请确保您正在以管理员身份运行应用程序。{1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: 无法移除目录“{0}”。{1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 653ec0e52d7..f79344992ae 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -1552,6 +1552,11 @@
         <target state="translated">MSB3216: 無法註冊組件 "{0}" - 存取遭拒。請確認您以系統管理員身分執行此應用程式。{1}</target>
         <note>{StrBegin="MSB3216: "}</note>
       </trans-unit>
+      <trans-unit id="RemoveDir.EmptyPath">
+        <source>MSB3232: An empty directory was passed to RemoveDir and was ignored.</source>
+        <target state="new">MSB3232: An empty directory was passed to RemoveDir and was ignored.</target>
+        <note>{StrBegin="MSB3232: "}</note>
+      </trans-unit>
       <trans-unit id="RemoveDir.Error">
         <source>MSB3231: Unable to remove directory "{0}". {1}</source>
         <target state="translated">MSB3231: 無法移除目錄 "{0}"。{1}</target>
diff --git a/src/Tasks/System.Resources.Extensions.pkgdef b/src/Tasks/System.Resources.Extensions.pkgdef
index 000095869d3..6c5ef517c6e 100644
--- a/src/Tasks/System.Resources.Extensions.pkgdef
+++ b/src/Tasks/System.Resources.Extensions.pkgdef
@@ -4,4 +4,4 @@
 "publicKeyToken"="cc7b13ffcd2ddd51"
 "culture"="neutral"
 "oldVersion"="0.0.0.0-99.9.9.9"
-"newVersion"="4.0.0.0"
+"newVersion"="6.0.0.0"
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 1ced49c9b63..b5df279597a 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -191,7 +191,7 @@ public void HandleExecutionErrorsWhenToolDoesntLogError()
 
                 // We just tried to run "cmd.exe /C garbagegarbagegarbagegarbage.exe".  This should fail,
                 // but since "cmd.exe" doesn't log its errors in canonical format, no errors got
-                // logged by the tool itself.  Therefore, ToolTask's default implementation of 
+                // logged by the tool itself.  Therefore, ToolTask's default implementation of
                 // HandleTaskExecutionErrors should have logged error MSB6006.
                 engine.AssertLogContains("MSB6006");
             }
@@ -227,7 +227,7 @@ public void HandleExecutionErrorsWhenToolLogsError()
         }
 
         /// <summary>
-        /// ToolTask should never run String.Format on strings that are 
+        /// ToolTask should never run String.Format on strings that are
         /// not meant to be formatted.
         /// </summary>
         [Fact]
@@ -524,27 +524,16 @@ public void EnvironmentVariablesToToolTask()
 
             ProcessStartInfo startInfo = task.StartInfo;
 
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
             startInfo.Environment["a"].ShouldBe("b");
             startInfo.Environment["c"].ShouldBe("d");
             startInfo.Environment[userVarName].ShouldBe("x");
             startInfo.Environment["path"].ShouldBe(String.Empty);
-#else
-            startInfo.EnvironmentVariables["a"].ShouldBe("b");
-            startInfo.EnvironmentVariables["c"].ShouldBe("d");
-            startInfo.EnvironmentVariables[userVarName].ShouldBe("x");
-            startInfo.EnvironmentVariables["path"].ShouldBe(string.Empty);
-#endif
 
             if (NativeMethodsShared.IsWindows)
             {
                 Assert.Equal(
                         Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles),
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
                         startInfo.Environment["programfiles"],
-#else
-                        startInfo.EnvironmentVariables["programfiles"],
-#endif
                         true);
             }
         }
@@ -562,11 +551,7 @@ public void EnvironmentVariablesToToolTaskEqualsSign()
             bool result = task.Execute();
 
             result.ShouldBe(true);
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
             task.StartInfo.Environment["a"].ShouldBe("b=c");
-#else
-            task.StartInfo.EnvironmentVariables["a"].ShouldBe("b=c");
-#endif
         }
 
         /// <summary>
@@ -628,12 +613,7 @@ public void EnvironmentVariablesToToolTaskNotSet()
 
             result.ShouldBe(true);
             task.ExecuteCalled.ShouldBe(true);
-            Assert.True(
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
-                task.StartInfo.Environment["PATH"].Length > 0);
-#else
-                task.StartInfo.EnvironmentVariables["PATH"].Length > 0);
-#endif
+            Assert.True(task.StartInfo.Environment["PATH"].Length > 0);
         }
 
         /// <summary>
@@ -707,22 +687,14 @@ public void FindOnPathSucceeds()
         public void GetProcessStartInfoCanOverrideEnvironmentVariables()
         {
             MyTool task = new MyTool();
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
             task.DoProcessStartInfoMutation = (p) => p.Environment.Remove("a");
-#else
-            task.DoProcessStartInfoMutation = (p) => p.EnvironmentVariables.Remove("a");
-#endif
-            
+
             task.BuildEngine = new MockEngine();
             task.EnvironmentVariables = new[] { "a=b" };
             bool result = task.Execute();
 
             result.ShouldBe(true);
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
             task.StartInfo.Environment.ContainsKey("a").ShouldBe(false);
-#else
-            task.StartInfo.EnvironmentVariables.ContainsKey("a").ShouldBe(false);
-#endif
         }
 
         [Fact]
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 6eb42bff3ff..cc316e7ad5e 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -33,7 +33,7 @@ public enum HostObjectInitializationStatus
         UseHostObjectToExecute,
 
         /// <summary>
-        /// This means that either there is no host object available, or that the host object is 
+        /// This means that either there is no host object available, or that the host object is
         /// not capable of supporting all of the features required for this build.  Therefore,
         /// ToolTask should fallback to an alternate means of doing the build, such as invoking
         /// the command-line tool.
@@ -56,7 +56,7 @@ public enum HostObjectInitializationStatus
     /// Base class used for tasks that spawn an executable. This class implements the ToolPath property which can be used to
     /// override the default path.
     /// </summary>
-    // INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and 
+    // INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and
     // we want to use resources from Utilities. Use LogPrivate (for private Utilities resources) and LogShared (for shared MSBuild resources)
     public abstract class ToolTask : Task, ICancelableTask
     {
@@ -65,7 +65,7 @@ public abstract class ToolTask : Task, ICancelableTask
         #region Constructors
 
         /// <summary>
-        /// Protected constructor 
+        /// Protected constructor
         /// </summary>
         protected ToolTask()
         {
@@ -87,7 +87,7 @@ protected ToolTask()
         }
 
         /// <summary>
-        /// Protected constructor 
+        /// Protected constructor
         /// </summary>
         /// <param name="taskResources">The resource manager for task resources</param>
         protected ToolTask(ResourceManager taskResources)
@@ -97,7 +97,7 @@ protected ToolTask(ResourceManager taskResources)
         }
 
         /// <summary>
-        /// Protected constructor 
+        /// Protected constructor
         /// </summary>
         /// <param name="taskResources">The resource manager for task resources</param>
         /// <param name="helpKeywordPrefix">The help keyword prefix for task's messages</param>
@@ -112,7 +112,7 @@ protected ToolTask(ResourceManager taskResources, string helpKeywordPrefix)
         #region Properties
 
         /// <summary>
-        /// The return code of the spawned process. If the task logged any errors, but the process 
+        /// The return code of the spawned process. If the task logged any errors, but the process
         /// had an exit code of 0 (success), this will be set to -1.
         /// </summary>
         [Output]
@@ -187,7 +187,7 @@ public virtual string ToolExe
         /// <summary>
         /// Whether or not to use UTF8 encoding for the cmd file and console window.
         /// Values: Always, Never, Detect
-        /// If set to Detect, the current code page will be used unless it cannot represent 
+        /// If set to Detect, the current code page will be used unless it cannot represent
         /// the Command string. In that case, UTF-8 is used.
         /// </summary>
         public string UseUtf8Encoding { get; set; } = EncodingUtilities.UseUtf8Detect;
@@ -205,7 +205,7 @@ public virtual string ToolExe
 
         /// <summary>
         /// Project visible property that allows the user to specify an amount of time after which the task executable
-        /// is terminated. 
+        /// is terminated.
         /// </summary>
         /// <value>Time-out in milliseconds. Default is <see cref="System.Threading.Timeout.Infinite"/> (no time-out).</value>
         public virtual int Timeout { set; get; } = System.Threading.Timeout.Infinite;
@@ -326,7 +326,7 @@ public virtual string ToolExe
         protected virtual void ProcessStarted() { }
 
         /// <summary>
-        /// Gets the fully qualified tool name. Should return ToolExe if ToolTask should search for the tool 
+        /// Gets the fully qualified tool name. Should return ToolExe if ToolTask should search for the tool
         /// in the system path. If ToolPath is set, this is ignored.
         /// </summary>
         /// <returns>Path string.</returns>
@@ -334,7 +334,7 @@ protected virtual void ProcessStarted() { }
 
         /// <summary>
         /// Gets the working directory to use for the process. Should return null if ToolTask should use the
-        /// current directory. 
+        /// current directory.
         /// </summary>
         /// <remarks>This is a method rather than a property so that derived classes (like Exec) can choose to
         /// expose a public WorkingDirectory property, and it would be confusing to have two properties.</remarks>
@@ -413,7 +413,7 @@ protected virtual bool HandleTaskExecutionErrors()
 
         /// <summary>
         /// We expect tasks to override this method if they support host objects.  The implementation should
-        /// make sure that the host object is ready to perform the real work of the task.  
+        /// make sure that the host object is ready to perform the real work of the task.
         /// </summary>
         /// <returns>The return value indicates what steps to take next.  The default is to assume that there
         /// is no host object provided, and therefore we should fallback to calling the command-line tool.</returns>
@@ -480,7 +480,7 @@ private string ComputePathToTool()
                 }
             }
 
-            // only look for the file if we have a path to it. If we have just the file name, we'll 
+            // only look for the file if we have a path to it. If we have just the file name, we'll
             // look for it in the path
             if (pathToTool != null)
             {
@@ -627,12 +627,7 @@ string responseFileSwitch
             {
                 foreach (KeyValuePair<string, string> entry in envOverrides)
                 {
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
                     startInfo.Environment[entry.Key] = entry.Value;
-#else
-                    startInfo.EnvironmentVariables[entry.Key] = entry.Value;
-#endif
-
                 }
 #pragma warning restore 0618
             }
@@ -642,11 +637,7 @@ string responseFileSwitch
             {
                 foreach (KeyValuePair<string, string> variable in _environmentVariablePairs)
                 {
-#if FEATURE_PROCESSSTARTINFO_ENVIRONMENT
                     startInfo.Environment[variable.Key] = variable.Value;
-#else
-                    startInfo.EnvironmentVariables[variable.Key] = variable.Value;
-#endif
                 }
             }
 
@@ -807,7 +798,7 @@ protected void DeleteTempFile(string fileName)
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                // Warn only -- occasionally temp files fail to delete because of virus checkers; we 
+                // Warn only -- occasionally temp files fail to delete because of virus checkers; we
                 // don't want the build to fail in such cases
                 LogShared.LogWarningWithCodeFromResources("Shared.FailedDeletingTempFile", fileName, e.Message);
             }
@@ -1225,7 +1216,7 @@ private bool AssignStandardStreamLoggingImportance()
             {
                 try
                 {
-                    // Parse the raw importance string into a strongly typed enumeration.  
+                    // Parse the raw importance string into a strongly typed enumeration.
                     _standardErrorImportanceToUse = (MessageImportance)Enum.Parse(typeof(MessageImportance), StandardErrorImportance, true /* case-insensitive */);
                 }
                 catch (ArgumentException)
@@ -1245,7 +1236,7 @@ private bool AssignStandardStreamLoggingImportance()
             {
                 try
                 {
-                    // Parse the raw importance string into a strongly typed enumeration.  
+                    // Parse the raw importance string into a strongly typed enumeration.
                     _standardOutputImportanceToUse = (MessageImportance)Enum.Parse(typeof(MessageImportance), StandardOutputImportance, true /* case-insensitive */);
                 }
                 catch (ArgumentException)
@@ -1386,7 +1377,7 @@ public override bool Execute()
 
                             if (encoding.CodePage != EncodingUtilities.CurrentSystemOemEncoding.CodePage)
                             {
-                                // cmd.exe reads the first line in the console CP, 
+                                // cmd.exe reads the first line in the console CP,
                                 // which for a new console (as here) is OEMCP
                                 // this string should ideally always be ASCII
                                 // and the same in any OEMCP.
@@ -1433,7 +1424,7 @@ public override bool Execute()
 
                 // Initialize the host object.  At this point, the task may elect
                 // to not proceed.  Compiler tasks do this for purposes of up-to-date
-                // checking in the IDE.  
+                // checking in the IDE.
                 HostObjectInitializationStatus nextAction = InitializeHostObject();
                 if (nextAction == HostObjectInitializationStatus.NoActionReturnSuccess)
                 {
@@ -1483,13 +1474,13 @@ public override bool Execute()
 
                 if (UseCommandProcessor)
                 {
-                    // Log that we are about to invoke the specified command.  
+                    // Log that we are about to invoke the specified command.
                     LogToolCommand(pathToTool + commandLineCommands);
                     LogToolCommand(batchFileContents);
                 }
                 else
                 {
-                    // Log that we are about to invoke the specified command.  
+                    // Log that we are about to invoke the specified command.
                     LogToolCommand(pathToTool + commandLineCommands + " " + responseFileCommands);
                 }
                 ExitCode = 0;
@@ -1497,7 +1488,7 @@ public override bool Execute()
                 if (nextAction == HostObjectInitializationStatus.UseHostObjectToExecute)
                 {
                     // The hosting IDE passed in a host object to this task.  Give the task
-                    // a chance to call this host object to do the actual work.  
+                    // a chance to call this host object to do the actual work.
                     try
                     {
                         if (!CallHostObjectToExecute())
@@ -1632,12 +1623,12 @@ private bool LogEnvironmentVariable(bool alreadyLoggedEnvironmentHeader, string
         private static readonly char[] s_equalsSplitter = MSBuildConstants.EqualsChar;
 
         /// <summary>
-        /// The actual importance at which standard out messages will be logged 
+        /// The actual importance at which standard out messages will be logged
         /// </summary>
         private MessageImportance _standardOutputImportanceToUse = MessageImportance.Low;
 
         /// <summary>
-        /// The actual importance at which standard error messages will be logged 
+        /// The actual importance at which standard error messages will be logged
         /// </summary>
         private MessageImportance _standardErrorImportanceToUse = MessageImportance.Normal;
 
@@ -1669,7 +1660,7 @@ private bool LogEnvironmentVariable(bool alreadyLoggedEnvironmentHeader, string
         private ManualResetEvent _toolExited;
 
         /// <summary>
-        /// Set to true if the tool process was terminated, 
+        /// Set to true if the tool process was terminated,
         /// either because the timeout was reached or it was canceled.
         /// </summary>
         private bool _terminatedTool;
