diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 5bc6989f65b..4bb6b3363de 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -126,12 +126,12 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
                 int timeout = 30;
 
                 // Attempt to connect to the process with the handshake without low priority.
-                Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, false));
+                Stream nodeStream = TryConnectToProcess(PipeNameByProcessId(nodeProcess.Id), timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, false));
 
                 if (nodeStream == null)
                 {
                     // If we couldn't connect attempt to connect to the process with the handshake including low priority.
-                    nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, true));
+                    nodeStream = TryConnectToProcess(PipeNameByProcessId(nodeProcess.Id), timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, true));
                 }
 
                 if (nodeStream != null)
@@ -143,6 +143,8 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
                     nodeStream.Dispose();
                 }
             }
+
+            // TODO: shtudown RAR node somehow
         }
 
         /// <summary>
@@ -199,7 +201,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                     _processesToIgnore.Add(nodeLookupKey);
 
                     // Attempt to connect to each process in turn.
-                    Stream nodeStream = TryConnectToProcess(nodeProcess.Id, 0 /* poll, don't wait for connections */, hostHandshake);
+                    Stream nodeStream = TryConnectToProcess(PipeNameByProcessId(nodeProcess.Id), 0 /* poll, don't wait for connections */, hostHandshake);
                     if (nodeStream != null)
                     {
                         // Connection successful, use this node.
@@ -209,7 +211,12 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                 }
             }
 #endif
+            return LaunchNodeProcess(msbuildLocation, commandLineArgs, nodeId, factory, hostHandshake, terminateNode);
+        }
 
+        protected NodeContext LaunchNodeProcess(string msbuildLocation, string commandLineArgs,  int nodeId, INodePacketFactory factory, Handshake hostHandshake,
+            NodeContextTerminateDelegate terminateNode, string pipeName = null)
+        {
             // None of the processes we tried to connect to allowed a connection, so create a new one.
             // We try this in a loop because it is possible that there is another MSBuild multiproc
             // host process running somewhere which is also trying to create nodes right now.  It might
@@ -250,7 +257,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                 // to the debugger process. Instead, use MSBUILDDEBUGONSTART=1
 
                 // Now try to connect to it.
-                Stream nodeStream = TryConnectToProcess(msbuildProcessId, TimeoutForNewNodeCreation, hostHandshake);
+                Stream nodeStream = TryConnectToProcess(PipeNameByProcessId(msbuildProcessId, pipeName), TimeoutForNewNodeCreation, hostHandshake);
                 if (nodeStream != null)
                 {
                     // Connection successful, use this node.
@@ -319,20 +326,26 @@ private void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStrea
         }
 #endif
 
+        protected static string PipeNameByProcessId(int nodeProcessId, string pipeNameFormat = null)
+        {
+            return string.Format(pipeNameFormat ?? "MSBuild{0}", nodeProcessId);
+        }
+
         /// <summary>
         /// Attempts to connect to the specified process.
         /// </summary>
-        private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
+        protected Stream TryConnectToProcess(string pipeName, int timeout, Handshake handshake)
         {
             // Try and connect to the process.
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + nodeProcessId);
+            pipeName = NamedPipeUtil.GetPipeNameOrPath(pipeName);
+
+            CommunicationsUtilities.Trace("Attempting connect to process by pipe {0} with timeout {1} ms", pipeName, timeout);
 
             NamedPipeClientStream nodeStream = new NamedPipeClientStream(".", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous
 #if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
                                                                          | PipeOptions.CurrentUserOnly
 #endif
                                                                          );
-            CommunicationsUtilities.Trace("Attempting connect to PID {0} with pipe {1} with timeout {2} ms", nodeProcessId, pipeName, timeout);
 
             try
             {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index a13368a2972..fea29ad18e7 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
 using System.Diagnostics;
@@ -73,7 +74,7 @@ internal class NodeProviderOutOfProcTaskHost : NodeProviderOutOfProcBase, INodeP
         /// <summary>
         /// A mapping of all the nodes managed by this provider.
         /// </summary>
-        private Dictionary<HandshakeOptions, NodeContext> _nodeContexts;
+        private ConcurrentDictionary<HandshakeOptions, NodeContext> _nodeContexts;
 
         /// <summary>
         /// A mapping of all of the INodePacketFactories wrapped by this provider.
@@ -88,7 +89,7 @@ internal class NodeProviderOutOfProcTaskHost : NodeProviderOutOfProcBase, INodeP
         /// <summary>
         /// Keeps track of the set of nodes for which we have not yet received shutdown notification.
         /// </summary>
-        private HashSet<int> _activeNodes;
+        private ConcurrentDictionary<int, NodeContext> _activeNodes;
 
         /// <summary>
         /// Packet factory we use if there's not already one associated with a particular context.
@@ -183,13 +184,8 @@ public void SendData(HandshakeOptions hostContext, INodePacket packet)
         public void ShutdownConnectedNodes(bool enableReuse)
         {
             // Send the build completion message to the nodes, causing them to shutdown or reset.
-            List<NodeContext> contextsToShutDown;
-
-            lock (_nodeContexts)
-            {
-                contextsToShutDown = new List<NodeContext>(_nodeContexts.Values);
-            }
 
+            var contextsToShutDown = new List<NodeContext>(_nodeContexts.Values);
             ShutdownConnectedNodes(contextsToShutDown, enableReuse);
 
             _noNodesActiveEvent.WaitOne();
@@ -213,10 +209,10 @@ public void ShutdownAllNodes()
         public void InitializeComponent(IBuildComponentHost host)
         {
             this.ComponentHost = host;
-            _nodeContexts = new Dictionary<HandshakeOptions, NodeContext>();
+            _nodeContexts = new ConcurrentDictionary<HandshakeOptions, NodeContext>();
             _nodeIdToPacketFactory = new Dictionary<int, INodePacketFactory>();
             _nodeIdToPacketHandler = new Dictionary<int, INodePacketHandler>();
-            _activeNodes = new HashSet<int>();
+            _activeNodes = new ConcurrentDictionary<int, NodeContext>();
 
             _noNodesActiveEvent = new ManualResetEvent(true);
             _localPacketFactory = new NodePacketFactory();
@@ -300,30 +296,24 @@ public void RoutePacket(int nodeId, INodePacket packet)
         /// This method is invoked by the NodePacketRouter when a packet is received and is intended for
         /// this recipient.
         /// </summary>
-        /// <param name="node">The node from which the packet was received.</param>
+        /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packet">The packet.</param>
-        public void PacketReceived(int node, INodePacket packet)
+        public void PacketReceived(int nodeId, INodePacket packet)
         {
-            if (_nodeIdToPacketHandler.ContainsKey(node))
+            if (_nodeIdToPacketHandler.ContainsKey(nodeId))
             {
-                _nodeIdToPacketHandler[node].PacketReceived(node, packet);
+                _nodeIdToPacketHandler[nodeId].PacketReceived(nodeId, packet);
             }
             else
             {
                 ErrorUtilities.VerifyThrow(packet.Type == NodePacketType.NodeShutdown, "We should only ever handle packets of type NodeShutdown -- everything else should only come in when there's an active task");
 
                 // May also be removed by unnatural termination, so don't assume it's there
-                lock (_activeNodes)
-                {
-                    if (_activeNodes.Contains(node))
-                    {
-                        _activeNodes.Remove(node);
-                    }
+                _activeNodes.TryRemove(nodeId, out _);
 
-                    if (_activeNodes.Count == 0)
-                    {
-                        _noNodesActiveEvent.Set();
-                    }
+                if (_activeNodes.IsEmpty)
+                {
+                    _noNodesActiveEvent.Set();
                 }
             }
         }
@@ -453,21 +443,24 @@ internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostCo
         /// </summary>
         internal bool AcquireAndSetUpHost(HandshakeOptions hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
         {
-            NodeContext context;
-            bool nodeCreationSucceeded;
-            if (!_nodeContexts.TryGetValue(hostContext, out context))
-            {
-                nodeCreationSucceeded = CreateNode(hostContext, factory, handler, configuration);
-            }
-            else
+            bool nodeContextExists = _nodeContexts.TryGetValue(hostContext, out var context);
+
+            if (!nodeContextExists)
             {
-                // node already exists, so "creation" automatically succeeded
-                nodeCreationSucceeded = true;
+                bool isRarService = (hostContext & HandshakeOptions.RarService) != 0;
+                nodeContextExists = isRarService ?
+                    CreateRarNode(hostContext, factory, handler, configuration) :
+                    CreateNode(hostContext, factory, handler, configuration);
+                if (nodeContextExists)
+                {
+                    // get just created node context
+                    context = _nodeContexts[hostContext];
+                }
             }
 
-            if (nodeCreationSucceeded)
+            if (nodeContextExists)
             {
-                context = _nodeContexts[hostContext];
+                // TODO: consider concurrent dict for those too
                 _nodeIdToPacketFactory[(int)hostContext] = factory;
                 _nodeIdToPacketHandler[(int)hostContext] = handler;
 
@@ -498,6 +491,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             ErrorUtilities.VerifyThrow(!_nodeIdToPacketFactory.ContainsKey((int)hostContext), "We should not already have a factory for this context!  Did we forget to call DisconnectFromHost somewhere?");
 
+            // TODO: hmmm, need to exclude RAR node here, also it looks like a bug as gen node can connect to already created node
             if (AvailableNodes == 0)
             {
                 ErrorUtilities.ThrowInternalError("All allowable nodes already created ({0}).", _nodeContexts.Count);
@@ -506,8 +500,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
 
             // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we
             // want to start up an MSBuild task host node.
-            bool isRarService = (hostContext & HandshakeOptions.RarService) != 0;
-            string commandLineArgs = $" /nologo /nodemode:{(isRarService ? 3 : 2)} /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} ";
+            string commandLineArgs = $" /nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} ";
 
             string msbuildLocation = GetMSBuildLocationFromHostContext(hostContext);
 
@@ -517,7 +510,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
                 return false;
             }
 
-            CommunicationsUtilities.Trace("For a host context of {0}, spawning executable from {1}.", hostContext.ToString(), msbuildLocation ?? "MSBuild.exe");
+            CommunicationsUtilities.Trace("For a host context of '{0}', spawning executable from {1}.", hostContext.ToString(), msbuildLocation);
 
             // Make it here.
             NodeContext context = GetNode
@@ -537,7 +530,9 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
                 // Start the asynchronous read.
                 context.BeginAsyncPacketRead();
 
-                _activeNodes.Add((int)hostContext);
+                bool added = _activeNodes.TryAdd((int) hostContext, context);
+                ErrorUtilities.VerifyThrow(added, "Internal error: node context for out of process task host of given node id already exist");
+
                 _noNodesActiveEvent.Reset();
 
                 return true;
@@ -547,27 +542,95 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
         }
 
         /// <summary>
-        /// Method called when a context terminates.
+        /// Connect to or instantiate the RAR service node
         /// </summary>
-        private void NodeContextTerminated(int nodeId)
+        internal bool CreateRarNode(HandshakeOptions hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
         {
-            lock (_nodeContexts)
+            ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
+            ErrorUtilities.VerifyThrow(!_nodeIdToPacketFactory.ContainsKey((int)hostContext), "We should not already have a factory for this context! Did we forget to call DisconnectFromHost somewhere?");
+
+            NodeContext context = GetRarNode
+            (
+                hostContext,
+                this,
+                new Handshake(hostContext),
+                NodeContextTerminated
+            );
+
+            if (context != null)
             {
-                _nodeContexts.Remove((HandshakeOptions)nodeId);
+                bool added = _nodeContexts.TryAdd(hostContext, context);
+                ErrorUtilities.VerifyThrow(added, "Internal error: node context for RAR node of given node id already exist in _nodeContexts");
+
+                _nodeContexts[hostContext] = context;
+
+                // Start the asynchronous read.
+                context.BeginAsyncPacketRead();
+
+                added = _activeNodes.TryAdd((int)hostContext, context);
+                ErrorUtilities.VerifyThrow(added, "Internal error: node context for RAR node of given node id already exist in _activeNodes");
+
+                _noNodesActiveEvent.Reset();
+
+                return true;
             }
 
-            // May also be removed by unnatural termination, so don't assume it's there
-            lock (_activeNodes)
+            return false;
+        }
+
+        /// <summary>
+        /// Finds or creates a child process which can act as a node.
+        /// </summary>
+        /// <returns>The pipe stream representing the node.</returns>
+        protected NodeContext GetRarNode(HandshakeOptions hostContext, INodePacketFactory factory, Handshake hostHandshake, NodeContextTerminateDelegate terminateNode)
+        {
+            int nodeId = (int) hostContext;
+
+            // Attempt to connect to RAR service process by its pipe name
+            string rarNodePipeName = RarNodePipeName(hostHandshake);
+
+            Stream nodeStream = TryConnectToProcess(rarNodePipeName, 0 /* poll, don't wait for connections */, hostHandshake);
+            if (nodeStream != null)
             {
-                if (_activeNodes.Contains(nodeId))
-                {
-                    _activeNodes.Remove(nodeId);
-                }
+                // Connection successful, use this node.
+                CommunicationsUtilities.Trace("Successfully connected to existed RAR node {0} by its pipe name {1}", nodeId, rarNodePipeName);
+                return new NodeContext(nodeId, -1, nodeStream, factory, terminateNode);
+            }
 
-                if (_activeNodes.Count == 0)
-                {
-                    _noNodesActiveEvent.Set();
-                }
+            // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we
+            string commandLineArgs = $" /nologo /nodemode:3 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /pipename:{rarNodePipeName} ";
+            string msbuildLocation = GetMSBuildLocationFromHostContext(hostContext);
+
+            // we couldn't even figure out the location we're trying to launch ... just go ahead and fail.
+            if (msbuildLocation == null)
+            {
+                return null;
+            }
+
+            CommunicationsUtilities.Trace("For a RAR node of context '{0}, spawning executable from {1}.", hostContext.ToString(), msbuildLocation);
+
+            return LaunchNodeProcess(msbuildLocation, commandLineArgs, nodeId, factory, hostHandshake, terminateNode, rarNodePipeName);
+        }
+
+        private static string RarNodePipeName(Handshake hostHandshake)
+        {
+            // TODO: consider using longer hash (sha) to lower conflict possibility
+            return $"MSBuildRAR-{CommunicationsUtilities.GetHashCode(hostHandshake.ToString()):x}";
+        }
+
+        /// <summary>
+        /// Method called when a context terminates.
+        /// </summary>
+        private void NodeContextTerminated(int nodeId)
+        {
+            _nodeContexts.TryRemove((HandshakeOptions)nodeId, out _);
+
+            // May also be removed by unnatural termination, so don't assume it's there
+            _activeNodes.TryRemove(nodeId, out _);
+
+            if (_activeNodes.IsEmpty)
+            {
+                _noNodesActiveEvent.Set();
             }
         }
     }
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 33490f3f831..52837237347 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -324,7 +324,7 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
 #endif
             bool isOutOfProc)
         {
-            bool useTaskFactory = false;
+            bool useTaskHost = false;
             IDictionary<string, string> mergedParameters = null;
             _taskLoggingContext = taskLoggingContext;
 
@@ -337,7 +337,7 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
                 VerifyThrowIdentityParametersValid(taskIdentityParameters, taskLocation, _taskName, "MSBuildRuntime", "MSBuildArchitecture");
 
                 mergedParameters = MergeTaskFactoryParameterSets(_factoryIdentityParameters, taskIdentityParameters);
-                useTaskFactory = !NativeMethodsShared.IsMono
+                useTaskHost  = !NativeMethodsShared.IsMono
                                  && (_taskHostFactoryExplicitlyRequested
                                      || !TaskHostParametersMatchCurrentProcess(mergedParameters));
             }
@@ -345,11 +345,14 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
             {
                 // if we don't have any task host parameters specified on either the using task or the 
                 // task invocation, then we will run in-proc UNLESS "TaskHostFactory" is explicitly specified
-                // as the task factory.  
-                useTaskFactory = _taskHostFactoryExplicitlyRequested || _taskName == "Microsoft.Build.Tasks.ResolveAssemblyReference";
+                // as the task factory.
+                useTaskHost  = _taskHostFactoryExplicitlyRequested;
             }
 
-            if (useTaskFactory)
+            bool hostInRarService = _taskName == "Microsoft.Build.Tasks.ResolveAssemblyReference" && Environment.GetEnvironmentVariable("MSBUILDRARSERVICE") != "0";
+            useTaskHost |= hostInRarService;
+
+            if (useTaskHost )
             {
                 ErrorUtilities.VerifyThrowInternalNull(buildComponentHost, nameof(buildComponentHost));
 
@@ -372,6 +375,7 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
 #if FEATURE_APPDOMAIN
                     , appDomainSetup
 #endif
+                    , hostInRarService
                     );
                 return task;
             }
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 1b1028a5b43..411fa986484 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -16,6 +16,8 @@
 
 namespace Microsoft.Build.BackEnd
 {
+    // TODO: consider to create RarHostTask, might be cleaner
+
     /// <summary>
     /// The wrapper task for tasks that wish to take advantage of the 
     /// task host factory feature.  Generated by AssemblyTaskFactory
@@ -74,6 +76,11 @@ internal class TaskHostTask : IGeneratedTask, ICancelableTask, INodePacketFactor
         /// </summary>
         private LoadedType _taskType;
 
+        /// <summary>
+        /// True is this is a RAR task to be run in RAR service
+        /// </summary>
+        private readonly bool _hostInRarService;
+
 #if FEATURE_APPDOMAIN
         /// <summary>
         /// The AppDomainSetup we'll want to apply to the AppDomain that we may 
@@ -126,6 +133,7 @@ public TaskHostTask(IElementLocation taskLocation, TaskLoggingContext taskLoggin
 #if FEATURE_APPDOMAIN
                 , AppDomainSetup appDomainSetup
 #endif
+                , bool hostInRarService
             )
         {
             ErrorUtilities.VerifyThrowInternalNull(taskType, nameof(taskType));
@@ -134,6 +142,7 @@ public TaskHostTask(IElementLocation taskLocation, TaskLoggingContext taskLoggin
             _taskLoggingContext = taskLoggingContext;
             _buildComponentHost = buildComponentHost;
             _taskType = taskType;
+            _hostInRarService = hostInRarService;
 #if FEATURE_APPDOMAIN
             _appDomainSetup = appDomainSetup;
 #endif
@@ -258,7 +267,7 @@ public bool Execute()
                     (
                         _buildComponentHost.BuildParameters.NodeId,
                         NativeMethodsShared.GetCurrentDirectory(),
-                        CommunicationsUtilities.GetEnvironmentVariables(),
+                        _hostInRarService ? null : CommunicationsUtilities.GetEnvironmentVariables(),
                         _buildComponentHost.BuildParameters.Culture,
                         _buildComponentHost.BuildParameters.UICulture,
 #if FEATURE_APPDOMAIN
@@ -279,7 +288,7 @@ public bool Execute()
                 lock (_taskHostLock)
                 {
                     _requiredContext = CommunicationsUtilities.GetHandshakeOptions(taskHost: true, taskHostParameters: _taskHostParameters);
-                    if (_taskType.Type.Name == "ResolveAssemblyReference")
+                    if (_hostInRarService)
                     {
                         _requiredContext |= HandshakeOptions.RarService;
                     }
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 9e6eb9fd49c..f17be783f38 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -76,6 +76,7 @@ internal enum ParameterizedSwitch
 #endif
             ConsoleLoggerParameters,
             NodeMode,
+            PipeName,
             MaxCPUCount,
             IgnoreProjectExtensions,
             ToolsVersion,
@@ -245,6 +246,7 @@ bool emptyParametersAllowed
 #endif
             new ParameterizedSwitchInfo(  new string[] { "consoleloggerparameters", "clp" },    ParameterizedSwitch.ConsoleLoggerParameters,    null,                           false,          "MissingConsoleLoggerParameterError",  true,   false  ),
             new ParameterizedSwitchInfo(  new string[] { "nodemode", "nmode" },                 ParameterizedSwitch.NodeMode,                   null,                           false,          null,                                  false,  false  ),
+            new ParameterizedSwitchInfo(  new string[] { "pipename", "pname" },                 ParameterizedSwitch.PipeName,                   null,                           false,          null,                                  true,   false  ),
             new ParameterizedSwitchInfo(  new string[] { "maxcpucount", "m" },                  ParameterizedSwitch.MaxCPUCount,                null,                           false,          "MissingMaxCPUCountError",             true,   false  ),
             new ParameterizedSwitchInfo(  new string[] { "ignoreprojectextensions", "ignore" }, ParameterizedSwitch.IgnoreProjectExtensions,    null,                           true,           "MissingIgnoreProjectExtensionsError", true,   false  ),
             new ParameterizedSwitchInfo(  new string[] { "toolsversion","tv" },                 ParameterizedSwitch.ToolsVersion,               null,                           false,          "MissingToolsVersionError",            true,   false  ),
diff --git a/src/MSBuild/RarServiceTaskHostNode.cs b/src/MSBuild/RarServiceTaskHostNode.cs
index 3b8cf315710..0eda5323a45 100644
--- a/src/MSBuild/RarServiceTaskHostNode.cs
+++ b/src/MSBuild/RarServiceTaskHostNode.cs
@@ -7,17 +7,15 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
-using System.Globalization;
-using System.Linq;
 using System.Threading;
 using System.Reflection;
-
+using System.Runtime.InteropServices;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
+
 #if FEATURE_APPDOMAIN
 using System.Runtime.Remoting;
 #endif
@@ -38,32 +36,6 @@ internal class RarServiceTaskHostNode :
         IBuildEngine7
 #endif
     {
-        /// <summary>
-        /// Keeps a record of all environment variables that, on startup of the task host, have a different
-        /// value from those that are passed to the task host in the configuration packet for the first task.  
-        /// These environments are assumed to be effectively identical, so the only difference between the 
-        /// two sets of values should be any environment variables that differ between e.g. a 32-bit and a 64-bit 
-        /// process.  Those are the variables that this dictionary should store.  
-        /// 
-        /// - The key into the dictionary is the name of the environment variable. 
-        /// - The Key of the KeyValuePair is the value of the variable in the parent process -- the value that we 
-        ///   wish to ensure is replaced by whatever the correct value in our current process is. 
-        /// - The Value of the KeyValuePair is the value of the variable in the current process -- the value that 
-        ///   we wish to replay the Key value with in the environment that we receive from the parent before 
-        ///   applying it to the current process. 
-        ///   
-        /// Note that either value in the KeyValuePair can be null, as it is completely possible to have an 
-        /// environment variable that is set in 32-bit processes but not in 64-bit, or vice versa.  
-        /// 
-        /// This dictionary must be static because otherwise, if a node is sitting around waiting for reuse, it will
-        /// have inherited the environment from the previous build, and any differences between the two will be seen 
-        /// as "legitimate".  There is no way for us to know what the differences between the startup environment of 
-        /// the previous build and the environment of the first task run in the task host in this build -- so we 
-        /// must assume that the 4ish system environment variables that this is really meant to catch haven't 
-        /// somehow magically changed between two builds spaced no more than 15 minutes apart.  
-        /// </summary>
-        private static IDictionary<string, KeyValuePair<string, string>> s_mismatchedEnvironmentValues;
-
         /// <summary>
         /// backing queue used to control creating concurrent RAR service clients (requests)
         /// </summary>
@@ -94,11 +66,6 @@ internal class RarServiceTaskHostNode :
         /// </summary>
         private TaskHostConfiguration _currentConfiguration;
 
-        /// <summary>
-        /// The saved environment for the process.
-        /// </summary>
-        private IDictionary<string, string> _savedEnvironment;
-
         /// <summary>
         /// The event which is set when we should shut down.
         /// </summary>
@@ -146,24 +113,6 @@ internal class RarServiceTaskHostNode :
         /// </summary>
         private OutOfProcTaskAppDomainWrapper _taskWrapper;
 
-        /// <summary>
-        /// Flag indicating if we should debug communications or not.
-        /// </summary>
-        private bool _debugCommunications;
-
-        /// <summary>
-        /// Flag indicating whether we should modify the environment based on any differences we find between that of the 
-        /// task host at startup and the environment passed to us in our initial task configuration packet.  
-        /// </summary>
-        private bool _updateEnvironment;
-
-        /// <summary>
-        /// An interim step between MSBuildTaskHostDoNotUpdateEnvironment=1 and the default update behavior:  go ahead and 
-        /// do all the updates that we would otherwise have done by default, but log any updates that are made (at low 
-        /// importance) so that the user is aware.  
-        /// </summary>
-        private bool _updateEnvironmentAndLog;
-
 #if !CLR2COMPATIBILITY
         /// <summary>
         /// The task object cache.
@@ -171,15 +120,17 @@ internal class RarServiceTaskHostNode :
         private RegisteredTaskObjectCacheBase _registeredTaskObjectCache;
 #endif
 
+        /// <summary>
+        /// unique id of this class instance
+        /// </summary>
+        private Guid _id;
+
         /// <summary>
         /// Constructor.
         /// </summary>
         public RarServiceTaskHostNode()
         {
-            // We don't know what the current build thinks this variable should be until RunTask(), but as a fallback in case there are 
-            // communications before we get the configuration set up, just go with what was already in the environment from when this node
-            // was initially launched. 
-            _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
+            _id = Guid.NewGuid();
 
             _receivedPackets = new Queue<INodePacket>();
 
@@ -529,10 +480,31 @@ public void PacketReceived(int node, INodePacket packet)
 
         #region INode Members
 
-        public static NodeEngineShutdownReason RunMultiClient(int maxClients, out Exception shutdownException)
+        public static NodeEngineShutdownReason StartRarService(string pipeName, out Exception shutdownException)
+        {
+            CommunicationsUtilities.Trace("RAR node starting.");
+            PipeName = pipeName;
+
+            // Grab the service  mutex to prevent multiple RAR services from starting with the same
+            // pipename, consuming excess resources and lesser cache hit ratio.
+            // If someone else holds the mutex exit immediately with a non-zero exit code.
+            var mutexName = GetRarServiceMutexName(pipeName);
+            using var serverMutex = CommunicationsUtilities.OpenOrCreateMutex(name: mutexName, createdNew: out var createdNew);
+            if (!createdNew)
+            {
+                shutdownException = new InvalidOperationException($"RAR service for pipename '{pipeName}' is already running.");
+                CommunicationsUtilities.Trace(shutdownException.ToString());
+                return NodeEngineShutdownReason.Error;
+            }
+
+            return StartRarServiceInternal(out shutdownException);
+        }
+
+        private static string GetRarServiceMutexName(string pipeName) => $"{pipeName}.server";
+
+        private static NodeEngineShutdownReason StartRarServiceInternal(out Exception shutdownException)
         {
-            // Option A
-            const int minListenCapacity = 2;
+            const int minListenCapacity = 3;
             int currentCapacity = 0;
 
             // initiate with two waiting clients
@@ -544,6 +516,7 @@ public static NodeEngineShutdownReason RunMultiClient(int maxClients, out Except
             // run draining queue
             foreach (var _ in s_waitForConcurrentClient.GetConsumingEnumerable())
             {
+                // rework into threads? or long running tasks?
                 System.Threading.Tasks.Task.Run(() =>
                 {
                     // TODO: block when max clients is reached
@@ -551,50 +524,25 @@ public static NodeEngineShutdownReason RunMultiClient(int maxClients, out Except
                     Interlocked.Increment(ref currentCapacity);
 
                     var rarTaskHost = new RarServiceTaskHostNode();
+                    CommunicationsUtilities.Trace("RAR node client {0} started to wait for task. Currently running instances {1}", rarTaskHost._id, currentCapacity);
                     var shutdownReason = rarTaskHost.Run(out var rarTaskHostShutdownException);
+                    CommunicationsUtilities.Trace("RAR node client {0} finished with shutdownReason: {1} and exception: '{2}'.", rarTaskHost._id, shutdownReason,
+                        rarTaskHostShutdownException);
 
                     Interlocked.Decrement(ref currentCapacity);
                     // TODO: somehow react to shutdownException and unexpected shutdownReason, maybe log unexpected somewhere?
                 });
-
-                // TODO: how to do graceful node termination?
             }
 
-            throw new NotImplementedException();
-
-            // Option B
-            // create list of N instances when N is concurrency level
-            //var clients = Enumerable.Range(0, maxClients).Select(_ =>
-            //    System.Threading.Tasks.Task.Run(() =>
-            //    {
-            //        RarServiceTaskHostNode rarTaskHost;
-            //        NodeEngineShutdownReason rarTaskHostShutdownReason;
-            //        Exception rarTaskHostShutdownException;
-
-            //        do
-            //        {
-            //            rarTaskHost = new RarServiceTaskHostNode();
-            //            rarTaskHostShutdownReason = rarTaskHost.Run(out rarTaskHostShutdownException);
-            //        } while (rarTaskHostShutdownReason == NodeEngineShutdownReason.ConnectionFailed || rarTaskHostShutdownReason == NodeEngineShutdownReason.BuildCompleteReuse);
-
-            //        return (TaskHost: rarTaskHost, shutdownReason: rarTaskHostShutdownReason, shutdownException: rarTaskHostShutdownException);
-            //    })).ToArray();
-            //// wait for them all to be finished
-            //System.Threading.Tasks.Task.WaitAll(clients.Cast<System.Threading.Tasks.Task>().ToArray());
-            //// aggregate exceptions
-            //var exceptions = clients.Where(c => c.Result.shutdownException != null).Select(c => c.Result.shutdownException).ToArray();
-            //if (exceptions.Length > 0)
-            //{
-            //    shutdownException = new AggregateException(exceptions);
-            //    return NodeEngineShutdownReason.Error;
-            //}
-            //else
-            //{
-            //    shutdownException = null;
-            //    return NodeEngineShutdownReason.BuildCompleteReuse;
-            //}
+            // TODO: how to do graceful node termination and automatic inactivity timeout termination?
+            throw new NotImplementedException("It shall never get here, as cancellation is not implemented yet");
         }
 
+        /// <summary>
+        /// Current process wide pine name used for 'named pipe' communication
+        /// </summary>
+        public static string PipeName { get; set; }
+
         /// <summary>
         /// Starts up the node and processes messages until the node is requested to shut down.
         /// </summary>
@@ -608,15 +556,12 @@ public NodeEngineShutdownReason Run(out Exception shutdownException)
 #endif
             shutdownException = null;
 
-            // Snapshot the current environment
-            _savedEnvironment = CommunicationsUtilities.GetEnvironmentVariables();
-
-            string pipeName = "MSBuild" + Process.GetCurrentProcess().Id;
-
-            _nodeEndpoint = new NodeEndpointRarTaskHost(pipeName/*, multiConnections: true*/);
+            _nodeEndpoint = new NodeEndpointRarTaskHost(PipeName);
             _nodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(OnLinkStatusChanged);
             _nodeEndpoint.Listen(this);
 
+            CommunicationsUtilities.Trace($"Listening RAR node client {this.GetHashCode()}");
+
             WaitHandle[] waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent, _taskCompleteEvent, _taskCancelledEvent };
 
             while (true)
@@ -739,28 +684,7 @@ private void CompleteTask()
         /// </summary>
         private void CancelTask()
         {
-            // If the task is an ICancellable task in CLR4 we will call it here and wait for it to complete
-            // Otherwise it's a classic ITask.
-
-            // Store in a local to avoid a race
-            var wrapper = _taskWrapper;
-            if (wrapper?.CancelTask() == false)
-            {
-                // Create a possibility for the task to be aborted if the user really wants it dropped dead asap
-                if (Environment.GetEnvironmentVariable("MSBUILDTASKHOSTABORTTASKONCANCEL") == "1")
-                {
-                    // Don't bother aborting the task if it has passed the actual user task Execute()
-                    // It means we're already in the process of shutting down - Wait for the taskCompleteEvent to be set instead.
-                    if (_isTaskExecuting)
-                    {
-#if FEATURE_THREAD_ABORT
-                        // The thread will be terminated crudely so our environment may be trashed but it's ok since we are 
-                        // shutting down ASAP.
-                        _taskRunnerThread.Abort();
-#endif
-                    }
-                }
-            }
+            // RAR task do not support cancellation
         }
 
         /// <summary>
@@ -768,6 +692,7 @@ private void CancelTask()
         /// </summary>
         private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
         {
+            CommunicationsUtilities.Trace($"RAR node client {this.GetHashCode()} handling NodeBuildComplete");
             ErrorUtilities.VerifyThrow(!_isTaskExecuting, "We should never have a task in the process of executing when we receive NodeBuildComplete.");
 
             _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;
@@ -782,13 +707,7 @@ private NodeEngineShutdownReason HandleShutdown()
             // Wait for the RunTask task runner thread before shutting down so that we can cleanly dispose all WaitHandles.
             _taskRunnerThread?.Join();
 
-            if (_debugCommunications)
-            {
-                using (StreamWriter writer = File.CreateText(String.Format(CultureInfo.CurrentCulture, Path.Combine(Path.GetTempPath(), @"MSBuild_NodeShutdown_{0}.txt"), Process.GetCurrentProcess().Id)))
-                {
-                    writer.WriteLine("Node shutting down with reason {0}.", _shutdownReason);
-                }
-            }
+            CommunicationsUtilities.Trace($"RAR node client {this.GetHashCode()} shutting down with reason {_shutdownReason}");
 
 #if !CLR2COMPATIBILITY
             _registeredTaskObjectCache.DisposeCacheObjects(RegisteredTaskObjectLifetime.Build);
@@ -799,9 +718,6 @@ private NodeEngineShutdownReason HandleShutdown()
             // so reset it away from a user-requested folder that may get deleted.
             NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);
 
-            // Restore the original environment.
-            CommunicationsUtilities.SetEnvironment(_savedEnvironment);
-
             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
             {
                 // Notify the BuildManager that we are done.
@@ -840,6 +756,7 @@ private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)
                 case LinkStatus.Failed:
                     // connection fail - unexpected but could happen if handshake fails for any reason
                     // in such case we need to start new client as LinkStatus.Active has not been reached
+                    CommunicationsUtilities.Trace("RAR {0} failed to connect to client or timeouted. Link Failed. New RAR client requested.", _id);
                     s_waitForConcurrentClient.Add(false);
 
                     _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;
@@ -851,6 +768,7 @@ private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)
 
                 case LinkStatus.Active:
                     // start listen to another incoming connection
+                    CommunicationsUtilities.Trace("RAR node {0} connected to client. Link Active. New RAR client requested.", _id);
                     s_waitForConcurrentClient.Add(true);
                     break;
 
@@ -869,29 +787,10 @@ private void RunTask(object state)
             TaskHostConfiguration taskConfiguration = state as TaskHostConfiguration;
             IDictionary<string, TaskParameter> taskParams = taskConfiguration.TaskParameters;
 
-            // We only really know the values of these variables for sure once we see what we received from our parent 
-            // environment -- otherwise if this was a completely new build, we could lose out on expected environment 
-            // variables.  
-            _debugCommunications = taskConfiguration.BuildProcessEnvironment.ContainsValueAndIsEqual("MSBUILDDEBUGCOMM", "1", StringComparison.OrdinalIgnoreCase);
-            _updateEnvironment = !taskConfiguration.BuildProcessEnvironment.ContainsValueAndIsEqual("MSBuildTaskHostDoNotUpdateEnvironment", "1", StringComparison.OrdinalIgnoreCase);
-            _updateEnvironmentAndLog = taskConfiguration.BuildProcessEnvironment.ContainsValueAndIsEqual("MSBuildTaskHostUpdateEnvironmentAndLog", "1", StringComparison.OrdinalIgnoreCase);
+            CommunicationsUtilities.Trace("RAR node {0} starting task {1} {2}.", _id, taskConfiguration.TaskName, taskConfiguration.NodeId);
 
             try
             {
-                // TODO: delete eventually
-                // Change to the startup directory
-                NativeMethodsShared.SetCurrentDirectory(taskConfiguration.StartupDirectory);
-
-                if (_updateEnvironment)
-                {
-                    // TODO: delete eventually
-                    InitializeMismatchedEnvironmentTable(taskConfiguration.BuildProcessEnvironment);
-                }
-
-                // Now set the new environment
-                // TODO: delete eventually
-                SetTaskHostEnvironment(taskConfiguration.BuildProcessEnvironment);
-
                 // Set culture
                 Thread.CurrentThread.CurrentCulture = taskConfiguration.Culture;
                 Thread.CurrentThread.CurrentUICulture = taskConfiguration.UICulture;
@@ -902,6 +801,7 @@ private void RunTask(object state)
                 // We will not create an appdomain now because of a bug
                 // As a fix, we will create the class directly without wrapping it in a domain
                 _taskWrapper = new OutOfProcTaskAppDomainWrapper();
+                var taskExecutionContext = new TaskExecutionContext(taskConfiguration.StartupDirectory, taskConfiguration.BuildProcessEnvironment, taskConfiguration.Culture, taskConfiguration.UICulture);
 
                 taskResult = _taskWrapper.ExecuteTask
                 (
@@ -915,7 +815,7 @@ private void RunTask(object state)
                     taskConfiguration.AppDomainSetup,
 #endif
                     taskParams,
-                    new TaskExecutionContext(taskConfiguration.StartupDirectory, taskConfiguration.BuildProcessEnvironment, taskConfiguration.Culture, taskConfiguration.UICulture)
+                    taskExecutionContext
                 );
             }
             catch (Exception e)
@@ -941,9 +841,6 @@ private void RunTask(object state)
                 {
                     _isTaskExecuting = false;
 
-                    IDictionary<string, string> currentEnvironment = CommunicationsUtilities.GetEnvironmentVariables();
-                    currentEnvironment = UpdateEnvironmentForMainNode(currentEnvironment);
-
                     if (taskResult == null)
                     {
                         taskResult = new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure);
@@ -954,7 +851,7 @@ private void RunTask(object state)
                         _taskCompletePacket = new TaskHostTaskComplete
                                                     (
                                                         taskResult,
-                                                        currentEnvironment
+                                                        null
                                                     );
                     }
 
@@ -965,9 +862,6 @@ private void RunTask(object state)
                         RemotingServices.Disconnect(param);
                     }
 #endif
-
-                    // Restore the original clean environment
-                    CommunicationsUtilities.SetEnvironment(_savedEnvironment);
                 }
                 catch (Exception e)
                 {
@@ -984,178 +878,8 @@ private void RunTask(object state)
 
                     // The task has now fully completed executing
                     _taskCompleteEvent.Set();
-                }
-            }
-        }
-
-        /// <summary>
-        /// Set the environment for the task host -- includes possibly munging the given 
-        /// environment somewhat to account for expected environment differences between, 
-        /// e.g. parent processes and task hosts of different bitnesses. 
-        /// </summary>
-        private void SetTaskHostEnvironment(IDictionary<string, string> environment)
-        {
-            ErrorUtilities.VerifyThrowInternalNull(s_mismatchedEnvironmentValues, "mismatchedEnvironmentValues");
-            IDictionary<string, string> updatedEnvironment = null;
-
-            if (_updateEnvironment)
-            {
-                foreach (string variable in s_mismatchedEnvironmentValues.Keys)
-                {
-                    string oldValue = s_mismatchedEnvironmentValues[variable].Key;
-                    string newValue = s_mismatchedEnvironmentValues[variable].Value;
-
-                    // We don't check the return value, because having the variable not exist == be 
-                    // null is perfectly valid, and mismatchedEnvironmentValues stores those values
-                    // as null as well, so the String.Equals should still return that they are equal.
-                    string environmentValue = null;
-                    environment.TryGetValue(variable, out environmentValue);
 
-                    if (String.Equals(environmentValue, oldValue, StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (updatedEnvironment == null)
-                        {
-                            if (_updateEnvironmentAndLog)
-                            {
-                                LogMessageFromResource(MessageImportance.Low, "ModifyingTaskHostEnvironmentHeader");
-                            }
-
-                            updatedEnvironment = new Dictionary<string, string>(environment, StringComparer.OrdinalIgnoreCase);
-                        }
-
-                        if (newValue != null)
-                        {
-                            if (_updateEnvironmentAndLog)
-                            {
-                                LogMessageFromResource(MessageImportance.Low, "ModifyingTaskHostEnvironmentVariable", variable, newValue, environmentValue ?? String.Empty);
-                            }
-
-                            updatedEnvironment[variable] = newValue;
-                        }
-                        else
-                        {
-                            updatedEnvironment.Remove(variable);
-                        }
-                    }
-                }
-            }
-
-            // if it's still null here, there were no changes necessary -- so just 
-            // set it to what was already passed in. 
-            if (updatedEnvironment == null)
-            {
-                updatedEnvironment = environment;
-            }
-
-            CommunicationsUtilities.SetEnvironment(updatedEnvironment);
-        }
-
-        /// <summary>
-        /// Given the environment of the task host at the end of task execution, make sure that any 
-        /// processor-specific variables have been re-applied in the correct form for the main node, 
-        /// so that when we pass this dictionary back to the main node, all it should have to do 
-        /// is just set it.  
-        /// </summary>
-        private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<string, string> environment)
-        {
-            ErrorUtilities.VerifyThrowInternalNull(s_mismatchedEnvironmentValues, "mismatchedEnvironmentValues");
-            IDictionary<string, string> updatedEnvironment = null;
-
-            if (_updateEnvironment)
-            {
-                foreach (string variable in s_mismatchedEnvironmentValues.Keys)
-                {
-                    // Since this is munging the property list for returning to the parent process, 
-                    // then the value we wish to replace is the one that is in this process, and the 
-                    // replacement value is the one that originally came from the parent process, 
-                    // instead of the other way around.
-                    string oldValue = s_mismatchedEnvironmentValues[variable].Value;
-                    string newValue = s_mismatchedEnvironmentValues[variable].Key;
-
-                    // We don't check the return value, because having the variable not exist == be 
-                    // null is perfectly valid, and mismatchedEnvironmentValues stores those values
-                    // as null as well, so the String.Equals should still return that they are equal.
-                    string environmentValue = null;
-                    environment.TryGetValue(variable, out environmentValue);
-
-                    if (String.Equals(environmentValue, oldValue, StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (updatedEnvironment == null)
-                        {
-                            updatedEnvironment = new Dictionary<string, string>(environment, StringComparer.OrdinalIgnoreCase);
-                        }
-
-                        if (newValue != null)
-                        {
-                            updatedEnvironment[variable] = newValue;
-                        }
-                        else
-                        {
-                            updatedEnvironment.Remove(variable);
-                        }
-                    }
-                }
-            }
-
-            // if it's still null here, there were no changes necessary -- so just 
-            // set it to what was already passed in. 
-            if (updatedEnvironment == null)
-            {
-                updatedEnvironment = environment;
-            }
-
-            return updatedEnvironment;
-        }
-
-        /// <summary>
-        /// Make sure the mismatchedEnvironmentValues table has been populated.  Note that this should 
-        /// only do actual work on the very first run of a task in the task host -- otherwise, it should 
-        /// already have been populated. 
-        /// </summary>
-        private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> environment)
-        {
-            if (s_mismatchedEnvironmentValues == null)
-            {
-                // This is the first time that we have received a TaskHostConfiguration packet, so we 
-                // need to construct the mismatched environment table based on our current environment 
-                // (assumed to be effectively identical to startup) and the environment we were given
-                // via the task host configuration, assumed to be effectively identical to the startup 
-                // environment of the task host, given that the configuration packet is sent immediately
-                // after the node is launched.  
-                s_mismatchedEnvironmentValues = new Dictionary<string, KeyValuePair<string, string>>(StringComparer.OrdinalIgnoreCase);
-
-                foreach (string variable in _savedEnvironment.Keys)
-                {
-                    string oldValue = _savedEnvironment[variable];
-                    string newValue;
-                    if (!environment.TryGetValue(variable, out newValue))
-                    {
-                        s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(null, oldValue);
-                    }
-                    else
-                    {
-                        if (!String.Equals(oldValue, newValue, StringComparison.OrdinalIgnoreCase))
-                        {
-                            s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, oldValue);
-                        }
-                    }
-                }
-
-                foreach (string variable in environment.Keys)
-                {
-                    string newValue = environment[variable];
-                    string oldValue;
-                    if (!_savedEnvironment.TryGetValue(variable, out oldValue))
-                    {
-                        s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, null);
-                    }
-                    else
-                    {
-                        if (!String.Equals(oldValue, newValue, StringComparison.OrdinalIgnoreCase))
-                        {
-                            s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, oldValue);
-                        }
-                    }
+                    CommunicationsUtilities.Trace("RAR node {0} finished task {1} {2}.", _id, taskConfiguration.TaskName, taskConfiguration.NodeId);
                 }
             }
         }
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 5f2b1ab2330..7424e0ce3ec 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1263,6 +1263,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </comment>
   </data>
+  <data name="InvalidPipeName" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
+
   <data name="Process" UESanitized="true" Visibility="Public">
     <value>Process = "{0}"</value>
   </data>
@@ -1281,7 +1291,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <!--
         The command line message bucket is: MSB1001 - MSB1999
 
-        Next error code should be MSB1060.
+        Next error code should be MSB1061.
 
         Don't forget to update this comment after using the new code.
   -->
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index ea203edd619..fc744560c0b 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -1041,6 +1041,17 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index dfbf6409b2d..e632c30541a 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1033,6 +1033,17 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.en.xlf b/src/MSBuild/Resources/xlf/Strings.en.xlf
index 813d56eb252..6c8a5e10bab 100644
--- a/src/MSBuild/Resources/xlf/Strings.en.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.en.xlf
@@ -1222,6 +1222,17 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index be5821b7ddb..f52c256392e 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1042,6 +1042,17 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 1e9052ab0ec..2cb64ba773b 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1034,6 +1034,17 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 3576dee6f26..f4aebb20fcc 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -1054,6 +1054,17 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index d64a16c977d..d338ebd227f 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1033,6 +1033,17 @@ Copyright (C) Microsoft Corporation.All rights reserved.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index b627ff1eef4..9ac6a44c140 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1033,6 +1033,17 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 8f1ee8b37b8..da02c524d3e 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -1046,6 +1046,17 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 5d4dd910080..6a271fdf56f 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1034,6 +1034,17 @@ isoladamente.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index b04ff45fb56..082814fdec8 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1033,6 +1033,17 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 73a7f281be0..f345f7b61f8 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1037,6 +1037,17 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index dcc8024c787..ec084a96edf 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1033,6 +1033,17 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 0e54b0e7198..fd9cf7122ac 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1033,6 +1033,17 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
         This error is shown when a user specifies a CPU value that is zero or less. For example, -nodeMode:0 instead of -nodeMode:2.
         LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
       </note>
+      </trans-unit>
+      <trans-unit id="InvalidPipeName">
+        <source>MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</source>
+        <target state="new">MSBUILD : error MSB1060: PipeName '{0}' is not valid. Argument pipename can include any character other than a backslash,
+      including numbers and special characters. The entire pipe name string can be up to 256 characters long.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1060: "}
+      UE: This is an internal error when argument PipeName, required by for resolve assembly reference (NodeMode: 3). For example, -nodeMode:3 -pipeName:"\a-name".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="InvalidPropertyError">
         <source>MSBUILD : error MSB1006: Property is not valid.</source>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 78a9ffbbe62..76a9c687ab6 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2656,7 +2656,12 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
                     }
                     else if (nodeModeNumber == 3)
                     {
-                        shutdownReason = RarServiceTaskHostNode.RunMultiClient(100, out nodeException);
+                        string pipeName = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.PipeName].FirstOrDefault();
+
+                        CommandLineSwitchException.VerifyThrow(!string.IsNullOrWhiteSpace(pipeName) && pipeName.Length < 256 && pipeName.IndexOf('\\') == -1,
+                            "InvalidPipeName", pipeName);
+
+                        shutdownReason = RarServiceTaskHostNode.StartRarService(pipeName, out nodeException);
                     }
                     else
                     {
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 63c98ed19fe..fc29d17c46c 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -143,6 +143,11 @@ static internal class CommunicationsUtilities
         /// </summary>
         private static string s_debugDumpPath;
 
+        /// <summary>
+        /// exclusive lock to folder write access
+        /// </summary>
+        private static Object s_traceLock = new();
+
         /// <summary>
         /// Ticks at last time logged
         /// </summary>
@@ -579,19 +584,30 @@ internal static void Trace(int nodeId, string format, params object[] args)
 
                     fileName += ".txt";
 
-                    using (StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(s_debugDumpPath, fileName), Process.GetCurrentProcess().Id, nodeId), append: true))
+                    lock (s_traceLock)
                     {
-                        string message = String.Format(CultureInfo.CurrentCulture, format, args);
-                        long now = DateTime.UtcNow.Ticks;
-                        float millisecondsSinceLastLog = (float)(now - s_lastLoggedTicks) / 10000L;
-                        s_lastLoggedTicks = now;
-                        file.WriteLine("{0} (TID {1}) {2,15} +{3,10}ms: {4}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, now, millisecondsSinceLastLog, message);
+                        using (StreamWriter file =
+                            FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(s_debugDumpPath, fileName), Process.GetCurrentProcess().Id, nodeId),
+                                append: true))
+                        {
+                            string message = String.Format(CultureInfo.CurrentCulture, format, args);
+                            long now = DateTime.UtcNow.Ticks;
+                            float millisecondsSinceLastLog = (float) (now - s_lastLoggedTicks) / 10000L;
+                            s_lastLoggedTicks = now;
+                            file.WriteLine("{0} (TID {1}) {2,15} +{3,10}ms: {4}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, now, millisecondsSinceLastLog,
+                                message);
+                        }
                     }
                 }
                 catch (IOException)
                 {
                     // Ignore
                 }
+                catch (Exception)
+                {
+                    // Tracing shall never throw in production
+                    Debug.Assert(false, "Exception during CommunicationsUtilities.Trace");
+                }
             }
         }
 
@@ -635,5 +651,291 @@ internal static int AvoidEndOfHandshakeSignal(int x)
         {
             return x == EndOfHandshakeSignal ? ~x : x;
         }
+
+        internal static IServerMutex OpenOrCreateMutex(string name, out bool createdNew)
+        {
+            if (PlatformInformation.IsRunningOnMono)
+            {
+                return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);
+            }
+            else
+            {
+                return new ServerNamedMutex(name, out createdNew);
+            }
+        }
+
+        internal interface IServerMutex : IDisposable
+        {
+            bool TryLock(int timeoutMs);
+            bool IsDisposed { get; }
+        }
+
+        /// <summary>
+        /// An interprocess mutex abstraction based on OS advisory locking (FileStream.Lock/Unlock).
+        /// If multiple processes running as the same user create FileMutex instances with the same name,
+        ///  those instances will all point to the same file somewhere in a selected temporary directory.
+        /// The TryLock method can be used to attempt to acquire the mutex, with Unlock or Dispose used to release.
+        /// Unlike Win32 named mutexes, there is no mechanism for detecting an abandoned mutex. The file
+        ///  will simply revert to being unlocked but remain where it is.
+        /// </summary>
+        internal sealed class FileMutex : IDisposable
+        {
+            public readonly FileStream Stream;
+            public readonly string FilePath;
+
+            public bool IsLocked { get; private set; }
+
+            internal static string GetMutexDirectory()
+            {
+                var tempPath = GetTempPath(null);
+                var result = Path.Combine(tempPath!, ".msbuild");
+                Directory.CreateDirectory(result);
+                return result;
+            }
+
+            public FileMutex(string name)
+            {
+                FilePath = Path.Combine(GetMutexDirectory(), name);
+                Stream = new FileStream(FilePath, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None);
+            }
+
+            public bool TryLock(int timeoutMs)
+            {
+                if (IsLocked)
+                    throw new InvalidOperationException("Lock already held");
+
+                var sw = Stopwatch.StartNew();
+                do
+                {
+                    try
+                    {
+                        Stream.Lock(0, 0);
+                        IsLocked = true;
+                        return true;
+                    }
+                    catch (IOException)
+                    {
+                        // Lock currently held by someone else.
+                        // We want to sleep for a short period of time to ensure that other processes
+                        //  have an opportunity to finish their work and relinquish the lock.
+                        // Spinning here (via Yield) would work but risks creating a priority
+                        //  inversion if the lock is held by a lower-priority process.
+                        Thread.Sleep(1);
+                    }
+                    catch (Exception)
+                    {
+                        // Something else went wrong.
+                        return false;
+                    }
+                } while (sw.ElapsedMilliseconds < timeoutMs);
+
+                return false;
+            }
+
+            public void Unlock()
+            {
+                if (!IsLocked)
+                    return;
+                Stream.Unlock(0, 0);
+                IsLocked = false;
+            }
+
+            public void Dispose()
+            {
+                var wasLocked = IsLocked;
+                if (wasLocked)
+                    Unlock();
+                Stream.Dispose();
+                // We do not delete the lock file here because there is no reliable way to perform a
+                //  'delete if no one has the file open' operation atomically on *nix. This is a leak.
+            }
+        }
+
+        internal sealed class ServerNamedMutex : IServerMutex
+        {
+            public readonly Mutex ServerMutex;
+
+            public bool IsDisposed { get; private set; }
+            public bool IsLocked { get; private set; }
+
+            public ServerNamedMutex(string mutexName, out bool createdNew)
+            {
+                ServerMutex = new Mutex(
+                    initiallyOwned: true,
+                    name: mutexName,
+                    createdNew: out createdNew
+                );
+                if (createdNew)
+                    IsLocked = true;
+            }
+
+            public static bool WasOpen(string mutexName)
+            {
+                try
+                {
+                    // we can't use TryOpenExisting as it is not supported in net3.5
+                    using var m = Mutex.OpenExisting(mutexName);
+                    return true;
+                }
+                catch
+                {
+                    // In the case an exception occurred trying to open the Mutex then 
+                    // the assumption is that it's not open.
+                    return false;
+                }
+            }
+
+            public bool TryLock(int timeoutMs)
+            {
+                if (IsDisposed)
+                    throw new ObjectDisposedException("Mutex");
+                if (IsLocked)
+                    throw new InvalidOperationException("Lock already held");
+                return IsLocked = ServerMutex.WaitOne(timeoutMs);
+            }
+
+            public void Dispose()
+            {
+                if (IsDisposed)
+                    return;
+                IsDisposed = true;
+
+                try
+                {
+                    if (IsLocked)
+                        ServerMutex.ReleaseMutex();
+                }
+                finally
+                {
+                    (ServerMutex as IDisposable).Dispose();
+                    IsLocked = false;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Approximates a named mutex with 'locked', 'unlocked' and 'abandoned' states.
+        /// There is no reliable way to detect whether a mutex has been abandoned on some target platforms,
+        ///  so we use the AliveMutex to manually track whether the creator of a mutex is still running,
+        ///  while the HeldMutex represents the actual lock state of the mutex.
+        /// </summary>
+        internal sealed class ServerFileMutexPair : IServerMutex
+        {
+            public readonly FileMutex AliveMutex;
+            public readonly FileMutex HeldMutex;
+
+            public bool IsDisposed { get; private set; }
+
+            public ServerFileMutexPair(string mutexName, bool initiallyOwned, out bool createdNew)
+            {
+                AliveMutex = new FileMutex(mutexName + "-alive");
+                HeldMutex = new FileMutex(mutexName + "-held");
+                createdNew = AliveMutex.TryLock(0);
+                if (initiallyOwned && createdNew)
+                {
+                    if (!TryLock(0))
+                        throw new Exception("Failed to lock mutex after creating it");
+                }
+            }
+
+            public bool TryLock(int timeoutMs)
+            {
+                if (IsDisposed)
+                    throw new ObjectDisposedException("Mutex");
+                return HeldMutex.TryLock(timeoutMs);
+            }
+
+            public void Dispose()
+            {
+                if (IsDisposed)
+                    return;
+                IsDisposed = true;
+
+                try
+                {
+                    HeldMutex.Unlock();
+                    AliveMutex.Unlock();
+                }
+                finally
+                {
+                    AliveMutex.Dispose();
+                    HeldMutex.Dispose();
+                }
+            }
+        }
+
+        /// <summary>
+        /// Gets the value of the temporary path for the current environment assuming the working directory
+        /// is <paramref name="workingDir"/>.  This function must emulate <see cref="Path.GetTempPath"/> as 
+        /// closely as possible.
+        /// </summary>
+        public static string GetTempPath(string workingDir)
+        {
+            if (PlatformInformation.IsUnix)
+            {
+                // Unix temp path is fine: it does not use the working directory
+                // (it uses ${TMPDIR} if set, otherwise, it returns /tmp)
+                return Path.GetTempPath();
+            }
+
+            var tmp = Environment.GetEnvironmentVariable("TMP");
+            if (Path.IsPathRooted(tmp))
+            {
+                return tmp;
+            }
+
+            var temp = Environment.GetEnvironmentVariable("TEMP");
+            if (Path.IsPathRooted(temp))
+            {
+                return temp;
+            }
+
+            if (!string.IsNullOrEmpty(workingDir))
+            {
+                if (!string.IsNullOrEmpty(tmp))
+                {
+                    return Path.Combine(workingDir, tmp);
+                }
+
+                if (!string.IsNullOrEmpty(temp))
+                {
+                    return Path.Combine(workingDir, temp);
+                }
+            }
+
+            var userProfile = Environment.GetEnvironmentVariable("USERPROFILE");
+            if (Path.IsPathRooted(userProfile))
+            {
+                return userProfile;
+            }
+
+            return Environment.GetEnvironmentVariable("SYSTEMROOT");
+        }
+
+        /// <summary>
+        /// This class provides simple properties for determining whether the current platform is Windows or Unix-based.
+        /// We intentionally do not use System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(...) because
+        /// it incorrectly reports 'true' for 'Windows' in desktop builds running on Unix-based platforms via Mono.
+        /// </summary>
+        internal static class PlatformInformation
+        {
+            public static bool IsWindows => Path.DirectorySeparatorChar == '\\';
+            public static bool IsUnix => Path.DirectorySeparatorChar == '/';
+            public static bool IsRunningOnMono
+            {
+                get
+                {
+                    try
+                    {
+                        return !(Type.GetType("Mono.Runtime") is null);
+                    }
+                    catch
+                    {
+                        // Arbitrarily assume we're not running on Mono.
+                        return false;
+                    }
+                }
+            }
+        }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index ab6b685ba91..8ed4e8f7c22 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -168,6 +168,7 @@ private void LazyInitialize()
                         _assemblyFoldersCache = _buildEngine.GetRegisteredTaskObject(key, RegisteredTaskObjectLifetime.Build) as AssemblyFoldersExCache;
                     }
 
+                    // TODO: although thread safe, there is risk of multiple initialization; consider it to rework into GetOrAdd Pattern
                     if (_assemblyFoldersCache == null)
                     {
                         AssemblyFoldersEx assemblyFolders = new AssemblyFoldersEx(_registryKeyRoot, _targetRuntimeVersion, _registryKeySuffix, _osVersion, _platform, _getRegistrySubKeyNames, _getRegistrySubKeyDefaultValue, this.targetProcessorArchitecture, _openBaseKey);
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
index e6e2a2bcb80..5af7d856789 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
@@ -122,6 +122,7 @@ private void LazyInitialize()
                         _assemblyFoldersCache = _buildEngine.GetRegisteredTaskObject(key, RegisteredTaskObjectLifetime.Build) as AssemblyFoldersFromConfigCache;
                     }
 
+                    // TODO: although thread safe, there is risk of multiple initialization; consider it to rework into GetOrAdd Pattern
                     if (_assemblyFoldersCache == null)
                     {
                         // This should never happen. Microsoft.Common.CurrentVersion.targets will not specify a AssemblyFoldersFromConfig search path
