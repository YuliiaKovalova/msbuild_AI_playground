diff --git a/.github/CODE_OF_CONDUCT.md b/.github/CODE_OF_CONDUCT.md
index 6684a497cb9..91d2e404ff1 100644
--- a/.github/CODE_OF_CONDUCT.md
+++ b/.github/CODE_OF_CONDUCT.md
@@ -1,3 +1,6 @@
 # Code of Conduct
 
-This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.
+This project has adopted the code of conduct defined by the Contributor Covenant
+to clarify expected behavior in our community.
+
+For more information, see the [.NET Foundation Code of Conduct](https://dotnetfoundation.org/code-of-conduct).
\ No newline at end of file
diff --git a/MSBuild.sln b/MSBuild.sln
index 105c979813e..966817afd12 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -1,7 +1,7 @@
 ï»¿
 Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 15
-VisualStudioVersion = 15.0.27004.2009
+# Visual Studio Version 16
+VisualStudioVersion = 16.0.30320.27
 MinimumVisualStudioVersion = 10.0.40219.1
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{4900B3B8-4310-4D5B-B1F7-2FDF9199765F}"
 	ProjectSection(SolutionItems) = preProject
@@ -65,6 +65,8 @@ Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild.Engine.Corext", "sr
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild.Bootstrap", "src\MSBuild.Bootstrap\MSBuild.Bootstrap.csproj", "{CEAEE4FE-9298-443B-AFC5-0F72472484B6}"
 EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.UnGAC", "src\Package\Microsoft.Build.UnGAC\Microsoft.Build.UnGAC.csproj", "{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -834,6 +836,36 @@ Global
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x64.ActiveCfg = Debug|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x64.Build.0 = Debug|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x86.Build.0 = Debug|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|Any CPU.Build.0 = Release|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|x64.ActiveCfg = Release|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|x64.Build.0 = Release|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|x86.ActiveCfg = Release|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|x86.Build.0 = Release|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -850,6 +882,7 @@ Global
 		{16DBDF17-3E0E-4140-989A-B42638126A40} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 	EndGlobalSection
 	GlobalSection(ExtensibilityGlobals) = postSolution
 		SolutionGuid = {F948D667-14E3-4F98-BA50-3F3C948BF4C2}
diff --git a/README.md b/README.md
index b81b6c6c627..2950b52008a 100644
--- a/README.md
+++ b/README.md
@@ -53,10 +53,6 @@ MSBuild can be run on Unix systems that support .NET Core. Set-up instructions c
 
 You can turn on localized builds via the `/p:LocalizedBuild=true` command line argument. For more information on localized builds and how to make contributions to MSBuild's translations, see our [localization documentation](documentation/wiki/Localization.md)
 
-## How to Engage, Contribute and Provide Feedback
-
-This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.
-
 #### Getting Started
 
 Before you contribute, please read through the contributing and developer guides to get an idea of what kinds of pull requests we accept.
diff --git a/eng/Signing.props b/eng/Signing.props
index 13912cb79a5..b07f715e5ab 100644
--- a/eng/Signing.props
+++ b/eng/Signing.props
@@ -2,7 +2,7 @@
     <ItemGroup>
 		<FileSignInfo Include="Nerdbank.Streams.dll" CertificateName="3PartySHA2" /> 
 		<FileSignInfo Include="MessagePack.dll" CertificateName="3PartySHA2" /> 
-		<FileSignInfo Include="MessagePack.Annotations.dll" CertificateName="3PartySHA2" /> 
-		<ItemsToSign Include="$(VisualStudioSetupOutputPath)DevDivPackages\*.nupkg" />
+		<FileSignInfo Include="MessagePack.Annotations.dll" CertificateName="3PartySHA2" />
+		<ItemsToSign Include="$(VisualStudioSetupInsertionPath)Microsoft.Build.UnGAC.exe" />
 	</ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index d8f4caae728..eced259e793 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20427.6">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20465.6">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>84cd401ce792220bdb17c5587f9b39265170c03f</Sha>
+      <Sha>4f384ab6a49fc642aec2acc4bcc938172a0744d1</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/global.json b/global.json
index 7f00e869a27..c1f4c682239 100644
--- a/global.json
+++ b/global.json
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20427.6"
+    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20465.6"
   }
 }
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index a4b601bd068..b500e0ea135 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -489,6 +489,18 @@ public GenerateDeploymentManifest() { }
         protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
         protected internal override bool ValidateInputs() { throw null; }
     }
+    public sealed partial class GenerateLauncher : Microsoft.Build.Tasks.TaskExtension
+    {
+        public GenerateLauncher() { }
+        public string AssemblyName { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
+        public string LauncherPath { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem OutputEntryPoint { get { throw null; } set { } }
+        public string OutputPath { get { throw null; } set { } }
+        public string VisualStudioVersion { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public abstract partial class GenerateManifestBase : Microsoft.Build.Utilities.Task
     {
         protected GenerateManifestBase() { }
@@ -497,6 +509,7 @@ protected GenerateManifestBase() { }
         public string Description { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem InputManifest { get { throw null; } set { } }
+        public bool LauncherBasedDeployment { get { throw null; } set { } }
         public int MaxTargetPath { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem OutputManifest { get { throw null; } set { } }
@@ -884,9 +897,9 @@ public ResolveAssemblyReference() { }
         public string AppConfigFile { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
+        public string AssemblyInformationCacheOutputPath { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] AssemblyInformationCachePaths { get { throw null; } set { } }
         public bool AutoUnify { get { throw null; } set { } }
-        public string[] CacheInputPaths { get { throw null; } set { } }
-        public string CacheOutputPath { get { throw null; } set { } }
         public string[] CandidateAssemblyFiles { get { throw null; } set { } }
         public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
@@ -1002,10 +1015,12 @@ public ResolveKeySource() { }
     public sealed partial class ResolveManifestFiles : Microsoft.Build.Tasks.TaskExtension
     {
         public ResolveManifestFiles() { }
+        public string AssemblyName { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] ExtraFiles { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public bool LauncherBasedDeployment { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] ManagedAssemblies { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] NativeAssemblies { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
@@ -1020,6 +1035,7 @@ public ResolveManifestFiles() { }
         public Microsoft.Build.Framework.ITaskItem[] SatelliteAssemblies { get { throw null; } set { } }
         public bool SigningManifests { get { throw null; } set { } }
         public string TargetCulture { get { throw null; } set { } }
+        public string TargetFrameworkIdentifier { get { throw null; } set { } }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -2141,6 +2157,12 @@ public void Clear() { }
         public System.Collections.IEnumerator GetEnumerator() { throw null; }
         public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) { }
     }
+    public partial class LauncherBuilder
+    {
+        public LauncherBuilder(string launcherPath) { }
+        public string LauncherPath { get { throw null; } set { } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(string filename, string outputPath) { throw null; }
+    }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public abstract partial class Manifest
     {
@@ -2148,6 +2170,8 @@ protected internal Manifest() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity AssemblyIdentity { get { throw null; } set { } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string AssemblyName { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection AssemblyReferences { get { throw null; } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string Description { get { throw null; } set { } }
@@ -2158,6 +2182,8 @@ protected internal Manifest() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public System.IO.Stream InputStream { get { throw null; } set { } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool LauncherBasedDeployment { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection OutputMessages { get { throw null; } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public bool ReadOnly { get { throw null; } set { } }
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 6c496dd317e..4d931ebd3ba 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -303,6 +303,14 @@ public FindUnderPath() { }
         public bool UpdateToAbsolutePaths { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public sealed partial class FormatUrl : Microsoft.Build.Tasks.TaskExtension
+    {
+        public FormatUrl() { }
+        public string InputUrl { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public string OutputUrl { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public sealed partial class FormatVersion : Microsoft.Build.Tasks.TaskExtension
     {
         public FormatVersion() { }
@@ -375,6 +383,18 @@ public GenerateDeploymentManifest() { }
         protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
         protected internal override bool ValidateInputs() { throw null; }
     }
+    public sealed partial class GenerateLauncher : Microsoft.Build.Tasks.TaskExtension
+    {
+        public GenerateLauncher() { }
+        public string AssemblyName { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
+        public string LauncherPath { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem OutputEntryPoint { get { throw null; } set { } }
+        public string OutputPath { get { throw null; } set { } }
+        public string VisualStudioVersion { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public abstract partial class GenerateManifestBase : Microsoft.Build.Utilities.Task
     {
         protected GenerateManifestBase() { }
@@ -383,6 +403,7 @@ protected GenerateManifestBase() { }
         public string Description { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem InputManifest { get { throw null; } set { } }
+        public bool LauncherBasedDeployment { get { throw null; } set { } }
         public int MaxTargetPath { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem OutputManifest { get { throw null; } set { } }
@@ -621,9 +642,9 @@ public ResolveAssemblyReference() { }
         public string AppConfigFile { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
+        public string AssemblyInformationCacheOutputPath { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] AssemblyInformationCachePaths { get { throw null; } set { } }
         public bool AutoUnify { get { throw null; } set { } }
-        public string[] CacheInputPaths { get { throw null; } set { } }
-        public string CacheOutputPath { get { throw null; } set { } }
         public string[] CandidateAssemblyFiles { get { throw null; } set { } }
         public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
@@ -739,10 +760,12 @@ public ResolveKeySource() { }
     public sealed partial class ResolveManifestFiles : Microsoft.Build.Tasks.TaskExtension
     {
         public ResolveManifestFiles() { }
+        public string AssemblyName { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] ExtraFiles { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public bool LauncherBasedDeployment { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] ManagedAssemblies { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] NativeAssemblies { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
@@ -757,6 +780,7 @@ public ResolveManifestFiles() { }
         public Microsoft.Build.Framework.ITaskItem[] SatelliteAssemblies { get { throw null; } set { } }
         public bool SigningManifests { get { throw null; } set { } }
         public string TargetCulture { get { throw null; } set { } }
+        public string TargetFrameworkIdentifier { get { throw null; } set { } }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -1768,6 +1792,12 @@ public void Clear() { }
         public System.Collections.IEnumerator GetEnumerator() { throw null; }
         public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) { }
     }
+    public partial class LauncherBuilder
+    {
+        public LauncherBuilder(string launcherPath) { }
+        public string LauncherPath { get { throw null; } set { } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(string filename, string outputPath) { throw null; }
+    }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public abstract partial class Manifest
     {
@@ -1775,6 +1805,8 @@ protected internal Manifest() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity AssemblyIdentity { get { throw null; } set { } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string AssemblyName { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection AssemblyReferences { get { throw null; } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string Description { get { throw null; } set { } }
@@ -1785,6 +1817,8 @@ protected internal Manifest() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public System.IO.Stream InputStream { get { throw null; } set { } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool LauncherBasedDeployment { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection OutputMessages { get { throw null; } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public bool ReadOnly { get { throw null; } set { } }
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index a4e0c79e34e..483adcb954b 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Exceptions;
 using Shouldly;
 using Xunit;
+using System.Text;
 
 namespace Microsoft.Build.UnitTests.Construction
 {
@@ -1067,6 +1068,59 @@ public void ParseProjectConfigurationsInSolutionConfigurations2()
             Assert.Equal(".NET", solution.GetDefaultPlatformName()); // "Default solution platform"
         }
 
+        /// <summary>
+        /// Parse solution file with comments
+        /// </summary>
+        [Fact]
+        public void ParseSolutionWithComments()
+        {
+            const string solutionFileContent = @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.0.29123.89
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project('{9A19103F-16F7-4668-BE54-9A1E7A4F7556}') = 'SlnCommentTest', 'SlnCommentTest.csproj', '{00000000-0000-0000-FFFF-FFFFFFFFFFFF}'
+                    EndProject
+                    Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'Solution Items', 'Solution Items', '{054DED3B-B890-4652-B449-839F581E5D86}'
+	                    ProjectSection(SolutionItems) = preProject
+		                    SlnFile.txt = SlnFile.txt
+	                    EndProjectSection
+                    EndProject
+                    Global
+	                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                    Debug|Any CPU = Debug|Any CPU
+		                    Release|Any CPU = Release|Any CPU
+	                    EndGlobalSection
+	                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Release|Any CPU.Build.0 = Release|Any CPU
+	                    EndGlobalSection
+	                    GlobalSection(SolutionProperties) = preSolution
+		                    HideSolutionNode = FALSE
+	                    EndGlobalSection
+	                    GlobalSection(ExtensibilityGlobals) = postSolution
+		                    SolutionGuid = {FFFFFFFF-FFFF-FFFF-0000-000000000000}
+	                    EndGlobalSection
+                    EndGlobal
+                    ";
+
+            StringBuilder stringBuilder = new StringBuilder();
+
+            // Put comment between all lines
+            const string comment = "\t# comment";
+            string[] lines = solutionFileContent.Split(new string[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
+            for (int i = 0; i < lines.Length; i++)
+            {
+                stringBuilder.AppendLine(comment);
+                stringBuilder.AppendLine(lines[i]);
+            }
+            stringBuilder.AppendLine(comment);
+
+            Should.NotThrow(() => ParseSolutionHelper(stringBuilder.ToString()));
+        }
+
         /// <summary>
         /// Helper method to create a SolutionFile object, and call it to parse the SLN file
         /// represented by the string contents passed in.
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 6444f966f98..dc096100aa9 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -114,15 +114,17 @@ public void SolutionFilterFiltersProjects()
                   </Target>
                   </Project>
                     ");
+
+                // Slashes here (and in the .slnf) are hardcoded as backslashes intentionally to support the common case.
                 TransientTestFile solutionFile = testEnvironment.CreateFile(simpleProjectFolder, "SimpleProject.sln",
                     @"
                     Microsoft Visual Studio Solution File, Format Version 12.00
                     # Visual Studio Version 16
                     VisualStudioVersion = 16.0.29326.124
                     MinimumVisualStudioVersion = 10.0.40219.1
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""SimpleProject"", """ + Path.Combine("SimpleProject", "SimpleProject.csproj") + @""", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""SimpleProject"", ""SimpleProject\SimpleProject.csproj"", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
                     EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""ClassLibrary"", """ + Path.Combine("..", "ClassLibrary", "ClassLibrary", "ClassLibrary.csproj") + @""", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""ClassLibrary"", ""..\ClassLibrary\ClassLibrary\ClassLibrary.csproj"", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
                     EndProject
                     Global
                         GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -155,9 +157,9 @@ public void SolutionFilterFiltersProjects()
                     @"
                 {
                   ""solution"": {
-                    ""path"": """ + Path.Combine(".", "SimpleProject", "SimpleProject.sln").Replace("\\", "\\\\") + @""",
+                    ""path"": "".\\SimpleProject\\SimpleProject.sln"",
                     ""projects"": [
-                      """ + Path.Combine("SimpleProject", "SimpleProject.csproj").Replace("\\", "\\\\") + @"""
+                      ""SimpleProject\\SimpleProject.csproj""
                     ]
                     }
                 }
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 177903a4e72..9e207770dae 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -81,13 +81,16 @@ public sealed class SolutionFile
         private const string fsProjectGuid = "{F2A71F9B-5D33-465A-A702-920D77279786}";
         private const string dbProjectGuid = "{C8D11400-126E-41CD-887F-60BD40844F9E}";
         private const string wdProjectGuid = "{2CFEAB61-6A3B-4EB8-B523-560B4BEEF521}";
+        private const string synProjectGuid = "{BBD0F5D1-1CC4-42FD-BA4C-A96779C64378}";
         private const string webProjectGuid = "{E24C65DC-7377-472B-9ABA-BC803B73C61A}";
         private const string solutionFolderGuid = "{2150E333-8FDC-42A3-9474-1A3956D46DE8}";
         private const string sharedProjectGuid = "{D954291E-2A0B-460D-934E-DC6B0785DB48}";
 
+        private const char CommentStartChar = '#';
         #endregion
         #region Member data
         private string _solutionFile;                 // Could be absolute or relative path to the .SLN file.
+        private string _solutionFilterFile;          // Could be absolute or relative path to the .SLNF file.
         private HashSet<string> _solutionFilter;     // The project files to include in loading the solution.
         private bool _parsingForConversionOnly;      // Are we parsing this solution to get project reference data during
                                                      // conversion, or in preparation for actually building the solution?
@@ -235,7 +238,7 @@ internal string SolutionFileDirectory
 
         internal bool ProjectShouldBuild(string projectFile)
         {
-            return _solutionFilter?.Contains(projectFile) != false;
+            return _solutionFilter?.Contains(FileUtilities.FixFilePath(projectFile)) != false;
         }
 
         /// <summary>
@@ -363,6 +366,7 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
 
         private void ParseSolutionFilter(string solutionFilterFile)
         {
+            _solutionFilterFile = solutionFilterFile;
             try
             {
                 _solutionFile = ParseSolutionFromSolutionFilter(solutionFilterFile, out JsonElement solution);
@@ -380,7 +384,7 @@ private void ParseSolutionFilter(string solutionFilterFile)
                 _solutionFilter = new HashSet<string>(NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
                 foreach (JsonElement project in solution.GetProperty("projects").EnumerateArray())
                 {
-                    _solutionFilter.Add(project.GetString());
+                    _solutionFilter.Add(FileUtilities.FixFilePath(project.GetString()));
                 }
             }
             catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
@@ -403,7 +407,7 @@ internal static string ParseSolutionFromSolutionFilter(string solutionFilterFile
             {
                 JsonDocument text = JsonDocument.Parse(File.ReadAllText(solutionFilterFile));
                 solution = text.RootElement.GetProperty("solution");
-                return Path.GetFullPath(Path.Combine(Path.GetDirectoryName(solutionFilterFile), solution.GetProperty("path").GetString()));
+                return FileUtilities.GetFullPath(solution.GetProperty("path").GetString(), Path.GetDirectoryName(solutionFilterFile));
             }
             catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
             {
@@ -543,7 +547,7 @@ internal void ParseSolution()
                 HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
                 foreach (ProjectInSolution project in _projectsInOrder)
                 {
-                    projectPaths.Add(project.RelativePath);
+                    projectPaths.Add(FileUtilities.FixFilePath(project.RelativePath));
                 }
                 foreach (string project in _solutionFilter)
                 {
@@ -552,9 +556,9 @@ internal void ParseSolution()
                         ProjectFileErrorUtilities.ThrowInvalidProjectFile
                         (
                             "SubCategoryForSolutionParsingErrors",
-                            new BuildEventFileInfo(project),
+                            new BuildEventFileInfo(FileUtilities.GetFullPath(project, Path.GetDirectoryName(_solutionFile))),
                             "SolutionFilterFilterContainsProjectNotInSolution",
-                            _solutionFilter,
+                            _solutionFilterFile,
                             project,
                             _solutionFile
                         );
@@ -1266,7 +1270,8 @@ ProjectInSolution proj
                 (String.Equals(projectTypeGuid, cpsFsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
                 (String.Equals(projectTypeGuid, fsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
                 (String.Equals(projectTypeGuid, dbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
-                (String.Equals(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase)))
+                (String.Equals(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, synProjectGuid, StringComparison.OrdinalIgnoreCase)))
             {
                 proj.ProjectType = SolutionProjectType.KnownToBeMSBuildFormat;
             }
@@ -1326,7 +1331,8 @@ internal void ParseNestedProjects()
                     break;
                 }
 
-                if (String.IsNullOrWhiteSpace(str))
+                // Ignore empty line or comment
+                if (String.IsNullOrWhiteSpace(str) || str[0] == CommentStartChar)
                 {
                     continue;
                 }
@@ -1373,7 +1379,8 @@ internal void ParseSolutionConfigurations()
                     break;
                 }
 
-                if (String.IsNullOrWhiteSpace(str))
+                // Ignore empty line or comment
+                if (String.IsNullOrWhiteSpace(str) || str[0] == CommentStartChar)
                 {
                     continue;
                 }
@@ -1438,7 +1445,8 @@ internal Dictionary<string, string> ParseProjectConfigurations()
                     break;
                 }
 
-                if (String.IsNullOrWhiteSpace(str))
+                // Ignore empty line or comment
+                if (String.IsNullOrWhiteSpace(str) || str[0] == CommentStartChar)
                 {
                     continue;
                 }
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 62efc814b55..99d9cd4e81e 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -60,7 +60,7 @@ public class Project : ILinkableObject
         private static readonly char[] s_invalidGlobChars = FileUtilities.InvalidFileNameChars.Where(c => c != '*' && c != '?' && c!= '/' && c != '\\' && c != ':').ToArray();
 
         /// <summary>
-        /// Context to log messages and events in
+        /// Context to log messages and events in.
         /// </summary>
         private static readonly BuildEventContext s_buildEventContext = new BuildEventContext(0 /* node ID */, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
 
@@ -157,7 +157,7 @@ public Project(ProjectCollection projectCollection, NewProjectFileOptions newPro
         /// Project will be added to the specified project collection when it is named.
         /// </summary>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         public Project(IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection)
             : this(ProjectRootElement.Create(projectCollection, DefaultNewProjectTemplateOptions), globalProperties, toolsVersion, projectCollection)
@@ -170,7 +170,7 @@ public Project(IDictionary<string, string> globalProperties, string toolsVersion
         /// Project will be added to the specified project collection when it is named.
         /// </summary>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="newProjectFileOptions">The <see cref="NewProjectFileOptions"/> to use for the new project.</param>
         public Project(IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, NewProjectFileOptions newProjectFileOptions)
@@ -185,7 +185,7 @@ public Project(IDictionary<string, string> globalProperties, string toolsVersion
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         public Project(ProjectRootElement xml)
             : this(xml, null, null)
         {
@@ -198,9 +198,9 @@ public Project(ProjectRootElement xml)
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion)
             : this(xml, globalProperties, toolsVersion, ProjectCollection.GlobalProjectCollection)
         {
@@ -213,9 +213,9 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection)
             : this(xml, globalProperties, toolsVersion, projectCollection, ProjectLoadSettings.Default)
@@ -229,9 +229,9 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
@@ -246,9 +246,9 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
@@ -277,7 +277,7 @@ private Project(ProjectRootElement xml, IDictionary<string, string> globalProper
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         public Project(XmlReader xmlReader)
             : this(xmlReader, null, null)
         {
@@ -290,9 +290,9 @@ public Project(XmlReader xmlReader)
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion)
             : this(xmlReader, globalProperties, toolsVersion, ProjectCollection.GlobalProjectCollection)
         {
@@ -305,9 +305,9 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection)
             : this(xmlReader, globalProperties, toolsVersion, projectCollection, ProjectLoadSettings.Default)
@@ -321,9 +321,9 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
@@ -338,9 +338,9 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
@@ -397,7 +397,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// May throw IO-related exceptions.
         /// </summary>
-        /// <param name="projectFile">The project file</param>
+        /// <param name="projectFile">The project file.</param>
         /// <param name="globalProperties">The global properties. May be null.</param>
         /// <param name="toolsVersion">The tools version. May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
@@ -414,7 +414,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// May throw IO-related exceptions.
         /// </summary>
-        /// <param name="projectFile">The project file</param>
+        /// <param name="projectFile">The project file.</param>
         /// <param name="globalProperties">The global properties. May be null.</param>
         /// <param name="toolsVersion">The tools version. May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
@@ -432,7 +432,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// May throw IO-related exceptions.
         /// </summary>
-        /// <param name="projectFile">The project file</param>
+        /// <param name="projectFile">The project file.</param>
         /// <param name="globalProperties">The global properties. May be null.</param>
         /// <param name="toolsVersion">The tools version. May be null.</param>
         /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
@@ -562,7 +562,7 @@ private enum BuildEnabledSetting
 
         /// <summary>
         /// The backing Xml project.
-        /// Can never be null
+        /// Can never be null.
         /// </summary>
         /// <remarks>
         /// There is no setter here as that doesn't make sense. If you have a new ProjectRootElement, evaluate it into a new Project.
@@ -595,7 +595,7 @@ private enum BuildEnabledSetting
         /// </summary>
         /// <comments>
         /// data.ItemTypes is a KeyCollection, so it doesn't need any
-        /// additional read-only protection
+        /// additional read-only protection.
         /// </comments>
         public ICollection<string> ItemTypes => implementation.ItemTypes;
 
@@ -625,12 +625,12 @@ private enum BuildEnabledSetting
 
         /// <summary>
         /// Read-only dictionary of item definitions in this project.
-        /// Keyed by item type
+        /// Keyed by item type.
         /// </summary>
         public IDictionary<string, ProjectItemDefinition> ItemDefinitions => implementation.ItemDefinitions;
 
         /// <summary>
-        /// Items in this project, ordered within groups of item types
+        /// Items in this project, ordered within groups of item types.
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
         public ICollection<ProjectItem> Items => implementation.Items;
@@ -806,12 +806,12 @@ public bool IsBuildEnabled
         public int LastEvaluationId => implementation.LastEvaluationId;
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable
+        /// List of names of the properties that, while global, are still treated as overridable.
         /// </summary>
         internal ISet<string> GlobalPropertiesToTreatAsLocal => implementationInternal.GlobalPropertiesToTreatAsLocal;
 
         /// <summary>
-        /// The logging service used for evaluation errors
+        /// The logging service used for evaluation errors.
         /// </summary>
         internal ILoggingService LoggingService => ProjectCollection.LoggingService;
 
@@ -862,7 +862,7 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item)
         ///GlobResult(glob: "*.txt", exclude=[]),
         ///GlobResult(glob: "*.a", exclude=[]),
         ///GlobResult(glob: "*.cs", exclude=["bar"])
-        ///]
+        ///].
         /// </example>
         /// <remarks>
         /// <see cref="GlobResult.MsBuildGlob"/> is a <see cref="IMSBuildGlob"/> that combines all globs in the include element and ignores
@@ -884,11 +884,11 @@ public List<GlobResult> GetAllGlobs()
         }
 
         /// <summary>
-        /// See <see cref="GetAllGlobs()"/>
+        /// See <see cref="GetAllGlobs()"/>.
         /// </summary>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext)
         {
@@ -896,21 +896,21 @@ public List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext)
         }
 
         /// <summary>
-        /// Overload of <see cref="GetAllGlobs()"/>
+        /// Overload of <see cref="GetAllGlobs()"/>.
         /// </summary>
-        /// <param name="itemType">Confine search to item elements of this type</param>
+        /// <param name="itemType">Confine search to item elements of this type.</param>
         public List<GlobResult> GetAllGlobs(string itemType)
         {
             return implementation.GetAllGlobs(itemType, null);
         }
 
         /// <summary>
-        /// See <see cref="GetAllGlobs(string)"/>
+        /// See <see cref="GetAllGlobs(string)"/>.
         /// </summary>
-        /// <param name="itemType">type of the item</param>
+        /// <param name="itemType">Type of the item.</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluationContext)
         {
@@ -921,11 +921,11 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         /// Finds all the item elements in the logical project with itemspecs that match the given string:
         /// - elements that would include (or exclude) the string
         /// - elements that would update the string (not yet implemented)
-        /// - elements that would remove the string (not yet implemented)
+        /// - elements that would remove the string (not yet implemented).
         /// </summary>
         ///
         /// <example>
-        /// The following snippet shows what <c>GetItemProvenance("a.cs")</c> returns for various item elements
+        /// The following snippet shows what <c>GetItemProvenance("a.cs")</c> returns for various item elements.
         /// <code>
         /// <A Include="a.cs;*.cs"/> // Occurrences:2; Operation: Include; Provenance: StringLiteral | Glob
         /// <B Include="*.cs" Exclude="a.cs"/> // Occurrences: 1; Operation: Exclude; Provenance: StringLiteral
@@ -956,7 +956,7 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         /// This API and its return types are prone to change.
         /// </remarks>
         ///
-        /// <param name="itemToMatch">The string to perform matching against</param>
+        /// <param name="itemToMatch">The string to perform matching against.</param>
         ///
         /// <returns>
         /// A list of <see cref="ProvenanceResult"/>, sorted in project evaluation order.
@@ -967,12 +967,12 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch)
         }
 
         /// <summary>
-        /// See <see cref="GetItemProvenance(string)"/>
+        /// See <see cref="GetItemProvenance(string)"/>.
         /// </summary>
-        /// <param name="itemToMatch">The string to perform matching against</param>
+        /// <param name="itemToMatch">The string to perform matching against.</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<ProvenanceResult> GetItemProvenance(string itemToMatch, EvaluationContext evaluationContext)
         {
@@ -980,23 +980,23 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch, EvaluationCo
         }
 
         /// <summary>
-        /// Overload of <see cref="GetItemProvenance(string)"/>
+        /// Overload of <see cref="GetItemProvenance(string)"/>.
         /// </summary>
-        /// <param name="itemToMatch">The string to perform matching against</param>
-        /// <param name="itemType">The item type to constrain the search in</param>
+        /// <param name="itemToMatch">The string to perform matching against.</param>
+        /// <param name="itemType">The item type to constrain the search in.</param>
         public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType)
         {
             return GetItemProvenance(itemToMatch, itemType, null);
         }
 
         /// <summary>
-        /// See <see cref="GetItemProvenance(string, string)"/>
+        /// See <see cref="GetItemProvenance(string, string)"/>.
         /// </summary>
-        /// <param name="itemToMatch">The string to perform matching against</param>
-        /// <param name="itemType">The type of the item to perform matching against</param>
+        /// <param name="itemToMatch">The string to perform matching against.</param>
+        /// <param name="itemType">The type of the item to perform matching against.</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, EvaluationContext evaluationContext)
         {
@@ -1004,7 +1004,7 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemT
         }
 
         /// <summary>
-        /// Overload of <see cref="GetItemProvenance(string)"/>
+        /// Overload of <see cref="GetItemProvenance(string)"/>.
         /// </summary>
         /// <param name="item">
         /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
@@ -1017,7 +1017,7 @@ public List<ProvenanceResult> GetItemProvenance(ProjectItem item)
         }
 
         /// <summary>
-        /// See <see cref="GetItemProvenance(ProjectItem)"/>
+        /// See <see cref="GetItemProvenance(ProjectItem)"/>.
         /// </summary>
         /// <param name="item">
         /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
@@ -1026,7 +1026,7 @@ public List<ProvenanceResult> GetItemProvenance(ProjectItem item)
         /// </param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<ProvenanceResult> GetItemProvenance(ProjectItem item, EvaluationContext evaluationContext)
         {
@@ -1065,7 +1065,7 @@ public static string GetMetadataValueEscaped(ProjectItemDefinition item, string
         }
 
         /// <summary>
-        /// Get the escaped value of the provided property
+        /// Get the escaped value of the provided property.
         /// </summary>
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IProperty is an internal interface; this is less confusing to outside customers. ")]
         public static string GetPropertyValueEscaped(ProjectProperty property)
@@ -1087,7 +1087,7 @@ public IEnumerable<ProjectElement> GetLogicalProject()
 
         /// <summary>
         /// Get any property in the project that has the specified name,
-        /// otherwise returns null
+        /// otherwise returns null.
         /// </summary>
         [DebuggerStepThrough]
         public ProjectProperty GetProperty(string name)
@@ -1318,7 +1318,7 @@ public string ExpandString(string unexpandedValue)
         /// This instance can be used to build independently.
         /// Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
         /// </summary>
-        /// <returns>the created project instance</returns>
+        /// <returns>The created project instance.</returns>
         public ProjectInstance CreateProjectInstance()
         {
             return CreateProjectInstance(ProjectInstanceSettings.None, null);
@@ -1331,19 +1331,19 @@ public ProjectInstance CreateProjectInstance()
         /// The instance is immutable; none of the objects that form it can be modified. This makes it safe to
         /// access concurrently from multiple threads.
         /// </summary>
-        /// <param name="settings">The project instance creation settings</param>
-        /// <returns>the created project instance</returns>
+        /// <param name="settings">The project instance creation settings.</param>
+        /// <returns>the created project instance.</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         {
             return CreateProjectInstance(settings, null);
         }
 
         /// <summary>
-        /// See <see cref="CreateProjectInstance(ProjectInstanceSettings)"/>
+        /// See <see cref="CreateProjectInstance(ProjectInstanceSettings)"/>.
         /// </summary>
-        /// <param name="settings">The project instance creation settings</param>
-        /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
-        /// <returns>the created project instance</returns>
+        /// <param name="settings">The project instance creation settings.</param>
+        /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
+        /// <returns>the created project instance.</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
         {
             return implementation.CreateProjectInstance(settings, evaluationContext);
@@ -1374,9 +1374,9 @@ public void ReevaluateIfNecessary()
         }
 
         /// <summary>
-        /// See <see cref="ReevaluateIfNecessary()"/>
+        /// See <see cref="ReevaluateIfNecessary()"/>.
         /// </summary>
-        /// <param name="evaluationContext">The <see cref="EvaluationContext"/> to use. See <see cref="EvaluationContext"/></param>
+        /// <param name="evaluationContext">The <see cref="EvaluationContext"/> to use. See <see cref="EvaluationContext"/>.</param>
         public void ReevaluateIfNecessary(EvaluationContext evaluationContext)
         {
             implementation.ReevaluateIfNecessary(evaluationContext);
@@ -1442,6 +1442,7 @@ public void SaveLogicalProject(TextWriter writer)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build()
         {
             return Build((string[])null);
@@ -1454,6 +1455,8 @@ public bool Build()
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="logger">Logger to use.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(ILogger logger)
         {
             var loggers = new List<ILogger>(1) { logger };
@@ -1467,6 +1470,8 @@ public bool Build(ILogger logger)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="loggers">List of loggers.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(IEnumerable<ILogger> loggers)
         {
             return Build((string[])null, loggers, null);
@@ -1479,6 +1484,9 @@ public bool Build(IEnumerable<ILogger> loggers)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="loggers">List of loggers.</param>
+        /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
             return Build((string[])null, loggers, remoteLoggers);
@@ -1491,6 +1499,8 @@ public bool Build(IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerReco
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="target">Target to build.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string target)
         {
             return Build(target, null, null);
@@ -1503,6 +1513,9 @@ public bool Build(string target)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="target">Target to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string target, IEnumerable<ILogger> loggers)
         {
             return Build(target, loggers, null);
@@ -1515,6 +1528,10 @@ public bool Build(string target, IEnumerable<ILogger> loggers)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="target">Target to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string target, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
             // targets may be null, but not an entry within it
@@ -1530,6 +1547,8 @@ public bool Build(string target, IEnumerable<ILogger> loggers, IEnumerable<Forwa
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="targets">Targets to build.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string[] targets)
         {
             return Build(targets, null, null);
@@ -1543,6 +1562,9 @@ public bool Build(string[] targets)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="targets">Targets to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string[] targets, IEnumerable<ILogger> loggers)
         {
             return Build(targets, loggers, null);
@@ -1556,18 +1578,23 @@ public bool Build(string[] targets, IEnumerable<ILogger> loggers)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="targets">Targets to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
             return Build(targets, loggers, remoteLoggers, null);
         }
 
         /// <summary>
-        /// See <see cref="Build(string[], IEnumerable&lt;ILogger&gt;, IEnumerable&lt;ForwardingLoggerRecord&gt;)"/>
+        /// See <see cref="Build(string[], IEnumerable&lt;ILogger&gt;, IEnumerable&lt;ForwardingLoggerRecord&gt;)"/>.
         /// </summary>
-        /// <param name="targets"></param>
-        /// <param name="loggers"></param>
-        /// <param name="remoteLoggers"></param>
-        /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+        /// <param name="targets">Targets to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+        /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
         {
             return implementation.Build(targets, loggers, remoteLoggers, evaluationContext);
@@ -1744,7 +1771,7 @@ internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml
         }
 
         /// <summary>
-        /// Internal project evaluation implementation
+        /// Internal project evaluation implementation.
         /// </summary>
         private class ProjectImpl : ProjectLink, IProjectLinkInternal
         {
@@ -1799,13 +1826,13 @@ private class ProjectImpl : ProjectLink, IProjectLinkInternal
             /// <summary>
             ///
             /// </summary>
-            /// <param name="owner">The owning project object</param>
-            /// <param name="xml">ProjectRootElement to use</param>
+            /// <param name="owner">The owning project object.</param>
+            /// <param name="xml">ProjectRootElement to use.</param>
             /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-            /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+            /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
             /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
@@ -1823,13 +1850,13 @@ public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, st
             /// Throws InvalidProjectFileException if the evaluation fails.
             /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
             /// </summary>
-            /// <param name="owner">The owning project object</param>
-            /// <param name="xmlReader">Xml reader to read project from</param>
+            /// <param name="owner">The owning project object.</param>
+            /// <param name="xmlReader">Xml reader to read project from.</param>
             /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-            /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+            /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
             /// <param name="loadSettings">The load settings for this project.</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(xmlReader, nameof(xmlReader));
@@ -1858,13 +1885,13 @@ public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, strin
             /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
             /// May throw IO-related exceptions.
             /// </summary>
-            /// <param name="owner">The owning project object</param>
-            /// <param name="projectFile">The project file</param>
+            /// <param name="owner">The owning project object.</param>
+            /// <param name="projectFile">The project file.</param>
             /// <param name="globalProperties">The global properties. May be null.</param>
             /// <param name="toolsVersion">The tools version. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
             /// <param name="loadSettings">The load settings for this project.</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             public ProjectImpl(Project owner, string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
@@ -1956,7 +1983,7 @@ public bool IsZombified
 
             /// <summary>
             /// The backing Xml project.
-            /// Can never be null
+            /// Can never be null.
             /// </summary>
             /// <remarks>
             /// There is no setter here as that doesn't make sense. If you have a new ProjectRootElement, evaluate it into a new Project.
@@ -2064,7 +2091,7 @@ public override IDictionary<string, string> GlobalProperties
             /// </summary>
             /// <comments>
             /// data.ItemTypes is a KeyCollection, so it doesn't need any
-            /// additional read-only protection
+            /// additional read-only protection.
             /// </comments>
             public override ICollection<string> ItemTypes => _data.ItemTypes;
 
@@ -2106,12 +2133,12 @@ public override IDictionary<string, List<string>> ConditionedProperties
 
             /// <summary>
             /// Read-only dictionary of item definitions in this project.
-            /// Keyed by item type
+            /// Keyed by item type.
             /// </summary>
             public override IDictionary<string, ProjectItemDefinition> ItemDefinitions => _data.ItemDefinitions;
 
             /// <summary>
-            /// Items in this project, ordered within groups of item types
+            /// Items in this project, ordered within groups of item types.
             /// </summary>
             [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
             public override ICollection<ProjectItem> Items => new ReadOnlyCollection<ProjectItem>(_data.Items);
@@ -2388,21 +2415,21 @@ public override bool IsBuildEnabled
             public override int LastEvaluationId => _data.EvaluationId;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable
+            /// List of names of the properties that, while global, are still treated as overridable.
             /// </summary>
             public ISet<string> GlobalPropertiesToTreatAsLocal => _data.GlobalPropertiesToTreatAsLocal;
 
             /// <summary>
-            /// The logging service used for evaluation errors
+            /// The logging service used for evaluation errors.
             /// </summary>
             internal ILoggingService LoggingService => ProjectCollection.LoggingService;
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetAllGlobs(EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetAllGlobs(EvaluationContext)"/>.
             /// </summary>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext)
             {
@@ -2410,12 +2437,12 @@ public override List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetAllGlobs(string, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetAllGlobs(string, EvaluationContext)"/>.
             /// </summary>
             /// <param name="itemType">The type of items to return.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluationContext)
             {
@@ -2591,12 +2618,12 @@ private void CacheInformationFromRemoveItem(ProjectItemElement itemElement, Dict
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetItemProvenance(string, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetItemProvenance(string, EvaluationContext)"/>.
             /// </summary>
-            /// <param name="itemToMatch">The string to perform matching against</param>
+            /// <param name="itemToMatch">The string to perform matching against.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, EvaluationContext evaluationContext)
             {
@@ -2604,13 +2631,13 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, Eva
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetItemProvenance(string, string, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetItemProvenance(string, string, EvaluationContext)"/>.
             /// </summary>
-            /// <param name="itemToMatch">The string to perform matching against</param>
+            /// <param name="itemToMatch">The string to perform matching against.</param>
             /// <param name="itemType">The type of items to return.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, EvaluationContext evaluationContext)
             {
@@ -2618,7 +2645,7 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, str
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetItemProvenance(ProjectItem, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetItemProvenance(ProjectItem, EvaluationContext)"/>.
             /// </summary>
             /// /// <param name="item"> 
             /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
@@ -2627,7 +2654,7 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, str
             /// </param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<ProvenanceResult> GetItemProvenance(ProjectItem item, EvaluationContext evaluationContext)
             {
@@ -2721,6 +2748,13 @@ ProvenanceResult SingleItemSpecProvenance(string itemSpec, IElementLocation elem
                     SingleItemSpecProvenance(itemElement.Exclude, itemElement.ExcludeLocation, Operation.Exclude) ?? result;
             }
 
+            /// <summary>
+            /// Since:
+            ///     - we have no proper AST and interpreter for itemspecs that we can do analysis on
+            ///     - GetItemProvenance needs to have correct counts for exclude strings (as correct as it can get while doing it after evaluation)
+            ///
+            /// The temporary hack is to use the expander to expand the strings, and if any property or item references were encountered, return Provenance.Inconclusive.
+            /// </summary>
             private static int ItemMatchesInItemSpec(string itemToMatch, EvaluationItemSpec itemSpec, out Provenance provenance)
             {
                 provenance = Provenance.Undefined;
@@ -2790,7 +2824,7 @@ public override IEnumerable<ProjectElement> GetLogicalProject()
 
             /// <summary>
             /// Get any property in the project that has the specified name,
-            /// otherwise returns null
+            /// otherwise returns null.
             /// </summary>
             [DebuggerStepThrough]
             public override ProjectProperty GetProperty(string name)
@@ -3170,10 +3204,10 @@ public override string ExpandString(string unexpandedValue)
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.CreateProjectInstance(ProjectInstanceSettings, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.CreateProjectInstance(ProjectInstanceSettings, EvaluationContext)"/>.
             /// </summary>
-            /// <param name="settings">Project instance creation settings</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="settings">Project instance creation settings.</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             /// <returns></returns>
             public override ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
             {
@@ -3201,9 +3235,9 @@ public override void MarkDirty()
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.ReevaluateIfNecessary"/>
+            /// See <see cref="ProjectLink.ReevaluateIfNecessary"/>.
             /// </summary>
-            /// <param name="evaluationContext">The <see cref="EvaluationContext"/> to use. See <see cref="EvaluationContext"/></param>
+            /// <param name="evaluationContext">The <see cref="EvaluationContext"/> to use. See <see cref="EvaluationContext"/>.</param>
             public override void ReevaluateIfNecessary(EvaluationContext evaluationContext)
             {
                 ReevaluateIfNecessary(LoggingService, evaluationContext);
@@ -3225,12 +3259,12 @@ public override void SaveLogicalProject(TextWriter writer)
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.Build"/>
+            /// See <see cref="ProjectLink.Build"/>.
             /// </summary>
-            /// <param name="targets">targets to build</param>
-            /// <param name="loggers">List of loggers</param>
-            /// <param name="remoteLoggers">remote loggers for multi proc logging</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="targets">Targets to build.</param>
+            /// <param name="loggers">List of loggers.</param>
+            /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
             {
                 if (!IsBuildEnabled)
@@ -3897,7 +3931,7 @@ internal class Data : IItemProvider<ProjectItem>, IPropertyProvider<ProjectPrope
             private static WeakReference<RetrievableEntryHashSet<ProjectTargetInstance>> s_typicalTargetsCollection;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable
+            /// List of names of the properties that, while global, are still treated as overridable.
             /// </summary>
             private ISet<string> _globalPropertiesToTreatAsLocal;
 
@@ -3917,14 +3951,14 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Whether evaluation should collect items ignoring condition,
             /// as well as items respecting condition; and collect
-            /// conditioned properties, as well as regular properties
+            /// conditioned properties, as well as regular properties.
             /// </summary>
             public bool ShouldEvaluateForDesignTime => true;
 
             public bool CanEvaluateElementsWithFalseConditions { get; }
 
             /// <summary>
-            /// Collection of all evaluated item definitions, one per item-type
+            /// Collection of all evaluated item definitions, one per item-type.
             /// </summary>
             IEnumerable<ProjectItemDefinition> IEvaluatorData<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.ItemDefinitionsEnumerable => ItemDefinitions.Values;
 
@@ -3948,7 +3982,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => this.Project.ProjectCollection.EnvironmentProperties;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable
+            /// List of names of the properties that, while global, are still treated as overridable.
             /// </summary>
             public ISet<string> GlobalPropertiesToTreatAsLocal => _globalPropertiesToTreatAsLocal ?? (_globalPropertiesToTreatAsLocal =
                                                                       new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default));
@@ -4040,12 +4074,12 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             public int EvaluationId { get; set; } = BuildEventContext.InvalidEvaluationId;
 
             /// <summary>
-            /// The root directory for this project
+            /// The root directory for this project.
             /// </summary>
             public string Directory => Project.DirectoryPath;
 
             /// <summary>
-            /// Registry of usingtasks, for build
+            /// Registry of usingtasks, for build.
             /// </summary>
             public TaskRegistry TaskRegistry { get; set; }
 
@@ -4055,7 +4089,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// </summary>
             /// <comments>
             /// item.ItemTypes is a KeyCollection, so it doesn't need any
-            /// additional read-only protection
+            /// additional read-only protection.
             /// </comments>
             public ICollection<string> ItemTypes => Items.ItemTypes;
 
@@ -4099,17 +4133,17 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             internal bool HasUnsavedChanges { get; set; }
 
             /// <summary>
-            /// Collection of all evaluated item definitions, one per item-type
+            /// Collection of all evaluated item definitions, one per item-type.
             /// </summary>
             internal RetrievableEntryHashSet<ProjectItemDefinition> ItemDefinitions { get; private set; }
 
             /// <summary>
-            /// Project that owns this data
+            /// Project that owns this data.
             /// </summary>
             internal Project Project { get; }
 
             /// <summary>
-            /// Targets in the project, used to build
+            /// Targets in the project, used to build.
             /// </summary>
             internal RetrievableEntryHashSet<ProjectTargetInstance> Targets { get; set; }
 
@@ -4126,7 +4160,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             internal List<ResolvedImport> ImportClosureWithDuplicates { get; private set; }
 
             /// <summary>
-            /// The toolsversion that was originally specified on the project's root element
+            /// The toolsversion that was originally specified on the project's root element.
             /// </summary>
             internal string OriginalProjectToolsVersion { get; private set; }
 
@@ -4254,7 +4288,7 @@ public void AddItem(ProjectItem item)
             }
 
             /// <summary>
-            /// Adds a new item to the collection of all items ignoring condition
+            /// Adds a new item to the collection of all items ignoring condition.
             /// </summary>
             public void AddItemIgnoringCondition(ProjectItem item)
             {
@@ -4298,7 +4332,7 @@ public void AddToAllEvaluatedItemsList(ProjectItem item)
             }
 
             /// <summary>
-            /// Adds a new item definition
+            /// Adds a new item definition.
             /// </summary>
             public IItemDefinition<ProjectMetadata> AddItemDefinition(string itemType)
             {
@@ -4438,7 +4472,7 @@ public ICollection<ProjectItem> GetItems(string itemType)
             #region IPropertyProvider<ProjectProperty> Members
 
             /// <summary>
-            /// Returns the property with the specified name or null if it was not present
+            /// Returns the property with the specified name or null if it was not present.
             /// </summary>
             /// <param name="name">The property name.</param>
             /// <returns>The property.</returns>
@@ -4448,7 +4482,7 @@ public ProjectProperty GetProperty(string name)
             }
 
             /// <summary>
-            /// Returns the property with the specified name or null if it was not present
+            /// Returns the property with the specified name or null if it was not present.
             /// </summary>
             /// <returns>The property.</returns>
             public ProjectProperty GetProperty(string name, int startIndex, int endIndex)
@@ -4549,7 +4583,7 @@ public class GlobResult
         public IEnumerable<string> Removes { get; set; }
 
         /// <summary>
-        /// Constructor
+        /// Constructor.
         /// </summary>
         public GlobResult(ProjectItemElement itemElement, IEnumerable<string> includeGlobStrings, IMSBuildGlob globWithGaps, IEnumerable<string> excludeFragmentStrings, IEnumerable<string> removeFragmentStrings)
         {
@@ -4591,7 +4625,7 @@ public enum Provenance
     }
 
     /// <summary>
-    /// Enum that specifies how an item element references an item
+    /// Enum that specifies how an item element references an item.
     /// </summary>
     public enum Operation
     {
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index a8e6b32e4a3..df1a9b1629e 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -49,7 +49,7 @@ internal ProjectProperty(Project project, string evaluatedValueEscaped)
             _evaluatedValueEscaped = evaluatedValueEscaped;
         }
 
-        internal virtual string EvaluatedValueEscapedIntenral => _evaluatedValueEscaped;
+        internal virtual string EvaluatedValueEscapedInternal => _evaluatedValueEscaped;
 
         /// <summary>
         /// Name of the property.
@@ -79,7 +79,7 @@ public string EvaluatedValue
         {
             [DebuggerStepThrough]
             get
-            { return EscapingUtilities.UnescapeAll(EvaluatedValueEscapedIntenral); }
+            { return EscapingUtilities.UnescapeAll(EvaluatedValueEscapedInternal); }
         }
 
         /// <summary>
@@ -94,7 +94,7 @@ public string EvaluatedValue
         string IProperty.EvaluatedValueEscaped
         {
             [DebuggerStepThrough]
-            get => EvaluatedValueEscapedIntenral;
+            get => EvaluatedValueEscapedInternal;
         }
 
         /// <summary>
@@ -201,7 +201,7 @@ string IKeyed.Key
         string IValued.EscapedValue
         {
             [DebuggerStepThrough]
-            get => EvaluatedValueEscapedIntenral;
+            get => EvaluatedValueEscapedInternal;
         }
 
         #region IEquatable<ProjectProperty> Members
@@ -225,7 +225,7 @@ bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
 
             return _project == other._project &&
                    Xml == other.Xml &&
-                   EvaluatedValueEscapedIntenral == other.EvaluatedValueEscapedIntenral &&
+                   EvaluatedValueEscapedInternal == other.EvaluatedValueEscapedInternal &&
                    Name == other.Name;
         }
 
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 4ab5024acf5..95510fe146f 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -616,7 +616,7 @@ private void Evaluate()
 
                 _logProjectImportedEvents = Traits.Instance.EscapeHatches.LogProjectImports;
 
-                ICollection<P> globalProperties;
+                int globalPropertiesCount;
 
                 using (_evaluationProfiler.TrackPass(EvaluationPass.InitialProperties))
                 {
@@ -626,7 +626,7 @@ private void Evaluate()
                     AddBuiltInProperties();
                     AddEnvironmentProperties();
                     AddToolsetProperties();
-                    globalProperties = AddGlobalProperties();
+                    globalPropertiesCount = AddGlobalProperties();
 
                     if (_interactive)
                     {
@@ -652,7 +652,7 @@ private void Evaluate()
                 List<string> initialTargets = new List<string>(_initialTargetsList.Count);
                 foreach (var initialTarget in _initialTargetsList)
                 {
-                    initialTargets.Add(EscapingUtilities.UnescapeAll(initialTarget.Trim()));
+                    initialTargets.Add(EscapingUtilities.UnescapeAll(initialTarget, trim: true));
                 }
 
                 _data.InitialTargets = initialTargets;
@@ -789,7 +789,7 @@ private void Evaluate()
 
                             string line = new string('#', 100) + "\n";
 
-                            string output = String.Format(CultureInfo.CurrentUICulture, "###: MSBUILD: Evaluating or reevaluating project {0} with {1} global properties and {2} tools version, child count {3}, CurrentSolutionConfigurationContents hash {4} other properties:\n{5}", _projectRootElement.FullPath, globalProperties.Count, _data.Toolset.ToolsVersion, _projectRootElement.Count, hash, propertyDump);
+                            string output = String.Format(CultureInfo.CurrentUICulture, "###: MSBUILD: Evaluating or reevaluating project {0} with {1} global properties and {2} tools version, child count {3}, CurrentSolutionConfigurationContents hash {4} other properties:\n{5}", _projectRootElement.FullPath, globalPropertiesCount, _data.Toolset.ToolsVersion, _projectRootElement.Count, hash, propertyDump);
 
                             Trace.WriteLine(line + output + line);
                         }
@@ -919,7 +919,7 @@ private void UpdateDefaultTargets(ProjectRootElement currentProjectOrImport)
 
                     for (int i = 0; i < temp.Count; i++)
                     {
-                        string target = EscapingUtilities.UnescapeAll(temp[i].Trim());
+                        string target = EscapingUtilities.UnescapeAll(temp[i], trim: true);
                         if (target.Length > 0)
                         {
                             _data.DefaultTargets ??= new List<string>(temp.Count);
@@ -1085,106 +1085,87 @@ private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement,
         /// <summary>
         /// Set the built-in properties, most of which are read-only
         /// </summary>
-        private ICollection<P> AddBuiltInProperties()
+        private void AddBuiltInProperties()
         {
             string startupDirectory = BuildParameters.StartupDirectory;
 
-            List<P> builtInProperties = new List<P>(19);
-
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.toolsVersion, _data.Toolset.ToolsVersion));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.toolsPath, _data.Toolset.ToolsPath));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.binPath, _data.Toolset.ToolsPath));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.startupDirectory, startupDirectory));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.buildNodeCount, _maxNodeCount.ToString(CultureInfo.CurrentCulture)));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.programFiles32, FrameworkLocationHelper.programFiles32));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild));
+            SetBuiltInProperty(ReservedPropertyNames.toolsVersion, _data.Toolset.ToolsVersion);
+            SetBuiltInProperty(ReservedPropertyNames.toolsPath, _data.Toolset.ToolsPath);
+            SetBuiltInProperty(ReservedPropertyNames.binPath, _data.Toolset.ToolsPath);
+            SetBuiltInProperty(ReservedPropertyNames.startupDirectory, startupDirectory);
+            SetBuiltInProperty(ReservedPropertyNames.buildNodeCount, _maxNodeCount.ToString(CultureInfo.CurrentCulture));
+            SetBuiltInProperty(ReservedPropertyNames.programFiles32, FrameworkLocationHelper.programFiles32);
+            SetBuiltInProperty(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion);
+            SetBuiltInProperty(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild);
 
             // Fake OS env variables when not on Windows
             if (!NativeMethodsShared.IsWindows)
             {
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.osName, NativeMethodsShared.OSName));
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.frameworkToolsRoot, NativeMethodsShared.FrameworkBasePath));
+                SetBuiltInProperty(ReservedPropertyNames.osName, NativeMethodsShared.OSName);
+                SetBuiltInProperty(ReservedPropertyNames.frameworkToolsRoot, NativeMethodsShared.FrameworkBasePath);
             }
 
 #if RUNTIME_TYPE_NETCORE
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType, "Core"));
+            SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType, "Core");
 #elif MONO
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType,
-                                                        NativeMethodsShared.IsMono ? "Mono" : "Full"));
+            SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType,
+                                                        NativeMethodsShared.IsMono ? "Mono" : "Full");
 #else
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType, "Full"));
+            SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType, "Full");
 #endif
 
             if (String.IsNullOrEmpty(_projectRootElement.FullPath))
             {
-                // If this is an un-saved project, this is as far as we can go
-                if (String.IsNullOrEmpty(_projectRootElement.DirectoryPath))
-                {
-                    builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectDirectory, startupDirectory));
-                }
-                else
-                {
+                SetBuiltInProperty(ReservedPropertyNames.projectDirectory, String.IsNullOrEmpty(_projectRootElement.DirectoryPath) ?
+                    // If this is an un-saved project, this is as far as we can go
+                    startupDirectory :
                     // Solution files based on the old OM end up here.  But they do have a location, which is where the solution was loaded from.
                     // We need to set this here otherwise we can't locate any projects the solution refers to.
-                    builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectDirectory, _projectRootElement.DirectoryPath));
-                }
+                    _projectRootElement.DirectoryPath);
             }
             else
             {
                 // Add the MSBuildProjectXXXXX properties, but not the MSBuildFileXXXX ones. Those
                 // vary according to the file they're evaluated in, so they have to be dealt with
                 // specially in the Expander.
-                string projectFile = EscapingUtilities.Escape(Path.GetFileName(_projectRootElement.FullPath));
                 string projectFileWithoutExtension = EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(_projectRootElement.FullPath));
                 string projectExtension = EscapingUtilities.Escape(Path.GetExtension(_projectRootElement.FullPath));
-                string projectFullPath = EscapingUtilities.Escape(_projectRootElement.FullPath);
+                string projectFile = projectFileWithoutExtension + projectExtension;
                 string projectDirectory = EscapingUtilities.Escape(_projectRootElement.DirectoryPath);
+                string projectFullPath = Path.Combine(projectDirectory, projectFile);
 
                 int rootLength = Path.GetPathRoot(projectDirectory).Length;
-                string projectDirectoryNoRoot = projectDirectory.Substring(rootLength);
-                projectDirectoryNoRoot = FileUtilities.EnsureNoTrailingSlash(projectDirectoryNoRoot);
-                projectDirectoryNoRoot = EscapingUtilities.Escape(FileUtilities.EnsureNoLeadingSlash(projectDirectoryNoRoot));
+                string projectDirectoryNoRoot = FileUtilities.EnsureNoLeadingOrTrailingSlash(projectDirectory, rootLength);
 
                 // ReservedPropertyNames.projectDefaultTargets is already set
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectFile, projectFile));
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectName, projectFileWithoutExtension));
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectExtension, projectExtension));
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectFullPath, projectFullPath));
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectDirectory, projectDirectory));
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectDirectoryNoRoot, projectDirectoryNoRoot));
+                SetBuiltInProperty(ReservedPropertyNames.projectFile, projectFile);
+                SetBuiltInProperty(ReservedPropertyNames.projectName, projectFileWithoutExtension);
+                SetBuiltInProperty(ReservedPropertyNames.projectExtension, projectExtension);
+                SetBuiltInProperty(ReservedPropertyNames.projectFullPath, projectFullPath);
+                SetBuiltInProperty(ReservedPropertyNames.projectDirectory, projectDirectory);
+                SetBuiltInProperty(ReservedPropertyNames.projectDirectoryNoRoot, projectDirectoryNoRoot);
             }
-
-            return builtInProperties;
         }
 
         /// <summary>
         /// Pull in all the environment into our property bag
         /// </summary>
-        private ICollection<P> AddEnvironmentProperties()
+        private void AddEnvironmentProperties()
         {
-            List<P> environmentPropertiesList = new List<P>(_environmentProperties.Count);
-
             foreach (ProjectPropertyInstance environmentProperty in _environmentProperties)
             {
-                P property = _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true);
-                environmentPropertiesList.Add(property);
+                _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true);
             }
-
-            return environmentPropertiesList;
         }
 
         /// <summary>
         /// Put all the toolset's properties into our property bag
         /// </summary>
-        private ICollection<P> AddToolsetProperties()
+        private void AddToolsetProperties()
         {
-            List<P> toolsetProperties = new List<P>(_data.Toolset.Properties.Count);
-
             foreach (ProjectPropertyInstance toolsetProperty in _data.Toolset.Properties.Values)
             {
-                P property = _data.SetProperty(toolsetProperty.Name, ((IProperty)toolsetProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */);
-                toolsetProperties.Add(property);
+                _data.SetProperty(toolsetProperty.Name, ((IProperty)toolsetProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */);
             }
 
             if (_data.SubToolsetVersion == null)
@@ -1193,55 +1174,46 @@ private ICollection<P> AddToolsetProperties()
                 // is most likely not a subtoolset now, we need to add VisualStudioVersion if its not already a property.
                 if (!_data.Properties.Contains(Constants.VisualStudioVersionPropertyName))
                 {
-                    P subToolsetVersionProperty = _data.SetProperty(Constants.VisualStudioVersionPropertyName, MSBuildConstants.CurrentVisualStudioVersion, false /* NOT global property */, false /* may NOT be a reserved name */);
-                    toolsetProperties.Add(subToolsetVersionProperty);
+                    _data.SetProperty(Constants.VisualStudioVersionPropertyName, MSBuildConstants.CurrentVisualStudioVersion, false /* NOT global property */, false /* may NOT be a reserved name */);
                 }
             }
             else
             {
-
                 // Make the subtoolset version itself available as a property -- but only if it's not already set. 
                 // Because some people may be depending on this value even if there isn't a matching sub-toolset,
                 // set the property even if there is no matching sub-toolset.  
                 if (!_data.Properties.Contains(Constants.SubToolsetVersionPropertyName))
                 {
-                    P subToolsetVersionProperty = _data.SetProperty(Constants.SubToolsetVersionPropertyName, _data.SubToolsetVersion, false /* NOT global property */, false /* may NOT be a reserved name */);
-                    toolsetProperties.Add(subToolsetVersionProperty);
+                     _data.SetProperty(Constants.SubToolsetVersionPropertyName, _data.SubToolsetVersion, false /* NOT global property */, false /* may NOT be a reserved name */);
                 }
 
-                SubToolset subToolset;
-                if (_data.Toolset.SubToolsets.TryGetValue(_data.SubToolsetVersion, out subToolset))
+                if (_data.Toolset.SubToolsets.TryGetValue(_data.SubToolsetVersion, out SubToolset subToolset))
                 {
                     foreach (ProjectPropertyInstance subToolsetProperty in subToolset.Properties.Values)
                     {
-                        P property = _data.SetProperty(subToolsetProperty.Name, ((IProperty)subToolsetProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */);
-                        toolsetProperties.Add(property);
+                        _data.SetProperty(subToolsetProperty.Name, ((IProperty)subToolsetProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */);
                     }
                 }
             }
 
-            return toolsetProperties;
         }
 
         /// <summary>
         /// Put all the global properties into our property bag
         /// </summary>
-        private ICollection<P> AddGlobalProperties()
+        private int AddGlobalProperties()
         {
             if (_data.GlobalPropertiesDictionary == null)
             {
-                return Array.Empty<P>();
+                return 0;
             }
 
-            List<P> globalProperties = new List<P>(_data.GlobalPropertiesDictionary.Count);
-
             foreach (ProjectPropertyInstance globalProperty in _data.GlobalPropertiesDictionary)
             {
-                P property = _data.SetProperty(globalProperty.Name, ((IProperty)globalProperty).EvaluatedValueEscaped, true /* IS global property */, false /* may NOT be a reserved name */);
-                globalProperties.Add(property);
+                _data.SetProperty(globalProperty.Name, ((IProperty)globalProperty).EvaluatedValueEscaped, true /* IS global property */, false /* may NOT be a reserved name */);
             }
 
-            return globalProperties;
+            return _data.GlobalPropertiesDictionary.Count;
         }
 
         /// <summary>
@@ -2510,7 +2482,7 @@ private void SetAllProjectsProperty()
             {
                 P oldValue = _data.GetProperty(Constants.MSBuildAllProjectsPropertyName);
                 string streamImports = string.Join(";", _streamImports.ToArray());
-                P newValue = _data.SetProperty(
+                _data.SetProperty(
                     Constants.MSBuildAllProjectsPropertyName,
                     oldValue == null
                         ? $"{_lastModifiedProject.FullPath}{streamImports}"
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 18ea640140f..dfcbdf19be8 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -118,7 +118,7 @@ internal enum ExpanderOptions
     /// Requires the caller to have previously provided the necessary material for the expansion requested.
     /// For example, if the caller requests ExpanderOptions.ExpandItems, the Expander will throw if it was not given items.
     /// </remarks>
-    /// <typeparam name="P">Type of the properties used</typeparam>
+    /// <typeparam name="P">Type of the properties used.</typeparam>
     /// <typeparam name="I">Type of the items used.</typeparam>
     internal class Expander<P, I>
         where P : class, IProperty
@@ -140,7 +140,7 @@ internal class Expander<P, I>
 
         /// <summary>
         /// Those characters which indicate that an expression may contain expandable
-        /// expressions
+        /// expressions.
         /// </summary>
         private static char[] s_expandableChars = { '$', '%', '@' };
 
@@ -151,22 +151,22 @@ internal class Expander<P, I>
         private static CompareInfo s_invariantCompareInfo = CultureInfo.InvariantCulture.CompareInfo;
 
         /// <summary>
-        /// Properties to draw on for expansion
+        /// Properties to draw on for expansion.
         /// </summary>
         private IPropertyProvider<P> _properties;
 
         /// <summary>
-        /// Items to draw on for expansion
+        /// Items to draw on for expansion.
         /// </summary>
         private IItemProvider<I> _items;
 
         /// <summary>
-        /// Metadata to draw on for expansion
+        /// Metadata to draw on for expansion.
         /// </summary>
         private IMetadataTable _metadata;
 
         /// <summary>
-        /// Set of properties which are null during expansion
+        /// Set of properties which are null during expansion.
         /// </summary>
         private UsedUninitializedProperties _usedUninitializedProperties;
 
@@ -235,7 +235,7 @@ internal UsedUninitializedProperties UsedUninitializedProperties
 
         /// <summary>
         /// Tests to see if the expression may contain expandable expressions, i.e.
-        /// contains $, % or @
+        /// contains $, % or @.
         /// </summary>
         internal static bool ExpressionMayContainExpandableExpressions(string expression)
         {
@@ -292,7 +292,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
 
         /// <summary>
         /// Used only for unit tests. Expands the property expression (including any metadata expressions) and returns
-        /// the result typed (i.e. not converted into a string if the result is a function return)
+        /// the result typed (i.e. not converted into a string if the result is a function return).
         /// </summary>
         internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
@@ -340,7 +340,7 @@ internal IList<TaskItem> ExpandIntoTaskItemsLeaveEscaped(string expression, Expa
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
-        /// <typeparam name="T">Type of items to return</typeparam>
+        /// <typeparam name="T">Type of items to return.</typeparam>
         internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory<I, T> itemFactory, ExpanderOptions options, IElementLocation elementLocation)
             where T : class, IItem
         {
@@ -413,7 +413,7 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
         /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not 
         /// have an item type set on it, it will be given the item type of the item vector to use.
         /// </summary>
-        /// <typeparam name="T">Type of the items that should be returned</typeparam>
+        /// <typeparam name="T">Type of the items that should be returned.</typeparam>
         internal IList<T> ExpandSingleItemVectorExpressionIntoItems<T>(string expression, IItemFactory<I, T> itemFactory, ExpanderOptions options, bool includeNullItems, out bool isTransformExpression, IElementLocation elementLocation)
             where T : class, IItem
         {
@@ -456,7 +456,7 @@ internal bool ExpandExpressionCapture(
         }
 
         /// <summary>
-        /// Returns true if the supplied string contains a valid property name
+        /// Returns true if the supplied string contains a valid property name.
         /// </summary>
         private static bool IsValidPropertyName(string propertyName)
         {
@@ -477,7 +477,7 @@ private static bool IsValidPropertyName(string propertyName)
         }
 
         /// <summary>
-        /// Returns true if ExpanderOptions.Truncate is set and EscapeHatches.DoNotTruncateConditions is not set
+        /// Returns true if ExpanderOptions.Truncate is set and EscapeHatches.DoNotTruncateConditions is not set.
         /// </summary>
         private static bool IsTruncationEnabled(ExpanderOptions options)
         {
@@ -503,7 +503,7 @@ private static int ScanForClosingParenthesis(string expression, int index)
         /// Takes the expression and the index to start at.
         /// Returns the index of the matching parenthesis, or -1 if it was not found.
         /// Also returns flags to indicate if a propertyfunction or registry property is likely
-        /// to be found in the expression
+        /// to be found in the expression.
         /// </summary>
         private static int ScanForClosingParenthesis(string expression, int index, out bool potentialPropertyFunction, out bool potentialRegistryFunction)
         {
@@ -561,7 +561,7 @@ private static int ScanForClosingParenthesis(string expression, int index, out b
         }
 
         /// <summary>
-        /// Skip all characters until we find the matching quote character
+        /// Skip all characters until we find the matching quote character.
         /// </summary>
         private static int ScanForClosingQuote(char quoteChar, string expression, int index)
         {
@@ -587,7 +587,7 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in
 
         /// <summary>
         /// Add the argument in the StringBuilder to the arguments list, handling nulls
-        /// appropriately
+        /// appropriately.
         /// </summary>
         private static void AddArgument(List<string> arguments, ReuseableStringBuilder argumentBuilder)
         {
@@ -722,12 +722,12 @@ private static class MetadataExpander
         {
             /// <summary>
             /// Expands all embedded item metadata in the given string, using the bucketed items.
-            /// Metadata may be qualified, like %(Compile.WarningLevel), or unqualified, like %(Compile)
+            /// Metadata may be qualified, like %(Compile.WarningLevel), or unqualified, like %(Compile).
             /// </summary>
-            /// <param name="expression">The expression containing item metadata references</param>
-            /// <param name="metadata"></param>
-            /// <param name="options"></param>
-            /// <param name="elementLocation"></param>
+            /// <param name="expression">The expression containing item metadata references.</param>
+            /// <param name="metadata">The metadata to be expanded.</param>
+            /// <param name="options">Used to specify what to expand.</param>
+            /// <param name="elementLocation">The location information for error reporting purposes.</param>
             /// <returns>The string with item metadata expanded in-place, escaped.</returns>
             internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTable metadata, ExpanderOptions options, IElementLocation elementLocation)
             {
@@ -738,11 +738,6 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                         return expression;
                     }
 
-                    if (expression.Length == 0)
-                    {
-                        return expression;
-                    }
-
                     ErrorUtilities.VerifyThrow(metadata != null, "Cannot expand metadata without providing metadata");
 
                     // PERF NOTE: Regex matching is expensive, so if the string doesn't contain any item metadata references, just bail
@@ -848,7 +843,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
             private class MetadataMatchEvaluator
             {
                 /// <summary>
-                /// Source of the metadata
+                /// Source of the metadata.
                 /// </summary>
                 private IMetadataTable _metadata;
 
@@ -858,7 +853,7 @@ private class MetadataMatchEvaluator
                 private ExpanderOptions _options;
 
                 /// <summary>
-                /// Constructor taking a source of metadata
+                /// Constructor taking a source of metadata.
                 /// </summary>
                 internal MetadataMatchEvaluator(IMetadataTable metadata, ExpanderOptions options)
                 {
@@ -907,13 +902,13 @@ internal string ExpandSingleMetadata(Match itemMetadataMatch)
         }
 
         /// <summary>
-        /// Expands property expressions, like $(Configuration) and $(Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation)
+        /// Expands property expressions, like $(Configuration) and $(Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation).
         /// </summary>
         /// <remarks>
         /// This is a private nested class, exposed only through the Expander class.
         /// That allows it to hide its private methods even from Expander.
         /// </remarks>
-        /// <typeparam name="T">Type of the properties used to expand the expression</typeparam>
+        /// <typeparam name="T">Type of the properties used to expand the expression.</typeparam>
         private static class PropertyExpander<T>
             where T : class, IProperty
         {
@@ -1184,7 +1179,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
             }
 
             /// <summary>
-            /// Expand the body of the property, including any functions that it may contain
+            /// Expand the body of the property, including any functions that it may contain.
             /// </summary>
             internal static object ExpandPropertyBody(
                 string propertyBody,
@@ -1304,7 +1299,7 @@ internal static object ExpandPropertyBody(
             /// <summary>
             /// Convert the object into an MSBuild friendly string
             /// Arrays are supported.
-            /// Will not return NULL
+            /// Will not return NULL.
             /// </summary>
             internal static string ConvertToString(object valueToConvert)
             {
@@ -1379,7 +1374,7 @@ internal static string ConvertToString(object valueToConvert)
             }
 
             /// <summary>
-            /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo)
+            /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
             {
@@ -1387,7 +1382,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
             }
 
             /// <summary>
-            /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo)
+            /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
             {
@@ -1487,10 +1482,7 @@ private static object ExpandMSBuildThisFileProperty(string propertyName, IElemen
                 {
                     string directory = Path.GetDirectoryName(elementLocation.File);
                     int rootLength = Path.GetPathRoot(directory).Length;
-                    string directoryNoRoot = directory.Substring(rootLength);
-                    directoryNoRoot = FileUtilities.EnsureTrailingSlash(directoryNoRoot);
-                    directoryNoRoot = FileUtilities.EnsureNoLeadingSlash(directoryNoRoot);
-                    value = directoryNoRoot;
+                    value = FileUtilities.EnsureTrailingNoLeadingSlash(directory, rootLength);
                 }
 
                 return value;
@@ -1629,7 +1621,7 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
         /// 
         ///     "my list: @(files -> 'temp\%(Filename).xml', ' ')   expands to string      "my list: temp\a.xml temp\b.xml"
         /// 
-        ///     "my list: @(files->'')                              expands to string      "my list: ;"
+        ///     "my list: @(files->'')                              expands to string      "my list: ;".
         /// </summary>
         /// <remarks>
         /// This is a private nested class, exposed only through the Expander class.
@@ -1638,9 +1630,9 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
         private static class ItemExpander
         {
             /// <summary>
-            /// Execute the list of transform functions
+            /// Execute the list of transform functions.
             /// </summary>
-            /// <typeparam name="S">class, IItem</typeparam>
+            /// <typeparam name="S">class, IItem.</typeparam>
             internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expander, bool includeNullEntries, Stack<TransformFunction<S>> transformFunctionStack, IEnumerable<Pair<string, S>> itemsOfType)
                 where S : class, IItem
             {
@@ -1687,8 +1679,8 @@ internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expande
             /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not 
             /// have an item type set on it, it will be given the item type of the item vector to use.
             /// </summary>
-            /// <typeparam name="S">Type of the items provided by the item source used for expansion</typeparam>
-            /// <typeparam name="T">Type of the items that should be returned</typeparam>
+            /// <typeparam name="S">Type of the items provided by the item source used for expansion.</typeparam>
+            /// <typeparam name="T">Type of the items that should be returned.</typeparam>
             internal static IList<T> ExpandSingleItemVectorExpressionIntoItems<S, T>(
                     Expander<P, I> expander, string expression, IItemProvider<S> items, IItemFactory<S, T> itemFactory, ExpanderOptions options,
                     bool includeNullEntries, out bool isTransformExpression, IElementLocation elementLocation)
@@ -1843,15 +1835,15 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
             /// Item1 represents the item string, escaped
             /// Item2 represents the original item.
             /// 
-            /// Item1 differs from Item2's string when it is coming from a transform
+            /// Item1 differs from Item2's string when it is coming from a transform.
             /// 
             /// </param>
-            /// <param name="expander">The expander whose state will be used to expand any transforms</param>
-            /// <param name="expressionCapture">The <see cref="ExpandSingleItemVectorExpressionIntoExpressionCapture"/> representing the structure of an item expression</param>
-            /// <param name="evaluatedItems"><see cref="IItemProvider{T}"/> to provide the inital items (which may get subsequently transformed, if <paramref name="expressionCapture"/> is a transform expression)></param>
-            /// <param name="elementLocation">Location of the xml element containing the <paramref name="expressionCapture"/></param>
-            /// <param name="options">expander options</param>
-            /// <param name="includeNullEntries">Wether to include items that evaluated to empty / null</param>
+            /// <param name="expander">The expander whose state will be used to expand any transforms.</param>
+            /// <param name="expressionCapture">The <see cref="ExpandSingleItemVectorExpressionIntoExpressionCapture"/> representing the structure of an item expression.</param>
+            /// <param name="evaluatedItems"><see cref="IItemProvider{T}"/> to provide the inital items (which may get subsequently transformed, if <paramref name="expressionCapture"/> is a transform expression)>.</param>
+            /// <param name="elementLocation">Location of the xml element containing the <paramref name="expressionCapture"/>.</param>
+            /// <param name="options">expander options.</param>
+            /// <param name="includeNullEntries">Wether to include items that evaluated to empty / null.</param>
             internal static bool ExpandExpressionCapture<S>(
                 Expander<P, I> expander,
                 ExpressionShredder.ItemExpressionCapture expressionCapture,
@@ -1934,11 +1926,11 @@ out List<Pair<string, S>> itemsFromCapture
             /// If the expression is empty, returns empty string.
             /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
             /// </summary>
-            /// <typeparam name="T">Type of the items provided</typeparam>
+            /// <typeparam name="T">Type of the items provided.</typeparam>
             internal static string ExpandItemVectorsIntoString<T>(Expander<P, I> expander, string expression, IItemProvider<T> items, ExpanderOptions options, IElementLocation elementLocation)
                 where T : class, IItem
             {
-                if (((options & ExpanderOptions.ExpandItems) == 0) || (expression.Length == 0))
+                if ((options & ExpanderOptions.ExpandItems) == 0 || expression.Length == 0)
                 {
                     return expression;
                 }
@@ -1987,9 +1979,9 @@ internal static string ExpandItemVectorsIntoString<T>(Expander<P, I> expander, s
             }
 
             /// <summary>
-            /// Prepare the stack of transforms that will be executed on a given set of items
+            /// Prepare the stack of transforms that will be executed on a given set of items.
             /// </summary>
-            /// <typeparam name="S">class, IItem</typeparam>
+            /// <typeparam name="S">class, IItem.</typeparam>
             private static Stack<TransformFunction<S>> PrepareTransformStackFromMatch<S>(IElementLocation elementLocation, ExpressionShredder.ItemExpressionCapture match)
                 where S : class, IItem
             {
@@ -2033,7 +2025,7 @@ private static Stack<TransformFunction<S>> PrepareTransformStackFromMatch<S>(IEl
             /// Expand the match provided into a string, and append that to the provided string builder.
             /// Returns true if ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and so it broke out early.
             /// </summary>
-            /// <typeparam name="S">Type of source items</typeparam>
+            /// <typeparam name="S">Type of source items.</typeparam>
             private static bool ExpandExpressionCaptureIntoStringBuilder<S>(
                 Expander<P, I> expander,
                 ExpressionShredder.ItemExpressionCapture capture,
@@ -2091,26 +2083,26 @@ ExpanderOptions options
             }
 
             /// <summary>
-            /// The set of functions that called during an item transformation, e.g. @(CLCompile->ContainsMetadata('MetaName', 'metaValue'))
+            /// The set of functions that called during an item transformation, e.g. @(CLCompile->ContainsMetadata('MetaName', 'metaValue')).
             /// </summary>
-            /// <typeparam name="S">class, IItem</typeparam>
+            /// <typeparam name="S">class, IItem.</typeparam>
             internal static class IntrinsicItemFunctions<S>
                 where S : class, IItem
             {
                 /// <summary>
-                /// A cache of previously created item function delegates
+                /// A cache of previously created item function delegates.
                 /// </summary>
                 private static ConcurrentDictionary<string, ItemTransformFunction> s_transformFunctionDelegateCache = new ConcurrentDictionary<string, ItemTransformFunction>(StringComparer.OrdinalIgnoreCase);
 
                 /// <summary>
                 /// Delegate that represents the signature of all item transformation functions
-                /// This is used to support calling the functions by name
+                /// This is used to support calling the functions by name.
                 /// </summary>
                 public delegate IEnumerable<Pair<string, S>> ItemTransformFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments);
 
                 /// <summary>
                 /// Get a delegate to the given item transformation function by supplying the name and the
-                /// Item type that should be used
+                /// Item type that should be used.
                 /// </summary>
                 internal static ItemTransformFunction GetItemTransformFunction(IElementLocation elementLocation, string functionName, Type itemType)
                 {
@@ -2167,7 +2159,7 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation
 
                 /// <summary>
                 /// Create an enumerator from a base IEnumerable of items into an enumerable
-                /// of transformation result which includes the new itemspec and the base item
+                /// of transformation result which includes the new itemspec and the base item.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType)
                 {
@@ -2194,7 +2186,7 @@ var resultantItem in
                 }
 
                 /// <summary>
-                /// Intrinsic function that returns the number of items in the list
+                /// Intrinsic function that returns the number of items in the list.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Count(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2203,7 +2195,7 @@ internal static IEnumerable<Pair<string, S>> Count(Expander<P, I> expander, IEle
 
                 /// <summary>
                 /// Intrinsic function that returns the specified built-in modifer value of the items in itemsOfType
-                /// Tuple is {current item include, item under transformation}
+                /// Tuple is {current item include, item under transformation}.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2470,7 +2462,7 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                 }
 
                 /// <summary>
-                /// Intrinsic function that returns the contents of the metadata in specified in argument[0]
+                /// Intrinsic function that returns the contents of the metadata in specified in argument[0].
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2527,7 +2519,7 @@ internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, I
 
                 /// <summary>
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
-                /// Using a case sensitive comparison
+                /// Using a case sensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> DistinctWithCase(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2536,7 +2528,7 @@ internal static IEnumerable<Pair<string, S>> DistinctWithCase(Expander<P, I> exp
 
                 /// <summary>
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2545,7 +2537,7 @@ internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, I
 
                 /// <summary>
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> DistinctWithComparer(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments, StringComparer comparer)
                 {
@@ -2578,7 +2570,7 @@ internal static IEnumerable<Pair<string, S>> Reverse(Expander<P, I> expander, IE
                 }
 
                 /// <summary>
-                /// Intrinsic function that transforms expressions like the %(foo) in @(Compile->'%(foo)')
+                /// Intrinsic function that transforms expressions like the %(foo) in @(Compile->'%(foo)').
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2618,7 +2610,7 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
 
                 /// <summary>
                 /// Intrinsic function that transforms expressions by invoking methods of System.String on the itemspec
-                /// of the item in the pipeline
+                /// of the item in the pipeline.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                     Expander<P, I> expander,
@@ -2660,7 +2652,7 @@ internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                 }
 
                 /// <summary>
-                /// Intrinsic function that returns the items from itemsOfType with their metadata cleared, i.e. only the itemspec is retained
+                /// Intrinsic function that returns the items from itemsOfType with their metadata cleared, i.e. only the itemspec is retained.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2677,7 +2669,7 @@ internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expand
 
                 /// <summary>
                 /// Intrinsic function that returns only those items that have a not-blank value for the metadata specified
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2714,7 +2706,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
 
                 /// <summary>
                 /// Intrinsic function that returns only those items have the given metadata value
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2750,7 +2742,7 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
 
                 /// <summary>
                 /// Intrinsic function that returns a boolean to indicate if any of the items have the given metadata value
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2801,34 +2793,34 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
             }
 
             /// <summary>
-            /// Represents all the components of a transform function, including the ability to execute it 
+            /// Represents all the components of a transform function, including the ability to execute it. 
             /// </summary>
-            /// <typeparam name="S">class, IItem</typeparam>
+            /// <typeparam name="S">class, IItem.</typeparam>
             internal class TransformFunction<S>
                 where S : class, IItem
             {
                 /// <summary>
-                /// The delegate that points to the transform function
+                /// The delegate that points to the transform function.
                 /// </summary>
                 private IntrinsicItemFunctions<S>.ItemTransformFunction _transform;
 
                 /// <summary>
-                /// Arguments to pass to the transform function as parsed out of the project file
+                /// Arguments to pass to the transform function as parsed out of the project file.
                 /// </summary>
                 private string[] _arguments;
 
                 /// <summary>
-                /// The element location of the transform expression
+                /// The element location of the transform expression.
                 /// </summary>
                 private IElementLocation _elementLocation;
 
                 /// <summary>
-                /// The name of the function that this class will call
+                /// The name of the function that this class will call.
                 /// </summary>
                 private string _functionName;
 
                 /// <summary>
-                /// TransformFunction constructor
+                /// TransformFunction constructor.
                 /// </summary>
                 public TransformFunction(IElementLocation elementLocation, string functionName, IntrinsicItemFunctions<S>.ItemTransformFunction transform, string[] arguments)
                 {
@@ -2839,7 +2831,7 @@ public TransformFunction(IElementLocation elementLocation, string functionName,
                 }
 
                 /// <summary>
-                /// Arguments to pass to the transform function as parsed out of the project file
+                /// Arguments to pass to the transform function as parsed out of the project file.
                 /// </summary>
                 public string[] Arguments
                 {
@@ -2847,7 +2839,7 @@ public string[] Arguments
                 }
 
                 /// <summary>
-                /// The element location of the transform expression
+                /// The element location of the transform expression.
                 /// </summary>
                 public IElementLocation ElementLocation
                 {
@@ -2855,7 +2847,7 @@ public IElementLocation ElementLocation
                 }
 
                 /// <summary>
-                /// Execute this transform function with the arguments contained within this TransformFunction instance
+                /// Execute this transform function with the arguments contained within this TransformFunction instance.
                 /// </summary>
                 public IEnumerable<Pair<string, S>> Execute(Expander<P, I> expander, bool includeNullEntries, IEnumerable<Pair<string, S>> itemsOfType)
                 {
@@ -2871,22 +2863,22 @@ public IEnumerable<Pair<string, S>> Execute(Expander<P, I> expander, bool includ
             private class MetadataMatchEvaluator
             {
                 /// <summary>
-                /// The current ItemSpec of the item being matched
+                /// The current ItemSpec of the item being matched.
                 /// </summary>
                 private string _itemSpec;
 
                 /// <summary>
-                /// Item used as the source of metadata
+                /// Item used as the source of metadata.
                 /// </summary>
                 private IItem _sourceOfMetadata;
 
                 /// <summary>
-                /// Location of the match
+                /// Location of the match.
                 /// </summary>
                 private IElementLocation _elementLocation;
 
                 /// <summary>
-                /// Constructor
+                /// Constructor.
                 /// </summary>
                 internal MetadataMatchEvaluator(string itemSpec, IItem sourceOfMetadata, IElementLocation elementLocation)
                 {
@@ -2898,7 +2890,7 @@ internal MetadataMatchEvaluator(string itemSpec, IItem sourceOfMetadata, IElemen
                 /// <summary>
                 /// Expands the metadata in the match provided into a string result.
                 /// The match is expected to be the content of a transform.
-                /// For example, representing "%(Filename.obj)" in the original expression "@(Compile->'%(Filename.obj)')"
+                /// For example, representing "%(Filename.obj)" in the original expression "@(Compile->'%(Filename.obj)')".
                 /// </summary>
                 internal string GetMetadataValueFromMatch(Match match)
                 {
@@ -2959,7 +2951,7 @@ private static class RegularExpressions
             internal const string NameGroup = "NAME";
 
             /// <summary>
-            /// Name of the group matching the prefix on a metadata expression, for example "Compile." in "%(Compile.Object)"
+            /// Name of the group matching the prefix on a metadata expression, for example "Compile." in "%(Compile.Object)".
             /// </summary>
             internal const string ItemSpecificationGroup = "ITEM_SPECIFICATION";
 
@@ -2969,9 +2961,9 @@ private static class RegularExpressions
             internal const string ItemTypeGroup = "ITEM_TYPE";
 
             /// <summary>
-            /// regular expression used to match item metadata references outside of item vector transforms
+            /// regular expression used to match item metadata references outside of item vector transforms.
             /// </summary>
-            /// <remarks>PERF WARNING: this Regex is complex and tends to run slowly</remarks>
+            /// <remarks>PERF WARNING: this Regex is complex and tends to run slowly.</remarks>
             internal static readonly Lazy<Regex> NonTransformItemMetadataPattern = new Lazy<Regex>(
                 () => new Regex
                     (
@@ -2990,12 +2982,12 @@ private static class RegularExpressions
             private const string ItemMetadataSpecification = @"%\(\s* (?<ITEM_SPECIFICATION>(?<ITEM_TYPE>" + ProjectWriter.itemTypeOrMetadataNameSpecification + @")\s*\.\s*)? (?<NAME>" + ProjectWriter.itemTypeOrMetadataNameSpecification + @") \s*\)";
 
             /// <summary>
-            /// description of an item vector with a transform, left hand side 
+            /// description of an item vector with a transform, left hand side. 
             /// </summary> 
             private const string ItemVectorWithTransformLHS = @"@\(\s*" + ProjectWriter.itemTypeOrMetadataNameSpecification + @"\s*->\s*'[^']*";
 
             /// <summary>
-            /// description of an item vector with a transform, right hand side 
+            /// description of an item vector with a transform, right hand side. 
             /// </summary> 
             private const string ItemVectorWithTransformRHS = @"[^']*'(\s*,\s*'[^']*')?\s*\)";
 
@@ -3008,37 +3000,37 @@ private struct FunctionBuilder<T>
             where T : class, IProperty
         {
             /// <summary>
-            /// The type of this function's receiver
+            /// The type of this function's receiver.
             /// </summary>
             public Type ReceiverType { get; set; }
 
             /// <summary>
-            /// The name of the function
+            /// The name of the function.
             /// </summary>
             public string Name { get; set; }
 
             /// <summary>
-            /// The arguments for the function
+            /// The arguments for the function.
             /// </summary>
             public string[] Arguments { get; set; }
 
             /// <summary>
-            /// The expression that this function is part of
+            /// The expression that this function is part of.
             /// </summary>
             public string Expression { get; set; }
 
             /// <summary>
-            /// The property name that this function is applied on
+            /// The property name that this function is applied on.
             /// </summary>
             public string Receiver { get; set; }
 
             /// <summary>
-            /// The binding flags that will be used during invocation of this function
+            /// The binding flags that will be used during invocation of this function.
             /// </summary>
             public BindingFlags BindingFlags { get; set; }
 
             /// <summary>
-            /// The remainder of the body once the function and arguments have been extracted
+            /// The remainder of the body once the function and arguments have been extracted.
             /// </summary>
             public string Remainder { get; set; }
 
@@ -3067,44 +3059,44 @@ internal Function<T> Build()
 
         /// <summary>
         /// This class represents the function as extracted from an expression
-        /// It is also responsible for executing the function
+        /// It is also responsible for executing the function.
         /// </summary>
-        /// <typeparam name="T">Type of the properties used to expand the expression</typeparam>
+        /// <typeparam name="T">Type of the properties used to expand the expression.</typeparam>
         private class Function<T>
             where T : class, IProperty
         {
             /// <summary>
-            /// The type of this function's receiver
+            /// The type of this function's receiver.
             /// </summary>
             private Type _receiverType;
 
             /// <summary>
-            /// The name of the function
+            /// The name of the function.
             /// </summary>
             private string _methodMethodName;
 
             /// <summary>
-            /// The arguments for the function
+            /// The arguments for the function.
             /// </summary>
             private string[] _arguments;
 
             /// <summary>
-            /// The expression that this function is part of
+            /// The expression that this function is part of.
             /// </summary>
             private string _expression;
 
             /// <summary>
-            /// The property name that this function is applied on
+            /// The property name that this function is applied on.
             /// </summary>
             private string _receiver;
 
             /// <summary>
-            /// The binding flags that will be used during invocation of this function
+            /// The binding flags that will be used during invocation of this function.
             /// </summary>
             private BindingFlags _bindingFlags;
 
             /// <summary>
-            /// The remainder of the body once the function and arguments have been extracted
+            /// The remainder of the body once the function and arguments have been extracted.
             /// </summary>
             private string _remainder;
 
@@ -3116,7 +3108,7 @@ private class Function<T>
             private IFileSystem _fileSystem;
 
             /// <summary>
-            /// Construct a function that will be executed during property evaluation
+            /// Construct a function that will be executed during property evaluation.
             /// </summary>
             internal Function(
                 Type receiverType,
@@ -3153,7 +3145,7 @@ internal Function(
             /// This accessor is used by the Expander
             /// Examples of expression root:
             ///     [System.Diagnostics.Process]::Start
-            ///     SomeMSBuildProperty
+            ///     SomeMSBuildProperty.
             /// </summary>
             internal string Receiver
             {
@@ -3161,7 +3153,7 @@ internal string Receiver
             }
 
             /// <summary>
-            /// Extract the function details from the given property function expression
+            /// Extract the function details from the given property function expression.
             /// </summary>
             internal static Function<T> ExtractPropertyFunction(
                 string expressionFunction,
@@ -3285,7 +3277,7 @@ internal static Function<T> ExtractPropertyFunction(
             }
 
             /// <summary>
-            /// Execute the function on the given instance
+            /// Execute the function on the given instance.
             /// </summary>
             internal object Execute(object objectInstance, IPropertyProvider<T> properties, ExpanderOptions options, IElementLocation elementLocation)
             {
@@ -3522,12 +3514,12 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
             /// bad for debugging experience and has a performance cost.
             /// A typical binding operation with exception can take ~1.500 ms; this call is ~0.050 ms
             /// (rough numbers just for comparison).
-            /// See https://github.com/Microsoft/msbuild/issues/2217
+            /// See https://github.com/Microsoft/msbuild/issues/2217.
             /// </summary>
-            /// <param name="returnVal">The value returned from the function call</param>
-            /// <param name="objectInstance">Object that the function is called on</param>
-            /// <param name="args">arguments</param>
-            /// <returns>True if the well known function call binding was successful</returns>
+            /// <param name="returnVal">The value returned from the function call.</param>
+            /// <param name="objectInstance">Object that the function is called on.</param>
+            /// <param name="args">arguments.</param>
+            /// <returns>True if the well known function call binding was successful.</returns>
             private bool TryExecuteWellKnownFunction(out object returnVal, object objectInstance, object[] args)
             {
                 returnVal = null;
@@ -4461,8 +4453,8 @@ private void LogFunctionCall(string fileName, object objectInstance, object[] ar
             /// <summary>
             /// Given a type name and method name, try to resolve the type.
             /// </summary>
-            /// <param name="typeName">May be full name or assembly qualified name</param>
-            /// <param name="simpleMethodName">simple name of the method</param>
+            /// <param name="typeName">May be full name or assembly qualified name.</param>
+            /// <param name="simpleMethodName">simple name of the method.</param>
             /// <returns></returns>
             private static Type GetTypeForStaticMethod(string typeName, string simpleMethodName)
             {
@@ -4552,7 +4544,7 @@ private static Type GetTypeForStaticMethod(string typeName, string simpleMethodN
             }
 
             /// <summary>
-            /// Gets the specified type using the namespace to guess the assembly that its in
+            /// Gets the specified type using the namespace to guess the assembly that its in.
             /// </summary>
             private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
             {
@@ -4592,7 +4584,7 @@ private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
             }
 
             /// <summary>
-            /// Get the specified type from the assembly partial name supplied
+            /// Get the specified type from the assembly partial name supplied.
             /// </summary>
             [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Reflection.Assembly.LoadWithPartialName", Justification = "Necessary since we don't have the full assembly name. ")]
             private static Type GetTypeFromAssembly(string typeName, string candidateAssemblyName)
@@ -4631,7 +4623,7 @@ private static Type GetTypeFromAssembly(string typeName, string candidateAssembl
 
             /// <summary>
             /// Extracts the name, arguments, binding flags, and invocation type for an indexer
-            /// Also extracts the remainder of the expression that is not part of this indexer
+            /// Also extracts the remainder of the expression that is not part of this indexer.
             /// </summary>
             private static void ConstructIndexerFunction(string expressionFunction, IElementLocation elementLocation, object propertyValue, int methodStartIndex, int indexerEndIndex, ref FunctionBuilder<T> functionBuilder)
             {
@@ -4674,7 +4666,7 @@ private static void ConstructIndexerFunction(string expressionFunction, IElement
 
             /// <summary>
             /// Extracts the name, arguments, binding flags, and invocation type for a static or instance function.
-            /// Also extracts the remainder of the expression that is not part of this function
+            /// Also extracts the remainder of the expression that is not part of this function.
             /// </summary>
             private static void ConstructFunction(IElementLocation elementLocation, string expressionFunction, int argumentStartIndex, int methodStartIndex, ref FunctionBuilder<T> functionBuilder)
             {
@@ -4785,7 +4777,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
 
             /// <summary>
             /// Coerce the arguments according to the parameter types
-            /// Will only return null if the coercion didn't work due to an InvalidCastException
+            /// Will only return null if the coercion didn't work due to an InvalidCastException.
             /// </summary>
             private static object[] CoerceArguments(object[] args, ParameterInfo[] parameters)
             {
@@ -5036,12 +5028,12 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
     }
 
     /// <summary>
-    /// This class wraps information about properties which have been used before they are initialized 
+    /// This class wraps information about properties which have been used before they are initialized. 
     /// </summary>
     internal class UsedUninitializedProperties
     {
         /// <summary>
-        /// This class wraps information about properties which have been used before they are initialized
+        /// This class wraps information about properties which have been used before they are initialized.
         /// </summary>
         internal UsedUninitializedProperties()
         {
@@ -5049,7 +5041,7 @@ internal UsedUninitializedProperties()
         }
 
         /// <summary>
-        /// Hash set of properties which have been used before being initialized
+        /// Hash set of properties which have been used before being initialized.
         /// </summary>
         internal IDictionary<string, IElementLocation> Properties
         {
@@ -5067,7 +5059,7 @@ internal bool Warn
         }
 
         /// <summary>
-        ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property
+        ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
         /// </summary>
         internal string CurrentlyEvaluatingPropertyElementName
         {
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 7c81f57ae2b..ba38ae601d5 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -4,11 +4,9 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Runtime.InteropServices.WindowsRuntime;
 using Microsoft.Build.Globbing;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.EscapingStringExtensions;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -473,7 +471,7 @@ public virtual IMSBuildGlob ToMSBuildGlob()
 
         protected virtual IMSBuildGlob CreateMsBuildGlob()
         {
-            return MSBuildGlob.Parse(ProjectDirectory, TextFragment.Unescape());
+            return MSBuildGlob.Parse(ProjectDirectory, EscapingUtilities.UnescapeAll(TextFragment));
         }
 
         private FileSpecMatcherTester CreateFileSpecMatcher()
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 58b2d1d661f..64df2a7402f 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -59,18 +59,14 @@ public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> ite
 
         private ImmutableList<I> GetItems(string itemType)
         {
-            LazyItemList itemList = GetItemList(itemType);
-            if (itemList == null)
-            {
-                return ImmutableList<I>.Empty;
-            }
-
-            return itemList.GetMatchedItems(ImmutableHashSet<string>.Empty);
+            return _itemLists.TryGetValue(itemType, out LazyItemList itemList) ?
+                itemList.GetMatchedItems(ImmutableHashSet<string>.Empty) :
+                ImmutableList<I>.Empty;
         }
 
         public bool EvaluateConditionWithCurrentState(ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions)
         {
-            return EvaluateCondition(element, expanderOptions, parserOptions, _expander, this);
+            return EvaluateCondition(element.Condition, element, expanderOptions, parserOptions, _expander, this);
         }
 
         private static bool EvaluateCondition(
@@ -108,17 +104,6 @@ LazyItemEvaluator<P, I, M, D> lazyEvaluator
             }
         }
 
-        private static bool EvaluateCondition(
-            ProjectElement element,
-            ExpanderOptions expanderOptions,
-            ParserOptions parserOptions,
-            Expander<P, I> expander,
-            LazyItemEvaluator<P, I, M, D> lazyEvaluator
-            )
-        {
-            return EvaluateCondition(element.Condition, element, expanderOptions, parserOptions, expander, lazyEvaluator);
-        }
-
         /// <summary>
         /// COMPAT: Whidbey used the "current project file/targets" directory for evaluating Import and PropertyGroup conditions
         /// Orcas broke this by using the current root project file for all conditions
@@ -417,21 +402,13 @@ public OperationBuilderWithMetadata(ProjectItemElement itemElement, bool conditi
 
         private void AddReferencedItemList(string itemType, IDictionary<string, LazyItemList> referencedItemLists)
         {
-            var itemList = GetItemList(itemType);
-            if (itemList != null)
+            if (_itemLists.TryGetValue(itemType, out LazyItemList itemList))
             {
                 itemList.MarkAsReferenced();
                 referencedItemLists[itemType] = itemList;
             }
         }
 
-        private LazyItemList GetItemList(string itemType)
-        {
-            LazyItemList ret;
-            _itemLists.TryGetValue(itemType, out ret);
-            return ret;
-        }
-
         public IEnumerable<ItemData> GetAllItemsDeferred()
         {
             return _itemLists.Values.SelectMany(itemList => itemList.GetItemData(ImmutableHashSet<string>.Empty))
@@ -459,7 +436,7 @@ public void ProcessItemElement(string rootDirectory, ProjectItemElement itemElem
                 ErrorUtilities.ThrowInternalErrorUnreachable();
             }
 
-            LazyItemList previousItemList = GetItemList(itemElement.ItemType);
+            _itemLists.TryGetValue(itemElement.ItemType, out LazyItemList previousItemList);
             LazyItemList newList = new LazyItemList(previousItemList, operation);
             _itemLists[itemElement.ItemType] = newList;
         }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index adbb3ba25c9..9ee6bfd61f3 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -124,7 +124,7 @@ public void Initialize(IEventSource eventSource)
 
                 if (CollectProjectImports != ProjectImportsCollectionMode.None)
                 {
-                    projectImportsCollector = new ProjectImportsCollector(FilePath);
+                    projectImportsCollector = new ProjectImportsCollector(FilePath, CollectProjectImports == ProjectImportsCollectionMode.ZipFile);
                 }
 
                 if (eventSource is IEventSource3 eventSource3)
@@ -175,20 +175,11 @@ public void Shutdown()
 
             if (projectImportsCollector != null)
             {
-                projectImportsCollector.Close();
-
                 if (CollectProjectImports == ProjectImportsCollectionMode.Embed)
                 {
-                    var archiveFilePath = projectImportsCollector.ArchiveFilePath;
-
-                    // It is possible that the archive couldn't be created for some reason.
-                    // Only embed it if it actually exists.
-                    if (FileSystems.Default.FileExists(archiveFilePath))
-                    {
-                        eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, File.ReadAllBytes(archiveFilePath));
-                        File.Delete(archiveFilePath);
-                    }
+                    eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, projectImportsCollector.GetAllBytes());
                 }
+                projectImportsCollector.Close();
 
                 projectImportsCollector = null;
             }
diff --git a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
index 2951f99c69d..59553953c79 100644
--- a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
+++ b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
@@ -15,10 +15,30 @@ namespace Microsoft.Build.Logging
     /// </summary>
     internal class ProjectImportsCollector
     {
-        private FileStream _fileStream;
+        private Stream _stream;
+        public byte[] GetAllBytes()
+        {
+            if (_stream == null)
+            {
+                return Array.Empty<byte>();
+            }
+            else if (ArchiveFilePath == null)
+            {
+                var stream = _stream as MemoryStream;
+                // Before we can use the zip archive, it must be closed.
+                Close(false);
+                return stream.ToArray();
+            }
+            else
+            {
+                Close();
+                return File.ReadAllBytes(ArchiveFilePath);
+            }
+        }
+
         private ZipArchive _zipArchive;
 
-        public string ArchiveFilePath { get; set; }
+        private string ArchiveFilePath { get; set; }
 
         /// <summary>
         /// Avoid visiting each file more than once.
@@ -28,29 +48,35 @@ internal class ProjectImportsCollector
         // this will form a chain of file write tasks, running sequentially on a background thread
         private Task _currentTask = Task.CompletedTask;
 
-        public ProjectImportsCollector(string logFilePath, string sourcesArchiveExtension = ".ProjectImports.zip")
+        public ProjectImportsCollector(string logFilePath, bool createFile, string sourcesArchiveExtension = ".ProjectImports.zip")
         {
-            ArchiveFilePath = Path.ChangeExtension(logFilePath, sourcesArchiveExtension);
-
             try
             {
-                _fileStream = new FileStream(ArchiveFilePath, FileMode.Create, FileAccess.ReadWrite, FileShare.Delete);
-                _zipArchive = new ZipArchive(_fileStream, ZipArchiveMode.Create);
+                if (createFile)
+                {
+                    ArchiveFilePath = Path.ChangeExtension(logFilePath, sourcesArchiveExtension);
+                    _stream = new FileStream(ArchiveFilePath, FileMode.Create, FileAccess.ReadWrite, FileShare.Delete);
+                }
+                else
+                {
+                    _stream = new MemoryStream();
+                }
+                _zipArchive = new ZipArchive(_stream, ZipArchiveMode.Create, true);
             }
             catch
             {
                 // For some reason we weren't able to create a file for the archive.
                 // Disable the file collector.
-                _fileStream = null;
+                _stream = null;
                 _zipArchive = null;
             }
         }
 
         public void AddFile(string filePath)
         {
-            if (filePath != null && _fileStream != null)
+            if (filePath != null && _stream != null)
             {
-                lock (_fileStream)
+                lock (_stream)
                 {
                     // enqueue the task to add a file and return quickly
                     // to avoid holding up the current thread
@@ -70,9 +96,9 @@ public void AddFile(string filePath)
 
         public void AddFileFromMemory(string filePath, string data)
         {
-            if (filePath != null && data != null && _fileStream != null)
+            if (filePath != null && data != null && _stream != null)
             {
-                lock (_fileStream)
+                lock (_stream)
                 {
                     // enqueue the task to add a file and return quickly
                     // to avoid holding up the current thread
@@ -169,7 +195,7 @@ private static string CalculateArchivePath(string filePath)
             return archivePath;
         }
 
-        public void Close()
+        public void Close(bool closeStream = true)
         {
             // wait for all pending file writes to complete
             _currentTask.Wait();
@@ -180,10 +206,10 @@ public void Close()
                 _zipArchive = null;
             }
 
-            if (_fileStream != null)
+            if (closeStream && (_stream != null))
             {
-                _fileStream.Dispose();
-                _fileStream = null;
+                _stream.Dispose();
+                _stream = null;
             }
         }
     }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 2f136f3ebf0..f29be042bac 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -699,9 +699,6 @@
     <Compile Include="..\Shared\ExceptionHandling.cs">
       <Link>SharedUtilities\ExceptionHandling.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\EscapingStringExtensions\EscapingStringExtensions.cs">
-      <Link>SharedUtilities\EscapingStringExtensions\EscapingStringExtensions.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\FileMatcher.cs">
       <Link>SharedUtilities\FileMatcher.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
index ee5c1263f3a..74fac4edbe2 100644
--- a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
+++ b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
@@ -68,7 +68,7 @@ public abstract class ProjectPropertyLink
         /// </summary>
         public static string GetEvaluatedValueEscaped(ProjectProperty property)
         {
-            return property.EvaluatedValueEscapedIntenral;
+            return property.EvaluatedValueEscapedInternal;
         }
     }
 }
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index 98ce259b750..2312e0d8be1 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -308,7 +308,7 @@ public override string UnevaluatedValue
 
             public override bool IsImported => Link.IsImported;
 
-            internal override string EvaluatedValueEscapedIntenral => Link.EvaluatedIncludeEscaped;
+            internal override string EvaluatedValueEscapedInternal => Link.EvaluatedIncludeEscaped;
         }
         #endregion
     }
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index b3c15748810..a58892f6c1b 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -167,7 +167,7 @@ private string[] GetFileList
                 // Unescape before handing it to the filesystem.
                 var directoryUnescaped = EscapingUtilities.UnescapeAll(directoryEscaped);
                 var filespecUnescaped = EscapingUtilities.UnescapeAll(filespecEscaped);
-                var excludeSpecsUnescaped = excludeSpecsEscaped.Where(IsValidExclude).Select(EscapingUtilities.UnescapeAll).ToList();
+                var excludeSpecsUnescaped = excludeSpecsEscaped.Where(IsValidExclude).Select(i => EscapingUtilities.UnescapeAll(i)).ToList();
 
                 // Get the list of actual files which match the filespec.  Put
                 // the list into a string array.  If the filespec started out
diff --git a/src/Build/Utilities/FileSpecMatchTester.cs b/src/Build/Utilities/FileSpecMatchTester.cs
index 725ef4752a2..c91234e397e 100644
--- a/src/Build/Utilities/FileSpecMatchTester.cs
+++ b/src/Build/Utilities/FileSpecMatchTester.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.EscapingStringExtensions;
 using System;
 using System.Diagnostics;
 using System.IO;
@@ -27,7 +26,7 @@ private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec,
 
         public static FileSpecMatcherTester Parse(string currentDirectory, string fileSpec)
         {
-            string unescapedFileSpec = fileSpec.Unescape();
+            string unescapedFileSpec = EscapingUtilities.UnescapeAll(fileSpec);
             Regex regex = EngineFileUtilities.FilespecHasWildcards(fileSpec) ? CreateRegex(unescapedFileSpec, currentDirectory) : null;
 
             return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, regex);
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 1e8dc5f827b..4810afd35e9 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -31,7 +31,7 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="Reference_FusionName" _locComment="" -->Fusion name of the assembly (optional)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="SpecificVersion">
+                            <xs:element name="SpecificVersion" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Reference_SpecificVersion" _locComment="" -->Whether only the version in the fusion name should be referenced (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -41,7 +41,7 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="Reference_Aliases" _locComment="" -->Aliases for the reference (optional)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="Private">
+                            <xs:element name="Private" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Reference_Private" _locComment="" -->Whether the reference should be copied to the output folder (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -133,7 +133,7 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="COMReference_WrapperTool" _locComment="" -->Wrapper tool, such as tlbimp</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="Isolated">
+                            <xs:element name="Isolated" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="COMReference_Isolated" _locComment="" -->Is it isolated (boolean)</xs:documentation>
                                 </xs:annotation>
@@ -703,7 +703,7 @@ elementFormDefault="qualified">
                         <xs:choice>
                             <xs:element name="SubType"/>
                             <xs:element name="DependentUpon"/>
-                            <xs:element name="AutoGen">
+                            <xs:element name="AutoGen" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Compile_AutoGen" _locComment="" -->Whether file was generated from another file (boolean)</xs:documentation>
                                 </xs:annotation>
@@ -715,7 +715,7 @@ elementFormDefault="qualified">
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="DesignTimeSharedInput"/>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Compile_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -764,7 +764,7 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="EmbeddedResource_Link" _locComment="" -->Notional path within project to display if the file is physically located outside of the project file's cone (optional)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="EmbeddedResource_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -813,18 +813,18 @@ elementFormDefault="qualified">
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="IsAssembly"/>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Content_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory">
+                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Content_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="CopyToPublishDirectory">
+                            <xs:element name="CopyToPublishDirectory" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Content_CopyToPublishDirectory" _locComment="" -->Copy file to publish directory (optional, boolean, default false)</xs:documentation>
                                 </xs:annotation>
@@ -865,7 +865,7 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory">
+                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Page_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
                                 </xs:annotation>
@@ -906,7 +906,7 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory">
+                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Resource_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
                                 </xs:annotation>
@@ -947,7 +947,7 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory">
+                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="ApplicationDefinition_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
                                 </xs:annotation>
@@ -980,7 +980,7 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="None_Link" _locComment="" -->Notional path within project to display if the file is physically located outside of the project file's cone (optional)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="None_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -1047,7 +1047,7 @@ elementFormDefault="qualified">
                 <xs:extension base="msb:SimpleItemType">
                     <xs:sequence minOccurs="0" maxOccurs="unbounded">
                         <xs:choice>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="FileAssociation_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -1067,7 +1067,7 @@ elementFormDefault="qualified">
                 <xs:extension base="msb:SimpleItemType">
                     <xs:sequence minOccurs="0" maxOccurs="unbounded">
                         <xs:choice>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="BootstrapperFile_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -1086,18 +1086,18 @@ elementFormDefault="qualified">
                 <xs:extension base="msb:SimpleItemType">
                     <xs:sequence minOccurs="0" maxOccurs="unbounded">
                         <xs:choice>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="PublishFile_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="Group"/>
-                            <xs:element name="IncludeHash">
+                            <xs:element name="IncludeHash" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="PublishFile_IncludeHash" _locComment="" -->(boolean)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="IsAssembly">
+                            <xs:element name="IsAssembly" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="PublishFile_IsAssembly" _locComment="" -->(boolean)</xs:documentation>
                                 </xs:annotation>
@@ -1158,6 +1158,18 @@ elementFormDefault="qualified">
     <xs:element name="MinimumVisualStudioVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="AdditionalFileItemNames" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="AllowUnsafeBlocks" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="AnalysisMode" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AnalysisMode" _locComment="" -->Customizes the set of rules that are enabled by default.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="Default" />
+          <xs:enumeration value="AllEnabledByDefault" />
+          <xs:enumeration value="AllDisabledByDefault" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
     <xs:element name="AppConfigForCompiler" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ApplicationIcon" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ApplicationRevision" type="msb:StringPropertyType" substitutionGroup="msb:Property">
@@ -1202,7 +1214,7 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="AutorunEnabled" _locComment="" -->Indicates whether BindingRedirect elements should be automatically generated for referenced assemblies.</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="AutorunEnabled" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="AutorunEnabled" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="AutorunEnabled" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1214,7 +1226,7 @@ elementFormDefault="qualified">
         </xs:annotation>
     </xs:element>
     <xs:element name="BootstrapperComponentsUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="BootstrapperEnabled" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="BootstrapperEnabled" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="BootstrapperEnabled" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1228,14 +1240,14 @@ elementFormDefault="qualified">
     <xs:element name="ConfigurationName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ConfigurationOverrideFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="CreateDesktopShortcut" type="msb:boolean" substitutionGroup="msb:Property" />
-    <xs:element name="CreateWebPageOnPublish" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="CreateWebPageOnPublish" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="CreateWebPageOnPublish" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
     </xs:element>
     <xs:element name="CurrentSolutionConfigurationContents" type="msb:GenericPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="DebugSecurityZoneURL" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="DebugSymbols" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="DebugSymbols" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="DebugSymbols" _locComment="" -->Whether to emit symbols (boolean)</xs:documentation>
         </xs:annotation>
@@ -1249,19 +1261,19 @@ elementFormDefault="qualified">
     <xs:element name="DefaultHTMLPageLayout" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="DefaultTargetSchema" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="DefineConstants" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="DefineDebug" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="DefineDebug" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="DefineDebug" _locComment="" -->Whether DEBUG is defined (boolean)</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="DefineTrace" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="DefineTrace" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="DefineTrace" _locComment="" -->Whether TRACE is defined (boolean)</xs:documentation>
         </xs:annotation>
     </xs:element>
     <xs:element name="DelaySign" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="DisableLangXtns" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="DisallowUrlActivation" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="DisallowUrlActivation" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="DisallowUrlActivation" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1501,6 +1513,11 @@ elementFormDefault="qualified">
     <xs:element name="EnableSQLServerDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="EnableSecurityDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="EnableUnmanagedDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="EnforceCodeStyleInBuild" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EnforceCodeStyleInBuild" _locComment="" -->Controls whether code style analysis rules configured as warnings or errors should execute on build and report violations. The default is false.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="ErrorLog" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ErrorReport" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="EmbedManifest" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1544,6 +1561,31 @@ elementFormDefault="qualified">
     <xs:element name="AnalysisLevel" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="InstallUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="IsCodeSharingProject" type="msb:boolean" substitutionGroup="msb:Property"/>
+    <xs:element name="IsPackable" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="IsPackable" _locComment="" -->Indicates whether the project can be used to create a NuGet package.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="EnableNETAnalyzers" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EnableNETAnalyzers" _locComment="" -->Indicates whether the .NET analyzers are enabled. They are enabled by default for projects that target .NET 5.0 or later.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="EnableDefaultCompileItems" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EnableDefaultCompileItems" _locComment="" -->Enable default Compile item globs for source files.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="EnableDefaultNoneItems" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EnableDefaultNoneItems" _locComment="" -->Enable default None item globs (which cover most files in the project not covered by other globs).</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="EnableDefaultItems" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EnableDefaultItems" _locComment="" -->Defaults to true, and if set to false will disable all default item globs.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="IsWebBootstrapper" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="JCPA" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="Keyword" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1554,7 +1596,7 @@ elementFormDefault="qualified">
     <xs:element name="LinkIncremental" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestCertificateThumbprint" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestKeyFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="MapFileExtensions" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="MapFileExtensions" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="MapFileExtensions" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1583,7 +1625,7 @@ elementFormDefault="qualified">
     </xs:element>
     <xs:element name="NoConfig" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="NoStandardLibraries" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="NoStdLib" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="NoStdLib" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="NoStdLib" _locComment="" -->Whether standard libraries (such as mscorlib) should be referenced automatically (boolean)</xs:documentation>
         </xs:annotation>
@@ -1597,12 +1639,12 @@ elementFormDefault="qualified">
     <xs:element name="OutDir" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="TargetExt" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="TargetName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="OpenBrowserOnPublish" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="OpenBrowserOnPublish" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="OpenBrowserOnPublish" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="Optimize" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="Optimize" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="Optimize" _locComment="" -->Should compiler optimize output (boolean)</xs:documentation>
         </xs:annotation>
@@ -1711,6 +1753,21 @@ elementFormDefault="qualified">
       </xs:annotation>
     </xs:element>
     <xs:element name="ResponseFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="RunAnalyzers" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="RunAnalyzers" _locComment="" -->Disables analyzers at both build and design time. This property takes precedence over RunAnalyzersDuringBuild and RunAnalyzersDuringLiveAnalysis. Default is true.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="RunAnalyzersDuringBuild" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="RunAnalyzersDuringBuild" _locComment="" -->Controls whether analyzers run at build time. Default is true.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="RunAnalyzersDuringLiveAnalysis" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="RunAnalyzersDuringLiveAnalysis" _locComment="" -->Controls whether analyzers analyze code live at design time. Default is true.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="RootNamespace" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="RuntimeIdentifier" type="msb:StringPropertyType" substitutionGroup="msb:Property">
       <xs:annotation>
@@ -1772,7 +1829,7 @@ elementFormDefault="qualified">
     <xs:element name="TargetPlatformMinVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="TargetZone" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="TreatWarningsAsErrors" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="TrustUrlParameters" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="TrustUrlParameters" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="TrustUrlParameters" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1780,7 +1837,7 @@ elementFormDefault="qualified">
     <xs:element name="TypeComplianceDiagnostics" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="UICulture" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="UpgradeBackupLocation" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="UpdateEnabled" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="UpdateEnabled" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="UpdateEnabled" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1796,12 +1853,12 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="UpdateMode" _locComment="" -->Foreground or Background</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="UpdatePeriodically" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="UpdatePeriodically" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="UpdatePeriodically" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="UpdateRequired" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="UpdateRequired" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="UpdateRequired" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -2562,6 +2619,7 @@ elementFormDefault="qualified">
                     <xs:attribute name="IconFile" />
                     <xs:attribute name="InputManifest" />
                     <xs:attribute name="IsolatedComReferences" />
+                    <xs:attribute name="LauncherBasedDeployment" type="msb:boolean" />
                     <xs:attribute name="ManifestType" />
                     <xs:attribute name="MaxTargetPath" />
                     <xs:attribute name="OSVersion" />
@@ -2621,6 +2679,7 @@ elementFormDefault="qualified">
                     <xs:attribute name="ErrorReportUrl" />
                     <xs:attribute name="InputManifest" />
                     <xs:attribute name="Install" type="msb:boolean" />
+                    <xs:attribute name="LauncherBasedDeployment" type="msb:boolean" />
                     <xs:attribute name="MapFileExtensions" type="msb:boolean" />
                     <xs:attribute name="MaxTargetPath" />
                     <xs:attribute name="MinimumRequiredVersion" />
@@ -2642,6 +2701,17 @@ elementFormDefault="qualified">
             </xs:complexContent>
         </xs:complexType>
     </xs:element>
+    <xs:element name="GenerateLauncher" substitutionGroup="msb:Task">
+        <xs:complexType>
+            <xs:complexContent>
+                <xs:extension base="msb:TaskType">
+                    <xs:attribute name="EntryPoint" />
+                    <xs:attribute name="OutputPath" />
+                    <xs:attribute name="VisualStudioVersion" />
+                </xs:extension>
+            </xs:complexContent>
+        </xs:complexType>
+    </xs:element>
     <xs:element name="GenerateResource" substitutionGroup="msb:Task">
         <xs:complexType>
             <xs:complexContent>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 0640d2d95e2..f19b82637ba 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1721,6 +1721,23 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman
                                 String.Equals(switchName, "maxcpucount", StringComparison.OrdinalIgnoreCase))
                             {
                                 int numberOfCpus = Environment.ProcessorCount;
+#if !MONO
+                                // .NET Core on Windows returns a core count limited to the current NUMA node
+                                //     https://github.com/dotnet/runtime/issues/29686
+                                // so always double-check it.
+                                if (NativeMethodsShared.IsWindows
+#if NETFRAMEWORK
+                                     // .NET Framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).
+                                     // So if we get a high core count on full framework, double-check it.
+                                     && (numberOfCpus >= 32)
+#endif
+                                    )
+                                {
+                                    var result = NativeMethodsShared.GetLogicalCoreCount();
+                                    if(result != -1)
+                                        numberOfCpus = result;
+                                }
+#endif
                                 switchParameters = ":" + numberOfCpus;
                             }
                             else if (String.Equals(switchName, "bl", StringComparison.OrdinalIgnoreCase) ||
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index d813b8deb3d..8449a0b7149 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -6,6 +6,7 @@ package name=Microsoft.Build
         vs.package.language=neutral
 
 vs.dependencies
+  vs.dependency id=Microsoft.Build.UnGAC
   vs.dependency id=Microsoft.VisualStudio.PackageGroup.NuGet
                 version=[15.0,17.0)
 
diff --git a/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj b/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj
new file mode 100644
index 00000000000..6282c3a2134
--- /dev/null
+++ b/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj
@@ -0,0 +1,29 @@
+ï»¿<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <!-- Setup runs on net45 and may not have installed newer yet. -->
+    <TargetFramework>net45</TargetFramework>
+    <!-- Set as an exe because this project publishes its own output. -->
+    <OutputType>Exe</OutputType>
+    <!-- Forcing the 'vsix' output to be json output. Workaround for https://github.com/dotnet/arcade/issues/6120 -->
+    <TargetVsixContainerName>Microsoft.Build.UnGAC.exe</TargetVsixContainerName>
+    <!-- VS Insertion -->
+    <VisualStudioInsertionComponent>Microsoft.Build.UnGAC</VisualStudioInsertionComponent>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <_SwixArgs Include="PackageType=manifest"/>
+    <!-- If we don't set TargetExt to .json, arcade defaults to generating a .vsix -->
+    <_SwixArgs Include="TargetExt=.json"/>
+  </ItemGroup>
+
+  <!-- SwrProperty is an arcade concept. -->
+  <ItemGroup>
+    <!-- BinDir is set via SwrProperty to be passed to the swr compiler. OutDir is the path to the bin folder. See exe.swr to see how this is used. -->
+    <SwrProperty Include="BinDir=$(OutDir)" />
+    <!-- Version must constantly update in order for our exe package to run on install and update. -->
+    <SwrProperty Include="Version=$(VsixVersion)" />
+
+    <!-- our swr file must be picked up, this is how we set that. -->
+    <SwrFile Include="exe.swr" Condition=" '$(MSBuildRuntimeType)' == 'Full' " />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src/Package/Microsoft.Build.UnGAC/NativeMethods.cs b/src/Package/Microsoft.Build.UnGAC/NativeMethods.cs
new file mode 100644
index 00000000000..f468942cf12
--- /dev/null
+++ b/src/Package/Microsoft.Build.UnGAC/NativeMethods.cs
@@ -0,0 +1,22 @@
+ï»¿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Runtime.InteropServices;
+
+namespace Microsoft.Build.UnGAC
+{
+    // See: https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/fusion/iassemblycache-interface
+    [ComImport, Guid("E707DCDE-D1CD-11D2-BAB9-00C04F8ECEAE"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
+    internal interface IAssemblyCache
+    {
+        [PreserveSig]
+        uint UninstallAssembly(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] string pszAssemblyName, IntPtr pRefData, ref ulong pulDisposition);
+    }
+
+    public static class NativeMethods
+    {
+        [DllImport("fusion.dll")]
+        internal static extern uint CreateAssemblyCache(out IAssemblyCache ppAsmCache, int dwReserved);
+    }
+}
diff --git a/src/Package/Microsoft.Build.UnGAC/Program.cs b/src/Package/Microsoft.Build.UnGAC/Program.cs
new file mode 100644
index 00000000000..c5b5caa710d
--- /dev/null
+++ b/src/Package/Microsoft.Build.UnGAC/Program.cs
@@ -0,0 +1,53 @@
+ï»¿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.Build.UnGAC
+{
+    /// <summary>
+    /// Original Issue: https://github.com/dotnet/msbuild/issues/5183
+    /// This tool was created to help prevent customers from putting MSBuild assemblies in the Global Assembly Cache.
+    /// It runs at VS install-time as well as repair-time.
+    /// It is intended to run as best effort. Meaning that if it fails, we avoid throwing and instead log it.
+    /// </summary>
+    class Program
+    {
+        static void Main(string[] args)
+        {
+            try
+            {
+                string[] assembliesToUnGAC =
+                {
+                    "Microsoft.Build, Version=15.1.0.0",
+                    "Microsoft.Build.Engine, Version=15.1.0.0",
+                    "Microsoft.Build.Framework, Version=15.1.0.0",
+                    "Microsoft.Build.Tasks.Core, Version=15.1.0.0",
+                    "Microsoft.Build.Utilities.Core, Version=15.1.0.0",
+                    "Microsoft.Build.Conversion.Core, Version=15.1.0.0"
+                };
+
+                uint hresult = NativeMethods.CreateAssemblyCache(out IAssemblyCache assemblyCache, 0);
+
+                // Most significant bit is set, meaning there was an error in the Hresult.
+                if ((hresult >> 31) == 1)
+                {
+                    Console.WriteLine($"Could not successfully call CreateAssemblyCache. HResult: {hresult}");
+                    Console.WriteLine("Exiting without removing assemblies from the GAC...");
+                    return;
+                }
+
+                foreach (string assembly in assembliesToUnGAC)
+                {
+                    hresult = assemblyCache.UninstallAssembly(dwFlags: 0, pszAssemblyName: assembly, pRefData: IntPtr.Zero, pulDisposition: 0);
+
+                    Console.WriteLine($"Tried to remove {assembly} from the GAC. HResult: 0x{hresult:X8}");
+                }
+            }
+            catch (Exception e)
+            {
+                Console.WriteLine($"Caught an exception! We don't want to throw because we want MSBuild to install.\n" + e.ToString());
+            }
+        }
+    }
+}
diff --git a/src/Package/Microsoft.Build.UnGAC/exe.swr b/src/Package/Microsoft.Build.UnGAC/exe.swr
new file mode 100644
index 00000000000..9a717021a50
--- /dev/null
+++ b/src/Package/Microsoft.Build.UnGAC/exe.swr
@@ -0,0 +1,19 @@
+use vs
+
+package name=Microsoft.Build.UnGAC
+        version=$(Version)
+        vs.package.type=exe
+        vs.package.chip=neutral
+        vs.package.language=neutral
+
+vs.installCommand fileName=[Payload]
+
+vs.repairCommand fileName=[Payload]
+
+vs.installSize
+  SystemDrive=0
+  TargetDrive=0
+  SharedDrive=0
+
+vs.payloads
+    vs.payload source=$(BinDir)Microsoft.Build.UnGAC.exe
diff --git a/src/Shared/EscapingStringExtensions/EscapingStringExtensions.cs b/src/Shared/EscapingStringExtensions/EscapingStringExtensions.cs
deleted file mode 100644
index ae749f47692..00000000000
--- a/src/Shared/EscapingStringExtensions/EscapingStringExtensions.cs
+++ /dev/null
@@ -1,34 +0,0 @@
-ï»¿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build.Shared.EscapingStringExtensions
-{
-    internal static class EscapingStringExtensions
-    {
-        internal static string Unescape(this string escapedString)
-        {
-            return EscapingUtilities.UnescapeAll(escapedString);
-        }
-
-        internal static string Unescape
-        (
-            this string escapedString,
-            out bool escapingWasNecessary
-        )
-        {
-            return EscapingUtilities.UnescapeAll(escapedString, out escapingWasNecessary);
-        }
-
-        internal static string Escape(this string unescapedString)
-        {
-            return EscapingUtilities.Escape(unescapedString);
-        }
-
-        internal static bool ContainsEscapedWildcards(this string escapedString)
-        {
-            return EscapingUtilities.ContainsEscapedWildcards(escapedString);
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/Shared/EscapingUtilities.cs b/src/Shared/EscapingUtilities.cs
index 965175bdbed..a8d86f06c31 100644
--- a/src/Shared/EscapingUtilities.cs
+++ b/src/Shared/EscapingUtilities.cs
@@ -24,20 +24,6 @@ static internal class EscapingUtilities
         /// </summary>
         private static Dictionary<string, string> s_unescapedToEscapedStrings = new Dictionary<string, string>(StringComparer.Ordinal);
 
-        /// <summary>
-        /// Replaces all instances of %XX in the input string with the character represented
-        /// by the hexadecimal number XX.
-        /// </summary>
-        /// <param name="escapedString">The string to unescape.</param>
-        /// <returns>unescaped string</returns>
-        internal static string UnescapeAll
-        (
-            string escapedString
-        )
-        {
-            return UnescapeAll(escapedString, out bool _);
-        }
-
         private static bool IsHexDigit(char character)
         {
             return ((character >= '0') && (character <= '9'))
@@ -50,16 +36,10 @@ private static bool IsHexDigit(char character)
         /// by the hexadecimal number XX.
         /// </summary>
         /// <param name="escapedString">The string to unescape.</param>
-        /// <param name="escapingWasNecessary">Whether any replacements were made.</param>
+        /// <param name="trim">If the string should be trimmed before being unescaped.</param>
         /// <returns>unescaped string</returns>
-        internal static string UnescapeAll
-        (
-            string escapedString,
-            out bool escapingWasNecessary
-        )
+        internal static string UnescapeAll(string escapedString, bool trim = false)
         {
-            escapingWasNecessary = false;
-
             // If the string doesn't contain anything, then by definition it doesn't
             // need unescaping.
             if (String.IsNullOrEmpty(escapedString))
@@ -72,13 +52,29 @@ out bool escapingWasNecessary
             int indexOfPercent = escapedString.IndexOf('%');
             if (indexOfPercent == -1)
             {
-                return escapedString;
+                return trim ? escapedString.Trim() : escapedString;
             }
 
             // This is where we're going to build up the final string to return to the caller.
             StringBuilder unescapedString = StringBuilderCache.Acquire(escapedString.Length);
 
             int currentPosition = 0;
+            int escapedStringLength = escapedString.Length;
+            if (trim)
+            {
+                while (currentPosition < escapedString.Length && Char.IsWhiteSpace(escapedString[currentPosition]))
+                {
+                    currentPosition++;
+                }
+                if (currentPosition == escapedString.Length)
+                {
+                    return String.Empty;
+                }
+                while (Char.IsWhiteSpace(escapedString[escapedStringLength - 1]))
+                {
+                    escapedStringLength--;
+                }
+            }
 
             // Loop until there are no more percent signs in the input string.
             while (indexOfPercent != -1)
@@ -86,7 +82,7 @@ out bool escapingWasNecessary
                 // There must be two hex characters following the percent sign
                 // for us to even consider doing anything with this.
                 if (
-                        (indexOfPercent <= (escapedString.Length - 3)) &&
+                        (indexOfPercent <= (escapedStringLength - 3)) &&
                         IsHexDigit(escapedString[indexOfPercent + 1]) &&
                         IsHexDigit(escapedString[indexOfPercent + 2])
                     )
@@ -106,8 +102,6 @@ out bool escapingWasNecessary
                     // Advance the current pointer to reflect the fact that the destination string
                     // is up to date with everything up to and including this escape code we just found.
                     currentPosition = indexOfPercent + 3;
-
-                    escapingWasNecessary = true;
                 }
 
                 // Find the next percent sign.
@@ -116,7 +110,7 @@ out bool escapingWasNecessary
 
             // Okay, there are no more percent signs in the input string, so just copy the remaining
             // characters into the destination.
-            unescapedString.Append(escapedString, currentPosition, escapedString.Length - currentPosition);
+            unescapedString.Append(escapedString, currentPosition, escapedStringLength - currentPosition);
 
             return StringBuilderCache.GetStringAndRelease(unescapedString);
         }
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index ca576a58036..6e6f789c2c1 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -187,7 +187,7 @@ internal static void ClearCacheDirectory()
         internal static string EnsureTrailingSlash(string fileSpec)
         {
             fileSpec = FixFilePath(fileSpec);
-            if (fileSpec.Length > 0 && !EndsWithSlash(fileSpec))
+            if (fileSpec.Length > 0 && !IsSlash(fileSpec[fileSpec.Length - 1]))
             {
                 fileSpec += Path.DirectorySeparatorChar;
             }
@@ -196,17 +196,37 @@ internal static string EnsureTrailingSlash(string fileSpec)
         }
 
         /// <summary>
-        /// Ensures the path does not have a leading slash.
+        /// Ensures the path does not have a leading or trailing slash after removing the first 'start' characters.
         /// </summary>
-        internal static string EnsureNoLeadingSlash(string path)
+        internal static string EnsureNoLeadingOrTrailingSlash(string path, int start)
         {
-            path = FixFilePath(path);
-            if (path.Length > 0 && IsSlash(path[0]))
+            int stop = path.Length;
+            while (start < stop && IsSlash(path[start]))
+            {
+                start++;
+            }
+            while (start < stop && IsSlash(path[stop - 1]))
             {
-                path = path.Substring(1);
+                stop--;
             }
 
-            return path;
+            return FixFilePath(path.Substring(start, stop - start));
+        }
+
+        /// <summary>
+        /// Ensures the path does not have a leading slash after removing the first 'start' characters but does end in a slash.
+        /// </summary>
+        internal static string EnsureTrailingNoLeadingSlash(string path, int start)
+        {
+            int stop = path.Length;
+            while (start < stop && IsSlash(path[start]))
+            {
+                start++;
+            }
+
+            return FixFilePath(start < stop && IsSlash(path[stop - 1]) ?
+                path.Substring(start) :
+                path.Substring(start) + Path.DirectorySeparatorChar);
         }
 
         /// <summary>
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index 9ab2e9faf9e..0e3be28f1da 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -20,10 +20,10 @@ internal static class FileUtilitiesRegex
         private static readonly char _forwardSlash = '/';
 
         /// <summary>
-        /// Indicates whether the specified string follows the pattern drive pattern (e.g. "C:", "D:")
+        /// Indicates whether the specified string follows the pattern drive pattern (for example "C:", "D:").
         /// </summary>
-        /// <param name="pattern">input to check for drive pattern</param>
-        /// <returns>true if follows the drive pattern, false otherwise</returns>
+        /// <param name="pattern">Input to check for drive pattern.</param>
+        /// <returns>true if follows the drive pattern, false otherwise.</returns>
         internal static bool IsDrivePattern(string pattern)
         {
             // Format must be two characters long: "<drive letter>:"
@@ -32,10 +32,10 @@ internal static bool IsDrivePattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string follows the pattern drive pattern (e.g. "C:/" or "C:\")
+        /// Indicates whether the specified string follows the pattern drive pattern (for example "C:/" or "C:\").
         /// </summary>
-        /// <param name="pattern">input to check for drive pattern with slash</param>
-        /// <returns>true if follows the drive pattern with slash, false otherwise</returns>
+        /// <param name="pattern">Input to check for drive pattern with slash.</param>
+        /// <returns>true if follows the drive pattern with slash, false otherwise.</returns>
         internal static bool IsDrivePatternWithSlash(string pattern)
         {
             return pattern.Length == 3 &&
@@ -43,10 +43,10 @@ internal static bool IsDrivePatternWithSlash(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string starts with the drive pattern (e.g. "C:")
+        /// Indicates whether the specified string starts with the drive pattern (for example "C:").
         /// </summary>
-        /// <param name="pattern">input to check for drive pattern</param>
-        /// <returns>true if starts with drive pattern, false otherwise</returns>
+        /// <param name="pattern">Input to check for drive pattern.</param>
+        /// <returns>true if starts with drive pattern, false otherwise.</returns>
         internal static bool StartsWithDrivePattern(string pattern)
         {
             // Format dictates a length of at least 2,
@@ -58,10 +58,10 @@ internal static bool StartsWithDrivePattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string starts with the drive pattern (e.g. "C:/" or "C:\")
+        /// Indicates whether the specified string starts with the drive pattern (for example "C:/" or "C:\").
         /// </summary>
-        /// <param name="pattern">input to check for drive pattern</param>
-        /// <returns>true if starts with drive pattern with slash, false otherwise</returns>
+        /// <param name="pattern">Input to check for drive pattern.</param>
+        /// <returns>true if starts with drive pattern with slash, false otherwise.</returns>
         internal static bool StartsWithDrivePatternWithSlash(string pattern)
         {
             // Format dictates a length of at least 3,
@@ -76,8 +76,8 @@ internal static bool StartsWithDrivePatternWithSlash(string pattern)
         /// <summary>
         /// Indicates whether the specified file-spec comprises exactly "\\server\share" (with no trailing characters).
         /// </summary>
-        /// <param name="pattern">input to check for Unc pattern</param>
-        /// <returns>true if comprises Unc pattern</returns>
+        /// <param name="pattern">Input to check for UNC pattern.</param>
+        /// <returns>true if comprises UNC pattern.</returns>
         internal static bool IsUncPattern(string pattern)
         {
             //Return value == pattern.length means:
@@ -90,8 +90,8 @@ internal static bool IsUncPattern(string pattern)
         /// <summary>
         /// Indicates whether the specified file-spec begins with "\\server\share".
         /// </summary>
-        /// <param name="pattern">input to check for Unc pattern</param>
-        /// <returns>true if starts with Unc pattern</returns>
+        /// <param name="pattern">Input to check for UNC pattern.</param>
+        /// <returns>true if starts with UNC pattern.</returns>
         internal static bool StartsWithUncPattern(string pattern)
         {
             //Any non -1 value returned means there was a match, therefore is begins with the pattern.
@@ -101,8 +101,8 @@ internal static bool StartsWithUncPattern(string pattern)
         /// <summary>
         /// Indicates whether the file-spec begins with a UNC pattern and how long the match is.
         /// </summary>
-        /// <param name="pattern">input to check for Unc pattern</param>
-        /// <returns>length of the match, -1 if no match</returns>
+        /// <param name="pattern">Input to check for UNC pattern.</param>
+        /// <returns>length of the match, -1 if no match.</returns>
         internal static int StartsWithUncPatternMatchLength(string pattern)
         {
             if (!MeetsUncPatternMinimumRequirements(pattern))
@@ -151,7 +151,7 @@ internal static int StartsWithUncPatternMatchLength(string pattern)
         /// <summary>
         /// Indicates whether or not the file-spec meets the minimum requirements of a UNC pattern.
         /// </summary>
-        /// <param name="pattern">input to check for Unc pattern minimum requirements</param>
+        /// <param name="pattern">Input to check for UNC pattern minimum requirements.</param>
         /// <returns>true if the UNC pattern is a minimum length of 5 and the first two characters are be a slash, false otherwise.</returns>
 #if !NET35
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index a8b21a618d8..e88e47f1dc6 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -136,6 +136,32 @@ private enum eDesiredAccess : int
             PROCESS_QUERY_INFORMATION = 0x0400,
             PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xFFF
         }
+#pragma warning disable 0649, 0169
+        internal enum LOGICAL_PROCESSOR_RELATIONSHIP
+        {
+            RelationProcessorCore,
+            RelationNumaNode,
+            RelationCache,
+            RelationProcessorPackage,
+            RelationGroup,
+            RelationAll = 0xffff
+        }
+        internal struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
+        {
+            public LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
+            public uint Size;
+            public PROCESSOR_RELATIONSHIP Processor;
+        }
+        [StructLayout(LayoutKind.Sequential)]
+        internal unsafe struct PROCESSOR_RELATIONSHIP
+        {
+            public byte Flags;
+            private byte EfficiencyClass;
+            private fixed byte Reserved[20];
+            public ushort GroupCount;
+            public IntPtr GroupInfo;
+        }
+#pragma warning restore 0169, 0149
 
         /// <summary>
         /// Flags for CoWaitForMultipleHandles
@@ -464,6 +490,51 @@ public SystemInformationData()
             }
         }
 
+        /// <summary>
+        /// Get the exact physical core count on Windows
+        /// Useful for getting the exact core count in 32 bits processes,
+        /// as Environment.ProcessorCount has a 32-core limit in that case. 
+        /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210
+        /// </summary>
+        public unsafe static int GetLogicalCoreCount()
+        {
+            uint len = 0;
+            const int ERROR_INSUFFICIENT_BUFFER = 122;
+
+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref len) &&
+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)
+            {
+                // Allocate that much space
+                var buffer = new byte[len];
+                fixed (byte* bufferPtr = buffer)
+                {
+                    // Call GetLogicalProcessorInformationEx with the allocated buffer
+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, (IntPtr)bufferPtr, ref len))
+                    {
+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how
+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.
+                        int processorCount = 0;
+                        byte* ptr = bufferPtr;
+                        byte* endPtr = bufferPtr + len;
+                        while (ptr < endPtr)
+                        {
+                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;
+                            if (current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore)
+                            {
+                                // Flags is 0 if the core has a single logical proc, LTP_PC_SMT if more than one
+                                // for now, assume "more than 1" == 2, as it has historically been for hyperthreading
+                                processorCount += (current->Processor.Flags == 0) ? 1 : 2;
+                            }
+                            ptr += current->Size;
+                        }
+                        return processorCount;
+                    }
+                }
+            }
+
+            return -1;
+        }
+
         #endregion
 
         #region Member data
@@ -804,6 +875,10 @@ internal static int SetErrorMode(int newMode)
         [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
         [DllImport("kernel32.dll", SetLastError = true)]
         internal static extern void GetNativeSystemInfo(ref SYSTEM_INFO lpSystemInfo);
+        
+        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
+        [DllImport("kernel32.dll", SetLastError = true)]
+        internal static extern bool GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, IntPtr Buffer, ref uint ReturnedLength);
 
         /// <summary>
         /// Get the last write time of the fullpath to a directory. If the pointed path is not a directory, or
diff --git a/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
new file mode 100644
index 00000000000..0571ce4e7eb
--- /dev/null
+++ b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
@@ -0,0 +1,104 @@
+ï»¿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+using Microsoft.Build.Framework;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.Utilities;
+using Shouldly;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Xunit;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    public class RARPrecomputedCache_Tests
+    {
+        private Dictionary<string, Guid> guidStore = new Dictionary<string, Guid>();
+
+        private Guid calculateMvid(string path)
+        {
+            if (!guidStore.ContainsKey(path))
+            {
+                guidStore.Add(path, Guid.NewGuid());
+            }
+            return guidStore[path];
+        }
+
+        [Fact]
+        public void TestPrecomputedCacheOutput()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile standardCache = env.CreateFile(".cache");
+                ResolveAssemblyReference t = new ResolveAssemblyReference();
+                t._cache = new SystemState();
+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {
+                    { Path.Combine(standardCache.Path, "assembly1"), new SystemState.FileState(DateTime.Now) },
+                    { Path.Combine(standardCache.Path, "assembly2"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension("hi") } } };
+                t._cache.IsDirty = true;
+                t.StateFile = standardCache.Path;
+                t.WriteStateFile(calculateMvid);
+                int standardLen = File.ReadAllText(standardCache.Path).Length;
+                File.Delete(standardCache.Path);
+                standardLen.ShouldBeGreaterThan(0);
+
+                string precomputedPath = standardCache.Path + ".cache";
+                t._cache.IsDirty = true;
+                t.AssemblyInformationCacheOutputPath = precomputedPath;
+                t.WriteStateFile(calculateMvid);
+                File.Exists(standardCache.Path).ShouldBeFalse();
+                int preLen = File.ReadAllText(precomputedPath).Length;
+                preLen.ShouldBeGreaterThan(0);
+                preLen.ShouldNotBe(standardLen);
+            }
+        }
+
+        [Fact]
+        public void TestPreComputedCacheInputAndOutput()
+        {
+            using (TestEnvironment env = TestEnvironment.Create()) {
+                TransientTestFile standardCache = env.CreateFile(".cache");
+                ResolveAssemblyReference t = new ResolveAssemblyReference();
+                t._cache = new SystemState();
+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {
+                    { Path.Combine(standardCache.Path, "assembly1"), new SystemState.FileState(DateTime.Now) },
+                    { Path.Combine(standardCache.Path, "assembly2"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension("hi") } } };
+                t.StateFile = standardCache.Path;
+                t._cache.IsDirty = true;
+                t.WriteStateFile(calculateMvid);
+
+                string dllName = Path.Combine(Path.GetDirectoryName(standardCache.Path), "randomFolder", "dll.dll");
+                t._cache.instanceLocalFileStateCache.Add(dllName,
+                    new SystemState.FileState(DateTime.Now) {
+                        Assembly = null,
+                        RuntimeVersion = "v4.0.30319",
+                        FrameworkNameAttribute = new System.Runtime.Versioning.FrameworkName(".NETFramework", Version.Parse("4.7.2"), "Profile"),
+                        scatterFiles = new string[] { "first", "second" } });
+                string precomputedCachePath = standardCache.Path + ".cache";
+                t.AssemblyInformationCacheOutputPath = precomputedCachePath;
+                t._cache.IsDirty = true;
+                t.WriteStateFile(calculateMvid);
+
+                ResolveAssemblyReference u = new ResolveAssemblyReference();
+                u.StateFile = standardCache.Path;
+                u.AssemblyInformationCachePaths = new ITaskItem[]
+                {
+                    new TaskItem(precomputedCachePath)
+                };
+
+                u.ReadStateFile(File.GetLastWriteTime, Array.Empty<AssemblyTableInfo>(), calculateMvid, p => true);
+                u._cache.instanceLocalFileStateCache.ShouldNotContainKey(dllName);
+                File.Delete(standardCache.Path);
+                u._cache = null;
+                u.ReadStateFile(File.GetLastWriteTime, Array.Empty<AssemblyTableInfo>(), calculateMvid, p => true);
+                u._cache.instanceLocalFileStateCache.ShouldContainKey(dllName);
+                SystemState.FileState a3 = u._cache.instanceLocalFileStateCache[dllName];
+                a3.Assembly.ShouldBeNull();
+                a3.RuntimeVersion.ShouldBe("v4.0.30319");
+                a3.FrameworkNameAttribute.Version.ShouldBe(Version.Parse("4.7.2"));
+                a3.scatterFiles.Length.ShouldBe(2);
+                a3.scatterFiles[1].ShouldBe("second");
+            }
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/XmlPoke_Tests.cs b/src/Tasks.UnitTests/XmlPoke_Tests.cs
index b57cd585398..98b16aaacc0 100644
--- a/src/Tasks.UnitTests/XmlPoke_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPoke_Tests.cs
@@ -1,22 +1,15 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
-using Microsoft.Build.Tasks;
-using Microsoft.Build.UnitTests;
-using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 using System;
-using System.CodeDom.Compiler;
 using System.Collections.Generic;
-using System.Reflection;
-using System.Reflection.Emit;
 using System.IO;
 using System.Linq;
-using System.Text;
 using System.Xml;
-using Xunit;
+using Microsoft.Build.Tasks;
+using Microsoft.Build.Utilities;
 using Shouldly;
+using Xunit;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -24,16 +17,16 @@ sealed public class XmlPoke_Tests
     {
         private const string XmlNamespaceUsedByTests = "http://nsurl";
 
-        private string _xmlFileWithNs = $@"<?xml version='1.0' encoding='utf-8'?>
+        private const string _xmlFileWithNs = @"<?xml version='1.0' encoding='utf-8'?>
         
-<class AccessModifier='public' Name='test' xmlns:s='{XmlNamespaceUsedByTests}'>
+<class AccessModifier='public' Name='test' xmlns:s='" + XmlNamespaceUsedByTests + @"'>
   <s:variable Type='String' Name='a'></s:variable>
   <s:variable Type='String' Name='b'></s:variable>
   <s:variable Type='String' Name='c'></s:variable>
   <method AccessModifier='public static' Name='GetVal' />
 </class>";
 
-        private string _xmlFileNoNs = @"<?xml version='1.0' encoding='utf-8'?>
+        private const string _xmlFileNoNs = @"<?xml version='1.0' encoding='utf-8'?>
         
 <class AccessModifier='public' Name='test'>
   <variable Type='String' Name='a'></variable>
@@ -57,9 +50,11 @@ public void PokeWithNamespace()
 
             List<XmlAttribute> nodes = xmlDocument.SelectNodes(query, ns)?.Cast<XmlAttribute>().ToList();
 
-            Assert.True(nodes?.Count == 3, $"There should be 3 <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(3, $"There should be 3 <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            Assert.True(nodes?.All(i => i.Value.Equals("Mert")), $"All <variable /> elements should have Name=\"Mert\" {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldAllBe(i => i.Value.Equals("Mert"), $"All <variable /> elements should have Name=\"Mert\" {Environment.NewLine}{xmlDocument.OuterXml}");
         }
 
         [Fact]
@@ -73,9 +68,11 @@ public void PokeNoNamespace()
 
             List<XmlAttribute> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlAttribute>().ToList();
 
-            Assert.True(nodes?.Count == 3, $"There should be 3 <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            Assert.True(nodes?.All(i => i.Value.Equals(value)), $"All <variable /> elements should have Name=\"{value}\" {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.Count.ShouldBe(3, $"There should be 3 <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.ShouldAllBe(i => i.Value.Equals(value), $"All <variable /> elements should have Name=\"{value}\" {Environment.NewLine}{xmlDocument.OuterXml}");
         }
 
         [Fact]
@@ -88,9 +85,11 @@ public void PokeAttribute()
 
             List<XmlAttribute> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlAttribute>().ToList();
 
-            Assert.True(nodes?.Count == 1, $"There should be 1 <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <class /> elements with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(1, $"There should be 1 <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            Assert.Equal(value, nodes?.First().Value);
+            nodes[0].Value.ShouldBe(value);
         }
 
         [Fact]
@@ -103,13 +102,17 @@ public void PokeChildren()
 
             List<XmlElement> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlElement>().ToList();
 
-            Assert.True(nodes?.Count == 1, $"There should be 1 <class /> element {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <class /> elements {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(1, $"There should be 1 <class /> element {Environment.NewLine}{xmlDocument.OuterXml}");
 
             var testNodes = nodes?.First().ChildNodes.Cast<XmlElement>().ToList();
 
-            Assert.True(testNodes?.Count == 1, $"There should be 1 <class /> element with one child Test element {Environment.NewLine}{xmlDocument.OuterXml}");
+            testNodes.ShouldNotBeNull($"There should be <class /> elements with one child Test element {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            testNodes.Count.ShouldBe(1, $"There should be 1 <class /> element with one child Test element {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            Assert.Equal("Testing", testNodes?.First().InnerText);
+            testNodes[0].InnerText.ShouldBe("Testing");
         }
 
         [Fact]
@@ -123,9 +126,11 @@ public void PokeAttributeWithCondition()
 
             List<XmlAttribute> nodes = xmlDocument.SelectNodes(string.Format(queryTemplate, value))?.Cast<XmlAttribute>().ToList();
 
-            nodes?.Count.ShouldBe(1, $"There should be 1 <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(1, $"There should be 1 <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            nodes?[0].Value.ShouldBe(value);
+            nodes[0].Value.ShouldBe(value);
         }
 
         [Fact]
@@ -155,23 +160,14 @@ public void PokeMissingParams()
                     p.Value = new TaskItem("Mert");
                 }
 
-                bool exceptionThrown = false;
-                try
-                {
-                    p.Execute();
-                }
-                catch (ArgumentNullException)
-                {
-                    exceptionThrown = true;
-                }
-
+                // "Expecting argumentnullexception for the first 7 tests"
                 if (i < 7)
                 {
-                    Assert.True(exceptionThrown); // "Expecting argumentnullexception for the first 7 tests"
+                    Should.Throw<ArgumentNullException>(() => p.Execute());
                 }
                 else
                 {
-                    Assert.False(exceptionThrown); // "Expecting argumentnullexception for the first 7 tests"
+                    Should.NotThrow(() => p.Execute());
                 }
             }
         }
@@ -188,12 +184,11 @@ public void ErrorInNamespaceDecl()
             p.XmlInputPath = new TaskItem(xmlInputPath);
             p.Query = "//s:variable/@Name";
             p.Namespaces = "<!THIS IS ERROR Namespace Prefix=\"s\" Uri=\"http://nsurl\" />";
-            Assert.Equal("<!THIS IS ERROR Namespace Prefix=\"s\" Uri=\"http://nsurl\" />", p.Namespaces);
+            p.Namespaces.ShouldBe("<!THIS IS ERROR Namespace Prefix=\"s\" Uri=\"http://nsurl\" />");
             p.Value = new TaskItem("Nur");
 
-            bool executeResult = p.Execute();
-            Assert.Contains("MSB3731", engine.Log);
-            Assert.False(executeResult); // "Execution should've failed"
+            p.Execute().ShouldBeFalse(); // "Execution should've failed"
+            engine.AssertLogContains("MSB3731");
         }
 
         [Fact]
@@ -209,8 +204,8 @@ public void PokeNoNSWPrefixedQueryError()
             p.XmlInputPath = new TaskItem(xmlInputPath);
             p.Query = "//s:variable/@Name";
             p.Value = new TaskItem("Nur");
-            Assert.False(p.Execute()); // "Test should've failed"
-            Assert.True(engine.Log.Contains("MSB3732"), "Engine log should contain error code MSB3732 " + engine.Log);
+            p.Execute().ShouldBeFalse(); // "Test should've failed"
+            engine.AssertLogContains("MSB3732");
         }
 
         [Fact]
@@ -242,11 +237,11 @@ public void MissingNamespaceParameters()
 
                 if (i == 3)
                 {
-                    Assert.True(result); // "Only 3rd value should pass."
+                    result.ShouldBeTrue(); // "Only 3rd value should pass."
                 }
                 else
                 {
-                    Assert.False(result); // "Only 3rd value should pass."
+                    result.ShouldBeFalse(); // "Only 3rd value should pass."
                 }
             }
         }
@@ -262,11 +257,13 @@ public void PokeElement()
 
             List<XmlElement> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlElement>().ToList();
 
-            Assert.True(nodes?.Count == 3, $"There should be 3 <variable/> elements {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <variable/> elements {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(3, $"There should be 3 <variable/> elements {Environment.NewLine}{xmlDocument.OuterXml}");
 
             foreach (var node in nodes)
             {
-                Assert.Equal(value, node.InnerXml);
+                node.InnerXml.ShouldBe(value);
             }
         }
 
@@ -287,7 +284,7 @@ public void PokeWithoutUsingTask()
             logger.AssertLogDoesntContain("MSB4036");
         }
 
-        private void Prepare(string xmlFile, out string xmlInputPath)
+        private static void Prepare(string xmlFile, out string xmlInputPath)
         {
             string dir = Path.Combine(Path.GetTempPath(), DateTime.Now.Ticks.ToString());
             Directory.CreateDirectory(dir);
@@ -302,7 +299,7 @@ private void Prepare(string xmlFile, out string xmlInputPath)
         /// <param name="useNamespace"><code>true</code> to use namespaces, otherwise <code>false</code> (Default).</param>
         /// <param name="value">The value to use.</param>
         /// <returns>An <see cref="XmlDocument"/> containing the resulting XML after the XmlPoke task has executed.</returns>
-        private XmlDocument ExecuteXmlPoke(string query, bool useNamespace = false, string value = null)
+        private static XmlDocument ExecuteXmlPoke(string query, bool useNamespace = false, string value = null)
         {
             MockEngine engine = new MockEngine(true);
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
index dced5e5453e..82fbcc95204 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
@@ -15,11 +15,11 @@ internal class AssemblyFoldersResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="searchPathElement"></param>
-        /// <param name="getAssemblyName"></param>
-        /// <param name="fileExists"></param>
-        /// <param name="getRuntimeVersion"></param>
-        /// <param name="targetedRuntimeVesion"></param>
+        /// <param name="searchPathElement">The corresponding element from the search path.</param>
+        /// <param name="getAssemblyName">Delegate that gets the assembly name.</param>
+        /// <param name="fileExists">Delegate that returns if the file exists.</param>
+        /// <param name="getRuntimeVersion">Delegate that returns the clr runtime version for the file.</param>
+        /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
         public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
diff --git a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
index eb126f0656a..23ccac23cb2 100644
--- a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
+++ b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
@@ -23,11 +23,11 @@ internal class CandidateAssemblyFilesResolver : Resolver
         /// Construct.
         /// </summary>
         /// <param name="candidateAssemblyFiles">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>
-        /// <param name="searchPathElement"></param>
-        /// <param name="getAssemblyName"></param>
-        /// <param name="fileExists"></param>
-        /// <param name="getRuntimeVersion"></param>
-        /// <param name="targetedRuntimeVesion"></param>
+        /// <param name="searchPathElement">The corresponding element from the search path.</param>
+        /// <param name="getAssemblyName">Delegate that gets the assembly name.</param>
+        /// <param name="fileExists">Delegate that returns if the file exists.</param>
+        /// <param name="getRuntimeVersion">Delegate that returns the clr runtime version for the file.</param>
+        /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
         public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 3c03605de6c..a842843a021 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -102,7 +102,7 @@ internal sealed class ReferenceTable
         /// </summary>
         private readonly IsWinMDFile _isWinMDFile;
 
-        /// <summary>version of the framework targeted by this project</summary>
+        /// <summary>Version of the framework targeted by this project.</summary>
         private readonly Version _projectTargetFramework;
 
         /// <summary>
@@ -111,7 +111,7 @@ internal sealed class ReferenceTable
         private readonly FrameworkNameVersioning _targetFrameworkMoniker;
 
         /// <summary>
-        /// Logging helper to allow the logging of meessages from the Reference Table
+        /// Logging helper to allow the logging of meessages from the Reference Table.
         /// </summary>
         private readonly TaskLoggingHelper _log;
 
@@ -186,10 +186,10 @@ internal sealed class ReferenceTable
         /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
         /// <param name="allowedAssemblyExtensions"></param>
         /// <param name="getRuntimeVersion"></param>
-        /// <param name="targetedRuntimeVersion"></param>
-        /// <param name="projectTargetFramework"></param>
-        /// <param name="targetFrameworkMoniker"></param>
-        /// <param name="log"></param>
+        /// <param name="targetedRuntimeVersion">Version of the runtime to target.</param>
+        /// <param name="projectTargetFramework">Version of the framework targeted by the project.</param>
+        /// <param name="targetFrameworkMoniker">Target framework moniker we are targeting.</param>
+        /// <param name="log">Logging helper to allow the logging of meessages from the Reference Table.</param>
         /// <param name="latestTargetFrameworkDirectories"></param>
         /// <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
         /// <param name="doNotCopyLocalIfInGac"></param>
@@ -224,10 +224,10 @@ internal sealed class ReferenceTable
         /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
         /// <param name="allowedAssemblyExtensions"></param>
         /// <param name="getRuntimeVersion"></param>
-        /// <param name="targetedRuntimeVersion"></param>
-        /// <param name="projectTargetFramework"></param>
-        /// <param name="targetFrameworkMoniker"></param>
-        /// <param name="log"></param>
+        /// <param name="targetedRuntimeVersion">Version of the runtime to target.</param>
+        /// <param name="projectTargetFramework">Version of the framework targeted by the project.</param>
+        /// <param name="targetFrameworkMoniker">Target framework moniker we are targeting.</param>
+        /// <param name="log">Logging helper to allow the logging of meessages from the Reference Table.</param>
         /// <param name="latestTargetFrameworkDirectories"></param>
         /// <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
         /// <param name="doNotCopyLocalIfInGac"></param>
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index fd70c667752..d961a6a7a7c 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -51,7 +51,7 @@ public class ResolveAssemblyReference : TaskExtension
         /// <summary>
         /// Cache of system state information, used to optimize performance.
         /// </summary>
-        private SystemState _cache = null;
+        internal SystemState _cache = null;
 
         /// <summary>
         /// Construct
@@ -450,16 +450,16 @@ public string TargetedRuntimeVersion
         }
 
         /// <summary>
-        /// If not null, serializes a cache to this location. This overrides the usual cache, so only use this if you will
-        /// not have access to the usual cache at the next build.
+        /// If not null, serializes information about <see cref="AssemblyFiles" /> inputs to the named file.
+        /// This overrides the usual outputs, so do not use this unless you are building an SDK with many references.
         /// </summary>
-        public string CacheOutputPath { get; set; }
+        public string AssemblyInformationCacheOutputPath { get; set; }
 
         /// <summary>
         /// If not null, uses this set of caches as inputs if RAR cannot find the usual cache in the obj folder. Typically
         /// used for demos and first-run scenarios.
         /// </summary>
-        public string[] CacheInputPaths { get; set; }
+        public ITaskItem[] AssemblyInformationCachePaths { get; set; }
 
         /// <summary>
         /// List of locations to search for assemblyFiles when resolving dependencies.
@@ -1859,7 +1859,7 @@ private void LogConflict(Reference reference, string fusionName)
         /// <summary>
         /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.
         /// </summary>
-        private void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)
+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid = null, Func<string, bool> fileExists = null)
         {
             var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
             deserializeOptions.Converters.Add(new SystemState.Converter());
@@ -1874,7 +1874,7 @@ private void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[
 
             if (_cache == null)
             {
-                _cache = SystemState.DeserializePrecomputedCaches(CacheInputPaths ?? new string[0], Log, typeof(SystemState), getLastWriteTime, installedAssemblyTableInfo);
+                _cache = SystemState.DeserializePrecomputedCaches(AssemblyInformationCachePaths ?? Array.Empty<ITaskItem>(), Log, typeof(SystemState), getLastWriteTime, installedAssemblyTableInfo, calculateMvid, fileExists);
             }
             else
             {
@@ -1886,11 +1886,11 @@ private void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[
         /// <summary>
         /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.
         /// </summary>
-        private void WriteStateFile()
+        internal void WriteStateFile(Func<string, Guid> calculateMvid = null)
         {
-            if (!string.IsNullOrEmpty(CacheOutputPath))
+            if (!string.IsNullOrEmpty(AssemblyInformationCacheOutputPath))
             {
-                _cache.SerializePrecomputedCache(CacheOutputPath, Log);
+                _cache.SerializePrecomputedCache(AssemblyInformationCacheOutputPath, Log, calculateMvid);
             }
             else if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
             {
diff --git a/src/Tasks/FormatUrl.cs b/src/Tasks/FormatUrl.cs
index 788da79089b..4942b3d2bed 100644
--- a/src/Tasks/FormatUrl.cs
+++ b/src/Tasks/FormatUrl.cs
@@ -19,8 +19,13 @@ public sealed class FormatUrl : TaskExtension
 
         public override bool Execute()
         {
+#if RUNTIME_TYPE_NETCORE
+            Log.LogErrorFromResources("TaskRequiresFrameworkFailure", nameof(FormatUrl));
+            return false;
+#else
             OutputUrl = InputUrl != null ? PathUtil.Format(InputUrl) : String.Empty;
             return true;
+#endif
         }
     }
 }
diff --git a/src/Tasks/GenerateApplicationManifest.cs b/src/Tasks/GenerateApplicationManifest.cs
index 69cdab6c19c..c69fe1a7155 100644
--- a/src/Tasks/GenerateApplicationManifest.cs
+++ b/src/Tasks/GenerateApplicationManifest.cs
@@ -125,7 +125,15 @@ private bool BuildApplicationManifest(ApplicationManifest manifest)
             {
                 foreach (ITaskItem item in Dependencies)
                 {
-                    AddAssemblyFromItem(item);
+                    if (LauncherBasedDeployment)
+                    {
+                        // In Launcher-based deployments, everything needs to be a regular file.
+                        AddFileFromItem(item);
+                    }
+                    else
+                    {
+                        AddAssemblyFromItem(item);
+                    }
                 }
             }
 
diff --git a/src/Tasks/GenerateLauncher.cs b/src/Tasks/GenerateLauncher.cs
new file mode 100644
index 00000000000..d8dd788d442
--- /dev/null
+++ b/src/Tasks/GenerateLauncher.cs
@@ -0,0 +1,98 @@
+ï»¿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Reflection;
+using System.Runtime.Versioning;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Tasks.Deployment.Bootstrapper;
+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
+using Microsoft.Build.Utilities;
+
+namespace Microsoft.Build.Tasks
+{
+    /// <summary>
+    /// Generates a bootstrapper for ClickOnce deployment projects.
+    /// </summary>
+    public sealed class GenerateLauncher : TaskExtension
+    {
+        private const string LAUNCHER_EXE = "Launcher.exe";
+        private const string ENGINE_PATH = "Engine"; // relative to ClickOnce bootstrapper path
+
+        #region Properties
+
+        public ITaskItem EntryPoint { get; set; }
+
+        public string LauncherPath { get; set; }
+
+        public string OutputPath { get; set; }
+
+        public string VisualStudioVersion { get; set; }
+
+        public string AssemblyName { get; set; }
+
+        [Output]
+        public ITaskItem OutputEntryPoint { get; set; }
+        #endregion
+
+        public override bool Execute()
+        {
+            if (LauncherPath == null)
+            {
+                // Launcher lives next to ClickOnce bootstrapper.
+                // GetDefaultPath obtains the root ClickOnce boostrapper path.
+                LauncherPath = Path.Combine(
+                    Microsoft.Build.Tasks.Deployment.Bootstrapper.Util.GetDefaultPath(VisualStudioVersion),
+                    ENGINE_PATH,
+                    LAUNCHER_EXE);
+            }
+
+            if (EntryPoint == null)
+            {
+                Log.LogErrorWithCodeFromResources("GenerateLauncher.InvalidInput");
+                return false;
+            }
+
+            var launcherBuilder = new LauncherBuilder(LauncherPath);
+            string entryPointFileName = Path.GetFileName(EntryPoint.ItemSpec);
+            //
+            // If the EntryPoint specified is apphost.exe, we need to use the assemblyname instead since
+            // apphost.exe is the source file that will get copied to outdir as {assemblyname}.exe.
+            //
+            if (entryPointFileName.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) &&
+                !String.IsNullOrEmpty(AssemblyName))
+            {
+                entryPointFileName = AssemblyName;
+            }
+            BuildResults results = launcherBuilder.Build(entryPointFileName, OutputPath);
+
+            BuildMessage[] messages = results.Messages;
+            if (messages != null)
+            {
+                foreach (BuildMessage message in messages)
+                {
+                    switch (message.Severity)
+                    {
+                        case BuildMessageSeverity.Error:
+                            Log.LogError(null, message.HelpCode, message.HelpKeyword, null, 0, 0, 0, 0, message.Message);
+                            break;
+                        case BuildMessageSeverity.Warning:
+                            Log.LogWarning(null, message.HelpCode, message.HelpKeyword, null, 0, 0, 0, 0, message.Message);
+                            break;
+                        case BuildMessageSeverity.Info:
+                            Log.LogMessage(null, message.HelpCode, message.HelpKeyword, null, 0, 0, 0, 0, message.Message);
+                            continue;
+                    }
+                }
+            }
+
+            OutputEntryPoint = new TaskItem(Path.Combine(Path.GetDirectoryName(EntryPoint.ItemSpec), results.KeyFile));
+            OutputEntryPoint.SetMetadata(ItemMetadataNames.targetPath, results.KeyFile);
+
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index 7aa4cfd5f95..3ad0bf8c681 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -42,6 +42,8 @@ protected GenerateManifestBase() : base(AssemblyResources.PrimaryResources, "MSB
 
         public ITaskItem InputManifest { get; set; }
 
+        public bool LauncherBasedDeployment { get; set; }
+
         public int MaxTargetPath { get; set; }
 
         [Output]
@@ -481,6 +483,8 @@ private bool InitializeManifest(Type manifestType)
             {
                 _manifest.Description = Description;
             }
+            _manifest.LauncherBasedDeployment = LauncherBasedDeployment;
+            _manifest.AssemblyName = AssemblyName;
 
             return true;
         }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 5fc96169dcf..7a3ad571bda 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -3825,10 +3825,10 @@ private void AddResource(ReaderInfo reader, IResource entry, String inputFileNam
         /// <summary>
         /// Add a resource from an XML or binary format file to the internal data structures
         /// </summary>
-        /// <param name="reader">Reader info</param>
-        /// <param name="name">Resource name</param>
-        /// <param name="value">Resource value</param>
-        /// <param name="inputFileName">Input file for messages</param>
+        /// <param name="reader">Reader information.</param>
+        /// <param name="name">Resource name.</param>
+        /// <param name="value">Resource value.</param>
+        /// <param name="inputFileName">Input file for messages.</param>
         private void AddResource(ReaderInfo reader, string name, object value, String inputFileName)
         {
             AddResource(reader, name, value, inputFileName, 0, 0);
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 1f0e1cc3d6a..d5a7628a245 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -655,7 +655,10 @@ private void ValidateReferencesForClickOnceApplication()
             foreach (FileReference file in FileReferences)
             {
                 // Check that file is not an assembly...
-                if (!String.IsNullOrEmpty(file.ResolvedPath) && PathUtil.IsAssembly(file.ResolvedPath))
+                // Unless this is a Launcher-based deployments where all files except launcher
+                // are added as regular file references and not assembly references.
+                if (!LauncherBasedDeployment &&
+                    !String.IsNullOrEmpty(file.ResolvedPath) && PathUtil.IsAssembly(file.ResolvedPath))
                 {
                     OutputMessages.AddWarningMessage("GenerateManifest.AssemblyAsFile", file.ToString());
                 }
diff --git a/src/Tasks/ManifestUtil/Constants.cs b/src/Tasks/ManifestUtil/Constants.cs
index f559bdf342a..afd96650c01 100644
--- a/src/Tasks/ManifestUtil/Constants.cs
+++ b/src/Tasks/ManifestUtil/Constants.cs
@@ -26,5 +26,8 @@ internal static class Constants
         public const int MaxFileAssociationExtensionLength = 24;
         public const string ClientFrameworkSubset = "Client";
         public const string DotNetFrameworkIdentifier = ".NETFramework";
+        public const string DotNetCoreIdentifier = ".NETCore";
+        public const string DotNetCoreAppIdentifier = ".NETCoreApp";
+        public const string AppHostExe = "apphost.exe";
     }
 }
diff --git a/src/Tasks/ManifestUtil/LauncherBuilder.cs b/src/Tasks/ManifestUtil/LauncherBuilder.cs
new file mode 100644
index 00000000000..f8f772bb5f9
--- /dev/null
+++ b/src/Tasks/ManifestUtil/LauncherBuilder.cs
@@ -0,0 +1,123 @@
+ï»¿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.ComponentModel;
+using System.IO;
+using System.Runtime.InteropServices;
+using System.Xml.Serialization;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Tasks.Deployment.Bootstrapper;
+
+namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
+{
+    /// <summary>
+    /// Adds Launcher and updates its resource
+    /// </summary>
+    public class LauncherBuilder
+    {
+        private const string LAUNCHER_RESOURCENAME = "FILENAME";
+        private const int LAUNCHER_RESOURCE_TABLE = 50;
+
+        private BuildResults _results;
+
+        public LauncherBuilder(string launcherPath)
+        {
+            LauncherPath = launcherPath;
+        }
+
+        /// <summary>
+        /// Specifies the location of the required Launcher files.
+        /// </summary>
+        /// <value>Path to Launcher files.</value>
+        public string LauncherPath { get; set; }
+
+        public BuildResults Build(string filename, string outputPath)
+        {
+            string launcherFilename = Path.GetFileName(LauncherPath);
+
+            _results = new BuildResults();
+
+            try
+            {
+                if (filename == null)
+                {
+                    _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateLauncher.InvalidInput"));
+                    return _results;
+                }
+
+                if (String.IsNullOrEmpty(outputPath))
+                {
+                    _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateLauncher.NoOutputPath"));
+                    return _results;
+                }
+
+                // Copy setup.bin to the output directory
+                string strOutputExe = System.IO.Path.Combine(outputPath, launcherFilename);
+                if (!CopyLauncherToOutputDirectory(strOutputExe))
+                {
+                    // Appropriate messages should have been stuffed into the results already
+                    return _results;
+                }
+
+                var resourceUpdater = new ResourceUpdater();
+                resourceUpdater.AddStringResource(LAUNCHER_RESOURCE_TABLE, LAUNCHER_RESOURCENAME, filename);
+                if (!resourceUpdater.UpdateResources(strOutputExe, _results))
+                {
+                    return _results;
+                }
+
+                _results.SetKeyFile(launcherFilename);
+                _results.BuildSucceeded();
+            }
+            catch (Exception ex)
+            {
+                _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateLauncher.General", ex.Message));
+            }
+
+            return _results;
+        }
+
+        private bool CopyLauncherToOutputDirectory(string strOutputExe)
+        {
+            if (!FileSystems.Default.FileExists(LauncherPath))
+            {
+                _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateLauncher.MissingLauncherExe", LauncherPath));
+                return false;
+            }
+
+            try
+            {
+                EnsureFolderExists(Path.GetDirectoryName(strOutputExe));
+                File.Copy(LauncherPath, strOutputExe, true);
+                ClearReadOnlyAttribute(strOutputExe);
+            }
+            catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
+            {
+                _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateLauncher.CopyError", LauncherPath, strOutputExe, ex.Message));
+                return false;
+            }
+
+            return true;
+        }
+
+        private static void EnsureFolderExists(string strFolderPath)
+        {
+            if (!FileSystems.Default.DirectoryExists(strFolderPath))
+            {
+                Directory.CreateDirectory(strFolderPath);
+            }
+        }
+
+        private static void ClearReadOnlyAttribute(string strFileName)
+        {
+            FileAttributes attribs = File.GetAttributes(strFileName);
+            if ((attribs & FileAttributes.ReadOnly) != 0)
+            {
+                attribs &= (~FileAttributes.ReadOnly);
+                File.SetAttributes(strFileName, attribs);
+            }
+        }
+    }
+}
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index 13a69ff34fc..762e09e226d 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -68,6 +68,19 @@ private void CollectionToArray()
             }
         }
 
+        /// <summary>
+        /// Assembly name passed to the manifest generation task
+        /// </summary>
+        [XmlIgnore]
+        public string AssemblyName { get; set; }
+
+        /// <summary>
+        /// Indicates if manifest is part of Launcher-based deployment, which requires
+        /// somewhat different manifest generation and validation.
+        /// </summary>
+        [XmlIgnore]
+        public bool LauncherBasedDeployment { get; set; } = false;
+
         /// <summary>
         /// Specifies a textual description for the manifest.
         /// </summary>
@@ -466,7 +479,7 @@ private void UpdateAssemblyReference(AssemblyReference a, string targetFramework
             }
         }
 
-        private static void UpdateFileReference(BaseReference f, string targetFrameworkVersion)
+        private void UpdateFileReference(BaseReference f, string targetFrameworkVersion)
         {
             if (String.IsNullOrEmpty(f.ResolvedPath))
             {
@@ -485,6 +498,21 @@ private static void UpdateFileReference(BaseReference f, string targetFrameworkV
             }
             f.Hash = hash;
             f.Size = size;
+
+            //
+            // .NETCore Launcher.exe based Deployment: If the filereference is for apphost.exe, we need to change
+            // the ResolvedPath and TargetPath to {assemblyname}.exe before we write the manifest, so that the
+            // manifest does not have a file reference to apphost.exe
+            //
+            string fileName = Path.GetFileName(f.ResolvedPath);
+            if (LauncherBasedDeployment &&
+                fileName.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) &&
+                !String.IsNullOrEmpty(AssemblyName))
+            {
+                f.ResolvedPath = Path.Combine(Path.GetDirectoryName(f.ResolvedPath), AssemblyName);
+                f.TargetPath = BaseReference.GetDefaultTargetPath(f.ResolvedPath);
+            }
+
             if (String.IsNullOrEmpty(f.TargetPath))
             {
                 if (!String.IsNullOrEmpty(f.SourcePath))
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 831cce4639b..d1fc908de96 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -416,6 +416,9 @@
     <Compile Include="FindInList.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="FormatUrl.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="FormatVersion.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -428,6 +431,9 @@
     <Compile Include="GenerateDeploymentManifest.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="GenerateLauncher.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="GenerateManifestBase.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -609,9 +615,6 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="FindInvalidProjectReferences.cs" />
-    <Compile Include="FormatUrl.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="GenerateBootstrapper.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 1b0aa167c3c..ef26ebafe6d 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -256,6 +256,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <_DeploymentBuiltUpdateIntervalUnits Condition="'$(UpdatePeriodically)'!='true'">Days</_DeploymentBuiltUpdateIntervalUnits>
     <_DeploymentBuiltMinimumRequiredVersion Condition="'$(UpdateRequired)'=='true' and '$(Install)'=='true'">$(MinimumRequiredVersion)</_DeploymentBuiltMinimumRequiredVersion>
 
+    <_DeploymentLauncherBased Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'">true</_DeploymentLauncherBased>
+
     <MaxTargetPath Condition="'$(MaxTargetPath)'==''">100</MaxTargetPath>
   </PropertyGroup>
 
@@ -3827,6 +3829,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <ResolveManifestFiles
         TargetFrameworkVersion="$(TargetFrameworkVersion)"
+        TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
         SigningManifests="$(SignManifests)"
         DeploymentManifestEntryPoint="@(ApplicationManifest)"
         PublishFiles="@(_DeploymentPublishFileOfTypeManifestEntryPoint)">
@@ -3863,6 +3866,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Target
       Name="GenerateApplicationManifest"
       DependsOnTargets="
+            _DeploymentSetClickOnceVersions;
+            _DeploymentGenerateLauncher;
             _DeploymentComputeNativeManifestInfo;
             _DeploymentComputeClickOnceManifestInfo;
             ResolveComReferences;
@@ -3908,11 +3913,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         IconFile="@(_DeploymentManifestIconFile)"
         InputManifest="$(_DeploymentBaseManifest)"
         IsolatedComReferences="@(ResolvedIsolatedComModules)"
+        LauncherBasedDeployment="$(_DeploymentLauncherBased)"
         ManifestType="$(_DeploymentManifestType)"
         MaxTargetPath="$(MaxTargetPath)"
         OutputManifest="@(ApplicationManifest)"
         OSVersion="$(OSVersion)"
-        Platform="$(PlatformTarget)"
+        Platform="$(_DeploymentPlatformTarget)"
         Product="$(ProductName)"
         Publisher="$(PublisherName)"
         RequiresMinimumFramework35SP1="$(_DeploymentRequiresMinimumFramework35SP1)"
@@ -3921,7 +3927,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         TargetCulture="$(TargetCulture)"
         TargetFrameworkSubset="$(TargetFrameworkSubset)"
         TargetFrameworkProfile="$(TargetFrameworkProfile)"
-        TargetFrameworkVersion="$(TargetFrameworkVersion)"
+        TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)"
         TrustInfoFile="@(_DeploymentIntermediateTrustInfoFile)"
         UseApplicationTrust="$(UseApplicationTrust)">
 
@@ -3935,6 +3941,90 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
+  <!--
+    ============================================================
+                                        _DeploymentSetClickOnceVersions
+
+    Sets ClickOnce versions
+    ============================================================
+    -->
+  <Target
+      Name="_DeploymentSetClickOnceVersions"
+      Condition="'$(GenerateClickOnceManifests)'=='true'">
+
+    <PropertyGroup>
+      <_DeploymentManifestTargetFrameworkMoniker>$(TargetFrameworkMoniker)</_DeploymentManifestTargetFrameworkMoniker>
+      <_DeploymentManifestTargetFrameworkVersion>$(TargetFrameworkVersion)</_DeploymentManifestTargetFrameworkVersion>
+    </PropertyGroup>
+
+  </Target>
+
+  <!--
+    ============================================================
+                                        _DeploymentGenerateLauncher
+
+    Generates Launcher if needed
+    ============================================================
+    -->
+  <Target
+      Name="_DeploymentGenerateLauncher"
+      Condition="'$(GenerateClickOnceManifests)'=='true' and '$(_DeploymentLauncherBased)' == 'true'">
+
+    <!-- 
+      If apphost based built EXE is found, use that as the Launcher.exe's entry point otherwise
+      use the built DLL as the entry point
+    -->
+    <ItemGroup Condition="'$(UseAppHost)' == 'true' and '$(_IsExecutable)' == 'true' and exists('$(AppHostIntermediatePath)')">
+      <EntryPointForLauncher Include="$(AppHostIntermediatePath)"/>
+      <ContentWithTargetPath Include="@(EntryPointForLauncher)"/>
+    </ItemGroup>
+    <ItemGroup Condition="'$(EntryPointForLauncher)'==''">
+      <EntryPointForLauncher Include="$(_DeploymentManifestEntryPoint)"/>
+    </ItemGroup>
+
+    <!-- Generates Launcher and obtains its Framework version and moniker -->
+    <GenerateLauncher
+        AssemblyName="$(_DeploymentApplicationManifestIdentity)"
+        EntryPoint="@(EntryPointForLauncher)"
+        OutputPath="$(IntermediateOutputPath)"
+        VisualStudioVersion="$(VisualStudioVersion)">
+
+      <Output TaskParameter="OutputEntryPoint" ItemName="_DeploymentManifestLauncherEntryPoint"/>
+    </GenerateLauncher>
+
+    <!--
+      .NET Core ClickOnce deployments use Launcher, which targets .NET FX 4.5 as the minimum
+      supported ClickOnce runtime version on target user's machine.
+
+      TargetFramework Verion and Moniker properties are used in Deployment manifest generation
+      task to set compatibleFrameworks element, which needs to match Launcher's target version.
+
+      Version can be overriden with DeploymentManifestTargetFrameworkVersionOverride property.
+    -->
+    <PropertyGroup>
+      <_DeploymentManifestTargetFrameworkVersion Condition="'$(DeploymentManifestTargetFrameworkVersionOverride)' == ''">v4.5</_DeploymentManifestTargetFrameworkVersion>
+      <_DeploymentManifestTargetFrameworkVersion Condition="'$(DeploymentManifestTargetFrameworkVersionOverride)' != ''">$(DeploymentManifestTargetFrameworkVersionOverride)</_DeploymentManifestTargetFrameworkVersion>
+      <_DeploymentManifestTargetFrameworkMoniker>.NETFramework,Version=$(_DeploymentManifestTargetFrameworkVersion)</_DeploymentManifestTargetFrameworkMoniker>
+    </PropertyGroup>
+
+    <!-- Sign Launcher EXE -->
+    <SignFile
+        CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)"
+        TimestampUrl="$(ManifestTimestampUrl)"
+        SigningTarget="@(_DeploymentManifestLauncherEntryPoint)"
+        TargetFrameworkVersion="$(TargetFrameworkVersion)"
+        Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
+
+    <!--
+      Replace entry-point with Launcher and move original project's entry-point to content group.
+    -->
+    <ItemGroup>
+      <ContentWithTargetPath Include="@(_DeploymentManifestEntryPoint)"/>
+      <_DeploymentManifestEntryPoint Remove="@(_DeploymentManifestEntryPoint)"/>
+      <_DeploymentManifestEntryPoint Include="@(_DeploymentManifestLauncherEntryPoint)"/>
+    </ItemGroup>
+  </Target>
+
   <!--
     ============================================================
                                         _DeploymentComputeNativeManifestInfo
@@ -3966,6 +4056,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
+  <PropertyGroup>
+    <DeploymentComputeClickOnceManifestInfoDependsOn>
+      CleanPublishFolder;
+      _DeploymentGenerateTrustInfo
+      $(DeploymentComputeClickOnceManifestInfoDependsOn)
+    </DeploymentComputeClickOnceManifestInfoDependsOn>
+  </PropertyGroup>
+
   <!--
     ============================================================
                                         _DeploymentComputeClickOnceManifestInfo
@@ -3973,12 +4071,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     Compute info for  ClickOnce manifest generation
     ============================================================
     -->
+
   <Target
       Name="_DeploymentComputeClickOnceManifestInfo"
       Condition="'$(GenerateClickOnceManifests)'=='true'"
-      DependsOnTargets="
-            CleanPublishFolder;
-            _DeploymentGenerateTrustInfo">
+      DependsOnTargets="$(DeploymentComputeClickOnceManifestInfoDependsOn)">
 
     <!-- Grab just the serialization assemblies for a referenced assembly.  There may also be a symbols file in ReferenceRelatedPaths -->
     <ItemGroup>
@@ -4000,10 +4097,24 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <IsPrimary>true</IsPrimary>
       </_DeploymentReferencePaths>
       <_DeploymentReferencePaths Include="@(_DeploymentReferencePaths);@(_CopyLocalFalseRefPathsWithExclusion)" />
+    </ItemGroup>
+
+    <!-- Include managed references in clickonce manifest only if single file publish is false -->
+    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
       <_ManifestManagedReferences Include="@(_DeploymentReferencePaths);@(ReferenceDependencyPaths);@(_SGenDllsRelatedToCurrentDll);@(SerializationAssembly);@(ReferenceCOMWrappersToCopyLocal)"
                                Exclude="@(_SatelliteAssemblies);@(_ReferenceScatterPaths);@(_ExcludedAssembliesFromManifestGeneration)" />
     </ItemGroup>
 
+    <!-- Include the following files in clickonce manifest only if single file publish is false -->
+    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
+      <ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce)"/>
+    </ItemGroup>
+
+    <!-- For single file publish, we only need to include the SF EXE in the clickonce manifest -->
+    <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
+      <ClickOnceFiles Include="$(PublishedSingleFilePath)"/>
+    </ItemGroup>
+
     <!-- Copy the application executable from Obj folder to app.publish folder.
     This is being done to avoid Windows Forms designer memory issues that can arise while operating directly on files located in Obj directory. -->
     <Copy
@@ -4023,16 +4134,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Create list of items for manifest generation -->
     <ResolveManifestFiles
-        TargetFrameworkVersion="$(TargetFrameworkVersion)"
-        SigningManifests="$(SignManifests)"
+        AssemblyName="$(_DeploymentApplicationManifestIdentity)"
         EntryPoint="@(_DeploymentClickOnceApplicationExecutable)"
         ExtraFiles="@(_DebugSymbolsIntermediatePath);$(IntermediateOutputPath)$(TargetName).xml;@(_ReferenceRelatedPaths)"
-        Files="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath)"
+        Files="@(ClickOnceFiles)"
+        LauncherBasedDeployment="$(_DeploymentLauncherBased)"
         ManagedAssemblies="@(_ManifestManagedReferences)"
         NativeAssemblies="@(NativeReferenceFile);@(_DeploymentNativePrerequisite)"
         PublishFiles="@(PublishFile)"
         SatelliteAssemblies="@(_SatelliteAssemblies)"
-        TargetCulture="$(TargetCulture)">
+        SigningManifests="$(SignManifests)"
+        TargetCulture="$(TargetCulture)"
+        TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
+        TargetFrameworkVersion="$(TargetFrameworkVersion)">
 
       <Output TaskParameter="OutputAssemblies" ItemName="_DeploymentManifestDependenciesUnfiltered"/>
       <Output TaskParameter="OutputFiles" ItemName="_DeploymentManifestFiles"/>
@@ -4051,6 +4165,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_DeploymentManifestType>ClickOnce</_DeploymentManifestType>
     </PropertyGroup>
 
+    <!--
+      Manifest platform should always be MSIL for Launcher-based deployments, as the Launcher is MSIL.
+      Do not set _DeploymentPlatformTarget property in Launcher case - this is interpreted as MSIL,
+      by GenerateApplicationManifest and GenerateDeploymentManifest tasks.
+      Otherwise, set it to PlatformTarget.
+    -->
+    <PropertyGroup>
+      <_DeploymentPlatformTarget Condition="'$(_DeploymentLauncherBased)' != 'true'">$(PlatformTarget)</_DeploymentPlatformTarget>
+    </PropertyGroup>
+
     <!-- Obtain manifest version from ApplicationVersion and ApplicationRevision properties -->
     <FormatVersion Version="$(ApplicationVersion)" Revision="$(ApplicationRevision)">
       <Output TaskParameter="OutputVersion" PropertyName="_DeploymentManifestVersion"/>
@@ -4127,18 +4251,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           EntryPoint="@(_DeploymentResolvedDeploymentManifestEntryPoint)"
           ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)"
           Install="$(Install)"
+          LauncherBasedDeployment="$(_DeploymentLauncherBased)"
           MapFileExtensions="$(MapFileExtensions)"
           MaxTargetPath="$(MaxTargetPath)"
           MinimumRequiredVersion="$(_DeploymentBuiltMinimumRequiredVersion)"
           OutputManifest="@(DeployManifest)"
-          Platform="$(PlatformTarget)"
+          Platform="$(_DeploymentPlatformTarget)"
           Product="$(ProductName)"
           Publisher="$(PublisherName)"
           SuiteName="$(SuiteName)"
           SupportUrl="$(_DeploymentFormattedSupportUrl)"
           TargetCulture="$(TargetCulture)"
-          TargetFrameworkVersion="$(TargetFrameworkVersion)"
-          TargetFrameworkMoniker="$(TargetFrameworkMoniker)"
+          TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)"
+          TargetFrameworkMoniker="$(_DeploymentManifestTargetFrameworkMoniker)"
           TrustUrlParameters="$(TrustUrlParameters)"
           UpdateEnabled="$(UpdateEnabled)"
           UpdateInterval="$(_DeploymentBuiltUpdateInterval)"
@@ -5464,6 +5589,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Copy files to publish folder -->
     <Copy
+        Condition="'$(PublishSingleFile)' != 'true'"
         SourceFiles=
                 "@(_ApplicationManifestFinal);
                 @(_DeploymentResolvedManifestEntryPoint);
@@ -5494,9 +5620,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
         UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)"
         UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)"
-        Condition="'%(_DeploymentManifestDependencies.DependencyType)'=='Install'"/>
+        Condition="'$(PublishSingleFile)' != 'true' and '%(_DeploymentManifestDependencies.DependencyType)'=='Install'"/>
 
     <Copy
+        Condition="'$(PublishSingleFile)' != 'true'"
         SourceFiles="@(_ReferenceScatterPaths)"
         DestinationFiles="@(_ReferenceScatterPaths->'$(_DeploymentApplicationDir)%(Filename)%(Extension)$(_DeploymentFileMappingExtension)')"
         SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
@@ -5507,6 +5634,28 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)"
             />
 
+    <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
+      <PublishedSingleFileToBeCopied Include="$(PublishedSingleFilePath)" TargetPath="$(PublishedSingleFileName)"/>
+    </ItemGroup>
+
+    <!-- For single-file publish case, we need to only copy the clickonce manifest, manifest entry point (launcher) and the SF EXE -->
+    <Copy
+        Condition="'$(PublishSingleFile)' == 'true'"
+        SourceFiles=
+                "@(_ApplicationManifestFinal);
+                 @(_DeploymentResolvedManifestEntryPoint);
+                 @(PublishedSingleFileToBeCopied);"
+        DestinationFiles=
+                "@(_ApplicationManifestFinal->'$(_DeploymentApplicationDir)%(TargetPath)');
+                 @(_DeploymentManifestEntryPoint->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');
+                 @(PublishedSingleFileToBeCopied->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)')"
+        SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
+        OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
+        Retries="$(CopyRetryCount)"
+        UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)"
+        UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)"
+        RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"/>
+
     <FormatUrl InputUrl="$(_DeploymentApplicationUrl)">
       <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedApplicationUrl"/>
     </FormatUrl>
@@ -5562,7 +5711,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <!-- Update entry point path in deploy manifest -->
     <UpdateManifest
         ApplicationPath="$(_DeploymentApplicationFolderName)\$(_DeploymentTargetApplicationManifestFileName)"
-        TargetFrameworkVersion="$(TargetFrameworkVersion)"
+        TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)"
         ApplicationManifest="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)"
         InputManifest="$(OutDir)$(TargetDeployManifestFileName)"
         OutputManifest="$(PublishDir)$(TargetDeployManifestFileName)">
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index 32f8ed42f3c..9f7f4620cd2 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -116,6 +116,7 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateBindingRedirects"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateBootstrapper"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateDeploymentManifest"            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateLauncher"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index 3fdf14ffd43..e73626a691e 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -74,8 +74,7 @@ public override bool Execute()
 
             if ((AssemblyListFile?.ItemSpec.Length > 0))
             {
-                cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache)) ??
-                            new AssemblyRegistrationCache();
+                cacheFile = StateFileBase.DeserializeCache<AssemblyRegistrationCache>(AssemblyListFile.ItemSpec, Log) ?? new AssemblyRegistrationCache();
             }
 
             bool taskReturnValue = true;
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 3632a916d83..ccacacb77d5 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -167,7 +167,7 @@ internal override void SerializeCache(string stateFile, TaskLoggingHelper log)
         /// </summary>
         internal static ResGenDependencies DeserializeCache(string stateFile, bool useSourcePath, TaskLoggingHelper log)
         {
-            var retVal = (ResGenDependencies)DeserializeCache(stateFile, log, typeof(ResGenDependencies)) ?? new ResGenDependencies();
+            var retVal = DeserializeCache<ResGenDependencies>(stateFile, log) ?? new ResGenDependencies();
 
             // Ensure that the cache is properly initialized with respect to how resgen will 
             // resolve linked files within .resx files.  ResGen has two different
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 2fd1310d355..043e1f54005 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -325,7 +325,7 @@ public override bool Execute()
             allProjectRefs = new List<ComReferenceInfo>();
             allDependencyRefs = new List<ComReferenceInfo>();
 
-            _timestampCache = (ResolveComReferenceCache)StateFileBase.DeserializeCache(StateFile, Log, typeof(ResolveComReferenceCache));
+            _timestampCache = StateFileBase.DeserializeCache<ResolveComReferenceCache>(StateFile, Log);
 
             if (_timestampCache?.ToolPathsMatchCachePaths(_tlbimpPath, _aximpPath) != true)
             {
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index ab41808f881..dfe0192be3d 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -46,6 +46,7 @@ public sealed class ResolveManifestFiles : TaskExtension
         private CultureInfo _targetCulture;
         private bool _includeAllSatellites;
 
+        private string _targetFrameworkIdentifier;
         private string _targetFrameworkVersion;
         // if signing manifests is on and not all app files are included, then the project can't be published.
         private bool _canPublish;
@@ -109,6 +110,10 @@ public ITaskItem[] SatelliteAssemblies
 
         public bool SigningManifests { get; set; }
 
+        public string AssemblyName { get; set; }
+
+        public bool LauncherBasedDeployment {get; set; } = false;
+
         public string TargetFrameworkVersion
         {
             get
@@ -122,6 +127,19 @@ public string TargetFrameworkVersion
             set => _targetFrameworkVersion = value;
         }
 
+        public string TargetFrameworkIdentifier
+        {
+            get
+            {
+                if (string.IsNullOrEmpty(_targetFrameworkIdentifier))
+                {
+                    return Constants.DotNetFrameworkIdentifier;
+                }
+                return _targetFrameworkIdentifier;
+            }
+            set => _targetFrameworkIdentifier = value;
+        }
+
         #endregion
 
         public override bool Execute()
@@ -238,13 +256,27 @@ private static ITaskItem CreateAssemblyItem(ITaskItem item, string group, string
         }
 
         // Creates an output item for a file, with optional Group and IsData attributes.
-        private static ITaskItem CreateFileItem(ITaskItem item, string group, string targetPath, string includeHash, bool isDataFile)
+        private ITaskItem CreateFileItem(ITaskItem item, string group, string targetPath, string includeHash, bool isDataFile)
         {
             ITaskItem outputItem = new TaskItem(item.ItemSpec);
             item.CopyMetadataTo(outputItem);
             if (String.IsNullOrEmpty(targetPath))
             {
-                targetPath = GetItemTargetPath(outputItem);
+                targetPath = Path.GetFileName(item.ItemSpec);
+                //
+                // .NETCore Launcher.exe based deployment: If the file is apphost.exe, we need to set 'TargetPath' metadata
+                // to {assemblyname}.exe so that the file gets published as {assemblyname}.exe and not apphost.exe.
+                //
+                if (LauncherBasedDeployment && 
+                    targetPath.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) &&
+                    !String.IsNullOrEmpty(AssemblyName))
+                {
+                    targetPath = AssemblyName;
+                }
+                else
+                {
+                    targetPath = GetItemTargetPath(outputItem);
+                }
             }
             outputItem.SetMetadata(ItemMetadataNames.targetPath, targetPath);
             if (!String.IsNullOrEmpty(group) && !isDataFile)
@@ -630,7 +662,14 @@ private bool IsFiltered(ITaskItem item)
                 return true;
             }
 
-            if (identity?.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion) == true)
+            if (String.Equals(TargetFrameworkIdentifier, Constants.DotNetCoreAppIdentifier, StringComparison.InvariantCultureIgnoreCase))
+            {
+                if (identity?.IsInFramework(Constants.DotNetCoreIdentifier, null) == true)
+                {
+                    return true;
+                }
+            }
+            else if (identity?.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion) == true)
             {
                 return true;
             }
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 9fe38b21d0f..db6c18091f7 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -452,7 +452,7 @@
     <comment>{StrBegin="MSB3101: "}</comment>
   </data>
   <data name="General.StateFileAlreadyPresent">
-    <value>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</value>
+    <value>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</value>
     <comment>{StrBegin="MSB3667: "}</comment>
   </data>
   <data name="General.DuplicateItemsNotSupported">
@@ -2836,6 +2836,31 @@
     <value>MSB3954: Failed to compute hash for file '{0}' because it does not exist or is inaccessible.</value>
     <comment>{StrBegin="MSB3954: "}</comment>
   </data>
+
+  <!--
+        MSB3961 - MSB3970   Task: GenerateLauncher
+        If this bucket overflows, pls. contact 'vsppbdev'.
+  -->
+  <data name="GenerateLauncher.CopyError">
+    <value>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</value>
+    <comment>{StrBegin="MSB3961: "}</comment>
+  </data>
+  <data name="GenerateLauncher.General">
+    <value>MSB3962: An error occurred generating a launcher: {0}</value>
+    <comment>{StrBegin="MSB3962: "}</comment>
+  </data>
+  <data name="GenerateLauncher.InvalidInput">
+    <value>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</value>
+    <comment>{StrBegin="MSB3963: "}</comment>
+  </data>
+  <data name="GenerateLauncher.MissingLauncherExe">
+    <value>MSB3964: Could not find required file '{0}'.</value>
+    <comment>{StrBegin="MSB3964: "}</comment>
+  </data>
+  <data name="GenerateLauncher.NoOutputPath">
+    <value>MSB3965: No output path specified in build settings.</value>
+    <comment>{StrBegin="MSB3965: "}</comment>
+  </data>
   <!--
         The tasks message bucket is: MSB3001 - MSB3999
 
@@ -2919,6 +2944,7 @@
             MSB3931 - MSB3940   Task: Unzip
             MSB3941 - MSB3950   Task: ZipDirectory
             MSB3951 - MSB3960   Task: VerifyFileHash
+            MSB3961 - MSB3970   Task: GenerateLauncher
 
             MSB4000 - MSB4200   Portable targets & tasks (vsproject\flavors\portable\msbuild)
             MSB9000 - MSB9900   MSBuild targets files (C++)
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index b171796dc7c..563837c2983 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: UpozornÄnÃ­ ovÄÅenÃ­ Xml v souboru {0}: {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: Odkaz {0} nepovoluje ÄÃ¡steÄnÄ dÅ¯vÄryhodnÃ© volajÃ­cÃ­.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 89578baaba2..715c0733ef5 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: XML-Validierungswarnung in der Datei "{0}": {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: Der Verweis "{0}" lÃ¤sst Aufrufer, die nur teilweise vertrauenswÃ¼rdig sind, nicht zu.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.en.xlf b/src/Tasks/Resources/xlf/Strings.en.xlf
index 6a3d5806ba8..44c7f33761d 100644
--- a/src/Tasks/Resources/xlf/Strings.en.xlf
+++ b/src/Tasks/Resources/xlf/Strings.en.xlf
@@ -555,8 +555,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -824,6 +824,31 @@
         <target state="new">MSB3160: Xml Validation warning in file '{0}': {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="new">MSB3177: Reference '{0}' does not allow partially trusted callers.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 1f0c1ed2ae5..5f4cc6b1206 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: Advertencia de validaciÃ³n XML en el archivo '{0}': {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: La referencia '{0}' no permite llamadores de confianza parcial.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 593b3c2d101..d2f869f2deb 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: Avertissement de validation XML dans le fichier '{0}'Â : {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: La rÃ©fÃ©rence '{0}' n'autorise pas les appelants dont le niveau de confiance n'est pas suffisant.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index bde5690037c..543de47e98a 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: avviso di convalida XML nel file '{0}': {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: il riferimento '{0}' non consente chiamanti parzialmente attendibili.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 262252ade00..83d9e27593c 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: ãã¡ã¤ã« '{0}' ã§ã® XML æ¤è¨¼è­¦åã§ã: {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: åç§ '{0}' ã¯é¨åçã«ä¿¡é ¼ãããå¼ã³åºãå´ãè¨±å¯ãã¾ããã</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 66e70e94abd..68a8a6e3a7e 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: '{0}' íì¼ìì XML ì í¨ì± ê²ì¬ ê²½ê³ ê° ë°ìíìµëë¤. {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: '{0}' ì°¸ì¡°ìë ë¶ë¶ì ì¼ë¡ ì ë¢°í  ì ìë í¸ì¶ìë¥¼ ì¬ì©í  ì ììµëë¤.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index e622142e07a..ac00b1d86de 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: OstrzeÅ¼enie walidacji kodu xml w pliku '{0}': {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: OdwoÅanie '{0}' nie zezwala na dostÄp czÄÅciowo zaufanych wywoÅaÅ.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 41d31d7e125..a5bfa091b68 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: Aviso de validaÃ§Ã£o de XML no arquivo "{0}": {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: A referÃªncia "{0}" nÃ£o admite chamadores parcialmente confiÃ¡veis.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 2ce32973f25..ab898336b0b 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: ÐÑÐµÐ´ÑÐ¿ÑÐµÐ¶Ð´ÐµÐ½Ð¸Ðµ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸ Xml Ð² ÑÐ°Ð¹Ð»Ðµ "{0}": {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: Ð¡ÑÑÐ»ÐºÐ° "{0}" Ð½Ðµ Ð´Ð¾Ð¿ÑÑÐºÐ°ÐµÑ ÑÐ°ÑÑÐ¸ÑÐ½Ð¾ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½ÑÐµ Ð²ÑÐ·ÑÐ²Ð°ÑÑÐ¸Ðµ ÑÑÐ¾ÑÐ¾Ð½Ñ.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 88a70cb7279..aa243572d65 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: '{0}' dosyasÄ±nda Xml DoÄrulamasÄ± uyarÄ±sÄ± oluÅtu: {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: '{0}' baÅvurusu, kÄ±smen gÃ¼venilen Ã§aÄÄ±ranlara izin vermiyor.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index c9055d2694c..af18c448974 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: æä»¶â{0}âä¸­ç XML éªè¯è­¦å: {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: å¼ç¨â{0}âä¸åè®¸é¨åä¿¡ä»»çè°ç¨æ¹ã</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 71104cddb3e..84e099a8dd6 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -510,8 +510,8 @@
         <note />
       </trans-unit>
       <trans-unit id="General.StateFileAlreadyPresent">
-        <source>MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</source>
-        <target state="new">MSB3101: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "_CacheOutputPath" field of RAR.</target>
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running RAR normally, do not set the "CacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -779,6 +779,31 @@
         <target state="translated">MSB3160: æªæ¡ '{0}' ä¸­ç¼ç XML é©è­è­¦å: {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: åè '{0}' ä¸åè¨±é¨åä¿¡ä»»çå¼å«ç«¯ã</target>
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index ec09003778a..8fc4ee04b40 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using System.Text.Json;
 
 namespace Microsoft.Build.Tasks
 {
@@ -65,9 +64,9 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
         /// <summary>
         /// Reads the specified file from disk into a StateFileBase derived object.
         /// </summary>
-        internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelper log, Type requiredReturnType, bool logWarnings = true)
+        internal static T DeserializeCache<T>(string stateFile, TaskLoggingHelper log, bool logWarnings = true) where T : StateFileBase
         {
-            StateFileBase retVal = null;
+            T retVal = null;
             object deserializedObject = null;
 
             // First, we read the cache from disk if one exists, or if one does not exist
@@ -80,7 +79,7 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                     {
                         var formatter = new BinaryFormatter();
                         deserializedObject = formatter.Deserialize(s);
-                        retVal = deserializedObject as StateFileBase;
+                        retVal = deserializedObject as T;
                     }
                     // If the deserialized object is null then there would be no cast error but retVal would still be null
                     // only log the message if there would have been a cast error
@@ -91,7 +90,7 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                         // If there is an invalid cast, a message rather than a warning should be emitted.
                         log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
                     }
-                    else if (retVal != null && (!requiredReturnType.IsInstanceOfType(retVal)))
+                    else if (retVal != null && !(retVal is T))
                     {
                         if (logWarnings)
                         {
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 9c98656c05c..3746c5fe606 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
@@ -15,7 +14,10 @@
 using System.Text.Encodings.Web;
 using System.Text.Json;
 using System.Text.Json.Serialization;
+using System.Security.Permissions;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyDependency;
 using Microsoft.Build.Utilities;
 
@@ -36,7 +38,7 @@ internal sealed class SystemState
         /// <summary>
         /// Cache at the SystemState instance level. It is serialized and reused between instances.
         /// </summary>
-        private Hashtable instanceLocalFileStateCache = new Hashtable(StringComparer.OrdinalIgnoreCase);
+        internal Dictionary<string, FileState> instanceLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// LastModified information is purely instance-local. It doesn't make sense to
@@ -113,7 +115,7 @@ internal sealed class SystemState
         /// Class that holds the current file state.
         /// </summary>
         [Serializable]
-        private sealed class FileState
+        internal sealed class FileState
         {
             /// <summary>
             /// The assemblies that this file depends on.
@@ -149,25 +151,25 @@ internal FileState()
             /// Gets the last modified date.
             /// </summary>
             /// <value></value>
-            public DateTime LastModified { get; set; }
+            internal DateTime LastModified { get; set; }
 
             /// <summary>
             /// Get or set the assemblyName.
             /// </summary>
             /// <value></value>
-            public AssemblyNameExtension Assembly { get; set; }
+            internal AssemblyNameExtension Assembly { get; set; }
 
             /// <summary>
             /// Get or set the runtimeVersion
             /// </summary>
             /// <value></value>
-            public string RuntimeVersion { get; set; }
+            internal string RuntimeVersion { get; set; }
 
             /// <summary>
             /// Get or set the framework name the file was built against
             /// </summary>
             [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Could be used in other assemblies")]
-            public FrameworkName FrameworkNameAttribute
+            internal FrameworkName FrameworkNameAttribute
             {
                 get { return frameworkName; }
                 set { frameworkName = value; }
@@ -176,7 +178,7 @@ public FrameworkName FrameworkNameAttribute
             /// <summary>
             /// Get or set the ID of this assembly. Used to verify it is the same version.
             /// </summary>
-            public Guid ModuleVersionID { get; set; }
+            internal Guid ModuleVersionID { get; set; }
         }
 
         internal sealed class Converter : JsonConverter<SystemState>
@@ -399,10 +401,10 @@ public SystemState()
 
         /// <summary>
         /// Set the target framework paths.
-        /// This is used to optimize IO in the case of files requested from one 
+        /// This is used to optimize IO in the case of files requested from one
         /// of the FX folders.
         /// </summary>
-        /// <param name="installedAssemblyTableInfos"></param>
+        /// <param name="installedAssemblyTableInfos">List of Assembly Table Info.</param>
         internal void SetInstalledAssemblyInformation
         (
             AssemblyTableInfo[] installedAssemblyTableInfos
@@ -418,6 +420,7 @@ AssemblyTableInfo[] installedAssemblyTableInfos
         internal bool IsDirty
         {
             get { return isDirty; }
+            set { isDirty = value; }
         }
 
         /// <summary>
@@ -514,8 +517,7 @@ private FileState GetFileState(string path)
         private FileState ComputeFileStateFromCachesAndDisk(string path)
         {
             DateTime lastModified = GetAndCacheLastModified(path);
-            FileState cachedInstanceFileState = (FileState)instanceLocalFileStateCache[path];
-            bool isCachedInInstance = cachedInstanceFileState != null;
+            bool isCachedInInstance = instanceLocalFileStateCache.TryGetValue(path, out FileState cachedInstanceFileState);
             bool isCachedInProcess =
                 s_processWideFileStateCache.TryGetValue(path, out FileState cachedProcessFileState);
             
@@ -682,42 +684,41 @@ out fileState.frameworkName
         /// <summary>
         /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.
         /// </summary>
-        internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo)
+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, Guid> calculateMvid, Func<string, bool> fileExists)
         {
             SystemState retVal = new SystemState();
             retVal.SetGetLastWriteTime(getLastWriteTime);
             retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);
             retVal.isDirty = stateFiles.Length > 0;
             HashSet<string> assembliesFound = new HashSet<string>();
+            calculateMvid ??= CalculateMvid;
+            fileExists ??= FileSystems.Default.FileExists;
 
-            foreach (string stateFile in stateFiles)
+            foreach (ITaskItem stateFile in stateFiles)
             {
                 // Verify that it's a real stateFile; log message but do not error if not
                 var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
                 deserializeOptions.Converters.Add(new SystemState.Converter());
                 SystemState sysBase = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(stateFile), deserializeOptions);
-                foreach (string relativePath in sysBase.instanceLocalFileStateCache.Keys)
+                if (sysBase == null)
                 {
+                    continue;
+                }
+
+                foreach (KeyValuePair<string, FileState> kvp in sysBase.instanceLocalFileStateCache)
+                {
+                    string relativePath = kvp.Key;
                     if (!assembliesFound.Contains(relativePath))
                     {
-                        FileState fileState = (FileState)sysBase.instanceLocalFileStateCache[relativePath];
+                        FileState fileState = kvp.Value;
                         // Verify that the assembly is correct
-                        Guid mvid;
-                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile), relativePath));
-                        if (File.Exists(fullPath))
+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));
+                        if (fileExists(fullPath) && calculateMvid(fullPath).Equals(fileState.ModuleVersionID))
                         {
-                            using (var reader = new PEReader(File.OpenRead(fullPath)))
-                            {
-                                var metadataReader = reader.GetMetadataReader();
-                                mvid = metadataReader.GetGuid(metadataReader.GetModuleDefinition().Mvid);
-                            }
-                            if (mvid.Equals(fileState.ModuleVersionID))
-                            {
-                                // Correct file path and timestamp
-                                fileState.LastModified = retVal.getLastWriteTime(fullPath);
-                                retVal.instanceLocalFileStateCache[fullPath] = fileState;
-                                assembliesFound.Add(relativePath);
-                            }
+                            // Correct file path and timestamp
+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);
+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;
+                            assembliesFound.Add(relativePath);
                         }
                     }
                 }
@@ -729,20 +730,18 @@ internal static SystemState DeserializePrecomputedCaches(string[] stateFiles, Ta
         /// <summary>
         /// Modifies this object to be more portable across machines, then writes it to stateFile.
         /// </summary>
-        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)
+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log, Func<string, Guid> calculateMvid)
         {
-            Hashtable newInstanceLocalFileStateCache = new Hashtable();
-            foreach (string path in instanceLocalFileStateCache.Keys)
+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);
+            calculateMvid ??= CalculateMvid;
+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)
             {
                 // Add MVID to allow us to verify that we are using the same assembly later
-                FileState fileState = (FileState)instanceLocalFileStateCache[path];
-                using (var reader = new PEReader(File.OpenRead(path)))
-                {
-                    var metadataReader = reader.GetMetadataReader();
-                    fileState.ModuleVersionID = metadataReader.GetGuid(metadataReader.GetModuleDefinition().Mvid);
-                }
+                string absolutePath = kvp.Key;
+                FileState fileState = kvp.Value;
+                fileState.ModuleVersionID = calculateMvid(absolutePath);
 
-                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), path);
+                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), absolutePath);
                 newInstanceLocalFileStateCache[relativePath] = fileState;
             }
             instanceLocalFileStateCache = newInstanceLocalFileStateCache;
@@ -756,6 +755,15 @@ internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)
             File.WriteAllText(stateFile, JsonSerializer.Serialize(this, options));
         }
 
+        private static Guid CalculateMvid(string path)
+        {
+            using (var reader = new PEReader(File.OpenRead(path)))
+            {
+                var metadataReader = reader.GetMetadataReader();
+                return metadataReader.GetGuid(metadataReader.GetModuleDefinition().Mvid);
+            }
+        }
+
             /// <summary>
             /// Cached implementation of GetDirectories.
             /// </summary>
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index cbcde5d8ef8..9160e78256b 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -49,7 +49,7 @@ public override bool Execute()
 
             if (AssemblyListFile != null)
             {
-                cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache));
+                cacheFile = StateFileBase.DeserializeCache<AssemblyRegistrationCache>(AssemblyListFile.ItemSpec, Log);
 
                 // no cache file, nothing to do. In case there was a problem reading the cache file, we can't do anything anyway.
                 if (cacheFile == null)
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index e8b84435ca2..840d2bcc37e 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -88,9 +88,6 @@
     <Compile Include="..\Shared\ExceptionHandling.cs">
       <Link>Shared\ExceptionHandling.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\EscapingStringExtensions\EscapingStringExtensions.cs">
-      <Link>Shared\EscapingStringExtensions\EscapingStringExtensions.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\FileUtilities.cs">
       <Link>Shared\FileUtilities.cs</Link>
     </Compile>
