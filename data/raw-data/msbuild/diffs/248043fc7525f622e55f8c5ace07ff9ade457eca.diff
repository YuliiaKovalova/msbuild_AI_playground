diff --git a/.editorconfig b/.editorconfig
index 90ed95160d4..c619a8f04ec 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -401,3 +401,10 @@ dotnet_diagnostic.IDE0270.severity = suggestion
 
 # naming rule violation
 dotnet_diagnostic.IDE1006.severity = suggestion
+
+# Use primary constructor
+dotnet_diagnostic.IDE0290.severity = suggestion
+
+# Collection initialization can be simplified
+dotnet_diagnostic.IDE0300.severity = suggestion
+dotnet_diagnostic.IDE0301.severity = suggestion
diff --git a/.exp-insertions.yml b/.exp-insertions.yml
new file mode 100644
index 00000000000..e3e22653a53
--- /dev/null
+++ b/.exp-insertions.yml
@@ -0,0 +1,127 @@
+# Pipeline creates a dotnet with experimental msbuild dlls.
+
+trigger: none # Prevents this pipeline from triggering on check-ins
+pr: none # don't run this on PR as well
+
+parameters:
+  # Dotnet installer channel from where to take the latest dotnet bits.
+  - name: DotnetInstallerChannel
+    displayName: Dotnet installer channel
+    type: string
+  # Branch from the MSBuild Build CI pipeline. Default: main
+  # Top run for the branch would be used to create an experimental insertion. 
+  - name: MSBuildBranch
+    displayName: MSBuild Branch
+    type: string
+    default: 'refs/heads/main'
+  # BuildID from the MSBuild Build CI pipeline. Overrides the choice of MSBuildBranch parameter 
+  - name: MSBuildBuildID
+    displayName: MSBuild CI Run Override
+    type: string
+    default: 'default'
+
+variables:
+  - name: _MsBuildCiPipelineId
+    value: 9434
+
+pool:
+  vmImage: windows-latest
+
+steps:
+- powershell: |
+    mkdir '$(System.ArtifactsDirectory)/installer'
+
+    $dotnetChannel = '${{parameters.DotnetInstallerChannel}}'
+    $sdks = "dotnet-sdk-win-x64.zip", "dotnet-sdk-linux-x64.tar.gz"
+
+    foreach ($sdk in $sdks)
+    {
+      Write-Host "Downloading dotnet $sdk from channel $dotnetChannel"
+      Invoke-WebRequest `
+        -Uri "https://aka.ms/dotnet/$dotnetChannel/daily/$sdk" `
+        -OutFile "$(System.ArtifactsDirectory)/installer/$sdk"
+    }
+    mkdir '$(Pipeline.Workspace)/artifacts'
+    
+  displayName: Download latest dotnet sdks
+
+# Download latest build artifacts for a branch from MSBuild Build CI
+- ${{ if eq(parameters.MSBuildBuildID, 'default') }}:
+  - task: DownloadBuildArtifacts@1
+    inputs:
+      buildType: specific
+      project: DevDiv
+      pipeline: $(_MsBuildCiPipelineId) 
+      buildVersionToDownload: latestFromBranch
+      branchName: '${{parameters.MSBuildBranch}}'  
+      artifactName: bin
+      downloadPath: '$(System.ArtifactsDirectory)/msbuild/artifacts/bin'
+      itemPattern: "MSBuild.Bootstrap/**"  
+    displayName: Download latest msbuild from branch
+
+# Download build artifacts for MSBuild Build CI specific build
+- ${{ if ne(parameters.MSBuildBuildID, 'default') }}:
+  - task: DownloadBuildArtifacts@1
+    inputs:
+      buildType: specific
+      project: DevDiv
+      pipeline: $(_MsBuildCiPipelineId) 
+      buildVersionToDownload: specific
+      buildId: ${{parameters.MSBuildBuildID}} 
+      artifactName: bin
+      downloadPath: '$(System.ArtifactsDirectory)/msbuild/artifacts/bin'
+      itemPattern: "MSBuild.Bootstrap/**"
+    displayName: Download specified msbuild build
+    
+- powershell: |
+    $sdk = "dotnet-sdk-win-x64"
+
+    Write-Host "Extracting $(System.ArtifactsDirectory)/installer/$sdk.zip"
+    Expand-Archive "$(System.ArtifactsDirectory)/installer/$sdk.zip" -DestinationPath "$(Pipeline.Workspace)/exp-dotnet/$sdk"
+    
+    $dotnetDirectory = Get-ChildItem -Directory -Path "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk"
+    $dotnetVersion = $dotnetDirectory.Name
+    Write-Host "Detected dotnet version: $dotnetVersion"
+    
+    Write-Host "Updating MSBuild dlls."
+    $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
+      -destination "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk/$dotnetVersion" `
+      -bootstrapDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin/MSBuild.Bootstrap" `
+      -configuration Release `
+      -makeBackup $false
+    
+    Write-Host "Compressing dotnet sdk files"
+    Get-ChildItem -Path "$(Pipeline.Workspace)/exp-dotnet/$sdk" | Compress-Archive -DestinationPath "$(Pipeline.Workspace)/artifacts/$sdk.zip"
+
+  displayName: Dogfood msbuild dlls to dotnet sdk win-x64
+
+- powershell: |
+    $sdk = "dotnet-sdk-linux-x64"
+    
+    mkdir "$(Pipeline.Workspace)/exp-dotnet/$sdk"
+
+    Write-Host "Extracting $(System.ArtifactsDirectory)/installer/$sdk.tar.gz"
+    tar -xzvf "$(System.ArtifactsDirectory)/installer/$sdk.tar.gz" -C "$(Pipeline.Workspace)/exp-dotnet/$sdk"
+
+    $dotnetDirectory = Get-ChildItem -Directory -Path $(Pipeline.Workspace)/exp-dotnet/$sdk/sdk
+    $dotnetVersion = $dotnetDirectory.Name
+    Write-Host "Detected dotnet version: $dotnetVersion"
+    
+    Write-Host "Updating MSBuild dlls."
+    $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
+      -destination "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk/$dotnetVersion" `
+      -bootstrapDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin/MSBuild.Bootstrap" `
+      -configuration Release `
+      -makeBackup $false
+    
+    Write-Host "Compressing dotnet sdk files"
+    tar -czvf "$(Pipeline.Workspace)/artifacts/$sdk.tar.gz" -C "$(Pipeline.Workspace)/exp-dotnet/$sdk" .
+  displayName: Dogfood msbuild dlls to dotnet sdk linux-x64
+
+- task: PublishPipelineArtifact@1
+  inputs:
+    targetPath: '$(Pipeline.Workspace)/artifacts'
+    artifactName: ExperimentalDotnet
+    parallel: true
+  condition: always()
+  displayName: Publish crank assests artifacts
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 343cec26283..18e9d39f8f5 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -40,6 +40,8 @@ variables:
     value: true
   - name: Codeql.Enabled
     value: true
+  - ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+    - group: DotNet-MSBuild-SDLValidation-Params
 
 stages:
 - stage: build
@@ -294,3 +296,17 @@ stages:
       enableSymbolValidation: false
       enableSourceLinkValidation: false
       enableNugetValidation: false
+      SDLValidationParameters:
+        enable: true
+        continueOnError: false
+        params: ' -SourceToolsList @("policheck","credscan")
+        -TsaInstanceURL "$(_TsaInstanceURL)"
+        -TsaProjectName "$(_TsaProjectName)"
+        -TsaNotificationEmail "$(_TsaNotificationEmail)"
+        -TsaCodebaseAdmin "$(_TsaCodebaseAdmin)"
+        -TsaBugAreaPath "$(_TsaBugAreaPath)"
+        -TsaIterationPath "$(_TsaIterationPath)"
+        -TsaRepositoryName "dotnet-msbuild"
+        -TsaCodebaseName "dotnet-msbuild"
+        -TsaPublish $True
+        -PoliCheckAdditionalRunConfigParams @("UserExclusionPath < $(Build.SourcesDirectory)\eng\policheck_exclusions.xml")'
diff --git a/NuGet.config b/NuGet.config
index 4e9907ea835..d7187b4d64a 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -8,6 +8,7 @@
     <add key="dotnet6" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json" />
     <add key="dotnet8" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json" />
     <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
+    <add key="BuildXL" value="https://pkgs.dev.azure.com/ms/BuildXL/_packaging/BuildXL/nuget/v3/index.json" />
   </packageSources>
   <disabledPackageSources />
 </configuration>
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 402fe6eb556..9fb1d1cc7fc 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -26,8 +26,9 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 ### 17.8
 - [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
 - [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
-- [New serialization approach for transferring build exceptions between processes](https://github.com/dotnet/msbuild/pull/8779)
 - [Moving from SHA1 to SHA256 for Hash task](https://github.com/dotnet/msbuild/pull/8812)
+- [Deprecating custom derived BuildEventArgs](https://github.com/dotnet/msbuild/pull/8917) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
+
 
 ### 17.6
 - [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
@@ -68,4 +69,4 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Optimized immutable files up to date checks](https://github.com/dotnet/msbuild/pull/6974)
 - [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
 - [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
-- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
\ No newline at end of file
+- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index 02e1e308112..e6fee0282f8 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -229,6 +229,9 @@
     <Copy SourceFiles="@(NuGetSdkResolverManifest)"
           DestinationFolder="$(BootstrapDestination)SdkResolvers\Microsoft.Build.NuGetSdkResolver" />
 
+    <Copy SourceFiles="$(RuntimeIdentifierGraphPath)"
+          DestinationFolder="$(BootstrapDestination)" />
+
     <Copy SourceFiles="@(InstalledSdks)"
           DestinationFiles="@(InstalledSdks -> '$(BootstrapDestination)Sdks\%(RecursiveDir)%(Filename)%(Extension)')" />
 
diff --git a/eng/Packages.props b/eng/Packages.props
index 489ea061c95..ac8df77f629 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -25,7 +25,6 @@
     <PackageVersion Include="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
     <PackageVersion Include="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
     <PackageVersion Include="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
-    <PackageVersion Include="System.Security.Permissions" Version="$(SystemSecurityPermissionsVersion)" />
     <PackageVersion Include="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
     <PackageVersion Include="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
     <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
diff --git a/eng/Signing.props b/eng/Signing.props
index 66347f3d9d1..3e8e6dbf5cc 100644
--- a/eng/Signing.props
+++ b/eng/Signing.props
@@ -1,9 +1,11 @@
 <Project>
   <ItemGroup>
     <ItemsToSign Include="$(VisualStudioSetupInsertionPath)Microsoft.Build.UnGAC.exe" />
+
+    <FileSignInfo Include="RuntimeContracts.dll" CertificateName="3PartySHA2" />
   </ItemGroup>
-    
+
   <PropertyGroup>
     <UseDotNetCertificate>true</UseDotNetCertificate>
   </PropertyGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 2758bb113ec..3c31d52a34c 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ProductDependencies>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.23428.2">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="9.0.0-alpha.1.23475.1">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>26ce96327dd346534926c4551f8b8d62a6fc724f</Sha>
+      <Sha>0650b50b2a5263c735d12b5c36c5deb34e7e6b60</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
@@ -52,39 +52,34 @@
       <Uri>https://github.com/dotnet/runtime</Uri>
       <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.Security.Permissions" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
-    </Dependency>
     <Dependency Name="System.Text.Json" Version="7.0.3">
       <Uri>https://github.com/dotnet/runtime</Uri>
       <Sha>5b20af47d99620150c53eaf5db8636fdf730b126</Sha>
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23425.2">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23463.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>90c167d5c57de4a8bced566379dbd893556c94e8</Sha>
+      <Sha>1d451c32dda2314c721adbf8829e1c0cd4e681ff</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23423.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23426.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
       <Uri>https://github.com/dotnet/xliff-tasks</Uri>
-      <Sha>ed9a83526483c094fb51e7000b6f816ce6cb0325</Sha>
+      <Sha>194f32828726c3f1f63f79f3dc09b9e99c157b11</Sha>
       <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.8.0-preview.1.82">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.8.0-rc.117">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>7bb6ca5f6930d23fd93820dfc9c6a4373c8fd691</Sha>
+      <Sha>7fb5ed887352d2892797a365cfdd7bb8df029941</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.8.0-2.23426.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.8.0-3.23474.3">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>34268d1bb9370c7b01c742303a895a99daf10d6a</Sha>
+      <Sha>2fe37da588ea81d852d3a42e290f8da4d610882f</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.23425.2">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.23463.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>90c167d5c57de4a8bced566379dbd893556c94e8</Sha>
+      <Sha>1d451c32dda2314c721adbf8829e1c0cd4e681ff</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 58866d8cc69..c8715dc2a0f 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,8 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.8.0</VersionPrefix>
-    <PackageValidationBaselineVersion>17.7.0</PackageValidationBaselineVersion>
+    <VersionPrefix>17.9.0</VersionPrefix>
+    <PackageValidationBaselineVersion>17.8.0-preview-23471-08</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -38,7 +38,6 @@
     <SystemReflectionMetadataLoadContextVersion>7.0.0</SystemReflectionMetadataLoadContextVersion>
     <SystemReflectionMetadataVersion>7.0.0</SystemReflectionMetadataVersion>
     <SystemResourcesExtensionsPackageVersion>7.0.0</SystemResourcesExtensionsPackageVersion>
-    <SystemSecurityPermissionsVersion>7.0.0</SystemSecurityPermissionsVersion>
     <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
     <SystemTextEncodingCodePagesVersion>7.0.0</SystemTextEncodingCodePagesVersion>
   </PropertyGroup>
@@ -48,11 +47,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.23425.2</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.23463.1</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.8.0-2.23426.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.8.0-preview.1.82</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.8.0-3.23474.3</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.8.0-rc.117</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.3</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
diff --git a/eng/common/cross/toolchain.cmake b/eng/common/cross/toolchain.cmake
index a88d643c8a7..0998e875e5f 100644
--- a/eng/common/cross/toolchain.cmake
+++ b/eng/common/cross/toolchain.cmake
@@ -207,6 +207,7 @@ elseif(ILLUMOS)
     set(CMAKE_CXX_STANDARD_LIBRARIES "${CMAKE_CXX_STANDARD_LIBRARIES} -lssp")
 elseif(HAIKU)
     set(CMAKE_SYSROOT "${CROSS_ROOTFS}")
+    set(CMAKE_PROGRAM_PATH "${CMAKE_PROGRAM_PATH};${CROSS_ROOTFS}/cross-tools-x86_64/bin")
 
     set(TOOLSET_PREFIX ${TOOLCHAIN}-)
     function(locate_toolchain_exec exec var)
@@ -217,7 +218,6 @@ elseif(HAIKU)
         endif()
 
         find_program(EXEC_LOCATION_${exec}
-            PATHS "${CROSS_ROOTFS}/cross-tools-x86_64/bin"
             NAMES
             "${TOOLSET_PREFIX}${exec}${CLR_CMAKE_COMPILER_FILE_NAME_VERSION}"
             "${TOOLSET_PREFIX}${exec}")
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 4a6756eff0a..697c4f4ca20 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -19,13 +19,16 @@
     <PackageVersion Include="LargeAddressAware" Version="1.0.5" />
     <PackageVersion Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
 
+    <PackageVersion Include="Microsoft.BuildXL.Processes" Version="0.1.0-20230727.4.2" />
+    <PackageVersion Update="Microsoft.BuildXL.Processes" Condition="'$(BuildXLProcessesVersion)' != ''" Version="$(BuildXLProcessesVersion)" />
+
     <PackageVersion Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.2.2146" PrivateAssets="All" />
     <PackageVersion Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(MicrosoftVisualStudioSetupConfigurationInteropVersion)' != ''" Version="$(MicrosoftVisualStudioSetupConfigurationInteropVersion)" PrivateAssets="All" />
 
     <PackageVersion Include="Microsoft.Win32.Registry" Version="5.0.0" />
     <PackageVersion Update="Microsoft.Win32.Registry" Condition="'$(MicrosoftWin32RegistryVersion)' != ''" Version="$(MicrosoftWin32RegistryVersion)" />
 
-    <PackageVersion Include="Newtonsoft.Json" Version="13.0.2" />
+    <PackageVersion Include="Newtonsoft.Json" Version="13.0.3" />
     <PackageVersion Update="Newtonsoft.Json" Condition="'$(NewtonsoftJsonVersion)' != ''" Version="$(NewtonsoftJsonVersion)" />
 
     <PackageVersion Include="PdbGit" Version="3.0.41" />
diff --git a/eng/policheck_exclusions.xml b/eng/policheck_exclusions.xml
new file mode 100644
index 00000000000..c5ed5390edf
--- /dev/null
+++ b/eng/policheck_exclusions.xml
@@ -0,0 +1,13 @@
+<PoliCheckExclusions>
+  <!-- All strings must be UPPER CASE -->
+  <!--Each of these exclusions is a folder name -if \[name]\exists in the file path, it will be skipped -->
+  <!--<Exclusion Type="FolderPathFull">ABC|XYZ</Exclusion>-->
+  <!--Each of these exclusions is a folder name -if any folder or file starts with "\[name]", it will be skipped -->
+  <!--<Exclusion Type="FolderPathStart">ABC|XYZ</Exclusion>-->
+  <!--Each of these file types will be completely skipped for the entire scan -->
+  <!--<Exclusion Type="FileType">.ABC|.XYZ</Exclusion>-->
+  <!--The specified file names will be skipped during the scan regardless which folder they are in -->
+  <!--<Exclusion Type="FileName">ABC.TXT|XYZ.CS</Exclusion>-->
+
+  <Exclusion Type="FolderPathFull">.DOTNET</Exclusion>
+</PoliCheckExclusions>
\ No newline at end of file
diff --git a/global.json b/global.json
index d9967b3a53d..2b69538de3a 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "8.0.100-preview.7.23376.3",
+    "dotnet": "8.0.100-rc.1.23463.5",
     "vs": {
-      "version": "17.6.0"
+      "version": "17.7.0"
     },
-    "xcopy-msbuild": "17.6.0-2"
+    "xcopy-msbuild": "17.7.2"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.23425.2"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.23463.1"
   }
-}
+}
\ No newline at end of file
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index 37b65ce9199..58966a34fdf 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -5,7 +5,9 @@ Param(
   [ValidateSet('Debug','Release')]
   [string] $configuration = "Debug",
   [ValidateSet('Core','Desktop', 'Detect', 'Full')]
-  [string] $runtime = "Detect"
+  [string] $runtime = "Detect",
+  [string] $bootstrapDirectory = "",
+  [bool] $makeBackup = $true
 )
 
 Set-StrictMode -Version "Latest"
@@ -15,9 +17,9 @@ function Copy-WithBackup ($origin, $destinationSubFolder = "") {
     $directoryPart = [IO.Path]::Combine($destination, $destinationSubFolder, $origin.IntermediaryDirectories)
     $destinationPath = Join-Path -Path $directoryPart (Split-Path $origin.SourceFile -leaf)
 
-    $backupInto = [IO.Path]::Combine($BackupFolder, $destinationSubFolder)
+    if (($makeBackup) -and (Test-Path $destinationPath -PathType Leaf)) {
+        $backupInto = [IO.Path]::Combine($BackupFolder, $destinationSubFolder)
 
-    if (Test-Path $destinationPath -PathType Leaf) {
         # Back up previous copy of the file
         if (!(Test-Path $backupInto)) {
             [system.io.directory]::CreateDirectory($backupInto)
@@ -45,10 +47,15 @@ function FileToCopy([string] $sourceFileRelativeToRepoRoot, [string] $intermedia
 
 # TODO: find most-recently-built MSBuild and make it default $configuration
 
-$BackupFolder = New-Item (Join-Path $destination -ChildPath "Backup-$(Get-Date -Format FileDateTime)") -itemType directory -ErrorAction Stop
-
 Write-Verbose "Copying $configuration MSBuild to $destination"
-Write-Host "Existing MSBuild assemblies backed up to $BackupFolder"
+
+if ($makeBackup) {
+    $BackupFolder = New-Item (Join-Path $destination -ChildPath "Backup-$(Get-Date -Format FileDateTime)") -itemType directory -ErrorAction Stop
+    Write-Host "Existing MSBuild assemblies backed up to $BackupFolder"
+}
+else {
+    Write-Host "Existing MSBuild assemblies won't be backed up"
+}
 
 if ($runtime -eq "Detect") {
     if ($destination -like "*dotnet*sdk*") {
@@ -72,7 +79,12 @@ if ($runtime -eq "Desktop") {
     $targetFramework = "net8.0"
 }
 
-$bootstrapBinDirectory = "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework"
+# If bootstrap directory is not defined in parameters, use the default location
+if ($bootstrapDirectory -eq "") {
+    $bootstrapDirectory = "artifacts\bin\MSBuild.Bootstrap" 
+}
+
+$bootstrapBinDirectory = "$bootstrapDirectory\$configuration\$targetFramework"
 
 $filesToCopyToBin = @(
     FileToCopy "$bootstrapBinDirectory\Microsoft.Build.dll"
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
index f454dc1161d..14e2a4cfd41 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
@@ -155,9 +155,15 @@ private void TestCustomEventWarning<T>(string envVariableValue, bool isWarningEx
         /// </summary>
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _projectCollection.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+                _projectCollection.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
         }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index e340aaacdc6..0f01ede7b2b 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -93,9 +93,15 @@ public BuildManager_Tests(ITestOutputHelper output)
         /// </summary>
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _projectCollection.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+                _projectCollection.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
         }
 
         /// <summary>
@@ -4040,7 +4046,7 @@ public void MultiProcReentrantProjectWithCallTargetDoesNotFail()
             }
         }
 
-        [Fact]
+        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/9245")]
         public void IdenticalSubmissionsShouldCompleteAndNotHangTheBuildOnMissingTargetExceptions()
         {
             var projectContents =
diff --git a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
index 322c61aa579..83d4ae0cf0a 100644
--- a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
@@ -77,9 +77,15 @@ public SdkResultOutOfProc_Tests(ITestOutputHelper output)
 
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _projectCollection.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+                _projectCollection.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
             EvaluationContext.TestOnlyHookOnCreate = null;
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
index 5c6bf006b2c..9fba141c3a3 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.FileAccess;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Xunit;
@@ -25,21 +26,67 @@ public class TaskHostTaskComplete_Tests
         [Fact]
         public void TestConstructors()
         {
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success), null);
-            TaskHostTaskComplete complete2 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure), null);
-            TaskHostTaskComplete complete3 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringInitialization, new ArgumentOutOfRangeException()), null);
-            TaskHostTaskComplete complete4 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringExecution, new ArgumentNullException()), null);
+#if FEATURE_REPORTFILEACCESSES
+            var fileAccessData = new List<FileAccessData>()
+            {
+                new FileAccessData(
+                    ReportedFileOperation.CreateFile,
+                    RequestedAccess.Read,
+                    0,
+                    0,
+                    DesiredAccess.GENERIC_READ,
+                    FlagsAndAttributes.FILE_ATTRIBUTE_NORMAL,
+                    "foo",
+                    null,
+                    true),
+            };
+#endif
+
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringInitialization,
+                new ArgumentOutOfRangeException()),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringExecution, new ArgumentNullException()),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
 
             IDictionary<string, object> parameters = new Dictionary<string, object>();
-            TaskHostTaskComplete complete5 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             IDictionary<string, object> parameters2 = new Dictionary<string, object>();
             parameters2.Add("Text", "Hello!");
             parameters2.Add("MyBoolValue", true);
             parameters2.Add("MyITaskItem", new TaskItem("ABC"));
             parameters2.Add("ItemArray", new ITaskItem[] { new TaskItem("DEF"), new TaskItem("GHI"), new TaskItem("JKL") });
-
-            TaskHostTaskComplete complete6 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters2), null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters2),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
         }
 
         /// <summary>
@@ -60,7 +107,12 @@ public void TestInvalidConstructors()
         [Fact]
         public void TestTranslationWithNullDictionary()
         {
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -78,7 +130,12 @@ public void TestTranslationWithNullDictionary()
         [Fact]
         public void TestTranslationWithEmptyDictionary()
         {
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, new Dictionary<string, object>()), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, new Dictionary<string, object>()),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -99,7 +156,12 @@ public void TestTranslationWithValueTypesInDictionary()
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("Text", "Foo");
             parameters.Add("BoolValue", false);
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -121,7 +183,12 @@ public void TestTranslationWithITaskItemInDictionary()
         {
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemValue", new TaskItem("Foo"));
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -142,7 +209,12 @@ public void TestTranslationWithITaskItemArrayInDictionary()
         {
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemArrayValue", new ITaskItem[] { new TaskItem("Foo"), new TaskItem("Baz") });
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -168,7 +240,12 @@ private void AssertInvalidConstructorThrows(Type expectedExceptionType, TaskComp
 
             try
             {
-                TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(taskResult, taskOutputParameters, taskException, taskExceptionMessage, taskExceptionMessageArgs), buildProcessEnvironment);
+                TaskHostTaskComplete complete = new(
+                    new OutOfProcTaskHostTaskResult(taskResult, taskOutputParameters, taskException, taskExceptionMessage, taskExceptionMessageArgs),
+#if FEATURE_REPORTFILEACCESSES
+                    null,
+#endif
+                    buildProcessEnvironment);
             }
             catch (Exception e)
             {
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 9963b2338b5..6e385896a9c 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -263,10 +263,11 @@ public void RoundtripBuildErrorEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool useArguments)
+        public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool withOptionalData)
         {
             var args = new ExtendedBuildErrorEventArgs(
                 "extendedDataType",
@@ -281,10 +282,14 @@ public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool useArguments)
                 "Help",
                 "SenderName",
                 DateTime.Parse("9/1/2021 12:02:07 PM"),
-                useArguments ? new object[] { "argument0" } : null);
+                withOptionalData ? new object[] { "argument0" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
 
-            // For now we don't serialize extended data into binary log
-            Roundtrip<BuildErrorEventArgs>(args,
+            Roundtrip(args,
                 e => e.Code,
                 e => e.ColumnNumber.ToString(),
                 e => e.EndColumnNumber.ToString(),
@@ -294,6 +299,9 @@ public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool useArguments)
                 e => e.Message,
                 e => e.ProjectFile,
                 e => e.Subcategory,
+                e => e.ExtendedType,
+                e => TranslationHelpers.ToString(e.ExtendedMetadata),
+                e => e.ExtendedData,
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
@@ -332,7 +340,7 @@ public void RoundtripBuildWarningEventArgs(bool useArguments)
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool useArguments)
+        public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool withOptionalData)
         {
             var args = new ExtendedBuildWarningEventArgs(
                 "extendedDataType",
@@ -347,10 +355,14 @@ public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool useArgume
                 "Help",
                 "SenderName",
                 DateTime.Parse("9/1/2021 12:02:07 PM"),
-                useArguments ? new object[] { "argument0" } : null);
+                withOptionalData ? new object[] { "argument0" } : null)
+                {
+                    ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                    ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                    BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+                };
 
-            // For now we don't serialize extended data into binary log
-            Roundtrip<BuildWarningEventArgs>(args,
+            Roundtrip(args,
                 e => e.Code,
                 e => e.ColumnNumber.ToString(),
                 e => e.EndColumnNumber.ToString(),
@@ -360,6 +372,9 @@ public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool useArgume
                 e => e.Message,
                 e => e.ProjectFile,
                 e => e.Subcategory,
+                e => e.ExtendedType,
+                e => TranslationHelpers.ToString(e.ExtendedMetadata),
+                e => e.ExtendedData,
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
@@ -400,7 +415,7 @@ public void RoundtripBuildMessageEventArgs(bool useArguments)
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool useArguments)
+        public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool withOptionalData)
         {
             var args = new ExtendedBuildMessageEventArgs(
                 "extendedDataType",
@@ -416,9 +431,14 @@ public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool useA
                 "SenderName",
                 MessageImportance.High,
                 DateTime.Parse("12/12/2015 06:11:56 PM"),
-                useArguments ? new object[] { "argument0" } : null);
+                withOptionalData ? new object[] { "argument0" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
 
-            Roundtrip<BuildMessageEventArgs>(args,
+            Roundtrip(args,
                 e => e.Code,
                 e => e.ColumnNumber.ToString(),
                 e => e.EndColumnNumber.ToString(),
@@ -429,6 +449,9 @@ public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool useA
                 e => e.Importance.ToString(),
                 e => e.ProjectFile,
                 e => e.Subcategory,
+                e => e.ExtendedType,
+                e => TranslationHelpers.ToString(e.ExtendedMetadata),
+                e => e.ExtendedData,
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
@@ -493,19 +516,21 @@ public void ExtendedCustomBuildEventArgs_SerializedAsMessage(bool withOptionalDa
 
             using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
             var deserialized = buildEventArgsReader.Read();
-            BuildMessageEventArgs desArgs = (BuildMessageEventArgs)deserialized;
-
-            desArgs.ShouldBeOfType(typeof(BuildMessageEventArgs));
+            ExtendedBuildMessageEventArgs desArgs = (ExtendedBuildMessageEventArgs)deserialized;
 
+            desArgs.ShouldBeOfType(typeof(ExtendedBuildMessageEventArgs));
             desArgs.Message.ShouldBe(args.Message);
             desArgs.HelpKeyword.ShouldBe(args.HelpKeyword);
             desArgs.SenderName.ShouldBe(args.SenderName);
             desArgs.Importance.ShouldBe(MessageImportance.Normal);
             desArgs.Timestamp.ShouldBe(args.Timestamp);
+            desArgs.ExtendedType.ShouldBe(args.ExtendedType);
 
             if (withOptionalData)
             {
                 desArgs.BuildEventContext.ShouldBe(args.BuildEventContext);
+                desArgs.ExtendedData.ShouldBe(args.ExtendedData);
+                TranslationHelpers.ToString(desArgs.ExtendedMetadata).ShouldBe(TranslationHelpers.ToString(args.ExtendedMetadata));
             }
             else
             {
diff --git a/src/Build.UnitTests/EvaluationProfiler_Tests.cs b/src/Build.UnitTests/EvaluationProfiler_Tests.cs
index 27438bec72e..078dc9e3520 100644
--- a/src/Build.UnitTests/EvaluationProfiler_Tests.cs
+++ b/src/Build.UnitTests/EvaluationProfiler_Tests.cs
@@ -67,8 +67,14 @@ public EvaluationProfiler_Tests(ITestOutputHelper output)
         /// <nodoc/>
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
         }
 
         /// <summary>
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index 40a6964c0e5..86a5a8073d2 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -32,3 +32,6 @@
 
 [assembly: ComVisible(false)]
 [assembly: CLSCompliant(true)]
+
+[assembly: Dependency("BuildXL.Utilities.Core", LoadHint.Sometimes)]
+[assembly: Dependency("BuildXL.Processes", LoadHint.Sometimes)]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 4c8bda783c3..fc71b1c1d1d 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -13,6 +13,7 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Runtime.CompilerServices;
 using System.Runtime.ExceptionServices;
 using System.Threading;
 using System.Threading.Tasks;
@@ -25,6 +26,7 @@
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Graph;
@@ -558,6 +560,13 @@ public void BeginBuild(BuildParameters parameters)
                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath("msbuild-cache");
                 }
 
+#if FEATURE_REPORTFILEACCESSES
+                if (_buildParameters.ReportFileAccesses)
+                {
+                    EnableDetouredNodeLauncher();
+                }
+#endif
+
                 // Initialize components.
                 _nodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager) as INodeManager;
 
@@ -572,9 +581,17 @@ public void BeginBuild(BuildParameters parameters)
 
                 InitializeCaches();
 
+#if FEATURE_REPORTFILEACCESSES
+                var fileAccessManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager) as IFileAccessManager;
+#endif
+
                 _projectCacheService = new ProjectCacheService(
                     this,
                     loggingService,
+#if FEATURE_REPORTFILEACCESSES
+                    fileAccessManager,
+#endif
+                    _configCache,
                     _buildParameters.ProjectCacheDescriptor);
 
                 _taskHostNodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.TaskHostNodeManager) as INodeManager;
@@ -584,7 +601,9 @@ public void BeginBuild(BuildParameters parameters)
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildRequestConfiguration, BuildRequestConfiguration.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildRequestConfigurationResponse, BuildRequestConfigurationResponse.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildResult, BuildResult.FactoryForDeserialization, this);
+                _nodeManager.RegisterPacketHandler(NodePacketType.FileAccessReport, FileAccessReport.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.NodeShutdown, NodeShutdown.FactoryForDeserialization, this);
+                _nodeManager.RegisterPacketHandler(NodePacketType.ProcessReport, ProcessReport.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.ResolveSdkRequest, SdkResolverRequest.FactoryForDeserialization, SdkResolverService as INodePacketHandler);
                 _nodeManager.RegisterPacketHandler(NodePacketType.ResourceRequest, ResourceRequest.FactoryForDeserialization, this);
 
@@ -699,6 +718,29 @@ void InitializeCaches()
             }
         }
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// Configure the build to use I/O tracking for nodes.
+        /// </summary>
+        /// <remarks>
+        /// Must be a separate non-inlinable method to avoid loading the BuildXL assembly when not opted in.
+        /// </remarks>
+        [MethodImpl(MethodImplOptions.NoInlining)]
+        private void EnableDetouredNodeLauncher()
+        {
+            // Currently BuildXL only supports x64. Once this feature moves out of the experimental phase, this will need to be addressed.
+            ErrorUtilities.VerifyThrowInvalidOperation(NativeMethodsShared.ProcessorArchitecture == NativeMethodsShared.ProcessorArchitectures.X64, "ReportFileAccessesX64Only");
+
+            // To properly report file access, we need to disable the in-proc node which won't be detoured.
+            _buildParameters.DisableInProcNode = true;
+
+            // Node reuse must be disabled as future builds will not be able to listen to events raised by detours.
+            _buildParameters.EnableNodeReuse = false;
+
+            _componentFactories.ReplaceFactory(BuildComponentType.NodeLauncher, DetouredNodeLauncher.CreateComponent);
+        }
+#endif
+
         private static void AttachDebugger()
         {
             if (Debugger.IsAttached)
@@ -1564,6 +1606,16 @@ private void ProcessPacket(int node, INodePacket packet)
                         HandleNodeShutdown(node, shutdownPacket);
                         break;
 
+                    case NodePacketType.FileAccessReport:
+                        FileAccessReport fileAccessReport = ExpectPacketType<FileAccessReport>(packet, NodePacketType.FileAccessReport);
+                        HandleFileAccessReport(node, fileAccessReport);
+                        break;
+
+                    case NodePacketType.ProcessReport:
+                        ProcessReport processReport = ExpectPacketType<ProcessReport>(packet, NodePacketType.ProcessReport);
+                        HandleProcessReport(node, processReport);
+                        break;
+
                     default:
                         ErrorUtilities.ThrowInternalError("Unexpected packet received by BuildManager: {0}", packet.Type);
                         break;
@@ -2371,6 +2423,39 @@ private void HandleResult(int node, BuildResult result)
                 configuration.ProjectTargets ??= result.ProjectTargets;
             }
 
+            // Only report results to the project cache services if it's the result for a build submission.
+            // Note that graph builds create a submission for each node in the graph, so each node in the graph will be
+            // handled here. This intentionally mirrors the behavior for cache requests, as it doesn't make sense to
+            // report for projects which aren't going to be requested. Ideally, *any* request could be handled, but that
+            // would require moving the cache service interactions to the Scheduler.
+            if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission buildSubmission))
+            {
+                // The result may be associated with the build submission due to it being the submission which
+                // caused the build, but not the actual request which was originally used with the build submission.
+                // ie. it may be a dependency of the "root-level" project which is associated with this submission, which
+                // isn't what we're looking for. Ensure only the actual submission's request is considered.
+                if (buildSubmission.BuildRequest != null
+                    && buildSubmission.BuildRequest.ConfigurationId == configuration.ConfigurationId
+                    && _projectCacheService.ShouldUseCache(configuration))
+                {
+                    BuildEventContext buildEventContext = _projectStartedEvents.TryGetValue(result.SubmissionId, out BuildEventArgs buildEventArgs)
+                        ? buildEventArgs.BuildEventContext
+                        : new BuildEventContext(result.SubmissionId, node, configuration.Project?.EvaluationId ?? BuildEventContext.InvalidEvaluationId, configuration.ConfigurationId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+                    try
+                    {
+                        _projectCacheService.HandleBuildResultAsync(configuration, result, buildEventContext, _executionCancellationTokenSource.Token).Wait();
+                    }
+                    catch (AggregateException ex) when (ex.InnerExceptions.All(inner => inner is OperationCanceledException))
+                    {
+                        // The build is being cancelled. Swallow any exceptions related specifically to cancellation.
+                    }
+                    catch (OperationCanceledException)
+                    {
+                        // The build is being cancelled. Swallow any exceptions related specifically to cancellation.
+                    }
+                }
+            }
+
             IEnumerable<ScheduleResponse> response = _scheduler.ReportResult(node, result);
             PerformSchedulingActions(response);
         }
@@ -2437,6 +2522,36 @@ private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket)
             CheckForActiveNodesAndCleanUpSubmissions();
         }
 
+        /// <summary>
+        /// Report the received <paramref name="fileAccessReport"/> to the file access manager.
+        /// </summary>
+        /// <param name="nodeId">The id of the node from which the <paramref name="fileAccessReport"/> was received.</param>
+        /// <param name="fileAccessReport">The file access report.</param>
+        private void HandleFileAccessReport(int nodeId, FileAccessReport fileAccessReport)
+        {
+#if FEATURE_REPORTFILEACCESSES
+            if (_buildParameters.ReportFileAccesses)
+            {
+                ((FileAccessManager)((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager)).ReportFileAccess(fileAccessReport.FileAccessData, nodeId);
+            }
+#endif
+        }
+
+        /// <summary>
+        /// Report the received <paramref name="processReport"/> to the file access manager.
+        /// </summary>
+        /// <param name="nodeId">The id of the node from which the <paramref name="processReport"/> was received.</param>
+        /// <param name="processReport">The process data report.</param>
+        private void HandleProcessReport(int nodeId, ProcessReport processReport)
+        {
+#if FEATURE_REPORTFILEACCESSES
+            if (_buildParameters.ReportFileAccesses)
+            {
+                ((FileAccessManager)((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager)).ReportProcess(processReport.ProcessData, nodeId);
+            }
+#endif
+        }
+
         /// <summary>
         /// If there are no more active nodes, cleans up any remaining submissions.
         /// </summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 8d7a8268648..582532e5795 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -220,6 +220,8 @@ public class BuildParameters : ITranslatable
 
         private string _outputResultsCacheFile;
 
+        private bool _reportFileAccesses;
+
         /// <summary>
         /// Constructor for those who intend to set all properties themselves.
         /// </summary>
@@ -303,6 +305,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             _projectIsolationMode = other.ProjectIsolationMode;
             _inputResultsCacheFiles = other._inputResultsCacheFiles;
             _outputResultsCacheFile = other._outputResultsCacheFile;
+            _reportFileAccesses = other._reportFileAccesses;
             DiscardBuildResults = other.DiscardBuildResults;
             LowPriority = other.LowPriority;
             Question = other.Question;
@@ -801,6 +804,17 @@ public string OutputResultsCacheFile
             set => _outputResultsCacheFile = value;
         }
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// Gets or sets a value indicating whether file accesses should be reported to any configured project cache plugins.
+        /// </summary>
+        public bool ReportFileAccesses
+        {
+            get => _reportFileAccesses;
+            set => _reportFileAccesses = value;
+        }
+#endif
+
         /// <summary>
         /// Determines whether MSBuild will save the results of builds after EndBuild to speed up future builds.
         /// </summary>
@@ -885,6 +899,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _interactive);
             translator.Translate(ref _question);
             translator.TranslateEnum(ref _projectIsolationMode, (int)_projectIsolationMode);
+            translator.Translate(ref _reportFileAccesses);
 
             // ProjectRootElementCache is not transmitted.
             // ResetCaches is not transmitted.
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 693912475d0..e0782c3fbf3 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -473,7 +473,7 @@ private bool TryLaunchServer()
                 };
                 NodeLauncher nodeLauncher = new NodeLauncher();
                 CommunicationsUtilities.Trace("Starting Server...");
-                Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions));
+                Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions), nodeId: 0);
                 CommunicationsUtilities.Trace("Server started with PID: {0}", msbuildProcess?.Id);
             }
             catch (Exception ex)
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index 5ea3ee2bde1..c4d543c87da 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -4,6 +4,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Components.Caching;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -61,6 +62,7 @@ public void RegisterDefaultFactories()
             _componentEntriesByType[BuildComponentType.NodeManager] = new BuildComponentEntry(BuildComponentType.NodeManager, NodeManager.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.TaskHostNodeManager] = new BuildComponentEntry(BuildComponentType.TaskHostNodeManager, TaskHostNodeManager.CreateComponent, CreationPattern.Singleton);
 
+            _componentEntriesByType[BuildComponentType.NodeLauncher] = new BuildComponentEntry(BuildComponentType.NodeLauncher, NodeLauncher.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.InProcNodeProvider] = new BuildComponentEntry(BuildComponentType.InProcNodeProvider, NodeProviderInProc.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.OutOfProcNodeProvider] = new BuildComponentEntry(BuildComponentType.OutOfProcNodeProvider, NodeProviderOutOfProc.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.OutOfProcTaskHostNodeProvider] = new BuildComponentEntry(BuildComponentType.OutOfProcTaskHostNodeProvider, NodeProviderOutOfProcTaskHost.CreateComponent, CreationPattern.Singleton);
@@ -80,6 +82,10 @@ public void RegisterDefaultFactories()
 
             // SDK resolution
             _componentEntriesByType[BuildComponentType.SdkResolverService] = new BuildComponentEntry(BuildComponentType.SdkResolverService, MainNodeSdkResolverService.CreateComponent, CreationPattern.Singleton);
+
+#if FEATURE_REPORTFILEACCESSES
+            _componentEntriesByType[BuildComponentType.FileAccessManager] = new BuildComponentEntry(BuildComponentType.FileAccessManager, FileAccessManager.CreateComponent, CreationPattern.Singleton);
+#endif
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
new file mode 100644
index 00000000000..d34bf7c9eec
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
@@ -0,0 +1,191 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using BuildXL.Processes;
+using BuildXL.Utilities.Core;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.FileAccesses;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+
+#nullable disable
+
+namespace Microsoft.Build.BackEnd
+{
+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent
+    {
+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();
+
+        private readonly BuildParameters.IBuildParameters _environmentVariables = CreateEnvironmentVariables();
+
+        private IFileAccessManager _fileAccessManager;
+
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));
+            return new DetouredNodeLauncher();
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);
+        }
+
+        public void ShutdownComponent()
+        {
+            _fileAccessManager = null;
+
+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)
+            {
+                sandboxedProcess.Dispose();
+            }
+
+            _sandboxedProcesses.Clear();
+        }
+
+        /// <summary>
+        /// Creates a new MSBuild process
+        /// </summary>
+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)
+        {
+            // Should always have been set already.
+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
+
+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));
+
+            if (!FileSystems.Default.FileExists(msbuildLocation))
+            {
+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotFindMSBuildExe", msbuildLocation));
+            }
+
+            // Repeat the executable name as the first token of the command line because the command line
+            // parser logic expects it and will otherwise skip the first argument
+            commandLineArgs = $"\"{msbuildLocation}\" {commandLineArgs}";
+
+            CommunicationsUtilities.Trace("Launching node from {0}", msbuildLocation);
+
+            string exeName = msbuildLocation;
+
+#if RUNTIME_TYPE_NETCORE
+            // Run the child process with the same host as the currently-running process.
+            exeName = CurrentHost.GetCurrentHost();
+#endif
+
+            var eventListener = new DetoursEventListener(_fileAccessManager, nodeId);
+            eventListener.SetMessageHandlingFlags(MessageHandlingFlags.DebugMessageNotify | MessageHandlingFlags.FileAccessNotify | MessageHandlingFlags.ProcessDataNotify | MessageHandlingFlags.ProcessDetoursStatusNotify);
+
+            var info = new SandboxedProcessInfo(
+                fileStorage: null, // Don't write stdout/stderr to files
+                fileName: exeName,
+                disableConHostSharing: false,
+                detoursEventListener: eventListener,
+                createJobObjectForCurrentProcess: false)
+            {
+                SandboxKind = SandboxKind.Default,
+                PipDescription = "MSBuild",
+                PipSemiStableHash = 0,
+                Arguments = commandLineArgs,
+                EnvironmentVariables = _environmentVariables,
+                MaxLengthInMemory = 0, // Don't buffer any output
+            };
+
+            // FileAccessManifest.AddScope is used to define the list of files which the running process is allowed to access and what kinds of file accesses are allowed
+            // Tracker internally uses AbsolutePath.Invalid to represent the root, just like Unix '/' root.
+            // this code allows all types of accesses for all files
+            info.FileAccessManifest.AddScope(
+                AbsolutePath.Invalid,
+                FileAccessPolicy.MaskNothing,
+                FileAccessPolicy.AllowAll | FileAccessPolicy.ReportAccess);
+
+            // Support shared compilation
+            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox = new string[] { NativeMethodsShared.IsWindows ? "VBCSCompiler.exe" : "VBCSCompiler" };
+            info.FileAccessManifest.MonitorChildProcesses = true;
+            info.FileAccessManifest.IgnoreReparsePoints = true;
+            info.FileAccessManifest.UseExtraThreadToDrainNtClose = false;
+            info.FileAccessManifest.UseLargeNtClosePreallocatedList = true;
+            info.FileAccessManifest.LogProcessData = true;
+
+            // needed for logging process arguments when a new process is invoked; see DetoursEventListener.cs
+            info.FileAccessManifest.ReportProcessArgs = true;
+
+            // By default, BuildXL sets the timestamp of all input files to January 1, 1970
+            // This breaks some tools like Robocopy which will not copy a file to the destination if the file exists at the destination and has a timestamp that is more recent than the source file
+            info.FileAccessManifest.NormalizeReadTimestamps = false;
+
+            // If a process exits but its child processes survive, Tracker waits 30 seconds by default to wait for this process to exit.
+            // This slows down C++ builds in which mspdbsrv.exe doesn't exit when it's parent exits. Set this time to 0.
+            info.NestedProcessTerminationTimeout = TimeSpan.Zero;
+
+            ISandboxedProcess sp = SandboxedProcessFactory.StartAsync(info, forceSandboxing: false).GetAwaiter().GetResult();
+            lock (_sandboxedProcesses)
+            {
+                _sandboxedProcesses.Add(sp);
+            }
+
+            CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", sp.ProcessId, exeName);
+            return Process.GetProcessById(sp.ProcessId);
+        }
+
+        private static BuildParameters.IBuildParameters CreateEnvironmentVariables()
+        {
+            var envVars = new Dictionary<string, string>();
+            foreach (DictionaryEntry baseVar in Environment.GetEnvironmentVariables())
+            {
+                envVars.Add((string)baseVar.Key, (string)baseVar.Value);
+            }
+
+            return BuildParameters.GetFactory().PopulateFromDictionary(envVars);
+        }
+
+        private sealed class DetoursEventListener : IDetoursEventListener
+        {
+            private readonly IFileAccessManager _fileAccessManager;
+            private readonly int _nodeId;
+
+            public DetoursEventListener(IFileAccessManager fileAccessManager, int nodeId)
+            {
+                _fileAccessManager = fileAccessManager;
+                _nodeId = nodeId;
+            }
+
+            public override void HandleDebugMessage(DebugData debugData)
+            {
+            }
+
+            public override void HandleFileAccess(FileAccessData fileAccessData) => _fileAccessManager.ReportFileAccess(
+                new Framework.FileAccess.FileAccessData(
+                    (Framework.FileAccess.ReportedFileOperation)fileAccessData.Operation,
+                    (Framework.FileAccess.RequestedAccess)fileAccessData.RequestedAccess,
+                    fileAccessData.ProcessId,
+                    fileAccessData.Error,
+                    (Framework.FileAccess.DesiredAccess)fileAccessData.DesiredAccess,
+                    (Framework.FileAccess.FlagsAndAttributes)fileAccessData.FlagsAndAttributes,
+                    fileAccessData.Path,
+                    fileAccessData.ProcessArgs,
+                    fileAccessData.IsAnAugmentedFileAccess),
+                _nodeId);
+
+            public override void HandleProcessData(ProcessData processData) => _fileAccessManager.ReportProcess(
+                new Framework.FileAccess.ProcessData(
+                    processData.ProcessName,
+                    processData.ProcessId,
+                    processData.ParentProcessId,
+                    processData.CreationDateTime,
+                    processData.ExitDateTime,
+                    processData.ExitCode),
+                _nodeId);
+
+            public override void HandleProcessDetouringStatus(ProcessDetouringStatusData data)
+            {
+            }
+        }
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/Communications/INodeLauncher.cs b/src/Build/BackEnd/Components/Communications/INodeLauncher.cs
new file mode 100644
index 00000000000..c409c856c0b
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/INodeLauncher.cs
@@ -0,0 +1,12 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal interface INodeLauncher
+    {
+        Process Start(string msbuildLocation, string commandLineArgs, int nodeId);
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
index 611c4ca68c9..ddec6d79279 100644
--- a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
@@ -16,12 +16,26 @@
 
 namespace Microsoft.Build.BackEnd
 {
-    internal class NodeLauncher
+    internal sealed class NodeLauncher : INodeLauncher, IBuildComponent
     {
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));
+            return new NodeLauncher();
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+        }
+
+        public void ShutdownComponent()
+        {
+        }
+
         /// <summary>
         /// Creates a new MSBuild process
         /// </summary>
-        public Process Start(string msbuildLocation, string commandLineArgs)
+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)
         {
             // Disable MSBuild server for a child process.
             // In case of starting msbuild server it prevents an infinite recurson. In case of starting msbuild node we also do not want this variable to be set.
@@ -181,7 +195,7 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)
             }
         }
 
-        private Process DisableMSBuildServer(Func<Process> func)
+        private static Process DisableMSBuildServer(Func<Process> func)
         {
             string useMSBuildServerEnvVarValue = Environment.GetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName);
             try
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 58105527c16..273e6990f13 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -332,8 +332,8 @@ bool StartNewNode(int nodeId)
                     }
 #endif
                     // Create the node process
-                    NodeLauncher nodeLauncher = new NodeLauncher();
-                    Process msbuildProcess = nodeLauncher.Start(msbuildLocation, commandLineArgs);
+                    INodeLauncher nodeLauncher = (INodeLauncher)_componentHost.GetComponent(BuildComponentType.NodeLauncher);
+                    Process msbuildProcess = nodeLauncher.Start(msbuildLocation, commandLineArgs, nodeId);
                     _processesToIgnore.TryAdd(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id), default);
 
                     // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
diff --git a/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
new file mode 100644
index 00000000000..efbe32a0f64
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
@@ -0,0 +1,188 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Collections.Concurrent;
+using System.IO;
+using System.Runtime.Versioning;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework.FileAccess;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent
+    {
+        private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, Action<BuildRequest, ProcessData> ProcessHandler);
+
+        // In order to synchronize between the node communication and the file access reporting, a special file access
+        // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen
+        // and the build result is reported can plugins be notified about project completion.
+        // NOTE! This is currently Windows-specific and will need to change once this feature is opened up to more scenarios.
+        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @":\{MSBuildFileAccessCompletion}\";
+
+        private IScheduler? _scheduler;
+        private IConfigCache? _configCache;
+
+        private object _handlersWriteLock = new object();
+        private Handlers[] _handlers = Array.Empty<Handlers>();
+        private string? _tempDirectory;
+
+        // Keyed on global request id
+        private readonly ConcurrentDictionary<int, ManualResetEventSlim> _fileAccessCompletionWaitHandles = new();
+
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));
+            return new FileAccessManager();
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;
+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;
+            _tempDirectory = FileUtilities.EnsureNoTrailingSlash(FileUtilities.TempFileDirectory);
+        }
+
+        public void ShutdownComponent()
+        {
+            _scheduler = null;
+            _configCache = null;
+            _tempDirectory = null;
+            _fileAccessCompletionWaitHandles.Clear();
+        }
+
+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)
+        {
+            string fileAccessPath = fileAccessData.Path;
+
+            // Intercept and avoid forwarding the file access completion
+            if (fileAccessPath.StartsWith(FileAccessCompletionPrefix, StringComparison.Ordinal))
+            {
+                // Parse out the global request id. Note, this must match what NotifyFileAccessCompletion does.
+                int globalRequestId = int.Parse(fileAccessPath.Substring(FileAccessCompletionPrefix.Length));
+
+                ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());
+                handle.Set();
+            }
+            else if (_tempDirectory != null && fileAccessPath.StartsWith(_tempDirectory))
+            {
+                // Ignore MSBuild's temp directory as these are related to internal MSBuild functionality and not always directly related to the execution of the project itself,
+                // so should not be exposed to handlers. Note that this is not %TEMP% but instead a subdir under %TEMP% which is only expected to be used by MSBuild.
+                return;
+            }
+            else
+            {
+                // Forward the file access to handlers.
+                BuildRequest? buildRequest = GetBuildRequest(nodeId);
+                if (buildRequest != null)
+                {
+                    Handlers[] localHandlers = _handlers;
+                    foreach (Handlers handlers in localHandlers)
+                    {
+                        handlers.FileAccessHander.Invoke(buildRequest, fileAccessData);
+                    }
+                }
+            }
+        }
+
+        public void ReportProcess(ProcessData processData, int nodeId)
+        {
+            BuildRequest? buildRequest = GetBuildRequest(nodeId);
+            if (buildRequest != null)
+            {
+                Handlers[] localHandlers = _handlers;
+                foreach (Handlers handlers in localHandlers)
+                {
+                    handlers.ProcessHandler.Invoke(buildRequest, processData);
+                }
+            }
+        }
+
+        public HandlerRegistration RegisterHandlers(Action<BuildRequest, FileAccessData> fileAccessHandler, Action<BuildRequest, ProcessData> processHandler)
+        {
+            lock (_handlersWriteLock)
+            {
+                Handlers[] newHandlers = new Handlers[_handlers.Length + 1];
+                _handlers.CopyTo(newHandlers, 0);
+
+                Handlers addedHandlers = new(fileAccessHandler, processHandler);
+                newHandlers[_handlers.Length] = addedHandlers;
+
+                _handlers = newHandlers;
+
+                return new HandlerRegistration(() => UnregisterHandlers(addedHandlers));
+            }
+        }
+
+        private void UnregisterHandlers(Handlers handlersToRemove)
+        {
+            lock (_handlersWriteLock)
+            {
+                Handlers[] newHandlers = new Handlers[_handlers.Length - 1];
+                int newHandlersIdx = 0;
+                for (int handlersIdx = 0; handlersIdx < _handlers.Length; handlersIdx++)
+                {
+                    if (_handlers[handlersIdx] != handlersToRemove)
+                    {
+                        newHandlers[newHandlersIdx] = _handlers[handlersIdx];
+                        newHandlersIdx++;
+                    }
+                }
+
+                _handlers = newHandlers;
+            }
+        }
+
+        // The [SupportedOSPlatform] attribute is a safeguard to ensure that the comment on FileAccessCompletionPrefix regarding being Windows-only gets addressed.
+        // [SupportedOSPlatform] doesn't apply to fields, so using it here as a reasonable proxy.
+        [SupportedOSPlatform("windows")]
+        public static void NotifyFileAccessCompletion(int globalRequestId)
+        {
+            // Make a dummy file access to use as a notification that the file accesses should be completed for a project.
+            string filePath = FileAccessCompletionPrefix + globalRequestId.ToString();
+            _ = File.Exists(filePath);
+        }
+
+        public void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken)
+        {
+            ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());
+            if (!handle.IsSet)
+            {
+                handle.Wait(cancellationToken);
+            }
+
+            // Try to keep the collection clean. A request should not need to be completed twice.
+            _fileAccessCompletionWaitHandles.TryRemove(globalRequestId, out _);
+        }
+
+        private BuildRequest? GetBuildRequest(int nodeId)
+        {
+            ErrorUtilities.VerifyThrow(
+                _scheduler != null && _configCache != null,
+                "Component has not been initialized");
+
+            // Note: If the node isn't executing anything it may be accessing binaries required to run, eg. the MSBuild binaries
+            return _scheduler!.GetExecutingRequestByNode(nodeId);
+        }
+
+        internal readonly struct HandlerRegistration : IDisposable
+        {
+            private readonly Action _unregisterAction;
+
+            public HandlerRegistration(Action unregisterAction)
+            {
+                _unregisterAction = unregisterAction;
+            }
+
+            public void Dispose()
+            {
+                _unregisterAction();
+            }
+        }
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs b/src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs
new file mode 100644
index 00000000000..f69b6fd1580
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs
@@ -0,0 +1,27 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework.FileAccess;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal sealed class FileAccessReport : INodePacket
+    {
+        private FileAccessData _fileAccessData;
+
+        internal FileAccessReport(FileAccessData fileAccessData) => _fileAccessData = fileAccessData;
+
+        private FileAccessReport(ITranslator translator) => Translate(translator);
+
+        /// <inheritdoc/>
+        public NodePacketType Type => NodePacketType.FileAccessReport;
+
+        /// <inheritdoc/>
+        public void Translate(ITranslator translator) => translator.Translate(ref _fileAccessData);
+
+        internal FileAccessData FileAccessData => _fileAccessData;
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator) => new FileAccessReport(translator);
+    }
+}
diff --git a/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs
new file mode 100644
index 00000000000..3dd724afef3
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs
@@ -0,0 +1,26 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework.FileAccess;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal interface IFileAccessManager
+    {
+        void ReportFileAccess(FileAccessData fileAccessData, int nodeId);
+
+        void ReportProcess(ProcessData processData, int nodeId);
+
+        // Note: The return type of FileAccessManager.HandlerRegistration is exposed directly instead of IDisposable to avoid boxing.
+        FileAccessManager.HandlerRegistration RegisterHandlers(
+            Action<BuildRequest, FileAccessData> fileAccessHandler,
+            Action<BuildRequest, ProcessData> processHandler);
+
+        void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken);
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs
new file mode 100644
index 00000000000..80255059350
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs
@@ -0,0 +1,63 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework.FileAccess;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.FileAccesses
+{
+    /// <summary>
+    /// Reports file accesses and process data to the in-proc node.
+    /// </summary>
+    internal sealed class OutOfProcNodeFileAccessManager : IFileAccessManager, IBuildComponent
+    {
+        /// <summary>
+        /// The <see cref="Action"/> to report file accesses and process
+        /// data to the in-proc node.
+        /// </summary>
+        private readonly Action<INodePacket> _sendPacket;
+
+        private OutOfProcNodeFileAccessManager(Action<INodePacket> sendPacket) => _sendPacket = sendPacket;
+
+        public static IBuildComponent CreateComponent(BuildComponentType type, Action<INodePacket> sendPacket)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));
+            return new OutOfProcNodeFileAccessManager(sendPacket);
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+        }
+
+        public void ShutdownComponent()
+        {
+        }
+
+        /// <summary>
+        /// Reports a file access to the in-proc node.
+        /// </summary>
+        /// <param name="fileAccessData">The file access to report to the in-proc node.</param>
+        /// <param name="nodeId">The id of the reporting out-of-proc node.</param>
+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId) => _sendPacket(new FileAccessReport(fileAccessData));
+
+        /// <summary>
+        /// Reports process data to the in-proc node.
+        /// </summary>
+        /// <param name="processData">The process data to report to the in-proc node.</param>
+        /// <param name="nodeId">The id of the reporting out-of-proc node.</param>
+        public void ReportProcess(ProcessData processData, int nodeId) => _sendPacket(new ProcessReport(processData));
+
+        public FileAccessManager.HandlerRegistration RegisterHandlers(
+            Action<BuildRequest, FileAccessData> fileAccessHandler,
+            Action<BuildRequest, ProcessData> processHandler) =>
+            throw new NotImplementedException("This method should not be called in OOP nodes.");
+
+        public void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken) =>
+            throw new NotImplementedException("This method should not be called in OOP nodes.");
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs b/src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs
new file mode 100644
index 00000000000..89bf533ed86
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs
@@ -0,0 +1,27 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework.FileAccess;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal sealed class ProcessReport : INodePacket
+    {
+        private ProcessData _processData;
+
+        internal ProcessReport(ProcessData processData) => _processData = processData;
+
+        private ProcessReport(ITranslator translator) => Translate(translator);
+
+        /// <inheritdoc/>
+        public NodePacketType Type => NodePacketType.ProcessReport;
+
+        internal ProcessData ProcessData => _processData;
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator) => new ProcessReport(translator);
+
+        /// <inheritdoc/>
+        public void Translate(ITranslator translator) => translator.Translate(ref _processData);
+    }
+}
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index bcbc7eac430..5ae9d947906 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -130,6 +130,18 @@ internal enum BuildComponentType
         /// The SDK resolution service.
         /// </summary>
         SdkResolverService,
+
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// The component which is the sink for file access reports and forwards reports to other components.
+        /// </summary>
+        FileAccessManager,
+#endif
+
+        /// <summary>
+        /// The component which launches new MSBuild nodes.
+        /// </summary>
+        NodeLauncher,
     }
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/ProjectCache/FileAccessContext.cs b/src/Build/BackEnd/Components/ProjectCache/FileAccessContext.cs
new file mode 100644
index 00000000000..5ff62cfb514
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/FileAccessContext.cs
@@ -0,0 +1,26 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    public readonly struct FileAccessContext
+    {
+        public FileAccessContext(
+            string projectFullPath,
+            IReadOnlyDictionary<string, string> globalProperties,
+            IReadOnlyList<string> targets)
+        {
+            ProjectFullPath = projectFullPath;
+            GlobalProperties = globalProperties;
+            Targets = targets;
+        }
+
+        public string ProjectFullPath { get; }
+
+        public IReadOnlyDictionary<string, string> GlobalProperties { get; }
+
+        public IReadOnlyList<string> Targets { get; }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
index 2bf479c6055..eb55d482ba0 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
@@ -1,9 +1,11 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework.FileAccess;
 
 namespace Microsoft.Build.Experimental.ProjectCache
 {
@@ -39,5 +41,32 @@ public abstract Task<CacheResult> GetCacheResultAsync(
         ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
         /// </summary>
         public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);
+
+        /// <summary>
+        ///     Called for each file access from an MSBuild node or one of its children.
+        /// </summary>
+        [CLSCompliant(false)]
+        public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData)
+        {
+        }
+
+        /// <summary>
+        ///     Called for each new child process created by an MSBuild node or one of its children.
+        /// </summary>
+        [CLSCompliant(false)]
+        public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData)
+        {
+        }
+
+        /// <summary>
+        ///     Called when a build request finishes execution. This provides an opportunity for the plugin to take action on the
+        ///     aggregated file access reports from <see cref="HandleFileAccess(FileAccessContext, FileAccessData)"/>.
+        ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
+        /// </summary>
+        public virtual Task HandleProjectFinishedAsync(
+            FileAccessContext fileAccessContext,
+            BuildResult buildResult,
+            PluginLoggerBase logger,
+            CancellationToken cancellationToken) => Task.CompletedTask;
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index e34e70cca44..d684119e4e8 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -16,6 +16,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Execution;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
@@ -33,17 +34,31 @@ internal sealed class ProjectCacheService : IAsyncDisposable
         private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { "TargetFramework", "Configuration", "Platform", "TargetPlatform", "OutputType" };
 
         private readonly BuildManager _buildManager;
+        private readonly IBuildComponentHost _componentHost;
         private readonly ILoggingService _loggingService;
+#if FEATURE_REPORTFILEACCESSES
+        private readonly IFileAccessManager _fileAccessManager;
+#endif
+        private readonly IConfigCache _configCache;
 
         private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;
 
         private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);
 
+        // Helps to avoid excessive allocation since BuildRequestConfiguration doesn't expose global properties in a way the plugins can consume (PropertyDictionary<ProjectPropertyInstance> vs IReadOnlyDictionary<string, string>).
+        private readonly ConcurrentDictionary<BuildRequestConfiguration, IReadOnlyDictionary<string, string>> _globalPropertiesPerConfiguration = new();
+
         private bool _isVsScenario;
 
         private bool _isDisposed;
 
-        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);
+        private record struct ProjectCachePlugin(
+            string Name,
+            ProjectCachePluginBase? Instance,
+#if FEATURE_REPORTFILEACCESSES
+            FileAccessManager.HandlerRegistration? HandlerRegistration,
+#endif
+            ExceptionDispatchInfo? InitializationException = null);
 
         /// <summary>
         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,
@@ -61,10 +76,19 @@ private DefaultMSBuildFileSystem()
         public ProjectCacheService(
             BuildManager buildManager,
             ILoggingService loggingService,
+#if FEATURE_REPORTFILEACCESSES
+            IFileAccessManager fileAccessManager,
+#endif
+            IConfigCache configCache,
             ProjectCacheDescriptor? globalProjectCacheDescriptor)
         {
             _buildManager = buildManager;
+            _componentHost = buildManager;
             _loggingService = loggingService;
+#if FEATURE_REPORTFILEACCESSES
+            _fileAccessManager = fileAccessManager;
+#endif
+            _configCache = configCache;
             _globalProjectCacheDescriptor = globalProjectCacheDescriptor;
         }
 
@@ -75,18 +99,24 @@ public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationTok
         {
             EnsureNotDisposed();
 
-            Parallel.ForEach(
-                projectGraph.ProjectNodes,
-                s_parallelOptions,
-                node =>
+            // Performing this in a Task.Run to break away from the main thread and prevent hangs
+            Task.Run(
+                () =>
                 {
-                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
-                    {
-                        // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                        _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
-                            .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
-                    }
-                });
+                    Parallel.ForEach(
+                        projectGraph.ProjectNodes,
+                        s_parallelOptions,
+                        node =>
+                        {
+                            foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
+                            {
+                                // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
+                                _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
+                                    .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                            }
+                        });
+                },
+                cancellationToken);
         }
 
         public void InitializePluginsForVsScenario(
@@ -104,15 +134,21 @@ public void InitializePluginsForVsScenario(
                 return;
             }
 
-            Parallel.ForEach(
-                projectCacheDescriptors,
-                s_parallelOptions,
-                projectCacheDescriptor =>
+            // Performing this in a Task.Run to break away from the main thread and prevent hangs
+            Task.Run(
+                () =>
                 {
-                    // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                    _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)
-                        .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
-                });
+                    Parallel.ForEach(
+                        projectCacheDescriptors,
+                        s_parallelOptions,
+                        projectCacheDescriptor =>
+                        {
+                            // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
+                            _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)
+                                .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                        });
+                },
+                cancellationToken);
         }
 
         private Task<ProjectCachePlugin> GetProjectCachePluginAsync(
@@ -187,7 +223,13 @@ private async Task<ProjectCachePlugin> CreateAndInitializePluginAsync(
                 }
                 catch (Exception e)
                 {
-                    return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
+                    return new ProjectCachePlugin(
+                        pluginTypeName,
+                        Instance: null,
+#if FEATURE_REPORTFILEACCESSES
+                        HandlerRegistration: null,
+#endif
+                        ExceptionDispatchInfo.Capture(e));
                 }
                 finally
                 {
@@ -218,11 +260,43 @@ await pluginInstance.BeginBuildAsync(
                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheInitializationFailed");
                 }
 
-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);
+#if FEATURE_REPORTFILEACCESSES
+            FileAccessManager.HandlerRegistration? handlerRegistration = null;
+            if (_componentHost.BuildParameters.ReportFileAccesses)
+            {
+                handlerRegistration = _fileAccessManager.RegisterHandlers(
+                    (buildRequest, fileAccessData) =>
+                    {
+                        // TODO: Filter out projects which do not configure this plugin
+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);
+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);
+                    },
+                    (buildRequest, processData) =>
+                    {
+                        // TODO: Filter out projects which do not configure this plugin
+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);
+                        pluginInstance.HandleProcess(fileAccessContext, processData);
+                    });
+            }
+#endif
+
+                return new ProjectCachePlugin(
+                    pluginTypeName,
+                    pluginInstance,
+#if FEATURE_REPORTFILEACCESSES
+                    handlerRegistration,
+#endif
+                    InitializationException: null);
             }
             catch (Exception e)
             {
-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
+                return new ProjectCachePlugin(
+                    pluginTypeName,
+                    Instance: null,
+#if FEATURE_REPORTFILEACCESSES
+                    HandlerRegistration: null,
+#endif
+                    ExceptionDispatchInfo.Capture(e));
             }
             finally
             {
@@ -230,6 +304,27 @@ await pluginInstance.BeginBuildAsync(
             }
         }
 
+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)
+        {
+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];
+            IReadOnlyDictionary<string, string> globalProperties = GetGlobalProperties(configuration);
+            return new FileAccessContext(configuration.ProjectFullPath, globalProperties, buildRequest.Targets);
+        }
+
+        private IReadOnlyDictionary<string, string> GetGlobalProperties(BuildRequestConfiguration configuration)
+            => _globalPropertiesPerConfiguration.GetOrAdd(
+                    configuration,
+                    static configuration =>
+                    {
+                        Dictionary<string, string> globalProperties = new(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);
+                        foreach (ProjectPropertyInstance property in configuration.GlobalProperties)
+                        {
+                            globalProperties.Add(property.Name, property.EvaluatedValue);
+                        }
+
+                        return globalProperties;
+                    });
+
         private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
         {
             try
@@ -306,6 +401,12 @@ public bool ShouldUseCache(BuildRequestConfiguration buildRequestConfiguration)
                 return false;
             }
 
+            // We need to retrieve the configuration if it's already loaded in order to access the Project property below.
+            if (buildRequestConfiguration.IsCached)
+            {
+                buildRequestConfiguration.RetrieveFromCache();
+            }
+
             // Check if there are any project cache items defined in the project
             return GetProjectCacheDescriptors(buildRequestConfiguration.Project).Any();
         }
@@ -587,6 +688,98 @@ static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromS
             }
         }
 
+        public async Task HandleBuildResultAsync(
+            BuildRequestConfiguration requestConfiguration,
+            BuildResult buildResult,
+            BuildEventContext buildEventContext,
+            CancellationToken cancellationToken)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(requestConfiguration.Project, nameof(requestConfiguration.Project));
+
+            if (_projectCachePlugins.IsEmpty)
+            {
+                return;
+            }
+
+            // We need to retrieve the configuration if it's already loaded in order to access the Project property below.
+            if (requestConfiguration.IsCached)
+            {
+                requestConfiguration.RetrieveFromCache();
+            }
+
+            // Filter to plugins which apply to the project, if any
+            List<ProjectCacheDescriptor> projectCacheDescriptors = GetProjectCacheDescriptors(requestConfiguration.Project).ToList();
+            if (projectCacheDescriptors.Count == 0)
+            {
+                return;
+            }
+
+#if FEATURE_REPORTFILEACCESSES
+            if (_componentHost.BuildParameters.ReportFileAccesses)
+            {
+                _fileAccessManager.WaitForFileAccessReportCompletion(buildResult.GlobalRequestId, cancellationToken);
+            }
+#endif
+
+            IReadOnlyDictionary<string, string> globalProperties = GetGlobalProperties(requestConfiguration);
+
+            List<string> targets = buildResult.ResultsByTarget.Keys.ToList();
+            string? targetNames = string.Join(", ", targets);
+
+            FileAccessContext fileAccessContext = new(requestConfiguration.ProjectFullPath, globalProperties, targets);
+
+            var buildEventFileInfo = new BuildEventFileInfo(requestConfiguration.ProjectFullPath);
+            var pluginLogger = new LoggingServiceToPluginLoggerAdapter(
+                _loggingService,
+                buildEventContext,
+                buildEventFileInfo);
+
+            Task[] tasks = new Task[projectCacheDescriptors.Count];
+            int idx = 0;
+            foreach (ProjectCacheDescriptor projectCacheDescriptor in projectCacheDescriptors)
+            {
+                tasks[idx++] = Task.Run(
+                    async () =>
+                    {
+                        if (!_projectCachePlugins.TryGetValue(projectCacheDescriptor, out Lazy<Task<ProjectCachePlugin>>? pluginLazyTask))
+                        {
+                            // The plugin might not be in the collection if it was never initialized, which can happen if there are multiple plugins
+                            // and the first one(s) always handles the cache request so the subsequent one(s) never get lazy initialized.
+                            return;
+                        }
+
+                        ProjectCachePlugin plugin = await pluginLazyTask.Value;
+
+                        // Rethrow any initialization exception.
+                        plugin.InitializationException?.Throw();
+
+                        ErrorUtilities.VerifyThrow(plugin.Instance != null, "Plugin '{0}' instance is null", plugin.Name);
+
+                        MSBuildEventSource.Log.ProjectCacheHandleBuildResultStart(plugin.Name, fileAccessContext.ProjectFullPath, targetNames);
+                        try
+                        {
+                            await plugin.Instance!.HandleProjectFinishedAsync(fileAccessContext, buildResult, pluginLogger, cancellationToken);
+                        }
+                        catch (Exception e) when (e is not ProjectCacheException)
+                        {
+                            HandlePluginException(e, nameof(ProjectCachePluginBase.HandleProjectFinishedAsync));
+                        }
+                        finally
+                        {
+                            MSBuildEventSource.Log.ProjectCacheHandleBuildResultStop(plugin.Name, fileAccessContext.ProjectFullPath, targetNames);
+                        }
+                    },
+                    cancellationToken);
+            }
+
+            await Task.WhenAll(tasks).ConfigureAwait(false);
+
+            if (pluginLogger.HasLoggedErrors)
+            {
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheHandleBuildResultFailed", fileAccessContext.ProjectFullPath);
+            }
+        }
+
         public async ValueTask DisposeAsync()
         {
             if (_isDisposed)
@@ -624,6 +817,13 @@ public async ValueTask DisposeAsync()
                         return;
                     }
 
+#if FEATURE_REPORTFILEACCESSES
+                    if (plugin.HandlerRegistration.HasValue)
+                    {
+                        plugin.HandlerRegistration.Value.Dispose();
+                    }
+#endif
+
                     MSBuildEventSource.Log.ProjectCacheEndBuildStart(plugin.Name);
                     try
                     {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 939370ab515..0d67e69b661 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -6,22 +6,24 @@
 using System.Collections.Generic;
 using System.Globalization;
 #if FEATURE_APPDOMAIN
-using System.Runtime.Remoting.Lifetime;
 using System.Runtime.Remoting;
+using System.Runtime.Remoting.Lifetime;
 #endif
+using System.Diagnostics;
+using System.Reflection;
 using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Components.Caching;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Eventing;
+using Microsoft.Build.Execution;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.FileAccess;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Execution;
-using System.Diagnostics;
-using Microsoft.Build.Collections;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using TaskLoggingContext = Microsoft.Build.BackEnd.Logging.TaskLoggingContext;
-using System.Threading.Tasks;
-using Microsoft.Build.BackEnd.Components.Caching;
-using System.Reflection;
-using Microsoft.Build.Eventing;
 
 #nullable disable
 
@@ -343,6 +345,14 @@ public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames,
         /// </summary>
         public void Yield()
         {
+#if FEATURE_REPORTFILEACCESSES
+            // If file accesses are being reported we should not yield as file access will be attributed to the wrong project.
+            if (_host.BuildParameters.ReportFileAccesses)
+            {
+                return;
+            }
+#endif
+
             lock (_callbackMonitor)
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
@@ -364,6 +374,14 @@ public void Reacquire()
             // to release explicitly granted cores when reacquiring the node may lead to deadlocks.
             ReleaseAllCores();
 
+#if FEATURE_REPORTFILEACCESSES
+            // If file accesses are being reported yielding is a no-op so reacquire should be too.
+            if (_host.BuildParameters.ReportFileAccesses)
+            {
+                return;
+            }
+#endif
+
             lock (_callbackMonitor)
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
@@ -377,7 +395,7 @@ public void Reacquire()
             }
         }
 
-        #endregion
+#endregion
 
         #region IBuildEngine Members
 
@@ -920,11 +938,23 @@ public override bool LogsMessagesOfImportance(MessageImportance importance)
 
             /// <inheritdoc/>
             public override bool IsTaskInputLoggingEnabled => _taskHost._host.BuildParameters.LogTaskInputs;
+
+            /// <inheritdoc/>
+            public override void ReportFileAccess(FileAccessData fileAccessData)
+            {
+#if FEATURE_REPORTFILEACCESSES
+                IBuildComponentHost buildComponentHost = _taskHost._host;
+                if (buildComponentHost.BuildParameters.ReportFileAccesses)
+                {
+                    ((IFileAccessManager)buildComponentHost.GetComponent(BuildComponentType.FileAccessManager)).ReportFileAccess(fileAccessData, buildComponentHost.BuildParameters.NodeId);
+                }
+#endif
+            }
         }
 
         public EngineServices EngineServices { get; }
 
-        #endregion
+#endregion
 
         /// <summary>
         /// Called by the internal MSBuild task.
diff --git a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
index d66e50d62c1..84e22a9c67c 100644
--- a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
@@ -33,6 +33,11 @@ internal interface IScheduler : IBuildComponent
         /// <returns>A positive configuration id if one exists in the plan, 0 otherwise.</returns>
         int GetConfigurationIdFromPlan(string configurationPath);
 
+        /// <summary>
+        /// Retrieves the request executing on a node.
+        /// </summary>
+        BuildRequest GetExecutingRequestByNode(int nodeId);
+
         /// <summary>
         /// Reports to the scheduler that a request is blocked.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 53bf46ec2f3..6208aa883e4 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -283,6 +283,20 @@ public int GetConfigurationIdFromPlan(string configPath)
             return _schedulingPlan.GetConfigIdForPath(configPath);
         }
 
+        /// <summary>
+        /// Retrieves the request executing on a node.
+        /// </summary>
+        public BuildRequest GetExecutingRequestByNode(int nodeId)
+        {
+            if (!_schedulingData.IsNodeWorking(nodeId))
+            {
+                return null;
+            }
+
+            SchedulableRequest request = _schedulingData.GetExecutingRequestByNode(nodeId);
+            return request.BuildRequest;
+        }
+
         /// <summary>
         /// Reports that the specified request has become blocked and cannot proceed.
         /// </summary>
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 619c476a1f6..7757598b2cd 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -14,6 +14,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -153,11 +154,15 @@ public OutOfProcNode()
 
             // Create a factory for the out-of-proc SDK resolver service which can pass our SendPacket delegate to be used for sending packets to the main node
             OutOfProcNodeSdkResolverServiceFactory sdkResolverServiceFactory = new OutOfProcNodeSdkResolverServiceFactory(SendPacket);
-
             ((IBuildComponentHost)this).RegisterFactory(BuildComponentType.SdkResolverService, sdkResolverServiceFactory.CreateInstance);
-
             _sdkResolverService = (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
 
+#if FEATURE_REPORTFILEACCESSES
+            ((IBuildComponentHost)this).RegisterFactory(
+                BuildComponentType.FileAccessManager,
+                (componentType) => OutOfProcNodeFileAccessManager.CreateComponent(componentType, SendPacket));
+#endif
+
             if (s_projectRootElementCacheBase == null)
             {
                 s_projectRootElementCacheBase = new ProjectRootElementCache(true /* automatically reload any changes from disk */);
@@ -369,6 +374,13 @@ private void OnRequestComplete(BuildRequest request, BuildResult result)
             {
                 _nodeEndpoint.SendData(result);
             }
+
+#if FEATURE_REPORTFILEACCESSES
+            if (_buildParameters.ReportFileAccesses)
+            {
+                FileAccessManager.NotifyFileAccessCompletion(result.GlobalRequestId);
+            }
+#endif
         }
 
         /// <summary>
@@ -575,7 +587,8 @@ private void SendPacket(INodePacket packet)
 #if RUNTIME_TYPE_NETCORE
                 if (packet is LogMessagePacketBase logMessage
                     && logMessage.EventType == LoggingEventType.CustomEvent 
-                    && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) 
+                    &&
+                    (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
                     && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
                 {
                     BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index 8380f9cd3b9..fb954982e34 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -32,6 +32,11 @@
 
 #nullable disable
 
+// The BuildXL package causes an indirect dependency on the RuntimeContracts package, which adds an analyzer which forbids the use of System.Diagnostics.Contract.
+// So effectively if your dependencies use RuntimeContracts, it attempts to force itself on your as well.
+// See: https://github.com/SergeyTeplyakov/RuntimeContracts/issues/12
+#pragma warning disable RA001 // Do not use System.Diagnostics.Contract class.
+
 namespace Microsoft.Build.Collections
 {
     /// <summary>
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
index e979313ca70..05317adadab 100644
--- a/src/Build/CompatibilitySuppressions.xml
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -1,9 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net7.0</Target>
-  </Suppression>
 </Suppressions>
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 645f8810cc0..cfc17374cb3 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -1020,11 +1020,11 @@ public ProjectItem CreateItem(string evaluatedIncludeEscaped, string evaluatedIn
             /// <summary>
             /// Applies the supplied metadata to the destination item.
             /// </summary>
-            public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadata, IEnumerable<ProjectItem> destinationItems)
+            public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadata, IEnumerable<ProjectItem> destinationItems)
             {
                 foreach (IItem<ProjectMetadata> item in destinationItems)
                 {
-                    foreach (Pair<ProjectMetadataElement, string> metadatum in metadata)
+                    foreach (KeyValuePair<ProjectMetadataElement, string> metadatum in metadata)
                     {
                         item.SetMetadata(metadatum.Key, metadatum.Value);
                     }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index f5db7b9d74a..9f298203fa4 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -92,7 +92,7 @@ internal class Evaluator<P, I, M, D>
         /// Key is the directory of the file importing the usingTask, which is needed
         /// to handle any relative paths in the usingTask.
         /// </summary>
-        private readonly List<Pair<string, ProjectUsingTaskElement>> _usingTaskElements;
+        private readonly List<KeyValuePair<string, ProjectUsingTaskElement>> _usingTaskElements;
 
         /// <summary>
         /// List of ProjectTargetElement's traversing into imports.
@@ -249,7 +249,7 @@ private Evaluator(
             _data = data;
             _itemGroupElements = new List<ProjectItemGroupElement>();
             _itemDefinitionGroupElements = new List<ProjectItemDefinitionGroupElement>();
-            _usingTaskElements = new List<Pair<string, ProjectUsingTaskElement>>();
+            _usingTaskElements = new List<KeyValuePair<string, ProjectUsingTaskElement>>();
             _targetElements = new List<ProjectTargetElement>();
             _importsSeen = new Dictionary<string, ProjectImportElement>(StringComparer.OrdinalIgnoreCase);
             _initialTargetsList = new List<string>();
@@ -913,7 +913,7 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
                             EvaluateImportGroupElement(currentProjectOrImport.DirectoryPath, importGroup);
                             break;
                         case ProjectUsingTaskElement usingTask:
-                            _usingTaskElements.Add(new Pair<string, ProjectUsingTaskElement>(currentProjectOrImport.DirectoryPath, usingTask));
+                            _usingTaskElements.Add(new KeyValuePair<string, ProjectUsingTaskElement>(currentProjectOrImport.DirectoryPath, usingTask));
                             break;
                         case ProjectChooseElement choose:
                             EvaluateChooseElement(choose);
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 6e812c58767..c998910190e 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -616,7 +616,7 @@ internal bool ExpandExpressionCapture(
             ExpanderOptions options,
             bool includeNullEntries,
             out bool isTransformExpression,
-            out List<Pair<string, I>> itemsFromCapture)
+            out List<KeyValuePair<string, I>> itemsFromCapture)
         {
             return ItemExpander.ExpandExpressionCapture(this, expressionCapture, _items, elementLocation, options, includeNullEntries, out isTransformExpression, out itemsFromCapture);
         }
@@ -1055,7 +1055,7 @@ internal string ExpandSingleMetadata(Match itemMetadataMatch)
                             _metadata is IItemTypeDefinition itemMetadata &&
                             (string.IsNullOrEmpty(itemType) || string.Equals(itemType, itemMetadata.ItemType, StringComparison.Ordinal)))
                         {
-                            _loggingContext.LogComment(MessageImportance.High, new BuildEventFileInfo(_elementLocation),
+                            _loggingContext.LogComment(MessageImportance.Low, new BuildEventFileInfo(_elementLocation),
                                 "ItemReferencingSelfInTarget", itemMetadata.ItemType, metadataName);
                         }
 
@@ -1742,7 +1742,7 @@ private static class ItemExpander
             /// Execute the list of transform functions.
             /// </summary>
             /// <typeparam name="S">class, IItem.</typeparam>
-            internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expander, bool includeNullEntries, Stack<TransformFunction<S>> transformFunctionStack, IEnumerable<Pair<string, S>> itemsOfType)
+            internal static IEnumerable<KeyValuePair<string, S>> Transform<S>(Expander<P, I> expander, bool includeNullEntries, Stack<TransformFunction<S>> transformFunctionStack, IEnumerable<KeyValuePair<string, S>> itemsOfType)
                 where S : class, IItem
             {
                 // If we have transforms on our stack, then we'll execute those first
@@ -1751,7 +1751,7 @@ internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expande
                 {
                     TransformFunction<S> function = transformFunctionStack.Pop();
 
-                    foreach (Pair<string, S> item in Transform(expander, includeNullEntries, transformFunctionStack, function.Execute(expander, includeNullEntries, itemsOfType)))
+                    foreach (KeyValuePair<string, S> item in Transform(expander, includeNullEntries, transformFunctionStack, function.Execute(expander, includeNullEntries, itemsOfType)))
                     {
                         yield return item;
                     }
@@ -1760,7 +1760,7 @@ internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expande
                 {
                     // When we have no more tranforms on the stack, iterate over the items
                     // that we have to return them
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         yield return item;
                     }
@@ -1893,7 +1893,7 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
                     return result;
                 }
 
-                List<Pair<string, S>> itemsFromCapture;
+                List<KeyValuePair<string, S>> itemsFromCapture;
                 brokeEarlyNonEmpty = ExpandExpressionCapture(expander, expressionCapture, items, elementLocation /* including null items */, options, true, out isTransformExpression, out itemsFromCapture);
 
                 if (brokeEarlyNonEmpty)
@@ -1959,7 +1959,7 @@ internal static bool ExpandExpressionCapture<S>(
                 ExpanderOptions options,
                 bool includeNullEntries,
                 out bool isTransformExpression,
-                out List<Pair<string, S>> itemsFromCapture)
+                out List<KeyValuePair<string, S>> itemsFromCapture)
                 where S : class, IItem
             {
                 ErrorUtilities.VerifyThrow(evaluatedItems != null, "Cannot expand items without providing items");
@@ -1980,7 +1980,7 @@ internal static bool ExpandExpressionCapture<S>(
                         if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) ||
                             expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "AnyHaveMetadataValue", StringComparison.OrdinalIgnoreCase)) != true)
                         {
-                            itemsFromCapture = new List<Pair<string, S>>();
+                            itemsFromCapture = new List<KeyValuePair<string, S>>();
                             return false;
                         }
                     }
@@ -1991,7 +1991,7 @@ internal static bool ExpandExpressionCapture<S>(
                     isTransformExpression = true;
                 }
 
-                itemsFromCapture = new List<Pair<string, S>>(itemsOfType.Count);
+                itemsFromCapture = new List<KeyValuePair<string, S>>(itemsOfType.Count);
 
                 if (!isTransformExpression)
                 {
@@ -2003,7 +2003,7 @@ internal static bool ExpandExpressionCapture<S>(
                             return true;
                         }
 
-                        itemsFromCapture.Add(new Pair<string, S>(item.EvaluatedIncludeEscaped, item));
+                        itemsFromCapture.Add(new KeyValuePair<string, S>(item.EvaluatedIncludeEscaped, item));
                     }
                 }
                 else
@@ -2011,7 +2011,7 @@ internal static bool ExpandExpressionCapture<S>(
                     Stack<TransformFunction<S>> transformFunctionStack = PrepareTransformStackFromMatch<S>(elementLocation, expressionCapture);
 
                     // iterate over the tranform chain, creating the final items from its results
-                    foreach (Pair<string, S> itemTuple in Transform<S>(expander, includeNullEntries, transformFunctionStack, IntrinsicItemFunctions<S>.GetItemPairEnumerable(itemsOfType)))
+                    foreach (KeyValuePair<string, S> itemTuple in Transform<S>(expander, includeNullEntries, transformFunctionStack, IntrinsicItemFunctions<S>.GetItemPairEnumerable(itemsOfType)))
                     {
                         if (!string.IsNullOrEmpty(itemTuple.Key) && (options & ExpanderOptions.BreakOnNotEmpty) != 0)
                         {
@@ -2026,7 +2026,7 @@ internal static bool ExpandExpressionCapture<S>(
                 {
                     var joinedItems = string.Join(expressionCapture.Separator, itemsFromCapture.Select(i => i.Key));
                     itemsFromCapture.Clear();
-                    itemsFromCapture.Add(new Pair<string, S>(joinedItems, null));
+                    itemsFromCapture.Add(new KeyValuePair<string, S>(joinedItems, null));
                 }
 
                 return false; // did not break early
@@ -2144,7 +2144,7 @@ private static bool ExpandExpressionCaptureIntoStringBuilder<S>(
                 ExpanderOptions options)
                 where S : class, IItem
             {
-                List<Pair<string, S>> itemsFromCapture;
+                List<KeyValuePair<string, S>> itemsFromCapture;
                 bool throwaway;
                 var brokeEarlyNonEmpty = ExpandExpressionCapture(expander, capture, evaluatedItems, elementLocation /* including null items */, options, true, out throwaway, out itemsFromCapture);
 
@@ -2205,7 +2205,7 @@ internal static class IntrinsicItemFunctions<S>
                 /// Delegate that represents the signature of all item transformation functions
                 /// This is used to support calling the functions by name.
                 /// </summary>
-                public delegate IEnumerable<Pair<string, S>> ItemTransformFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments);
+                public delegate IEnumerable<KeyValuePair<string, S>> ItemTransformFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments);
 
                 /// <summary>
                 /// Get a delegate to the given item transformation function by supplying the name and the
@@ -2268,7 +2268,7 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation
                 /// Create an enumerator from a base IEnumerable of items into an enumerable
                 /// of transformation result which includes the new itemspec and the base item.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType)
+                internal static IEnumerable<KeyValuePair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType)
                 {
                     // iterate over the items, and yield out items in the tuple format
                     foreach (var item in itemsOfType)
@@ -2281,12 +2281,12 @@ internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S
                                     item.EvaluatedIncludeEscaped,
                                     forceEvaluate: true))
                             {
-                                yield return new Pair<string, S>(resultantItem, item);
+                                yield return new KeyValuePair<string, S>(resultantItem, item);
                             }
                         }
                         else
                         {
-                            yield return new Pair<string, S>(item.EvaluatedIncludeEscaped, item);
+                            yield return new KeyValuePair<string, S>(item.EvaluatedIncludeEscaped, item);
                         }
                     }
                 }
@@ -2294,20 +2294,20 @@ internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S
                 /// <summary>
                 /// Intrinsic function that returns the number of items in the list.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Count(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Count(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
-                    yield return new Pair<string, S>(Convert.ToString(itemsOfType.Count(), CultureInfo.InvariantCulture), null /* no base item */);
+                    yield return new KeyValuePair<string, S>(Convert.ToString(itemsOfType.Count(), CultureInfo.InvariantCulture), null /* no base item */);
                 }
 
                 /// <summary>
                 /// Intrinsic function that returns the specified built-in modifer value of the items in itemsOfType
                 /// Tuple is {current item include, item under transformation}.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> ItemSpecModifierFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         // If the item include has become empty,
                         // this is the end of the pipeline for this item
@@ -2339,11 +2339,11 @@ internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P
                         {
                             // GetItemSpecModifier will have returned us an escaped string
                             // there is nothing more to do than yield it into the pipeline
-                            yield return new Pair<string, S>(result, item.Value);
+                            yield return new KeyValuePair<string, S>(result, item.Value);
                         }
                         else if (includeNullEntries)
                         {
-                            yield return new Pair<string, S>(null, item.Value);
+                            yield return new KeyValuePair<string, S>(null, item.Value);
                         }
                     }
                 }
@@ -2351,11 +2351,11 @@ internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P
                 /// <summary>
                 /// Intrinsic function that returns the subset of items that actually exist on disk.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Exists(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Exists(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (String.IsNullOrEmpty(item.Key))
                         {
@@ -2398,13 +2398,13 @@ internal static IEnumerable<Pair<string, S>> Exists(Expander<P, I> expander, IEl
                 /// <summary>
                 /// Intrinsic function that combines the existing paths of the input items with a given relative path.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Combine(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Combine(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string relativePath = arguments[0];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (String.IsNullOrEmpty(item.Key))
                         {
@@ -2415,14 +2415,14 @@ internal static IEnumerable<Pair<string, S>> Combine(Expander<P, I> expander, IE
                         string unescapedPath = EscapingUtilities.UnescapeAll(item.Key);
                         string combinedPath = Path.Combine(unescapedPath, relativePath);
                         string escapedPath = EscapingUtilities.Escape(combinedPath);
-                        yield return new Pair<string, S>(escapedPath, null);
+                        yield return new KeyValuePair<string, S>(escapedPath, null);
                     }
                 }
 
                 /// <summary>
                 /// Intrinsic function that returns all ancestor directories of the given items.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> GetPathsOfAllDirectoriesAbove(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
@@ -2430,7 +2430,7 @@ internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expan
 
                     SortedSet<string> directories = new SortedSet<string>(StringComparer.OrdinalIgnoreCase);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (String.IsNullOrEmpty(item.Key))
                         {
@@ -2490,7 +2490,7 @@ internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expan
                     foreach (string directoryPath in directories)
                     {
                         string escapedDirectoryPath = EscapingUtilities.Escape(directoryPath);
-                        yield return new Pair<string, S>(escapedDirectoryPath, null);
+                        yield return new KeyValuePair<string, S>(escapedDirectoryPath, null);
                     }
                 }
 
@@ -2498,13 +2498,13 @@ internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expan
                 /// Intrinsic function that returns the DirectoryName of the items in itemsOfType
                 /// UNDONE: This can be removed in favor of a built-in %(DirectoryName) metadata in future.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> DirectoryName(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     Dictionary<string, string> directoryNameTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         // If the item include has become empty,
                         // this is the end of the pipeline for this item
@@ -2553,11 +2553,11 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                         if (!String.IsNullOrEmpty(directoryName))
                         {
                             // return a result through the enumerator
-                            yield return new Pair<string, S>(directoryName, item.Value);
+                            yield return new KeyValuePair<string, S>(directoryName, item.Value);
                         }
                         else if (includeNullEntries)
                         {
-                            yield return new Pair<string, S>(null, item.Value);
+                            yield return new KeyValuePair<string, S>(null, item.Value);
                         }
                     }
                 }
@@ -2565,13 +2565,13 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                 /// <summary>
                 /// Intrinsic function that returns the contents of the metadata in specified in argument[0].
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Metadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (item.Value != null)
                         {
@@ -2598,18 +2598,18 @@ internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, I
                                     foreach (string itemSpec in splits)
                                     {
                                         // return a result through the enumerator
-                                        yield return new Pair<string, S>(itemSpec, item.Value);
+                                        yield return new KeyValuePair<string, S>(itemSpec, item.Value);
                                     }
                                 }
                                 else
                                 {
                                     // return a result through the enumerator
-                                    yield return new Pair<string, S>(metadataValue, item.Value);
+                                    yield return new KeyValuePair<string, S>(metadataValue, item.Value);
                                 }
                             }
                             else if (metadataValue != String.Empty && includeNullEntries)
                             {
-                                yield return new Pair<string, S>(metadataValue, item.Value);
+                                yield return new KeyValuePair<string, S>(metadataValue, item.Value);
                             }
                         }
                     }
@@ -2619,7 +2619,7 @@ internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, I
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
                 /// Using a case sensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> DistinctWithCase(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> DistinctWithCase(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     return DistinctWithComparer(expander, elementLocation, includeNullEntries, functionName, itemsOfType, arguments, StringComparer.Ordinal);
                 }
@@ -2628,7 +2628,7 @@ internal static IEnumerable<Pair<string, S>> DistinctWithCase(Expander<P, I> exp
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Distinct(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     return DistinctWithComparer(expander, elementLocation, includeNullEntries, functionName, itemsOfType, arguments, StringComparer.OrdinalIgnoreCase);
                 }
@@ -2637,20 +2637,18 @@ internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, I
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> DistinctWithComparer(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments, StringComparer comparer)
+                internal static IEnumerable<KeyValuePair<string, S>> DistinctWithComparer(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments, StringComparer comparer)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     // This dictionary will ensure that we only return one result per unique itemspec
-                    Dictionary<string, S> seenItems = new Dictionary<string, S>(comparer);
+                    HashSet<string> seenItems = new HashSet<string>(comparer);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
-                        if (item.Key != null && !seenItems.ContainsKey(item.Key))
+                        if (item.Key != null && seenItems.Add(item.Key))
                         {
-                            seenItems[item.Key] = item.Value;
-
-                            yield return new Pair<string, S>(item.Key, item.Value);
+                            yield return item;
                         }
                     }
                 }
@@ -2658,23 +2656,20 @@ internal static IEnumerable<Pair<string, S>> DistinctWithComparer(Expander<P, I>
                 /// <summary>
                 /// Intrinsic function reverses the item list.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Reverse(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Reverse(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
-                    foreach (Pair<String, S> item in itemsOfType.Reverse())
-                    {
-                        yield return new Pair<string, S>(item.Key, item.Value);
-                    }
+                    return itemsOfType.Reverse();
                 }
 
                 /// <summary>
                 /// Intrinsic function that transforms expressions like the %(foo) in @(Compile->'%(foo)').
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> ExpandQuotedExpressionFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         MetadataMatchEvaluator matchEvaluator;
                         string include = null;
@@ -2697,11 +2692,11 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
                         // We pass in the existing item so we can copy over its metadata
                         if (!string.IsNullOrEmpty(include))
                         {
-                            yield return new Pair<string, S>(include, item.Value);
+                            yield return new KeyValuePair<string, S>(include, item.Value);
                         }
                         else if (includeNullEntries)
                         {
-                            yield return new Pair<string, S>(null, item.Value);
+                            yield return new KeyValuePair<string, S>(null, item.Value);
                         }
                     }
                 }
@@ -2710,17 +2705,17 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
                 /// Intrinsic function that transforms expressions by invoking methods of System.String on the itemspec
                 /// of the item in the pipeline.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
+                internal static IEnumerable<KeyValuePair<string, S>> ExecuteStringFunction(
                     Expander<P, I> expander,
                     IElementLocation elementLocation,
                     bool includeNullEntries,
                     string functionName,
-                    IEnumerable<Pair<string, S>> itemsOfType,
+                    IEnumerable<KeyValuePair<string, S>> itemsOfType,
                     string[] arguments)
                 {
                     // Transform: expression is like @(Compile->'%(foo)'), so create completely new items,
                     // using the Include from the source items
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         Function<P> function = new Function<P>(
                             typeof(string),
@@ -2740,11 +2735,11 @@ internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                         // We pass in the existing item so we can copy over its metadata
                         if (include.Length > 0)
                         {
-                            yield return new Pair<string, S>(include, item.Value);
+                            yield return new KeyValuePair<string, S>(include, item.Value);
                         }
                         else if (includeNullEntries)
                         {
-                            yield return new Pair<string, S>(null, item.Value);
+                            yield return new KeyValuePair<string, S>(null, item.Value);
                         }
                     }
                 }
@@ -2752,15 +2747,15 @@ internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                 /// <summary>
                 /// Intrinsic function that returns the items from itemsOfType with their metadata cleared, i.e. only the itemspec is retained.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> ClearMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (includeNullEntries || item.Key != null)
                         {
-                            yield return new Pair<string, S>(item.Key, null);
+                            yield return new KeyValuePair<string, S>(item.Key, null);
                         }
                     }
                 }
@@ -2769,13 +2764,13 @@ internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expand
                 /// Intrinsic function that returns only those items that have a not-blank value for the metadata specified
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> HasMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         string metadataValue = null;
 
@@ -2794,7 +2789,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
                         if (!string.IsNullOrEmpty(metadataValue))
                         {
                             // return a result through the enumerator
-                            yield return new Pair<string, S>(item.Key, item.Value);
+                            yield return item;
                         }
                     }
                 }
@@ -2803,14 +2798,14 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
                 /// Intrinsic function that returns only those items have the given metadata value
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> WithMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
                     string metadataValueToFind = arguments[1];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         string metadataValue = null;
 
@@ -2827,7 +2822,7 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
                         if (metadataValue != null && String.Equals(metadataValue, metadataValueToFind, StringComparison.OrdinalIgnoreCase))
                         {
                             // return a result through the enumerator
-                            yield return new Pair<string, S>(item.Key, item.Value);
+                            yield return item;
                         }
                     }
                 }
@@ -2836,14 +2831,14 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
                 /// Intrinsic function that returns those items don't have the given metadata value
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> WithoutMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> WithoutMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
                     string metadataValueToFind = arguments[1];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         string metadataValue = null;
 
@@ -2860,7 +2855,7 @@ internal static IEnumerable<Pair<string, S>> WithoutMetadataValue(Expander<P, I>
                         if (!String.Equals(metadataValue, metadataValueToFind, StringComparison.OrdinalIgnoreCase))
                         {
                             // return a result through the enumerator
-                            yield return new Pair<string, S>(item.Key, item.Value);
+                            yield return item;
                         }
                     }
                 }
@@ -2869,7 +2864,7 @@ internal static IEnumerable<Pair<string, S>> WithoutMetadataValue(Expander<P, I>
                 /// Intrinsic function that returns a boolean to indicate if any of the items have the given metadata value
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> AnyHaveMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
@@ -2877,7 +2872,7 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
                     string metadataValueToFind = arguments[1];
                     bool metadataFound = false;
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (item.Value != null)
                         {
@@ -2898,7 +2893,7 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
                                 metadataFound = true;
 
                                 // return a result through the enumerator
-                                yield return new Pair<string, S>("true", item.Value);
+                                yield return new KeyValuePair<string, S>("true", item.Value);
 
                                 // break out as soon as we found a match
                                 yield break;
@@ -2909,7 +2904,7 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
                     if (!metadataFound)
                     {
                         // We did not locate an item with the required metadata
-                        yield return new Pair<string, S>("false", null);
+                        yield return new KeyValuePair<string, S>("false", null);
                     }
                 }
             }
@@ -2971,7 +2966,7 @@ public IElementLocation ElementLocation
                 /// <summary>
                 /// Execute this transform function with the arguments contained within this TransformFunction instance.
                 /// </summary>
-                public IEnumerable<Pair<string, S>> Execute(Expander<P, I> expander, bool includeNullEntries, IEnumerable<Pair<string, S>> itemsOfType)
+                public IEnumerable<KeyValuePair<string, S>> Execute(Expander<P, I> expander, bool includeNullEntries, IEnumerable<KeyValuePair<string, S>> itemsOfType)
                 {
                     // Execute via the delegate
                     return _transform(expander, _elementLocation, includeNullEntries, _functionName, itemsOfType, _arguments);
diff --git a/src/Build/Evaluation/IItemFactory.cs b/src/Build/Evaluation/IItemFactory.cs
index 2125968bf6c..986386cd7a0 100644
--- a/src/Build/Evaluation/IItemFactory.cs
+++ b/src/Build/Evaluation/IItemFactory.cs
@@ -68,6 +68,6 @@ ProjectItemElement ItemElement
         /// <summary>
         /// Applies the supplied metadata to the destination items.
         /// </summary>
-        void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadata, IEnumerable<T> destinationItems);
+        void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadata, IEnumerable<T> destinationItems);
     }
 }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs b/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs
index 722d467c342..99c7166189b 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs
@@ -75,7 +75,7 @@ public I CreateItem(string include, I baseItem, string definingProject)
                 return _wrappedItemFactory.CreateItem(include, baseItem, definingProject);
             }
 
-            public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadata, IEnumerable<I> destinationItems)
+            public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadata, IEnumerable<I> destinationItems)
             {
                 SetItemElement();
                 _wrappedItemFactory.SetMetadata(metadata, destinationItems);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 43fffb961a6..fe8b1805bab 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -230,7 +230,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                         _expander.Metadata = metadataTable;
 
                         // Also keep a list of everything so we can get the predecessor objects correct.
-                        List<Pair<ProjectMetadataElement, string>> metadataList = new(metadata.Length);
+                        List<KeyValuePair<ProjectMetadataElement, string>> metadataList = new(metadata.Length);
 
                         foreach (var metadataElement in metadata)
                         {
@@ -252,7 +252,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                             evaluatedValue = FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath);
 
                             metadataTable.SetValue(metadataElement, evaluatedValue);
-                            metadataList.Add(new Pair<ProjectMetadataElement, string>(metadataElement, evaluatedValue));
+                            metadataList.Add(new KeyValuePair<ProjectMetadataElement, string>(metadataElement, evaluatedValue));
                         }
 
                         // Apply those metadata to each item
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 4db93ab3bb0..cf6fc186770 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -2007,7 +2007,7 @@ public ProjectItemInstance CreateItem(string evaluatedInclude, string evaluatedI
                 /// <summary>
                 /// Applies the supplied metadata to the destination item.
                 /// </summary>
-                public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadataList, IEnumerable<ProjectItemInstance> destinationItems)
+                public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadataList, IEnumerable<ProjectItemInstance> destinationItems)
                 {
                     // Set up a single dictionary that can be applied to all the items
                     CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
@@ -2172,7 +2172,7 @@ public TaskItem CreateItem(string includeEscaped, string includeBeforeWildcardEx
                 /// <summary>
                 /// Applies the supplied metadata to the destination item.
                 /// </summary>
-                public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadata, IEnumerable<TaskItem> destinationItems)
+                public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadata, IEnumerable<TaskItem> destinationItems)
                 {
                     // Not difficult to implement, but we do not expect to go here.
                     ErrorUtilities.ThrowInternalErrorUnreachable();
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 0b874696321..a77509a9120 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -1,4 +1,4 @@
-// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -9,7 +9,9 @@
 using System.Threading;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.FileAccess;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
@@ -433,6 +435,17 @@ private void HandlePacket(INodePacket packet, out bool taskFinished)
         /// </summary>
         private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplete)
         {
+#if FEATURE_REPORTFILEACCESSES
+            if (taskHostTaskComplete.FileAccessData?.Count > 0)
+            {
+                IFileAccessManager fileAccessManager = ((IFileAccessManager)_buildComponentHost.GetComponent(BuildComponentType.FileAccessManager));
+                foreach (FileAccessData fileAccessData in taskHostTaskComplete.FileAccessData)
+                {
+                    fileAccessManager.ReportFileAccess(fileAccessData, _buildComponentHost.BuildParameters.NodeId);
+                }
+            }
+#endif
+
             // If it crashed, or if it failed, it didn't succeed.   
             _taskExecutionSucceeded = taskHostTaskComplete.TaskResult == TaskCompleteType.Success ? true : false;
 
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index b7014cd6ac2..f4143ccaae7 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -272,12 +272,7 @@ internal void WriteLinePretty(int indentLevel, string formattedString)
         /// </summary>
         internal void IsRunningWithCharacterFileType()
         {
-            runningWithCharacterFileType = false;
-
-            if (NativeMethodsShared.IsWindows)
-            {
-                runningWithCharacterFileType = ConsoleConfiguration.OutputIsScreen;
-            }
+            runningWithCharacterFileType = NativeMethodsShared.IsWindows && ConsoleConfiguration.OutputIsScreen;
         }
 
         /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 9a43d3e30de..c01095f73b9 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -64,7 +64,9 @@ public sealed class BinaryLogger : ILogger
         // version 17:
         //   - Making ProjectStartedEventArgs, ProjectEvaluationFinishedEventArgs, AssemblyLoadBuildEventArgs equal
         //     between de/serialization roundtrips.
-        internal const int FileFormatVersion = 17;
+        // version 18:
+        //   - Added extended data for types implementing IExtendedBuildEventArgs
+        internal const int FileFormatVersion = 18;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs
index 65468da0972..0f579c2a549 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs
@@ -29,6 +29,7 @@ internal enum BuildEventArgsFieldFlags
         EndLineNumber = 1 << 12,
         EndColumnNumber = 1 << 13,
         Arguments = 1 << 14,
-        Importance = 1 << 15
+        Importance = 1 << 15,
+        Extended = 1 << 16,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsFields.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsFields.cs
index f5aba4eb60c..fcc7c4433ff 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsFields.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsFields.cs
@@ -32,5 +32,6 @@ internal class BuildEventArgsFields
         public int ColumnNumber { get; set; }
         public int EndLineNumber { get; set; }
         public int EndColumnNumber { get; set; }
+        public ExtendedDataFields Extended { get; set; }
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index fb7dacd422a..f2c6365cb6f 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -216,8 +216,6 @@ public void Dispose()
                 case BinaryLogRecordKind.AssemblyLoad:
                     result = ReadAssemblyLoadEventArgs();
                     break;
-                default:
-                    break;
             }
 
             recordNumber += 1;
@@ -702,21 +700,50 @@ private BuildEventArgs ReadBuildErrorEventArgs()
             var fields = ReadBuildEventArgsFields();
             ReadDiagnosticFields(fields);
 
-            var e = new BuildErrorEventArgs(
-                fields.Subcategory,
-                fields.Code,
-                fields.File,
-                fields.LineNumber,
-                fields.ColumnNumber,
-                fields.EndLineNumber,
-                fields.EndColumnNumber,
-                fields.Message,
-                fields.HelpKeyword,
-                fields.SenderName,
-                fields.Timestamp,
-                fields.Arguments);
+            BuildEventArgs e;
+            if (fields.Extended == null)
+            {
+                e = new BuildErrorEventArgs(
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile
+                };
+            }
+            else
+            {
+                e = new ExtendedBuildErrorEventArgs(
+                    fields.Extended.ExtendedType,
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                    ExtendedMetadata = fields.Extended.ExtendedMetadata,
+                    ExtendedData = fields.Extended.ExtendedData,
+                };
+            }
             e.BuildEventContext = fields.BuildEventContext;
-            e.ProjectFile = fields.ProjectFile;
+                
             return e;
         }
 
@@ -725,21 +752,50 @@ private BuildEventArgs ReadBuildWarningEventArgs()
             var fields = ReadBuildEventArgsFields();
             ReadDiagnosticFields(fields);
 
-            var e = new BuildWarningEventArgs(
-                fields.Subcategory,
-                fields.Code,
-                fields.File,
-                fields.LineNumber,
-                fields.ColumnNumber,
-                fields.EndLineNumber,
-                fields.EndColumnNumber,
-                fields.Message,
-                fields.HelpKeyword,
-                fields.SenderName,
-                fields.Timestamp,
-                fields.Arguments);
+            BuildEventArgs e;
+            if (fields.Extended == null)
+            {
+                e = new BuildWarningEventArgs(
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile
+                };
+            }
+            else
+            {
+                e = new ExtendedBuildWarningEventArgs(
+                    fields.Extended.ExtendedType,
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                    ExtendedMetadata = fields.Extended.ExtendedMetadata,
+                    ExtendedData = fields.Extended.ExtendedData,
+                };
+            }
             e.BuildEventContext = fields.BuildEventContext;
-            e.ProjectFile = fields.ProjectFile;
+
             return e;
         }
 
@@ -747,22 +803,53 @@ private BuildEventArgs ReadBuildMessageEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
 
-            var e = new BuildMessageEventArgs(
-                fields.Subcategory,
-                fields.Code,
-                fields.File,
-                fields.LineNumber,
-                fields.ColumnNumber,
-                fields.EndLineNumber,
-                fields.EndColumnNumber,
-                fields.Message,
-                fields.HelpKeyword,
-                fields.SenderName,
-                fields.Importance,
-                fields.Timestamp,
-                fields.Arguments);
+            BuildEventArgs e;
+            if (fields.Extended == null)
+            {
+                e = new BuildMessageEventArgs(
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Importance,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                };
+            }
+            else
+            {
+                e = new ExtendedBuildMessageEventArgs(
+                    fields.Extended?.ExtendedType ?? string.Empty,
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Importance,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                    ExtendedMetadata = fields.Extended?.ExtendedMetadata,
+                    ExtendedData = fields.Extended?.ExtendedData,
+                };
+            }
+
             e.BuildEventContext = fields.BuildEventContext;
-            e.ProjectFile = fields.ProjectFile;
+
             return e;
         }
 
@@ -954,12 +1041,23 @@ private void ReadDiagnosticFields(BuildEventArgsFields fields)
             fields.EndColumnNumber = ReadInt32();
         }
 
+        private ExtendedDataFields? ReadExtendedDataFields()
+        {
+            string extendedType = ReadOptionalString()!;
+            IDictionary<string, string?>? extendedMetadata = ReadStringDictionary()!;
+            string? extendedData = ReadOptionalString();
+
+            return new ExtendedDataFields(extendedType, extendedMetadata, extendedData);
+        }
+
         private BuildEventArgsFields ReadBuildEventArgsFields(bool readImportance = false)
         {
             BuildEventArgsFieldFlags flags = (BuildEventArgsFieldFlags)ReadInt32();
             var result = new BuildEventArgsFields();
             result.Flags = flags;
 
+            // Base Fields
+
             if ((flags & BuildEventArgsFieldFlags.Message) != 0)
             {
                 result.Message = ReadDeduplicatedString();
@@ -990,6 +1088,13 @@ private BuildEventArgsFields ReadBuildEventArgsFields(bool readImportance = fals
                 result.Timestamp = ReadDateTime();
             }
 
+            if ((flags & BuildEventArgsFieldFlags.Extended) != 0)
+            {
+                result.Extended = ReadExtendedDataFields();
+            }
+
+            // End of BaseFields
+
             if ((flags & BuildEventArgsFieldFlags.Subcategory) != 0)
             {
                 result.Subcategory = ReadDeduplicatedString();
@@ -1349,9 +1454,9 @@ private bool ReadBoolean()
             return binaryReader.ReadBoolean();
         }
 
-        private unsafe Guid ReadGuid()
+        private Guid ReadGuid()
         {
-            return new Guid(binaryReader.ReadBytes(sizeof(Guid)));
+            return new Guid(binaryReader.ReadBytes(16 /*sizeof(Guid) - to avoid unsafe context, Guid will never change in size */));
         }
 
         private DateTime ReadDateTime()
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index ba6956cee42..99ffe22d96d 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -199,12 +199,31 @@ private void WriteCore(BuildEventArgs e)
                 default:
                     // convert all unrecognized objects to message
                     // and just preserve the message
-                    var buildMessageEventArgs = new BuildMessageEventArgs(
-                        e.Message,
-                        e.HelpKeyword,
-                        e.SenderName,
-                        MessageImportance.Normal,
-                        e.Timestamp);
+                    BuildMessageEventArgs buildMessageEventArgs;
+                    if (e is IExtendedBuildEventArgs extendedData)
+                    {
+                        // For Extended events convert to ExtendedBuildMessageEventArgs
+                        buildMessageEventArgs = new ExtendedBuildMessageEventArgs(
+                            extendedData.ExtendedType,
+                            e.Message,
+                            e.HelpKeyword,
+                            e.SenderName,
+                            MessageImportance.Normal,
+                            e.Timestamp)
+                        {
+                            ExtendedData = extendedData.ExtendedData,
+                            ExtendedMetadata = extendedData.ExtendedMetadata,
+                        };
+                    }
+                    else
+                    {
+                        buildMessageEventArgs = new BuildMessageEventArgs(
+                            e.Message,
+                            e.HelpKeyword,
+                            e.SenderName,
+                            MessageImportance.Normal,
+                            e.Timestamp);
+                    }
                     buildMessageEventArgs.BuildEventContext = e.BuildEventContext ?? BuildEventContext.Invalid;
                     Write(buildMessageEventArgs);
                     break;
@@ -584,6 +603,11 @@ private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags)
             {
                 Write(e.Timestamp);
             }
+
+            if ((flags & BuildEventArgsFieldFlags.Extended) != 0)
+            {
+                Write(e as IExtendedBuildEventArgs);
+            }
         }
 
         private void WriteMessageFields(BuildMessageEventArgs e, bool writeMessage = true, bool writeImportance = false)
@@ -749,6 +773,11 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
                 flags |= BuildEventArgsFieldFlags.Timestamp;
             }
 
+            if (e is IExtendedBuildEventArgs extendedData)
+            {
+                flags |= BuildEventArgsFieldFlags.Extended;
+            }
+
             return flags;
         }
 
@@ -1218,6 +1247,16 @@ private void Write(ProfiledLocation e)
             Write(e.InclusiveTime);
         }
 
+        private void Write(IExtendedBuildEventArgs extendedData)
+        {
+            if (extendedData?.ExtendedType != null)
+            {
+                WriteDeduplicatedString(extendedData.ExtendedType);
+                Write(extendedData.ExtendedMetadata);
+                WriteDeduplicatedString(extendedData.ExtendedData);
+            }
+        }
+
         internal readonly struct HashKey : IEquatable<HashKey>
         {
             private readonly ulong value;
diff --git a/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs b/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs
new file mode 100644
index 00000000000..2a227e9d69c
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs
@@ -0,0 +1,20 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Logging;
+
+internal class ExtendedDataFields
+{
+    public ExtendedDataFields(string extendedType, IDictionary<string, string?>? extendedMetadata, string? extendedData)
+    {
+        ExtendedType = extendedType;
+        ExtendedMetadata = extendedMetadata;
+        ExtendedData = extendedData;
+    }
+
+    public string ExtendedType { get; }
+    public IDictionary<string, string?>? ExtendedMetadata { get; }
+    public string? ExtendedData { get; }
+}
diff --git a/src/Build/Logging/ProfilerLogger.cs b/src/Build/Logging/ProfilerLogger.cs
index a67d513a099..7f12efba35c 100644
--- a/src/Build/Logging/ProfilerLogger.cs
+++ b/src/Build/Logging/ProfilerLogger.cs
@@ -219,7 +219,7 @@ private static Dictionary<EvaluationLocation, ProfiledLocation> PruneSmallItems(
 
             // Let's build an index of profiled locations by id, to speed up subsequent queries
             var idTable = aggregatedLocations.ToDictionary(pair => pair.Key.Id,
-                pair => new Pair<EvaluationLocation, ProfiledLocation>(pair.Key, pair.Value));
+                pair => new KeyValuePair<EvaluationLocation, ProfiledLocation>(pair.Key, pair.Value));
 
             // We want to keep all evaluation pass entries plus the big enough regular entries
             foreach (var prunedPair in aggregatedLocations.Where(pair =>
@@ -237,7 +237,7 @@ private static Dictionary<EvaluationLocation, ProfiledLocation> PruneSmallItems(
         /// <summary>
         /// Finds the first ancestor of parentId (which could be itself) that is either an evaluation pass location or a big enough profiled data.
         /// </summary>
-        private static long? FindBigEnoughParentId(IDictionary<long, Pair<EvaluationLocation, ProfiledLocation>> idTable,
+        private static long? FindBigEnoughParentId(IDictionary<long, KeyValuePair<EvaluationLocation, ProfiledLocation>> idTable,
             long? parentId)
         {
             // The parent id is null, which means the item was pointing to an evaluation pass item. So we keep it as is.
diff --git a/src/Build/Logging/SimpleErrorLogger.cs b/src/Build/Logging/SimpleErrorLogger.cs
index 8f4a793b8ee..6414324064b 100644
--- a/src/Build/Logging/SimpleErrorLogger.cs
+++ b/src/Build/Logging/SimpleErrorLogger.cs
@@ -3,6 +3,7 @@
 
 using System;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Logging.TerminalLogger;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging.SimpleErrorLogger
@@ -19,8 +20,11 @@ namespace Microsoft.Build.Logging.SimpleErrorLogger
     /// </summary>
     public sealed class SimpleErrorLogger : INodeLogger
     {
+        private readonly bool acceptAnsiColorCodes;
+        private readonly uint? originalConsoleMode;
         public SimpleErrorLogger()
         {
+            (acceptAnsiColorCodes, _, originalConsoleMode) = NativeMethods.QueryIsScreenAndTryEnableAnsiColorCodes(NativeMethods.StreamHandleType.StdErr);
         }
 
         public bool HasLoggedErrors { get; private set; } = false;
@@ -41,21 +45,37 @@ public void Initialize(IEventSource eventSource, int nodeCount)
         {
             eventSource.ErrorRaised += HandleErrorEvent;
             eventSource.WarningRaised += HandleWarningEvent;
+
+            // This needs to happen so binary loggers can get evaluation properties and items
+            if (eventSource is IEventSource4 eventSource4)
+            {
+                eventSource4.IncludeEvaluationPropertiesAndItems();
+            }
         }
 
         private void HandleErrorEvent(object sender, BuildErrorEventArgs e)
         {
             HasLoggedErrors = true;
-            Console.Error.Write("\x1b[31;1m");
-            Console.Error.Write(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true));
-            Console.Error.WriteLine("\x1b[m");
+            LogWithColor(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true),
+                TerminalColor.Red);
         }
 
         private void HandleWarningEvent(object sender, BuildWarningEventArgs e)
         {
-            Console.Error.Write("\x1b[33;1m");
-            Console.Error.Write(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true));
-            Console.Error.WriteLine("\x1b[m");
+            LogWithColor(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true),
+                TerminalColor.Yellow);
+        }
+
+        private void LogWithColor(string message, TerminalColor color)
+        {
+            if (acceptAnsiColorCodes)
+            {
+                Console.Error.Write(AnsiCodes.Colorize(message, color));
+            }
+            else
+            {
+                Console.Error.Write(message);
+            }
         }
 
         public void Initialize(IEventSource eventSource)
@@ -65,6 +85,7 @@ public void Initialize(IEventSource eventSource)
 
         public void Shutdown()
         {
+            NativeMethods.RestoreConsoleMode(originalConsoleMode, NativeMethods.StreamHandleType.StdErr);
         }
     }
 }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index b3e03043a4e..12387bcce58 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -32,12 +32,15 @@
 
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
+    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
     <PackageReference Include="System.Reflection.MetadataLoadContext" />
 
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+
+    <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildFromSource)' != 'true'">
@@ -51,7 +54,6 @@
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="System.Reflection.Metadata" />
-    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Text.Encoding.CodePages" />
   </ItemGroup>
 
@@ -84,9 +86,6 @@
     <Compile Include="..\Shared\NGen.cs">
       <Link>SharedUtilities\NGen.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\Pair.cs">
-      <Link>SharedUtilities\Pair.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\PropertyParser.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\PropertyParser.cs</Link>
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
@@ -152,8 +151,14 @@
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\ProjectCache\*.cs" />
     <Compile Include="BackEnd\Components\Communications\CurrentHost.cs" />
+    <Compile Include="BackEnd\Components\Communications\DetouredNodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\SerializationContractInitializer.cs" />
     <Compile Include="BackEnd\Components\Communications\ServerNodeEndpointOutOfProc.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\IFileAccessManager.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\FileAccessManager.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\FileAccessReport.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\OutOfProcNodeFileAccessManager.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\ProcessReport.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\AssemblyLoadsTracker.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
@@ -173,6 +178,10 @@
     <Compile Include="Logging\BinaryLogger\Postprocessing\IEmbeddedContentSource.cs" />
     <Compile Include="Logging\BinaryLogger\Postprocessing\StringReadEventArgs.cs" />
     <Compile Include="Logging\BinaryLogger\Postprocessing\SubStream.cs" />
+    <Compile Include="Logging\BinaryLogger\ExtendedDataFields.cs" />
+    <Compile Include="Logging\BinaryLogger\IBuildEventArgsReaderNotifications.cs" />
+    <Compile Include="Logging\BinaryLogger\IBuildEventStringsReader.cs" />
+    <Compile Include="Logging\BinaryLogger\StringReadEventArgs.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
@@ -372,6 +381,7 @@
     <Compile Include="BackEnd\Shared\TargetResult.cs" />
     <Compile Include="BackEnd\Shared\WorkUnitResult.cs" />
     <Compile Include="BackEnd\Components\BuildRequestEngine\IBuildRequestEngine.cs" />
+    <Compile Include="BackEnd\Components\Communications\INodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\INodeManager.cs" />
     <Compile Include="BackEnd\Components\Communications\INodeProvider.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeEndpointInProc.cs" />
diff --git a/src/Build/Microsoft.Build.pkgdef b/src/Build/Microsoft.Build.pkgdef
index 74546cfe4fe..5ade779232c 100644
--- a/src/Build/Microsoft.Build.pkgdef
+++ b/src/Build/Microsoft.Build.pkgdef
@@ -5,3 +5,27 @@
 "culture"="neutral"
 "oldVersion"="0.0.0.0-99.9.9.9"
 "newVersion"="15.1.0.0"
+
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{F74A7C60-AC4A-4EC4-A8DB-1FE89FDB53CD}]
+"name"="BuildXL.Processes"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\BuildXL.Processes.dll"
+"publicKeyToken"="6212d9137135ce5d"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
+
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{A038F286-A634-460D-9964-75465129EEF2}]
+"name"="BuildXL.Utilities.Core"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\BuildXL.Utilities.Core.dll"
+"publicKeyToken"="6212d9137135ce5d"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
+
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{0EE5D593-1F73-4FA2-98D7-B347DFD50186}]
+"name"="BuildXL.Native"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\BuildXL.Native.dll"
+"publicKeyToken"="6212d9137135ce5d"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 3a046f4d554..0707bc3bbb4 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1906,6 +1906,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ProjectCacheShutdownFailed" xml:space="preserve">
     <value>MSB4268: The project cache failed to shut down properly.</value>
   </data>
+  <data name="ProjectCacheHandleBuildResultFailed" xml:space="preserve">
+    <value>MSB4269: The project cache failed while handling a build result for the following project: {0}.</value>
+  </data>
   <data name="NoProjectCachePluginFoundInAssembly" xml:space="preserve">
     <value>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</value>
   </data>
@@ -1995,6 +1998,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>MSB4277: Cannot copy from object of that type.</value>
     <comment>{StrBegin="MSB4277: "}</comment>
   </data>
+  <data name="ReportFileAccessesX64Only" xml:space="preserve">
+    <value>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</value>
+  </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 0fb219fdd76..e47a6be2f0e 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: Mezipam projektu vyvolala neoetenou vjimku z metody {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Mezipam projektu selhala pi zpracovn vsledku sestaven pro nsledujc projekt: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Pstup do mezipamti projektu pro {0} (vchoz cle).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: Zakzn uzlu inproc zpsob snen vkonu pi pouvn modul plug-in mezipamti projektu, kter vyslaj dosti o sestaven proxy serveru.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Pstupy k souborm sestav se v souasn dob podporuj jenom pomoc varianty x64 nstroje MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Selhn pekladae sady SDK: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 34f2984b55a..afc7548add2 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: Der Projektcache hat ber die Methode {0} eine unbehandelte Ausnahme ausgelst.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Fehler beim Verarbeiten eines Buildergebnisses fr das folgende Projekt im Projektcache: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Projektcachetreffer fr {0} (Standardziele).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: Das Deaktivieren des In-Process-Knotens fhrt zu Leistungseinbuen bei der Verwendung von Projektcache-Plug-Ins, die Proxybuildanforderungen ausgeben.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Das Melden von Dateizugriffen wird derzeit nur mit der x64-Variante von MSBuild untersttzt.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Fehler bei SDK-Resolver: "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index ad3fa5bce70..b239a2147f8 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: la cach del proyecto inici una excepcin no controlada desde el mtodo {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: error en la cach del proyecto al controlar un resultado de compilacin para el siguiente proyecto: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Acierto de cach de proyecto para "{0}" (destinos predeterminados).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: Al deshabilitar el nodo InProc, se degrada el rendimiento cuando use los complementos de cach de proyectos que emiten solicitudes de compilacin de proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Los accesos a archivos de informes solo se admiten actualmente con el tipo x64 de MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Error del solucionador del SDK: "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 62958ed7308..1a7b7f44d73 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: le cache de projet a lev une exception non gre  partir de la mthode {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: le cache du projet a chou lors de la gestion dun rsultat de build pour le projet suivant : {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Le cache de projet a t atteint pour  {0}  (cibles par dfaut).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: la dsactivation du nud inproc entrane une dtrioration des performances lors de lutilisation de plug-ins de cache de projet qui mettent des requtes de build proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Les accs aux fichiers de cration de rapports sont uniquement pris en charge  laide de la saveur x64 de MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: chec du Programme de Rsolution SDK : {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index b78569055ff..2b84a74df2e 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: la cache del progetto ha generato un'eccezione non gestita dal metodo {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: errore della cache del progetto durante la gestione di un risultato di compilazione per il progetto seguente: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Riscontro nella cache del progetto per "{0}" (destinazioni predefinite).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: la disabilitazione del nodo InProc porta a una riduzione del livello delle prestazioni quando si usano plug-in della cache del progetto che emettono richieste di compilazione proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Gli accessi ai file di report sono attualmente supportati solo con la versione x64 di MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: errore sistema di risoluzione SDK: "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 6b1cdb3452c..b542f06c26c 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273:   {0} </target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269:  : {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}"    ()</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274:   InProc </target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated"> MSBuild  x64 </target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK  : "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 76064b46602..cc93c3d1c32 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273:   {0}     .</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: {0}         .</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}"( )    .</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274:           inproc      .</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">    x64  MSBuild   .</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK   : "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index a4ea3f9b1d4..c41c1a12d2b 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: pami podrczna projektu zgosia nieobsugiwany wyjtek z metody {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: pami podrczna projektu nie powioda si podczas obsugi wyniku kompilacji dla nastpujcego projektu: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Trafienie pamici podrcznej projektu dla {0} (domylne elementy docelowe).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: wyczenie wza InProc prowadzi do obnienia wydajnoci, gdy uywane s wtyczki pamici podrcznej projektu, ktre emituj dania kompilowania serwera proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Raportowanie dostpu do plikw jest obecnie obsugiwane tylko przy uyciu wersji x64 programu MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: niepowodzenia programu do rozpoznawania zestawu SDK: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 6ca0dd891e9..56b0d6b36f5 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: O cache do projeto lanou uma exceo sem tratamento do mtodo {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: O cache do projeto falhou ao manipular um resultado de construo para o seguinte projeto: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Acerto de cache do projeto para "{0}" (destinos padro).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: desativar o n inproc leva  degradao do desempenho ao usar plug-ins de cache de projeto que emitem solicitaes de construo de proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Atualmente, o relatrio de acessos a arquivos s tem suporte usando o tipo x64 do MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Falha no Resolvedor do SDK: "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index d54d3bca5a4..07817ef4752 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273:         {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269:          : {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">     "{0}" (   ).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274:           ,      -.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">         64-   MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242:   SDK: "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 2d211d40f45..19239812ab3 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: Proje nbellei {0} ynteminden yakalanamayan zel durum oluturdu.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Proje nbellei u proje iin bir derleme sonucu ilenirken baarsz oldu: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}" (varsaylan hedefler) iin proje nbellei isabeti.</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: InProc dmnn devre d braklmas, ara sunucu oluturma istekleri gnderen proje nbellei eklentileri kullanlrken performans dne yol aar.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Raporlama dosyas eriimleri u anda yalnzca MSBuild x64 varyant kullanldnda destekleniyor.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK zmleyici Hatas: "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 1d2c6843628..757c28ce80f 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273:  {0} </target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: : {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated"> "{0}" ()</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274:  inproc </target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated"> x64  MSBuild </target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK : "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index c073146888d..b2bdd01d43e 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273:  {0} </target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: : {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}"  ()</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274:  inproc  proxy </target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated"> MSBuild  x64 </target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK : "{0}"</target>
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index d136a2607c9..0352fbf056b 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -117,4 +117,9 @@
     <FeatureMSIORedist>true</FeatureMSIORedist>
   </PropertyGroup>
 
+  <PropertyGroup Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">
+    <DefineConstants>$(DefineConstants);FEATURE_REPORTFILEACCESSES</DefineConstants>
+    <FeatureReportFileAccesses>true</FeatureReportFileAccesses>
+  </PropertyGroup>
+
 </Project>
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index 995cfebfbc7..f5585995802 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -9,6 +9,9 @@
 using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.BuildException;
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Framework.FileAccess;
+#endif
 
 #nullable disable
 
@@ -172,6 +175,9 @@ public void Translate(ref int value)
                 value = _reader.ReadInt32();
             }
 
+            /// <inheritdoc/>
+            public void Translate(ref uint unsignedInteger) => unsignedInteger = _reader.ReadUInt32();
+
             /// <summary>
             /// Translates an <see langword="int"/> array.
             /// </summary>
@@ -421,6 +427,81 @@ public void Translate(ref BuildEventContext value)
                     _reader.ReadInt32());
             }
 
+            /// <inheritdoc/>
+            public void Translate(ref FileAccessData fileAccessData)
+            {
+                ReportedFileOperation reportedFileOperation = default;
+                RequestedAccess requestedAccess = default;
+                uint processId = default;
+                uint error = default;
+                DesiredAccess desiredAccess = default;
+                FlagsAndAttributes flagsAndAttributes = default;
+                string path = default;
+                string processArgs = default;
+                bool isAnAugmentedFileAccess = default;
+                TranslateEnum(ref reportedFileOperation, (int)reportedFileOperation);
+                TranslateEnum(ref requestedAccess, (int)requestedAccess);
+                Translate(ref processId);
+                Translate(ref error);
+                TranslateEnum(ref desiredAccess, (int)desiredAccess);
+                TranslateEnum(ref flagsAndAttributes, (int)flagsAndAttributes);
+                Translate(ref path);
+                Translate(ref processArgs);
+                Translate(ref isAnAugmentedFileAccess);
+                fileAccessData = new FileAccessData(
+                    reportedFileOperation,
+                    requestedAccess,
+                    processId,
+                    error,
+                    desiredAccess,
+                    flagsAndAttributes,
+                    path,
+                    processArgs,
+                    isAnAugmentedFileAccess);
+            }
+
+            /// <inheritdoc/>
+            public void Translate(ref List<FileAccessData> fileAccessDataList)
+            {
+                if (!TranslateNullable(fileAccessDataList))
+                {
+                    return;
+                }
+
+                int count = default;
+                Translate(ref count);
+                fileAccessDataList = new List<FileAccessData>(count);
+                for (int i = 0; i < count; i++)
+                {
+                    FileAccessData fileAccessData = default;
+                    Translate(ref fileAccessData);
+                    fileAccessDataList.Add(fileAccessData);
+                }
+            }
+
+            /// <inheritdoc/>
+            public void Translate(ref ProcessData processData)
+            {
+                string processName = default;
+                uint processId = default;
+                uint parentProcessId = default;
+                DateTime creationDateTime = default;
+                DateTime exitDateTime = default;
+                uint exitCode = default;
+                Translate(ref processName);
+                Translate(ref processId);
+                Translate(ref parentProcessId);
+                Translate(ref creationDateTime);
+                Translate(ref exitDateTime);
+                Translate(ref exitCode);
+                processData = new ProcessData(
+                    processName,
+                    processId,
+                    parentProcessId,
+                    creationDateTime,
+                    exitDateTime,
+                    exitCode);
+            }
 #endif
 
             /// <summary>
@@ -501,12 +582,6 @@ public void TranslateDotNet<T>(ref T value)
 
             public void TranslateException(ref Exception value)
             {
-                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-                {
-                    TranslateDotNet<Exception>(ref value);
-                    return;
-                }
-
                 if (!TranslateNullable(value))
                 {
                     return;
@@ -884,6 +959,9 @@ public void Translate(ref int value)
                 _writer.Write(value);
             }
 
+            /// <inheritdoc/>
+            public void Translate(ref uint unsignedInteger) => _writer.Write(unsignedInteger);
+
             /// <summary>
             /// Translates an <see langword="int"/> array.
             /// </summary>
@@ -1109,6 +1187,58 @@ public void Translate(ref BuildEventContext value)
                 _writer.Write(value.TaskId);
             }
 
+            /// <inheritdoc/>
+            public void Translate(ref FileAccessData fileAccessData)
+            {
+                ReportedFileOperation reportedFileOperation = fileAccessData.Operation;
+                RequestedAccess requestedAccess = fileAccessData.RequestedAccess;
+                uint processId = fileAccessData.ProcessId;
+                uint error = fileAccessData.Error;
+                DesiredAccess desiredAccess = fileAccessData.DesiredAccess;
+                FlagsAndAttributes flagsAndAttributes = fileAccessData.FlagsAndAttributes;
+                string path = fileAccessData.Path;
+                string processArgs = fileAccessData.ProcessArgs;
+                bool isAnAugmentedFileAccess = fileAccessData.IsAnAugmentedFileAccess;
+                TranslateEnum(ref reportedFileOperation, (int)reportedFileOperation);
+                TranslateEnum(ref requestedAccess, (int)requestedAccess);
+                Translate(ref processId);
+                Translate(ref error);
+                TranslateEnum(ref desiredAccess, (int)desiredAccess);
+                TranslateEnum(ref flagsAndAttributes, (int)flagsAndAttributes);
+                Translate(ref path);
+                Translate(ref processArgs);
+                Translate(ref isAnAugmentedFileAccess);
+            }
+
+            /// <inheritdoc/>
+            public void Translate(ref List<FileAccessData> fileAccessDataList)
+            {
+                if (!TranslateNullable(fileAccessDataList))
+                {
+                    return;
+                }
+
+                int count = fileAccessDataList.Count;
+                Translate(ref count);
+                fileAccessDataList.ForEach(fileAccessData => Translate(ref fileAccessData));
+            }
+
+            /// <inheritdoc/>
+            public void Translate(ref ProcessData processData)
+            {
+                string processName = processData.ProcessName;
+                uint processId = processData.ProcessId;
+                uint parentProcessId = processData.ParentProcessId;
+                DateTime creationDateTime = processData.CreationDateTime;
+                DateTime exitDateTime = processData.ExitDateTime;
+                uint exitCode = processData.ExitCode;
+                Translate(ref processName);
+                Translate(ref processId);
+                Translate(ref parentProcessId);
+                Translate(ref creationDateTime);
+                Translate(ref exitDateTime);
+                Translate(ref exitCode);
+            }
 #endif 
 
             /// <summary>
@@ -1155,12 +1285,6 @@ public void TranslateDotNet<T>(ref T value)
 
             public void TranslateException(ref Exception value)
             {
-                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-                {
-                    TranslateDotNet<Exception>(ref value);
-                    return;
-                }
-
                 if (!TranslateNullable(value))
                 {
                     return;
diff --git a/src/Framework/CompatibilitySuppressions.xml b/src/Framework/CompatibilitySuppressions.xml
index 1c5e56d19a3..2545a39b99a 100644
--- a/src/Framework/CompatibilitySuppressions.xml
+++ b/src/Framework/CompatibilitySuppressions.xml
@@ -54,9 +54,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-  <!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net7.0</Target>
-  </Suppression>
 </Suppressions>
diff --git a/src/Framework/EngineServices.cs b/src/Framework/EngineServices.cs
index 271bc7d33c7..853663d4e5b 100644
--- a/src/Framework/EngineServices.cs
+++ b/src/Framework/EngineServices.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.Framework.FileAccess;
 
 namespace Microsoft.Build.Framework
 {
@@ -21,10 +22,18 @@ public abstract class EngineServices
         public const int Version1 = 1;
 
         /// <summary>
-        /// An explicit version of this class. Must be incremented whenever new members are added. Derived classes should override
-        /// the property to return the version actually being implemented.
+        /// Includes <see cref="ReportFileAccess(FileAccessData)"/>.
         /// </summary>
-        public virtual int Version => Version1; // Not updated since we have not shipped 17.0 yet. This comment is meant to bypass RequiredVersionBumps check in build.ps1 for PR #470646. If the changes in the file are cosmetic, change PR# in this comment to silence the build error on CI build.
+        public const int Version2 = 2;
+
+        /// <summary>
+        /// Gets an explicit version of this class.
+        /// </summary>
+        /// <remarks>
+        /// Must be incremented whenever new members are added. Derived classes should override
+        /// the property to return the version actually being implemented.
+        /// </remarks>
+        public virtual int Version => Version2;
 
         /// <summary>
         /// Returns <see langword="true"/> if the given message importance is not guaranteed to be ignored by registered loggers.
@@ -45,5 +54,12 @@ public abstract class EngineServices
         /// This is a performance optimization allowing tasks to skip expensive double-logging.
         /// </remarks>
         public virtual bool IsTaskInputLoggingEnabled => throw new NotImplementedException();
+
+        /// <summary>
+        /// Reports a file access from a task.
+        /// </summary>
+        /// <param name="fileAccessData">The file access to report.</param>
+        [CLSCompliant(false)]
+        public virtual void ReportFileAccess(FileAccessData fileAccessData) => throw new NotImplementedException();
     }
 }
diff --git a/src/Framework/ExtendedBuildErrorEventArgs.cs b/src/Framework/ExtendedBuildErrorEventArgs.cs
index 85d10939236..e5830592b6c 100644
--- a/src/Framework/ExtendedBuildErrorEventArgs.cs
+++ b/src/Framework/ExtendedBuildErrorEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedBuildErrorEventArgs : BuildErrorEventArgs, IExtended
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/ExtendedBuildMessageEventArgs.cs b/src/Framework/ExtendedBuildMessageEventArgs.cs
index 53ec510c8da..6330a502050 100644
--- a/src/Framework/ExtendedBuildMessageEventArgs.cs
+++ b/src/Framework/ExtendedBuildMessageEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedBuildMessageEventArgs : BuildMessageEventArgs, IExte
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/ExtendedBuildWarningEventArgs.cs b/src/Framework/ExtendedBuildWarningEventArgs.cs
index 9481d2bfbdc..88eaf08af0d 100644
--- a/src/Framework/ExtendedBuildWarningEventArgs.cs
+++ b/src/Framework/ExtendedBuildWarningEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedBuildWarningEventArgs : BuildWarningEventArgs, IExte
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/ExtendedCustomBuildEventArgs.cs b/src/Framework/ExtendedCustomBuildEventArgs.cs
index 0669c025843..8a20c512923 100644
--- a/src/Framework/ExtendedCustomBuildEventArgs.cs
+++ b/src/Framework/ExtendedCustomBuildEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedCustomBuildEventArgs : CustomBuildEventArgs, IExtend
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/FileAccess/DesiredAccess.cs b/src/Framework/FileAccess/DesiredAccess.cs
new file mode 100644
index 00000000000..056c74d6f19
--- /dev/null
+++ b/src/Framework/FileAccess/DesiredAccess.cs
@@ -0,0 +1,112 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Framework.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.DesiredAccess.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// The requested access to the file or device.
+    /// </summary>
+    /// <remarks>
+    /// See https://learn.microsoft.com/en-us/windows/win32/fileio/file-access-rights-constants for a full list of values.
+    /// </remarks>
+    [Flags]
+    [CLSCompliant(false)]
+    public enum DesiredAccess : uint
+    {
+        /// <summary>
+        /// For a directory, the right to list the contents of the directory.
+        /// </summary>
+        FILE_LIST_DIRECTORY = 0x00000001,
+
+        /// <summary>
+        /// For a directory, the right to create a file in the directory.
+        /// </summary>
+        FILE_ADD_FILE = 0x00000002,
+
+        /// <summary>
+        /// For a directory, the right to create a subdirectory.
+        /// </summary>
+        FILE_ADD_SUBDIRECTORY = 0x00000004,
+
+        /// <summary>
+        /// The right to read extended file attributes.
+        /// </summary>
+        FILE_READ_EA = 0x00000008,
+
+        /// <summary>
+        /// Right to delete an object.
+        /// </summary>
+        DELETE = 0x00010000,
+
+        /// <summary>
+        /// Right to wait on a handle.
+        /// </summary>
+        SYNCHRONIZE = 0x00100000,
+
+        /// <summary>
+        /// For a file object, the right to append data to the file. (For local files, write operations will not overwrite existing
+        /// data if this flag is specified without <see cref="FILE_WRITE_DATA"/>.) For a directory object, the right to create a subdirectory
+        /// (<see cref="FILE_ADD_SUBDIRECTORY"/>).
+        /// </summary>
+        FILE_APPEND_DATA = 0x00000004,
+
+        /// <summary>
+        /// The right to write extended file attributes.
+        /// </summary>
+        FILE_WRITE_EA = 0x00000010,
+
+        /// <summary>
+        /// For a native code file, the right to execute the file. This access right given to scripts may cause the script to be executable, depending on the script interpreter.
+        /// </summary>
+        FILE_EXECUTE = 0x00000020,
+
+        /// <summary>
+        /// For a directory, the right to delete a directory and all the files it contains, including read-only files.
+        /// </summary>
+        FILE_DELETE_CHILD = 0x00000040,
+
+        /// <summary>
+        /// The right to read file attributes.
+        /// </summary>
+        FILE_READ_ATTRIBUTES = 0x00000080,
+
+        /// <summary>
+        /// The right to write file attributes.
+        /// </summary>
+        FILE_WRITE_ATTRIBUTES = 0x00000100,
+
+        /// <summary>
+        /// For a file object, the right to write data to the file. For a directory object, the right to create a file in the
+        /// directory (<see cref="FILE_ADD_FILE"/>).
+        /// </summary>
+        FILE_WRITE_DATA = 0x00000002,
+
+        /// <summary>
+        /// All possible access rights.
+        /// </summary>
+        GENERIC_ALL = 0x10000000,
+
+        /// <summary>
+        /// Execute access.
+        /// </summary>
+        GENERIC_EXECUTE = 0x20000000,
+
+        /// <summary>
+        /// Write access.
+        /// </summary>
+        GENERIC_WRITE = 0x40000000,
+
+        /// <summary>
+        /// Read access.
+        /// </summary>
+        GENERIC_READ = 0x80000000,
+    }
+}
diff --git a/src/Framework/FileAccess/FileAccessData.cs b/src/Framework/FileAccess/FileAccessData.cs
new file mode 100644
index 00000000000..2f95ce9d471
--- /dev/null
+++ b/src/Framework/FileAccess/FileAccessData.cs
@@ -0,0 +1,31 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Framework.FileAccess
+{
+    /// <summary>
+    /// File access data.
+    /// </summary>
+    /// <param name="Operation">The operation that performed the file access.</param>
+    /// <param name="RequestedAccess">The requested access.</param>
+    /// <param name="ProcessId">The process id.</param>
+    /// <param name="Error">The error code of the operation.</param>
+    /// <param name="DesiredAccess">The desired access.</param>
+    /// <param name="FlagsAndAttributes">The file flags and attributes.</param>
+    /// <param name="Path">The path being accessed.</param>
+    /// <param name="ProcessArgs">The process arguments.</param>
+    /// <param name="IsAnAugmentedFileAccess">Whether the file access is augmented.</param>
+    [CLSCompliant(false)]
+    public readonly record struct FileAccessData(
+        ReportedFileOperation Operation,
+        RequestedAccess RequestedAccess,
+        uint ProcessId,
+        uint Error,
+        DesiredAccess DesiredAccess,
+        FlagsAndAttributes FlagsAndAttributes,
+        string Path,
+        string? ProcessArgs,
+        bool IsAnAugmentedFileAccess);
+}
diff --git a/src/Framework/FileAccess/FlagsAndAttributes.cs b/src/Framework/FileAccess/FlagsAndAttributes.cs
new file mode 100644
index 00000000000..8b01f48106f
--- /dev/null
+++ b/src/Framework/FileAccess/FlagsAndAttributes.cs
@@ -0,0 +1,185 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Framework.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.FlagsAndAttributes.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// The file or device attributes and flags.
+    /// </summary>
+    [Flags]
+    [CLSCompliant(false)]
+    public enum FlagsAndAttributes : uint
+    {
+        /// <summary>
+        /// The file is read only. Applications can read the file but cannot write to or delete it.
+        /// </summary>
+        FILE_ATTRIBUTE_READONLY = 0x00000001,
+
+        /// <summary>
+        /// The file is hidden. Do not include it in an ordinary directory listing.
+        /// </summary>
+        FILE_ATTRIBUTE_HIDDEN = 0x00000002,
+
+        /// <summary>
+        /// The file is part of or used exclusively by an operating system.
+        /// </summary>
+        FILE_ATTRIBUTE_SYSTEM = 0x00000004,
+
+        /// <summary>
+        /// The path is a directory.
+        /// </summary>
+        FILE_ATTRIBUTE_DIRECTORY = 0x00000010,
+
+        /// <summary>
+        /// The file should be archived. Applications use this attribute to mark files for backup or removal.
+        /// </summary>
+        FILE_ATTRIBUTE_ARCHIVE = 0x00000020,
+
+        /// <summary>
+        /// The file does not have other attributes set. This attribute is valid only if used alone.
+        /// </summary>
+        FILE_ATTRIBUTE_NORMAL = 0x00000080,
+
+        /// <summary>
+        /// The file is being used for temporary storage.
+        /// </summary>
+        /// <remarks>
+        /// For more information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_ATTRIBUTE_TEMPORARY = 0x00000100,
+
+        /// <summary>
+        /// The data of a file is not immediately available. This attribute indicates that file data is physically moved to offline
+        /// storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should
+        /// not arbitrarily change this attribute.
+        /// </summary>
+        FILE_ATTRIBUTE_OFFLINE = 0x00001000,
+
+        /// <summary>
+        /// The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory,
+        /// this means that encryption is the default for newly created files and subdirectories. For more information, see File
+        /// Encryption.
+        /// </summary>
+        /// <remarks>
+        /// This flag has no effect if <see cref="FILE_ATTRIBUTE_SYSTEM"/> is also specified.
+        /// This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.
+        /// </remarks>
+        FILE_ATTRIBUTE_ENCRYPED = 0x00004000,
+
+        /// <summary>
+        /// The file data is requested, but it should continue to be located in remote storage. It should not be transported back
+        /// to local storage. This flag is for use by remote storage systems.
+        /// </summary>
+        FILE_FLAG_OPEN_NO_RECALL = 0x00100000,
+
+        /// <summary>
+        /// Normal reparse point processing will not occur; CreateFile will attempt to open the reparse point. When a file is
+        /// opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.
+        /// </summary>
+        /// <remarks>
+        /// This flag cannot be used with the CREATE_ALWAYS flag.
+        /// If the file is not a reparse point, then this flag is ignored.
+        /// For more information, see the Remarks section.
+        /// </remarks>
+        FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000,
+
+        /// <summary>
+        /// The file or device is being opened with session awareness. If this flag is not specified, then per-session devices
+        /// (such as a redirected USB device) cannot be opened by processes running in session 0. This flag has no effect for
+        /// callers not in session 0. This flag is supported only on server editions of Windows.
+        /// </summary>
+        /// <remarks>
+        /// Windows Server 2008 R2, Windows Server 2008, and Windows Server 2003: This flag is not supported before Windows Server
+        /// 2012.
+        /// </remarks>
+        FILE_FLAG_SESSION_AWARE = 0x00800000,
+
+        /// <summary>
+        /// Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only in case,
+        /// for file systems that support that naming. Use care when using this option, because files created with this flag may
+        /// not be accessible by applications that are written for MS-DOS or 16-bit Windows.
+        /// </summary>
+        FILE_FLAG_POSIX_SEMANTICS = 0x01000000,
+
+        /// <summary>
+        /// The file is being opened or created for a backup or restore operation. The system ensures that the calling process
+        /// overrides file security checks when the process has SE_BACKUP_NAME and SE_RESTORE_NAME privileges. For more
+        /// information, see Changing Privileges in a Token.
+        /// </summary>
+        /// <remarks>
+        /// You must set this flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of
+        /// a file handle. For more information, see the Remarks section.
+        /// </remarks>
+        FILE_FLAG_BACKUP_SEMANTICS = 0x02000000,
+
+        /// <summary>
+        /// The file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any
+        /// other open or duplicated handles.
+        /// </summary>
+        /// <remarks>
+        /// If there are existing open handles to a file, the call fails unless they were all opened with the FILE_SHARE_DELETE
+        /// share mode.
+        /// Subsequent open requests for the file fail, unless the FILE_SHARE_DELETE share mode is specified.
+        /// </remarks>
+        FILE_FLAG_DELETE_ON_CLOSE = 0x04000000,
+
+        /// <summary>
+        /// Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file caching.
+        /// </summary>
+        /// <remarks>
+        /// This flag should not be used if read-behind (that is, reverse scans) will be used.
+        /// This flag has no effect if the file system does not support cached I/O and <see cref="FILE_FLAG_NO_BUFFERING"/> .
+        /// For more information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000,
+
+        /// <summary>
+        /// Access is intended to be random. The system can use this as a hint to optimize file caching.
+        /// </summary>
+        /// <remarks>
+        /// This flag has no effect if the file system does not support cached I/O and <see cref="FILE_FLAG_NO_BUFFERING"/>.
+        /// For more information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_FLAG_RANDOM_ACCESS = 0x10000000,
+
+        /// <summary>
+        /// The file or device is being opened with no system caching for data reads and writes. This flag does not affect hard
+        /// disk caching or memory mapped files.
+        /// </summary>
+        /// <remarks>
+        /// There are strict requirements for successfully working with files opened with CreateFile using this
+        /// flag; for details, see File Buffering.
+        /// </remarks>
+        FILE_FLAG_NO_BUFFERING = 0x20000000,
+
+        /// <summary>
+        /// The file or device is being opened or created for asynchronous I/O.
+        /// </summary>
+        /// <remarks>
+        /// When subsequent I/O operations are completed on this handle, the event specified in the OVERLAPPED structure will be
+        /// set to the signaled state.
+        /// If this flag is specified, the file can be used for simultaneous read and write operations.
+        /// If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write functions
+        /// specify an OVERLAPPED structure.
+        /// For information about considerations when using a file handle created with this flag, see the Synchronous and
+        /// Asynchronous I/O Handles section of this topic.
+        /// </remarks>
+        FILE_FLAG_OVERLAPPED = 0x40000000,
+
+        /// <summary>
+        /// Write operations will not go through any intermediate cache; they will go directly to disk.
+        /// </summary>
+        /// <remarks>
+        /// For additional information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_FLAG_WRITE_THROUGH = 0x80000000,
+    }
+}
diff --git a/src/Framework/FileAccess/ProcessData.cs b/src/Framework/FileAccess/ProcessData.cs
new file mode 100644
index 00000000000..aa4c8ab873c
--- /dev/null
+++ b/src/Framework/FileAccess/ProcessData.cs
@@ -0,0 +1,25 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Framework.FileAccess
+{
+    /// <summary>
+    /// Process data.
+    /// </summary>
+    /// <param name="ProcessName">The process name.</param>
+    /// <param name="ProcessId">The process id.</param>
+    /// <param name="ParentProcessId">The parent process id.</param>
+    /// <param name="CreationDateTime">The creation date time.</param>
+    /// <param name="ExitDateTime">The exit date time.</param>
+    /// <param name="ExitCode">The exit code.</param>
+    [CLSCompliant(false)]
+    public readonly record struct ProcessData(
+        string ProcessName,
+        uint ProcessId,
+        uint ParentProcessId,
+        DateTime CreationDateTime,
+        DateTime ExitDateTime,
+        uint ExitCode);
+}
diff --git a/src/Framework/FileAccess/ReportedFileOperation.cs b/src/Framework/FileAccess/ReportedFileOperation.cs
new file mode 100644
index 00000000000..22e90c56cea
--- /dev/null
+++ b/src/Framework/FileAccess/ReportedFileOperation.cs
@@ -0,0 +1,263 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Framework.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.ReportedFileOperation.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// Which operation resulted in a reported file access.
+    /// </summary>
+    public enum ReportedFileOperation : byte
+    {
+        /// <summary>
+        /// Unknown operation.
+        /// </summary>
+        Unknown = 0,
+
+        /// <summary>
+        /// CreateFile.
+        /// </summary>
+        CreateFile,
+
+        /// <summary>
+        /// CreateProcess.
+        /// </summary>
+        CreateProcess,
+
+        /// <summary>
+        /// GetFileAttributes.
+        /// </summary>
+        GetFileAttributes,
+
+        /// <summary>
+        /// GetFileAttributesEx.
+        /// </summary>
+        GetFileAttributesEx,
+
+        /// <summary>
+        /// Process forked.
+        /// </summary>
+        Process,
+
+        /// <summary>
+        /// FindFirstFileEx.
+        /// </summary>
+        /// <remarks>
+        /// FindFirstFile also indicates this op, since we implement it in terms of FindFirstFileEx.
+        /// </remarks>
+        FindFirstFileEx,
+
+        /// <summary>
+        /// FindNextFile.
+        /// </summary>
+        FindNextFile,
+
+        /// <summary>
+        /// CreateDirectory.
+        /// </summary>
+        CreateDirectory,
+
+        /// <summary>
+        /// DeleteFile.
+        /// </summary>
+        DeleteFile,
+
+        /// <summary>
+        /// MoveFile (source; read and deleted).
+        /// </summary>
+        MoveFileSource,
+
+        /// <summary>
+        /// MoveFile (destination; written).
+        /// </summary>
+        MoveFileDestination,
+
+        /// <summary>
+        /// SetFileInformationByHandleSource (source; read and deleted).
+        /// </summary>
+        SetFileInformationByHandleSource,
+
+        /// <summary>
+        /// SetFileInformationByHandleDest (destination; written).
+        /// </summary>
+        SetFileInformationByHandleDest,
+
+        /// <summary>
+        /// ZwSetRenameInformationFileSource (source; read and deleted).
+        /// </summary>
+        ZwSetRenameInformationFileSource,
+
+        /// <summary>
+        /// ZwSetRenameInformationFileDest (destination; written).
+        /// </summary>
+        ZwSetRenameInformationFileDest,
+
+        /// <summary>
+        /// ZwSetLinkInformationFileDest.
+        /// </summary>
+        ZwSetLinkInformationFile,
+
+        /// <summary>
+        /// ZwSetDispositionInformationFile (delete-on-close; deleted).
+        /// </summary>
+        ZwSetDispositionInformationFile,
+
+        /// <summary>
+        /// ZwSetModeInformationFile (delete-on-close; deleted).
+        /// </summary>
+        ZwSetModeInformationFile,
+
+        /// <summary>
+        /// ZwSetFileNameInformationFile (source; read and written).
+        /// </summary>
+        ZwSetFileNameInformationFileSource,
+
+        /// <summary>
+        /// ZwSetFileNameInformationFile (destination; written).
+        /// </summary>
+        ZwSetFileNameInformationFileDest,
+
+        /// <summary>
+        /// CopyFile (source; read).
+        /// </summary>
+        CopyFileSource,
+
+        /// <summary>
+        /// CopyFile (destination; written).
+        /// </summary>
+        CopyFileDestination,
+
+        /// <summary>
+        /// CreateHardLink (source; read).
+        /// </summary>
+        CreateHardLinkSource,
+
+        /// <summary>
+        /// CreateHardLink (destination; written).
+        /// </summary>
+        CreateHardLinkDestination,
+
+        /// <summary>
+        /// RemoveDirectory.
+        /// </summary>
+        RemoveDirectory,
+
+        /// <summary>
+        /// RemoveDirectory (source; written).
+        /// </summary>
+        RemoveDirectorySource,
+
+        /// <summary>
+        /// NtQueryDirectoryFile.
+        /// </summary>
+        NtQueryDirectoryFile,
+
+        /// <summary>
+        /// ZwQueryDirectoryFile.
+        /// </summary>
+        ZwQueryDirectoryFile,
+
+        /// <summary>
+        /// NtCreateFile.
+        /// </summary>
+        NtCreateFile,
+
+        /// <summary>
+        /// ZwCreateFile.
+        /// </summary>
+        ZwCreateFile,
+
+        /// <summary>
+        /// ZwOpenFile.
+        /// </summary>
+        ZwOpenFile,
+
+        /// <summary>
+        /// This is a quasi operation. We issue this
+        /// report when Detours is changing file open
+        /// request with Read/Write access to Read access only.
+        /// </summary>
+        ChangedReadWriteToReadAccess,
+
+        /// <summary>
+        /// This is a quasi operation. The sandbox issues this only when FileAccessPolicy.OverrideAllowWriteForExistingFiles is set, representing
+        /// that an allow for write check was performed for a given path for the first time (in the scope of a process, another process in the same process 
+        /// tree may also report this for the same path).
+        /// </summary>
+        FirstAllowWriteCheckInProcess,
+
+        /// <summary>
+        /// This operation used to indicate to the engine by the Linux sandbox that a process being executed statically links libc
+        /// and may have missing file observations.
+        /// </summary>
+        StaticallyLinkedProcess,
+
+        /// <summary>
+        /// Access of reparse point target.
+        /// </summary>
+        ReparsePointTarget,
+
+        /// <summary>
+        /// Access of reparse point target, cached by Detours.
+        /// </summary>
+        ReparsePointTargetCached,
+
+        /// <summary>
+        /// Access checks for source of CreateSymbolicLink API.
+        /// </summary>
+        CreateSymbolicLinkSource,
+
+        /// <summary>
+        /// Access check for MoveFileWithgProgress source target.
+        /// </summary>
+        MoveFileWithProgressSource,
+
+        /// <summary>
+        /// Access check for MoveFileWithProgress dest target.
+        /// </summary>
+        MoveFileWithProgressDest,
+
+        /// <summary>
+        /// Multiple operations lumped into one.
+        /// </summary>
+        MultipleOperations,
+
+        /// <summary>
+        /// Process exited.
+        /// </summary>
+        ProcessExit,
+
+        #region Operation Names Reported by BuildXLSandbox (macOS sandbox implementation)
+        MacLookup,
+        MacReadlink,
+        MacVNodeCreate,
+        KAuthMoveSource,
+        KAuthMoveDest,
+        KAuthCreateHardlinkSource,
+        KAuthCreateHardlinkDest,
+        KAuthCopySource,
+        KAuthCopyDest,
+        KAuthDeleteDir,
+        KAuthDeleteFile,
+        KAuthOpenDir,
+        KAuthReadFile,
+        KAuthCreateDir,
+        KAuthWriteFile,
+        KAuthClose,
+        KAuthCloseModified,
+        KAuthGetAttributes,
+        KAuthVNodeExecute,
+        KAuthVNodeWrite,
+        KAuthVNodeRead,
+        KAuthVNodeProbe,
+        MacVNodeWrite,
+        MacVNodeCloneSource,
+        MacVNodeCloneDest,
+        #endregion
+    }
+}
diff --git a/src/Framework/FileAccess/RequestedAccess.cs b/src/Framework/FileAccess/RequestedAccess.cs
new file mode 100644
index 00000000000..b522571460f
--- /dev/null
+++ b/src/Framework/FileAccess/RequestedAccess.cs
@@ -0,0 +1,60 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Framework.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.RequestedAccess.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// Level of access requested by a reported file operation.
+    /// </summary>
+    [Flags]
+    public enum RequestedAccess : byte
+    {
+        /// <summary>
+        /// No access requested.
+        /// </summary>
+        None = 0,
+
+        /// <summary>
+        /// Read access requested.
+        /// </summary>
+        Read = 1,
+
+        /// <summary>
+        /// Write access requested.
+        /// </summary>
+        Write = 2,
+
+        /// <summary>
+        /// Metadata-only probe access requested (e.g. <see cref="ReportedFileOperation.GetFileAttributes"/>).
+        /// </summary>
+        Probe = 4,
+
+        /// <summary>
+        /// Directory enumeration access requested (on the directory itself; immediate children will be enumerated).
+        /// </summary>
+        Enumerate = 8,
+
+        /// <summary>
+        /// Metadata-only probe access requested; probed as part of a directory enumeration (e.g. <see cref="ReportedFileOperation.FindNextFile"/>).
+        /// </summary>
+        EnumerationProbe = 16,
+
+        /// <summary>
+        /// Both read and write access requested.
+        /// </summary>
+        ReadWrite = Read | Write,
+
+        /// <summary>
+        /// All defined access levels requested.
+        /// </summary>
+        All = Read | Write | Probe | Enumerate | EnumerationProbe,
+    }
+}
diff --git a/src/Framework/IExtendedBuildEventArgs.cs b/src/Framework/IExtendedBuildEventArgs.cs
index 0c73ddb914f..83b4c3ba555 100644
--- a/src/Framework/IExtendedBuildEventArgs.cs
+++ b/src/Framework/IExtendedBuildEventArgs.cs
@@ -22,7 +22,7 @@ public interface IExtendedBuildEventArgs
     ///   - data which needed in custom code to properly routing this message without interpreting/deserializing <see cref="ExtendedData"/>.
     ///   - simple extended data can be transferred in form of dictionary key-value per one extended property.
     /// </summary>
-    Dictionary<string, string?>? ExtendedMetadata { get; set; }
+    IDictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <summary>
     /// Transparent data as string.
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index 930cc45f6b2..77f1c76f647 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -6,6 +6,9 @@
 using System.Globalization;
 using System.IO;
 using Microsoft.Build.Framework;
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Framework.FileAccess;
+#endif
 
 #nullable disable
 
@@ -134,6 +137,12 @@ BinaryWriter Writer
         /// <param name="value">The value to be translated.</param>
         void Translate(ref int value);
 
+        /// <summary>
+        /// Translates an unsigned integer.
+        /// </summary>
+        /// <param name="unsignedInteger">The unsigned integer to translate.</param>
+        void Translate(ref uint unsignedInteger);
+
         /// <summary>
         /// Translates an <see langword="int"/> array.
         /// </summary>
@@ -234,6 +243,23 @@ BinaryWriter Writer
         /// <param name="value">The context to be translated.</param>
         void Translate(ref BuildEventContext value);
 
+        /// <summary>
+        /// Translates <paramref name="fileAccessData"/>.
+        /// </summary>
+        /// <param name="fileAccessData">The <see cref="FileAccessData"/> to translate.</param>
+        void Translate(ref FileAccessData fileAccessData);
+
+        /// <summary>
+        /// Translates <paramref name="fileAccessDataList"/>.
+        /// </summary>
+        /// <param name="fileAccessDataList">The file accesses to translate.</param>
+        void Translate(ref List<FileAccessData> fileAccessDataList);
+
+        /// <summary>
+        /// Translates <paramref name="processData"/>.
+        /// </summary>
+        /// <param name="processData">The <see cref="ProcessData"/> to translate.</param>
+        void Translate(ref ProcessData processData);
 #endif 
 
         /// <summary>
diff --git a/src/MSBuild/TerminalLogger/AnsiCodes.cs b/src/Framework/Logging/AnsiCodes.cs
similarity index 100%
rename from src/MSBuild/TerminalLogger/AnsiCodes.cs
rename to src/Framework/Logging/AnsiCodes.cs
diff --git a/src/MSBuild/TerminalLogger/TerminalColor.cs b/src/Framework/Logging/TerminalColor.cs
similarity index 85%
rename from src/MSBuild/TerminalLogger/TerminalColor.cs
rename to src/Framework/Logging/TerminalColor.cs
index 683b4d683b8..55b63e915ac 100644
--- a/src/MSBuild/TerminalLogger/TerminalColor.cs
+++ b/src/Framework/Logging/TerminalColor.cs
@@ -4,7 +4,7 @@
 namespace Microsoft.Build.Logging.TerminalLogger;
 
 /// <summary>
-/// Enumerates the text colors supported by <see cref="ITerminal"/>.
+/// Enumerates the text colors supported by VT100 terminal.
 /// </summary>
 internal enum TerminalColor
 {
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 29e9e67abfb..a5dbe84a3ee 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -661,6 +661,18 @@ public void MSBuildServerBuildStop(string commandLine, int countOfConsoleMessage
         {
             WriteEvent(90, commandLine, countOfConsoleMessages, sumSizeOfConsoleMessages, clientExitType, serverExitType);
         }
+
+        [Event(91, Keywords = Keywords.All)]
+        public void ProjectCacheHandleBuildResultStart(string pluginTypeName, string projectPath, string targets)
+        {
+            WriteEvent(91, pluginTypeName, projectPath, targets);
+        }
+
+        [Event(92, Keywords = Keywords.All)]
+        public void ProjectCacheHandleBuildResultStop(string pluginTypeName, string projectPath, string targets)
+        {
+            WriteEvent(92, pluginTypeName, projectPath, targets);
+        }
         #endregion
     }
 }
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 724e1a38496..c0da0474e6c 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -15,10 +15,6 @@
     <PackageReference Include="Microsoft.CodeAnalysis.Collections" PrivateAssets="all" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <PackageReference Include="System.Security.Permissions" />
-  </ItemGroup>
-
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <!-- Promote CompilerServices.Unsafe from the old version we get from System.Memory on net472. -->
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index c71d9f49ff6..d30a8ec85f5 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -35,6 +35,7 @@ internal static class NativeMethods
     internal const uint RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = 0x40;
     internal const uint FILE_TYPE_CHAR = 0x0002;
     internal const Int32 STD_OUTPUT_HANDLE = -11;
+    internal const Int32 STD_ERROR_HANDLE = -12;
     internal const uint ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004;
     internal const uint RPC_S_CALLPENDING = 0x80010115;
     internal const uint E_ABORT = (uint)0x80004004;
@@ -76,6 +77,12 @@ internal static class NativeMethods
 
     #region Enums
 
+    internal enum StreamHandleType
+    {
+        StdOut = STD_OUTPUT_HANDLE,
+        StdErr = STD_ERROR_HANDLE,
+    };
+
     private enum PROCESSINFOCLASS : int
     {
         ProcessBasicInformation = 0,
@@ -1300,7 +1307,7 @@ internal static int GetParentProcessId(int processId)
                 // using (var r = FileUtilities.OpenRead("/proc/" + processId + "/stat"))
                 // and could be again when FileUtilities moves to Framework
 
-                using var fileStream = new FileStream("/proc/" + processId + "/stat", FileMode.Open, FileAccess.Read);
+                using var fileStream = new FileStream("/proc/" + processId + "/stat", FileMode.Open, System.IO.FileAccess.Read);
                 using StreamReader r = new(fileStream);
 
                 line = r.ReadLine();
@@ -1481,11 +1488,11 @@ internal static void VerifyThrowWin32Result(int result)
     }
 
 #if !CLR2COMPATIBILITY
-    internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalConsoleMode) QueryIsScreenAndTryEnableAnsiColorCodes()
+    internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalConsoleMode) QueryIsScreenAndTryEnableAnsiColorCodes(StreamHandleType handleType = StreamHandleType.StdOut)
     {
         if (Console.IsOutputRedirected)
         {
-            // There's no ANSI terminal support is console output is redirected.
+            // There's no ANSI terminal support if console output is redirected.
             return (acceptAnsiColorCodes: false, outputIsScreen: false, originalConsoleMode: null);
         }
 
@@ -1496,8 +1503,8 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
         {
             try
             {
-                IntPtr stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
-                if (GetConsoleMode(stdOut, out uint consoleMode))
+                IntPtr outputStream = GetStdHandle((int)handleType);
+                if (GetConsoleMode(outputStream, out uint consoleMode))
                 {
                     if ((consoleMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == ENABLE_VIRTUAL_TERMINAL_PROCESSING)
                     {
@@ -1508,7 +1515,7 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
                     {
                         originalConsoleMode = consoleMode;
                         consoleMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
-                        if (SetConsoleMode(stdOut, consoleMode) && GetConsoleMode(stdOut, out consoleMode))
+                        if (SetConsoleMode(outputStream, consoleMode) && GetConsoleMode(outputStream, out consoleMode))
                         {
                             // We only know if vt100 is supported if the previous call actually set the new flag, older
                             // systems ignore the setting.
@@ -1516,7 +1523,7 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
                         }
                     }
 
-                    uint fileType = GetFileType(stdOut);
+                    uint fileType = GetFileType(outputStream);
                     // The std out is a char type (LPT or Console).
                     outputIsScreen = fileType == FILE_TYPE_CHAR;
                     acceptAnsiColorCodes &= outputIsScreen;
@@ -1537,11 +1544,11 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
         return (acceptAnsiColorCodes, outputIsScreen, originalConsoleMode);
     }
 
-    internal static void RestoreConsoleMode(uint? originalConsoleMode)
+    internal static void RestoreConsoleMode(uint? originalConsoleMode, StreamHandleType handleType = StreamHandleType.StdOut)
     {
         if (IsWindows && originalConsoleMode is not null)
         {
-            IntPtr stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
+            IntPtr stdOut = GetStdHandle((int)handleType);
             _ = SetConsoleMode(stdOut, originalConsoleMode.Value);
         }
     }
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 864119f99f2..3c81043f963 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -194,6 +194,11 @@ internal class EscapeHatches
         /// </summary>
         public readonly bool AlwaysDoImmutableFilesUpToDateCheck = Environment.GetEnvironmentVariable("MSBUILDDONOTCACHEMODIFICATIONTIME") == "1";
 
+        /// <summary>
+        /// When copying over an existing file, copy directly into the existing file rather than deleting and recreating.
+        /// </summary>
+        public readonly bool CopyWithoutDelete = Environment.GetEnvironmentVariable("MSBUILDCOPYWITHOUTDELETE") == "1";
+
         /// <summary>
         /// Emit events for project imports.
         /// </summary>
@@ -401,6 +406,27 @@ public bool EnableWarningOnCustomBuildEvent
             }
         }
 
+        private bool? _isBinaryFormatterSerializationAllowed;
+        public bool IsBinaryFormatterSerializationAllowed
+        {
+            get
+            {
+                if (!_isBinaryFormatterSerializationAllowed.HasValue)
+                {
+#if RUNTIME_TYPE_NETCORE
+                    AppContext.TryGetSwitch("System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization",
+                        out bool enabled);
+                    _isBinaryFormatterSerializationAllowed = enabled;
+#else
+                    _isBinaryFormatterSerializationAllowed = true;
+#endif
+                }
+
+                return _isBinaryFormatterSerializationAllowed.Value;
+            }
+        }
+
+
         private static bool? ParseNullableBoolFromEnvironmentVariable(string environmentVariable)
         {
             var value = Environment.GetEnvironmentVariable(environmentVariable);
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index d151bc71199..a3f744978d0 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -1131,6 +1131,9 @@ public void InvalidToolsVersionErrors()
                                         outputResultsCache: null,
                                         saveProjectResult: false,
                                         ref buildResult,
+#if FEATURE_REPORTFILEACCESSES
+                                        reportFileAccesses: false,
+#endif
                                         commandLine: null);
                 }
                 finally
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index d5d2b08a104..847da8ba276 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -106,6 +106,9 @@ internal enum ParameterizedSwitch
             GraphBuild,
             InputResultsCaches,
             OutputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+            ReportFileAccesses,
+#endif
             LowPriority,
             Question,
             DetailedSummary,
@@ -268,6 +271,9 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           true,           null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "inputResultsCaches", "irc" },         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true),
             new ParameterizedSwitchInfo(  new string[] { "outputResultsCache", "orc" },         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true),
+#if FEATURE_REPORTFILEACCESSES
+            new ParameterizedSwitchInfo(  new string[] { "reportfileaccesses" },                ParameterizedSwitch.ReportFileAccesses,         null,                           false,          null,                                  true,   false),
+#endif
             new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false),
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 3ca22b8e510..f552d2c765f 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -18,6 +18,7 @@
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
          versions of this project -->
     <RuntimeIdentifiers Condition="'$(DotNetBuildFromSource)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
+    <UseRidGraph>true</UseRidGraph>
 
     <EnableDefaultItems>false</EnableDefaultItems>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
@@ -218,6 +219,7 @@
     </None>
   </ItemGroup>
   <ItemGroup>
+    <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 1a0c3871a2d..64ab30c8d6d 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -5,14 +5,16 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.IO;
 using System.Globalization;
-using System.Threading;
+using System.IO;
 using System.Reflection;
-
+using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Framework.FileAccess;
+#endif
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 #if FEATURE_APPDOMAIN
@@ -165,6 +167,13 @@ internal class OutOfProcTaskHostNode :
         private RegisteredTaskObjectCacheBase _registeredTaskObjectCache;
 #endif
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// The file accesses reported by the most recently completed task.
+        /// </summary>
+        private List<FileAccessData> _fileAccessData = new List<FileAccessData>();
+#endif
+
         /// <summary>
         /// Constructor.
         /// </summary>
@@ -531,11 +540,19 @@ public override bool IsTaskInputLoggingEnabled
                     return _taskHost._currentConfiguration.IsTaskInputLoggingEnabled;
                 }
             }
+
+            /// <inheritdoc/>
+            public override void ReportFileAccess(FileAccessData fileAccessData)
+            {
+#if FEATURE_REPORTFILEACCESSES
+                _taskHost._fileAccessData.Add(fileAccessData);
+#endif
+            }
         }
 
         public EngineServices EngineServices { get; }
 
-        #endregion
+#endregion
 
 #endif
 
@@ -936,8 +953,11 @@ private void RunTask(object state)
                     lock (_taskCompleteLock)
                     {
                         _taskCompletePacket = new TaskHostTaskComplete(
-                                                        taskResult,
-                                                        currentEnvironment);
+                            taskResult,
+#if FEATURE_REPORTFILEACCESSES
+                            _fileAccessData,
+#endif
+                            currentEnvironment);
                     }
 
 #if FEATURE_APPDOMAIN
@@ -956,11 +976,20 @@ private void RunTask(object state)
                     lock (_taskCompleteLock)
                     {
                         // Create a minimal taskCompletePacket to carry the exception so that the TaskHostTask does not hang while waiting
-                        _taskCompletePacket = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedAfterExecution, e), null);
+                        _taskCompletePacket = new TaskHostTaskComplete(
+                            new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedAfterExecution, e),
+#if FEATURE_REPORTFILEACCESSES
+                            _fileAccessData,
+#endif
+                            null);
                     }
                 }
                 finally
                 {
+#if FEATURE_REPORTFILEACCESSES
+                    _fileAccessData = new List<FileAccessData>();
+#endif
+
                     // Call CleanupTask to unload any domains and other necessary cleanup in the taskWrapper
                     _taskWrapper.CleanupTask();
 
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 328cb2dcdd4..a753a09c5b6 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -865,6 +865,18 @@
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </comment>
   </data>
+  <data name="HelpMessage_42_ReportFileAccessesSwitch" Visibility="Public">
+    <value>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </value>
+    <comment>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
   <data name="InvalidConfigurationFile" Visibility="Public">
     <value>MSBUILD : Configuration error MSB1043: The application could not start. {0}</value>
     <comment>
@@ -1336,6 +1348,15 @@
     <value>MSBUILD : error MSB1049: The {0} parameter must be specified</value>
     <comment>{StrBegin="MSBUILD : error MSB1049: "}</comment>
   </data>
+  <data name="InvalidReportFileAccessesValue" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <!-- #################################################################################################-->
   <!-- ######################################## Shared strings #########################################-->
   <!-- ###### These belong in Strings.shared.resx, but have been copied here for performance ###########-->
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index f2b85eea526..9a4dee64212 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Sestaven se nezdailo. Nelze zskat vsledky vlastnost, poloek a cle. Viz podrobnosti ve stderr ve.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -97,6 +97,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Zpsob, e MSBuild bude hlsit pstupy k souborm ve vech konfigurovanch
+                     modulech plug-in pro mezipam projektu.
+
+                     Tento pznak je experimentln a nemus fungovat podle oekvn.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -117,6 +135,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Hodnota pstup k souborm sestavy nen platn. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1301,7 +1329,7 @@ Kdy se nastav na MessageUponIsolationViolation (nebo jeho krtk
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: Je nutn zadat nzev poloky pro pepna getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1310,7 +1338,7 @@ Kdy se nastav na MessageUponIsolationViolation (nebo jeho krtk
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: Je nutn zadat nzev vlastnosti pro pepna getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1319,7 +1347,7 @@ Kdy se nastav na MessageUponIsolationViolation (nebo jeho krtk
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: Je nutn zadat clov nzev pro pepna getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1606,7 +1634,7 @@ Kdy se nastav na MessageUponIsolationViolation (nebo jeho krtk
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: Pi vytven soubor een nebo soubor filtr een nelze zskat pstup k vlastnostem nebo polokm. Tato funkce je k dispozici jen pi sestavovn jednotlivch projekt.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index f29f73bd6ed..0a93c2b4b6d 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Fehler beim Buildvorgang. Eigenschaften, Elemente und Zielergebnisse knnen nicht abgerufen werden. Details finden Sie oben in stderr.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -96,6 +96,25 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|Falsch]
+                     Fhrt dazu, dass MSBuild Dateizugriffe an alle konfigurierten
+ meldet
+                     Projektcache-Plug-Ins.
+
+                     Dieses Kennzeichen ist experimentell und funktioniert mglicherweise nicht wie vorgesehen.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +135,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Der Wert fr den Zugriff auf die Berichtsdatei ist ungltig. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1288,7 +1317,7 @@ Dieses Protokollierungsformat ist standardmig aktiviert.
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: Es muss ein Elementname fr den getItem-Switch angegeben werden.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1297,7 +1326,7 @@ Dieses Protokollierungsformat ist standardmig aktiviert.
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: Fr den getProperty-Switch muss ein Eigenschaftenname angegeben werden.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1306,7 +1335,7 @@ Dieses Protokollierungsformat ist standardmig aktiviert.
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: Fr den GetTargetResult-Switch muss ein Zielname angegeben werden.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1593,7 +1622,7 @@ Dieses Protokollierungsformat ist standardmig aktiviert.
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: Beim Erstellen von Projektmappendateien oder Projektmappenfilterdateien kann nicht auf Eigenschaften oder Elemente zugegriffen werden. Dieses Feature ist nur beim Erstellen einzelner Projekte verfgbar.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 65032455f70..cfa87dc7547 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Error de compilacin. No se pueden obtener los resultados de propiedades, elementos y destinos. Vea los detalles en stderr anterior.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -96,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|Falso]
+                     Hace que MSBuild informe de los accesos a los archivos a cualquier
+                     complemento de cach de proyectos.
+
+Esta marca es experimental y puede que no funcione segn lo previsto.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: el valor de acceso al archivo de informe no es vlido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1295,7 +1323,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: debe proporcionar un nombre de elemento para el modificador getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1304,7 +1332,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: debe proporcionar un nombre de propiedad para el modificador getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1313,7 +1341,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: debe proporcionar un nombre de destino para el modificador getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1600,7 +1628,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: no se puede tener acceso a propiedades o elementos al compilar archivos de solucin o archivos de filtro de soluciones. Esta caracterstica solo est disponible al compilar proyectos individuales.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 80312d77ab5..b4b2ae8bfde 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">chec de la gnration. Impossible dobtenir les proprits, les lments et les rsultats cibles. Consultez les dtails dans stderr ci-dessus.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -96,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Entrane le signalement par MSBuild des accs par fichiers aux plug-ins
+                     cache de projet configurs.
+
+                     Cet indicateur est exprimental et peut ne pas fonctionner comme prvu.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: la valeur daccs au fichier de rapport nest pas valide. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 9a391602b01..b7e8235cf4c 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Compilazione non riuscita. Non  possibile ottenere propriet, elementi e risultati di destinazione. Vedere i dettagli in stderr sopra.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -96,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Fa in modo che MSBuild segnali gli accessi ai file a qualsiasi file configurato
+                     plug-in della cache del progetto.
+
+Questo flag  sperimentale e potrebbe non funzionare come previsto.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: il valore degli accessi al file di report non  valido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1299,7 +1327,7 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014:  necessario specificare un nome elemento per l'opzione getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1308,7 +1336,7 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010:  necessario specificare un nome propriet per l'opzione getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1317,7 +1345,7 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017:  necessario specificare un nome destinazione per l'opzione getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1604,7 +1632,7 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: non  possibile accedere a propriet o elementi durante la compilazione di file di soluzione o file di filtro della soluzione. Questa funzionalit  disponibile solo durante la compilazione di singoli progetti.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 35aa68724fe..b10dcf784c2 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated"> stderr </target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -96,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     MSBuild   
+                      
+
+                     
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063:   {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1288,7 +1316,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: getItem </target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1297,7 +1325,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: getProperty </target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1306,7 +1334,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: getTargetResult </target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1593,7 +1621,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063:    </target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 47d973d6a67..d6d76449a65 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated"> . ,       .  stderr   .</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -96,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     MSBuild       
+                        .
+
+                            .
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063:     . {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1288,7 +1316,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: getItem     .</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1297,7 +1325,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: getProperty     .</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1306,7 +1334,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: getTargetResult     .</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1593,7 +1621,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063:              .         .</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 9d9bfb601d7..2a48d1d5450 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Kompilacja nie powioda si. Nie mona uzyska wynikw waciwoci, elementw i celu. Zobacz szczegy w sekcji stderr powyej.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -96,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Powoduje, e program MSBuild zgasza dostpy do wszystkich skonfigurowanych plikw
+                     wtyczek pamici podrcznej projektu.
+
+Ta flaga jest eksperymentalna i moe nie dziaa zgodnie z oczekiwaniami.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: warto dostpw do pliku raportu jest nieprawidowa. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1299,7 +1327,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: Musi poda nazw elementu dla przecznika getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1308,7 +1336,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: Musi poda nazw waciwoci dla przecznika getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1317,7 +1345,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: Musi poda nazw celu dla przecznika getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1604,7 +1632,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: Nie mona uzyska dostpu do waciwoci lub elementw podczas tworzenia plikw rozwiza lub plikw filtrw rozwiza. Ta funkcja jest dostpna tylko podczas tworzenia pojedynczych projektw.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 4c60b3fbda2..15c9b624a84 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Falha na compilao. No foi possvel obter os resultados de Propriedades, Itens e Destino. Veja os detalhes no stderr acima.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -96,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Faz com que o MSBuild relate acessos a arquivos para qualquer plug-in
+                     de cache de projeto configurado.
+
+                     Este sinalizador  experimental e pode no funcionar conforme o esperado.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: o valor de acesso ao arquivo de relatrio no  vlido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1289,7 +1317,7 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014:  preciso fornecer um nome de item para a chave getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1298,7 +1326,7 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010:  preciso fornecer um nome de propriedade para a chave getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1307,7 +1335,7 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017:  preciso fornecer um nome de destino para a chave getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1594,7 +1622,7 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: No foi possvel acessar propriedades ou itens ao compilar arquivos de soluo ou arquivos de filtro de soluo. Esse recurso s est disponvel para a compilao de projetos individuais.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index e94db7008c0..6dca92a8e84 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">  .    ,    . .   stderr .</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -96,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                       MSBuild       
+                        .
+
+                            .
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063:         . {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1287,7 +1315,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014:       getItem.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1296,7 +1324,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010:       getProperty.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1305,7 +1333,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017:       getTargetResult.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1592,7 +1620,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063:                .        .</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index f2ee8ee03a4..ff6f95f2eae 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated">Derleme baarsz oldu. zellikler, eler ve Hedef sonular alnamyor. Yukarda stderr'de ayrntlara bakn.</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -96,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     MSBuildin yaplandrlm proje nbellei eklentilerine dosya
+                     eriimlerini bildirmesine neden olur.
+
+                     Bu bayrak deneme amaldr ve istendii gibi almayabilir.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Dosya eriimleri deerinin geerli olmadn bildirir. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1292,7 +1320,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014: getItem anahtar iin bir e ad salanmas gerekiyor.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1301,7 +1329,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010: getProperty anahtar iin bir zellik ad belirtilmelidir.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1310,7 +1338,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017: getTargetResult anahtar iin bir hedef ad salanmas gerekiyor.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1597,7 +1625,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: zm dosyalar veya zm filtresi dosyalar oluturulurken zelliklere veya elere eriilemiyor. Bu zellik yalnzca tek tek projeler oluturulurken kullanlabilir.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index d1f839fc7b7..db252831300 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated"> stderr </target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -96,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                      MSBuild 
+                     
+
+                     
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1288,7 +1316,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014:  getItem </target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1297,7 +1325,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010:  getProperty </target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1306,7 +1334,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017:  getTargetResult </target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1593,7 +1621,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: </target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 4e6f1da310b..f5907cf51e5 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -12,7 +12,7 @@
       </trans-unit>
       <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
         <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
-        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <target state="translated"> stderr </target>
         <note />
       </trans-unit>
       <trans-unit id="BuildFinished">
@@ -96,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                      MSBuild 
+                     
+
+                     
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -116,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1288,7 +1316,7 @@
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <target state="translated">MSBUILD : error MSB1014:  getItem </target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1297,7 +1325,7 @@
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <target state="translated">MSBUILD : error MSB1010:  getProperty </target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1306,7 +1334,7 @@
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <target state="translated">MSBUILD : error MSB1017:  getTargetResult </target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1593,7 +1621,7 @@
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <target state="translated">MSBUILD : error MSB1063: </target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index ffb06c9e550..0d5d5cd2b09 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -9,7 +9,6 @@
 using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Runtime.InteropServices;
 #if NETFRAMEWORK
 using Microsoft.IO;
 #else
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index d57971461d4..dacfef278e2 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -713,6 +713,9 @@ public static ExitType Execute(
                 string[] getItem = Array.Empty<string>();
                 string[] getTargetResult = Array.Empty<string>();
                 BuildResult result = null;
+#if FEATURE_REPORTFILEACCESSES
+                bool reportFileAccesses = false;
+#endif
 
                 GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile, out _);
                 bool buildCanBeInvoked = ProcessCommandLineSwitches(
@@ -747,6 +750,9 @@ public static ExitType Execute(
                                             ref graphBuildOptions,
                                             ref inputResultsCaches,
                                             ref outputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+                                            ref reportFileAccesses,
+#endif
                                             ref lowPriority,
                                             ref question,
                                             ref getProperty,
@@ -846,6 +852,9 @@ public static ExitType Execute(
                                     outputResultsCache,
                                     saveProjectResult: outputPropertiesItemsOrTargetResults,
                                     ref result,
+#if FEATURE_REPORTFILEACCESSES
+                                    reportFileAccesses,
+#endif
                                     commandLine))
                         {
                             exitType = ExitType.BuildError;
@@ -1232,6 +1241,9 @@ internal static bool BuildProject(
             string outputResultsCache,
             bool saveProjectResult,
             ref BuildResult result,
+#if FEATURE_REPORTFILEACCESSES
+            bool reportFileAccesses,
+#endif
 #if FEATURE_GET_COMMANDLINE
             string commandLine)
 #else
@@ -1423,6 +1435,9 @@ internal static bool BuildProject(
                     parameters.InputResultsCacheFiles = inputResultsCaches;
                     parameters.OutputResultsCacheFile = outputResultsCache;
                     parameters.Question = question;
+#if FEATURE_REPORTFILEACCESSES
+                    parameters.ReportFileAccesses = reportFileAccesses;
+#endif
 
                     // Propagate the profiler flag into the project load settings so the evaluator
                     // can pick it up
@@ -2383,6 +2398,9 @@ private static bool ProcessCommandLineSwitches(
             ref GraphBuildOptions graphBuild,
             ref string[] inputResultsCaches,
             ref string outputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+            ref bool reportFileAccesses,
+#endif
             ref bool lowPriority,
             ref bool question,
             ref string[] getProperty,
@@ -2446,6 +2464,13 @@ private static bool ProcessCommandLineSwitches(
             // leave priority where it was.
             catch (Win32Exception) { }
 
+#if FEATURE_REPORTFILEACCESSES
+            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.ReportFileAccesses))
+            {
+                reportFileAccesses = ProcessBooleanSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ReportFileAccesses], defaultValue: true, resourceName: "");
+            }
+#endif
+
             // if help switch is set (regardless of switch errors), show the help message and ignore the other switches
             if (commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.Help])
             {
@@ -2508,6 +2533,9 @@ private static bool ProcessCommandLineSwitches(
                                                            ref graphBuild,
                                                            ref inputResultsCaches,
                                                            ref outputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+                                                           ref reportFileAccesses,
+#endif
                                                            ref lowPriority,
                                                            ref question,
                                                            ref getProperty,
@@ -4426,6 +4454,9 @@ private static void ShowHelpMessage()
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_InputCachesFiles"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_OutputCacheFile"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_36_GraphBuildSwitch"));
+#if FEATURE_REPORTFILEACCESSES
+            Console.WriteLine(AssemblyResources.GetString("HelpMessage_42_ReportFileAccessesSwitch"));
+#endif
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_39_LowPrioritySwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_41_QuestionSwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_7_ResponseFile"));
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 91009eec184..1feab29307d 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -54,6 +54,18 @@
         </dependentAssembly>
 
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
+        <dependentAssembly>
+          <assemblyIdentity name="BuildXL.Native" publicKeyToken="6212d9137135ce5d" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\BuildXL.Native.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="BuildXL.Processes" publicKeyToken="6212d9137135ce5d" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\BuildXL.Processes.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="BuildXL.Utilities.Core" publicKeyToken="6212d9137135ce5d" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\BuildXL.Utilities.Core.dll"/>
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
@@ -69,6 +81,10 @@
           <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
           <codeBase version="1.0.0.0" href="..\Microsoft.NET.StringTools.net35.dll"/>
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="RuntimeContracts" publicKeyToken="3d487639874b2199" culture="neutral" />
+          <codeBase version="0.5.0.0" href="..\RuntimeContracts.dll" />
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
@@ -121,6 +137,11 @@
           <bindingRedirect oldVersion="0.0.0.0-7.0.0.3" newVersion="7.0.0.3" />
           <codeBase version="7.0.0.3" href="..\System.Text.Json.dll"/>
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Threading.Channels" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <codeBase version="7.0.0.0" href="..\System.Threading.Channels.dll"/>
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 463795025c0..aa4ce2eac58 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -14,6 +14,7 @@
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
          versions of this project -->
     <RuntimeIdentifiers Condition="'$(DotNetBuildFromSource)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
+    <UseRidGraph>true</UseRidGraph>
 
     <EnableDefaultItems>false</EnableDefaultItems>
     <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY;TASKHOST;NO_FRAMEWORK_IVT</DefineConstants>
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 3780b51c588..06d5e138401 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -36,13 +36,18 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe vs.file.ngenArchitecture=x86 vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe.config
-  file source=$(TaskHostBinPath)MSBuildTaskHost.exe 
+  file source=$(TaskHostBinPath)MSBuildTaskHost.exe
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config
+  file source=$(X86BinPath)BuildXL.Native.dll
+  file source=$(X86BinPath)BuildXL.Processes.dll
+  file source=$(X86BinPath)BuildXL.Utilities.Core.dll
+  file source=$(X86BinPath)RuntimeContracts.dll
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Threading.Channels.dll
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -313,6 +318,13 @@ folder InstallDir:\MSBuild\Current\Bin\amd64\zh-Hant
   file source=$(X64BinPath)zh-Hant\MSBuild.resources.dll
   file source=$(TaskHostX64BinPath)zh-Hant\MSBuildTaskHost.resources.dll
 
+folder InstallDir:\MSBuild\Current\Bin\x86
+  file source=$(X86BinPath)x86\DetoursServices.dll
+
+folder InstallDir:\MSBuild\Current\Bin\x64
+  file source=$(X86BinPath)x64\DetoursServices.dll
+  file source=$(X86BinPath)x64\BuildXLNatives.dll
+
 folder InstallDir:\Common7\IDE\CommonExtensions\MSBuild
   file source=$(SourceDir)Package\MSBuild.VSSetup\MSBuild.clientenabledpkg
   file source=$(SourceDir)Framework\Microsoft.Build.Framework.pkgdef
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index 994c24341bd..822af5c1a96 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.IO;
 using System.Runtime.CompilerServices;
 using Microsoft.Build.Framework;
@@ -108,7 +109,7 @@ public static void ReadExtendedBuildEventData(this BinaryReader reader, IExtende
             bool haveMetadata = reader.ReadBoolean();
             if (haveMetadata)
             {
-                data.ExtendedMetadata = new();
+                data.ExtendedMetadata = new Dictionary<string, string?>();
 
                 int count = reader.Read7BitEncodedInt();
                 for (int i = 0; i < count; i++)
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index a7ef74e8737..eca284ecb64 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -167,7 +167,9 @@ internal static bool IsIoRelatedException(Exception e)
         internal static bool IsXmlException(Exception e)
         {
             return e is XmlException
-                || e is XmlSyntaxException
+#if FEATURE_SECURITY_PERMISSIONS
+                || e is System.Security.XmlSyntaxException
+#endif
                 || e is XmlSchemaException
                 || e is UriFormatException; // XmlTextReader for example uses this under the covers
         }
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index cb89889c3ac..52d335944af 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -190,6 +190,16 @@ internal enum NodePacketType : byte
         /// </summary>
         ResourceResponse,
 
+        /// <summary>
+        /// Message sent from a node reporting a file access.
+        /// </summary>
+        FileAccessReport,
+
+        /// <summary>
+        /// Message sent from a node reporting process data.
+        /// </summary>
+        ProcessReport,
+
         /// <summary>
         /// Command in form of MSBuild command line for server node - MSBuild Server.
         /// Keep this enum value constant intact as this is part of contract with dotnet CLI
diff --git a/src/Shared/Pair.cs b/src/Shared/Pair.cs
deleted file mode 100644
index ef5073b4835..00000000000
--- a/src/Shared/Pair.cs
+++ /dev/null
@@ -1,60 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Diagnostics.CodeAnalysis;
-
-#nullable disable
-
-namespace Microsoft.Build.Shared
-{
-    /// <summary>
-    /// This struct is functionally identical to KeyValuePair, but avoids
-    /// CA908 warnings (types that in ngen images that will JIT).
-    /// Instead of generic collections of KeyValuePair, use Pair.
-    /// </summary>
-    /// <comment>
-    /// This trick is based on advice from 
-    /// http://sharepoint/sites/codeanalysis/Wiki%20Pages/Rule%20-%20Avoid%20Types%20That%20Require%20JIT%20Compilation%20In%20Precompiled%20Assemblies.aspx.
-    /// It works because although this is a value type, it is not defined in mscorlib.
-    /// </comment>
-    /// <typeparam name="TKey">Key</typeparam>
-    /// <typeparam name="TValue">Value</typeparam>
-    [SuppressMessage("Microsoft.Performance", "CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes", Justification = "Not possible as Equals cannot be implemented on the struct members")]
-    internal struct Pair<TKey, TValue>
-    {
-        /// <summary>
-        /// Key
-        /// </summary>
-        private TKey _key;
-
-        /// <summary>
-        /// Value
-        /// </summary>
-        private TValue _value;
-
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        public Pair(TKey key, TValue value)
-        {
-            _key = key;
-            _value = value;
-        }
-
-        /// <summary>
-        /// Key
-        /// </summary>
-        internal readonly TKey Key
-        {
-            get { return _key; }
-        }
-
-        /// <summary>
-        /// Value
-        /// </summary>
-        internal readonly TValue Value
-        {
-            get { return _value; }
-        }
-    }
-}
diff --git a/src/Shared/TaskHostTaskComplete.cs b/src/Shared/TaskHostTaskComplete.cs
index faad07dd31e..f493f43175f 100644
--- a/src/Shared/TaskHostTaskComplete.cs
+++ b/src/Shared/TaskHostTaskComplete.cs
@@ -1,9 +1,12 @@
-// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Framework.FileAccess;
+#endif
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -49,6 +52,10 @@ internal enum TaskCompleteType
     /// </summary>
     internal class TaskHostTaskComplete : INodePacket
     {
+#if FEATURE_REPORTFILEACCESSES
+        private List<FileAccessData> _fileAccessData;
+#endif
+
         /// <summary>
         /// Result of the task's execution. 
         /// </summary>
@@ -82,12 +89,21 @@ internal class TaskHostTaskComplete : INodePacket
         /// </summary>
         private Dictionary<string, string> _buildProcessEnvironment = null;
 
+
+#pragma warning disable CS1572 // XML comment has a param tag, but there is no parameter by that name. Justification: xmldoc doesn't seem to interact well with #ifdef of params.
         /// <summary>
-        /// Constructor
+        /// Initializes a new instance of the <see cref="TaskHostTaskComplete"/> class.
         /// </summary>
-        /// <param name="result">Result of the task's execution.</param>
+        /// <param name="result">The result of the task's execution.</param>
+        /// <param name="fileAccessData">The file accesses reported by the task.</param>
         /// <param name="buildProcessEnvironment">The build process environment as it was at the end of the task's execution.</param>
-        public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary<string, string> buildProcessEnvironment)
+#pragma warning restore CS1572 // XML comment has a param tag, but there is no parameter by that name
+        public TaskHostTaskComplete(
+            OutOfProcTaskHostTaskResult result,
+#if FEATURE_REPORTFILEACCESSES
+            List<FileAccessData> fileAccessData,
+#endif
+            IDictionary<string, string> buildProcessEnvironment)
         {
             ErrorUtilities.VerifyThrowInternalNull(result, nameof(result));
 
@@ -95,6 +111,9 @@ public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary<stri
             _taskException = result.TaskException;
             _taskExceptionMessage = result.ExceptionMessage;
             _taskExceptionMessageArgs = result.ExceptionMessageArgs;
+#if FEATURE_REPORTFILEACCESSES
+            _fileAccessData = fileAccessData;
+#endif
 
             if (result.FinalParameterValues != null)
             {
@@ -201,6 +220,17 @@ public NodePacketType Type
             get { return NodePacketType.TaskHostTaskComplete; }
         }
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// Gets the file accesses reported by the task.
+        /// </summary>
+        public List<FileAccessData> FileAccessData
+        {
+            [DebuggerStepThrough]
+            get => _fileAccessData;
+        }
+#endif
+
         /// <summary>
         /// Translates the packet to/from binary form.
         /// </summary>
@@ -213,6 +243,12 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _taskExceptionMessageArgs);
             translator.TranslateDictionary(ref _taskOutputParameters, StringComparer.OrdinalIgnoreCase, TaskParameter.FactoryForDeserialization);
             translator.TranslateDictionary(ref _buildProcessEnvironment, StringComparer.OrdinalIgnoreCase);
+#if FEATURE_REPORTFILEACCESSES
+            translator.Translate(ref _fileAccessData);
+#else
+            bool hasFileAccessData = false;
+            translator.Translate(ref hasFileAccessData);
+#endif
         }
 
         /// <summary>
diff --git a/src/Shared/Tracing.cs b/src/Shared/Tracing.cs
index d26f7127305..a71f01f150d 100644
--- a/src/Shared/Tracing.cs
+++ b/src/Shared/Tracing.cs
@@ -141,7 +141,6 @@ internal static void List<T>(IEnumerable<T> items)
         /// Dump all the named counters, if any
         /// </summary>
         [Conditional("DEBUG")]
-        [SuppressMessage("Microsoft.MSInternal", "CA908:AvoidTypesThatRequireJitCompilationInPrecompiledAssemblies", Justification = "Debug only")]
         internal static void Dump()
         {
             if (s_counts.Count > 0)
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index f704ef169a1..5b672f3b88c 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
+using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
@@ -338,7 +339,7 @@ public void ForceOutOfDate()
             /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
             Before:
             Utilities.AssertLogContainsResource(t, "GenerateResource.OutputDoesntExist", t.OutputResources[0].ItemSpec);
-            
+
             Utilities.AssertStateFileWasWritten(t);
             After:
             Utilities.AssertLogContainsResource(t, "GenerateResource.OutputDoesntExist", t.OutputResources[0].ItemSpec);
@@ -1718,7 +1719,7 @@ public void FailedResXReader()
                 /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
                 Before:
                 Assert.False(success);
-                
+
                 Utilities.AssertStateFileWasWritten(t);
                 After:
                 Assert.False(success);
@@ -1797,7 +1798,7 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
                 /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
                 Before:
                 Assert.False(success);
-                
+
                 Utilities.AssertStateFileWasWritten(t);
                 After:
                 Assert.False(success);
@@ -2317,7 +2318,7 @@ public void OutputFilesPartialInputs()
                 /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
                 Before:
                 Assert.Equal(t.FilesWritten[2].ItemSpec, Path.ChangeExtension(t.Sources[3].ItemSpec, ".resources"));
-                
+
                 Utilities.AssertStateFileWasWritten(t);
                 After:
                 Assert.Equal(t.FilesWritten[2].ItemSpec, Path.ChangeExtension(t.Sources[3].ItemSpec, ".resources"));
@@ -3653,6 +3654,20 @@ GenerateResource ExecuteTask()
                 Utilities.FileUpdated(resourcesFile, initialWriteTime).ShouldBeFalse();
             }
         }
+
+        /// <summary>
+        /// https://github.com/dotnet/msbuild/issues/9199
+        /// </summary>
+        [Fact]
+        public void NotValidSources()
+        {
+            GenerateResource t = new GenerateResource { BuildEngine = new MockEngine(_output) };
+            t.Sources = new ITaskItem[] { new TaskItem("non-existent") };
+            t.OutputResources = new ITaskItem[] { new TaskItem("out") };
+            Assert.False(t.Execute());
+            ((MockEngine)t.BuildEngine).AssertLogContains("MSB3552");
+            Assert.Equal(1, ((MockEngine)t.BuildEngine).Errors);
+        }
     }
 }
 
diff --git a/src/Tasks/Al.cs b/src/Tasks/Al.cs
index 7d9ad8fa1a8..0b587df5b74 100644
--- a/src/Tasks/Al.cs
+++ b/src/Tasks/Al.cs
@@ -1,21 +1,26 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// This class defines the "AL" XMake task, which enables using al.exe to link
     /// modules and resource files into assemblies.
     /// </summary>
-    public class AL : ToolTaskExtension
+    public class AL : ToolTaskExtension, IALTaskContract
     {
         #region Properties
         /*
@@ -387,6 +392,130 @@ public override bool Execute()
             return base.Execute();
         }
 
+        #endregion
+    }
+
+#else
+
+    /// <summary>
+    /// Stub AL task for .NET Core.
+    /// </summary>
+    public sealed class AL : TaskRequiresFramework, IALTaskContract
+    {
+        public AL()
+            : base(nameof(AL))
+        {
+        }
+
+        #region Properties
+
+        public string AlgorithmId { get; set; }
+
+        public string BaseAddress { get; set; }
+
+        public string CompanyName { get; set; }
+
+        public string Configuration { get; set; }
+
+        public string Copyright { get; set; }
+
+        public string Culture { get; set; }
+
+        public bool DelaySign { get; set; }
+
+        public string Description { get; set; }
+
+        public string EvidenceFile { get; set; }
+
+        public string FileVersion { get; set; }
+
+        public string Flags { get; set; }
+
+        public bool GenerateFullPaths { get; set; }
+
+        public string KeyFile { get; set; }
+
+        public string KeyContainer { get; set; }
+
+        public string MainEntryPoint { get; set; }
+
+        [Output]
+        public ITaskItem OutputAssembly { get; set; }
+
+        public string Platform { get; set; }
+
+        public bool Prefer32Bit { get; set; }
+
+        public string ProductName { get; set; }
+
+        public string ProductVersion { get; set; }
+
+        public string[] ResponseFiles { get; set; }
+
+        public string TargetType { get; set; }
+
+        public string TemplateFile { get; set; }
+
+        public string Title { get; set; }
+
+        public string Trademark { get; set; }
+
+        public string Version { get; set; }
+
+        public string Win32Icon { get; set; }
+
+        public string Win32Resource { get; set; }
+
+        public ITaskItem[] SourceModules { get; set; }
+
+        public ITaskItem[] EmbedResources { get; set; }
+
+        public ITaskItem[] LinkResources { get; set; }
+
+        public string SdkToolsPath { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IALTaskContract
+    {
+        #region Properties
+
+        string AlgorithmId { get; set; }
+        string BaseAddress { get; set; }
+        string CompanyName { get; set; }
+        string Configuration { get; set; }
+        string Copyright { get; set; }
+        string Culture { get; set; }
+        bool DelaySign { get; set; }
+        string Description { get; set; }
+        string EvidenceFile { get; set; }
+        string FileVersion { get; set; }
+        string Flags { get; set; }
+        bool GenerateFullPaths { get; set; }
+        string KeyFile { get; set; }
+        string KeyContainer { get; set; }
+        string MainEntryPoint { get; set; }
+        ITaskItem OutputAssembly { get; set; }
+        string Platform { get; set; }
+        bool Prefer32Bit { get; set; }
+        string ProductName { get; set; }
+        string ProductVersion { get; set; }
+        string[] ResponseFiles { get; set; }
+        string TargetType { get; set; }
+        string TemplateFile { get; set; }
+        string Title { get; set; }
+        string Trademark { get; set; }
+        string Version { get; set; }
+        string Win32Icon { get; set; }
+        string Win32Resource { get; set; }
+        ITaskItem[] SourceModules { get; set; }
+        ITaskItem[] EmbedResources { get; set; }
+        ITaskItem[] LinkResources { get; set; }
+        string SdkToolsPath { get; set; }
+
         #endregion
     }
 }
diff --git a/src/Tasks/AspNetCompiler.cs b/src/Tasks/AspNetCompiler.cs
index 1e1d3b4b2be..3570cc44010 100644
--- a/src/Tasks/AspNetCompiler.cs
+++ b/src/Tasks/AspNetCompiler.cs
@@ -1,16 +1,20 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using Microsoft.Build.Utilities;
+#endif
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// The AspNetCompiler task, which is a wrapper around aspnet_compiler.exe
     /// </summary>
-    public class AspNetCompiler : ToolTaskExtension
+    public class AspNetCompiler : ToolTaskExtension, IAspNetCompilerTaskContract
     {
         /*
             C:\WINDOWS\Microsoft.NET\Framework\v2.0.x86dbg>aspnet_compiler /?
@@ -338,4 +342,70 @@ protected override bool ValidateParameters()
             return true;
         }
     }
+
+#else
+
+    public sealed class AspNetCompiler : TaskRequiresFramework, IAspNetCompilerTaskContract
+    {
+        public AspNetCompiler()
+            : base(nameof(AspNetCompiler))
+        {
+        }
+
+        #region Properties
+
+        public bool AllowPartiallyTrustedCallers { get; set; }
+
+        public bool DelaySign { get; set; }
+
+        public bool FixedNames { get; set; }
+
+        public string KeyContainer { get; set; }
+
+        public string KeyFile { get; set; }
+
+        public string MetabasePath { get; set; }
+
+        public string PhysicalPath { get; set; }
+
+        public string TargetPath { get; set; }
+
+        public string VirtualPath { get; set; }
+
+        public bool Updateable { get; set; }
+
+        public bool Force { get; set; }
+
+        public bool Debug { get; set; }
+
+        public bool Clean { get; set; }
+
+        public string TargetFrameworkMoniker { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IAspNetCompilerTaskContract
+    {
+        #region Properties
+
+        bool AllowPartiallyTrustedCallers { get; set; }
+        bool DelaySign { get; set; }
+        bool FixedNames { get; set; }
+        string KeyContainer { get; set; }
+        string KeyFile { get; set; }
+        string MetabasePath { get; set; }
+        string PhysicalPath { get; set; }
+        string TargetPath { get; set; }
+        string VirtualPath { get; set; }
+        bool Updateable { get; set; }
+        bool Force { get; set; }
+        bool Debug { get; set; }
+        bool Clean { get; set; }
+        string TargetFrameworkMoniker { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/CompatibilitySuppressions.xml b/src/Tasks/CompatibilitySuppressions.xml
index 498513b70bc..9647c21c161 100644
--- a/src/Tasks/CompatibilitySuppressions.xml
+++ b/src/Tasks/CompatibilitySuppressions.xml
@@ -1,24 +1,75 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <Suppression>
-<!-- For ease of logging the "not supported on Core" message, this task is a
-         TaskExtension on netstandard/netcore. Since the type is sealed there,
+<!-- For ease of logging the "not supported on Core" message, these tasks are a
+         TaskRequiresFramework on netstandard/netcore. Since the type is sealed there,
          that shouldn't cause any implementation problems since no one can derive
          from it and try to call TaskExtension.Log. -->
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.AL</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.AspNetCompiler</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.GenerateBootstrapper</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.GenerateTrustInfo</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.GetFrameworkSdkPath</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.RegisterAssembly</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
     <DiagnosticId>CP0007</DiagnosticId>
     <Target>T:Microsoft.Build.Tasks.ResolveComReference</Target>
     <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
     <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
   </Suppression>
-
-  <!-- We don't have the net7 reference assemblies handy to pass in to compare against the net8 ones -->
   <Suppression>
-    <DiagnosticId>CP1002</DiagnosticId>
-    <Target>System.Security.Cryptography, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Target>
-    <Left>ref/net7.0/Microsoft.Build.Tasks.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.ResolveNativeReference</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.UnregisterAssembly</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.UpdateManifest</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.WinMDExp</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
   </Suppression>
 
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
@@ -74,9 +125,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-<!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net7.0</Target>
-  </Suppression>
 </Suppressions>
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 68d7f27ddba..606677f3305 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -211,11 +211,11 @@ internal static void RefreshInternalEnvironmentValues()
         /// If MSBUILDALWAYSRETRY is set, also log useful diagnostic information -- as 
         /// a warning, so it's easily visible. 
         /// </summary>
-        private void LogDiagnostic(string message, params object[] messageArgs)
+        private void LogAlwaysRetryDiagnosticFromResources(string messageResourceName, params object[] messageArgs)
         {
             if (s_alwaysRetryCopy)
             {
-                Log.LogWarning(message, messageArgs);
+                Log.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
             }
         }
 
@@ -285,7 +285,10 @@ private void LogDiagnostic(string message, params object[] messageArgs)
                 MakeFileWriteable(destinationFileState, true);
             }
 
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) && destinationFileState.FileExists && !destinationFileState.IsReadOnly)
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) &&
+                Traits.Instance.EscapeHatches.CopyWithoutDelete != true &&
+                destinationFileState.FileExists &&
+                !destinationFileState.IsReadOnly)
             {
                 FileUtilities.DeleteNoThrow(destinationFileState.Name);
             }
@@ -823,7 +826,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                         case IOException: // Not clear why we can get one and not the other
                             int code = Marshal.GetHRForException(e);
 
-                            LogDiagnostic("Got {0} copying {1} to {2} and HR is {3}", e.ToString(), sourceFileState.Name, destinationFileState.Name, code);
+                            LogAlwaysRetryDiagnosticFromResources("Copy.IOException", e.ToString(), sourceFileState.Name, destinationFileState.Name, code);
                             if (code == NativeMethods.ERROR_ACCESS_DENIED)
                             {
                                 // ERROR_ACCESS_DENIED can either mean there's an ACL preventing us, or the file has the readonly bit set.
@@ -839,7 +842,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                                 }
                                 else
                                 {
-                                    LogDiagnostic("Retrying on ERROR_ACCESS_DENIED because MSBUILDALWAYSRETRY = 1");
+                                    LogAlwaysRetryDiagnosticFromResources("Copy.RetryingOnAccessDenied");
                                 }
                             }
                             else if (code == NativeMethods.ERROR_INVALID_FILENAME)
diff --git a/src/Tasks/GenerateBootstrapper.cs b/src/Tasks/GenerateBootstrapper.cs
index 7eb63e1e8e0..241ca0a4610 100644
--- a/src/Tasks/GenerateBootstrapper.cs
+++ b/src/Tasks/GenerateBootstrapper.cs
@@ -1,20 +1,25 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.Deployment.Bootstrapper;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Generates a bootstrapper for ClickOnce deployment projects.
     /// </summary>
-    public sealed class GenerateBootstrapper : TaskExtension
+    public sealed class GenerateBootstrapper : TaskExtension, IGenerateBootstrapperTaskContract
     {
         public string ApplicationName { get; set; }
 
@@ -174,4 +179,81 @@ private ComponentsLocation ConvertStringToComponentsLocation(string parameterVal
             }
         }
     }
+
+#else
+
+    public sealed class GenerateBootstrapper : TaskRequiresFramework, IGenerateBootstrapperTaskContract
+    {
+        public GenerateBootstrapper()
+            : base(nameof(GenerateBootstrapper))
+        {
+        }
+
+        #region Properties
+
+        public string ApplicationName { get; set; }
+
+        public string ApplicationFile { get; set; }
+
+        public bool ApplicationRequiresElevation { get; set; }
+
+        public string ApplicationUrl { get; set; }
+
+        public ITaskItem[] BootstrapperItems { get; set; }
+
+        public string ComponentsLocation { get; set; }
+
+        public string ComponentsUrl { get; set; }
+
+        public bool CopyComponents { get; set; }
+
+        public string Culture { get; set; }
+
+        public string FallbackCulture { get; set; }
+
+        public string OutputPath { get; set; }
+
+        public string Path { get; set; }
+
+        public string SupportUrl { get; set; }
+
+        public string VisualStudioVersion { get; set; }
+
+        public bool Validate { get; set; }
+
+        [Output]
+        public string BootstrapperKeyFile { get; set; }
+
+        [Output]
+        public string[] BootstrapperComponentFiles { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IGenerateBootstrapperTaskContract
+    {
+        #region Properties
+
+        string ApplicationName { get; set; }
+        string ApplicationFile { get; set; }
+        bool ApplicationRequiresElevation { get; set; }
+        string ApplicationUrl { get; set; }
+        ITaskItem[] BootstrapperItems { get; set; }
+        string ComponentsLocation { get; set; }
+        string ComponentsUrl { get; set; }
+        bool CopyComponents { get; set; }
+        string Culture { get; set; }
+        string FallbackCulture { get; set; }
+        string OutputPath { get; set; }
+        string Path { get; set; }
+        string SupportUrl { get; set; }
+        string VisualStudioVersion { get; set; }
+        bool Validate { get; set; }
+        string BootstrapperKeyFile { get; set; }
+        string[] BootstrapperComponentFiles { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 3c198c1d512..cb84eb5b8ae 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -714,14 +714,22 @@ public override bool Execute()
 
                 GetResourcesToProcess(out inputsToProcess, out outputsToProcess, out cachedOutputFiles);
 
-                if (inputsToProcess.Count == 0 && !Log.HasLoggedErrors)
+                if (inputsToProcess.Count == 0)
                 {
-                    if (cachedOutputFiles.Count > 0)
+                    if (!Log.HasLoggedErrors)
                     {
-                        OutputResources = cachedOutputFiles.ToArray();
-                    }
+                        if (cachedOutputFiles.Count > 0)
+                        {
+                            OutputResources = cachedOutputFiles.ToArray();
+                        }
 
-                    Log.LogMessageFromResources("GenerateResource.NothingOutOfDate");
+                        Log.LogMessageFromResources("GenerateResource.NothingOutOfDate");
+                    }
+                    else
+                    {
+                        // No valid sources found--failures should have been logged in GetResourcesToProcess
+                        return false;
+                    }
                 }
                 else if (FailIfNotIncremental)
                 {
diff --git a/src/Tasks/GenerateTrustInfo.cs b/src/Tasks/GenerateTrustInfo.cs
index e6a6a1d43cc..7d76056879b 100644
--- a/src/Tasks/GenerateTrustInfo.cs
+++ b/src/Tasks/GenerateTrustInfo.cs
@@ -1,21 +1,27 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
-using Microsoft.Build.Framework;
+
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// This task generates the application trust from the base manifest
     /// and the TargetZone and ExcludedPermissions properties.
     /// </summary>
-    public sealed class GenerateTrustInfo : TaskExtension
+    public sealed class GenerateTrustInfo : TaskExtension, IGenerateTrustInfoTaskContract
     {
         private const string Custom = "Custom";
 
@@ -98,4 +104,47 @@ public override bool Execute()
             return true;
         }
     }
+
+#else
+
+    public sealed class GenerateTrustInfo : TaskRequiresFramework, IGenerateTrustInfoTaskContract
+    {
+        public GenerateTrustInfo()
+            : base(nameof(GenerateTrustInfo))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem BaseManifest { get; set; }
+
+        public string ExcludedPermissions { get; set; }
+
+        public string TargetFrameworkMoniker { get; set; }
+
+        public string TargetZone { get; set; }
+
+        public ITaskItem[] ApplicationDependencies { get; set; }
+
+        [Output]
+        public ITaskItem TrustInfoFile { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IGenerateTrustInfoTaskContract
+    {
+        #region Properties
+
+        ITaskItem BaseManifest { get; set; }
+        string ExcludedPermissions { get; set; }
+        string TargetFrameworkMoniker { get; set; }
+        string TargetZone { get; set; }
+        ITaskItem[] ApplicationDependencies { get; set; }
+        ITaskItem TrustInfoFile { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/GetFrameworkSDKPath.cs b/src/Tasks/GetFrameworkSDKPath.cs
index 5d10aaf2817..fb90e032392 100644
--- a/src/Tasks/GetFrameworkSDKPath.cs
+++ b/src/Tasks/GetFrameworkSDKPath.cs
@@ -1,19 +1,25 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
-using Microsoft.Build.Framework;
+
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Returns paths to the frameworks SDK.
     /// </summary>
-    public class GetFrameworkSdkPath : TaskExtension
+    public class GetFrameworkSdkPath : TaskExtension, IGetFrameworkSdkPathTaskContract
     {
         #region Properties
 
@@ -311,4 +317,61 @@ public override bool Execute()
 
         #endregion
     }
+#else
+
+    public sealed class GetFrameworkSdkPath : TaskRequiresFramework, IGetFrameworkSdkPathTaskContract
+    {
+        public GetFrameworkSdkPath()
+            : base(nameof(GetFrameworkSdkPath))
+        {
+        }
+
+        #region Properties
+
+        [Output]
+        public string Path { get; set; }
+
+        [Output]
+        public string FrameworkSdkVersion20Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion35Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion40Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion45Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion451Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion46Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion461Path { get; }
+
+        #endregion
+    }
+
+#endif
+
+#pragma warning disable SA1201 // Elements should appear in the correct order
+    internal interface IGetFrameworkSdkPathTaskContract
+    {
+        #region Properties
+
+        string Path { get; set; }
+        string FrameworkSdkVersion20Path { get; }
+        string FrameworkSdkVersion35Path { get; }
+        string FrameworkSdkVersion40Path { get; }
+        string FrameworkSdkVersion45Path { get; }
+        string FrameworkSdkVersion451Path { get; }
+        string FrameworkSdkVersion46Path { get; }
+        string FrameworkSdkVersion461Path { get; }
+
+        #endregion
+    }
+#pragma warning restore SA1201 // Elements should appear in the correct order
 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 72ea1091d20..d791ba1e021 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -328,7 +328,6 @@
     <Compile Include="ResourceHandling\*.cs" />
     <Compile Include="GetCompatiblePlatform.cs" />
     <Compile Include="SetRidAgnosticValueForProjects.cs" />
-    <Compile Include="ResolveComReference.cs" />
     <Compile Include="BuildCacheDisposeWrapper.cs" />
     <Compile Include="DownloadFile.cs" />
     <Compile Include="FileIO\GetFileHash.cs" />
@@ -550,14 +549,41 @@
     <Compile Include="DependencyFile.cs" />
     <Compile Include="ZipDirectory.cs" />
   </ItemGroup>
-  <ItemGroup Condition="$(TargetFrameworkIdentifier) == '.NETFramework'">
+  <ItemGroup>
+    <Compile Include="TaskRequiresFramework.cs" />
+    <!-- Tasks with NET/NETSTANDARD stubs -->
     <Compile Include="Al.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="AppDomainIsolatedTaskExtension.cs">
+    <Compile Include="AspNetCompiler.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="AspNetCompiler.cs">
+    <Compile Include="GenerateBootstrapper.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="GenerateTrustInfo.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="GetFrameworkSDKPath.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="RegisterAssembly.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="ResolveComReference.cs" />
+    <Compile Include="ResolveNativeReference.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="UnregisterAssembly.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="UpdateManifest.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="WinMDExp.cs" />
+  </ItemGroup>
+  <ItemGroup Condition="$(TargetFrameworkIdentifier) == '.NETFramework'">
+    <Compile Include="AppDomainIsolatedTaskExtension.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="AssemblyDependency\GacResolver.cs">
@@ -598,15 +624,6 @@
     <Compile Include="ComReferenceWrapperInfo.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="GenerateBootstrapper.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateTrustInfo.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GetFrameworkSDKPath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="IComReferenceResolver.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -617,16 +634,10 @@
     <Compile Include="PiaReference.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="RegisterAssembly.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="ResGen.cs" />
     <Compile Include="ResolveComReferenceCache.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="ResolveNativeReference.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="StrongNameException.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -637,13 +648,6 @@
     <Compile Include="TlbReference.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="UnregisterAssembly.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="UpdateManifest.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="WinMDExp.cs" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <Compile Include="XamlTaskFactory\CommandLineGenerator.cs" />
@@ -974,11 +978,9 @@
   </ItemGroup>
 
   <!-- Mimics AddRefAssemblies from MSBuild.csproj -->
-  <Target Name="AddRefAssemblies"
-          DependsOnTargets="ResolveAssemblyReferences"
-          BeforeTargets="AssignTargetPaths">
+  <Target Name="AddRefAssemblies" DependsOnTargets="ResolveAssemblyReferences" BeforeTargets="AssignTargetPaths">
     <ItemGroup>
-      <Content Include="@(NetstandardRefAssemblies)" CopyToOutputDirectory="PreserveNewest" Link="ref\%(Filename)%(Extension)"/>
+      <Content Include="@(NetstandardRefAssemblies)" CopyToOutputDirectory="PreserveNewest" Link="ref\%(Filename)%(Extension)" />
     </ItemGroup>
   </Target>
 
@@ -1008,7 +1010,6 @@
     <PackageReference Include="System.CodeDom" />
     <PackageReference Include="System.Security.Cryptography.Pkcs" />
     <PackageReference Include="System.Security.Cryptography.Xml" />
-    <PackageReference Include="System.Security.Permissions" />
 
     <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\netcore\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index ad309e55ee2..ebb62b24ded 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1511,6 +1511,24 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
     -->
   <Target Name="AfterResolveReferences"/>
+  
+  <!--
+    ============================================================
+                                        IgnoreJavaScriptOutputAssembly
+
+    esproj are JavaScript or TypeScript Projects that never produce an assembly.
+    Set ReferenceOutputAssembly to false in any reference to an esproj.
+    ============================================================
+    -->
+  <Target Name="IgnoreJavaScriptOutputAssembly"
+    BeforeTargets="AssignProjectConfiguration"
+    Condition="$([MSBuild]::AreFeaturesEnabled('17.8'))">
+      <ItemGroup>
+        <ProjectReference Condition="'%(ProjectReference.Extension)' == '.esproj' and '%(ProjectReference.ReferenceOutputAssembly)' == ''">
+          <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+        </ProjectReference>
+      </ItemGroup>
+  </Target>
 
   <!--
     ============================================================
@@ -4359,6 +4377,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <DeploymentComputeClickOnceManifestInfoDependsOn>
       CleanPublishFolder;
+      GetCopyToOutputDirectoryItems;
       _DeploymentGenerateTrustInfo
       $(DeploymentComputeClickOnceManifestInfoDependsOn)
     </DeploymentComputeClickOnceManifestInfoDependsOn>
@@ -4422,7 +4441,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_ClickOnceRuntimeCopyLocalItems Include="@(NativeCopyLocalItems)"
                                       Condition="'%(NativeCopyLocalItems.CopyLocal)' == 'true'" />
       <_ClickOnceRuntimeCopyLocalItems Remove="@(_DeploymentReferencePaths)" />
-      <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems)"/>
+
+      <!-- Include items from None itemgroup for publishing -->
+      <_ClickOnceNoneItems Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
+
+      <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems);@(_ClickOnceNoneItems);@(_TransitiveItemsToCopyToOutputDirectory)"/>
     </ItemGroup>
 
     <!-- For single file publish, we need to include the SF bundle EXE, application icon file and files excluded from the bundle EXE in the clickonce manifest -->
@@ -5108,7 +5131,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <!-- Empty intermediate items to release memory -->
       <_TransitiveItemsToCopyToOutputDirectoryAlways               Remove="@(_TransitiveItemsToCopyToOutputDirectoryAlways)"/>
       <_TransitiveItemsToCopyToOutputDirectoryPreserveNewest       Remove="@(_TransitiveItemsToCopyToOutputDirectoryPreserveNewest)"/>
-      <_TransitiveItemsToCopyToOutputDirectory                     Remove="@(_TransitiveItemsToCopyToOutputDirectory)"/>
 
       <_ThisProjectItemsToCopyToOutputDirectoryAlways              Remove="@(_ThisProjectItemsToCopyToOutputDirectoryAlways)"/>
       <_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest      Remove="@(_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest)"/>
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index beab1878e60..f8e09491af3 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -63,7 +63,7 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.MSBuild"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(DisableOutOfProcTaskHost)' != ''" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(DisableOutOfProcTaskHost)' != ''" />
   <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
   <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
@@ -84,7 +84,7 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.Telemetry"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Touch"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(DisableOutOfProcTaskHost)' != ''" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(DisableOutOfProcTaskHost)' != ''" />
   <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
   <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index 0fb8e616bb3..542e2a8f08b 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -1,7 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#if FEATURE_APPDOMAIN
+#if NETFRAMEWORK && FEATURE_APPDOMAIN
 
 using System;
 using System.Diagnostics;
@@ -11,20 +11,25 @@
 using System.Runtime.InteropServices.ComTypes;
 using System.Security;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
+#endif
+
+using Microsoft.Build.Framework;
+
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK && FEATURE_APPDOMAIN
+
     /// <summary>
     /// Registers a managed assembly for COM interop (equivalent of regasm.exe functionality, but this code doesn't actually call the exe).
     /// </summary>
     /// <comment>ITypeLibExporterNotifySink is necessary for the ITypeLibConverter.ConvertAssemblyToTypeLib call.</comment>
-    public class RegisterAssembly : AppDomainIsolatedTaskExtension, ITypeLibExporterNotifySink
+    public class RegisterAssembly : AppDomainIsolatedTaskExtension, ITypeLibExporterNotifySink, IRegisterAssemblyTaskContract
     {
         #region Properties
 
@@ -360,5 +365,41 @@ private bool ExportTypeLib(Assembly asm, string typeLibFileName)
 
         #endregion
     }
-}
+
+#elif !NETFRAMEWORK
+
+    public sealed class RegisterAssembly : TaskRequiresFramework, IRegisterAssemblyTaskContract
+    {
+        public RegisterAssembly()
+            : base(nameof(RegisterAssembly))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem[] Assemblies { get; set; }
+
+        [Output]
+        public ITaskItem[] TypeLibFiles { get; set; }
+
+        public bool CreateCodeBase { get; set; }
+
+        public ITaskItem AssemblyListFile { get; set; }
+
+        #endregion
+    }
+
 #endif
+
+    internal interface IRegisterAssemblyTaskContract
+    {
+        #region Properties
+
+        ITaskItem[] Assemblies { get; set; }
+        ITaskItem[] TypeLibFiles { get; set; }
+        bool CreateCodeBase { get; set; }
+        ITaskItem AssemblyListFile { get; set; }
+
+        #endregion
+    }
+}
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 0a3eb949eef..a9fcee543f6 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -139,8 +139,13 @@ internal interface IResolveComReferenceTaskContract
     /// <summary>
     /// Main class for the COM reference resolution task for .NET Core
     /// </summary>
-    public sealed partial class ResolveComReference : Microsoft.Build.Tasks.TaskExtension, IResolveComReferenceTaskContract
+    public sealed partial class ResolveComReference : TaskRequiresFramework, IResolveComReferenceTaskContract
     {
+        public ResolveComReference()
+            : base(nameof(ResolveComReference))
+        {
+        }
+
 #pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Properties
 
@@ -183,20 +188,6 @@ public sealed partial class ResolveComReference : Microsoft.Build.Tasks.TaskExte
         public string TargetFrameworkVersion { get; set; } = String.Empty;
 
         #endregion
-
-        #region ITask members
-
-        /// <summary>
-        /// Task entry point.
-        /// </summary>
-        /// <returns></returns>
-        public override bool Execute()
-        {
-            Log.LogErrorWithCodeFromResources("TaskRequiresFrameworkFailure", nameof(ResolveComReference));
-            return false;
-        }
-
-        #endregion
 #pragma warning restore format 
     }
 
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index 66a5ac3c70b..484401442be 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
 using System.IO;
 using System.Collections;
@@ -9,20 +10,25 @@
 using System.Diagnostics;
 #endif
 using System.Linq;
-using Microsoft.Build.Framework;
+
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using Microsoft.Build.Utilities;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Main class for the native reference resolution task.
     /// </summary>
-    public class ResolveNativeReference : TaskExtension
+    public class ResolveNativeReference : TaskExtension, IResolveNativeReferenceTaskConract
     {
         #region Constructors
 
@@ -340,4 +346,58 @@ internal bool ExtractFromManifest(
         }
         #endregion
     }
+
+#else
+
+    public sealed class ResolveNativeReference : TaskRequiresFramework, IResolveNativeReferenceTaskConract
+    {
+        public ResolveNativeReference()
+            : base(nameof(ResolveNativeReference))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem[] NativeReferences { get; set; }
+
+        public string[] AdditionalSearchPaths { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainingReferenceFiles { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedPrerequisiteAssemblies { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedComComponents { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedTypeLibraries { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedLooseTlbFiles { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedLooseEtcFiles { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IResolveNativeReferenceTaskConract
+    {
+        #region Properties
+
+        ITaskItem[] NativeReferences { get; set; }
+        string[] AdditionalSearchPaths { get; set; }
+        ITaskItem[] ContainingReferenceFiles { get; set; }
+        ITaskItem[] ContainedPrerequisiteAssemblies { get; set; }
+        ITaskItem[] ContainedComComponents { get; set; }
+        ITaskItem[] ContainedTypeLibraries { get; set; }
+        ITaskItem[] ContainedLooseTlbFiles { get; set; }
+        ITaskItem[] ContainedLooseEtcFiles { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 8b337bb2db5..eb1e5e3b341 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -2781,6 +2781,14 @@
     <value>MSB3893: Could not use a link to copy "{0}" to "{1}".</value>
     <comment>{StrBegin="MSB3893: "} LOCALIZATION: {0} and {1} are paths.</comment>
   </data>
+  <data name="Copy.IOException">
+    <value>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</value>
+    <comment>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</comment>
+  </data>
+  <data name="Copy.RetryingOnAccessDenied">
+    <value>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</value>
+    <comment>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</comment>
+  </data>
 
   <!--
         MSB3901 - MSB3910   Task: Telemetry
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index e911bfc64fe..fae41cc00f4 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Vytv se pevn odkaz pro koprovn {0} do {1}.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Ned se pout odkaz pro koprovn {0} do {1}.</target>
@@ -221,6 +226,11 @@
         <target state="translated">Nepovedlo se pout pevn odkaz ke zkoprovn {0} do {1}. Msto toho se soubor kopruje pomoc symbolickho odkazu. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Zdrojov soubor {0} je ve skutenosti adres.  loha koprovn nepodporuje koprovn adres.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 1db9a0ed02b..59a4deae689 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Es wird ein fester Link erstellt, um "{0}" in "{1}" zu kopieren.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Es konnte kein Link verwendet werden, um "{0}" in "{1}" zu kopieren.</target>
@@ -221,6 +226,11 @@
         <target state="translated">Es konnte kein fester Link verwendet werden, um "{0}" in "{1}" zu kopieren. Stattdessen wird die Datei mit einer symbolischen Verknpfung kopiert. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Die Quelldatei "{0}" ist keine Datei, sondern ein Verzeichnis.  Mit der Copy-Aufgabe knnen keine Verzeichnisse kopiert werden.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 6bf3797e34f..ae7cfb8ec4f 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Creando un vnculo fsico para copiar "{0}" en "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: No se puede usar un vnculo para copiar "{0}" en "{1}".</target>
@@ -221,6 +226,11 @@
         <target state="translated">No se puede usar un vnculo fsico para copiar "{0}" en "{1}". Se va a copiar el archivo en un vnculo simblico su lugar. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: El archivo de origen "{0}" es un directorio.  La tarea "Copy" no permite copiar directorios.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 1c092fd0a8c..9b160b33de7 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Cration d'un lien physique pour copier "{0}" vers "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: impossible d'utiliser un lien pour copier "{0}" vers "{1}".</target>
@@ -221,6 +226,11 @@
         <target state="translated">Impossible dutiliser un lien physique pour copier {0} vers {1}. Copie du fichier avec un lien symbolique  la place. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Le fichier source "{0}" est en fait un rpertoire.  La tche "Copy" ne prend pas en charge la copie des rpertoires.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index fc2c0670f0a..e523ac51626 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Creazione del collegamento reale per copiare "{0}" in "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: non  stato possibile usare un collegamento per copiare "{0}" in "{1}".</target>
@@ -221,6 +226,11 @@
         <target state="translated">Impossibile utilizzare un collegamento reale per copiare "{0}" in "{1}". Verr invece copiato il file con collegamento simbolico. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: il file di origine "{0}"  in realt una directory. L'attivit "Copia" non supporta la copia di directory.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 605cfdf73f4..a1c707f056e 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -191,6 +191,11 @@
         <target state="translated">  "{0}"  "{1}" </target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893:  "{0}"  "{1}" </target>
@@ -221,6 +226,11 @@
         <target state="translated">  "{0}"  "{1}"   {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025:   "{0}" "Copy" </target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 39b15815f32..757be9a3c02 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -191,6 +191,11 @@
         <target state="translated">"{0}"() "{1}"()     .</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893:   "{0}"() "{1}"   .</target>
@@ -221,6 +226,11 @@
         <target state="translated">   "{0}() "{1}"   .      . {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025:   "{0}"()  .  "Copy"     .</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 56153414787..8840c4369a4 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Tworzenie twardego cza w celu skopiowania {0} do {1}.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Nie mona uy linku w celu skopiowania cieki {0} do cieki {1}.</target>
@@ -221,6 +226,11 @@
         <target state="translated">Nie mona uy twardego linku do skopiowania {0} do {1}. Zamiast tego kopiuje plik za pomoc linku symbolicznego. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Plik rdowy {0} jest w rzeczywistoci katalogiem.  Zadanie Copy nie obsuguje kopiowania katalogw.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index db84fa88b8a..8be7760268b 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Criando link fsico para copiar "{0}" em "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: No foi possvel usar um link para copiar "{0}" para "{1}".</target>
@@ -221,6 +226,11 @@
         <target state="translated">No foi possvel usar um link fsico para copiar "{0}" para "{1}". Em vez disso, copiando o arquivo com link simblico. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: O arquivo de origem "{0}" , na verdade, um diretrio.  A tarefa "Copy" no d suporte  cpia de diretrios.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index d090d29ef62..1821c37dca7 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -191,6 +191,11 @@
         <target state="translated">     "{0}"  "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893:       "{0}"  "{1}".</target>
@@ -221,6 +226,11 @@
         <target state="translated">       "{0}"  "{1}".      . {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025:   "{0}"    .   Copy    .</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index c5979af8059..e72910ae0ad 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -191,6 +191,11 @@
         <target state="translated">"{0}" yolunu "{1}" yoluna kopyalamak iin sabit balant oluturuluyor.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: "{0}" dosyasn "{1}" yoluna kopyalama balants kullanlamad.</target>
@@ -221,6 +226,11 @@
         <target state="translated">"{0}" yolunu "{1}" yoluna kopyalamak iin sabit balant kullanlamad. Dosya bunun yerine sembolik balant ile kopyalanyor. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: "{0}" kaynak dosyas aslnda bir dizindir.  "Kopyala" grevi, dizinleri kopyalamay desteklemez.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 8b146319e98..414ba0e831c 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -191,6 +191,11 @@
         <target state="translated">{0}{1}</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: {0}{1}</target>
@@ -221,6 +226,11 @@
         <target state="translated">{0}{1} {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: {0}Copy</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index c03fdbd6641..cf5ea88f40c 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -191,6 +191,11 @@
         <target state="translated"> "{0}"  "{1}"</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="new">MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893:  "{0}"  "{1}"</target>
@@ -221,6 +226,11 @@
         <target state="translated"> "{0}"  "{1}"{2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="new">MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025:  "{0}" "Copy" </target>
diff --git a/src/Tasks/TaskRequiresFramework.cs b/src/Tasks/TaskRequiresFramework.cs
new file mode 100644
index 00000000000..e681eb903b5
--- /dev/null
+++ b/src/Tasks/TaskRequiresFramework.cs
@@ -0,0 +1,30 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+
+using System;
+
+namespace Microsoft.Build.Tasks
+{
+#if NETFRAMEWORK
+    [Obsolete("The class should not be used in .Net Framework.", true)]
+#endif
+    public abstract class TaskRequiresFramework : TaskExtension
+    {
+        internal TaskRequiresFramework(string taskName) => TaskName = taskName;
+
+        private string TaskName { get; set; }
+
+#if !NETFRAMEWORK
+        /// <summary>
+        /// Task entry point.
+        /// </summary>
+        /// <returns></returns>
+        public override bool Execute()
+        {
+            Log.LogErrorWithCodeFromResources("TaskRequiresFrameworkFailure", TaskName);
+            return false;
+        }
+#endif
+    }
+}
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 4c297df27fd..6721625deb5 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -1,7 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#if FEATURE_APPDOMAIN
+#if NETFRAMEWORK && FEATURE_APPDOMAIN
 
 using System;
 #if DEBUG
@@ -14,19 +14,23 @@
 using System.Threading;
 using System.Runtime.InteropServices.ComTypes;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK && FEATURE_APPDOMAIN
+
     /// <summary>
     /// Registers a managed assembly for COM interop (equivalent of regasm.exe functionality, but this code
     /// doesn't actually call the exe).
     /// </summary>
-    public class UnregisterAssembly : AppDomainIsolatedTaskExtension
+    public class UnregisterAssembly : AppDomainIsolatedTaskExtension, IUnregisterAssemblyTaskContract
     {
         #region Properties
 
@@ -289,5 +293,37 @@ private bool Unregister(string assemblyPath, string typeLibPath)
         private const string unregisteringLockName = "MSBUILD_V_3_5_UNREGISTER_LOCK";
         #endregion
     }
-}
+
+#elif !NETFRAMEWORK
+
+    public sealed class UnregisterAssembly : TaskRequiresFramework, IUnregisterAssemblyTaskContract
+    {
+        public UnregisterAssembly()
+            : base(nameof(UnregisterAssembly))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem[] Assemblies { get; set; }
+
+        public ITaskItem[] TypeLibFiles { get; set; }
+
+        public ITaskItem AssemblyListFile { get; set; }
+
+        #endregion
+    }
+
 #endif
+
+    public interface IUnregisterAssemblyTaskContract
+    {
+        #region Properties
+
+        ITaskItem[] Assemblies { get; set; }
+        ITaskItem[] TypeLibFiles { get; set; }
+        ITaskItem AssemblyListFile { get; set; }
+
+        #endregion
+    }
+}
diff --git a/src/Tasks/UpdateManifest.cs b/src/Tasks/UpdateManifest.cs
index 0e9e78bef9c..109f7ee732c 100644
--- a/src/Tasks/UpdateManifest.cs
+++ b/src/Tasks/UpdateManifest.cs
@@ -2,17 +2,22 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.Build.Framework;
+
+#if NETFRAMEWORK
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using Microsoft.Build.Utilities;
+#endif
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Updates selected properties in a manifest and resigns.
     /// </summary>
-    public class UpdateManifest : Task
+    public class UpdateManifest : Task, IUpdateManifestTaskContract
     {
         [Required]
         public string ApplicationPath { get; set; }
@@ -35,4 +40,44 @@ public override bool Execute()
             return true;
         }
     }
+
+#else
+
+    public sealed class UpdateManifest : TaskRequiresFramework, IUpdateManifestTaskContract
+    {
+        public UpdateManifest()
+            : base(nameof(UpdateManifest))
+        {
+        }
+
+        #region Properties
+
+        public string ApplicationPath { get; set; }
+
+        public string TargetFrameworkVersion { get; set; }
+
+        public ITaskItem ApplicationManifest { get; set; }
+
+        public ITaskItem InputManifest { get; set; }
+
+        [Output]
+        public ITaskItem OutputManifest { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IUpdateManifestTaskContract
+    {
+        #region Properties
+
+        string ApplicationPath { get; set; }
+        string TargetFrameworkVersion { get; set; }
+        ITaskItem ApplicationManifest { get; set; }
+        ITaskItem InputManifest { get; set; }
+        ITaskItem OutputManifest { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/WinMDExp.cs b/src/Tasks/WinMDExp.cs
index 28e2662c997..280b5dcb55c 100644
--- a/src/Tasks/WinMDExp.cs
+++ b/src/Tasks/WinMDExp.cs
@@ -1,21 +1,28 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
-using System.Diagnostics.CodeAnalysis;
 using System.IO;
 using System.Text;
-using Microsoft.Build.Framework;
+
 using Microsoft.Build.Shared;
+#endif
+
+using System.Diagnostics.CodeAnalysis;
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Exports a managed assembly to a windows runtime metadata.
     /// </summary>
-    public class WinMDExp : ToolTaskExtension
+    public class WinMDExp : ToolTaskExtension, IWinMDExpTaskContract
     {
         #region Properties
 
@@ -274,4 +281,66 @@ protected override bool SkipTaskExecution()
         }
         #endregion
     }
+
+#else
+
+    public sealed class WinMDExp : TaskRequiresFramework, IWinMDExpTaskContract
+    {
+        public WinMDExp()
+            : base(nameof(WinMDExp))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem[] References { get; set; }
+
+        public string DisabledWarnings { get; set; }
+
+        public string InputDocumentationFile { get; set; }
+
+        public string OutputDocumentationFile { get; set; }
+
+        public string InputPDBFile { get; set; }
+
+        public string OutputPDBFile { get; set; }
+
+        public string WinMDModule { get; set; }
+
+        [Output]
+        public string OutputWindowsMetadataFile { get; set; }
+
+        public string SdkToolsPath { get; set; }
+
+        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "UTF", Justification = "Not worth breaking customers because of case correction")]
+        public bool UTF8Output { get; set; }
+
+        public bool TreatWarningsAsErrors { get; set; }
+
+        public string AssemblyUnificationPolicy { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IWinMDExpTaskContract
+    {
+        #region Properties
+
+        ITaskItem[] References { get; set; }
+        string DisabledWarnings { get; set; }
+        string InputDocumentationFile { get; set; }
+        string OutputDocumentationFile { get; set; }
+        string InputPDBFile { get; set; }
+        string OutputPDBFile { get; set; }
+        string WinMDModule { get; set; }
+        string OutputWindowsMetadataFile { get; set; }
+        string SdkToolsPath { get; set; }
+        bool UTF8Output { get; set; }
+        bool TreatWarningsAsErrors { get; set; }
+        string AssemblyUnificationPolicy { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Utilities/CompatibilitySuppressions.xml b/src/Utilities/CompatibilitySuppressions.xml
index bb15e1e6c3e..2545a39b99a 100644
--- a/src/Utilities/CompatibilitySuppressions.xml
+++ b/src/Utilities/CompatibilitySuppressions.xml
@@ -1,14 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- We don't have the net7 reference assemblies handy to pass in to compare against the net8 ones -->
-  <Suppression>
-    <DiagnosticId>CP1002</DiagnosticId>
-    <Target>System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Target>
-    <Left>ref/net7.0/Microsoft.Build.Utilities.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Utilities.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
        This is intentional, because you can only use MSBuild in the context of a .NET SDK
        (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
@@ -62,9 +54,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-<!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net7.0</Target>
-  </Suppression>
 </Suppressions>
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index b9296ffc4e4..5b9a22eba36 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -32,7 +32,6 @@
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
-    <PackageReference Include="System.Security.Permissions" />
     <PackageReference Include="System.Text.Encoding.CodePages" />
   </ItemGroup>
   
diff --git a/src/Utilities/Resources/xlf/Strings.cs.xlf b/src/Utilities/Resources/xlf/Strings.cs.xlf
index 40ec557b1b3..472924ca574 100644
--- a/src/Utilities/Resources/xlf/Strings.cs.xlf
+++ b/src/Utilities/Resources/xlf/Strings.cs.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated">Zadan asov limit ukonen ({0}) je neplatn  oekv se hodnota vt nebo rovna -1.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/Resources/xlf/Strings.fr.xlf b/src/Utilities/Resources/xlf/Strings.fr.xlf
index eda5b70eadc..b5081267c27 100644
--- a/src/Utilities/Resources/xlf/Strings.fr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.fr.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated">Le dlai darrt spcifi ({0}) nest pas valide . La valeur attendue est suprieure ou gale  -1.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/Resources/xlf/Strings.ja.xlf b/src/Utilities/Resources/xlf/Strings.ja.xlf
index cbdd70df0f9..82696e9d9f3 100644
--- a/src/Utilities/Resources/xlf/Strings.ja.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ja.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated"> ({0}) -1 </target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/Resources/xlf/Strings.ko.xlf b/src/Utilities/Resources/xlf/Strings.ko.xlf
index dd22c108316..2de87f94e2b 100644
--- a/src/Utilities/Resources/xlf/Strings.ko.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ko.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated">   ({0}) . -1    .</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/Resources/xlf/Strings.pl.xlf b/src/Utilities/Resources/xlf/Strings.pl.xlf
index 75c6c2b9bf9..0be09edd704 100644
--- a/src/Utilities/Resources/xlf/Strings.pl.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pl.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated">Okrelony limit czasu zakoczenia ({0}) jest nieprawidowy  oczekiwano wartoci wikszej lub rwnej -1.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/Resources/xlf/Strings.tr.xlf b/src/Utilities/Resources/xlf/Strings.tr.xlf
index 434da205f02..a2d9744fdbc 100644
--- a/src/Utilities/Resources/xlf/Strings.tr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.tr.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated">Belirtilen sonlandrma zaman am ({0}) geersiz; -1'den byk veya buna eit bir deer bekleniyor.</target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
index d417911a7fa..347b5ed842b 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
@@ -59,7 +59,7 @@
       </trans-unit>
       <trans-unit id="ToolTask.InvalidTerminationTimeout">
         <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
-        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <target state="translated"> ({0})  -  -1 </target>
         <note />
       </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
