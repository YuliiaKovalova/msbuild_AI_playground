diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 9aff19e9e15..9d90c75075e 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -43,27 +43,6 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Introduce [MSBuild]::StableStringHash overloads](https://github.com/dotnet/msbuild/issues/9519)
 - [Keep the encoding of standard output & error consistent with the console code page for ToolTask](https://github.com/dotnet/msbuild/pull/9539)
 
-### 17.8
-- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
-- [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
-- [Moving from SHA1 to SHA256 for Hash task](https://github.com/dotnet/msbuild/pull/8812)
-- [Deprecating custom derived BuildEventArgs](https://github.com/dotnet/msbuild/pull/8917) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
-
-### 17.6
-- [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
-- [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
-- [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
-- [Log assembly loads](https://github.com/dotnet/msbuild/pull/8316)
-- [AnyHaveMetadataValue returns false when passed an empty list](https://github.com/dotnet/msbuild/pull/8603)
-- [Log item self-expansion](https://github.com/dotnet/msbuild/pull/8581)
-
-### 17.4
-- [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
-- [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
-- [Adding accepted SDK name match pattern to SDK manifests](https://github.com/dotnet/msbuild/pull/7597)
-- [Throw warning indicating invalid project types](https://github.com/dotnet/msbuild/pull/7708)
-- [MSBuild server](https://github.com/dotnet/msbuild/pull/7634)
-
 ## Change Waves No Longer In Rotation
 ### 16.8
 - [Enable NoWarn](https://github.com/dotnet/msbuild/pull/5671)
@@ -89,3 +68,27 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
 - [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
 - [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
+
+### 17.4
+
+- [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
+- [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
+- [Adding accepted SDK name match pattern to SDK manifests](https://github.com/dotnet/msbuild/pull/7597)
+- [Throw warning indicating invalid project types](https://github.com/dotnet/msbuild/pull/7708)
+- [MSBuild server](https://github.com/dotnet/msbuild/pull/7634)
+
+### 17.6
+
+- [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
+- [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
+- [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
+- [Log assembly loads](https://github.com/dotnet/msbuild/pull/8316)
+- [AnyHaveMetadataValue returns false when passed an empty list](https://github.com/dotnet/msbuild/pull/8603)
+- [Log item self-expansion](https://github.com/dotnet/msbuild/pull/8581)
+
+### 17.8
+
+- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
+- [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
+- [Moving from SHA1 to SHA256 for Hash task](https://github.com/dotnet/msbuild/pull/8812)
+- [Deprecating custom derived BuildEventArgs](https://github.com/dotnet/msbuild/pull/8917) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 6522e66bbef..271bbd11e8e 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -1850,35 +1850,6 @@ public void ReloadCanOverwriteUnsavedChanges()
             AssertReload(SimpleProject, ComplexProject, true, true, true, act);
         }
 
-        [Fact]
-        public void ReloadDoesNotLeakCachedXmlDocuments()
-        {
-            using var env = TestEnvironment.Create();
-            ChangeWaves.ResetStateForTests();
-            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-            var testFiles = env.CreateTestProjectWithFiles("", new[] { "build.proj" });
-            var projectFile = testFiles.CreatedFiles.First();
-
-            var projectElement = ObjectModelHelpers.CreateInMemoryProjectRootElement(SimpleProject);
-            projectElement.Save(projectFile);
-
-            int originalDocumentCount = GetNumberOfDocumentsInProjectStringCache(projectElement);
-
-            // Test successful reload.
-            projectElement.Reload(false);
-            GetNumberOfDocumentsInProjectStringCache(projectElement).ShouldBe(originalDocumentCount);
-
-            // Test failed reload.
-            using (StreamWriter sw = new StreamWriter(projectFile))
-            {
-                sw.WriteLine("<XXX />"); // Invalid root element
-            }
-            Should.Throw<InvalidProjectFileException>(() => projectElement.Reload(false));
-            GetNumberOfDocumentsInProjectStringCache(projectElement).ShouldBe(originalDocumentCount);
-        }
-
         private void AssertReload(
             string initialContents,
             string changedContents,
@@ -2015,17 +1986,5 @@ private void VerifyAssertLineByLine(string expected, string actual)
         {
             Helpers.VerifyAssertLineByLine(expected, actual, false);
         }
-
-        /// <summary>
-        /// Returns the number of documents retained by the project string cache.
-        /// Peeks at it via reflection since internals are not visible to these tests.
-        /// </summary>
-        private int GetNumberOfDocumentsInProjectStringCache(ProjectRootElement project)
-        {
-            var bindingFlags = BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.GetProperty;
-            object document = typeof(ProjectRootElement).InvokeMember("XmlDocument", bindingFlags, null, project, Array.Empty<object>());
-            object cache = document.GetType().InvokeMember("StringCache", bindingFlags, null, document, Array.Empty<object>());
-            return (int)cache.GetType().InvokeMember("DocumentCount", bindingFlags, null, cache, Array.Empty<object>());
-        }
     }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
index cdbf64f9774..2cb88649b35 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
@@ -340,19 +340,12 @@ public void SetReturns()
         /// <summary>
         /// Parse invalid property under target
         /// </summary>
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void ReadInvalidPropertyUnderTarget(bool enableNewBehavior)
+        [Fact]
+        public void ReadInvalidPropertyUnderTarget()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
                 ChangeWaves.ResetStateForTests();
-                if (!enableNewBehavior)
-                {
-                    env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-                }
 
                 string projectFile = @"
                     <Project>
@@ -369,14 +362,7 @@ public void ReadInvalidPropertyUnderTarget(bool enableNewBehavior)
 
                 error.ErrorCode.ShouldMatch("MSB4067");
                 var expectedString = "<PropertyGroup>";
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
-                {
-                    error.Message.ShouldMatch(expectedString);
-                }
-                else
-                {
-                    error.Message.ShouldNotMatch(expectedString);
-                }
+                error.Message.ShouldMatch(expectedString);
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index f5887f5a46b..62e842a2558 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -150,29 +150,6 @@ public void AssertFirstResolverCanResolve()
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
         }
 
-        [Fact]
-        // Scenario: MockSdkResolver1 has higher priority than MockSdkResolverWithResolvableSdkPattern1 and resolves sdk.
-        public void AssertFirstResolverWithPatternCantResolveChangeWave17_4()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_4.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
-
-                SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
-
-                var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
-
-                result.Path.ShouldBe("resolverpath1");
-                _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
-                _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
-                ChangeWaves.ResetStateForTests();
-            }
-        }
-
         [Fact]
         // Scenario: MockSdkResolver1 has higher priority than MockSdkResolverWithResolvableSdkPattern1 but MockSdkResolverWithResolvableSdkPattern1 resolves sdk,
         // becuase MockSdkResolver1 is general and MockSdkResolverWithResolvableSdkPattern1 is specific.
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 5c82a444f39..ebb24ca82e6 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -61,31 +61,11 @@ public void TaskNodesDieAfterBuild()
             }
         }
 
-        [DotNetOnlyTheory]
-        [InlineData(false)]
-        // [InlineData(true)] <-- explicitly opting out on core will lead to node crash
-        public void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost_NetCore(
-            bool testLegacyImplementation)
-            => VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(testLegacyImplementation);
-
-        [WindowsFullFrameworkOnlyTheory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost_Framework(
-            bool testLegacyImplementation)
-            => VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(testLegacyImplementation);
-
-        private void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(bool testLegacyImplementation)
+        [Fact]
+        private void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost()
         {
             using TestEnvironment env = TestEnvironment.Create(_output);
 
-            ChangeWaves.ResetStateForTests();
-            if (testLegacyImplementation)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             string boolParam = "True";
             string boolArrayParam = "False;True;False";
             string byteParam = "42";
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index f137cf89960..b29a857dc69 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -40,8 +40,6 @@ public class Expander_Tests
         private string _dateToParse = new DateTime(2010, 12, 25).ToString(CultureInfo.CurrentCulture);
         private static readonly string s_rootPathPrefix = NativeMethodsShared.IsWindows ? "C:\\" : Path.VolumeSeparatorChar.ToString();
 
-        private static bool IsIntrinsicFunctionOverloadsEnabled => ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8);
-
         [Fact]
         public void ExpandAllIntoTaskItems0()
         {
@@ -4577,7 +4575,7 @@ public void PropertyFunctionMSBuildAddRealLiteral()
         public void PropertyFunctionMSBuildAddIntegerOverflow()
         {
             // Overflow wrapping - result exceeds size of long
-            string expected = IsIntrinsicFunctionOverloadsEnabled ? "-9223372036854775808" : (long.MaxValue + 1.0).ToString();
+            string expected = "-9223372036854775808";
             TestPropertyFunction("$([MSBuild]::Add($(X), 1))", "X", long.MaxValue.ToString(), expected);
         }
 
@@ -4612,7 +4610,7 @@ public void PropertyFunctionMSBuildSubtractRealLiteral()
         public void PropertyFunctionMSBuildSubtractIntegerMaxValue()
         {
             // If the double overload is used, there will be a rounding error.
-            string expected = IsIntrinsicFunctionOverloadsEnabled ? "1" : "0";
+            string expected = "1";
             TestPropertyFunction("$([MSBuild]::Subtract($(X), 9223372036854775806))", "X", long.MaxValue.ToString(), expected);
         }
 
@@ -4632,7 +4630,7 @@ public void PropertyFunctionMSBuildMultiplyRealLiteral()
         public void PropertyFunctionMSBuildMultiplyIntegerOverflow()
         {
             // Overflow - result exceeds size of long
-            string expected = IsIntrinsicFunctionOverloadsEnabled ? "-2" : (long.MaxValue * 2.0).ToString();
+            string expected = "-2";
             TestPropertyFunction("$([MSBuild]::Multiply($(X), 2))", "X", long.MaxValue.ToString(), expected);
         }
 
@@ -4645,7 +4643,7 @@ public void PropertyFunctionMSBuildMultiplyComplex()
         [Fact]
         public void PropertyFunctionMSBuildDivideIntegerLiteral()
         {
-            string expected = IsIntrinsicFunctionOverloadsEnabled ? "6" : "6.5536";
+            string expected = "6";
             TestPropertyFunction("$([MSBuild]::Divide($(X), 10000))", "X", "65536", expected);
         }
 
diff --git a/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs b/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
index 9ca64ef3923..099e1404c2c 100644
--- a/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
@@ -18,12 +18,8 @@ namespace Microsoft.Build.Engine.UnitTests.Evaluation
 {
     public class IntrinsicFunctionOverload_Tests
     {
-        private Version ChangeWaveForOverloading = ChangeWaves.Wave17_8;
-
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildAddInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildAddInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -32,16 +28,11 @@ public void MSBuildAddInteger(bool isIntrinsicFunctionOverloadsEnabled)
                         </PropertyGroup>
                     </Project>";
 
-            string expected = isIntrinsicFunctionOverloadsEnabled ? unchecked(long.MaxValue + 1).ToString() : (long.MaxValue + 1.0).ToString();
+            string expected = unchecked(long.MaxValue + 1).ToString();
 
             using TestEnvironment env = TestEnvironment.Create();
 
             ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
 
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
@@ -115,10 +106,8 @@ public void MSBuildAddReal()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildSubtractInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildSubtractInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -127,17 +116,10 @@ public void MSBuildSubtractInteger(bool isIntrinsicFunctionOverloadsEnabled)
                         </PropertyGroup>
                     </Project>";
 
-            string expected = isIntrinsicFunctionOverloadsEnabled ? 1.ToString() : 0.ToString();
+            string expected = 1.ToString();
 
             using TestEnvironment env = TestEnvironment.Create();
 
-            ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
             ProjectProperty? actualProperty = project.GetProperty("Actual");
@@ -210,10 +192,8 @@ public void MSBuildSubtractReal()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildMultiplyInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildMultiplyInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -222,17 +202,10 @@ public void MSBuildMultiplyInteger(bool isIntrinsicFunctionOverloadsEnabled)
                         </PropertyGroup>
                     </Project>";
 
-            string expected = isIntrinsicFunctionOverloadsEnabled ? unchecked(long.MaxValue * 2).ToString() : (long.MaxValue * 2.0).ToString();
+            string expected = unchecked(long.MaxValue * 2).ToString();
 
             using TestEnvironment env = TestEnvironment.Create();
 
-            ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
             ProjectProperty? actualProperty = project.GetProperty("Actual");
@@ -305,10 +278,8 @@ public void MSBuildMultiplyReal()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildDivideInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildDivideInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -317,17 +288,10 @@ public void MSBuildDivideInteger(bool isIntrinsicFunctionOverloadsEnabled)
                         </PropertyGroup>
                     </Project>";
 
-            string expected = isIntrinsicFunctionOverloadsEnabled ? (10 / 3).ToString() : (10.0 / 3.0).ToString();
+            string expected = (10 / 3).ToString();
 
             using TestEnvironment env = TestEnvironment.Create();
 
-            ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
             ProjectProperty? actualProperty = project.GetProperty("Actual");
@@ -400,10 +364,8 @@ public void MSBuildDivideReal()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildModuloInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildModuloInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -416,13 +378,6 @@ public void MSBuildModuloInteger(bool isIntrinsicFunctionOverloadsEnabled)
 
             using TestEnvironment env = TestEnvironment.Create();
 
-            ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
             ProjectProperty? actualProperty = project.GetProperty("Actual");
diff --git a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
deleted file mode 100644
index 923fe822ce4..00000000000
--- a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
+++ /dev/null
@@ -1,501 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.IO;
-using System.Text;
-using System.Xml;
-using Microsoft.Build.Construction;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Xunit;
-
-#nullable disable
-
-namespace Microsoft.Build.UnitTests.OM.Evaluation
-{
-    /// <summary>
-    /// Tests for ProjectStringCache
-    /// </summary>
-    public class ProjectStringCache_Tests
-    {
-        /// <summary>
-        /// Test that loading two instances of the same xml file uses the same strings
-        /// to store read values.
-        /// </summary>
-        [Fact]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void ContentIsSameAcrossInstances()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                string content = ObjectModelHelpers.CleanupFileContents(@"
-                    <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
-                        <ItemGroup>
-                           Item group content
-                        </ItemGroup>
-                    </Project>
-                    ");
-
-                string path = FileUtilities.GetTemporaryFileName();
-
-                try
-                {
-                    File.WriteAllText(path, content);
-
-                    ProjectStringCache cache = new ProjectStringCache();
-                    XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
-                    document1.StringCache = cache;
-                    document1.Load(path);
-
-                    XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
-                    document2.StringCache = cache;
-                    document2.Load(path);
-
-                    XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
-                    XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
-
-                    Assert.Equal(1, nodes1.Count);
-                    Assert.Equal(1, nodes2.Count);
-
-                    XmlNode node1 = nodes1[0].FirstChild;
-                    XmlNode node2 = nodes2[0].FirstChild;
-
-                    Assert.NotNull(node1);
-                    Assert.NotNull(node2);
-                    Assert.NotSame(node1, node2);
-                    Assert.Same(node1.Value, node2.Value);
-                }
-                finally
-                {
-                    File.Delete(path);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Test that modifying one instance of a file does not affect the other file.
-        /// </summary>
-        [Fact]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void ContentCanBeModified()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                string content = ObjectModelHelpers.CleanupFileContents(@"
-                    <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
-                        <ItemGroup attr1='attr1value'>
-                           Item group content
-                        </ItemGroup>
-                    </Project>
-                    ");
-
-                string path = FileUtilities.GetTemporaryFileName();
-
-                try
-                {
-                    File.WriteAllText(path, content);
-                    ProjectStringCache cache = new ProjectStringCache();
-                    XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
-                    document1.StringCache = cache;
-                    document1.Load(path);
-
-                    XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
-                    document2.StringCache = cache;
-                    document2.Load(path);
-
-                    string outerXml1 = document1.OuterXml;
-                    string outerXml2 = document2.OuterXml;
-                    Assert.Equal(outerXml1, outerXml2);
-
-                    XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
-                    XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
-
-                    Assert.Equal(1, nodes1.Count);
-                    Assert.Equal(1, nodes2.Count);
-
-                    XmlNode node1 = nodes1[0];
-                    XmlNode node2 = nodes2[0];
-                    Assert.NotNull(node1);
-                    Assert.NotNull(node2);
-                    Assert.NotSame(node1, node2);
-                    Assert.Single(node1.Attributes);
-                    Assert.Single(node2.Attributes);
-                    Assert.Same(node1.Attributes[0].Value, node2.Attributes[0].Value);
-
-                    node2.Attributes[0].Value = "attr1value";
-                    Assert.Equal(node1.Attributes[0].Value, node2.Attributes[0].Value);
-                    Assert.NotSame(node1.Attributes[0].Value, node2.Attributes[0].Value);
-
-                    node1 = nodes1[0].FirstChild;
-                    node2 = nodes2[0].FirstChild;
-                    Assert.NotSame(node1, node2);
-                    Assert.Same(node1.Value, node2.Value);
-
-                    XmlText newText = document2.CreateTextNode("New Value");
-                    XmlNode parent = node2.ParentNode;
-                    parent.ReplaceChild(newText, node2);
-
-                    Assert.NotEqual(outerXml1, document2.OuterXml);
-                }
-                finally
-                {
-                    File.Delete(path);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Test that unloading a project file makes its string entries disappear from
-        /// the string cache.
-        /// </summary>
-        [Fact]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void RemovingFilesRemovesEntries()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                string content = ObjectModelHelpers.CleanupFileContents(@"
-                    <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
-                        <ItemGroup>Content</ItemGroup>
-                    </Project>
-                    ");
-
-                string path = FileUtilities.GetTemporaryFileName();
-
-                try
-                {
-                    File.WriteAllText(path, content);
-
-                    ProjectStringCache cache = new ProjectStringCache();
-                    using ProjectCollection collection = new ProjectCollection();
-                    int entryCount;
-
-                    ProjectRootElement pre1 = ProjectRootElement.Create(collection);
-                    pre1.XmlDocument.StringCache = cache;
-                    pre1.FullPath = path;
-                    pre1.XmlDocument.Load(path);
-
-                    entryCount = cache.Count;
-                    Assert.True(entryCount > 0);
-
-                    ProjectRootElement pre2 = ProjectRootElement.Create(collection);
-                    pre2.XmlDocument.StringCache = cache;
-                    pre2.FullPath = path;
-                    pre2.XmlDocument.Load(path);
-
-                    // Entry count should not have changed
-                    Assert.Equal(entryCount, cache.Count);
-
-                    string itemGroupContent = cache.Get("Content");
-                    Assert.NotNull(itemGroupContent);
-
-                    XmlNodeList nodes1 = pre1.XmlDocument.GetElementsByTagName("ItemGroup");
-                    XmlNodeList nodes2 = pre2.XmlDocument.GetElementsByTagName("ItemGroup");
-
-                    Assert.Equal(1, nodes1.Count);
-                    Assert.Equal(1, nodes2.Count);
-
-                    XmlNode node1 = nodes1[0];
-                    XmlNode node2 = nodes2[0];
-                    Assert.NotNull(node1);
-                    Assert.NotNull(node2);
-                    Assert.NotSame(node1, node2);
-                    Assert.Same(node1.Value, node2.Value);
-
-                    // Now remove one document
-                    collection.UnloadProject(pre1);
-
-                    // We should still be able to get Content
-                    itemGroupContent = cache.Get("Content");
-                    Assert.NotNull(itemGroupContent);
-
-                    // Now remove the second document
-                    collection.UnloadProject(pre2);
-
-                    // Now we should not be able to get Content
-                    itemGroupContent = cache.Get("Content");
-                    Assert.Null(itemGroupContent);
-
-                    // And there should be no entries
-                    Assert.Equal(0, cache.Count);
-                }
-                finally
-                {
-                    File.Delete(path);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Adding a string equivalent to an existing instance and under the same document should
-        /// return the existing instance.
-        /// </summary>
-        [Fact]
-        public void AddReturnsSameInstanceForSameDocument()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                string return1 = cache.Add(stringToAdd, document);
-
-                // Content of string should be the same.
-                Assert.Equal(1, cache.Count);
-                Assert.Equal(stringToAdd, return1);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('1');
-
-                string return2 = cache.Add(builder.ToString(), document);
-
-                // Content of string should be the same.
-                Assert.Equal(builder.ToString(), return2);
-
-                // Returned references should be the same
-                Assert.Same(return1, return2);
-
-                // Should not have added any new string instances to the cache.
-                Assert.Equal(1, cache.Count);
-            }
-        }
-
-        /// <summary>
-        /// Adding a string equivalent to an existing instance but under a different document
-        /// should return the existing instance.
-        /// </summary>
-        [Fact]
-        public void AddReturnsSameInstanceForDifferentDocument()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                string return1 = cache.Add(stringToAdd, document);
-
-                // Content of string should be the same.
-                Assert.Equal(stringToAdd, return1);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('1');
-                XmlDocument document2 = new XmlDocument();
-
-                string return2 = cache.Add(builder.ToString(), document2);
-
-                // Content of string should be the same.
-                Assert.Equal(builder.ToString(), return2);
-
-                // Returned references should be the same
-                Assert.Same(return1, return2);
-
-                // Should not have added any new string instances to the cache.
-                Assert.Equal(1, cache.Count);
-            }
-        }
-
-        /// <summary>
-        /// Removing the last document containing an instance of a string should remove the string entry.
-        /// A subsequent add should then return a different instance.
-        /// </summary>
-        /// <remarks>
-        /// WHITEBOX ASSUMPTION:
-        /// The following method assumes knowledge of the ProjectStringCache internal implementation
-        /// details, and may become invalid if those details change.
-        /// </remarks>
-        [Fact]
-        public void RemoveLastInstanceDeallocatesEntry()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                string return1 = cache.Add(stringToAdd, document);
-
-                cache.Clear(document);
-
-                // Should be no instances left.
-                Assert.Equal(0, cache.Count);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('1');
-                XmlDocument document2 = new XmlDocument();
-
-                string return2 = cache.Add(builder.ToString(), document2);
-
-                // Returned references should NOT be the same
-                Assert.NotSame(return1, return2);
-            }
-        }
-
-        /// <summary>
-        /// Removing one document containing a string which already existed in the collection
-        /// should still leave a reference in the collection, so that a subsequent add will
-        /// return the existing reference.
-        /// </summary>
-        [Fact]
-        public void RemoveOneInstance()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                string return1 = cache.Add(stringToAdd, document);
-                Assert.Equal(1, cache.Count);
-
-                XmlDocument document2 = new XmlDocument();
-                cache.Add(stringToAdd, document2);
-                Assert.Equal(1, cache.Count);
-
-                cache.Clear(document2);
-
-                // Since there is still one document referencing the string, it should remain.
-                Assert.Equal(1, cache.Count);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('1');
-                XmlDocument document3 = new XmlDocument();
-
-                string return3 = cache.Add(builder.ToString(), document3);
-
-                // Returned references should be the same
-                Assert.Same(return1, return3);
-
-                // Still should only be one cached instance.
-                Assert.Equal(1, cache.Count);
-            }
-        }
-
-        /// <summary>
-        /// Different strings should get their own entries.
-        /// </summary>
-        [Fact]
-        public void DifferentStringsSameDocument()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                cache.Add(stringToAdd, document);
-                Assert.Equal(1, cache.Count);
-
-                stringToAdd = "Test2";
-                string return2 = cache.Add(stringToAdd, document);
-
-                // The second string gets its own instance.
-                Assert.Equal(2, cache.Count);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('2');
-                string return3 = cache.Add(builder.ToString(), document);
-
-                // The new string should be the same as the other one already in the collection.
-                Assert.Same(return2, return3);
-
-                // No new instances for string with the same content.
-                Assert.Equal(2, cache.Count);
-            }
-        }
-
-        /// <summary>
-        /// Different strings should get their own entries.
-        /// </summary>
-        [Fact]
-        public void DifferentStringsDifferentDocuments()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                cache.Add(stringToAdd, document);
-                Assert.Equal(1, cache.Count);
-
-                stringToAdd = "Test2";
-                XmlDocument document2 = new XmlDocument();
-                string return2 = cache.Add(stringToAdd, document2);
-
-                // The second string gets its own instance.
-                Assert.Equal(2, cache.Count);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('2');
-                XmlDocument document3 = new XmlDocument();
-                string return3 = cache.Add(builder.ToString(), document3);
-
-                // The new string should be the same as the other one already in the collection.
-                Assert.Same(return2, return3);
-
-                // No new instances for string with the same content.
-                Assert.Equal(2, cache.Count);
-            }
-        }
-    }
-}
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index d00b7d90a1d..a3d5e1d18c7 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -968,7 +968,6 @@ public void PacketReceived(int node, INodePacket packet)
         private void WarnOnDeprecatedCustomArgsSerialization(LogMessagePacket loggingPacket)
         {
             if (loggingPacket.EventType == LoggingEventType.CustomEvent
-                && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8)
                 && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
             {
                 BuildEventArgs buildEvent = loggingPacket.NodeBuildEvent.Value.Value;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
index 8835f4278ca..5fd70efcc79 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
@@ -66,7 +66,7 @@ public static IDisposable StartTracking(
 #if FEATURE_APPDOMAIN
         public static void StopTracking(AppDomain appDomain)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && !appDomain.IsDefaultAppDomain())
+            if (!appDomain.IsDefaultAppDomain())
             {
                 lock (s_instances)
                 {
@@ -106,20 +106,15 @@ private static IDisposable StartTracking(
             string? initiatorName,
             AppDomain? appDomain)
         {
-            if (
-                // Feature is not enabled
-                !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) ||
+            if (// We do not want to load all assembly loads (including those triggered by builtin types)
+                !Traits.Instance.LogAllAssemblyLoads &&
                 (
-                    // We do not want to load all assembly loads (including those triggered by builtin types)
-                    !Traits.Instance.LogAllAssemblyLoads &&
-                    (
-                        // Load will be initiated by internal type - so we are not interested in those
-                        initiatorType?.Assembly == Assembly.GetExecutingAssembly()
-                        ||
-                        IsBuiltinType(initiatorType?.FullName)
-                        ||
-                        IsBuiltinType(initiatorName)
-                    )
+                    // Load will be initiated by internal type - so we are not interested in those
+                    initiatorType?.Assembly == Assembly.GetExecutingAssembly()
+                    ||
+                    IsBuiltinType(initiatorType?.FullName)
+                    ||
+                    IsBuiltinType(initiatorName)
                 )
             )
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index e5d09b99d8a..2a9cc0e26b0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -182,8 +182,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 if (condition)
                 {
                     ExpanderOptions expanderOptions = ExpanderOptions.ExpandAll;
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) &&
-                        // If multiple buckets were expanded - we do not want to repeat same error for same metadatum on a same line
+                    if (// If multiple buckets were expanded - we do not want to repeat same error for same metadatum on a same line
                         bucket.BucketSequenceNumber == 0 &&
                         // Referring to unqualified metadata of other item (transform) is fine.
                         child.Include.IndexOf("@(", StringComparison.Ordinal) == -1)
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index a7f54890bbd..9de6967036e 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -119,22 +119,11 @@ internal virtual IReadOnlyList<SdkResolverManifest> FindPotentialSdkResolversMan
                 var assembly = Path.Combine(subfolder.FullName, $"{subfolder.Name}.dll");
                 bool assemblyAdded = false;
 
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-                {
-                    // Prefer manifest over the assembly. Try to read the xml first, and if not found then look for an assembly.
-                    assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
-                    if (!assemblyAdded)
-                    {
-                        assemblyAdded = TryAddAssemblyManifestFromDll(assembly, manifestsList);
-                    }
-                }
-                else
+                // Prefer manifest over the assembly. Try to read the xml first, and if not found then look for an assembly.
+                assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
+                if (!assemblyAdded)
                 {
                     assemblyAdded = TryAddAssemblyManifestFromDll(assembly, manifestsList);
-                    if (!assemblyAdded)
-                    {
-                        assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
-                    }
                 }
 
                 if (!assemblyAdded)
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 5b0265c8ae2..252bf62ab14 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -40,14 +40,6 @@ internal class SdkResolverService : ISdkResolverService
         /// </summary>
         private readonly ConcurrentDictionary<int, ConcurrentDictionary<SdkResolver, object>> _resolverStateBySubmission = new ConcurrentDictionary<int, ConcurrentDictionary<SdkResolver, object>>();
 
-        /// <summary>
-        /// Stores the list of SDK resolvers which were loaded.
-        /// </summary>
-        /// <remarks>
-        /// Need it for supporting the ChangeWave less than <see cref="ChangeWaves.Wave17_4"/>. Remove when move out Wave17_4.
-        /// </remarks>
-        private IReadOnlyList<SdkResolver> _resolversList;
-
         /// <summary>
         /// Stores the loaded SDK resolvers, mapped to the manifest from which they came.
         /// </summary>
@@ -118,7 +110,7 @@ public virtual void ClearCaches()
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
-            // If we are running in .NET core, we ask the built-in default resolver first.
+                        // If we are running in .NET core, we ask the built-in default resolver first.
             // - It is a perf optimization (no need to discover and load any of the plug-in assemblies to resolve an "in-box" Sdk).
             // - It brings `dotnet build` to parity with `MSBuild.exe` functionally, as the Framework build of Microsoft.DotNet.MSBuildSdkResolver
             //   contains the same logic and it is the first resolver in priority order.
@@ -165,27 +157,8 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
                 }
             }
 #endif
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-            {
-                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
-            }
-            else
-            {
-                SdkResult result = ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, out IEnumerable<string> errors, out IEnumerable<string> warnings);
-
-                // Warnings are already logged on success.
-                if (!result.Success)
-                {
-                    if (failOnUnresolvedSdk)
-                    {
-                        loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "FailedToResolveSDK", sdk.Name, string.Join($"{Environment.NewLine}  ", errors));
-                    }
-
-                    LogWarnings(loggingContext, sdkReferenceLocation, warnings);
-                }
 
-                return result;
-            }
+            return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
         }
 
         /// <remarks>
@@ -311,31 +284,6 @@ private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManif
             return resolvers;
         }
 
-        private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, out IEnumerable<string> errors, out IEnumerable<string> warnings)
-        {
-            // Lazy initialize all SDK resolvers
-            if (_resolversList == null)
-            {
-                Initialize(sdkReferenceLocation);
-            }
-
-            TryResolveSdkUsingSpecifiedResolvers(
-                _resolversList,
-                submissionId,
-                sdk,
-                loggingContext,
-                sdkReferenceLocation,
-                solutionPath,
-                projectPath,
-                interactive,
-                isRunningInVisualStudio,
-                out SdkResult sdkResult,
-                out errors,
-                out warnings);
-
-            return sdkResult;
-        }
-
         private bool TryResolveSdkUsingSpecifiedResolvers(
             IReadOnlyList<SdkResolver> resolvers,
             int submissionId,
@@ -458,24 +406,16 @@ internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IReadO
             _specificResolversManifestsRegistry = null;
             _generalResolversManifestsRegistry = null;
             _manifestToResolvers = null;
-            _resolversList = null;
 
             if (resolvers != null)
             {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-                {
-                    _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
-                    _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
-                    _manifestToResolvers = new Dictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>>();
+                _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
+                _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
+                _manifestToResolvers = new Dictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>>();
 
-                    SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(DisplayName: "TestResolversManifest", Path: null, ResolvableSdkRegex: null);
-                    _generalResolversManifestsRegistry.Add(sdkResolverManifest);
-                    _manifestToResolvers[sdkResolverManifest] = resolvers;
-                }
-                else
-                {
-                    _resolversList = resolvers;
-                }
+                SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(DisplayName: "TestResolversManifest", Path: null, ResolvableSdkRegex: null);
+                _generalResolversManifestsRegistry.Add(sdkResolverManifest);
+                _manifestToResolvers[sdkResolverManifest] = resolvers;
             }
         }
 
@@ -517,19 +457,6 @@ private object GetResolverState(int submissionId, SdkResolver resolver)
             return null;
         }
 
-        private void Initialize(ElementLocation location)
-        {
-            lock (_lockObject)
-            {
-                if (_resolversList != null)
-                {
-                    return;
-                }
-
-                _resolversList = _sdkResolverLoader.LoadAllResolvers(location);
-            }
-        }
-
         private void RegisterResolversManifests(ElementLocation location)
         {
             lock (_lockObject)
@@ -587,7 +514,7 @@ private void SetResolverState(int submissionId, SdkResolver resolver, object sta
                     submissionId,
                     _ => new ConcurrentDictionary<SdkResolver, object>(
                         NativeMethodsShared.GetLogicalCoreCount(),
-                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) ? _specificResolversManifestsRegistry.Count + _generalResolversManifestsRegistry.Count : _resolversList.Count));
+                        _specificResolversManifestsRegistry.Count + _generalResolversManifestsRegistry.Count));
 
                 resolverState.AddOrUpdate(resolver, state, (sdkResolver, obj) => state);
             }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index f0fd2ca4af5..af13beb079d 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -586,8 +586,6 @@ private void SendPacket(INodePacket packet)
 #if RUNTIME_TYPE_NETCORE
                 if (packet is LogMessagePacketBase logMessage
                     && logMessage.EventType == LoggingEventType.CustomEvent
-                    &&
-                    (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
                     && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
                 {
                     BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 5aa8ca900e9..1e1964748af 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -12,6 +12,14 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
+/// <summary>
+/// Central logger for the build check infrastructure.
+/// Receives events from the <see cref="BuildCheckForwardingLogger"/>.
+/// Processes the events and forwards them to the <see cref="IBuildCheckManager"/> and registered analyzers.
+/// </summary>
+/// <remarks>
+/// Ensure that the consuming events are in sync with <see cref="BuildCheckForwardingLogger"/>.
+/// </remarks>
 internal sealed class BuildCheckConnectorLogger : ILogger
 {
     private readonly BuildCheckBuildEventHandler _eventHandler;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
index 6e8f969b544..02808f434a5 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
@@ -7,13 +7,62 @@
 using System.Text;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck.Acquisition;
+using Microsoft.Build.Framework;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.BuildCheckManagerProvider;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// Forwarding logger for the build check infrastructure.
-/// For now we jus want to forward all events, while disable verbose logging of tasks.
+/// For now we just want to forward all events that are needed for BuildCheckConnectorLogger and filter out all other.
+/// If the custom analyzer is detected, starts to unconditionally forward all events.
 /// In the future we may need more specific behavior.
 /// </summary>
-internal class BuildCheckForwardingLogger : CentralForwardingLogger
-{ }
+/// <remarks>
+/// Ensure that events filtering is in sync with <see cref="BuildCheckConnectorLogger"/>
+/// </remarks>
+internal class BuildCheckForwardingLogger : IForwardingLogger
+{
+    public IEventRedirector? BuildEventRedirector { get; set; }
+
+    public int NodeId { get; set; }
+
+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Quiet; set { return; } }
+
+    public string? Parameters { get; set; }
+
+    /// <summary>
+    /// Set of events to be forwarded to  <see cref="BuildCheckConnectorLogger"/>
+    /// </summary>
+    private HashSet<Type> _eventsToForward = new HashSet<Type>
+    {
+        typeof(EnvironmentVariableReadEventArgs),
+        typeof(ProjectEvaluationFinishedEventArgs),
+        typeof(ProjectEvaluationStartedEventArgs),
+        typeof(ProjectStartedEventArgs),
+        typeof(ProjectFinishedEventArgs),
+        typeof(BuildCheckTracingEventArgs),
+        typeof(BuildCheckAcquisitionEventArgs),
+        typeof(TaskStartedEventArgs),
+        typeof(TaskFinishedEventArgs),
+        typeof(TaskParameterEventArgs)
+    };
+
+    public void Initialize(IEventSource eventSource, int nodeCount) => Initialize(eventSource);
+
+    public void Initialize(IEventSource eventSource)
+    {
+        eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+    }
+
+    public void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent)
+    {
+        if (_eventsToForward.Contains(buildEvent.GetType()))
+        {
+            BuildEventRedirector?.ForwardEvent(buildEvent);
+        }
+    }
+
+    public void Shutdown() { }
+}
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 92e920c3f80..2ab9a1a53d4 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -1691,31 +1691,13 @@ private void ReloadFrom(Func<bool, XmlDocumentWithLocation> documentProducer, bo
 
             var oldDocument = XmlDocument;
             XmlDocumentWithLocation newDocument = documentProducer(preserveFormatting ?? PreserveFormatting);
-            try
-            {
-                // Reload should only mutate the state if there are no parse errors.
-                ThrowIfDocumentHasParsingErrors(newDocument);
 
-                RemoveAllChildren();
+            // Reload should only mutate the state if there are no parse errors.
+            ThrowIfDocumentHasParsingErrors(newDocument);
 
-                ProjectParser.Parse(newDocument, this);
-            }
-            finally
-            {
-                // Whichever document didn't become this element's document must be removed from the string cache.
-                // We do it after the fact based on the assumption that Projects are reloaded repeatedly from their
-                // file with small increments, and thus most strings would get reused avoiding unnecessary churn in
-                // the string cache.
-                var currentDocument = XmlDocument;
-                if (!object.ReferenceEquals(currentDocument, oldDocument))
-                {
-                    oldDocument.ClearAnyCachedStrings();
-                }
-                if (!object.ReferenceEquals(currentDocument, newDocument))
-                {
-                    newDocument.ClearAnyCachedStrings();
-                }
-            }
+            RemoveAllChildren();
+
+            ProjectParser.Parse(newDocument, this);
 
             MarkDirty("Project reloaded", null);
         }
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index ef1fbe5bd37..d7d90b3a939 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -3571,7 +3571,6 @@ public override void Unload()
             {
                 Xml.OnAfterProjectRename -= _renameHandler;
                 Xml.OnProjectXmlChanged -= ProjectRootElement_ProjectXmlChangedHandler;
-                Xml.XmlDocument.ClearAnyCachedStrings();
                 _renameHandler = null;
             }
 
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 9429ec8ecf8..93e536f0aa8 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -1363,18 +1363,6 @@ public void UnloadProject(Project project)
                 // free memory. These may be the last references to the ProjectRootElements
                 // in the cache, so the cache shouldn't hold strong references to them of its own.
                 ProjectRootElementCache.DiscardStrongReferences();
-
-                // Aggressively release any strings from all the contributing documents.
-                // It's fine if we cache less (by now we likely did a lot of loading and got the benefits)
-                // If we don't do this, we could be releasing the last reference to a
-                // ProjectRootElement, causing it to fall out of the weak cache leaving its strings and XML
-                // behind in the string cache.
-                project.Xml.XmlDocument.ClearAnyCachedStrings();
-
-                foreach (var import in project.Imports)
-                {
-                    import.ImportedProject.XmlDocument.ClearAnyCachedStrings();
-                }
             }
         }
 
@@ -1405,7 +1393,6 @@ public void UnloadProject(ProjectRootElement projectRootElement)
                     ErrorUtilities.ThrowInvalidOperation("OM_ProjectXmlCannotBeUnloadedDueToLoadedProjects", projectRootElement.FullPath, conflictingProject.FullPath);
                 }
 
-                projectRootElement.XmlDocument.ClearAnyCachedStrings();
                 ProjectRootElementCache.DiscardAnyWeakReference(projectRootElement);
             }
         }
@@ -1556,7 +1543,6 @@ public bool TryUnloadProject(ProjectRootElement projectRootElement)
                 if (conflictingProject == null)
                 {
                     ProjectRootElementCache.DiscardAnyWeakReference(projectRootElement);
-                    projectRootElement.XmlDocument.ClearAnyCachedStrings();
                     return true;
                 }
 
@@ -2041,7 +2027,7 @@ public ReusableLogger(ILogger originalLogger)
             /// The telemetry sent event.
             /// </summary>
             public event TelemetryEventHandler TelemetryLogged;
-            
+
             /// <summary>
             /// Should evaluation events include generated metaprojects?
             /// </summary>
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index 71f51e9f272..cfa910da6a8 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+using Microsoft.NET.StringTools;
 
 #nullable disable
 
@@ -23,11 +24,6 @@ namespace Microsoft.Build.Construction
     /// </remarks>
     internal class XmlDocumentWithLocation : XmlDocument
     {
-        /// <summary>
-        /// Used to cache strings used in attribute values and comments.
-        /// </summary>
-        private static ProjectStringCache s_globalStringCache = new ProjectStringCache();
-
         /// <summary>
         /// Used to cache tag names in loaded files.
         /// </summary>
@@ -49,11 +45,6 @@ internal class XmlDocumentWithLocation : XmlDocument
         /// </summary>
         private string _fullPath;
 
-        /// <summary>
-        /// Local cache of strings for attribute values and comments. Used for testing.
-        /// </summary>
-        private ProjectStringCache _stringCache;
-
         /// <summary>
         /// Whether we can expect to never save this file.
         /// In such a case, we can discard as much as possible on load, like comments and whitespace.
@@ -124,19 +115,6 @@ internal string FullPath
             set { _fullPath = value; }
         }
 
-        /// <summary>
-        /// Sets or gets the string cache used by this XmlDocument.
-        /// </summary>
-        /// <remarks>
-        /// When a particular instance has not been set will use the global string cache. The ability
-        /// to use a particular instance is useful for tests.
-        /// </remarks>
-        internal ProjectStringCache StringCache
-        {
-            get { return _stringCache ?? s_globalStringCache; }
-            set { _stringCache = value; }
-        }
-
         /// <summary>
         /// Loads from an XmlReader, intercepting the reader.
         /// </summary>
@@ -262,7 +240,7 @@ public override XmlWhitespace CreateWhitespace(string text)
                 text = String.Empty;
             }
 
-            string interned = StringCache.Add(text, this);
+            string interned = Strings.WeakIntern(text);
             return base.CreateWhitespace(interned);
         }
 
@@ -278,7 +256,7 @@ public override XmlSignificantWhitespace CreateSignificantWhitespace(string text
                 text = String.Empty;
             }
 
-            string interned = StringCache.Add(text, this);
+            string interned = Strings.WeakIntern(text);
             return base.CreateSignificantWhitespace(interned);
         }
 
@@ -288,7 +266,7 @@ public override XmlSignificantWhitespace CreateSignificantWhitespace(string text
         /// </summary>
         public override XmlText CreateTextNode(string text)
         {
-            string textNode = StringCache.Add(text, this);
+            string textNode = Strings.WeakIntern(text);
             return base.CreateTextNode(textNode);
         }
 
@@ -303,7 +281,7 @@ public override XmlComment CreateComment(string data)
                 data = String.Empty;
             }
 
-            string interned = StringCache.Add(data, this);
+            string interned = Strings.WeakIntern(data);
             return base.CreateComment(interned);
         }
 
@@ -356,16 +334,6 @@ internal static void ClearReadOnlyFlags_UnitTestsOnly()
             s_readOnlyFlags = ReadOnlyLoadFlags.Undefined;
         }
 
-        /// <summary>
-        /// Called when the XmlDocument is unloaded to remove this XML's
-        /// contribution to the string interning cache.
-        /// Does NOT zombie the ProjectRootElement or anything else.
-        /// </summary>
-        internal void ClearAnyCachedStrings()
-        {
-            StringCache.Clear(this);
-        }
-
         /// <summary>
         /// Determine whether we should load this file read only.
         /// We decide yes if it is in program files or the OS directory, and the file name starts with "microsoft", else no.
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 3e67f786ac8..8e0f9318b89 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1593,7 +1593,7 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
                 if (!_fallbackSearchPathsCache.DirectoryExists(extensionPathExpanded))
                 {
                     // Set to log an error only if the change wave is enabled.
-                    missingDirectoryDespiteTrueCondition = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && !containsWildcards;
+                    missingDirectoryDespiteTrueCondition = !containsWildcards;
                     continue;
                 }
 
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 0395322c345..b298a3d7211 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -396,7 +396,7 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMeta
         /// This is for the purpose of evaluations through API calls, that might not be able to pass the logging context
         ///  - BuildCheck analysis won't be executed for those.
         /// (for one of the calls we can actually pass IDataConsumingContext - as we have logging service and project)
-        /// 
+        ///
         /// </summary>
         internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMetadataTable metadata, IFileSystem fileSystem)
             : this(properties, items, fileSystem, null)
@@ -1558,7 +1558,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                                    MSBuildNameIgnoreCaseComparer.Default.Equals("MSBuild", propertyName, startIndex, 7);
 
                 propertiesUseTracker.TrackRead(propertyName, startIndex, endIndex, elementLocation, property == null, isArtifical);
-                
+
                 if (isArtifical)
                 {
                     // It could be one of the MSBuildThisFileXXXX properties,
@@ -1654,9 +1654,8 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
             {
 #if RUNTIME_TYPE_NETCORE
                 // .NET Core MSBuild used to always return empty, so match that behavior
-                // on non-Windows (no registry), and with a changewave (in case someone
-                // had a registry property and it breaks when it lights up).
-                if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                // on non-Windows (no registry).
+                if (!NativeMethodsShared.IsWindows)
                 {
                     return string.Empty;
                 }
@@ -2017,8 +2016,7 @@ internal static bool ExpandExpressionCapture<S>(
                     if (expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "Count", StringComparison.OrdinalIgnoreCase)) != true)
                     {
                         // ...or a function "AnyHaveMetadataValue", since that will want to return false for an empty list.
-                        if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) ||
-                            expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "AnyHaveMetadataValue", StringComparison.OrdinalIgnoreCase)) != true)
+                        if (expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "AnyHaveMetadataValue", StringComparison.OrdinalIgnoreCase)) != true)
                         {
                             itemsFromCapture = new List<KeyValuePair<string, S>>();
                             return false;
@@ -4944,13 +4942,10 @@ private static bool TryExecuteArithmeticOverload(object[] args, Func<long, long,
                     return false;
                 }
 
-                if (IntrinsicFunctionOverload.IsIntrinsicFunctionOverloadsEnabled())
+                if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))
                 {
-                    if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))
-                    {
-                        resultValue = integerOperation(argLong0, argLong1);
-                        return true;
-                    }
+                    resultValue = integerOperation(argLong0, argLong1);
+                    return true;
                 }
 
                 if (TryConvertToDouble(args[0], out double argDouble0) && TryConvertToDouble(args[1], out double argDouble1))
@@ -5582,17 +5577,11 @@ internal static class IntrinsicFunctionOverload
         // For reuse, the comparer is cached in a non-generic type.
         // Both comparer instances can be cached to support change wave testing.
         private static IComparer<MemberInfo>? s_comparerLongBeforeDouble;
-        private static IComparer<MemberInfo>? s_comparerDoubleBeforeLong;
 
-        internal static IComparer<MemberInfo> IntrinsicFunctionOverloadMethodComparer => IsIntrinsicFunctionOverloadsEnabled() ? LongBeforeDoubleComparer : DoubleBeforeLongComparer;
+        internal static IComparer<MemberInfo> IntrinsicFunctionOverloadMethodComparer => LongBeforeDoubleComparer;
 
         private static IComparer<MemberInfo> LongBeforeDoubleComparer => s_comparerLongBeforeDouble ??= Comparer<MemberInfo>.Create((key0, key1) => SelectTypeOfFirstParameter(key0).CompareTo(SelectTypeOfFirstParameter(key1)));
 
-        private static IComparer<MemberInfo> DoubleBeforeLongComparer => s_comparerDoubleBeforeLong ??= Comparer<MemberInfo>.Create((key0, key1) => SelectTypeOfFirstParameter(key1).CompareTo(SelectTypeOfFirstParameter(key0)));
-
-        // The arithmetic overload feature uses this method to test for the change wave.
-        internal static bool IsIntrinsicFunctionOverloadsEnabled() => ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8);
-
         internal static bool IsKnownOverloadMethodName(string methodName) => s_knownOverloadName.Any(name => string.Equals(name, methodName, StringComparison.OrdinalIgnoreCase));
 
         private static TypeCode SelectTypeOfFirstParameter(MemberInfo member)
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 8027834af60..4d8fe9a56cb 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -191,9 +191,8 @@ internal static object GetRegistryValue(string keyName, string valueName)
         {
 #if RUNTIME_TYPE_NETCORE
             // .NET Core MSBuild used to always return empty, so match that behavior
-            // on non-Windows (no registry), and with a changewave (in case someone
-            // had a registry property and it breaks when it lights up).
-            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // on non-Windows (no registry).
+            if (!NativeMethodsShared.IsWindows)
             {
                 return null;
             }
@@ -208,9 +207,8 @@ internal static object GetRegistryValue(string keyName, string valueName, object
         {
 #if RUNTIME_TYPE_NETCORE
             // .NET Core MSBuild used to always return empty, so match that behavior
-            // on non-Windows (no registry), and with a changewave (in case someone
-            // had a registry property and it breaks when it lights up).
-            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // on non-Windows (no registry).
+            if (!NativeMethodsShared.IsWindows)
             {
                 return defaultValue;
             }
@@ -222,9 +220,8 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
         {
 #if RUNTIME_TYPE_NETCORE
             // .NET Core MSBuild used to always return empty, so match that behavior
-            // on non-Windows (no registry), and with a changewave (in case someone
-            // had a registry property and it breaks when it lights up).
-            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // on non-Windows (no registry).
+            if (!NativeMethodsShared.IsWindows)
             {
                 return defaultValue;
             }
@@ -245,9 +242,8 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
         {
 #if RUNTIME_TYPE_NETCORE
             // .NET Core MSBuild used to always return empty, so match that behavior
-            // on non-Windows (no registry), and with a changewave (in case someone
-            // had a registry property and it breaks when it lights up).
-            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // on non-Windows (no registry).
+            if (!NativeMethodsShared.IsWindows)
             {
                 return defaultValue;
             }
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 5de3520dab8..5ad09b27116 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -629,13 +629,10 @@ private ProjectTargetElement ParseProjectTargetElement(XmlElementWithLocation el
                         {
                             ProjectErrorUtilities.ThrowInvalidProject(onError.Location, "NodeMustBeLastUnderElement", XMakeElements.onError, XMakeElements.target, childElement.Name);
                         }
-                        if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+                        if (childElement.ChildNodes.Count == 1 && childElement.FirstChild.NodeType == XmlNodeType.Text)
                         {
-                            if (childElement.ChildNodes.Count == 1 && childElement.FirstChild.NodeType == XmlNodeType.Text)
-                            {
-                                // If the element has inner text and no other child elements except text, then this should be a property and throw invalid child element of <Target>
-                                ProjectErrorUtilities.ThrowInvalidProject(childElement.Location, "PropertyOutsidePropertyGroupInTarget", childElement.Name, childElement.ParentNode.Name);
-                            }
+                            // If the element has inner text and no other child elements except text, then this should be a property and throw invalid child element of <Target>
+                            ProjectErrorUtilities.ThrowInvalidProject(childElement.Location, "PropertyOutsidePropertyGroupInTarget", childElement.Name, childElement.ParentNode.Name);
                         }
 
                         child = ParseProjectTaskElement(childElement, target);
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 143587d96ee..97c925a0327 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -438,14 +438,8 @@ internal override void DiscardStrongReferences()
             {
                 DebugTraceCache("Clearing strong refs: ", _strongCache.Count);
 
-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
                 _strongCache = new LinkedList<ProjectRootElement>();
 
-                foreach (ProjectRootElement projectRootElement in oldStrongCache)
-                {
-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
-                }
-
                 // A scavenge of the weak cache is probably not worth it as
                 // the GC would have had to run immediately after the line above.
             }
@@ -459,45 +453,8 @@ internal override void Clear()
         {
             lock (_locker)
             {
-                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)
-                {
-                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
-                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);
-                    _strongCache = new LinkedList<ProjectRootElement>();
-
-                    foreach (ProjectRootElement projectRootElement in oldStrongCache)
-                    {
-                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
-                    }
-                }
-                else
-                {
-                    // Manually iterate through LinkedList so we can remove items during this iteration
-                    for (var listNode = _strongCache.First; listNode != null;)
-                    {
-                        var nextNode = listNode.Next;
-
-                        ProjectRootElement projectRootElement = listNode.Value;
-                        // Do not remove cache of files from immutable locations.
-                        // Those are mostly SDK project files and will be most probably needed in next builds.
-                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))
-                        {
-                            _weakCache.Remove(projectRootElement.FullPath);
-                            _strongCache.Remove(listNode);
-                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
-                        }
-
-                        listNode = nextNode;
-                    }
-
-                    // From weak list remove all which is not in strong list anymore
-                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();
-                    foreach (string victim in toBeRemovedFromWeakRefs)
-                    {
-                        _weakCache.Remove(victim);
-                    }
-                    _weakCache.Scavenge();
-                }
+                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);
+                _strongCache = new LinkedList<ProjectRootElement>();
             }
         }
 
@@ -540,10 +497,6 @@ internal override void DiscardImplicitReferences()
                         {
                             _strongCache.AddFirst(kvp.Value);
                         }
-                        else
-                        {
-                            RaiseProjectRootElementRemovedFromStrongCache(kvp.Value);
-                        }
                     }
                 }
             }
@@ -608,7 +561,6 @@ private void RenameEntryInternal(string oldFullPathIfAny, ProjectRootElement pro
             if (existingWeakEntry != null && !object.ReferenceEquals(existingWeakEntry, projectRootElement))
             {
                 _strongCache.Remove(existingWeakEntry);
-                RaiseProjectRootElementRemovedFromStrongCache(existingWeakEntry);
             }
 
             DebugTraceCache("Adding: ", projectRootElement.FullPath);
@@ -654,7 +606,6 @@ private void BoostEntryInStrongCache(ProjectRootElement projectRootElement)
 
                 DebugTraceCache("Shedding: ", node.Value.FullPath);
                 _strongCache.Remove(node);
-                RaiseProjectRootElementRemovedFromStrongCache(node.Value);
             }
         }
 
@@ -674,7 +625,6 @@ private void ForgetEntry(ProjectRootElement projectRootElement)
             if (strongCacheEntry != null)
             {
                 _strongCache.Remove(strongCacheEntry);
-                RaiseProjectRootElementRemovedFromStrongCache(strongCacheEntry.Value);
             }
 
             DebugTraceCache("Out of date dropped from XML cache: ", projectRootElement.FullPath);
diff --git a/src/Build/Evaluation/ProjectRootElementCacheBase.cs b/src/Build/Evaluation/ProjectRootElementCacheBase.cs
index 97857fa0b6e..bc8823398b5 100644
--- a/src/Build/Evaluation/ProjectRootElementCacheBase.cs
+++ b/src/Build/Evaluation/ProjectRootElementCacheBase.cs
@@ -27,11 +27,6 @@ internal abstract class ProjectRootElementCacheBase
         /// </summary>
         internal delegate ProjectRootElement OpenProjectRootElement(string path, ProjectRootElementCacheBase cache);
 
-        /// <summary>
-        /// Event that is fired when an entry in the Strong Cache is removed.
-        /// </summary>
-        internal static event StrongCacheEntryRemovedDelegate StrongCacheEntryRemoved;
-
         /// <summary>
         /// Event which is fired when a project root element is added to this cache.
         /// </summary>
@@ -96,15 +91,6 @@ protected void RaiseProjectRootElementAddedToCacheEvent(ProjectRootElement rootE
         {
             ProjectRootElementAddedHandler?.Invoke(this, new ProjectRootElementCacheAddEntryEventArgs(rootElement));
         }
-
-        /// <summary>
-        /// Raises an event which is raised when a project root element is removed from the strong cache.
-        /// </summary>
-        protected virtual void RaiseProjectRootElementRemovedFromStrongCache(ProjectRootElement projectRootElement)
-        {
-            StrongCacheEntryRemovedDelegate removedEvent = StrongCacheEntryRemoved;
-            removedEvent?.Invoke(this, projectRootElement);
-        }
     }
 
     /// <summary>
diff --git a/src/Build/Evaluation/ProjectStringCache.cs b/src/Build/Evaluation/ProjectStringCache.cs
deleted file mode 100644
index 7753ae7e5a5..00000000000
--- a/src/Build/Evaluation/ProjectStringCache.cs
+++ /dev/null
@@ -1,320 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Xml;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-
-#nullable disable
-
-namespace Microsoft.Build.Construction
-{
-    /// <summary>
-    /// This class will cache string values for loaded Xml files.
-    /// </summary>
-    [DebuggerDisplay("#Strings={Count} #Documents={_documents.Count}")]
-    internal class ProjectStringCache
-    {
-        /// <summary>
-        /// Start off with a large size as there are very many strings in common scenarios and resizing is expensive.
-        /// Note that there is a single instance of this cache for the lifetime of the process (albeit cleared out on XML unload)
-        /// Australian Govt has about 3000 strings; a single VC project with all its various XML files has about 4000 strings.
-        /// </summary>
-        private const int InitialSize = 5000;
-
-        /// <summary>
-        /// Store interned strings, and also a ref count, one per document using them.
-        /// </summary>
-        private RetrievableEntryHashSet<StringCacheEntry> _strings = new RetrievableEntryHashSet<StringCacheEntry>(InitialSize, StringComparer.Ordinal);
-
-        /// <summary>
-        /// Store all the strings a document is using, so their ref count can be decremented.
-        /// </summary>
-        private Dictionary<XmlDocument, HashSet<StringCacheEntry>> _documents = new Dictionary<XmlDocument, HashSet<StringCacheEntry>>();
-
-        /// <summary>
-        /// Locking object for this shared cache
-        /// </summary>
-        private Object _locker = new Object();
-
-        /// <summary>
-        /// Public constructor.
-        /// </summary>
-        public ProjectStringCache()
-        {
-            ProjectRootElementCacheBase.StrongCacheEntryRemoved += OnStrongCacheEntryRemoved;
-        }
-
-        /// <summary>
-        /// Obtain the number of entries contained in the cache.
-        /// </summary>
-        internal int Count
-        {
-            get
-            {
-                lock (_locker)
-                {
-                    return _strings.Count;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Obtain the number of documents contained in the cache.
-        /// </summary>
-        internal int DocumentCount
-        {
-            get
-            {
-                lock (_locker)
-                {
-                    return _documents.Count;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Add the given string to the cache or return the existing string if it is already
-        /// in the cache.
-        /// Constant time operation.
-        /// </summary>
-        public string Add(string key, XmlDocument document)
-        {
-            // Remove string interning in ChangeWave 17.6
-            // Note: When ready to remove the ChangeWaves under 17.6, please delete this entire class and all references to it. (See the PR https://github.com/dotnet/msbuild/pull/7952).
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
-            {
-                return key;
-            }
-
-            if (key.Length == 0)
-            {
-                return String.Empty;
-            }
-
-            // see Microsoft.Build.BackEnd.BuildRequestConfiguration.CreateUniqueGlobalProperty
-            if (key.StartsWith(MSBuildConstants.MSBuildDummyGlobalPropertyHeader, StringComparison.Ordinal))
-            {
-                return key;
-            }
-
-            lock (_locker)
-            {
-                VerifyState();
-
-                StringCacheEntry entry;
-                HashSet<StringCacheEntry> entries;
-
-                bool seenString = _strings.TryGetValue(key, out entry);
-                bool seenDocument = _documents.TryGetValue(document, out entries);
-
-                if (!seenString)
-                {
-                    entry = new StringCacheEntry(key);
-                    _strings.Add(entry);
-                }
-
-                if (!seenDocument)
-                {
-                    entries = new HashSet<StringCacheEntry>();
-                    _documents.Add(document, entries);
-                }
-
-                bool seenStringInThisDocument = seenString && seenDocument && entries.Contains(entry);
-
-                if (!seenStringInThisDocument)
-                {
-                    entries.Add(entry);
-
-                    // We've been referred to by a new document, so increment our ref count.
-                    entry.Increment();
-                }
-
-                VerifyState();
-
-                return entry.CachedString;
-            }
-        }
-
-        /// <summary>
-        /// Find the matching string in the cache.
-        /// Constant time operation.
-        /// </summary>
-        /// <param name="key">String to find in the cache.</param>
-        /// <returns>Existing string in the cache, or null if it is not contained.</returns>
-        public string Get(string key)
-        {
-            lock (_locker)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(key, nameof(key));
-
-                if (key.Length == 0)
-                {
-                    return String.Empty;
-                }
-
-                StringCacheEntry entry;
-                if (_strings.TryGetValue(key, out entry))
-                {
-                    return entry.CachedString;
-                }
-
-                return null;
-            }
-        }
-
-        /// <summary>
-        /// Indicates that a document's entries should be removed.
-        /// If document is unknown, does nothing.
-        /// Complexity proportional to the number of strings in the document,
-        /// if the document is anywhere in the cache, otherwise O(1).
-        /// </summary>
-        public void Clear(XmlDocument document)
-        {
-            lock (_locker)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(document, nameof(document));
-
-                VerifyState();
-
-                HashSet<StringCacheEntry> entries;
-                if (_documents.TryGetValue(document, out entries))
-                {
-                    foreach (var entry in entries)
-                    {
-                        string str = entry.CachedString;
-                        entry.Decrement();
-
-                        if (entry.RefCount == 0)
-                        {
-                            _strings.Remove(str);
-                        }
-                    }
-
-                    _documents.Remove(document);
-                }
-
-                VerifyState();
-            }
-        }
-
-        /// <summary>
-        /// Verifies that each string entry has only one instance in the system.
-        /// Enable the conditional if and while you make any modifications to the class, then disable as it is very slow.
-        /// </summary>
-        [Conditional("NEVER")]
-        private void VerifyState()
-        {
-            HashSet<StringCacheEntry> uniqueEntries = new HashSet<StringCacheEntry>();
-            foreach (var entries in _documents.Values)
-            {
-                foreach (var entry in entries)
-                {
-                    uniqueEntries.Add(entry);
-                    ErrorUtilities.VerifyThrow(entry.RefCount > 0, "extra deref");
-
-                    // We only ever create one StringCacheEntry instance per unique string, and that instance should be
-                    // the same in both collections.
-                    ErrorUtilities.VerifyThrow(Object.ReferenceEquals(entry, _strings[entry.CachedString]), "bad state");
-                }
-            }
-
-            ErrorUtilities.VerifyThrow(uniqueEntries.Count == _strings.Count, "bad state");
-        }
-
-        /// <summary>
-        /// Handle event that is fired when an entry in the project root element cache is removed
-        /// from its strong cache.
-        /// </summary>
-        /// <remarks>
-        /// When an entry is removed from a project root element cache's strong cache, we will remove
-        /// its entries from our string cache. Otherwise the string cache ends up being the only one
-        /// holding references to the Xml documents that have already been dropped.
-        /// </remarks>
-        private void OnStrongCacheEntryRemoved(object sender, ProjectRootElement projectRootElement)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
-            Clear(projectRootElement.XmlDocument);
-        }
-
-        /// <summary>
-        /// Represents an entry in the ProjectStringCache.
-        /// Can't be a struct because the copy-by-value and the ref counting don't go well together.
-        /// </summary>
-        [DebuggerDisplay("Count={_refCount} String={_cachedString}")]
-        private class StringCacheEntry : IKeyed
-        {
-            /// <summary>
-            /// Cached string
-            /// </summary>
-            private string _cachedString;
-
-            /// <summary>
-            /// Number of XmlDocuments where this string is included.
-            /// </summary>
-            private int _refCount;
-
-            /// <summary>
-            /// Constructor.
-            /// Caller must then do Increment().
-            /// </summary>
-            internal StringCacheEntry(string str)
-            {
-                _cachedString = str;
-                _refCount = 0;
-            }
-
-            /// <summary>
-            /// Key to find it
-            /// </summary>
-            public string Key
-            {
-                get { return _cachedString; }
-            }
-
-            /// <summary>
-            /// Number of documents using this string
-            /// </summary>
-            internal int RefCount
-            {
-                get { return _refCount; }
-            }
-
-            /// <summary>
-            /// Get the cached string.
-            /// </summary>
-            internal string CachedString
-            {
-                get
-                {
-                    ErrorUtilities.VerifyThrow(_refCount > 0, "extra deref");
-                    return _cachedString;
-                }
-            }
-
-            /// <summary>
-            /// Indicates that this entry is included in the given document.
-            /// Callers must verify that we were not already adreffed for this document.
-            /// </summary>
-            internal void Increment()
-            {
-                _refCount++;
-            }
-
-            /// <summary>
-            /// Removes a container for this entry.
-            /// Callers must verify that this was not already reffed and not subsequently dereffed.
-            /// </summary>
-            internal void Decrement()
-            {
-                ErrorUtilities.VerifyThrow(_refCount > 0, "extra deref");
-                _refCount--;
-            }
-        }
-    }
-}
diff --git a/src/Build/Evaluation/SimpleProjectRootElementCache.cs b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
index f359d3cbd07..e2a9d7d782e 100644
--- a/src/Build/Evaluation/SimpleProjectRootElementCache.cs
+++ b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
@@ -139,10 +139,5 @@ internal override void OnProjectDirtied(Project sender, ProjectChangedEventArgs
         {
             throw new NotImplementedException();
         }
-
-        protected override void RaiseProjectRootElementRemovedFromStrongCache(ProjectRootElement projectRootElement)
-        {
-            throw new NotImplementedException();
-        }
     }
 }
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 7dc448e6fb5..d254e53458d 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -881,7 +881,7 @@ public int Compare(object o1, object o2)
 
         public virtual void Shutdown()
         {
-            Traits.LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES")) && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4);
+            Traits.LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES"));
         }
 
         internal abstract void ResetConsoleLoggerState();
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 289a3b2c959..b06858fa47a 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -487,7 +487,6 @@
     <Compile Include="Evaluation\ProjectRootElementCacheBase.cs" />
     <Compile Include="Evaluation\ProjectRootElementCache.cs" />
     <Compile Include="Evaluation\SimpleProjectRootElementCache.cs" />
-    <Compile Include="Evaluation\ProjectStringCache.cs" />
     <Compile Include="Evaluation\SemiColonTokenizer.cs" />
     <Compile Include="Evaluation\StringMetadataTable.cs" />
     <Compile Include="Evaluation\ExpressionShredder.cs" />
diff --git a/src/Build/Xml/ProjectXmlUtilities.cs b/src/Build/Xml/ProjectXmlUtilities.cs
index c5ef688824e..e555da0aae3 100644
--- a/src/Build/Xml/ProjectXmlUtilities.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.cs
@@ -98,7 +98,7 @@ internal static bool VerifyValidProjectNamespace(XmlElementWithLocation element)
             }
             else if (string.IsNullOrEmpty(element.NamespaceURI))
             {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) && Path.GetExtension(element.Location.File).Equals(".dwproj", StringComparison.OrdinalIgnoreCase))
+                if (Path.GetExtension(element.Location.File).Equals(".dwproj", StringComparison.OrdinalIgnoreCase))
                 {
                     bool validMSBuildProject = true;
                     foreach (XmlNode child in element.ChildNodes)
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 51717c375ae..1d682c4fc75 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -25,12 +25,9 @@ internal enum ChangeWaveConversionState
     /// For dev docs: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves-Dev.md
     internal static class ChangeWaves
     {
-        internal static readonly Version Wave17_4 = new Version(17, 4);
-        internal static readonly Version Wave17_6 = new Version(17, 6);
-        internal static readonly Version Wave17_8 = new Version(17, 8);
         internal static readonly Version Wave17_10 = new Version(17, 10);
         internal static readonly Version Wave17_12 = new Version(17, 12);
-        internal static readonly Version[] AllWaves = { Wave17_4, Wave17_6, Wave17_8, Wave17_10, Wave17_12 };
+        internal static readonly Version[] AllWaves = { Wave17_10, Wave17_12 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
diff --git a/src/Framework/EncodingUtilities.cs b/src/Framework/EncodingUtilities.cs
index 93e0dd940fe..4ee4679dd3f 100644
--- a/src/Framework/EncodingUtilities.cs
+++ b/src/Framework/EncodingUtilities.cs
@@ -264,11 +264,6 @@ internal static Encoding BatchFileEncoding(string contents, string encodingSpeci
         /// </returns>
         public static CultureInfo? GetExternalOverriddenUILanguageIfSupportableWithEncoding()
         {
-            if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-            {
-                return null;
-            }
-
             CultureInfo? externalLanguageSetting = GetExternalOverriddenUILanguage();
             if (externalLanguageSetting != null)
             {
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 9bca9afa1a5..cc0ef31eee8 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -110,11 +110,8 @@ public Traits()
         /// <summary>
         /// Log all environment variables whether or not they are used in a build in the binary log.
         /// </summary>
-        public static bool LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES"))
-#if !TASKHOST
-            && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4)
-#endif
-            ;
+        public static bool LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES"));
+
         /// <summary>
         /// Log property tracking information.
         /// </summary>
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index c33b4e8da98..6851120de48 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -899,10 +899,8 @@ public void SetConsoleUICulture()
         }
 
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void ConsoleUIRespectsSDKLanguage(bool enableFeature)
+        [Fact]
+        public void ConsoleUIRespectsSDKLanguage()
         {
             if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && !EncodingUtilities.CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding())
             {
@@ -923,18 +921,10 @@ public void ConsoleUIRespectsSDKLanguage(bool enableFeature)
             {
                 // Set the UI language based on the SDK environment var.
                 testEnvironment.SetEnvironmentVariable(DOTNET_CLI_UI_LANGUAGE, "ja"); // Japanese chose arbitrarily.
-                ChangeWaves.ResetStateForTests();
-                if (!enableFeature)
-                {
-                    testEnvironment.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_8.ToString());
-                }
                 MSBuildApp.SetConsoleUI();
 
-                Assert.Equal(enableFeature ? new CultureInfo("ja") : CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture(), thisThread.CurrentUICulture);
-                if (enableFeature)
-                {
-                    Assert.Equal(65001, Console.OutputEncoding.CodePage); // UTF-8 enabled for correct rendering.
-                }
+                Assert.Equal(new CultureInfo("ja"), thisThread.CurrentUICulture);
+                Assert.Equal(65001, Console.OutputEncoding.CodePage); // UTF-8 enabled for correct rendering.
             }
             finally
             {
@@ -956,7 +946,6 @@ public void ConsoleUIRespectsSDKLanguage(bool enableFeature)
         /// We shouldn't change the UI culture if the current UI culture is invariant.
         /// In other cases, we can get an exception on CultureInfo creation when System.Globalization.Invariant enabled.
         /// </summary>
-
         [Fact]
         public void SetConsoleUICultureInInvariantCulture()
         {
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 6f7cc4b61e0..bfc061b5a1d 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -247,7 +247,6 @@ string[] args
 
             int exitCode;
             if (
-                ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) &&
                 Environment.GetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName) == "1" &&
                 !Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout &&
                 CanRunServerBasedOnCommandLineSwitches(
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index 9bde8a4db14..e2ebdff4f85 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -56,14 +56,11 @@ public MSBuildLoadContext(string assemblyPath)
                 return null;
             }
 
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // respect plugin.dll.json with the AssemblyDependencyResolver
+            string? assemblyPath = _resolver?.ResolveAssemblyToPath(assemblyName);
+            if (assemblyPath != null)
             {
-                // respect plugin.dll.json with the AssemblyDependencyResolver
-                string? assemblyPath = _resolver?.ResolveAssemblyToPath(assemblyName);
-                if (assemblyPath != null)
-                {
-                    return LoadFromAssemblyPath(assemblyPath);
-                }
+                return LoadFromAssemblyPath(assemblyPath);
             }
 
             // Fall back to the older MSBuild-on-Core behavior to continue to support
@@ -113,13 +110,10 @@ public MSBuildLoadContext(string assemblyPath)
 
         protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            string? libraryPath = _resolver?.ResolveUnmanagedDllToPath(unmanagedDllName);
+            if (libraryPath != null)
             {
-                string? libraryPath = _resolver?.ResolveUnmanagedDllToPath(unmanagedDllName);
-                if (libraryPath != null)
-                {
-                    return LoadUnmanagedDllFromPath(libraryPath);
-                }
+                return LoadUnmanagedDllFromPath(libraryPath);
             }
 
             return base.LoadUnmanagedDll(unmanagedDllName);
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 4595adaba62..187a7a43e4b 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -238,24 +238,10 @@ public void Translate(ITranslator translator)
                     TranslatePrimitiveTypeArray(translator);
                     break;
                 case TaskParameterType.ValueType:
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-                    {
                         TranslateValueType(translator);
-                    }
-                    else
-                    {
-                        translator.TranslateDotNet(ref _wrappedParameter);
-                    }
                     break;
                 case TaskParameterType.ValueTypeArray:
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-                    {
                         TranslateValueTypeArray(translator);
-                    }
-                    else
-                    {
-                        translator.TranslateDotNet(ref _wrappedParameter);
-                    }
                     break;
                 case TaskParameterType.ITaskItem:
                     TranslateITaskItem(translator);
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index f8cc28a2fa4..b8cf7e10aa4 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -1258,14 +1258,11 @@ private void ResolveReference(
             Reference reference)
         {
             bool isImmutableFrameworkReference = false;
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+            // For a path to be an immutable reference, it must be externally resolved and has a FrameworkReferenceName defined.
+            if (assemblyName == null && !string.IsNullOrEmpty(rawFileNameCandidate) && reference.IsPrimary && reference.ExternallyResolved)
             {
-                // For a path to be an immutable reference, it must be externally resolved and has a FrameworkReferenceName defined.
-                if (assemblyName == null && !string.IsNullOrEmpty(rawFileNameCandidate) && reference.IsPrimary && reference.ExternallyResolved)
-                {
-                    string frameworkReferenceName = reference.PrimarySourceItem.GetMetadata(ItemMetadataNames.frameworkReferenceName);
-                    isImmutableFrameworkReference = !string.IsNullOrEmpty(frameworkReferenceName);
-                }
+                string frameworkReferenceName = reference.PrimarySourceItem.GetMetadata(ItemMetadataNames.frameworkReferenceName);
+                isImmutableFrameworkReference = !string.IsNullOrEmpty(frameworkReferenceName);
             }
 
             // Now, resolve this reference.
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index bc7367121e4..bc2dc2279a9 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -287,8 +287,7 @@ private void LogAlwaysRetryDiagnosticFromResources(string messageResourceName, p
                 MakeFileWriteable(destinationFileState, true);
             }
 
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) &&
-                !Traits.Instance.EscapeHatches.CopyWithoutDelete &&
+            if (!Traits.Instance.EscapeHatches.CopyWithoutDelete &&
                 destinationFileState.FileExists &&
                 !destinationFileState.IsReadOnly)
             {
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index 476c2b52ae6..e37a9bcf300 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -23,7 +23,9 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal static class CultureInfoCache
     {
+#if !NET5_0_OR_GREATER
         private static readonly Lazy<HashSet<string>> ValidCultureNames = new Lazy<HashSet<string>>(() => InitializeValidCultureNames());
+#endif
 
         // https://docs.microsoft.com/en-gb/windows/desktop/Intl/using-pseudo-locales-for-localization-testing
         // These pseudo-locales are available in versions of Windows from Vista and later.
@@ -62,22 +64,20 @@ private static HashSet<string> InitializeValidCultureNames()
         internal static bool IsValidCultureString(string name)
         {
 #if NET5_0_OR_GREATER
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            try
             {
-                try
-                {
-                    // GetCultureInfo throws if the culture doesn't exist
-                    CultureInfo.GetCultureInfo(name, predefinedOnly: true);
-                    return true;
-                }
-                catch
-                {
-                    // Second attempt: try pseudolocales (see above)
-                    return pseudoLocales.Contains(name, StringComparer.OrdinalIgnoreCase);
-                }
+                // GetCultureInfo throws if the culture doesn't exist
+                CultureInfo.GetCultureInfo(name, predefinedOnly: true);
+                return true;
             }
-#endif
+            catch
+            {
+                // Second attempt: try pseudolocales (see above)
+                return pseudoLocales.Contains(name, StringComparer.OrdinalIgnoreCase);
+            }
+#else
             return ValidCultureNames.Value.Contains(name);
+#endif
         }
 
 #if !FEATURE_CULTUREINFO_GETCULTURES
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index ea271573fd0..d1d6f8f7bc6 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -121,12 +121,7 @@ public override bool Execute()
 
         private HashAlgorithm CreateHashAlgorithm()
         {
-            return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) ?
-                SHA256.Create() :
-#pragma warning disable CA5350
-                // Kept for back compatibility reasons when chnange wave is opted-out
-                SHA1.Create();
-#pragma warning restore CA5350
+            return SHA256.Create();
         }
 
         /// <summary>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 9850e8cc161..811dcdc42cc 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -48,7 +48,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <!-- Extract necessary information for SetPlatform negotiation -->
         <!-- This target does not run for cpp projects. -->
         <IsVcxOrNativeProj>false</IsVcxOrNativeProj>
-        <Platform Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">$(Platform)</Platform>
+        <Platform>$(Platform)</Platform>
         <Platforms>$(Platforms)</Platforms>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index bc59d692a76..d881ab86b69 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1551,8 +1551,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
     -->
   <Target Name="IgnoreJavaScriptOutputAssembly"
-    BeforeTargets="AssignProjectConfiguration"
-    Condition="$([MSBuild]::AreFeaturesEnabled('17.8'))">
+    BeforeTargets="AssignProjectConfiguration">
       <ItemGroup>
         <ProjectReference Condition="'%(ProjectReference.Extension)' == '.esproj' and '%(ProjectReference.ReferenceOutputAssembly)' == ''">
           <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
@@ -1985,7 +1984,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <IsRidAgnostic>@(_TargetFrameworkInfo->'%(IsRidAgnostic)')</IsRidAgnostic>
         <!-- Extract necessary information for SetPlatform negotiation -->
         <IsVcxOrNativeProj Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">true</IsVcxOrNativeProj>
-        <Platform Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">$(Platform)</Platform>
+        <Platform>$(Platform)</Platform>
         <Platforms>$(Platforms)</Platforms>
         <!-- .vcxproj and .nativeproj contain a `ProjectConfiguration` item that have `Platform` metadata within.
              Build the `Platforms` property from that. -->
@@ -4553,7 +4552,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </_ClickOnceTransitiveContentItemsTemp>
       <_ClickOnceTransitiveContentItems Include="@(_ClickOnceTransitiveContentItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
 
-      <!-- 
+      <!--
         ClickOnce content items is union of transitive content items and content items from this project.
         We also exclude content items from this project that have set CopyToPublishDirectory to Never.
       -->
diff --git a/src/Utilities/LockCheck.cs b/src/Utilities/LockCheck.cs
index 186f627f28e..c2de1dfaa65 100644
--- a/src/Utilities/LockCheck.cs
+++ b/src/Utilities/LockCheck.cs
@@ -271,13 +271,10 @@ private static string GetLockedFileMessageWindows(string filePath)
 
             try
             {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-                {
-                    var processes = GetProcessesLockingFile(filePath);
-                    message = !string.IsNullOrEmpty(processes)
-                        ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("LockCheck.FileLocked", processes)
-                        : String.Empty;
-                }
+                var processes = GetProcessesLockingFile(filePath);
+                message = !string.IsNullOrEmpty(processes)
+                    ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("LockCheck.FileLocked", processes)
+                    : String.Empty;
             }
             catch (Exception)
             {
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index a4f1f9295aa..20510c33d8b 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -2460,7 +2460,7 @@ private static IEnumerable<TargetPlatformSDK> RetrieveTargetPlatformList(string[
                     var monikers = new Dictionary<TargetPlatformSDK, TargetPlatformSDK>();
                     GatherSDKListFromDirectory(sdkDiskRoots, monikers);
 
-                    if (NativeMethodsShared.IsWindows && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                    if (NativeMethodsShared.IsWindows)
                     {
                         GatherSDKListFromRegistry(registryRoot, monikers);
                     }
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 2443ff50c43..fe6ab5d92ed 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -380,7 +380,7 @@ protected virtual void ProcessStarted() { }
         /// <returns>true, if successful</returns>
         protected internal virtual bool ValidateParameters()
         {
-            if (TaskProcessTerminationTimeout < -1 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+            if (TaskProcessTerminationTimeout < -1)
             {
                 Log.LogWarningWithCodeFromResources("ToolTask.InvalidTerminationTimeout", TaskProcessTerminationTimeout);
                 return false;
@@ -694,7 +694,7 @@ protected virtual ProcessStartInfo GetProcessStartInfo(
         /// <summary>
         /// We expect tasks to override this method if they need information about the tool process or its process events during task execution.
         /// Implementation should make sure that the task is started in this method.
-        /// Starts the process during task execution. 
+        /// Starts the process during task execution.
         /// </summary>
         /// <param name="proc">Fully populated <see cref="Process"/> instance representing the tool process to be started.</param>
         /// <returns>A started process. This could be <paramref name="proc"/> or another <see cref="Process"/> instance.</returns>
@@ -1000,7 +1000,7 @@ private void KillToolProcessOnTimeout(Process proc, bool isBeingCancelled)
                     LogShared.LogWarningWithCodeFromResources("Shared.KillingProcessByCancellation", processName);
                 }
 
-                int timeout = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && TaskProcessTerminationTimeout >= -1 ? TaskProcessTerminationTimeout : 5000;
+                int timeout = TaskProcessTerminationTimeout >= -1 ? TaskProcessTerminationTimeout : 5000;
                 string timeoutFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDTOOLTASKCANCELPROCESSWAITTIMEOUT");
                 if (timeoutFromEnvironment != null)
                 {
