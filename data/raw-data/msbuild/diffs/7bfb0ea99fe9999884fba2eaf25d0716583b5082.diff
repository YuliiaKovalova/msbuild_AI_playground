diff --git a/NuGet.config b/NuGet.config
index 28add67a226..659ab421680 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -18,7 +18,6 @@
     <add key="dotnet8" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json" />
     <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
     <add key="dotnet9" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json" />
-    <add key="BuildXL" value="https://pkgs.dev.azure.com/ms/BuildXL/_packaging/BuildXL/nuget/v3/index.json" />
     <add key="msbuild17.12" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/darc-pub-DotNet-msbuild-Trusted-95c7bf01-1/nuget/v3/index.json" />
   </packageSources>
   <disabledPackageSources>
@@ -32,10 +31,8 @@
     <!--  End: Package sources from dotnet-runtime -->
     <!--End: Package sources managed by Dependency Flow automation. Do not edit the sources above.-->
   </disabledPackageSources>
-
   <auditSources>
     <clear />
     <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
   </auditSources>
-
 </configuration>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index ebcf20d46e9..c195807e00b 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -71,36 +71,36 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.24473.1">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.24503.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1230437de1ab7b3e15fe7cdfe7ffce2f65449959</Sha>
+      <Sha>beb827ded6acdff8c7333dfc6583cc984a8f2620</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.24473.1">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.24503.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1230437de1ab7b3e15fe7cdfe7ffce2f65449959</Sha>
+      <Sha>beb827ded6acdff8c7333dfc6583cc984a8f2620</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.24473.1">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.24503.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1230437de1ab7b3e15fe7cdfe7ffce2f65449959</Sha>
+      <Sha>beb827ded6acdff8c7333dfc6583cc984a8f2620</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.12.0-rc.120">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.12.0-rc.127">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>675e8a81acb53958e40dc21be5f562d00239a449</Sha>
+      <Sha>19756345139c45de23bd196e9b4be01d48e84fdd</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.12.0-3.24479.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.12.0-3.24504.7">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>ba2f19abe63a267dc9b2d082d0e1904cd91c1947</Sha>
+      <Sha>6a9d2b077973e31b213517579f674b461053ac1c</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.12.0-3.24479.1">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.12.0-3.24504.7">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>ba2f19abe63a267dc9b2d082d0e1904cd91c1947</Sha>
+      <Sha>6a9d2b077973e31b213517579f674b461053ac1c</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.24473.1">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.24503.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1230437de1ab7b3e15fe7cdfe7ffce2f65449959</Sha>
+      <Sha>beb827ded6acdff8c7333dfc6583cc984a8f2620</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 31df63da22b..78ad453b6b3 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -50,11 +50,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.24473.1</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.24503.2</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.12.0-3.24479.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.12.0-rc.120</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.12.0-3.24504.7</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.12.0-rc.127</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
diff --git a/eng/common/templates-official/job/job.yml b/eng/common/templates-official/job/job.yml
index 3d16b41c78c..605692d2fb7 100644
--- a/eng/common/templates-official/job/job.yml
+++ b/eng/common/templates-official/job/job.yml
@@ -1,6 +1,7 @@
 parameters:
 # Sbom related params
   enableSbom: true
+  runAsPublic: false
   PackageVersion: 9.0.0
   BuildDropPath: '$(Build.SourcesDirectory)/artifacts'
 
diff --git a/eng/common/templates/job/job.yml b/eng/common/templates/job/job.yml
index 07d317bf8f9..d1aeb92fcea 100644
--- a/eng/common/templates/job/job.yml
+++ b/eng/common/templates/job/job.yml
@@ -4,6 +4,7 @@ parameters:
   componentGovernanceIgnoreDirectories: ''
 # Sbom related params
   enableSbom: true
+  runAsPublic: false
   PackageVersion: 9.0.0
   BuildDropPath: '$(Build.SourcesDirectory)/artifacts'
 
diff --git a/global.json b/global.json
index 20a7d304435..055227f031e 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.10.0-pre.4.0"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.24473.1"
+    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.24503.2"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index f609a693cba..c249a953174 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -79,6 +79,7 @@ public void VerifyEventType()
             GeneratedFileUsedEventArgs generatedFileUsed = new GeneratedFileUsedEventArgs("path", "some content");
             BuildSubmissionStartedEventArgs buildSubmissionStarted = new(new Dictionary<string, string> { { "Value1", "Value2" } }, ["Path1"], ["TargetName"], BuildRequestDataFlags.ReplaceExistingProjectInstance, 123);
             BuildCheckTracingEventArgs buildCheckTracing = new();
+            BuildCanceledEventArgs buildCanceled = new("message", DateTime.UtcNow);
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -114,6 +115,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(generatedFileUsed, LoggingEventType.GeneratedFileUsedEvent);
             VerifyLoggingPacket(buildSubmissionStarted, LoggingEventType.BuildSubmissionStartedEvent);
             VerifyLoggingPacket(buildCheckTracing, LoggingEventType.BuildCheckTracingEvent);
+            VerifyLoggingPacket(buildCanceled, LoggingEventType.BuildCanceledEvent);
         }
 
         private static BuildEventContext CreateBuildEventContext()
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index bf2af7ca1fc..c45baa49e1e 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -97,6 +97,18 @@ public void RoundtripBuildFinishedEventArgs()
                 e => e.Succeeded.ToString());
         }
 
+        [Fact]
+        public void RoundtripBuildCanceledEventArgs()
+        {
+            var args = new BuildCanceledEventArgs(
+                "Message",
+                eventTimestamp: DateTime.Parse("12/12/2015 06:11:56 PM"));
+
+            Roundtrip(args,
+                e => e.Message,
+                e => e.Timestamp.ToString());
+        }
+
         [Fact]
         public void RoundtripBuildSubmissionStartedEventArgs()
         {
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 199c39ff7f6..3d8ccf424fb 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -668,7 +668,7 @@ IEnumerable<ILogger> AppendDebuggingLoggers(IEnumerable<ILogger> loggers)
 
                 var logger = new BinaryLogger { Parameters = binlogPath };
 
-                return (loggers ?? Enumerable.Empty<ILogger>()).Concat(new[] { logger });
+                return (loggers ?? [logger]);
             }
 
             void InitializeCaches()
@@ -1522,7 +1522,7 @@ private BuildRequestConfiguration CreateConfiguration(Project project, BuildRequ
 
             if (existingConfiguration == null)
             {
-                existingConfiguration = new BuildRequestConfiguration(GetNewConfigurationId(), new BuildRequestData(newInstance, Array.Empty<string>()), null /* use the instance's tools version */);
+                existingConfiguration = new BuildRequestConfiguration(GetNewConfigurationId(), new BuildRequestData(newInstance, []), null /* use the instance's tools version */);
             }
             else
             {
@@ -1830,7 +1830,7 @@ void IssueBuildSubmissionToSchedulerImpl(BuildSubmission submission, bool allowM
                             }
                         }
 
-                        BuildRequestBlocker blocker = new BuildRequestBlocker(-1, Array.Empty<string>(), new[] { submission.BuildRequest });
+                        BuildRequestBlocker blocker = new BuildRequestBlocker(-1, [], [submission.BuildRequest]);
 
                         HandleNewRequest(Scheduler.VirtualNode, blocker);
                     }
@@ -3110,48 +3110,51 @@ private void ShutdownLoggingService(ILoggingService? loggingService)
         /// </summary>
         private void Dispose(bool disposing)
         {
-            if (!_disposed)
+            if (disposing && !_disposed)
             {
-                if (disposing)
+                lock (_syncLock)
                 {
-                    lock (_syncLock)
+                    if (_disposed)
                     {
-                        // We should always have finished cleaning up before calling Dispose.
-                        RequireState(BuildManagerState.Idle, "ShouldNotDisposeWhenBuildManagerActive");
+                        // Multiple caller raced for enter into the lock
+                        return;
+                    }
 
-                        _componentFactories?.ShutdownComponents();
+                    // We should always have finished cleaning up before calling Dispose.
+                    RequireState(BuildManagerState.Idle, "ShouldNotDisposeWhenBuildManagerActive");
 
-                        if (_workQueue != null)
-                        {
-                            _workQueue.Complete();
-                            _workQueue = null;
-                        }
+                    _componentFactories?.ShutdownComponents();
 
-                        if (_executionCancellationTokenSource != null)
-                        {
-                            _executionCancellationTokenSource.Cancel();
-                            _executionCancellationTokenSource = null;
-                        }
+                    if (_workQueue != null)
+                    {
+                        _workQueue.Complete();
+                        _workQueue = null;
+                    }
 
-                        if (_noActiveSubmissionsEvent != null)
-                        {
-                            _noActiveSubmissionsEvent.Dispose();
-                            _noActiveSubmissionsEvent = null;
-                        }
+                    if (_executionCancellationTokenSource != null)
+                    {
+                        _executionCancellationTokenSource.Cancel();
+                        _executionCancellationTokenSource = null;
+                    }
 
-                        if (_noNodesActiveEvent != null)
-                        {
-                            _noNodesActiveEvent.Dispose();
-                            _noNodesActiveEvent = null;
-                        }
+                    if (_noActiveSubmissionsEvent != null)
+                    {
+                        _noActiveSubmissionsEvent.Dispose();
+                        _noActiveSubmissionsEvent = null;
+                    }
 
-                        if (ReferenceEquals(this, s_singletonInstance))
-                        {
-                            s_singletonInstance = null;
-                        }
+                    if (_noNodesActiveEvent != null)
+                    {
+                        _noNodesActiveEvent.Dispose();
+                        _noNodesActiveEvent = null;
+                    }
 
-                        _disposed = true;
+                    if (ReferenceEquals(this, s_singletonInstance))
+                    {
+                        s_singletonInstance = null;
                     }
+
+                    _disposed = true;
                 }
             }
         }
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index 1dba5f10f78..7ef719402d2 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -187,7 +187,7 @@ public override BuildResult Execute()
             ExecuteAsync(null, null, _legacyThreadingSemantics);
             if (_legacyThreadingSemantics)
             {
-                RequestBuilder.WaitWithBuilderThreadStart(new[] { WaitHandle }, false, legacyThreadingData, SubmissionId);
+                RequestBuilder.WaitWithBuilderThreadStart([WaitHandle], false, legacyThreadingData, SubmissionId);
             }
             else
             {
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 642f1b1b024..c23b5134407 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -467,10 +467,11 @@ private bool TryLaunchServer()
 
             try
             {
-                string[] msBuildServerOptions = new string[] {
+                string[] msBuildServerOptions =
+                [
                     "/nologo",
                     "/nodemode:8"
-                };
+                ];
                 NodeLauncher nodeLauncher = new NodeLauncher();
                 CommunicationsUtilities.Trace("Starting Server...");
                 Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions), nodeId: 0);
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index 4c2be1f5a97..9e9ee1d0bf8 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -205,14 +205,15 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                     // will be returned by WaitAny if multiple wait handles are signalled. We prefer to have the
                     // terminate event triggered so that we cannot get into a situation where packets are being
                     // spammed to the client and it never gets an opportunity to shutdown.
-                    WaitHandle[] handles = new WaitHandle[] {
-                    localPacketPumpShutdownEvent,
+                    WaitHandle[] handles =
+                    [
+                        localPacketPumpShutdownEvent,
 #if FEATURE_APM
-                    result.AsyncWaitHandle
+                        result.AsyncWaitHandle
 #else
-                    ((IAsyncResult)readTask).AsyncWaitHandle
+                        ((IAsyncResult)readTask).AsyncWaitHandle
 #endif
-                    };
+                    ];
                     int waitId = WaitHandle.WaitAny(handles);
                     switch (waitId)
                     {
diff --git a/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
index 8bfb43b1ecb..3defd87986c 100644
--- a/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
@@ -107,14 +107,14 @@ public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)
                 FileAccessPolicy.AllowAll | FileAccessPolicy.ReportAccess);
 
             // Support shared compilation
-            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox = new BreakawayChildProcess[]
-            {
+            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox =
+            [
 #if RUNTIME_TYPE_NETCORE
                 new BreakawayChildProcess(NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet", "vbcscompiler.dll", CommandLineArgsSubstringContainmentIgnoreCase: true)
 #else
                 new BreakawayChildProcess(NativeMethodsShared.IsWindows ? "VBCSCompiler.exe" : "VBCSCompiler")
 #endif
-            };
+            ];
             info.FileAccessManifest.MonitorChildProcesses = true;
             info.FileAccessManifest.IgnoreReparsePoints = true;
             info.FileAccessManifest.UseExtraThreadToDrainNtClose = false;
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 68843247305..70ec3d41487 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -420,7 +420,7 @@ private void PacketPumpProc()
                 // will be returned by WaitAny if multiple wait handles are signalled.  We prefer to have the
                 // terminate event triggered so that we cannot get into a situation where packets are being
                 // spammed to the endpoint and it never gets an opportunity to shutdown.
-                WaitHandle[] handles = new WaitHandle[] { _terminatePacketPump, _packetAvailable };
+                WaitHandle[] handles = [_terminatePacketPump, _packetAvailable];
 
                 bool exitLoop = false;
                 do
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 69e796772b4..22687557135 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -207,7 +207,7 @@ private static ProjectStartedEventArgs CreateProjectStarted(
             {
                 if (projectProperties is null)
                 {
-                    properties = Enumerable.Empty<DictionaryEntry>();
+                    properties = [];
                 }
                 else if (Traits.LogAllEnvironmentVariables)
                 {
@@ -218,7 +218,7 @@ private static ProjectStartedEventArgs CreateProjectStarted(
                     properties = projectProperties.Filter(p => p is not EnvironmentDerivedProjectPropertyInstance || EnvironmentUtilities.IsWellKnownEnvironmentDerivedProperty(p.Name), p => new DictionaryEntry(p.Name, p.EvaluatedValue));
                 }
 
-                items = projectItems?.GetCopyOnReadEnumerable(item => new DictionaryEntry(item.ItemType, new TaskItem(item))) ?? Enumerable.Empty<DictionaryEntry>();
+                items = projectItems?.GetCopyOnReadEnumerable(item => new DictionaryEntry(item.ItemType, new TaskItem(item))) ?? [];
             }
 
             if (projectProperties != null &&
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
index d7b5ea98cca..5f3ff599c99 100644
--- a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
@@ -30,7 +30,7 @@ public CacheContext(
             MSBuildFileSystemBase fileSystem,
             ProjectGraph? graph = null,
             IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = null)
-            : this(pluginSettings, fileSystem, requestedTargets: Array.Empty<string>(), graph, graphEntryPoints)
+            : this(pluginSettings, fileSystem, requestedTargets: [], graph, graphEntryPoints)
         {
         }
 
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index d573f4bdc74..43192499a9e 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -454,7 +454,7 @@ public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancel
 
                 BuildRequestData buildRequest = new BuildRequestData(
                     cacheRequest.Configuration.Project,
-                    cacheRequest.Submission.BuildRequestData?.TargetNames.ToArray() ?? Array.Empty<string>());
+                    cacheRequest.Submission.BuildRequestData?.TargetNames.ToArray() ?? []);
                 BuildEventContext buildEventContext = _loggingService.CreateProjectCacheBuildEventContext(
                     cacheRequest.Submission.SubmissionId,
                     evaluationId: cacheRequest.Configuration.Project.EvaluationId,
@@ -650,7 +650,7 @@ private IReadOnlyCollection<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildReq
             }
             else
             {
-                return new[] { new ProjectGraphEntryPoint(configuration.ProjectFullPath, globalProperties) };
+                return [new ProjectGraphEntryPoint(configuration.ProjectFullPath, globalProperties)];
             }
 
             static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index b072bdbe462..73f84dd94a0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -504,7 +504,7 @@ internal static List<string[]> CreateTargetLists(
                 // Separate target invocations for each individual target.
                 foreach (string targetName in targets)
                 {
-                    targetLists.Add(new[] { targetName });
+                    targetLists.Add([targetName]);
                 }
             }
             else
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 5df61cc392b..0d9b660b451 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -402,7 +402,7 @@ public async Task BlockOnTargetInProgress(int blockingGlobalRequestId, string bl
 
             RaiseOnBlockedRequest(blockingGlobalRequestId, blockingTarget, partialBuildResult);
 
-            WaitHandle[] handles = new WaitHandle[] { _terminateEvent, _continueEvent };
+            WaitHandle[] handles = [_terminateEvent, _continueEvent];
 
             int handle;
             if (IsBuilderUsingLegacyThreadingSemantics(_componentHost, _requestEntry))
@@ -448,7 +448,7 @@ public void Reacquire()
             VerifyIsNotZombie();
             RaiseOnBlockedRequest(_requestEntry.Request.GlobalRequestId, String.Empty);
 
-            WaitHandle[] handles = new WaitHandle[] { _terminateEvent, _continueEvent };
+            WaitHandle[] handles = [_terminateEvent, _continueEvent];
 
             int handle = WaitHandle.WaitAny(handles);
 
@@ -506,7 +506,7 @@ public int RequestCores(object monitorLockObject, int requestedCores, bool waitF
             RaiseResourceRequest(ResourceRequest.CreateAcquireRequest(_requestEntry.Request.GlobalRequestId, requestedCores, waitForCores));
 
             // Wait for one of two events to be signaled: 1) The build was canceled, 2) The response to our request was received.
-            WaitHandle[] waitHandles = new WaitHandle[] { _terminateEvent, responseEvent };
+            WaitHandle[] waitHandles = [_terminateEvent, responseEvent];
             int waitResult;
 
             // Drop the lock so that the same task can call ReleaseCores from other threads to unblock itself.
@@ -957,7 +957,7 @@ private async Task<BuildResult[]> StartNewBuildRequests(FullyQualifiedBuildReque
             BuildResult[] results;
             if (waitForResults)
             {
-                WaitHandle[] handles = new WaitHandle[] { _terminateEvent, _continueEvent };
+                WaitHandle[] handles = [_terminateEvent, _continueEvent];
 
                 int handle;
                 if (IsBuilderUsingLegacyThreadingSemantics(_componentHost, _requestEntry))
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index e9e1bf575a2..09567c2370f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -261,11 +261,11 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, Syste
         {
             VerifyActiveProxy();
             return BuildProjectFilesInParallel(
-                new string[] { projectFileName },
+                [projectFileName],
                 targetNames,
-                new IDictionary[] { globalProperties },
-                new IDictionary[] { targetOutputs },
-                new string[] { toolsVersion },
+                [globalProperties],
+                [targetOutputs],
+                [toolsVersion],
                 true,
                 false);
         }
@@ -1205,8 +1205,8 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                     BuildResult[] results = await builderCallback.BuildProjects(
                         projectFileNames,
                         propertyDictionaries,
-                        toolsVersion ?? Array.Empty<string>(),
-                        targetNames ?? Array.Empty<string>(),
+                        toolsVersion ?? [],
+                        targetNames ?? [],
                         waitForResults: true,
                         skipNonexistentTargets: skipNonexistentTargets);
 
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index 4d7abb22231..246f6b591b6 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -187,7 +187,7 @@ public IEnumerable<string> ActiveTargets
         {
             get
             {
-                VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Yielding, SchedulableRequestState.Blocked, SchedulableRequestState.Executing });
+                VerifyOneOfStates([SchedulableRequestState.Yielding, SchedulableRequestState.Blocked, SchedulableRequestState.Executing]);
                 return _activeTargetsWhenBlocked;
             }
         }
@@ -334,7 +334,7 @@ public void Reacquire()
         /// <param name="blockingTarget">Target that we are blocked on which is being built by <paramref name="blockingRequest"/></param>
         public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTargets, string blockingTarget = null)
         {
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Executing });
+            VerifyOneOfStates([SchedulableRequestState.Blocked, SchedulableRequestState.Executing]);
             ErrorUtilities.VerifyThrowArgumentNull(blockingRequest, nameof(blockingRequest));
             ErrorUtilities.VerifyThrowArgumentNull(activeTargets, nameof(activeTargets));
             ErrorUtilities.VerifyThrow(BlockingTarget == null, "Cannot block again if we're already blocked on a target");
@@ -350,7 +350,7 @@ public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTa
             // to also execute, then that request is not unscheduled (because it was running on the node) and it is not executing (because this condition
             // can only occur against requests which are executing on the same node and since the request which called this method is the one currently
             // executing on that node, that means the request it is blocked by must either be itself blocked or ready.)
-            blockingRequest.VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Yielding, SchedulableRequestState.Blocked, SchedulableRequestState.Ready, SchedulableRequestState.Unscheduled });
+            blockingRequest.VerifyOneOfStates([SchedulableRequestState.Yielding, SchedulableRequestState.Blocked, SchedulableRequestState.Ready, SchedulableRequestState.Unscheduled]);
 
             // Update our list of active targets.  This has to be done before we detect circular dependencies because we use this information to detect
             // re-entrancy circular dependencies.
@@ -371,7 +371,7 @@ public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTa
         /// </summary>
         public void UnblockWithPartialResultForBlockingTarget(BuildResult result)
         {
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled });
+            VerifyOneOfStates([SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled]);
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
 
             BlockingRequestKey key = new BlockingRequestKey(result);
@@ -384,7 +384,7 @@ public void UnblockWithPartialResultForBlockingTarget(BuildResult result)
         /// </summary>
         public void UnblockWithResult(BuildResult result)
         {
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled });
+            VerifyOneOfStates([SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled]);
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
 
             BlockingRequestKey key = new BlockingRequestKey(result);
@@ -400,7 +400,7 @@ public void ResumeExecution(int nodeId)
         {
             ErrorUtilities.VerifyThrow(_assignedNodeId == Scheduler.InvalidNodeId || _assignedNodeId == nodeId, "Request must always resume on the same node on which it was started.");
 
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Ready, SchedulableRequestState.Unscheduled });
+            VerifyOneOfStates([SchedulableRequestState.Ready, SchedulableRequestState.Unscheduled]);
             ErrorUtilities.VerifyThrow((_state == SchedulableRequestState.Ready) || !_schedulingData.IsRequestScheduled(this), "Another instance of request {0} is already scheduled.", _request.GlobalRequestId);
             ErrorUtilities.VerifyThrow(!_schedulingData.IsNodeWorking(nodeId), "Cannot resume execution of request {0} because node {1} is already working.", _request.GlobalRequestId, nodeId);
 
@@ -416,7 +416,7 @@ public void ResumeExecution(int nodeId)
         /// </summary>
         public void Complete(BuildResult result)
         {
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Ready, SchedulableRequestState.Executing, SchedulableRequestState.Unscheduled });
+            VerifyOneOfStates([SchedulableRequestState.Ready, SchedulableRequestState.Executing, SchedulableRequestState.Unscheduled]);
             ErrorUtilities.VerifyThrow(_state != SchedulableRequestState.Ready || result.CircularDependency, "Request can only be Completed from the Ready state if the result indicates a circular dependency occurred.");
             ErrorUtilities.VerifyThrow(_requestsWeAreBlockedBy.Count == 0, "We can't be complete if we are still blocked on requests.");
 
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 4bffd2f0cf4..5fedb8c7ac9 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -1627,7 +1627,7 @@ private void HandleRequestBlockedOnInProgressTarget(SchedulableRequest blockedRe
 
             // The request we blocked on couldn't have been executing (because we are) so it must either be yielding (which is ok because
             // it isn't modifying its own state, just running a background process), ready, or still blocked.
-            blockingRequest.VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Yielding, SchedulableRequestState.Ready, SchedulableRequestState.Blocked });
+            blockingRequest.VerifyOneOfStates([SchedulableRequestState.Yielding, SchedulableRequestState.Ready, SchedulableRequestState.Blocked]);
 
             // detect the case for https://github.com/dotnet/msbuild/issues/3047
             // if we have partial results AND blocked and blocking share the same configuration AND are blocked on each other
@@ -1651,7 +1651,7 @@ private void HandleRequestBlockedOnInProgressTarget(SchedulableRequest blockedRe
         private void HandleRequestBlockedOnResultsTransfer(SchedulableRequest parentRequest, List<ScheduleResponse> responses)
         {
             // Create the new request which will go to the configuration's results node.
-            BuildRequest newRequest = new BuildRequest(parentRequest.BuildRequest.SubmissionId, BuildRequest.ResultsTransferNodeRequestId, parentRequest.BuildRequest.ConfigurationId, Array.Empty<string>(), null, parentRequest.BuildRequest.BuildEventContext, parentRequest.BuildRequest, parentRequest.BuildRequest.BuildRequestDataFlags);
+            BuildRequest newRequest = new BuildRequest(parentRequest.BuildRequest.SubmissionId, BuildRequest.ResultsTransferNodeRequestId, parentRequest.BuildRequest.ConfigurationId, [], null, parentRequest.BuildRequest.BuildEventContext, parentRequest.BuildRequest, parentRequest.BuildRequest.BuildRequestDataFlags);
 
             // Assign a new global request id - always different from any other.
             newRequest.GlobalRequestId = _nextGlobalRequestId;
diff --git a/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs b/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
index 8ce9065b9d0..6e49ea9d18d 100644
--- a/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
@@ -34,7 +34,7 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase c
 
             return FileUtilities.DirectoryExistsNoThrow(sdkPath)
                 ? factory.IndicateSuccess(sdkPath, string.Empty)
-                : factory.IndicateFailure(new string[] { ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("DefaultSDKResolverError", sdk.Name, sdkPath) }, null);
+                : factory.IndicateFailure([ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("DefaultSDKResolverError", sdk.Name, sdkPath)], null);
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 5241e228c2f..fbd4a2ba24a 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -126,7 +126,7 @@ private SdkResult RequestSdkPathFromMainNode(int submissionId, SdkReference sdk,
             SendPacket(packet);
 
             // Wait for either the response or a shutdown event.  Either event means this thread should return
-            WaitHandle.WaitAny(new WaitHandle[] { _responseReceivedEvent, ShutdownEvent });
+            WaitHandle.WaitAny([_responseReceivedEvent, ShutdownEvent]);
 
             // Keep track of the element location of the reference
             _lastResponse.ElementLocation = sdkReferenceLocation;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 252bf62ab14..cf2f12b58a2 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -349,7 +349,7 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
 
                 SetResolverState(submissionId, sdkResolver, context.State);
 
-                result ??= (SdkResult)resultFactory.IndicateFailure(new string[] { ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SDKResolverReturnedNull", sdkResolver.Name) }, Array.Empty<string>());
+                result ??= (SdkResult)resultFactory.IndicateFailure([ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SDKResolverReturnedNull", sdkResolver.Name)], []);
 
                 if (result.Success)
                 {
@@ -380,8 +380,8 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
                 results.Add(result);
             }
 
-            warnings = results.SelectMany(r => r.Warnings ?? Array.Empty<string>());
-            errors = results.SelectMany(r => r.Errors ?? Array.Empty<string>());
+            warnings = results.SelectMany(r => r.Warnings ?? []);
+            errors = results.SelectMany(r => r.Errors ?? []);
 
             sdkResult = new SdkResult(sdk, null, null);
             return false;
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index 927d696f2e9..7b4049f8905 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -137,7 +137,7 @@ public NodeEngineShutdownReason Run(out Exception shutdownException)
                 _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
                 _nodeEndpoint.Listen(this);
 
-                var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
+                WaitHandle[] waitHandles = [_shutdownEvent, _packetReceivedEvent];
 
                 // Get the current directory before doing work. We need this so we can restore the directory when the node shuts down.
                 _savedCurrentDirectory = NativeMethodsShared.GetCurrentDirectory();
diff --git a/src/Build/BackEnd/Node/NodeConfiguration.cs b/src/Build/BackEnd/Node/NodeConfiguration.cs
index 2caec69b11d..99ab53e2e70 100644
--- a/src/Build/BackEnd/Node/NodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/NodeConfiguration.cs
@@ -162,27 +162,20 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _buildParameters, BuildParameters.FactoryForDeserialization);
             translator.TranslateArray(ref _forwardingLoggers, LoggerDescription.FactoryForTranslation);
 #if FEATURE_APPDOMAIN
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
-            {
-                byte[] appDomainConfigBytes = null;
+            byte[] appDomainConfigBytes = null;
 
-                // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
-                if (translator.Mode == TranslationDirection.WriteToStream)
-                {
-                    appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
-                }
+            // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
+            }
 
-                translator.Translate(ref appDomainConfigBytes);
+            translator.Translate(ref appDomainConfigBytes);
 
-                if (translator.Mode == TranslationDirection.ReadFromStream)
-                {
-                    _appDomainSetup = new AppDomainSetup();
-                    _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
-                }
-            }
-            else
+            if (translator.Mode == TranslationDirection.ReadFromStream)
             {
-                translator.TranslateDotNet(ref _appDomainSetup);
+                _appDomainSetup = new AppDomainSetup();
+                _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
             }
 #endif
             translator.Translate(ref _loggingNodeConfiguration);
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index af13beb079d..5148f89be9f 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -250,7 +250,7 @@ public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exce
             _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
             _nodeEndpoint.Listen(this);
 
-            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
+            WaitHandle[] waitHandles = [_shutdownEvent, _packetReceivedEvent];
 
             // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.
             while (true)
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index d409d52d057..ab17e3b7ce1 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -139,7 +139,7 @@ private NodeEngineShutdownReason RunInternal(out Exception? shutdownException, S
             _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
             _nodeEndpoint.Listen(this);
 
-            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
+            WaitHandle[] waitHandles = [_shutdownEvent, _packetReceivedEvent];
 
             // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.
             while (true)
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 537998947d3..b3ce3e8eafd 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -380,7 +380,7 @@ public override BuildResultCode OverallResult
                     return BuildResultCode.Failure;
                 }
 
-                foreach (KeyValuePair<string, TargetResult> result in _resultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
+                foreach (KeyValuePair<string, TargetResult> result in _resultsByTarget ?? [])
                 {
                     if ((result.Value.ResultCode == TargetResultCode.Failure && !result.Value.TargetFailureDoesntCauseBuildFailure)
                         || result.Value.AfterTargetsHaveFailed)
@@ -549,7 +549,7 @@ internal void KeepSpecificTargetResults(IReadOnlyCollection<string> targetsToKee
                 targetsToKeep.Count > 0,
                 $"{nameof(targetsToKeep)} should contain at least one target.");
 
-            foreach (string target in _resultsByTarget?.Keys ?? Enumerable.Empty<string>())
+            foreach (string target in _resultsByTarget?.Keys ?? [])
             {
                 if (!targetsToKeep.Contains(target))
                 {
@@ -574,7 +574,7 @@ public void MergeResults(BuildResult results)
             }
 
             // Merge in the results
-            foreach (KeyValuePair<string, TargetResult> targetResult in results._resultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
+            foreach (KeyValuePair<string, TargetResult> targetResult in results._resultsByTarget ?? [])
             {
                 // NOTE: I believe that because we only allow results for a given target to be produced and cached once for a given configuration,
                 // we can never receive conflicting results for that target, since the cache and build request manager would always return the
@@ -696,7 +696,7 @@ internal static BuildResult FactoryForDeserialization(ITranslator translator)
         /// </summary>
         internal void CacheIfPossible()
         {
-            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
+            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget ?? [])
             {
                 targetResultPair.Value.CacheItems(ConfigurationId, targetResultPair.Key);
             }
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 1a2ba345658..e3a33a5e641 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -804,7 +804,7 @@ private ITaskItem[] GetItemOutputs(TaskPropertyInfo parameter)
 
             if (!(outputs is ITaskItem[] taskItemOutputs))
             {
-                taskItemOutputs = new[] { (ITaskItem)outputs };
+                taskItemOutputs = [(ITaskItem)outputs];
             }
 
             return taskItemOutputs;
@@ -1325,7 +1325,7 @@ private bool InternalSetTaskParameter(
                             parameterName: parameter.Name,
                             propertyName: null,
                             itemType: parameter.Name,
-                            parameterValueAsList ?? new object[] { parameterValue },
+                            parameterValueAsList ?? (object[])[parameterValue],
                             parameter.LogItemMetadata);
                     }
                 }
@@ -1486,7 +1486,7 @@ static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary c
                                     parameterName: parameter.Name,
                                     propertyName: outputTargetName,
                                     itemType: outputTargetName,
-                                    new object[] { outputString },
+                                    (object[])[outputString],
                                     parameter.LogItemMetadata);
                             }
                             else
@@ -1573,7 +1573,7 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                                     parameterName: parameter.Name,
                                     propertyName: outputTargetName,
                                     itemType: outputTargetName,
-                                    new object[] { outputString },
+                                    (object[])[outputString],
                                     parameter.LogItemMetadata);
                             }
                             else
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 9d65e00927a..d9ca747fc60 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -205,7 +205,7 @@ private void RunRegisteredActions<T>(
                     return;
                 }
 
-                configPerRule = new[] { commonConfig };
+                configPerRule = [commonConfig];
             }
             else
             {
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
index e0417966263..a811b61d973 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
@@ -81,7 +81,7 @@ internal static EditorConfigFile Parse(string text)
         // dictionary, but we also use a case-insensitive key comparer when doing lookups
         var activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>(StringComparer.OrdinalIgnoreCase);
         string activeSectionName = "";
-        var lines = string.IsNullOrEmpty(text) ? Array.Empty<string>() : text.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.None);
+        var lines = string.IsNullOrEmpty(text) ? [] : text.Split(["\r\n", "\n"], StringSplitOptions.None);
 
         foreach(var line in lines)
         {
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 97c8e269da4..a73df401565 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -469,7 +469,7 @@ internal string GetProjectGuidWithoutCurlyBrackets()
                 return null;
             }
 
-            return ProjectGuid.Trim(new char[] { '{', '}' });
+            return ProjectGuid.Trim(['{', '}']);
         }
 
         /// <summary>
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 7c8a7dcc867..4676638ed9f 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -1179,7 +1179,7 @@ private static void ParseAspNetCompilerProperty(
                 // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;"
                 if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
-                    string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+                    string[] projectReferenceEntries = propertyValue.Split([';'], StringSplitOptions.RemoveEmptyEntries);
 
                     foreach (string projectReferenceEntry in projectReferenceEntries)
                     {
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 33e382771f6..1cbb076827b 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -189,7 +189,7 @@ private SolutionProjectGenerator(
 
             if (targetNames != null)
             {
-                _targetNames = targetNames.Select(i => i.Split(new char[] { ':' }, 2, StringSplitOptions.RemoveEmptyEntries).Last()).ToList();
+                _targetNames = targetNames.Select(i => i.Split([':'], 2, StringSplitOptions.RemoveEmptyEntries).Last()).ToList();
             }
         }
 
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 031ce7a01a9..3998a51002f 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -1574,7 +1574,7 @@ public bool Build(string target, IEnumerable<ILogger> loggers)
         public bool Build(string target, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
             // targets may be null, but not an entry within it
-            string[] targets = (target == null) ? null : new[] { target };
+            string[] targets = (target == null) ? null : [target];
 
             return Build(targets, loggers, remoteLoggers);
         }
@@ -2627,7 +2627,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                 ImmutableArray<string> includeGlobStrings = includeGlobFragments.Select(f => f.TextFragment).ToImmutableArray();
                 var includeGlob = CompositeGlob.Create(includeGlobFragments.Select(f => f.ToMSBuildGlob()));
 
-                IEnumerable<string> excludeFragmentStrings = Enumerable.Empty<string>();
+                IEnumerable<string> excludeFragmentStrings = [];
                 IMSBuildGlob excludeGlob = null;
 
                 if (!string.IsNullOrEmpty(itemElement.Exclude))
@@ -2638,7 +2638,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                     excludeGlob = excludeItemspec.ToMSBuildGlob();
                 }
 
-                IEnumerable<string> removeFragmentStrings = Enumerable.Empty<string>();
+                IEnumerable<string> removeFragmentStrings = [];
                 IMSBuildGlob removeGlob = null;
 
                 if (removeElementCache.TryGetValue(itemElement.ItemType, out CumulativeRemoveElementData removeItemElement))
@@ -2763,7 +2763,7 @@ private static IEnumerable<ProjectItemElement> GetItemElementsThatMightAffectIte
                         itemElement.RemoveLocation == null);
 
                 // add the include operation that created the project item element
-                return new[] { item.Xml }.Concat(relevantElementsAfterInclude);
+                return [item.Xml, ..relevantElementsAfterInclude];
             }
 
             private static List<ProjectItemElement> GetItemElementsByType(IEnumerable<ProjectItemElement> itemElements, string itemType)
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index d3d70ef98de..8aabe516dc8 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -94,7 +94,7 @@ public string ItemType
         /// This is a read-only collection.
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
-        public IEnumerable<ProjectMetadata> Metadata => Link != null ? Link.Metadata : _metadata ?? Enumerable.Empty<ProjectMetadata>();
+        public IEnumerable<ProjectMetadata> Metadata => Link != null ? Link.Metadata : _metadata ?? [];
 
         /// <summary>
         /// Count of metadata on the item definition.
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index eee61cb02f5..cd1c1317069 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -730,7 +730,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, LoggingContext
                 Array.Sort<string>(defaultTasksFiles, StringComparer.OrdinalIgnoreCase);
                 return defaultTasksFiles;
             }
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
diff --git a/src/Build/Definition/ToolsetLocalReader.cs b/src/Build/Definition/ToolsetLocalReader.cs
index 33feee94720..dacbbb6e8b0 100644
--- a/src/Build/Definition/ToolsetLocalReader.cs
+++ b/src/Build/Definition/ToolsetLocalReader.cs
@@ -46,7 +46,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetPropertyDefinitions
 
         protected override IEnumerable<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion)
         {
-            return Enumerable.Empty<ToolsetPropertyDefinition>();
+            return [];
         }
 
         protected override Dictionary<string, ProjectImportPathMatch> GetProjectImportSearchPathsTable(string toolsVersion, string os)
@@ -56,7 +56,7 @@ protected override Dictionary<string, ProjectImportPathMatch> GetProjectImportSe
 
         protected override IEnumerable<string> GetSubToolsetVersions(string toolsVersion)
         {
-            return Enumerable.Empty<string>();
+            return [];
         }
     }
 }
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index 0cc16709f31..19bd5141017 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -75,7 +75,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> ToolsVersions
         {
             get
             {
-                string[] toolsVersionNames = Array.Empty<string>();
+                string[] toolsVersionNames = [];
                 try
                 {
                     RegistryKeyWrapper subKey = null;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 3152d850174..284b3486ed0 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -2152,7 +2152,7 @@ private static Stack<TransformFunction<S>> PrepareTransformStackFromMatch<S>(IEl
                     if (functionName == null)
                     {
                         functionName = "ExpandQuotedExpressionFunction";
-                        arguments = new string[] { function };
+                        arguments = [function];
                     }
                     else if (argumentsExpression != null)
                     {
@@ -3283,7 +3283,7 @@ internal Function(
                 _methodMethodName = methodName;
                 if (arguments == null)
                 {
-                    _arguments = Array.Empty<string>();
+                    _arguments = [];
                 }
                 else
                 {
@@ -3548,11 +3548,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                             // include $(MSBuildThisFileDirectory) as a parameter.
                             string startingDirectory = String.IsNullOrWhiteSpace(elementLocation.File) ? String.Empty : Path.GetDirectoryName(elementLocation.File);
 
-                            args = new[]
-                            {
-                                args[0],
-                                startingDirectory,
-                            };
+                            args = [args[0], startingDirectory];
                         }
                     }
 
@@ -5157,7 +5153,7 @@ private static void ConstructIndexerFunction(string expressionFunction, IElement
                 // If there are no arguments, then just create an empty array
                 if (String.IsNullOrEmpty(argumentsContent))
                 {
-                    functionArguments = Array.Empty<string>();
+                    functionArguments = [];
                 }
                 else
                 {
@@ -5231,7 +5227,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                     // It may be that there are '()' but no actual arguments content
                     if (argumentStartIndex == expressionFunction.Length - 1)
                     {
-                        functionArguments = Array.Empty<string>();
+                        functionArguments = [];
                     }
                     else
                     {
@@ -5241,7 +5237,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                         // If there are no arguments, then just create an empty array
                         if (string.IsNullOrEmpty(argumentsContent))
                         {
-                            functionArguments = Array.Empty<string>();
+                            functionArguments = [];
                         }
                         else
                         {
@@ -5264,7 +5260,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                         nextMethodIndex = indexerIndex;
                     }
 
-                    functionArguments = Array.Empty<string>();
+                    functionArguments = [];
 
                     if (nextMethodIndex > 0)
                     {
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 4a4a183d24f..da988bfdeaf 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -34,7 +34,7 @@ namespace Microsoft.Build.Evaluation
     internal static class IntrinsicFunctions
     {
 #pragma warning disable CA1416 // Platform compatibility: we'll only use this on Windows
-        private static readonly object[] DefaultRegistryViews = new object[] { RegistryView.Default };
+        private static readonly object[] DefaultRegistryViews = [RegistryView.Default];
 #pragma warning restore CA1416
 
         private static readonly Lazy<Regex> RegistrySdkRegex = new Lazy<Regex>(() => new Regex(@"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$", RegexOptions.IgnoreCase));
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index ce2c28494ff..30400c410f6 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -369,7 +369,7 @@ public IList<string> IntersectsWith(IReadOnlyDictionary<string, ItemDataCollecti
                 }
             }
 
-            return matches ?? Array.Empty<string>();
+            return matches ?? [];
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs b/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
index cdca2c31156..35faaad48df 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
@@ -65,7 +65,7 @@ protected static string GetElementOrConditionText(string description, Evaluation
             var outerXml = description;
             outerXml = outerXml.Replace(@"xmlns=""http://schemas.microsoft.com/developer/msbuild/2003""", "");
 
-            var newLineIndex = outerXml.IndexOfAny(new[] { '\r', '\n' });
+            var newLineIndex = outerXml.IndexOfAny(['\r', '\n']);
             return newLineIndex == -1 ? outerXml : outerXml.Remove(newLineIndex);
         }
 
@@ -75,12 +75,8 @@ protected static string GetElementOrConditionText(string description, Evaluation
         protected void AppendDefaultHeaderWithSeparator(StringBuilder stringBuilder, string separator)
         {
             stringBuilder.AppendLine(
-                string.Join(separator,
-                    new[]
-                    {
-                        "Id", "ParentId", "Pass", "File", "Line #", "Expression", "Inc (ms)", "Inc (%)", "Exc (ms)",
-                        "Exc (%)", "#", "Kind", "Bug"
-                    }));
+                string.Join(separator, ["Id", "ParentId", "Pass", "File", "Line #", "Expression", "Inc (ms)", "Inc (%)", "Exc (ms)",
+                        "Exc (%)", "#", "Kind", "Bug"]));
         }
 
         /// <summary>
diff --git a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
index d4b6a316964..9d259bda8c6 100644
--- a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
+++ b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
@@ -95,10 +95,10 @@ private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string sea
 #endif
             IEnumerable<string> directories = includeDirectories
                 ? _directoryCache.EnumerateDirectories(path, searchPattern, predicate, transform)
-                : Enumerable.Empty<string>();
+                : [];
             IEnumerable<string> files = includeFiles
                 ? _directoryCache.EnumerateFiles(path, searchPattern, predicate, transform)
-                : Enumerable.Empty<string>();
+                : [];
 
             return Enumerable.Concat(directories, files);
         }
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index da261545e94..e1173e46681 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -44,11 +44,7 @@ internal sealed class ProjectInterpretation
 
         public static ProjectInterpretation Instance = new ProjectInterpretation();
 
-        private ProjectInterpretation()
-        {
-        }
-
-        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] { (GlobalPropertiesModifier)ProjectReferenceGlobalPropertiesModifier }.ToImmutableList();
+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = [(GlobalPropertiesModifier)ProjectReferenceGlobalPropertiesModifier];
 
         internal enum ProjectType
         {
@@ -298,7 +294,7 @@ private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(Pr
                     project: outerBuild,
                     itemType: InnerBuildReferenceItemName,
                     includeEscaped: outerBuild.FullPath,
-                    directMetadata: new[] { new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}") },
+                    directMetadata: [new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}")],
                     definingFileEscaped: outerBuild.FullPath);
             }
         }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 29b00d51996..1419a53c6db 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -2151,7 +2151,7 @@ public bool Build(string target, IEnumerable<ILogger> loggers)
         /// </remarks>
         public bool Build(string target, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
-            string[] targets = (target == null) ? Array.Empty<string>() : new string[] { target };
+            string[] targets = (target == null) ? [] : [target];
 
             return Build(targets, loggers, remoteLoggers);
         }
@@ -2647,7 +2647,7 @@ internal bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<
 
             if (targets == null)
             {
-                targets = Array.Empty<string>();
+                targets = [];
             }
 
             BuildResult results;
@@ -2962,7 +2962,7 @@ private static ProjectInstance[] GenerateSolutionWrapperUsingOldOM(
                 };
                 ProjectInstance instance = new(projectRootElement, globalProperties, toolsVersion, buildParameters, loggingService, projectBuildEventContext, sdkResolverService, submissionId);
 
-                return new[] { instance };
+                return [instance];
             }
         }
 
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 2051107c8bd..d1d7ac3c678 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -122,7 +122,7 @@ public int MetadataCount
         /// <summary>
         /// Names of all metadata on this item definition
         /// </summary>
-        public IEnumerable<string> MetadataNames => _metadata == null ? Enumerable.Empty<string>() : _metadata.Keys;
+        public IEnumerable<string> MetadataNames => _metadata == null ? [] : _metadata.Keys;
 
         /// <summary>
         /// Implementation of IKeyed exposing the item type, so these
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index ce19ec7872f..ec5c67f344e 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1063,7 +1063,7 @@ public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
                 }
                 else
                 {
-                    return Enumerable.Empty<KeyValuePair<string, string>>();
+                    return [];
                 }
             }
 
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 20f381dda93..6130bc25264 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -483,9 +483,9 @@ private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplet
                 }
                 else
                 {
-                    exceptionMessageArgs = new string[] { _taskType.Type.Name,
+                    exceptionMessageArgs = [_taskType.Type.Name,
                         AssemblyUtilities.GetAssemblyLocation(_taskType.Type.GetTypeInfo().Assembly),
-                        string.Empty };
+                        string.Empty];
                 }
 
                 _taskLoggingContext.LogFatalError(taskHostTaskComplete.TaskException, new BuildEventFileInfo(_taskLocation), taskHostTaskComplete.TaskExceptionMessage, taskHostTaskComplete.TaskExceptionMessageArgs);
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 598819b3cd4..3618f4c1b14 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -664,7 +664,7 @@ private IEnumerable<RegisteredTaskRecord> GetRelevantOrderedRegistrations(Regist
 
             if (exactMatchRequired)
             {
-                return Enumerable.Empty<RegisteredTaskRecord>();
+                return [];
             }
 
             // look through all task declarations for partial matches
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index afda13dd6e5..59a7a4ef914 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -46,5 +46,6 @@ public enum BinaryLogRecordKind
         BuildCheckTracing,
         BuildCheckAcquisition,
         BuildSubmissionStarted,
+        BuildCanceled,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 0e07217a267..be4eaa2288d 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -78,6 +78,8 @@ public sealed class BinaryLogger : ILogger
         // version 23:
         //    - new record kinds: BuildCheckMessageEvent, BuildCheckWarningEvent, BuildCheckErrorEvent,
         //    BuildCheckTracingEvent, BuildCheckAcquisitionEvent, BuildSubmissionStartedEvent
+        // version 24:
+        //    - new record kind: BuildCanceledEventArgs
 
         // MAKE SURE YOU KEEP BuildEventArgsWriter AND StructuredLogViewer.BuildEventArgsWriter IN SYNC WITH THE CHANGES ABOVE.
         // Both components must stay in sync to avoid issues with logging or event handling in the products.
@@ -88,7 +90,7 @@ public sealed class BinaryLogger : ILogger
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 23;
+        internal const int FileFormatVersion = 24;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index dc7b097be1a..395263d6a53 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -325,6 +325,7 @@ void HandleError(FormatErrorMessage msgFactory, bool noThrow, ReaderErrorType re
                 BinaryLogRecordKind.BuildCheckError => ReadBuildErrorEventArgs(),
                 BinaryLogRecordKind.BuildCheckTracing => ReadBuildCheckTracingEventArgs(),
                 BinaryLogRecordKind.BuildCheckAcquisition => ReadBuildCheckAcquisitionEventArgs(),
+                BinaryLogRecordKind.BuildCanceled => ReadBuildCanceledEventArgs(),
                 _ => null
             };
 
@@ -634,8 +635,8 @@ private BuildEventArgs ReadBuildSubmissionStartedEventArgs()
             IDictionary<string, string>? globalProperties = null;
             globalProperties = ReadStringDictionary() ?? new Dictionary<string, string>();
 
-            var entryProjectsFullPath = ReadStringIEnumerable() ?? Enumerable.Empty<string>();
-            var targetNames = ReadStringIEnumerable() ?? Enumerable.Empty<string>();
+            var entryProjectsFullPath = ReadStringIEnumerable() ?? [];
+            var targetNames = ReadStringIEnumerable() ?? [];
             var flags = (BuildRequestDataFlags)ReadInt32();
             var submissionId = ReadInt32();
 
@@ -1275,6 +1276,15 @@ private BuildEventArgs ReadBuildCheckAcquisitionEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadBuildCanceledEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            var e = new BuildCanceledEventArgs(fields.Message);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
         /// <summary>
         /// For errors and warnings these 8 fields are written out explicitly
         /// (their presence is not marked as a bit in the flags). So we have to
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index f140698b70a..77121b29b21 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -187,6 +187,7 @@ Base types and inheritance ("EventArgs" suffix omitted):
                     BuildSubmissionStarted
                     BuildStarted
                     BuildFinished
+                    BuildCanceled
                     ProjectEvaluationStarted
                     ProjectEvaluationFinished
                 BuildError
@@ -215,6 +216,7 @@ private BinaryLogRecordKind WriteCore(BuildEventArgs e)
                 case BuildSubmissionStartedEventArgs buildSubmissionStarted: return Write(buildSubmissionStarted);
                 case BuildStartedEventArgs buildStarted: return Write(buildStarted);
                 case BuildFinishedEventArgs buildFinished: return Write(buildFinished);
+                case BuildCanceledEventArgs buildCanceled: return Write(buildCanceled);
                 case ProjectEvaluationStartedEventArgs projectEvaluationStarted: return Write(projectEvaluationStarted);
                 case ProjectEvaluationFinishedEventArgs projectEvaluationFinished: return Write(projectEvaluationFinished);
                 case BuildCheckTracingEventArgs buildCheckTracing: return Write(buildCheckTracing);
@@ -307,6 +309,13 @@ private BinaryLogRecordKind Write(BuildFinishedEventArgs e)
             return BinaryLogRecordKind.BuildFinished;
         }
 
+        private BinaryLogRecordKind Write(BuildCanceledEventArgs e)
+        {
+            WriteBuildEventArgsFields(e);
+
+            return BinaryLogRecordKind.BuildCanceled;
+        }
+
         private BinaryLogRecordKind Write(ProjectEvaluationStartedEventArgs e)
         {
             WriteBuildEventArgsFields(e, writeMessage: false);
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index de9c04f2c57..dd73599bec2 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -146,7 +146,7 @@ internal string[] ProjectCallStackFromProject(BuildEventContext e)
             // or the event is raised before the project started event
             if (startedEvent == null)
             {
-                return Array.Empty<string>();
+                return [];
             }
 
             List<ProjectStartedEventMinimumFields> projectStackTrace = GetProjectCallStack(e);
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 9fc62d7b964..82724a46b03 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -185,7 +185,7 @@ private static string[] GetFileList(
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
 
-            string[] fileList = Array.Empty<string>();
+            string[] fileList = [];
 
             // Used to properly detect and log drive enumerating wildcards when applicable.
             string excludeFileSpec = string.Empty;
@@ -200,7 +200,7 @@ private static string[] GetFileList(
             if (filespecMatchesLazyWildcard || (filespecHasNoWildCards && excludeSpecsAreEmpty))
             {
                 // Just return the original string.
-                fileList = new string[] { returnEscaped ? filespecEscaped : EscapingUtilities.UnescapeAll(filespecEscaped) };
+                fileList = [returnEscaped ? filespecEscaped : EscapingUtilities.UnescapeAll(filespecEscaped)];
             }
             else
             {
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 97ccb0de770..4e1f865bbae 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -66,7 +66,7 @@ public void Initialize(AssemblyName assemblyName, string assemblyFilePath)
             var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
             var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
             var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
-            ParseMethod = NuGetFramework.GetMethod("Parse", new Type[] { typeof(string) });
+            ParseMethod = NuGetFramework.GetMethod("Parse", [typeof(string)]);
             IsCompatibleMethod = NuGetFrameworkCompatibilityProvider.GetMethod("IsCompatible");
             DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, Array.Empty<object>());
             FrameworkProperty = NuGetFramework.GetProperty("Framework");
@@ -78,7 +78,7 @@ public void Initialize(AssemblyName assemblyName, string assemblyFilePath)
 
         private object Parse(string tfm)
         {
-            return ParseMethod.Invoke(null, new object[] { tfm });
+            return ParseMethod.Invoke(null, [tfm]);
         }
 
         public string GetTargetFrameworkIdentifier(string tfm)
@@ -105,7 +105,7 @@ public string GetTargetPlatformVersion(string tfm, int minVersionPartCount)
 
         public bool IsCompatible(string target, string candidate)
         {
-            return Convert.ToBoolean(IsCompatibleMethod.Invoke(DefaultCompatibilityProvider, new object[] { Parse(target), Parse(candidate) }));
+            return Convert.ToBoolean(IsCompatibleMethod.Invoke(DefaultCompatibilityProvider, [Parse(target), Parse(candidate)]));
         }
 
         private string GetNonZeroVersionParts(Version version, int minVersionPartCount)
@@ -143,7 +143,7 @@ public string FilterTargetFrameworks(string incoming, string filter)
 
             IEnumerable<(string originalTfm, object parsedTfm)> ParseTfms(string desiredTargetFrameworks)
             {
-                return desiredTargetFrameworks.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries).Select(tfm =>
+                return desiredTargetFrameworks.Split([';'], StringSplitOptions.RemoveEmptyEntries).Select(tfm =>
                 {
                     (string originalTfm, object parsedTfm) parsed = (tfm, Parse(tfm));
                     return parsed;
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index ebe70f61d8c..e946a3546a3 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -128,7 +128,7 @@ public virtual string[] GetValueNames()
         {
             try
             {
-                return Exists() ? WrappedKey.GetValueNames() : Array.Empty<string>();
+                return Exists() ? WrappedKey.GetValueNames() : [];
             }
             catch (Exception ex) when (!ExceptionHandling.NotExpectedRegistryException(ex))
             {
@@ -144,7 +144,7 @@ public virtual string[] GetSubKeyNames()
         {
             try
             {
-                return Exists() ? WrappedKey.GetSubKeyNames() : Array.Empty<string>();
+                return Exists() ? WrappedKey.GetSubKeyNames() : [];
             }
             catch (Exception ex) when (!ExceptionHandling.NotExpectedRegistryException(ex))
             {
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index f66c5bb3880..b12e865dfd1 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -125,7 +125,7 @@ public static SimpleVersion Parse(string input)
             return new SimpleVersion(major, minor, build, revision);
         }
 
-        private static readonly char[] s_semverSeparators = new char[] { '-', '+' };
+        private static readonly char[] s_semverSeparators = ['-', '+'];
 
         private static ReadOnlySpan<char> RemoveTrivia(string input)
         {
diff --git a/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs b/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs
new file mode 100644
index 00000000000..0ad43127a32
--- /dev/null
+++ b/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs
@@ -0,0 +1,41 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class BuildCanceledEventArgs_Tests
+    {
+        [Fact]
+        public void SerializationDeserializationTest()
+        {
+            var message = "message";
+            var datetime = DateTime.Today;
+
+            BuildCanceledEventArgs args = new(
+                message,
+                datetime
+                );
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter bw = new BinaryWriter(stream);
+            args.WriteToStream(bw);
+
+            stream.Position = 0;
+            using BinaryReader br = new BinaryReader(stream);
+            BuildCanceledEventArgs argDeserialized = new("m");
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+
+            argDeserialized.CreateFromStream(br, packetVersion);
+            argDeserialized.Message.ShouldBe(message);
+            argDeserialized.Timestamp.ShouldBe(datetime); 
+        }
+    }
+}
diff --git a/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs b/src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs
similarity index 97%
rename from src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs
rename to src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs
index 1db4853b515..199d2fc038d 100644
--- a/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs
@@ -12,7 +12,7 @@
 
 namespace Microsoft.Build.Framework.UnitTests
 {
-    public class BuildSubmissionStartedEventAgs_Tests
+    public class BuildSubmissionStartedEventArgs_Tests
     {
         [Fact]
         public void SerializationDeserializationTest()
diff --git a/src/Framework/AssemblyUtilities.cs b/src/Framework/AssemblyUtilities.cs
index eea490775a7..c7e1ac2473b 100644
--- a/src/Framework/AssemblyUtilities.cs
+++ b/src/Framework/AssemblyUtilities.cs
@@ -166,7 +166,7 @@ private static CultureInfo[] GetValidCultures()
 
             var allCulturesEnumValue = Enum.Parse(cultureTypesType, "AllCultures", true);
 
-            var cultures = s_cultureInfoGetCultureMethod.Invoke(null, new[] { allCulturesEnumValue }) as CultureInfo[];
+            var cultures = s_cultureInfoGetCultureMethod.Invoke(null, [allCulturesEnumValue]) as CultureInfo[];
 
             FrameworkErrorUtilities.VerifyThrowInternalNull(cultures, "CultureInfo.GetCultures should work if all reflection checks pass");
 
diff --git a/src/Framework/BuildSubmissionStartedEventArgs.cs b/src/Framework/BuildSubmissionStartedEventArgs.cs
index f77fdf8cfd0..3e42bbb142b 100644
--- a/src/Framework/BuildSubmissionStartedEventArgs.cs
+++ b/src/Framework/BuildSubmissionStartedEventArgs.cs
@@ -19,8 +19,8 @@ public sealed class BuildSubmissionStartedEventArgs : BuildStatusEventArgs
         public BuildSubmissionStartedEventArgs()
         {
             GlobalProperties = new Dictionary<string, string?>();
-            EntryProjectsFullPath = Enumerable.Empty<string>();
-            TargetNames = Enumerable.Empty<string>();
+            EntryProjectsFullPath = [];
+            TargetNames = [];
             Flags = BuildRequestDataFlags.None;
             SubmissionId = 0;
         }
diff --git a/src/Framework/FileClassifier.cs b/src/Framework/FileClassifier.cs
index 8f19fd39b81..2072633870b 100644
--- a/src/Framework/FileClassifier.cs
+++ b/src/Framework/FileClassifier.cs
@@ -85,7 +85,7 @@ private set
         /// <summary>
         ///     Copy on write snapshot of <see cref="_knownImmutableDirectories"/>.
         /// </summary>
-        private volatile IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();
+        private volatile IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = [];
 
         /// <summary>
         ///     Creates default FileClassifier which following immutable folders:
@@ -103,7 +103,7 @@ private set
         public FileClassifier()
         {
             // Register Microsoft "Reference Assemblies" as immutable
-            string[] programFilesEnvs = new[] { "ProgramFiles(x86)", "ProgramW6432", "ProgramFiles(Arm)" };
+            string[] programFilesEnvs = ["ProgramFiles(x86)", "ProgramW6432", "ProgramFiles(Arm)"];
             foreach (string programFilesEnv in programFilesEnvs)
             {
                 string? programFiles = Environment.GetEnvironmentVariable(programFilesEnv);
diff --git a/src/Framework/NullableAttributes.cs b/src/Framework/NullableAttributes.cs
index 4e46baa38f0..b6698fce618 100644
--- a/src/Framework/NullableAttributes.cs
+++ b/src/Framework/NullableAttributes.cs
@@ -99,7 +99,7 @@ internal sealed class MemberNotNullAttribute : Attribute
         /// <param name="member">
         /// The field or property member that is promised to be not-null.
         /// </param>
-        public MemberNotNullAttribute(string member) => Members = new[] { member };
+        public MemberNotNullAttribute(string member) => Members = [member];
 
         /// <summary>Initializes the attribute with the list of field and property members.</summary>
         /// <param name="members">
@@ -125,7 +125,7 @@ internal sealed class MemberNotNullWhenAttribute : Attribute
         public MemberNotNullWhenAttribute(bool returnValue, string member)
         {
             ReturnValue = returnValue;
-            Members = new[] { member };
+            Members = [member];
         }
 
         /// <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index 8dcf4330fb0..c8e0538eb25 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -303,7 +303,7 @@ public IEnumerable? Properties
                 // By doing this, we no longer need to transmit properties using this message because they've already
                 // been transmitted as part of the BuildRequestConfiguration.
                 return properties ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
-                    ? Enumerable.Empty<DictionaryEntry>()
+                    ? (DictionaryEntry[])[]
                     : null);
             }
         }
@@ -329,7 +329,7 @@ public IEnumerable? Items
                 // has likely not loaded this project, and therefore the live items would not be available to them, which is
                 // the same as the current functionality.
                 return items ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
-                    ? Enumerable.Empty<DictionaryEntry>()
+                    ? (DictionaryEntry[])[]
                     : null);
             }
         }
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 6cf235e8ab1..2558de02b41 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -423,26 +423,6 @@ public bool UnquoteTargetSwitchParameters
             }
         }
 
-        private bool? _isBinaryFormatterSerializationAllowed;
-        public bool IsBinaryFormatterSerializationAllowed
-        {
-            get
-            {
-                if (!_isBinaryFormatterSerializationAllowed.HasValue)
-                {
-#if RUNTIME_TYPE_NETCORE
-                    AppContext.TryGetSwitch("System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization",
-                        out bool enabled);
-                    _isBinaryFormatterSerializationAllowed = enabled;
-#else
-                    _isBinaryFormatterSerializationAllowed = true;
-#endif
-                }
-
-                return _isBinaryFormatterSerializationAllowed.Value;
-            }
-        }
-
 
         private static bool? ParseNullableBoolFromEnvironmentVariable(string environmentVariable)
         {
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 28c4fbd93b9..b192f584c19 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -213,24 +213,24 @@ internal ParameterizedSwitchInfo(
             //----------------------------------------------------------------------------------------------------------------------------------------------------------
             //                                          Switch Names                        Switch Id                             Dup Error  Light up key    resourceId
             //----------------------------------------------------------------------------------------------------------------------------------------------------------
-            new ParameterlessSwitchInfo(  new string[] { "help", "h", "?" },                         ParameterlessSwitch.Help,                  null,       "HelpMessage_4_HelpSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "version", "ver" },                         ParameterlessSwitch.Version,               null,       "HelpMessage_6_VersionSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "nologo" },                                 ParameterlessSwitch.NoLogo,                null,       "HelpMessage_5_NoLogoSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "noautoresponse", "noautorsp" },            ParameterlessSwitch.NoAutoResponse,        null,       "HelpMessage_8_NoAutoResponseSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "noconsolelogger", "noconlog" },            ParameterlessSwitch.NoConsoleLogger,       null,       "HelpMessage_14_NoConsoleLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger", "fl" },                       ParameterlessSwitch.FileLogger,            null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger1", "fl1" },                     ParameterlessSwitch.FileLogger1,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger2", "fl2" },                     ParameterlessSwitch.FileLogger2,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger3", "fl3" },                     ParameterlessSwitch.FileLogger3,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger4", "fl4" },                     ParameterlessSwitch.FileLogger4,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger5", "fl5" },                     ParameterlessSwitch.FileLogger5,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger6", "fl6" },                     ParameterlessSwitch.FileLogger6,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger7", "fl7" },                     ParameterlessSwitch.FileLogger7,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },                     ParameterlessSwitch.FileLogger8,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },                     ParameterlessSwitch.FileLogger9,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },           ParameterlessSwitch.DistributedFileLogger, null,       "HelpMessage_21_DistributedFileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["help", "h", "?"],                        ParameterlessSwitch.Help,                  null,       "HelpMessage_4_HelpSwitch"),
+            new ParameterlessSwitchInfo(  ["version", "ver"],                        ParameterlessSwitch.Version,               null,       "HelpMessage_6_VersionSwitch"),
+            new ParameterlessSwitchInfo(  ["nologo"],                                ParameterlessSwitch.NoLogo,                null,       "HelpMessage_5_NoLogoSwitch"),
+            new ParameterlessSwitchInfo(  ["noautoresponse", "noautorsp"],           ParameterlessSwitch.NoAutoResponse,        null,       "HelpMessage_8_NoAutoResponseSwitch"),
+            new ParameterlessSwitchInfo(  ["noconsolelogger", "noconlog"],           ParameterlessSwitch.NoConsoleLogger,       null,       "HelpMessage_14_NoConsoleLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger", "fl"],                      ParameterlessSwitch.FileLogger,            null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger1", "fl1"],                    ParameterlessSwitch.FileLogger1,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger2", "fl2"],                    ParameterlessSwitch.FileLogger2,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger3", "fl3"],                    ParameterlessSwitch.FileLogger3,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger4", "fl4"],                    ParameterlessSwitch.FileLogger4,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger5", "fl5"],                    ParameterlessSwitch.FileLogger5,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger6", "fl6"],                    ParameterlessSwitch.FileLogger6,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger7", "fl7"],                    ParameterlessSwitch.FileLogger7,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger8", "fl8"],                    ParameterlessSwitch.FileLogger8,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger9", "fl9"],                    ParameterlessSwitch.FileLogger9,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["distributedfilelogger", "dfl"],          ParameterlessSwitch.DistributedFileLogger, null,       "HelpMessage_21_DistributedFileLoggerSwitch"),
 #if DEBUG
-            new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },                 ParameterlessSwitch.WaitForDebugger,       null,       null),
+            new ParameterlessSwitchInfo(  ["waitfordebugger", "wfd"],                ParameterlessSwitch.WaitForDebugger,       null,       null),
 #endif
         };
 
@@ -241,62 +241,62 @@ internal ParameterizedSwitchInfo(
             //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
             //                                          Switch Names                            Switch Id                                       Duplicate Switch Error          Multi Params?   Missing Parameters Error           Unquote?    Empty?   reosurceId
             //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-            new ParameterizedSwitchInfo(  new string[] { null },                                ParameterizedSwitch.Project,                    "DuplicateProjectSwitchError",  false,          null,                                  true,   false,   null),
-            new ParameterizedSwitchInfo(  new string[] { "target", "t"},                        ParameterizedSwitch.Target,                     null,                           true,           "MissingTargetError",                  true,   false,   "HelpMessage_9_TargetSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "property", "p" },                     ParameterizedSwitch.Property,                   null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_10_PropertySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "logger", "l" },                       ParameterizedSwitch.Logger,                     null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_11_LoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "distributedlogger", "dl" },           ParameterizedSwitch.DistributedLogger,          null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_18_DistributedLoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "verbosity", "v" },                    ParameterizedSwitch.Verbosity,                  null,                           false,          "MissingVerbosityError",               true,   false,   "HelpMessage_12_VerbositySwitch"),
+            new ParameterizedSwitchInfo(  [null],                                ParameterizedSwitch.Project,                    "DuplicateProjectSwitchError",  false,          null,                                  true,   false,   null),
+            new ParameterizedSwitchInfo(  ["target", "t"],                       ParameterizedSwitch.Target,                     null,                           true,           "MissingTargetError",                  true,   false,   "HelpMessage_9_TargetSwitch"),
+            new ParameterizedSwitchInfo(  ["property", "p"],                    ParameterizedSwitch.Property,                   null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_10_PropertySwitch"),
+            new ParameterizedSwitchInfo(  ["logger", "l"],                      ParameterizedSwitch.Logger,                     null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_11_LoggerSwitch"),
+            new ParameterizedSwitchInfo(  ["distributedlogger", "dl"],          ParameterizedSwitch.DistributedLogger,          null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_18_DistributedLoggerSwitch"),
+            new ParameterizedSwitchInfo(  ["verbosity", "v"],                   ParameterizedSwitch.Verbosity,                  null,                           false,          "MissingVerbosityError",               true,   false,   "HelpMessage_12_VerbositySwitch"),
 #if FEATURE_XML_SCHEMA_VALIDATION
-            new ParameterizedSwitchInfo(  new string[] { "validate", "val" },                   ParameterizedSwitch.Validate,                   null,                           false,          null,                                  true,   false,   "HelpMessage_15_ValidateSwitch"),
+            new ParameterizedSwitchInfo(  ["validate", "val"],                  ParameterizedSwitch.Validate,                   null,                           false,          null,                                  true,   false,   "HelpMessage_15_ValidateSwitch"),
 #endif
-            new ParameterizedSwitchInfo(  new string[] { "consoleloggerparameters", "clp" },    ParameterizedSwitch.ConsoleLoggerParameters,    null,                           false,          "MissingConsoleLoggerParameterError",  true,   false,   "HelpMessage_13_ConsoleLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "nodemode", "nmode" },                 ParameterizedSwitch.NodeMode,                   null,                           false,          null,                                  false,  false,   null),
-            new ParameterizedSwitchInfo(  new string[] { "maxcpucount", "m" },                  ParameterizedSwitch.MaxCPUCount,                null,                           false,          "MissingMaxCPUCountError",             true,   false,   "HelpMessage_17_MaximumCPUSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "ignoreprojectextensions", "ignore" }, ParameterizedSwitch.IgnoreProjectExtensions,    null,                           true,           "MissingIgnoreProjectExtensionsError", true,   false,   "HelpMessage_19_IgnoreProjectExtensionsSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "toolsversion","tv" },                 ParameterizedSwitch.ToolsVersion,               null,                           false,          "MissingToolsVersionError",            true,   false,   "HelpMessage_23_ToolsVersionSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters", "flp" },       ParameterizedSwitch.FileLoggerParameters,       null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters1", "flp1" },     ParameterizedSwitch.FileLoggerParameters1,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters2", "flp2" },     ParameterizedSwitch.FileLoggerParameters2,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters3", "flp3" },     ParameterizedSwitch.FileLoggerParameters3,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters4", "flp4" },     ParameterizedSwitch.FileLoggerParameters4,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters5", "flp5" },     ParameterizedSwitch.FileLoggerParameters5,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters6", "flp6" },     ParameterizedSwitch.FileLoggerParameters6,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters7", "flp7" },     ParameterizedSwitch.FileLoggerParameters7,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters8", "flp8" },     ParameterizedSwitch.FileLoggerParameters8,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters9", "flp9" },     ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["consoleloggerparameters", "clp"],   ParameterizedSwitch.ConsoleLoggerParameters,    null,                           false,          "MissingConsoleLoggerParameterError",  true,   false,   "HelpMessage_13_ConsoleLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["nodemode", "nmode"],                ParameterizedSwitch.NodeMode,                   null,                           false,          null,                                  false,  false,   null),
+            new ParameterizedSwitchInfo(  ["maxcpucount", "m"],                 ParameterizedSwitch.MaxCPUCount,                null,                           false,          "MissingMaxCPUCountError",             true,   false,   "HelpMessage_17_MaximumCPUSwitch"),
+            new ParameterizedSwitchInfo(  ["ignoreprojectextensions", "ignore"],ParameterizedSwitch.IgnoreProjectExtensions,    null,                           true,           "MissingIgnoreProjectExtensionsError", true,   false,   "HelpMessage_19_IgnoreProjectExtensionsSwitch"),
+            new ParameterizedSwitchInfo(  ["toolsversion","tv"],                ParameterizedSwitch.ToolsVersion,               null,                           false,          "MissingToolsVersionError",            true,   false,   "HelpMessage_23_ToolsVersionSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters", "flp"],      ParameterizedSwitch.FileLoggerParameters,       null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters1", "flp1"],    ParameterizedSwitch.FileLoggerParameters1,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters2", "flp2"],    ParameterizedSwitch.FileLoggerParameters2,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters3", "flp3"],    ParameterizedSwitch.FileLoggerParameters3,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters4", "flp4"],    ParameterizedSwitch.FileLoggerParameters4,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters5", "flp5"],    ParameterizedSwitch.FileLoggerParameters5,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters6", "flp6"],    ParameterizedSwitch.FileLoggerParameters6,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters7", "flp7"],    ParameterizedSwitch.FileLoggerParameters7,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters8", "flp8"],    ParameterizedSwitch.FileLoggerParameters8,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters9", "flp9"],    ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
             // To not break existing use, keep supporting live logger switches
-            new ParameterizedSwitchInfo(  new string[] { "livelogger", "ll", "terminallogger", "tl" }, ParameterizedSwitch.TerminalLogger,      null,                           true,           null,                                  true,   true,    "HelpMessage_47_TerminalLoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "terminalloggerparameters", "tlp" },   ParameterizedSwitch.TerminalLoggerParameters,   null,                           false,          "MissingTerminalLoggerParameterError", true,   false,   "HelpMessage_48_TerminalLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["livelogger", "ll", "terminallogger", "tl"],ParameterizedSwitch.TerminalLogger,      null,                           true,           null,                                  true,   true,    "HelpMessage_47_TerminalLoggerSwitch"),
+            new ParameterizedSwitchInfo(  ["terminalloggerparameters", "tlp"],  ParameterizedSwitch.TerminalLoggerParameters,   null,                           false,          "MissingTerminalLoggerParameterError", true,   false,   "HelpMessage_48_TerminalLoggerParametersSwitch"),
 #if FEATURE_NODE_REUSE
-            new ParameterizedSwitchInfo(  new string[] { "nodereuse", "nr" },                   ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false,   "HelpMessage_24_NodeReuse"),
+            new ParameterizedSwitchInfo(  ["nodereuse", "nr"],                  ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false,   "HelpMessage_24_NodeReuse"),
 #endif
-            new ParameterizedSwitchInfo(  new string[] { "preprocess", "pp" },                  ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false,   "HelpMessage_25_PreprocessSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "targets", "ts" },                     ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false,   "HelpMessage_38_TargetsSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "warnaserror", "err" },                ParameterizedSwitch.WarningsAsErrors,           null,                           true,           null,                                  true,   true,    "HelpMessage_28_WarnAsErrorSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "warnnotaserror", "noerr" },           ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false,   "HelpMessage_40_WarnNotAsErrorSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "warnasmessage", "nowarn" },           ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false,   "HelpMessage_29_WarnAsMessageSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "binarylogger", "bl" },                ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false,   "HelpMessage_30_BinaryLoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "check", },                            ParameterizedSwitch.Check,                      null,                           false,          null,                                  true,   false,   "HelpMessage_52_BuildCheckSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "restore", "r" },                      ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false,   "HelpMessage_31_RestoreSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "profileevaluation", "prof" },         ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false,   "HelpMessage_32_ProfilerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_33_RestorePropertySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "interactive" },                       ParameterizedSwitch.Interactive,                null,                           false,          null,                                  true,   false,   "HelpMessage_34_InteractiveSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "isolateprojects", "isolate" },        ParameterizedSwitch.IsolateProjects,            null,                           false,          null,                                  true,   false,   "HelpMessage_35_IsolateProjectsSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           true,           null,                                  true,   false,   "HelpMessage_36_GraphBuildSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "inputResultsCaches", "irc" },         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true,    "HelpMessage_InputCachesFiles"),
-            new ParameterizedSwitchInfo(  new string[] { "outputResultsCache", "orc" },         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true,    "HelpMessage_OutputCacheFile"),
+            new ParameterizedSwitchInfo(  ["preprocess", "pp"],                 ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false,   "HelpMessage_25_PreprocessSwitch"),
+            new ParameterizedSwitchInfo(  ["targets", "ts"],                    ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false,   "HelpMessage_38_TargetsSwitch"),
+            new ParameterizedSwitchInfo(  ["warnaserror", "err"],               ParameterizedSwitch.WarningsAsErrors,           null,                           true,           null,                                  true,   true,    "HelpMessage_28_WarnAsErrorSwitch"),
+            new ParameterizedSwitchInfo(  ["warnnotaserror", "noerr"],          ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false,   "HelpMessage_40_WarnNotAsErrorSwitch"),
+            new ParameterizedSwitchInfo(  ["warnasmessage", "nowarn"],          ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false,   "HelpMessage_29_WarnAsMessageSwitch"),
+            new ParameterizedSwitchInfo(  ["binarylogger", "bl"],               ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false,   "HelpMessage_30_BinaryLoggerSwitch"),
+            new ParameterizedSwitchInfo(  ["check"],                             ParameterizedSwitch.Check,                      null,                           false,          null,                                  true,   false,   "HelpMessage_52_BuildCheckSwitch"),
+            new ParameterizedSwitchInfo(  ["restore", "r"],                     ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false,   "HelpMessage_31_RestoreSwitch"),
+            new ParameterizedSwitchInfo(  ["profileevaluation", "prof"],        ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false,   "HelpMessage_32_ProfilerSwitch"),
+            new ParameterizedSwitchInfo(  ["restoreproperty", "rp"],            ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_33_RestorePropertySwitch"),
+            new ParameterizedSwitchInfo(  ["interactive"],                      ParameterizedSwitch.Interactive,                null,                           false,          null,                                  true,   false,   "HelpMessage_34_InteractiveSwitch"),
+            new ParameterizedSwitchInfo(  ["isolateprojects", "isolate"],       ParameterizedSwitch.IsolateProjects,            null,                           false,          null,                                  true,   false,   "HelpMessage_35_IsolateProjectsSwitch"),
+            new ParameterizedSwitchInfo(  ["graphbuild", "graph"],              ParameterizedSwitch.GraphBuild,                 null,                           true,           null,                                  true,   false,   "HelpMessage_36_GraphBuildSwitch"),
+            new ParameterizedSwitchInfo(  ["inputResultsCaches", "irc"],        ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true,    "HelpMessage_InputCachesFiles"),
+            new ParameterizedSwitchInfo(  ["outputResultsCache", "orc"],        ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true,    "HelpMessage_OutputCacheFile"),
 #if FEATURE_REPORTFILEACCESSES
-            new ParameterizedSwitchInfo(  new string[] { "reportfileaccesses" },                ParameterizedSwitch.ReportFileAccesses,         null,                           false,          null,                                  true,   false,   "HelpMessage_42_ReportFileAccessesSwitch"),
+            new ParameterizedSwitchInfo(  ["reportfileaccesses"],               ParameterizedSwitch.ReportFileAccesses,         null,                           false,          null,                                  true,   false,   "HelpMessage_42_ReportFileAccessesSwitch"),
 #endif
-            new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false,   "HelpMessage_39_LowPrioritySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false,   "HelpMessage_41_QuestionSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false,   "HelpMessage_26_DetailedSummarySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "getProperty" },                       ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false,   "HelpMessage_43_GetPropertySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "getItem" },                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",                 true,   false,   "HelpMessage_44_GetItemSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "getTargetResult" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",         true,   false,   "HelpMessage_45_GetTargetResultSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "getResultOutputFile" },               ParameterizedSwitch.GetResultOutputFile,        null,                           true,           "MissingGetResultFileError",           true,   false,   "HelpMessage_51_GetResultOutputFileSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "featureAvailability", "fa" },         ParameterizedSwitch.FeatureAvailability,        null,                           true,           "MissingFeatureAvailabilityError",     true,   false,   "HelpMessage_46_FeatureAvailabilitySwitch")
+            new ParameterizedSwitchInfo(  ["lowpriority", "low"],               ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false,   "HelpMessage_39_LowPrioritySwitch"),
+            new ParameterizedSwitchInfo(  ["question", "q"],                    ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false,   "HelpMessage_41_QuestionSwitch"),
+            new ParameterizedSwitchInfo(  ["detailedsummary", "ds"],            ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false,   "HelpMessage_26_DetailedSummarySwitch"),
+            new ParameterizedSwitchInfo(  ["getProperty"],                      ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false,   "HelpMessage_43_GetPropertySwitch"),
+            new ParameterizedSwitchInfo(  ["getItem"],                          ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",                 true,   false,   "HelpMessage_44_GetItemSwitch"),
+            new ParameterizedSwitchInfo(  ["getTargetResult"],                  ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",         true,   false,   "HelpMessage_45_GetTargetResultSwitch"),
+            new ParameterizedSwitchInfo(  ["getResultOutputFile"],              ParameterizedSwitch.GetResultOutputFile,        null,                           true,           "MissingGetResultFileError",           true,   false,   "HelpMessage_51_GetResultOutputFileSwitch"),
+            new ParameterizedSwitchInfo(  ["featureAvailability", "fa"],        ParameterizedSwitch.FeatureAvailability,        null,                           true,           "MissingFeatureAvailabilityError",     true,   false,   "HelpMessage_46_FeatureAvailabilitySwitch")
         };
 
         /// <summary>
@@ -651,7 +651,7 @@ internal bool IsParameterizedSwitchSet(ParameterizedSwitch parameterizedSwitch)
         }
 
         // used to indicate a null parameter list for a switch
-        private static readonly string[] s_noParameters = Array.Empty<string>();
+        private static readonly string[] s_noParameters = [];
 
         /// <summary>
         /// Gets the parameters (if any) detected on the command line for the given parameterized switch.
@@ -745,7 +745,7 @@ private string[] GetSpecificFileLoggerParameters(ParameterlessSwitch parameterle
             }
             else if (IsParameterlessSwitchSet(parameterlessSwitch))
             {
-                result = Array.Empty<string>();
+                result = [];
             }
 
             return result;
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index 2cd1b34f072..d3502c8befd 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -125,7 +125,7 @@ internal OutOfProcTaskHostTaskResult ExecuteTask(
                                 TaskCompleteType.CrashedDuringInitialization,
                                 exceptionToReturn,
                                 "TaskInstantiationFailureError",
-                                new string[] { taskName, taskLocation, String.Empty });
+                                [taskName, taskLocation, String.Empty]);
             }
 
             OutOfProcTaskHostTaskResult taskResult;
@@ -142,7 +142,7 @@ internal OutOfProcTaskHostTaskResult ExecuteTask(
                                                     TaskCompleteType.CrashedDuringInitialization,
                                                     null,
                                                     "TaskInstantiationFailureNotSupported",
-                                                    new string[] { taskName, taskLocation, typeof(RunInSTAAttribute).FullName });
+                                                    [taskName, taskLocation, typeof(RunInSTAAttribute).FullName]);
 #endif
             }
             else
@@ -318,7 +318,7 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                     TaskCompleteType.CrashedDuringInitialization,
                     exceptionToReturn,
                     "TaskInstantiationFailureError",
-                    new string[] { taskName, taskLocation, String.Empty });
+                    [taskName, taskLocation, String.Empty]);
             }
 
             foreach (KeyValuePair<string, TaskParameter> param in taskParams)
@@ -335,7 +335,7 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                                 // If it's a TargetInvocationException, we only care about the contents of the inner exception, so save that instead.
                                 e is TargetInvocationException ? e.InnerException : e,
                                 "InvalidTaskAttributeError",
-                                new string[] { param.Key, param.Value.ToString(), taskName });
+                                [param.Key, param.Value.ToString(), taskName]);
                 }
             }
 
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 00b1333080b..02d83eca1c6 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -644,7 +644,7 @@ public NodeEngineShutdownReason Run(out Exception shutdownException)
             _nodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(OnLinkStatusChanged);
             _nodeEndpoint.Listen(this);
 
-            WaitHandle[] waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent, _taskCompleteEvent, _taskCancelledEvent };
+            WaitHandle[] waitHandles = [_shutdownEvent, _packetReceivedEvent, _taskCompleteEvent, _taskCancelledEvent];
 
             while (true)
             {
diff --git a/src/MSBuild/PerformanceLogEventListener.cs b/src/MSBuild/PerformanceLogEventListener.cs
index 4aaa1283384..3eb6090cd4b 100644
--- a/src/MSBuild/PerformanceLogEventListener.cs
+++ b/src/MSBuild/PerformanceLogEventListener.cs
@@ -22,15 +22,15 @@ internal struct ProviderConfiguration
             internal EventLevel Level { get; set; }
         }
 
-        private static ProviderConfiguration[] s_config = new ProviderConfiguration[]
-        {
+        private static ProviderConfiguration[] s_config =
+        [
             new ProviderConfiguration()
             {
                 Name = "Microsoft-Build",
                 Keywords = MSBuildEventSource.Keywords.PerformanceLog,
                 Level = EventLevel.Verbose
             }
-        };
+        ];
 
         private const string PerfLogDirEnvVar = "DOTNET_PERFLOG_DIR";
         private const char EventDelimiter = '\n';
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 8411c5408ba..c6e0ca436ba 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -684,7 +684,7 @@ public static ExitType Execute(
                 // process the detected command line switches -- gather build information, take action on non-build switches, and
                 // check for non-trivial errors
                 string projectFile = null;
-                string[] targets = Array.Empty<string>();
+                string[] targets = [];
                 string toolsVersion = null;
                 Dictionary<string, string> globalProperties = null;
                 Dictionary<string, string> restoreProperties = null;
@@ -717,9 +717,9 @@ public static ExitType Execute(
                 string outputResultsCache = null;
                 bool question = false;
                 bool isBuildCheckEnabled = false;
-                string[] getProperty = Array.Empty<string>();
-                string[] getItem = Array.Empty<string>();
-                string[] getTargetResult = Array.Empty<string>();
+                string[] getProperty = [];
+                string[] getItem = [];
+                string[] getTargetResult = [];
                 string getResultOutputFile = string.Empty;
                 BuildResult result = null;
 #if FEATURE_REPORTFILEACCESSES
@@ -1569,7 +1569,7 @@ internal static bool BuildProject(
 
                                 if (graphBuildOptions != null)
                                 {
-                                    graphBuildRequest = new GraphBuildRequestData(new[] { new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, flags, graphBuildOptions);
+                                    graphBuildRequest = new GraphBuildRequestData([new ProjectGraphEntryPoint(projectFile, globalProperties)], targets, null, flags, graphBuildOptions);
                                 }
                                 else
                                 {
@@ -1854,7 +1854,7 @@ private static BuildResult ExecuteRestore(string projectFile, string toolsVersio
                 projectFile,
                 restoreGlobalProperties,
                 toolsVersion,
-                targetsToBuild: new[] { MSBuildConstants.RestoreTargetName },
+                targetsToBuild: [MSBuildConstants.RestoreTargetName],
                 hostServices: null,
                 flags: flags);
 
@@ -2648,9 +2648,9 @@ private static bool ProcessCommandLineSwitches(
                     targets = ProcessTargetSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Target]);
 
                     // If we are looking for the value of a specific property or item post-evaluation or a target post-build, figure that out now
-                    getProperty = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetProperty] ?? Array.Empty<string>();
-                    getItem = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetItem] ?? Array.Empty<string>();
-                    getTargetResult = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetTargetResult] ?? Array.Empty<string>();
+                    getProperty = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetProperty] ?? [];
+                    getItem = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetItem] ?? [];
+                    getTargetResult = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetTargetResult] ?? [];
                     getResultOutputFile = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetResultOutputFile].FirstOrDefault() ?? string.Empty;
 
                     bool minimizeStdOutOutput = getProperty.Length + getItem.Length + getTargetResult.Length > 0 && getResultOutputFile.Length == 0;
@@ -3251,7 +3251,7 @@ private static ISet<string> ProcessWarningRelatedSwitch(CommandLineSwitches comm
             ISet<string> warningSwitches = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             foreach (string code in parameters
-                .SelectMany(parameter => parameter?.Split(s_commaSemicolon, StringSplitOptions.RemoveEmptyEntries) ?? new string[] { null }))
+                .SelectMany(parameter => parameter?.Split(s_commaSemicolon, StringSplitOptions.RemoveEmptyEntries) ?? [null]))
             {
                 if (code == null)
                 {
@@ -3526,7 +3526,7 @@ internal static string ProcessProjectSwitch(
             if (projectFile == null)
             {
                 ValidateExtensions(projectsExtensionsToIgnore);
-                HashSet<string> extensionsToIgnore = new HashSet<string>(projectsExtensionsToIgnore ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);
+                HashSet<string> extensionsToIgnore = new HashSet<string>(projectsExtensionsToIgnore ?? [], StringComparer.OrdinalIgnoreCase);
                 // Get all files in the current directory that have a proj-like extension
                 string[] potentialProjectFiles = getFiles(projectDirectory ?? ".", "*.*proj");
                 List<string> actualProjectFiles = new List<string>();
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 314301eec05..d9d361df7ba 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -119,8 +119,8 @@ public override string ToString()
 
         public virtual int[] RetrieveHandshakeComponents()
         {
-            return new int[]
-            {
+            return
+            [
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),
@@ -128,7 +128,7 @@ public virtual int[] RetrieveHandshakeComponents()
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)
-            };
+            ];
         }
 
         public virtual string GetKey() => $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}".ToString(CultureInfo.InvariantCulture);
@@ -152,15 +152,15 @@ internal ServerNodeHandshake(HandshakeOptions nodeType)
 
         public override int[] RetrieveHandshakeComponents()
         {
-            return new int[]
-            {
+            return
+            [
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),
-            };
+            ];
         }
 
         public override string GetKey()
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 27bdb7e93e3..c1e3d664d3e 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -119,7 +119,7 @@ private Assembly TryGetWellKnownAssembly(AssemblyLoadContext context, AssemblyNa
             // of the Microsoft.Build.* assembly.
             assemblyName.Version = _currentAssemblyVersion;
 
-            var searchPaths = new[] { Assembly.GetExecutingAssembly().Location };
+            string[] searchPaths = [Assembly.GetExecutingAssembly().Location];
             return TryResolveAssemblyFromPaths(context, assemblyName, searchPaths);
         }
 
@@ -145,14 +145,14 @@ private Assembly TryResolveAssembly(AssemblyLoadContext context, AssemblyName as
 
         private Assembly TryResolveAssemblyFromPaths(AssemblyLoadContext context, AssemblyName assemblyName, IEnumerable<string> searchPaths)
         {
-            foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
+            foreach (string cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
                 // If no culture is specified, attempt to load directly from
                 // the known dependency paths.
                 ? new[] { string.Empty }
                 // Search for satellite assemblies in culture subdirectories
                 // of the assembly search directories, but fall back to the
                 // bare search directory if that fails.
-                : new[] { assemblyName.CultureName, string.Empty })
+                : [assemblyName.CultureName, string.Empty])
             {
                 foreach (var searchPath in searchPaths)
                 {
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index ea3b9735314..10afb6c4d4d 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -128,7 +128,7 @@ public void Log(
 #if DEBUG
             var writer = GetWriter();
 
-            writer?.Invoke(_id, CallsiteString(sourceFilePath, memberName, sourceLineNumber), new[] { message });
+            writer?.Invoke(_id, CallsiteString(sourceFilePath, memberName, sourceLineNumber), [message]);
 #endif
         }
 
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 43fb3d65d16..4cda8fc8a4e 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -231,7 +231,7 @@ private static IReadOnlyList<string> GetAccessibleFileSystemEntries(IFileSystem
                     ErrorUtilities.ThrowInternalError("Unexpected filesystem entity type.");
                     break;
             }
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
@@ -266,7 +266,7 @@ private static IReadOnlyList<string> GetAccessibleFilesAndDirectories(IFileSyste
                 }
             }
 
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
@@ -354,12 +354,12 @@ private static IReadOnlyList<string> GetAccessibleFiles(
             catch (System.Security.SecurityException)
             {
                 // For code access security.
-                return Array.Empty<string>();
+                return [];
             }
             catch (System.UnauthorizedAccessException)
             {
                 // For OS security.
-                return Array.Empty<string>();
+                return [];
             }
         }
 
@@ -410,12 +410,12 @@ private static IReadOnlyList<string> GetAccessibleDirectories(
             catch (System.Security.SecurityException)
             {
                 // For code access security.
-                return Array.Empty<string>();
+                return [];
             }
             catch (System.UnauthorizedAccessException)
             {
                 // For OS security.
-                return Array.Empty<string>();
+                return [];
             }
         }
 
@@ -1042,7 +1042,7 @@ private IEnumerable<string> GetFilesForStep(
         {
             if (!stepResult.ConsiderFiles)
             {
-                return Enumerable.Empty<string>();
+                return [];
             }
 
             // Back-compat hack: We don't use case-insensitive file enumeration I/O on Linux so the behavior is different depending
@@ -2340,18 +2340,18 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
                     // - maintain legacy behaviour where an illegal filespec is treated as a normal string
                     if (FileUtilities.PathsEqual(filespecUnescaped, excludeSpec))
                     {
-                        return Array.Empty<string>();
+                        return [];
                     }
 
                     var match = Default.FileMatch(excludeSpec, filespecUnescaped);
 
                     if (match.isLegalFileSpec && match.isMatch)
                     {
-                        return Array.Empty<string>();
+                        return [];
                     }
                 }
             }
-            return new[] { filespecUnescaped };
+            return [filespecUnescaped];
         }
 
         /// <summary>
@@ -2377,7 +2377,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
 
             if (action == SearchAction.ReturnEmptyList)
             {
-                return (Array.Empty<string>(), action, string.Empty);
+                return ([], action, string.Empty);
             }
             else if (action == SearchAction.ReturnFileSpec)
             {
@@ -2385,7 +2385,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
             }
             else if (action == SearchAction.FailOnDriveEnumeratingWildcard)
             {
-                return (Array.Empty<string>(), action, string.Empty);
+                return ([], action, string.Empty);
             }
             else if ((action != SearchAction.RunSearch) && (action != SearchAction.LogDriveEnumeratingWildcard))
             {
@@ -2430,7 +2430,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
                     }
                     else if (excludeAction == SearchAction.FailOnDriveEnumeratingWildcard)
                     {
-                        return (Array.Empty<string>(), excludeAction, excludeSpec);
+                        return ([], excludeAction, excludeSpec);
                     }
                     else if (excludeAction == SearchAction.LogDriveEnumeratingWildcard)
                     {
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index fe1b7c6e2b0..d2d6108add8 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -91,27 +91,27 @@ public static bool GetIsFileSystemCaseSensitive()
         /// Copied from https://github.com/dotnet/corefx/blob/056715ff70e14712419d82d51c8c50c54b9ea795/src/Common/src/System/IO/PathInternal.Windows.cs#L61
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/dotnet/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-        internal static readonly char[] InvalidPathChars = new char[]
-        {
+        internal static readonly char[] InvalidPathChars =
+        [
             '|', '\0',
             (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10,
             (char)11, (char)12, (char)13, (char)14, (char)15, (char)16, (char)17, (char)18, (char)19, (char)20,
             (char)21, (char)22, (char)23, (char)24, (char)25, (char)26, (char)27, (char)28, (char)29, (char)30,
             (char)31
-        };
+        ];
 
         /// <summary>
         /// Copied from https://github.com/dotnet/corefx/blob/387cf98c410bdca8fd195b28cbe53af578698f94/src/System.Runtime.Extensions/src/System/IO/Path.Windows.cs#L18
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/dotnet/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-        internal static readonly char[] InvalidFileNameChars = new char[]
-        {
+        internal static readonly char[] InvalidFileNameChars =
+        [
             '\"', '<', '>', '|', '\0',
             (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10,
             (char)11, (char)12, (char)13, (char)14, (char)15, (char)16, (char)17, (char)18, (char)19, (char)20,
             (char)21, (char)22, (char)23, (char)24, (char)25, (char)26, (char)27, (char)28, (char)29, (char)30,
             (char)31, ':', '*', '?', '\\', '/'
-        };
+        ];
 
         internal static readonly char[] Slashes = { '/', '\\' };
 
@@ -361,7 +361,7 @@ internal static string TrimAndStripAnyQuotes(string path)
 
             // Trim returns the same string if trimming isn't needed
             path = path.Trim();
-            path = path.Trim(new char[] { '"' });
+            path = path.Trim(['"']);
 
             return path;
         }
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 51d551eef38..4107d4b4197 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -148,8 +148,8 @@ internal static class FrameworkLocationHelper
         /// <summary>
         /// List the supported .net versions.
         /// </summary>
-        private static DotNetFrameworkSpec[] DotNetFrameworkSpecs() => new DotNetFrameworkSpec[]
-        {
+        private static DotNetFrameworkSpec[] DotNetFrameworkSpecs() =>
+        [
             // v1.1
             new DotNetFrameworkSpecLegacy(
                 dotNetFrameworkVersion11,
@@ -223,7 +223,7 @@ internal static class FrameworkLocationHelper
 
             // v4.8.1
             CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion481, visualStudioVersion170),
-        };
+        ];
 
         /// <summary>
         /// List the supported visual studio versions.
@@ -231,30 +231,30 @@ internal static class FrameworkLocationHelper
         /// <remarks>
         /// The items must be ordered by the version, because some methods depend on that fact to find the previous visual studio version.
         /// </remarks>
-        private static readonly Lazy<VisualStudioSpec[]> VisualStudioSpecs = new(() => new VisualStudioSpec[]
-        {
+        private static readonly Lazy<VisualStudioSpec[]> VisualStudioSpecs = new(() =>
+        [
             // VS10
-            new VisualStudioSpec(visualStudioVersion100, "Windows\\v7.0A", null, null, new []
-            {
+            new VisualStudioSpec(visualStudioVersion100, "Windows\\v7.0A", null, null,
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
                 dotNetFrameworkVersion40,
-            }),
+            ]),
 
             // VS11
-            new VisualStudioSpec(visualStudioVersion110, "Windows\\v8.0A", "v8.0", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion110, "Windows\\v8.0A", "v8.0", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
                 dotNetFrameworkVersion40,
                 dotNetFrameworkVersion45,
-            }),
+            ]),
 
             // VS12
-            new VisualStudioSpec(visualStudioVersion120, "Windows\\v8.1A", "v8.1", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion120, "Windows\\v8.1A", "v8.1", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -262,11 +262,11 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion45,
                 dotNetFrameworkVersion451,
                 dotNetFrameworkVersion452,
-            }),
+            ]),
 
             // VS14
-            new VisualStudioSpec(visualStudioVersion140, "NETFXSDK\\{0}", "v8.1", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion140, "NETFXSDK\\{0}", "v8.1", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -276,11 +276,11 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion452,
                 dotNetFrameworkVersion46,
                 dotNetFrameworkVersion461,
-            }),
+            ]),
 
             // VS15
-            new VisualStudioSpec(visualStudioVersion150, "NETFXSDK\\{0}", "v8.1", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion150, "NETFXSDK\\{0}", "v8.1", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -295,11 +295,11 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion471,
                 dotNetFrameworkVersion472,
                 dotNetFrameworkVersion48,
-            }),
+            ]),
 
             // VS16
-            new VisualStudioSpec(visualStudioVersion160, "NETFXSDK\\{0}", "v10.0", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion160, "NETFXSDK\\{0}", "v10.0", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -314,11 +314,11 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion471,
                 dotNetFrameworkVersion472,
                 dotNetFrameworkVersion48,
-            }),
+            ]),
 
             // VS17
-            new VisualStudioSpec(visualStudioVersion170, "NETFXSDK\\{0}", "v10.0", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion170, "NETFXSDK\\{0}", "v10.0", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -334,8 +334,8 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion472,
                 dotNetFrameworkVersion48,
                 dotNetFrameworkVersion481,
-            }),
-        });
+            ]),
+        ]);
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 4caf4874652..650b62c2a1b 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -244,6 +244,11 @@ internal enum LoggingEventType : int
         /// Event is <see cref="BuildSubmissionStartedEventArgs"/>.
         /// </summary>
         BuildSubmissionStartedEvent = 40,
+
+        /// <summary>
+        /// Event is <see cref="BuildCanceledEventArgs"/>
+        /// </summary>
+        BuildCanceledEvent = 41,
     }
     #endregion
 
@@ -656,6 +661,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.BuildCheckTracingEvent => new BuildCheckTracingEventArgs(),
                 LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
                 LoggingEventType.BuildSubmissionStartedEvent => new BuildSubmissionStartedEventArgs(),
+                LoggingEventType.BuildCanceledEvent => new BuildCanceledEventArgs("Build canceled."),
 #endif
                 _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
             };
@@ -799,6 +805,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildSubmissionStartedEvent;
             }
+            else if (eventType == typeof(BuildCanceledEventArgs))
+            {
+                return LoggingEventType.BuildCanceledEvent;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
@@ -1414,7 +1424,7 @@ private IEnumerable ReadProperties(ITranslator translator)
             int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
             if (count == 0)
             {
-                return Enumerable.Empty<DictionaryEntry>();
+                return (DictionaryEntry[])[];
             }
 
             var list = new ArrayList(count);
@@ -1436,7 +1446,7 @@ private IEnumerable ReadItems(ITranslator translator)
             int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
             if (count == 0)
             {
-                return Enumerable.Empty<DictionaryEntry>();
+                return (DictionaryEntry[])[];
             }
 
             var list = new ArrayList(count);
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index e2ebdff4f85..7427c5ed735 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -22,14 +22,13 @@ internal class MSBuildLoadContext : AssemblyLoadContext
         private readonly string _directory;
 
         internal static readonly ImmutableHashSet<string> WellKnownAssemblyNames =
-            new[]
-            {
-                "MSBuild",
-                "Microsoft.Build",
-                "Microsoft.Build.Framework",
-                "Microsoft.Build.Tasks.Core",
-                "Microsoft.Build.Utilities.Core",
-            }.ToImmutableHashSet();
+        [
+            "MSBuild",
+            "Microsoft.Build",
+            "Microsoft.Build.Framework",
+            "Microsoft.Build.Tasks.Core",
+            "Microsoft.Build.Utilities.Core",
+        ];
 
         public MSBuildLoadContext(string assemblyPath)
             : base($"MSBuild plugin {assemblyPath}")
@@ -69,11 +68,11 @@ public MSBuildLoadContext(string assemblyPath)
             foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
                 // If no culture is specified, attempt to load directly from
                 // the known dependency paths.
-                ? new[] { string.Empty }
+                ? (string[])[string.Empty]
                 // Search for satellite assemblies in culture subdirectories
                 // of the assembly search directories, but fall back to the
                 // bare search directory if that fails.
-                : new[] { assemblyName.CultureName, string.Empty })
+                : [assemblyName.CultureName, string.Empty])
             {
                 var candidatePath = Path.Combine(_directory,
                     cultureSubfolder,
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 8783318b2e5..55cfb842bdf 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -531,13 +531,15 @@ private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
             {
                 // Ordering is important.  We want packetAvailable to supercede terminate otherwise we will not properly wait for all
                 // packets to be sent by other threads which are shutting down, such as the logging thread.
-                WaitHandle[] handles = new WaitHandle[] {
+                WaitHandle[] handles =
+                [
 #if FEATURE_APM
                     result.AsyncWaitHandle,
 #else
                     ((IAsyncResult)readTask).AsyncWaitHandle,
 #endif
-                    localPacketAvailable, localTerminatePacketPump };
+                    localPacketAvailable, localTerminatePacketPump
+                ];
 
                 int waitId = WaitHandle.WaitAny(handles);
                 switch (waitId)
diff --git a/src/Shared/StrongNameHelpers.cs b/src/Shared/StrongNameHelpers.cs
index ac9476181eb..b6ba9a50cc3 100644
--- a/src/Shared/StrongNameHelpers.cs
+++ b/src/Shared/StrongNameHelpers.cs
@@ -45,11 +45,10 @@ private static IClrStrongName StrongName
                     if (s_GetRuntimeInterfaceAsObjectMethod != null)
                     {
                         s_StrongName = (IClrStrongName)s_GetRuntimeInterfaceAsObjectMethod.Invoke(null,
-                            new object[]
-                            {
+                            [
                                 new Guid("B79B0ACD-F5CD-409b-B5A5-A16244610B92"),
                                 new Guid("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")
-                            });
+                            ]);
                     }
                 }
                 return s_StrongName;
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 9a9c199f732..723a4ba240b 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -417,27 +417,20 @@ public void Translate(ITranslator translator)
             translator.TranslateCulture(ref _culture);
             translator.TranslateCulture(ref _uiCulture);
 #if FEATURE_APPDOMAIN
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
-            {
-                byte[] appDomainConfigBytes = null;
+            byte[] appDomainConfigBytes = null;
 
-                // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
-                if (translator.Mode == TranslationDirection.WriteToStream)
-                {
-                    appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
-                }
+            // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
+            }
 
-                translator.Translate(ref appDomainConfigBytes);
+            translator.Translate(ref appDomainConfigBytes);
 
-                if (translator.Mode == TranslationDirection.ReadFromStream)
-                {
-                    _appDomainSetup = new AppDomainSetup();
-                    _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
-                }
-            }
-            else
+            if (translator.Mode == TranslationDirection.ReadFromStream)
             {
-                translator.TranslateDotNet(ref _appDomainSetup);
+                _appDomainSetup = new AppDomainSetup();
+                _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
             }
 #endif
             translator.Translate(ref _lineNumberOfTask);
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 187a7a43e4b..79e0ea37008 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -1003,12 +1003,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
             {
                 if (_customEscapedMetadata == null || _customEscapedMetadata.Count == 0)
                 {
-#if TASKHOST
-                    // MSBuildTaskHost.dll compiles against .NET 3.5 which doesn't have Enumerable.Empty()
-                    return new KeyValuePair<string, string>[0];
-#else
-                    return Enumerable.Empty<KeyValuePair<string, string>>();
-#endif
+                    return [];
                 }
 
                 var result = new KeyValuePair<string, string>[_customEscapedMetadata.Count];
diff --git a/src/Tasks/Al.cs b/src/Tasks/Al.cs
index 0b587df5b74..d1872e4fb39 100644
--- a/src/Tasks/Al.cs
+++ b/src/Tasks/Al.cs
@@ -356,17 +356,17 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
             commandLine.AppendSwitchIfNotNull("/win32icon:", Win32Icon);
             commandLine.AppendSwitchIfNotNull("/win32res:", Win32Resource);
 
-            commandLine.AppendSwitchIfNotNull("", SourceModules, new[] { "TargetFile" });
+            commandLine.AppendSwitchIfNotNull("", SourceModules, ["TargetFile"]);
 
             commandLine.AppendSwitchIfNotNull(
                 "/embed:",
                 EmbedResources,
-                new[] { "LogicalName", "Access" });
+                ["LogicalName", "Access"]);
 
             commandLine.AppendSwitchIfNotNull(
                 "/link:",
                 LinkResources,
-                new[] { "LogicalName", "TargetFile", "Access" });
+                ["LogicalName", "TargetFile", "Access"]);
 
             // It's a good idea for the response file to be the very last switch passed, just
             // from a predictability perspective.  This is also consistent with the compiler
diff --git a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
index d9803997df2..b7352e6b255 100644
--- a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
+++ b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
@@ -140,7 +140,7 @@ internal IEnumerable<AssemblyEntry> FindAssemblyNameFromSimpleName(string simple
         {
             if (_redistList == null)
             {
-                return Enumerable.Empty<AssemblyEntry>();
+                return [];
             }
 
             return _redistList.FindAssemblyNameFromSimpleName(simpleName);
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index 5819184dc59..d9ba3671e32 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -40,7 +40,7 @@ internal sealed class Reference
         /// <summary>
         /// Scatter files associated with this reference.
         /// </summary>
-        private string[] _scatterFiles = Array.Empty<string>();
+        private string[] _scatterFiles = [];
 
         /// <summary>
         /// Any errors that occurred while resolving or finding dependencies on this item.
@@ -258,7 +258,7 @@ internal void AttachScatterFiles(string[] scatterFilesToAttach)
         {
             if (scatterFilesToAttach == null || scatterFilesToAttach.Length == 0)
             {
-                _scatterFiles = Array.Empty<string>();
+                _scatterFiles = [];
             }
             else
             {
@@ -500,7 +500,7 @@ internal string FullPath
 
                     if (string.IsNullOrEmpty(_fullPath))
                     {
-                        _scatterFiles = Array.Empty<string>();
+                        _scatterFiles = [];
                         _satelliteFiles = new List<string>();
                         _serializationAssemblyFiles = new List<string>();
                         AssembliesConsideredAndRejected = new List<ResolutionSearchLocation>();
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index b8cf7e10aa4..e353f56470a 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -46,7 +46,7 @@ internal sealed class ReferenceTable
         private readonly Dictionary<string, AssemblyNameExtension> _externallyResolvedImmutableFiles = new Dictionary<string, AssemblyNameExtension>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>The table of remapped assemblies. Used for Unification.</summary>
-        private IEnumerable<DependentAssembly> _remappedAssemblies = Enumerable.Empty<DependentAssembly>();
+        private IEnumerable<DependentAssembly> _remappedAssemblies = [];
 
         /// <summary>If true, then search for dependencies.</summary>
         private readonly bool _findDependencies;
@@ -817,7 +817,7 @@ private static void TryGetAssemblyNameComponent(string fusionName, string compon
                 return;
             }
             position += component.Length + 1;
-            int nextDelimiter = fusionName.IndexOfAny(new[] { ',', ' ' }, position);
+            int nextDelimiter = fusionName.IndexOfAny([',', ' '], position);
             if (nextDelimiter == -1)
             {
                 value = fusionName.Substring(position);
@@ -1290,7 +1290,7 @@ private void ResolveReference(
             // If a reference has the SDKName metadata on it then we will only search using a single resolver, that is the InstalledSDKResolver.
             if (reference.SDKName.Length > 0)
             {
-                jaggedResolvers.Add(new Resolver[] { new InstalledSDKResolver(_resolvedSDKReferences, "SDKResolver", _getAssemblyName, _fileExists, _getRuntimeVersion, _targetedRuntimeVersion) });
+                jaggedResolvers.Add([new InstalledSDKResolver(_resolvedSDKReferences, "SDKResolver", _getAssemblyName, _fileExists, _getRuntimeVersion, _targetedRuntimeVersion)]);
             }
             else
             {
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 75ea877da61..a0f8ea6bb75 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -175,11 +175,11 @@ internal static void Initialize(TaskLoggingHelper log)
         private ITaskItem[] _resolvedSDKReferences = Array.Empty<TaskItem>();
         private bool _ignoreDefaultInstalledAssemblyTables = false;
         private bool _ignoreDefaultInstalledAssemblySubsetTables = false;
-        private string[] _candidateAssemblyFiles = Array.Empty<string>();
-        private string[] _targetFrameworkDirectories = Array.Empty<string>();
-        private string[] _searchPaths = Array.Empty<string>();
-        private string[] _allowedAssemblyExtensions = new string[] { ".winmd", ".dll", ".exe" };
-        private string[] _relatedFileExtensions = new string[] { ".pdb", ".xml", ".pri" };
+        private string[] _candidateAssemblyFiles = [];
+        private string[] _targetFrameworkDirectories = [];
+        private string[] _searchPaths = [];
+        private string[] _allowedAssemblyExtensions = [".winmd", ".dll", ".exe"];
+        private string[] _relatedFileExtensions = [".pdb", ".xml", ".pri"];
         private string _appConfigFile = null;
         private bool _supportsBindingRedirectGeneration;
         private bool _autoUnify = false;
@@ -194,8 +194,8 @@ internal static void Initialize(TaskLoggingHelper log)
         private ITaskItem[] _copyLocalFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _suggestedRedirects = Array.Empty<TaskItem>();
         private List<ITaskItem> _unresolvedConflicts = new List<ITaskItem>();
-        private string[] _targetFrameworkSubsets = Array.Empty<string>();
-        private string[] _fullTargetFrameworkSubsetNames = Array.Empty<string>();
+        private string[] _targetFrameworkSubsets = [];
+        private string[] _fullTargetFrameworkSubsetNames = [];
         private string _targetedFrameworkMoniker = String.Empty;
 
         private bool _findDependencies = true;
@@ -211,8 +211,8 @@ internal static void Initialize(TaskLoggingHelper log)
         private string _targetProcessorArchitecture = null;
 
         private string _profileName = String.Empty;
-        private string[] _fullFrameworkFolders = Array.Empty<string>();
-        private string[] _latestTargetFrameworkDirectories = Array.Empty<string>();
+        private string[] _fullFrameworkFolders = [];
+        private string[] _latestTargetFrameworkDirectories = [];
         private bool _copyLocalDependenciesWhenParentReferenceInGac = true;
         private Dictionary<string, MessageImportance> _showAssemblyFoldersExLocations = new Dictionary<string, MessageImportance>(StringComparer.OrdinalIgnoreCase);
         private bool _logVerboseSearchResults = false;
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index e1923c87f9d..2b996326fc5 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -429,7 +429,7 @@ private List<string> ExtractReferencedAssemblies()
             {
                 XmlAttribute attribute = referenceNodes[i].Attributes["Include"];
 
-                bool hasInvalidChildNodes = HasInvalidChildNodes(referenceNodes[i], new[] { XmlNodeType.Comment, XmlNodeType.Whitespace });
+                bool hasInvalidChildNodes = HasInvalidChildNodes(referenceNodes[i], [XmlNodeType.Comment, XmlNodeType.Whitespace]);
 
                 if (hasInvalidChildNodes)
                 {
@@ -459,7 +459,7 @@ private List<string> ExtractUsingNamespaces()
             var usings = new List<string>();
             for (int i = 0; i < usingNodes.Count; i++)
             {
-                bool hasInvalidChildNodes = HasInvalidChildNodes(usingNodes[i], new[] { XmlNodeType.Comment, XmlNodeType.Whitespace });
+                bool hasInvalidChildNodes = HasInvalidChildNodes(usingNodes[i], [XmlNodeType.Comment, XmlNodeType.Whitespace]);
 
                 if (hasInvalidChildNodes)
                 {
@@ -509,7 +509,7 @@ private XmlNode ExtractTaskContent(string taskElementContents)
                 return null;
             }
 
-            bool hasInvalidChildNodes = HasInvalidChildNodes(codeNodes[0], new[] { XmlNodeType.Comment, XmlNodeType.Whitespace, XmlNodeType.Text, XmlNodeType.CDATA });
+            bool hasInvalidChildNodes = HasInvalidChildNodes(codeNodes[0], [XmlNodeType.Comment, XmlNodeType.Whitespace, XmlNodeType.Text, XmlNodeType.CDATA]);
 
             if (hasInvalidChildNodes)
             {
diff --git a/src/Tasks/CreateProperty.cs b/src/Tasks/CreateProperty.cs
index 7980feb2d14..d077411d58c 100644
--- a/src/Tasks/CreateProperty.cs
+++ b/src/Tasks/CreateProperty.cs
@@ -59,7 +59,7 @@ public override bool Execute()
         {
             if (Value == null)
             {
-                Value = Array.Empty<string>();
+                Value = [];
             }
 
             return true;
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index e37a9bcf300..aed8b824d4f 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -31,7 +31,7 @@ internal static class CultureInfoCache
         // These pseudo-locales are available in versions of Windows from Vista and later.
         // However, from Windows 10, version 1803, they are not returned when enumerating the
         // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.
-        private static readonly string[] pseudoLocales = new[] { "qps-ploc", "qps-ploca", "qps-plocm", "qps-Latn-x-sh" };
+        private static readonly string[] pseudoLocales = ["qps-ploc", "qps-ploca", "qps-plocm", "qps-Latn-x-sh"];
 
         private static HashSet<string> InitializeValidCultureNames()
         {
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index faa3df5e80e..67d44af7c62 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -579,7 +579,7 @@ private void LogResgenCommandLine(List<ITaskItem> inputFiles, List<ITaskItem> ou
                     if (!ExtractResWFiles)
                     {
                         commandLineBuilder.AppendFileNamesIfNotNull(
-                            new string[] { inputFiles[i].ItemSpec, outputFiles[i].ItemSpec },
+                            [inputFiles[i].ItemSpec, outputFiles[i].ItemSpec],
                             ",");
                     }
                     else
@@ -597,7 +597,7 @@ private void LogResgenCommandLine(List<ITaskItem> inputFiles, List<ITaskItem> ou
                 // append the strongly-typed resource details
                 commandLineBuilder.AppendSwitchIfNotNull(
                     "/str:",
-                    new string[] { StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName },
+                    [StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName],
                     ",");
             }
 
@@ -1238,7 +1238,7 @@ private int CalculateResourceBatchSize(List<ITaskItem> inputsToProcess, List<ITa
             while (currentCommand.Length < s_maximumCommandLength && i < inputsToProcess.Count)
             {
                 currentCommand.AppendFileNamesIfNotNull(
-                        new ITaskItem[] { inputsToProcess[i], outputsToProcess[i] },
+                        [inputsToProcess[i], outputsToProcess[i]],
                         ",");
                 i++;
             }
@@ -1705,7 +1705,7 @@ private void UpdateNewestUncorrelatedInputWriteTime()
 
             // Check the timestamp of each of the passed-in references to find the newest;
             // and then the additional inputs
-            var inputs = (this.References ?? Enumerable.Empty<ITaskItem>()).Concat(this.AdditionalInputs ?? Enumerable.Empty<ITaskItem>());
+            ITaskItem[] inputs = this.References ?? [..(this.AdditionalInputs ?? [])];
 
             foreach (ITaskItem input in inputs)
             {
@@ -2020,7 +2020,7 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
         /// <summary>
         /// Chars that should be ignored in the nicely justified block of base64
         /// </summary>
-        private static readonly char[] s_specialChars = new char[] { ' ', '\r', '\n' };
+        private static readonly char[] s_specialChars = [' ', '\r', '\n'];
 
         /// <summary>
         /// Turns the nicely justified block of base64 found in a resx into a byte array.
diff --git a/src/Tasks/GetAssembliesMetadata.cs b/src/Tasks/GetAssembliesMetadata.cs
index 520b979be03..73a3877001f 100644
--- a/src/Tasks/GetAssembliesMetadata.cs
+++ b/src/Tasks/GetAssembliesMetadata.cs
@@ -32,7 +32,7 @@ public class GetAssembliesMetadata : TaskExtension
         /// <summary>
         /// Assembly paths.
         /// </summary>
-        private string[] _assemblyPaths = Array.Empty<string>();
+        private string[] _assemblyPaths = [];
 
         /// <summary>
         /// Set of resolved assembly metadata.
diff --git a/src/Tasks/GetInstalledSDKLocations.cs b/src/Tasks/GetInstalledSDKLocations.cs
index e1d4bb966e7..05aa5d2a30f 100644
--- a/src/Tasks/GetInstalledSDKLocations.cs
+++ b/src/Tasks/GetInstalledSDKLocations.cs
@@ -169,8 +169,8 @@ public override bool Execute()
                     item.SetMetadata("PlatformVersion", sdk.Value.Item2);
 
                     // Need to stash these so we can unroll the platform via GetMatchingPlatformSDK when we get the reference files for the sdks
-                    item.SetMetadata(DirectoryRootsMetadataName, String.Join(";", SDKDirectoryRoots ?? Array.Empty<string>()));
-                    item.SetMetadata(ExtensionDirectoryRootsMetadataName, String.Join(";", SDKExtensionDirectoryRoots ?? Array.Empty<string>()));
+                    item.SetMetadata(DirectoryRootsMetadataName, String.Join(";", SDKDirectoryRoots ?? []));
+                    item.SetMetadata(ExtensionDirectoryRootsMetadataName, String.Join(";", SDKExtensionDirectoryRoots ?? []));
                     item.SetMetadata(RegistryRootMetadataName, SDKRegistryRoot);
 
                     outputItems.Add(item);
diff --git a/src/Tasks/GetReferenceAssemblyPaths.cs b/src/Tasks/GetReferenceAssemblyPaths.cs
index 621291acdac..50e3f54d4c4 100644
--- a/src/Tasks/GetReferenceAssemblyPaths.cs
+++ b/src/Tasks/GetReferenceAssemblyPaths.cs
@@ -65,7 +65,7 @@ public string[] ReferenceAssemblyPaths
                 }
                 else
                 {
-                    return Array.Empty<string>();
+                    return [];
                 }
             }
         }
@@ -87,7 +87,7 @@ public string[] FullFrameworkReferenceAssemblyPaths
                 }
                 else
                 {
-                    return Array.Empty<string>();
+                    return [];
                 }
             }
         }
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 2af5faaf3b8..b1a24a00d6a 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -1168,7 +1168,7 @@ private static IEnumerable<string> GetAllRedistDirectories(string sdkRoot)
                     return Directory.GetDirectories(redistPath, "*", SearchOption.AllDirectories);
                 }
 
-                return Enumerable.Empty<string>();
+                return [];
             }
 
             /// <summary>
@@ -1182,7 +1182,7 @@ private static IEnumerable<string> GetAllReferenceDirectories(string sdkRoot)
                     return Directory.GetDirectories(referencesPath, "*", SearchOption.AllDirectories);
                 }
 
-                return Enumerable.Empty<string>();
+                return [];
             }
         }
 
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index d1d6f8f7bc6..0bc42f56bfe 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -26,7 +26,7 @@ public class Hash : TaskExtension
     {
         private const char ItemSeparatorCharacter = '\u2028';
         private static readonly Encoding s_encoding = Encoding.UTF8;
-        private static readonly byte[] s_itemSeparatorCharacterBytes = s_encoding.GetBytes(new char[] { ItemSeparatorCharacter });
+        private static readonly byte[] s_itemSeparatorCharacterBytes = s_encoding.GetBytes([ItemSeparatorCharacter]);
 
         // Size of buffer where bytes of the strings are stored until sha.TransformBlock is to be run on them.
         // It is needed to get a balance between amount of costly sha.TransformBlock calls and amount of allocated memory.
diff --git a/src/Tasks/InstalledSDKResolver.cs b/src/Tasks/InstalledSDKResolver.cs
index 9fd40f7963e..b8f7d6a0b12 100644
--- a/src/Tasks/InstalledSDKResolver.cs
+++ b/src/Tasks/InstalledSDKResolver.cs
@@ -62,13 +62,13 @@ public override bool Resolve(
                     string referenceAssemblyPathNeutral = Path.Combine(sdkDirectory, "References", configuration, "Neutral");
                     string referenceAssemblyArchFilePathNeutral = Path.Combine(sdkDirectory, "References", "CommonConfiguration", "Neutral");
 
-                    string[] searchLocations = new string[]
-                    {
+                    string[] searchLocations =
+                    [
                         referenceAssemblyFilePath, // Config-Arch
                         referenceAssemblyPathNeutral, // Config-Neutral
                         referenceAssemblyCommonArchFilePath, // CommonArch-Config
                         referenceAssemblyArchFilePathNeutral // CommonArch-Neutral
-                    };
+                    ];
 
                     // Lets try and resovle from the windowsmetadata directory first
 
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index 9e78a48daf4..3169eaec219 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -460,7 +460,7 @@ internal static List<string[]> CreateTargetLists(string[] targets, bool runEachT
                 // Separate target invocations for each individual target.
                 foreach (string targetName in targets)
                 {
-                    targetLists.Add(new[] { targetName });
+                    targetLists.Add([targetName]);
                 }
             }
             else
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index 64af947c9d1..6328476020f 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -509,7 +509,7 @@ internal string Resolve(string[] searchPaths, bool specificVersion)
         {
             if (searchPaths == null)
             {
-                searchPaths = new[] { ".\\" };
+                searchPaths = [".\\"];
             }
 
             foreach (string searchPath in searchPaths)
diff --git a/src/Tasks/ManifestUtil/CngLightup.cs b/src/Tasks/ManifestUtil/CngLightup.cs
index 3ccb3de31b9..9df8266fb8e 100644
--- a/src/Tasks/ManifestUtil/CngLightup.cs
+++ b/src/Tasks/ManifestUtil/CngLightup.cs
@@ -558,7 +558,7 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
                 methodName,
                 BindingFlags.Public | BindingFlags.Static,
                 null,
-                new[] { typeof(X509Certificate2) },
+                [typeof(X509Certificate2)],
                 null);
 
             Debug.Assert(api != null, "Method '" + methodName + "(X509Certificate2 c)' not found on type '" + type + "'");
diff --git a/src/Tasks/ManifestUtil/ComImporter.cs b/src/Tasks/ManifestUtil/ComImporter.cs
index 084c04b607e..b4678e65365 100644
--- a/src/Tasks/ManifestUtil/ComImporter.cs
+++ b/src/Tasks/ManifestUtil/ComImporter.cs
@@ -125,7 +125,7 @@ public ComImporter(string path, OutputMessageCollection outputMessages, string o
 
         private void CheckForUnknownSubKeys(RegistryKey key)
         {
-            CheckForUnknownSubKeys(key, Array.Empty<string>());
+            CheckForUnknownSubKeys(key, []);
         }
 
         private void CheckForUnknownSubKeys(RegistryKey key, string[] knownNames)
@@ -144,7 +144,7 @@ private void CheckForUnknownSubKeys(RegistryKey key, string[] knownNames)
 
         private void CheckForUnknownValues(RegistryKey key)
         {
-            CheckForUnknownValues(key, Array.Empty<string>());
+            CheckForUnknownValues(key, []);
         }
 
         private void CheckForUnknownValues(RegistryKey key, string[] knownNames)
@@ -230,7 +230,7 @@ private bool GetRegisteredClassInfo(RegistryKey rootKey, Guid clsid, ref ClassIn
                     registeredPath = (string)subKey.GetValue(null);
                     threadingModel = (string)subKey.GetValue("ThreadingModel");
                     CheckForUnknownSubKeys(subKey);
-                    CheckForUnknownValues(subKey, new string[] { "ThreadingModel" });
+                    CheckForUnknownValues(subKey, ["ThreadingModel"]);
                 }
                 else if (String.Equals(subKeyName, "ProgID", StringComparison.OrdinalIgnoreCase))
                 {
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index b49395de0d6..a737ed59012 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -255,7 +255,7 @@ private static XmlElement GetCurrentCLRPermissions(string targetZone)
                 Internet => SecurityZone.Internet,
                 _ => throw new ArgumentException(String.Empty /* no message */, nameof(targetZone)),
             };
-            var evidence = new Evidence(new EvidenceBase[] { new Zone(zone), new System.Runtime.Hosting.ActivationArguments(new System.ApplicationIdentity("")) }, null);
+            var evidence = new Evidence([new Zone(zone), new System.Runtime.Hosting.ActivationArguments(new System.ApplicationIdentity(""))], null);
 
             PermissionSet sandbox = SecurityManager.GetStandardSandbox(evidence);
             string resultInString = sandbox.ToString();
@@ -455,7 +455,7 @@ private static string[] XmlToIdentityList(XmlElement psElement)
             }
             else
             {
-                a = Array.Empty<string>();
+                a = [];
             }
             return a;
         }
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 59e9f6c1ba5..111880e1d30 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -1334,7 +1334,7 @@ private void InitializeEnum(String assemblyName)
                     }
                     else
                     {
-                        _gacDirectories = Array.Empty<string>();
+                        _gacDirectories = [];
                     }
                 }
             }
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index c46d663bbb7..e94588e4264 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -215,7 +215,7 @@ public AssemblyNameExtension RemapAssembly(AssemblyNameExtension extensionToRema
         public static RedistList GetFrameworkList20()
         {
             string frameworkVersion20Path = ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20);
-            string[] redistListPaths = Array.Empty<string>();
+            string[] redistListPaths = [];
             if (frameworkVersion20Path != null)
             {
                 redistListPaths = RedistList.GetRedistListPathsFromDisk(frameworkVersion20Path);
@@ -255,7 +255,7 @@ public static RedistList GetFrameworkList35()
         /// </summary>
         public static RedistList GetRedistListFromPath(string path)
         {
-            string[] redistListPaths = (path == null) ? Array.Empty<string>() : GetRedistListPathsFromDisk(path);
+            string[] redistListPaths = (path == null) ? [] : GetRedistListPathsFromDisk(path);
 
             var assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
             for (int i = 0; i < redistListPaths.Length; ++i)
@@ -272,7 +272,7 @@ private static RedistList GetFrameworkListFromReferenceAssembliesPath(TargetDotN
 
             // On dogfood build machines, v3.5 is not formally installed, so this returns null.
             // We don't use redist lists in this case.
-            string[] redistListPaths = (referenceAssembliesPath == null) ? Array.Empty<string>() : GetRedistListPathsFromDisk(referenceAssembliesPath);
+            string[] redistListPaths = (referenceAssembliesPath == null) ? [] : GetRedistListPathsFromDisk(referenceAssembliesPath);
 
             var assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
             for (int i = 0; i < redistListPaths.Length; ++i)
@@ -317,7 +317,7 @@ public static string[] GetRedistListPathsFromDisk(string frameworkDirectory)
                 }
             }
 
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
@@ -1067,7 +1067,7 @@ public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
                 }
             }
 
-            return Array.Empty<string>();
+            return [];
         }
         #endregion
     }
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 614ed571685..4931ce4aa84 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -601,7 +601,7 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                             else
                             {
                                 resGenArguments.AppendFileNamesIfNotNull(
-                                    new[] { inputFiles[i], outputFiles[i] },
+                                    [inputFiles[i], outputFiles[i]],
                                     ",");
                             }
                         }
@@ -616,7 +616,7 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                     // append the strongly-typed resource details
                     resGenArguments.AppendSwitchIfNotNull(
                         "/str:",
-                        new[] { StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName },
+                        [StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName],
                         ",");
                 }
             }
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index b3a1bca439a..c8ba6d686f4 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -1297,7 +1297,7 @@ internal bool ResolveComReferencePia(ComReferenceInfo referenceInfo, string refN
         /// <returns></returns>
         internal IEnumerable<string> GetResolvedAssemblyReferenceItemSpecs()
         {
-            return (ResolvedAssemblyReferences == null) ? Array.Empty<string>() : ResolvedAssemblyReferences.Select(rar => rar.ItemSpec);
+            return (ResolvedAssemblyReferences == null) ? [] : ResolvedAssemblyReferences.Select(rar => rar.ItemSpec);
         }
 
         /// <summary>
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index f67cab5f410..80620581904 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -83,7 +83,7 @@ public string[] AdditionalSearchPaths
         public ITaskItem[] ContainedLooseEtcFiles { get; set; }
 
         private ITaskItem[] _nativeReferences;
-        private string[] _additionalSearchPaths = Array.Empty<string>();
+        private string[] _additionalSearchPaths = [];
         #endregion
 
         #region Nested classes
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index 0e458a48807..824bb439e46 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -561,7 +561,7 @@ internal SDKReference ParseSDKReference(ITaskItem referenceItem)
 
             if (!splitSuccessful)
             {
-                LogErrorOrWarning(new Tuple<string, object[]>("ResolveSDKReference.SDKReferenceIncorrectFormat", new object[] { referenceItem.ItemSpec }));
+                LogErrorOrWarning(new Tuple<string, object[]>("ResolveSDKReference.SDKReferenceIncorrectFormat", [referenceItem.ItemSpec]));
                 return null;
             }
 
@@ -613,7 +613,7 @@ private void LogResolution(SDKReference reference)
             else if (reference.ResolutionErrors == null || reference.ResolutionErrors.Count == 0)
             {
                 // We only want to say we could not find it if there were no other errors which would cause it not to be found
-                LogErrorOrWarning(new Tuple<string, object[]>("ResolveSDKReference.CouldNotResolveSDK", new object[] { reference.ReferenceItem.ItemSpec }));
+                LogErrorOrWarning(new Tuple<string, object[]>("ResolveSDKReference.CouldNotResolveSDK", [reference.ReferenceItem.ItemSpec]));
             }
 
             // Log warnings
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 05c2e50efe6..29ca1ce275f 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -366,15 +366,15 @@ internal static string[] ParseResxFileRefString(string stringValue)
                 string[] parts = remainingString.Split(';');
                 if (parts.Length > 1)
                 {
-                    result = new string[] { fileName, parts[0], parts[1] };
+                    result = [fileName, parts[0], parts[1]];
                 }
                 else if (parts.Length > 0)
                 {
-                    result = new string[] { fileName, parts[0] };
+                    result = [fileName, parts[0]];
                 }
                 else
                 {
-                    result = new string[] { fileName };
+                    result = [fileName];
                 }
             }
             return result;
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 7989a98917a..b2bac7f674a 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -737,7 +737,7 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
                     managedCompiler.Optimize = false;
                     managedCompiler.OutputAssembly = new TaskItem(assemblyPath);
                     managedCompiler.References = references;
-                    managedCompiler.Sources = new ITaskItem[] { new TaskItem(sourceCodePath) };
+                    managedCompiler.Sources = [new TaskItem(sourceCodePath)];
                     managedCompiler.TargetType = "Library";
                     managedCompiler.UseSharedCompilation = false;
 
diff --git a/src/Tasks/SGen.cs b/src/Tasks/SGen.cs
index 743cbf2eaf8..7be17cf5dc2 100644
--- a/src/Tasks/SGen.cs
+++ b/src/Tasks/SGen.cs
@@ -365,7 +365,7 @@ protected override string GenerateCommandLineCommands()
                 {
                     Debug.Assert(ShouldGenerateSerializer, "GenerateCommandLineCommands() should not be called if ShouldGenerateSerializer is true and SerializationAssembly is null.");
 
-                    SerializationAssembly = new ITaskItem[] { new TaskItem(SerializationAssemblyPath) };
+                    SerializationAssembly = [new TaskItem(SerializationAssemblyPath)];
                 }
 
                 // Add the assembly switch
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 7e1e971b48d..e44fbf5f2bf 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -102,7 +102,7 @@ internal static T DeserializeCache<T>(string stateFile, TaskLoggingHelper log) w
                             var parameters = constructor.GetParameters();
                             if (parameters.Length == 1 && parameters[0].ParameterType == typeof(ITranslator))
                             {
-                                retVal = constructor.Invoke(new object[] { translator }) as T;
+                                retVal = constructor.Invoke([translator]) as T;
                             }
                         }
 
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 6039813ba39..690308135f0 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -319,7 +319,7 @@ private void ParseIncludeExclude()
 
         private void ParsePattern(string pattern, out string[] patterns)
         {
-            patterns = Array.Empty<string>();
+            patterns = [];
             if (!string.IsNullOrWhiteSpace(pattern))
             {
                 if (FileMatcher.HasPropertyOrItemReferences(pattern))
@@ -334,8 +334,8 @@ private void ParsePattern(string pattern, out string[] patterns)
                 else
                 {
                     patterns = pattern.Contains(';')
-                                   ? pattern.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries).Select(FileMatcher.Normalize).ToArray()
-                                   : new[] { pattern };
+                                   ? pattern.Split([';'], StringSplitOptions.RemoveEmptyEntries).Select(FileMatcher.Normalize).ToArray()
+                                   : [pattern];
                 }
             }
         }
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 79efdf61495..ecfe9bad0d6 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -34,7 +34,7 @@ public class WriteCodeFragment : TaskExtension
     {
         private const string TypeNameSuffix = "_TypeName";
         private const string IsLiteralSuffix = "_IsLiteral";
-        private static readonly IEnumerable<string> NamespaceImports = new string[] { "System", "System.Reflection" };
+        private static readonly string[] NamespaceImports = ["System", "System.Reflection"];
         private static readonly IReadOnlyDictionary<string, ParameterType> EmptyParameterTypes = new Dictionary<string, ParameterType>();
 
         /// <summary>
diff --git a/src/Tasks/XamlTaskFactory/TaskGenerator.cs b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
index 38a2a4562e5..83d45753651 100644
--- a/src/Tasks/XamlTaskFactory/TaskGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
@@ -765,19 +765,19 @@ private void GenerateIntegers(Property property, CodeMemberProperty propertyName
             string name = property.SwitchName != String.Empty ? property.Prefix + property.SwitchName : property.Name;
             if (!String.IsNullOrEmpty(property.Min) && !String.IsNullOrEmpty(property.Max))
             {
-                parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodePrimitiveExpression(Int32.Parse(property.Min, CultureInfo.CurrentCulture)), new CodePrimitiveExpression(Int32.Parse(property.Max, CultureInfo.CurrentCulture)), new CodePropertySetValueReferenceExpression() };
+                parameters = [new CodeSnippetExpression(SurroundWithQuotes(name)), new CodePrimitiveExpression(Int32.Parse(property.Min, CultureInfo.CurrentCulture)), new CodePrimitiveExpression(Int32.Parse(property.Max, CultureInfo.CurrentCulture)), new CodePropertySetValueReferenceExpression()];
             }
             else if (!String.IsNullOrEmpty(property.Min))
             {
-                parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodePrimitiveExpression(Int32.Parse(property.Min, CultureInfo.CurrentCulture)), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression() };
+                parameters = [new CodeSnippetExpression(SurroundWithQuotes(name)), new CodePrimitiveExpression(Int32.Parse(property.Min, CultureInfo.CurrentCulture)), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression()];
             }
             else if (!String.IsNullOrEmpty(property.Max))
             {
-                parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodePrimitiveExpression(Int32.Parse(property.Max, CultureInfo.CurrentCulture)), new CodePropertySetValueReferenceExpression() };
+                parameters = [new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodePrimitiveExpression(Int32.Parse(property.Max, CultureInfo.CurrentCulture)), new CodePropertySetValueReferenceExpression()];
             }
             else
             {
-                parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression() };
+                parameters = [new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression()];
             }
 
             var validateInt = new CodeMethodReferenceExpression(new CodeThisReferenceExpression(), ValidateIntegerMethod);
@@ -896,9 +896,9 @@ private void GenerateStrings(Property property, CodeMemberProperty propertyName)
                     // The condition to test.
                     new CodeVariableReferenceExpression("i >= 0"),
                     // The statements to execute if the condition evaluates to true.
-                    new CodeStatement[] { setToolSwitchNameGoodIndex, setArgumentsGoodIndex },
+                    [setToolSwitchNameGoodIndex, setArgumentsGoodIndex],
                     // The statements to execute if the condition evalues to false.
-                    new CodeStatement[] { setToolSwitchNameBadIndex, setArgumentsBadIndex });
+                    [setToolSwitchNameBadIndex, setArgumentsBadIndex]);
 
                 propertyName.SetStatements.Add(conditionalStatement);
                 // Set the separator
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 342fb1f30b2..b2823627ffd 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -118,13 +118,12 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
             // create the code generator options
             // Since we are running msbuild 12.0 these had better load.
             var compilerParameters = new CompilerParameters(
-                new[]
-                {
+                [
                     "System.dll",
                     Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Framework.dll"),
                     Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Utilities.Core.dll"),
                     Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Tasks.Core.dll")
-                })
+                ])
             {
                 GenerateInMemory = true,
                 TreatWarningsAsErrors = false
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index f55532b9546..dd15d64cea9 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -292,7 +292,7 @@ public XmlInput(ITaskItem[] xmlFile, string xml)
                 else
                 {
                     XmlMode = XmlModes.Xml;
-                    _data = new[] { xml };
+                    _data = [xml];
                 }
             }
 
diff --git a/src/Tasks/system.design/stronglytypedresourcebuilder.cs b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
index 6f6bf7f491e..c43ddc11ad1 100644
--- a/src/Tasks/system.design/stronglytypedresourcebuilder.cs
+++ b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
@@ -71,10 +71,10 @@ internal static class StronglyTypedResourceBuilder
 
         // When fixing up identifiers, we will replace all these chars with
         // a single char that is valid in identifiers, such as '_'.
-        private static readonly char[] s_charsToReplace = new char[] { ' ',
+        private static readonly char[] s_charsToReplace = [' ',
         '\u00A0' /* non-breaking space */, '.', ',', ';', '|', '~', '@',
         '#', '%', '^', '&', '*', '+', '-', '/', '\\', '<', '>', '?', '[',
-        ']', '(', ')', '{', '}', '\"', '\'', ':', '!' };
+        ']', '(', ')', '{', '}', '\"', '\'', ':', '!'];
         private const char ReplacementChar = '_';
 
         private const String DocCommentSummaryStart = "<summary>";
diff --git a/src/Utilities/LockCheck.cs b/src/Utilities/LockCheck.cs
index c2de1dfaa65..7b191851e70 100644
--- a/src/Utilities/LockCheck.cs
+++ b/src/Utilities/LockCheck.cs
@@ -342,7 +342,7 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
                         // If pnProcInfo == 0, then there is simply no locking process (found), in this case rgAffectedApps is "null".
                         if (pnProcInfo == 0)
                         {
-                            return Enumerable.Empty<ProcessInfo>();
+                            return [];
                         }
 
                         var lockInfos = new List<ProcessInfo>((int)pnProcInfo);
@@ -371,7 +371,7 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
                 }
             }
 
-            return Enumerable.Empty<ProcessInfo>();
+            return [];
         }
 
         private static Exception GetException(int res, string apiName, string message)
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index dc1e8ee78ff..ab2c1fd9b9b 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -495,7 +495,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
         {
             if (_metadata == null)
             {
-                return Enumerable.Empty<KeyValuePair<string, string>>();
+                return [];
             }
 
             int count = _metadata.Count;
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 20510c33d8b..0ee514640fc 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -1060,7 +1060,7 @@ private static string[] GetLegacyTargetPlatformReferences(string targetPlatformI
                 ErrorUtilities.DebugTraceMessage("GetLegacyTargetPlatformReferences", "Encountered exception trying to gather the platform references: {0}", e.Message);
             }
 
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
@@ -1081,7 +1081,7 @@ private static string[] GetTargetPlatformReferencesFromManifest(
             ErrorUtilities.VerifyThrowArgumentLength(targetPlatformIdentifier, nameof(targetPlatformIdentifier));
             ErrorUtilities.VerifyThrowArgumentLength(targetPlatformVersion, nameof(targetPlatformVersion));
 
-            string[] contractWinMDs = Array.Empty<string>();
+            string[] contractWinMDs = [];
 
             TargetPlatformSDK matchingSdk = GetMatchingPlatformSDK(targetPlatformIdentifier, targetPlatformVersion, diskRoots, null, registryRoot);
             string platformKey = TargetPlatformSDK.GetSdkKey(targetPlatformIdentifier, targetPlatformVersion);
@@ -1119,7 +1119,7 @@ internal static string[] GetApiContractReferences(IEnumerable<ApiContract> apiCo
         {
             if (apiContracts == null)
             {
-                return Array.Empty<string>();
+                return [];
             }
 
             var contractWinMDs = new List<string>();
@@ -2479,7 +2479,7 @@ private static IEnumerable<TargetPlatformSDK> RetrieveTargetPlatformList(string[
                         GatherExtensionSDKListFromDirectory(extensionSdkDiskRoots, extensionSdk);
                         s_cachedExtensionSdks.Add(cachedExtensionSdksKey, extensionSdk);
                     }
-                    collection = collection.Concat(new[] { extensionSdk });
+                    collection = collection.Concat([extensionSdk]);
                 }
 
                 return collection;
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index c196b0afcc8..ae2f672a390 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -127,7 +127,7 @@ public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskI
         /// <param name="useMinimalRebuildOptimization">WARNING: Minimal rebuild optimization requires 100% accurate computed outputs to be specified!</param>
         /// <param name="maintainCompositeRootingMarkers">True to keep composite rooting markers around (many-to-one case) or false to shred them (one-to-one or one-to-many case)</param>
         public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem sourceFile, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)
-            => InternalConstruct(ownerTask, tlogFiles, new[] { sourceFile }, null, excludedInputPaths, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);
+            => InternalConstruct(ownerTask, tlogFiles, [sourceFile], null, excludedInputPaths, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);
 
         /// <summary>
         /// Common internal constructor
@@ -930,7 +930,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
-        public void RemoveEntriesForSource(ITaskItem source) => RemoveEntriesForSource(new[] { source });
+        public void RemoveEntriesForSource(ITaskItem source) => RemoveEntriesForSource([source]);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
@@ -1002,14 +1002,14 @@ private void RemoveDependencyFromEntry(string rootingMarker, ITaskItem dependenc
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
-        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source) => RemoveDependenciesFromEntryIfMissing(new ITaskItem[] { source }, null);
+        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source) => RemoveDependenciesFromEntryIfMissing([source], null);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
         /// <param name="correspondingOutput">Output that correspond ot the sources (used for same file processing)</param>
-        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput) => RemoveDependenciesFromEntryIfMissing(new[] { source }, new[] { correspondingOutput });
+        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput) => RemoveDependenciesFromEntryIfMissing([source], [correspondingOutput]);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 5a94ceeb1ad..fad06ee59a9 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -617,14 +617,14 @@ public void SaveTlog(DependencyFilter includeInTLog)
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Sources that should be removed from the graph</param>
-        public void RemoveEntriesForSource(ITaskItem source) => RemoveEntriesForSource(new[] { source }, null);
+        public void RemoveEntriesForSource(ITaskItem source) => RemoveEntriesForSource([source], null);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Sources that should be removed from the graph</param>
         /// <param name="correspondingOutput">Outputs that correspond ot the sources (used for same file processing)</param>
-        public void RemoveEntriesForSource(ITaskItem source, ITaskItem correspondingOutput) => RemoveEntriesForSource(new[] { source }, new[] { correspondingOutput });
+        public void RemoveEntriesForSource(ITaskItem source, ITaskItem correspondingOutput) => RemoveEntriesForSource([source], [correspondingOutput]);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
@@ -696,14 +696,14 @@ private void RemoveDependencyFromEntry(string rootingMarker, ITaskItem dependenc
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
-        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source) => RemoveDependenciesFromEntryIfMissing(new[] { source }, null);
+        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source) => RemoveDependenciesFromEntryIfMissing([source], null);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
         /// <param name="correspondingOutput">Output that correspond ot the sources (used for same file processing)</param>
-        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput) => RemoveDependenciesFromEntryIfMissing(new[] { source }, new[] { correspondingOutput });
+        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput) => RemoveDependenciesFromEntryIfMissing([source], [correspondingOutput]);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index be62498f6ee..f3db3169e4f 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -284,14 +284,14 @@ public static bool FileIsUnderPath(string fileName, string path)
         /// Construct a rooting marker string from the ITaskItem array of primary sources.
         /// </summary>
         /// <param name="source">An <see cref="ITaskItem"/> containing information about the primary source.</param>
-        public static string FormatRootingMarker(ITaskItem source) => FormatRootingMarker(new[] { source }, null);
+        public static string FormatRootingMarker(ITaskItem source) => FormatRootingMarker([source], null);
 
         /// <summary>
         /// Construct a rooting marker string from the ITaskItem array of primary sources.
         /// </summary>
         /// <param name="source">An <see cref="ITaskItem"/> containing information about the primary source.</param>
         /// <param name="output">An <see cref="ITaskItem"/> containing information about the output.</param>
-        public static string FormatRootingMarker(ITaskItem source, ITaskItem output) => FormatRootingMarker(new[] { source }, new[] { output });
+        public static string FormatRootingMarker(ITaskItem source, ITaskItem output) => FormatRootingMarker([source], [output]);
 
         /// <summary>
         /// Construct a rooting marker string from the ITaskItem array of primary sources.
