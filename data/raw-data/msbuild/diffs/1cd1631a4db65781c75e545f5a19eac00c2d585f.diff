diff --git a/README.md b/README.md
index 84781e6d767..1d26aa4cd39 100644
--- a/README.md
+++ b/README.md
@@ -39,7 +39,7 @@ To get started on **Visual Studio 2017**:
 2. Clone the source code (see above).
 2. Open a `Developer Command Prompt for VS 2017` prompt.
 3. Build the code using the `build.cmd` script. This also restores packages needed to open the projects in Visual Studio.
-5. Open `src/MSBuild.sln` in Visual Studio 2017.
+5. Open `MSBuild.sln` in Visual Studio 2017.
 
 ### Building MSBuild in Unix (Mac & Linux)
 
diff --git a/src/Shared/UnitTests/MockEngine.cs b/src/Shared/UnitTests/MockEngine.cs
index 996cec3a590..dcc843accca 100644
--- a/src/Shared/UnitTests/MockEngine.cs
+++ b/src/Shared/UnitTests/MockEngine.cs
@@ -28,57 +28,37 @@ namespace Microsoft.Build.UnitTests
      * is somewhat of a no-no for task assemblies.
      * 
      **************************************************************************/
-    sealed internal class MockEngine : IBuildEngine5
+    internal sealed class MockEngine : IBuildEngine5
     {
         private readonly ITestOutputHelper _output;
 
-        private bool _isRunningMultipleNodes;
-        private int _messages = 0;
-        private int _warnings = 0;
-        private int _errors = 0;
-        private StringBuilder _log = new StringBuilder();
-        private ProjectCollection _projectCollection = new ProjectCollection();
-        private bool _logToConsole = false;
-        private MockLogger _mockLogger = null;
-        private Dictionary<object, object> _objectCashe = new Dictionary<object, object>();
+        private readonly StringBuilder _log = new StringBuilder();
+        private readonly ProjectCollection _projectCollection = new ProjectCollection();
+        private readonly bool _logToConsole;
+        private readonly Dictionary<object, object> _objectCashe = new Dictionary<object, object>();
 
         internal MockEngine() : this(false)
         {
         }
 
-        internal int Messages
-        {
-            set { _messages = value; }
-            get { return _messages; }
-        }
+        internal int Messages { set; get; }
 
-        internal int Warnings
-        {
-            set { _warnings = value; }
-            get { return _warnings; }
-        }
+        internal int Warnings { set; get; }
 
-        internal int Errors
-        {
-            set { _errors = value; }
-            get { return _errors; }
-        }
+        internal int Errors { set; get; }
 
-        internal MockLogger MockLogger
-        {
-            get { return _mockLogger; }
-        }
+        internal MockLogger MockLogger { get; }
 
         public MockEngine(bool logToConsole)
         {
-            _mockLogger = new MockLogger();
+            MockLogger = new MockLogger();
             _logToConsole = logToConsole;
         }
 
         public MockEngine(ITestOutputHelper output)
         {
             _output = output;
-            _mockLogger = new MockLogger(output);
+            MockLogger = new MockLogger(output);
             _logToConsole = false; // We have a better place to put it.
         }
 
@@ -86,13 +66,13 @@ public void LogErrorEvent(BuildErrorEventArgs eventArgs)
         {
             string message = string.Empty;
 
-            if (eventArgs.File != null && eventArgs.File.Length > 0)
+            if (!string.IsNullOrEmpty(eventArgs.File))
             {
-                message += String.Format("{0}({1},{2}): ", eventArgs.File, eventArgs.LineNumber, eventArgs.ColumnNumber);
+                message += $"{eventArgs.File}({eventArgs.LineNumber},{eventArgs.ColumnNumber}): ";
             }
 
             message += "ERROR " + eventArgs.Code + ": ";
-            ++_errors;
+            ++Errors;
 
             message += eventArgs.Message;
 
@@ -106,13 +86,13 @@ public void LogWarningEvent(BuildWarningEventArgs eventArgs)
         {
             string message = string.Empty;
 
-            if (eventArgs.File != null && eventArgs.File.Length > 0)
+            if (!string.IsNullOrEmpty(eventArgs.File))
             {
-                message += String.Format("{0}({1},{2}): ", eventArgs.File, eventArgs.LineNumber, eventArgs.ColumnNumber);
+                message += $"{eventArgs.File}({eventArgs.LineNumber},{eventArgs.ColumnNumber}): ";
             }
 
             message += "WARNING " + eventArgs.Code + ": ";
-            ++_warnings;
+            ++Warnings;
 
             message += eventArgs.Message;
 
@@ -136,7 +116,7 @@ public void LogMessageEvent(BuildMessageEventArgs eventArgs)
                 Console.WriteLine(eventArgs.Message);
             _output?.WriteLine(eventArgs.Message);
             _log.AppendLine(eventArgs.Message);
-            ++_messages;
+            ++Messages;
         }
 
         public void LogTelemetry(string eventName, IDictionary<string, string> properties)
@@ -155,37 +135,13 @@ public void LogTelemetry(string eventName, IDictionary<string, string> propertie
             _log.AppendLine(message);
         }
 
-        public bool ContinueOnError
-        {
-            get
-            {
-                return false;
-            }
-        }
+        public bool ContinueOnError => false;
 
-        public string ProjectFileOfTaskNode
-        {
-            get
-            {
-                return String.Empty;
-            }
-        }
+        public string ProjectFileOfTaskNode => String.Empty;
 
-        public int LineNumberOfTaskNode
-        {
-            get
-            {
-                return 0;
-            }
-        }
+        public int LineNumberOfTaskNode => 0;
 
-        public int ColumnNumberOfTaskNode
-        {
-            get
-            {
-                return 0;
-            }
-        }
+        public int ColumnNumberOfTaskNode => 0;
 
         internal string Log
         {
@@ -198,14 +154,10 @@ internal string Log
 
                 _log.Clear();
             }
-            get { return _log.ToString(); }
+            get => _log.ToString();
         }
 
-        public bool IsRunningMultipleNodes
-        {
-            get { return _isRunningMultipleNodes; }
-            set { _isRunningMultipleNodes = value; }
-        }
+        public bool IsRunningMultipleNodes { get; set; }
 
         public bool BuildProjectFile
             (
@@ -215,7 +167,7 @@ public bool BuildProjectFile
             IDictionary targetOutputs
             )
         {
-            ILogger[] loggers = new ILogger[2] { _mockLogger, new ConsoleLogger() };
+            ILogger[] loggers = new ILogger[2] { MockLogger, new ConsoleLogger() };
 
             return this.BuildProjectFile(projectFileName, targetNames, globalPropertiesPassedIntoTask, targetOutputs, null);
         }
@@ -242,7 +194,7 @@ string toolsVersion
 
             Project project = _projectCollection.LoadProject(projectFileName, finalGlobalProperties, toolsVersion);
 
-            ILogger[] loggers = new ILogger[2] { _mockLogger, new ConsoleLogger() };
+            ILogger[] loggers = new ILogger[2] { MockLogger, new ConsoleLogger() };
 
             return project.Build(targetNames, loggers);
         }
@@ -291,7 +243,7 @@ bool returnTargetOutputs
         {
             List<IDictionary<string, ITaskItem[]>> targetOutputsPerProject = null;
 
-            ILogger[] loggers = new ILogger[2] { _mockLogger, new ConsoleLogger() };
+            ILogger[] loggers = new ILogger[2] { MockLogger, new ConsoleLogger() };
 
             bool allSucceeded = true;
 
@@ -424,7 +376,7 @@ internal void AssertLogContains(string contains)
                     _output.WriteLine(logText);
                 }
 
-                _mockLogger.AssertLogContains(contains);
+                MockLogger.AssertLogContains(contains);
             }
         }
 
@@ -451,7 +403,7 @@ internal void AssertLogDoesntContain(string contains)
             // If we do not contain this string than pass it to
             // MockLogger. Since MockLogger is also registered as
             // a logger it may have this string.
-            _mockLogger.AssertLogDoesntContain(contains);
+            MockLogger.AssertLogDoesntContain(contains);
         }
 
         /// <summary>
@@ -461,8 +413,7 @@ internal void AssertLogDoesntContain(string contains)
 
         public object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime)
         {
-            object obj = null;
-            _objectCashe.TryGetValue(key, out obj);
+            _objectCashe.TryGetValue(key, out object obj);
             return obj;
         }
 
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 8e50157f6dd..6fa73ed2a6a 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -3,7 +3,10 @@
 
 using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.IO;
+using System.Runtime.InteropServices;
+using System.Security.Principal;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.AccessControl;
 #endif
@@ -12,11 +15,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
-
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-using System.Security.Principal;
-using System.Text;
 using Xunit;
 using Xunit.Abstractions;
 
@@ -24,22 +22,23 @@ namespace Microsoft.Build.UnitTests
 {
     public class Copy_Tests : IDisposable
     {
-        public bool useHardLinks = false;
+        public bool UseHardLinks { get; protected set; }
+
+        public bool UseSymbolicLinks { get; protected set; }
 
-        public bool useSymbolicLinks = false;
         /// <summary>
         /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run 
         /// the tests isolated from the current state of the environment, but put it back how it belongs
         /// once we're done. 
         /// </summary>
-        private string _alwaysOverwriteReadOnlyFiles = null;
+        private readonly string _alwaysOverwriteReadOnlyFiles;
 
         /// <summary>
         /// Temporarily save off the value of MSBUILDALWAYSRETRY, so that we can run 
         /// the tests isolated from the current state of the environment, but put it back how it belongs
         /// once we're done. 
         /// </summary>
-        private string _alwaysRetry = null;
+        private readonly string _alwaysRetry;
 
         private readonly ITestOutputHelper _testOutputHelper;
 
@@ -82,32 +81,27 @@ public void DontCopyOverSameFile()
             string file = FileUtilities.GetTemporaryFile();
             try
             {
-                using (StreamWriter sw = FileUtilities.OpenWrite(file, true))   // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(file, true)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a temp file.");
+                }
 
                 ITaskItem f = new TaskItem(file);
-                ITaskItem[] sourceFiles = new ITaskItem[] { f };
-                ITaskItem[] destinationFiles = new ITaskItem[] { f };
+                ITaskItem[] sourceFiles = { f };
+                ITaskItem[] destinationFiles = { f };
 
                 CopyMonitor m = new CopyMonitor();
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                Copy t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-
-                t.BuildEngine = new MockEngine();
-                t.SourceFiles = sourceFiles;
-                t.DestinationFiles = destinationFiles;
-                t.SkipUnchangedFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
-                t.Execute
-                (
-                    new Microsoft.Build.Tasks.CopyFileWithState(m.CopyFile)
-                );
+                t.Execute(m.CopyFile);
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -134,29 +128,32 @@ public void DoNotNormallyCopyOverReadOnlyFile()
             try
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(source, true))
+                {
                     sw.Write("This is a source file.");
+                }
+
                 using (StreamWriter sw = FileUtilities.OpenWrite(destination, true))
+                {
                     sw.Write("This is a destination file.");
+                }
 
                 File.SetAttributes(destination, FileAttributes.ReadOnly);
 
                 ITaskItem sourceItem = new TaskItem(source);
                 ITaskItem destinationItem = new TaskItem(destination);
-                ITaskItem[] sourceFiles = new ITaskItem[] { sourceItem };
-                ITaskItem[] destinationFiles = new ITaskItem[] { destinationItem };
+                ITaskItem[] sourceFiles = { sourceItem };
+                ITaskItem[] destinationFiles = { destinationItem };
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                t.BuildEngine = new MockEngine();
-                t.SourceFiles = sourceFiles;
-                t.DestinationFiles = destinationFiles;
-                t.SkipUnchangedFiles = true;
-                // OverwriteReadOnlyFiles defaults to false
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    // OverwriteReadOnlyFiles defaults to false
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 // Should fail: target is readonly
                 Assert.False(t.Execute());
@@ -197,29 +194,32 @@ public void CopyOverReadOnlyFileEnvironmentOverride()
                 Environment.SetEnvironmentVariable("MSBUILDALWAYSOVERWRITEREADONLYFILES", "1   ");
 
                 using (StreamWriter sw = FileUtilities.OpenWrite(source, true))
+                {
                     sw.Write("This is a source file.");
+                }
+
                 using (StreamWriter sw = FileUtilities.OpenWrite(destination, true))
+                {
                     sw.Write("This is a destination file.");
+                }
 
                 File.SetAttributes(destination, FileAttributes.ReadOnly);
 
                 ITaskItem sourceItem = new TaskItem(source);
                 ITaskItem destinationItem = new TaskItem(destination);
-                ITaskItem[] sourceFiles = new ITaskItem[] { sourceItem };
-                ITaskItem[] destinationFiles = new ITaskItem[] { destinationItem };
+                ITaskItem[] sourceFiles = { sourceItem };
+                ITaskItem[] destinationFiles = { destinationItem };
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                t.BuildEngine = new MockEngine();
-                t.SourceFiles = sourceFiles;
-                t.DestinationFiles = destinationFiles;
-                t.SkipUnchangedFiles = true;
-                t.OverwriteReadOnlyFiles = false;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    OverwriteReadOnlyFiles = false,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 // Should not fail although target is readonly
                 Assert.True(t.Execute());
@@ -260,30 +260,33 @@ public void AlwaysRetryCopyEnvironmentOverride()
                 Copy.RefreshInternalEnvironmentValues();
 
                 using (StreamWriter sw = FileUtilities.OpenWrite(source, true))
+                {
                     sw.Write("This is a source file.");
+                }
+
                 using (StreamWriter sw = FileUtilities.OpenWrite(destination, true))
+                {
                     sw.Write("This is a destination file.");
+                }
 
                 File.SetAttributes(destination, FileAttributes.ReadOnly);
 
                 ITaskItem sourceItem = new TaskItem(source);
                 ITaskItem destinationItem = new TaskItem(destination);
-                ITaskItem[] sourceFiles = new ITaskItem[] { sourceItem };
-                ITaskItem[] destinationFiles = new ITaskItem[] { destinationItem };
+                ITaskItem[] sourceFiles = { sourceItem };
+                ITaskItem[] destinationFiles = { destinationItem };
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                t.BuildEngine = new MockEngine();
-                t.SourceFiles = sourceFiles;
-                t.DestinationFiles = destinationFiles;
-                t.SkipUnchangedFiles = true;
-                t.OverwriteReadOnlyFiles = false;
-                t.Retries = 5;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    OverwriteReadOnlyFiles = false,
+                    Retries = 5,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 // The file is read-only, so the retries will all fail. 
                 Assert.False(t.Execute());
@@ -323,29 +326,32 @@ public void CopyOverReadOnlyFileParameterIsSet()
             try
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(source, true))
+                {
                     sw.Write("This is a source file.");
+                }
+
                 using (StreamWriter sw = FileUtilities.OpenWrite(destination, true))
+                {
                     sw.Write("This is a destination file.");
+                }
 
                 File.SetAttributes(destination, FileAttributes.ReadOnly);
 
                 ITaskItem sourceItem = new TaskItem(source);
                 ITaskItem destinationItem = new TaskItem(destination);
-                ITaskItem[] sourceFiles = new ITaskItem[] { sourceItem };
-                ITaskItem[] destinationFiles = new ITaskItem[] { destinationItem };
+                ITaskItem[] sourceFiles = { sourceItem };
+                ITaskItem[] destinationFiles = { destinationItem };
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                t.BuildEngine = new MockEngine();
-                t.SourceFiles = sourceFiles;
-                t.DestinationFiles = destinationFiles;
-                t.SkipUnchangedFiles = true;
-                t.OverwriteReadOnlyFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    OverwriteReadOnlyFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 // Should not fail although target is readonly
                 Assert.True(t.Execute());
@@ -381,13 +387,25 @@ public void CopyOverReadOnlyFileParameterIsSetWithDestinationFolder()
                 Directory.CreateDirectory(destinationFolder);
 
                 using (StreamWriter sw = FileUtilities.OpenWrite(source1, true))
+                {
                     sw.Write("This is a source file1.");
+                }
+
                 using (StreamWriter sw = FileUtilities.OpenWrite(source2, true))
+                {
+
                     sw.Write("This is a source file2.");
+                }
+
                 using (StreamWriter sw = FileUtilities.OpenWrite(destination1, true))
+                {
                     sw.Write("This is a destination file1.");
+                }
+
                 using (StreamWriter sw = FileUtilities.OpenWrite(destination2, true))
+                {
                     sw.Write("This is a destination file2.");
+                }
 
                 // Set one destination readonly.
                 File.SetAttributes(destination1, FileAttributes.ReadOnly);
@@ -396,17 +414,15 @@ public void CopyOverReadOnlyFileParameterIsSetWithDestinationFolder()
                 ITaskItem sourceItem2 = new TaskItem(source2);
                 ITaskItem[] sourceFiles = new ITaskItem[] { sourceItem1, sourceItem2 };
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                t.BuildEngine = new MockEngine();
-                t.SourceFiles = sourceFiles;
-                t.DestinationFolder = new TaskItem(destinationFolder);
-                t.OverwriteReadOnlyFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(),
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destinationFolder),
+                    OverwriteReadOnlyFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 // Should not fail although one target is readonly
                 Assert.True(t.Execute());
@@ -449,26 +465,28 @@ public void DoCopyOverDifferentFile()
             string destinationFile = FileUtilities.GetTemporaryFile();
             try
             {
-                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a source temp file.");
+                }
 
-                using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a destination temp file.");
+                }
 
-                ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
-                ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+                ITaskItem[] destinationFiles = { new TaskItem(destinationFile) };
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                t.BuildEngine = new MockEngine();
-                t.SourceFiles = sourceFiles;
-                t.DestinationFiles = destinationFiles;
-                t.SkipUnchangedFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 t.Execute();
 
@@ -501,28 +519,30 @@ public void DoCopyOverNonExistentFile()
 
             try
             {
-                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a source temp file.");
+                }
 
-                using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true))   // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a destination temp file.");
+                }
 
-                ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
-                ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+                ITaskItem[] destinationFiles = { new TaskItem(destinationFile) };
 
                 File.Delete(destinationFile);
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                t.BuildEngine = new MockEngine();
-                t.SourceFiles = sourceFiles;
-                t.DestinationFiles = destinationFiles;
-                t.SkipUnchangedFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 t.Execute();
 
@@ -554,21 +574,19 @@ public void DoNotRetryCopyNotSupportedException()
 
             try
             {
-                ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
-                ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+                ITaskItem[] destinationFiles = { new TaskItem(destinationFile) };
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var engine = new MockEngine();
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                MockEngine engine = new MockEngine();
-                t.BuildEngine = engine;
-                t.SourceFiles = sourceFiles;
-                t.DestinationFiles = destinationFiles;
-                t.SkipUnchangedFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = engine,
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks,
+                };
 
                 bool result = t.Execute();
                 Assert.False(result);
@@ -594,26 +612,26 @@ public void DoNotRetryCopyNonExistentSourceFile()
 
             try
             {
-                using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true))   // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a destination temp file.");
+                }
 
-                ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
-                ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+                ITaskItem[] destinationFiles = { new TaskItem(destinationFile) };
 
                 File.Delete(destinationFile);
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var engine = new MockEngine();
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                MockEngine engine = new MockEngine();
-                t.BuildEngine = engine;
-                t.SourceFiles = sourceFiles;
-                t.DestinationFiles = destinationFiles;
-                t.SkipUnchangedFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = engine,
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 bool result = t.Execute();
                 Assert.False(result);
@@ -639,26 +657,26 @@ public void DoNotRetryCopyWhenSourceIsFolder()
 
             try
             {
-                using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true))   // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a destination temp file.");
+                }
 
-                ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
-                ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+                ITaskItem[] destinationFiles = { new TaskItem(destinationFile) };
 
                 File.Delete(destinationFile);
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var engine = new MockEngine();
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                MockEngine engine = new MockEngine();
-                t.BuildEngine = engine;
-                t.SourceFiles = sourceFiles;
-                t.DestinationFiles = destinationFiles;
-                t.SkipUnchangedFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = engine,
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 bool result = t.Execute();
                 Assert.False(result);
@@ -689,19 +707,17 @@ public void DoRetryWhenDestinationLocked()
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(destinationFile, true)) // Keep it locked
                 {
-                    ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
+                    ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
 
-                    Copy t = new Copy();
-                    t.RetryDelayMilliseconds = 1; // speed up tests!
-                    // Allow the task's default (false) to have a chance
-                    if (useHardLinks)
+                    var engine = new MockEngine(_testOutputHelper);
+                    var t = new Copy
                     {
-                        t.UseHardlinksIfPossible = useHardLinks;
-                    }
-                    MockEngine engine = new MockEngine(_testOutputHelper);
-                    t.BuildEngine = engine;
-                    t.SourceFiles = sourceFiles;
-                    t.DestinationFiles = new TaskItem[] { new TaskItem(destinationFile) };
+                        RetryDelayMilliseconds = 1,  // speed up tests!
+                        BuildEngine = engine,
+                        SourceFiles = sourceFiles,
+                        DestinationFiles = new ITaskItem[] { new TaskItem(destinationFile) },
+                        UseHardlinksIfPossible = UseHardLinks
+                    };
 
                     bool result = t.Execute();
                     Assert.False(result);
@@ -744,10 +760,10 @@ public void DoNotRetryWhenDestinationLockedDueToAcl()
             File.WriteAllText(destinationFile, "Destination");
             File.WriteAllText(sourceFile, "SourceFile");
 
-            string userAccount = string.Format(@"{0}\{1}", System.Environment.UserDomainName, System.Environment.UserName);
+            string userAccount = $@"{Environment.UserDomainName}\{Environment.UserName}";
 
-            FileSystemAccessRule denyFile = new FileSystemAccessRule(userAccount, FileSystemRights.Write | FileSystemRights.Delete | FileSystemRights.DeleteSubdirectoriesAndFiles | FileSystemRights.WriteData, AccessControlType.Deny);
-            FileSystemAccessRule denyDirectory = new FileSystemAccessRule(userAccount, FileSystemRights.DeleteSubdirectoriesAndFiles, AccessControlType.Deny);
+            var denyFile = new FileSystemAccessRule(userAccount, FileSystemRights.Write | FileSystemRights.Delete | FileSystemRights.DeleteSubdirectoriesAndFiles | FileSystemRights.WriteData, AccessControlType.Deny);
+            var denyDirectory = new FileSystemAccessRule(userAccount, FileSystemRights.DeleteSubdirectoriesAndFiles, AccessControlType.Deny);
 
             FileSecurity fSecurity = File.GetAccessControl(destinationFile);
             DirectorySecurity dSecurity = Directory.GetAccessControl(tempDirectory);
@@ -760,17 +776,15 @@ public void DoNotRetryWhenDestinationLockedDueToAcl()
                 dSecurity.AddAccessRule(denyDirectory);
                 Directory.SetAccessControl(tempDirectory, dSecurity);
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var engine = new MockEngine();
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                MockEngine engine = new MockEngine();
-                t.BuildEngine = engine;
-                t.SourceFiles = new TaskItem[] { new TaskItem(sourceFile) };
-                t.DestinationFiles = new TaskItem[] { new TaskItem(destinationFile) };
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem(destinationFile) },
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 bool result = t.Execute();
                 Assert.False(result);
@@ -809,22 +823,22 @@ public void DoNotRetryCopyWhenDestinationFolderIsFile()
             try
             {
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
+                {
                     sw.Write("This is a destination temp file.");
+                }
 
-                ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var engine = new MockEngine();
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                MockEngine engine = new MockEngine();
-                t.BuildEngine = engine;
-                t.SourceFiles = sourceFiles;
-                t.DestinationFolder = new TaskItem(destinationFile);
-                t.SkipUnchangedFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = engine,
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destinationFile),
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 bool result = t.Execute();
                 Assert.False(result);
@@ -855,21 +869,19 @@ public void DoNotRetryCopyWhenDestinationFileIsFolder()
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))   // HIGHCHAR: Test writes in UTF8 without preamble.
                     sw.Write("This is a destination temp file.");
 
-                ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
-                ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+                ITaskItem[] destinationFiles = { new TaskItem(destinationFile) };
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var engine = new MockEngine();
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                MockEngine engine = new MockEngine();
-                t.BuildEngine = engine;
-                t.SourceFiles = sourceFiles;
-                t.DestinationFiles = destinationFiles;
-                t.SkipUnchangedFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = engine,
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 bool result = t.Execute();
                 Assert.False(result);
@@ -886,7 +898,7 @@ public void DoNotRetryCopyWhenDestinationFileIsFolder()
 
         internal class CopyMonitor
         {
-            internal int copyCount = 0;
+            internal int copyCount;
 
             /*
             * Method:   CopyFile
@@ -912,7 +924,7 @@ public void OutputsOnlyIncludeSuccessfulCopies()
             string temp = Path.GetTempPath();
             string inFile1 = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A392");
             string inFile2 = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A393");
-            string invalidFile = "!@#$%^&*()|";
+            const string invalidFile = "!@#$%^&*()|";
             string validOutFile = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A394");
 
             try
@@ -927,29 +939,27 @@ public void OutputsOnlyIncludeSuccessfulCopies()
                 }
                 finally
                 {
-                    fs.Dispose();
-                    fs2.Dispose();
+                    fs?.Dispose();
+                    fs2?.Dispose();
                 }
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var engine = new MockEngine();
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                MockEngine engine = new MockEngine();
-                t.BuildEngine = engine;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = engine,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 ITaskItem i1 = new TaskItem(inFile1);
                 i1.SetMetadata("Locale", "en-GB");
                 i1.SetMetadata("Color", "taupe");
-                t.SourceFiles = new ITaskItem[] { new TaskItem(inFile2), i1 };
+                t.SourceFiles = new[] { new TaskItem(inFile2), i1 };
 
                 ITaskItem o1 = new TaskItem(validOutFile);
                 o1.SetMetadata("Locale", "fr");
                 o1.SetMetadata("Flavor", "Pumpkin");
-                t.DestinationFiles = new ITaskItem[] { new TaskItem(invalidFile), o1 };
+                t.DestinationFiles = new[] { new TaskItem(invalidFile), o1 };
 
                 bool success = t.Execute();
 
@@ -1010,21 +1020,20 @@ public void CopyFileOnItself()
                 }
                 finally
                 {
-                    fs.Dispose();
+                    fs?.Dispose();
                 }
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var engine = new MockEngine();
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                MockEngine engine = new MockEngine();
-                t.BuildEngine = engine;
-                t.SourceFiles = new ITaskItem[] { new TaskItem(file) };
-                t.DestinationFiles = new ITaskItem[] { new TaskItem(file) };
-                t.SkipUnchangedFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(file) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem(file) },
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
+
                 bool success = t.Execute();
 
                 Assert.True(success);
@@ -1033,17 +1042,15 @@ public void CopyFileOnItself()
 
                 ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries, nothing to do
 
-                t = new Copy();
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
-                {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
                 engine = new MockEngine();
-                t.BuildEngine = engine;
-                t.SourceFiles = new ITaskItem[] { new TaskItem(file) };
-                t.DestinationFiles = new ITaskItem[] { new TaskItem(file) };
-                t.SkipUnchangedFiles = false;
+                t = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(file) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem(file) },
+                    SkipUnchangedFiles = false,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 success = t.Execute();
 
@@ -1082,21 +1089,20 @@ public void CopyFileOnItself2()
                 }
                 finally
                 {
-                    fs.Dispose();
+                    fs?.Dispose();
                 }
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var engine = new MockEngine();
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                MockEngine engine = new MockEngine();
-                t.BuildEngine = engine;
-                t.SourceFiles = new ITaskItem[] { new TaskItem(file) };
-                t.DestinationFiles = new ITaskItem[] { new TaskItem(filename.ToLowerInvariant()) };
-                t.SkipUnchangedFiles = false;
+                    RetryDelayMilliseconds = 1, // speed up tests!
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(file) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem(filename.ToLowerInvariant()) },
+                    SkipUnchangedFiles = false,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
+
                 bool success = t.Execute();
 
                 Assert.True(success);
@@ -1124,7 +1130,7 @@ public void CopyFileOnItselfAndFailACopy()
             string temp = Path.GetTempPath();
             string file = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A395");
             string invalidFile = NativeMethodsShared.IsUnixLike ? Path.Combine(temp, "!@#$%^&*()|") : "!@#$%^&*()|";
-            string dest2 = "whatever";
+            const string dest2 = "whatever";
 
             try
             {
@@ -1136,21 +1142,20 @@ public void CopyFileOnItselfAndFailACopy()
                 }
                 finally
                 {
-                    fs.Dispose();
+                    fs?.Dispose();
                 }
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var engine = new MockEngine();
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                MockEngine engine = new MockEngine();
-                t.BuildEngine = engine;
-                t.SourceFiles = new ITaskItem[] { new TaskItem(file), new TaskItem(invalidFile) };
-                t.DestinationFiles = new ITaskItem[] { new TaskItem(file), new TaskItem(dest2) };
-                t.SkipUnchangedFiles = false;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(file), new TaskItem(invalidFile) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem(file), new TaskItem(dest2) },
+                    SkipUnchangedFiles = false,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
+
                 bool success = t.Execute();
 
                 // Since on Unix there are no invalid file names, the copy will succeed
@@ -1190,26 +1195,25 @@ public void CopyToDestinationFolder()
             string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
             try
             {
-                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a source temp file.");
+                }
 
                 // Don't create the dest folder, let task do that
 
-                ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var me = new MockEngine();
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                MockEngine me = new MockEngine();
-
-                t.BuildEngine = me;
-                t.SourceFiles = sourceFiles;
-                t.DestinationFolder = new TaskItem(destFolder);
-                t.SkipUnchangedFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = me,
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destFolder),
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 bool success = t.Execute();
 
@@ -1220,14 +1224,14 @@ public void CopyToDestinationFolder()
                 using (StreamReader sr = FileUtilities.OpenRead(destFile))
                     destinationFileContents = sr.ReadToEnd();
 
-                if (!useHardLinks)
+                if (!UseHardLinks)
                 {
-                    Microsoft.Build.UnitTests.MockEngine.GetStringDelegate resourceDelegate = new Microsoft.Build.UnitTests.MockEngine.GetStringDelegate(AssemblyResources.GetString);
+                    MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
                     me.AssertLogDoesntContainMessageFromResource(resourceDelegate, "Copy.HardLinkComment", sourceFile, destFile);
                 }
                 else
                 {
-                    Microsoft.Build.UnitTests.MockEngine.GetStringDelegate resourceDelegate = new Microsoft.Build.UnitTests.MockEngine.GetStringDelegate(AssemblyResources.GetString);
+                    MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
                     me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.HardLinkComment", sourceFile, destFile);
                 }
 
@@ -1267,19 +1271,17 @@ public void CopyDoubleEscapableFileToDestinationFolder()
 
                 // Don't create the dest folder, let task do that
 
-                ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFileEscaped) };
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFileEscaped) };
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                t.BuildEngine = new MockEngine();
-                t.SourceFiles = sourceFiles;
-                t.DestinationFolder = new TaskItem(destFolder);
-                t.SkipUnchangedFiles = true;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(),
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destFolder),
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 bool success = t.Execute();
 
@@ -1316,7 +1318,7 @@ public void CopyWithDuplicatesUsingFolder()
         {
             string tempPath = Path.GetTempPath();
 
-            ITaskItem[] sourceFiles = new ITaskItem[]
+            ITaskItem[] sourceFiles =
             {
                 new TaskItem(Path.Combine(tempPath, "a.cs")),
                 new TaskItem(Path.Combine(tempPath, "b.cs")),
@@ -1334,16 +1336,14 @@ public void CopyWithDuplicatesUsingFolder()
 
             var filesActuallyCopied = new List<KeyValuePair<FileState, FileState>>();
 
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
-            // Allow the task's default (false) to have a chance
-            if (useHardLinks)
+            var t = new Copy
             {
-                t.UseHardlinksIfPossible = useHardLinks;
-            }
-            t.BuildEngine = new MockEngine();
-            t.SourceFiles = sourceFiles;
-            t.DestinationFolder = new TaskItem(Path.Combine(tempPath, "foo"));
+                RetryDelayMilliseconds = 1, // speed up tests!
+                BuildEngine = new MockEngine(),
+                SourceFiles = sourceFiles,
+                DestinationFolder = new TaskItem(Path.Combine(tempPath, "foo")),
+                UseHardlinksIfPossible = UseHardLinks
+            };
 
             bool success = t.Execute(delegate (FileState source, FileState dest)
             {
@@ -1369,7 +1369,7 @@ public void CopyWithDuplicatesUsingFiles()
         {
             string tempPath = Path.GetTempPath();
 
-            ITaskItem[] sourceFiles = new ITaskItem[]
+            ITaskItem[] sourceFiles =
             {
                 new TaskItem(Path.Combine(tempPath, "a.cs")),
                 new TaskItem(Path.Combine(tempPath, "b.cs")),
@@ -1386,7 +1386,7 @@ public void CopyWithDuplicatesUsingFiles()
                 }
             }
 
-            ITaskItem[] destFiles = new ITaskItem[]
+            ITaskItem[] destFiles =
             {
                 new TaskItem(Path.Combine(tempPath, @"xa.cs")), // a.cs -> xa.cs
                 new TaskItem(Path.Combine(tempPath, @"xa.cs")), // b.cs -> xa.cs should copy because it's a different source
@@ -1397,16 +1397,14 @@ public void CopyWithDuplicatesUsingFiles()
 
             var filesActuallyCopied = new List<KeyValuePair<FileState, FileState>>();
 
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
-            // Allow the task's default (false) to have a chance
-            if (useHardLinks)
+            var t = new Copy
             {
-                t.UseHardlinksIfPossible = useHardLinks;
-            }
-            t.BuildEngine = new MockEngine();
-            t.SourceFiles = sourceFiles;
-            t.DestinationFiles = destFiles;
+                RetryDelayMilliseconds = 1,  // speed up tests!
+                BuildEngine = new MockEngine(),
+                SourceFiles = sourceFiles,
+                DestinationFiles = destFiles,
+                UseHardlinksIfPossible = UseHardLinks
+            };
 
             bool success = t.Execute(delegate (FileState source, FileState dest)
             {
@@ -1453,22 +1451,19 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
                 }
                 finally
                 {
-                    fs.Dispose();
-                    fs2.Dispose();
+                    fs?.Dispose();
+                    fs2?.Dispose();
                 }
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var engine = new MockEngine();
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                MockEngine engine = new MockEngine();
-                t.BuildEngine = engine;
-
-                t.SourceFiles = new ITaskItem[] { new TaskItem(inFile1), new TaskItem(inFile2) };
-                t.DestinationFiles = new ITaskItem[] { new TaskItem(outFile1) };
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(inFile1), new TaskItem(inFile2) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem(outFile1) },
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 bool success = t.Execute();
 
@@ -1496,26 +1491,26 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
-            string destinationFile = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
+            const string destinationFile = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
 
             try
             {
-                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a source temp file.");
+                }
 
-                ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
-                ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+                ITaskItem[] destinationFiles = { new TaskItem(destinationFile) };
 
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-                // Allow the task's default (false) to have a chance
-                if (useHardLinks)
+                var t = new Copy
                 {
-                    t.UseHardlinksIfPossible = useHardLinks;
-                }
-                t.BuildEngine = new MockEngine();
-                t.SourceFiles = sourceFiles;
-                t.DestinationFiles = destinationFiles;
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    UseHardlinksIfPossible = UseHardLinks
+                };
 
                 bool result = t.Execute();
 
@@ -1538,23 +1533,21 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
         public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
         {
-            string sourceFile = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
+            const string sourceFile = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
             string destinationFile = FileUtilities.GetTemporaryFile();
             File.Delete(destinationFile);
 
-            ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
-            ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
+            ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+            ITaskItem[] destinationFiles = { new TaskItem(destinationFile) };
 
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
-            // Allow the task's default (false) to have a chance
-            if (useHardLinks)
+            var t = new Copy
             {
-                t.UseHardlinksIfPossible = useHardLinks;
-            }
-            t.BuildEngine = new MockEngine();
-            t.SourceFiles = sourceFiles;
-            t.DestinationFiles = destinationFiles;
+                RetryDelayMilliseconds = 1, // speed up tests!
+                BuildEngine = new MockEngine(),
+                SourceFiles = sourceFiles,
+                DestinationFiles = destinationFiles,
+                UseHardlinksIfPossible = UseHardLinks
+            };
 
             bool result = t.Execute();
 
@@ -1571,16 +1564,14 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong2()
         [Fact]
         public void ExitGracefullyOnInvalidPathCharacters()
         {
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
-            // Allow the task's default (false) to have a chance
-            if (useHardLinks)
+            var t = new Copy
             {
-                t.UseHardlinksIfPossible = useHardLinks;
-            }
-            t.BuildEngine = new MockEngine();
-            t.SourceFiles = new ITaskItem[] { new TaskItem("foo | bar") }; ;
-            t.DestinationFolder = new TaskItem("dest");
+                RetryDelayMilliseconds = 1,  // speed up tests!
+                BuildEngine = new MockEngine(),
+                SourceFiles = new ITaskItem[] { new TaskItem("foo | bar") },
+                DestinationFolder = new TaskItem("dest"),
+                UseHardlinksIfPossible = UseHardLinks
+            };
 
             bool result = t.Execute();
 
@@ -1595,18 +1586,16 @@ public void ExitGracefullyOnInvalidPathCharacters()
         [Fact]
         public void InvalidRetryCount()
         {
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
-            // Allow the task's default (false) to have a chance
-            if (useHardLinks)
-            {
-                t.UseHardlinksIfPossible = useHardLinks;
-            }
-            MockEngine engine = new MockEngine(true /* log to console */);
-            t.BuildEngine = engine;
-            t.SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") };
-            t.DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") };
-            t.Retries = -1;
+            var engine = new MockEngine(true /* log to console */);
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 1, // speed up tests!
+                BuildEngine = engine,
+                SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
+                DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
+                Retries = -1,
+                UseHardlinksIfPossible = UseHardLinks
+            };
 
             bool result = t.Execute();
 
@@ -1620,19 +1609,16 @@ public void InvalidRetryCount()
         [Fact]
         public void InvalidRetryDelayCount()
         {
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
-            // Allow the task's default (false) to have a chance
-            if (useHardLinks)
-            {
-                t.UseHardlinksIfPossible = useHardLinks;
-            }
-            MockEngine engine = new MockEngine(true /* log to console */);
-            t.BuildEngine = engine;
-            t.SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") };
-            t.DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") };
-            t.Retries = 1;
-            t.RetryDelayMilliseconds = -1;
+            var engine = new MockEngine(true /* log to console */);
+            var t = new Copy
+            {
+                BuildEngine = engine,
+                SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
+                DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
+                Retries = 1,
+                RetryDelayMilliseconds = -1,
+                UseHardlinksIfPossible = UseHardLinks
+            };
 
             bool result = t.Execute();
 
@@ -1647,20 +1633,18 @@ public void InvalidRetryDelayCount()
         [Fact]
         public void FailureWithNoRetries()
         {
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
-            // Allow the task's default (false) to have a chance
-            if (useHardLinks)
-            {
-                t.UseHardlinksIfPossible = useHardLinks;
-            }
-            MockEngine engine = new MockEngine(true /* log to console */);
-            t.BuildEngine = engine;
-            t.SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") };
-            t.DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") };
-            t.Retries = 0;
-
-            CopyFunctor copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
+            var engine = new MockEngine(true /* log to console */);
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 1,  // speed up tests!
+                BuildEngine = engine,
+                SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
+                DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
+                Retries = 0,
+                UseHardlinksIfPossible = UseHardLinks
+            };
+            
+            var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
             bool result = t.Execute(copyFunctor.Copy);
 
             Assert.Equal(false, result);
@@ -1674,8 +1658,10 @@ public void FailureWithNoRetries()
         [Fact]
         public void DefaultRetriesIs10()
         {
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 1,  // speed up tests!
+            };
 
             Assert.Equal(10, t.Retries);
         }
@@ -1686,7 +1672,7 @@ public void DefaultRetriesIs10()
         [Fact]
         public void DefaultRetryDelayIs1000()
         {
-            Copy t = new Copy();
+            var t = new Copy();
 
             Assert.Equal(1000, t.RetryDelayMilliseconds);
         }
@@ -1697,9 +1683,11 @@ public void DefaultRetryDelayIs1000()
         [Fact]
         public void DefaultNoHardlink()
         {
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
-
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 1,  // speed up tests!
+            };
+            
             Assert.Equal(false, t.UseHardlinksIfPossible);
         }
 
@@ -1710,21 +1698,18 @@ public void DefaultNoHardlink()
         [Fact]
         public void SuccessAfterOneRetry()
         {
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
-            // Allow the task's default (false) to have a chance
-            if (useHardLinks)
-            {
-                t.UseHardlinksIfPossible = useHardLinks;
-            }
-            MockEngine engine = new MockEngine(true /* log to console */);
-            t.BuildEngine = engine;
-            t.SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") };
-            t.DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") };
-            t.Retries = 1;
-            t.RetryDelayMilliseconds = 0; // Can't really test the delay, but at least try passing in a value
+            var engine = new MockEngine(true /* log to console */);
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 0, // Can't really test the delay, but at least try passing in a value
+                BuildEngine = engine,
+                SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
+                DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
+                Retries = 1,
+                UseHardlinksIfPossible = UseHardLinks
+            };
 
-            CopyFunctor copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
+            var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
             bool result = t.Execute(copyFunctor.Copy);
 
             Assert.Equal(true, result);
@@ -1738,21 +1723,18 @@ public void SuccessAfterOneRetry()
         [Fact]
         public void SuccessAfterOneRetryContinueToNextFile()
         {
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
-            // Allow the task's default (false) to have a chance
-            if (useHardLinks)
-            {
-                t.UseHardlinksIfPossible = useHardLinks;
-            }
-            MockEngine engine = new MockEngine(true /* log to console */);
-            t.BuildEngine = engine;
-            t.SourceFiles = new ITaskItem[] { new TaskItem("c:\\source"), new TaskItem("c:\\source2") };
-            t.DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination"), new TaskItem("c:\\destination2") };
-            t.Retries = 1;
-            t.RetryDelayMilliseconds = 1; // Can't really test the delay, but at least try passing in a value
+            var engine = new MockEngine(true /* log to console */);
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 1, // Can't really test the delay, but at least try passing in a value
+                BuildEngine = engine,
+                SourceFiles = new ITaskItem[] { new TaskItem("c:\\source"), new TaskItem("c:\\source2") },
+                DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination"), new TaskItem("c:\\destination2") },
+                Retries = 1,
+                UseHardlinksIfPossible = UseHardLinks
+            };
 
-            CopyFunctor copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
+            var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
             bool result = t.Execute(copyFunctor.Copy);
 
             Assert.Equal(true, result);
@@ -1769,20 +1751,18 @@ public void SuccessAfterOneRetryContinueToNextFile()
         [Fact]
         public void TooFewRetriesReturnsFalse()
         {
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
-            // Allow the task's default (false) to have a chance
-            if (useHardLinks)
-            {
-                t.UseHardlinksIfPossible = useHardLinks;
-            }
-            MockEngine engine = new MockEngine(true /* log to console */);
-            t.BuildEngine = engine;
-            t.SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") };
-            t.DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") };
-            t.Retries = 2;
+            var engine = new MockEngine(true /* log to console */);
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 1, // speed up tests!
+                BuildEngine = engine,
+                SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
+                DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
+                Retries = 2,
+                UseHardlinksIfPossible = UseHardLinks
+            };
 
-            CopyFunctor copyFunctor = new CopyFunctor(4, false /* do not throw */);
+            var copyFunctor = new CopyFunctor(4, false /* do not throw */);
             bool result = t.Execute(copyFunctor.Copy);
 
             Assert.Equal(false, result);
@@ -1797,20 +1777,18 @@ public void TooFewRetriesReturnsFalse()
         [Fact]
         public void TooFewRetriesThrows()
         {
-            Copy t = new Copy();
-            t.RetryDelayMilliseconds = 1; // speed up tests!
-            // Allow the task's default (false) to have a chance
-            if (useHardLinks)
-            {
-                t.UseHardlinksIfPossible = useHardLinks;
-            }
-            MockEngine engine = new MockEngine(true /* log to console */);
-            t.BuildEngine = engine;
-            t.SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") };
-            t.DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") };
-            t.Retries = 1;
+            var engine = new MockEngine(true /* log to console */);
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 1,  // speed up tests!
+                BuildEngine = engine,
+                SourceFiles = new ITaskItem[] { new TaskItem("c:\\source") },
+                DestinationFiles = new ITaskItem[] { new TaskItem("c:\\destination") },
+                Retries = 1,
+                UseHardlinksIfPossible = UseHardLinks
+            };
 
-            CopyFunctor copyFunctor = new CopyFunctor(3, true /* throw */);
+            var copyFunctor = new CopyFunctor(3, true /* throw */);
             bool result = t.Execute(copyFunctor.Copy);
 
             Assert.Equal(false, result);
@@ -1828,30 +1806,22 @@ private class CopyFunctor
             /// <summary>
             /// On what attempt count should we stop failing?
             /// </summary>
-            private int _countOfSuccess;
+            private readonly int _countOfSuccess;
 
             /// <summary>
             /// Should we throw when we fail, instead of just returning false?
             /// </summary>
-            private bool _throwOnFailure;
+            private readonly bool _throwOnFailure;
 
             /// <summary>
             /// How many tries have we done so far
             /// </summary>
             private int _tries;
 
-            /// <summary>
-            /// Which files we actually copied.
-            /// </summary>
-            private List<FileState> _filesCopiedSuccessfully;
-
             /// <summary>
             /// Which files we actually copied
             /// </summary>
-            internal List<FileState> FilesCopiedSuccessfully
-            {
-                get { return _filesCopiedSuccessfully; }
-            }
+            internal List<FileState> FilesCopiedSuccessfully { get; }
 
             /// <summary>
             /// Constructor
@@ -1861,7 +1831,7 @@ internal CopyFunctor(int countOfSuccess, bool throwOnFailure)
                 _countOfSuccess = countOfSuccess;
                 _throwOnFailure = throwOnFailure;
                 _tries = 0;
-                _filesCopiedSuccessfully = new List<FileState>();
+                FilesCopiedSuccessfully = new List<FileState>();
             }
 
             /// <summary>
@@ -1872,10 +1842,10 @@ internal CopyFunctor(int countOfSuccess, bool throwOnFailure)
                 _tries++;
 
                 // 2nd and subsequent copies always succeed
-                if (_filesCopiedSuccessfully.Count > 0 || _countOfSuccess == _tries)
+                if (FilesCopiedSuccessfully.Count > 0 || _countOfSuccess == _tries)
                 {
                     Console.WriteLine("Copied {0} to {1} OK", source, destination);
-                    _filesCopiedSuccessfully.Add(source);
+                    FilesCopiedSuccessfully.Add(source);
                     return true;
                 }
 
@@ -1883,10 +1853,8 @@ internal CopyFunctor(int countOfSuccess, bool throwOnFailure)
                 {
                     throw new IOException("oops");
                 }
-                else
-                {
-                    return null;
-                }
+
+                return null;
             }
         }
     }
@@ -1896,7 +1864,7 @@ public class CopyNotHardLink_Tests : Copy_Tests
         public CopyNotHardLink_Tests(ITestOutputHelper testOutputHelper)
             : base(testOutputHelper)
         {
-            this.useHardLinks = false;
+            UseHardLinks = false;
         }
     }
 
@@ -1945,7 +1913,7 @@ public class CopyHardLink_Tests : Copy_Tests
         public CopyHardLink_Tests(ITestOutputHelper testOutputHelper)
             : base(testOutputHelper)
         {
-            this.useHardLinks = true;
+            this.UseHardLinks = true;
         }
 
         /// <summary>
@@ -1960,36 +1928,39 @@ public void CopyToDestinationFolderWithHardLinkCheck()
             string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
             try
             {
-                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a source temp file.");
+                }
 
                 // Don't create the dest folder, let task do that
 
-                ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
-
-                Copy t = new Copy();
-                t.RetryDelayMilliseconds = 1; // speed up tests!
-
-                // Allow the task's default (false) to have a chance
-                t.UseHardlinksIfPossible = true;
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
 
-                MockEngine me = new MockEngine(true);
-                t.BuildEngine = me;
-                t.SourceFiles = sourceFiles;
-                t.DestinationFolder = new TaskItem(destFolder);
-                t.SkipUnchangedFiles = true;
+                var me = new MockEngine(true);
+                var t = new Copy
+                {
+                    RetryDelayMilliseconds = 1, // speed up tests!
+                    BuildEngine = me,
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destFolder),
+                    SkipUnchangedFiles = true,
+                    UseHardlinksIfPossible = true
+                };
 
                 bool success = t.Execute();
 
                 Assert.True(success); // "success"
                 Assert.True(File.Exists(destFile)); // "destination exists"
-                Microsoft.Build.UnitTests.MockEngine.GetStringDelegate resourceDelegate = new Microsoft.Build.UnitTests.MockEngine.GetStringDelegate(AssemblyResources.GetString);
+                MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
 
                 me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.HardLinkComment", sourceFile, destFile);
 
                 string destinationFileContents;
                 using (StreamReader sr = FileUtilities.OpenRead(destFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is a source temp file.", destinationFileContents); //"Expected the destination hard linked file to contain the contents of source file."
 
@@ -2001,12 +1972,16 @@ public void CopyToDestinationFolderWithHardLinkCheck()
                 // Now we will write new content to the source file
                 // we'll then check that the destination file automatically
                 // has the same content (i.e. it's been hard linked)
-                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, false))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, false)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is another source temp file.");
+                }
 
                 // Read the destination file (it should have the same modified content as the source)
                 using (StreamReader sr = FileUtilities.OpenRead(destFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is another source temp file.", destinationFileContents); //"Expected the destination hard linked file to contain the contents of source file. Even after modification of the source"
 
@@ -2033,17 +2008,13 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()
             Marshal.GetExceptionForHR(errorCode);
 
             string sourceFile = FileUtilities.GetTemporaryFile();
-            string temp = @"\\localhost\c$\temp";
+            const string temp = @"\\localhost\c$\temp";
             string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
             string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
 
             try
             {
-                if (!Directory.Exists(destFolder))
-                {
-                    Directory.CreateDirectory(destFolder);
-                }
-
+                Directory.CreateDirectory(destFolder);
                 string nothingFile = Path.Combine(destFolder, "nothing.txt");
                 File.WriteAllText(nothingFile, "nothing");
                 File.Delete(nothingFile);
@@ -2057,13 +2028,15 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()
 
             try
             {
-                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is a source temp file.");
+                }
 
                 ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
 
-                MockEngine me = new MockEngine(true);
-                Copy t = new Copy
+                var me = new MockEngine(true);
+                var t = new Copy
                 {
                     RetryDelayMilliseconds = 1, // speed up tests!
                     UseHardlinksIfPossible = true,
@@ -2089,7 +2062,9 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()
 
                 string destinationFileContents;
                 using (StreamReader sr = FileUtilities.OpenRead(destFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is a source temp file.", destinationFileContents); //"Expected the destination file to contain the contents of source file."
 
@@ -2101,12 +2076,16 @@ public void CopyToDestinationFolderWithHardLinkFallbackNetwork()
                 // Now we will write new content to the source file
                 // we'll then check that the destination file automatically
                 // has the same content (i.e. it's been hard linked)
-                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, false))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, false)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is another source temp file.");
+                }
 
                 // Read the destination file (it should have the same modified content as the source)
                 using (StreamReader sr = FileUtilities.OpenRead(destFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is a source temp file.", destinationFileContents); //"Expected the destination copied file to contain the contents of original source file only."
 
@@ -2188,7 +2167,9 @@ public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
 
                 string destinationFileContents;
                 using (StreamReader sr = FileUtilities.OpenRead(destFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is a source temp file.", destinationFileContents); //"Expected the destination file to contain the contents of source file."
 
@@ -2200,12 +2181,16 @@ public void CopyToDestinationFolderWithHardLinkFallbackTooManyLinks()
                 // Now we will write new content to the source file
                 // we'll then check that the destination file automatically
                 // has the same content (i.e. it's been hard linked)
-                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, false))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, false)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                {
                     sw.Write("This is another source temp file.");
+                }
 
                 // Read the destination file (it should have the same modified content as the source)
                 using (StreamReader sr = FileUtilities.OpenRead(destFile))
+                {
                     destinationFileContents = sr.ReadToEnd();
+                }
 
                 Assert.Equal("This is a source temp file.", destinationFileContents); //"Expected the destination copied file to contain the contents of original source file only."
 
@@ -2225,7 +2210,7 @@ public class CopySymbolicLink_Tests : Copy_Tests
         public CopySymbolicLink_Tests(ITestOutputHelper testOutputHelper)
             : base(testOutputHelper)
         {
-            useSymbolicLinks = true;
+            UseSymbolicLinks = true;
         }
 
         /// <summary>
@@ -2253,24 +2238,25 @@ public void CopyToDestinationFolderWithSymbolicLinkCheck()
                 string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
                 try
                 {
-                    using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                    using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                    {
                         sw.Write("This is a source temp file.");
+                    }
 
                     // Don't create the dest folder, let task do that
 
-                    ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
+                    ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
 
-                    Copy t = new Copy();
-                    t.RetryDelayMilliseconds = 1; // speed up tests!
-
-                    // Allow the task's default (false) to have a chance
-                    t.UseSymboliclinksIfPossible = true;
-
-                    MockEngine me = new MockEngine(true);
-                    t.BuildEngine = me;
-                    t.SourceFiles = sourceFiles;
-                    t.DestinationFolder = new TaskItem(destFolder);
-                    t.SkipUnchangedFiles = true;
+                    var me = new MockEngine(true);
+                    var t = new Copy
+                    {
+                        RetryDelayMilliseconds = 1,  // speed up tests!
+                        BuildEngine = me,
+                        SourceFiles = sourceFiles,
+                        DestinationFolder = new TaskItem(destFolder),
+                        SkipUnchangedFiles = true,
+                        UseSymboliclinksIfPossible = true
+                    };
 
                     bool success = t.Execute();
 
@@ -2297,12 +2283,16 @@ public void CopyToDestinationFolderWithSymbolicLinkCheck()
                     // we'll then check that the destination file automatically
                     // has the same content (i.e. it's been hard linked)
 
-                    using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, false))    // HIGHCHAR: Test writes in UTF8 without preamble.
+                    using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, false)) // HIGHCHAR: Test writes in UTF8 without preamble.
+                    {
                         sw.Write("This is another source temp file.");
+                    }
 
                     // Read the destination file (it should have the same modified content as the source)
                     using (StreamReader sr = FileUtilities.OpenRead(destFile))
+                    {
                         destinationFileContents = sr.ReadToEnd();
+                    }
 
                     Assert.Equal("This is another source temp file.", destinationFileContents); //"Expected the destination hard linked file to contain the contents of source file. Even after modification of the source"
 
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index eadc2078a63..a7b495b66bb 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -51,35 +51,12 @@ public class ResolveAssemblyReference : TaskExtension
         /// <summary>
         /// Cache of system state information, used to optimize performance.
         /// </summary>
-        private SystemState _cache = null;
-
-        /// <summary>
-        /// Construct
-        /// </summary>
-        public ResolveAssemblyReference()
-        {
-        }
+        private SystemState _cache;
 
         #region Properties
 
-        private ITaskItem[] _assemblyFiles = Array.Empty<TaskItem>();
-        private ITaskItem[] _assemblyNames = Array.Empty<TaskItem>();
-        private ITaskItem[] _installedAssemblyTables = Array.Empty<TaskItem>();
         private ITaskItem[] _installedAssemblySubsetTables = Array.Empty<TaskItem>();
         private ITaskItem[] _fullFrameworkAssemblyTables = Array.Empty<TaskItem>();
-        private ITaskItem[] _resolvedSDKReferences = Array.Empty<TaskItem>();
-        private bool _ignoreDefaultInstalledAssemblyTables = false;
-        private bool _ignoreDefaultInstalledAssemblySubsetTables = false;
-        private string[] _candidateAssemblyFiles = Array.Empty<string>();
-        private string[] _targetFrameworkDirectories = Array.Empty<string>();
-        private string[] _searchPaths = Array.Empty<string>();
-        private string[] _allowedAssemblyExtensions = new string[] { ".winmd", ".dll", ".exe" };
-        private string[] _relatedFileExtensions = new string[] { ".pdb", ".xml", ".pri" };
-        private string _appConfigFile = null;
-        private bool _supportsBindingRedirectGeneration;
-        private bool _autoUnify = false;
-        private bool _ignoreVersionForFrameworkReferences = false;
-        private bool _ignoreTargetFrameworkAttributeVersionMismatch = false;
         private ITaskItem[] _resolvedFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _resolvedDependencyFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _relatedFiles = Array.Empty<TaskItem>();
@@ -90,43 +67,19 @@ public ResolveAssemblyReference()
         private ITaskItem[] _suggestedRedirects = Array.Empty<TaskItem>();
         private string[] _targetFrameworkSubsets = Array.Empty<string>();
         private string[] _fullTargetFrameworkSubsetNames = Array.Empty<string>();
-        private string _targetedFrameworkMoniker = String.Empty;
-
-        private bool _findDependencies = true;
-        private bool _findSatellites = true;
-        private bool _findSerializationAssemblies = true;
-        private bool _findRelatedFiles = true;
-        private bool _silent = false;
-        private string _projectTargetFrameworkAsString = String.Empty;
-        private string _targetedRuntimeVersionRawValue = String.Empty;
-        private Version _projectTargetFramework;
 
-        private string _stateFile = null;
-        private string _targetProcessorArchitecture = null;
+        private Version _projectTargetFramework;
 
         private string _profileName = String.Empty;
         private string[] _fullFrameworkFolders = Array.Empty<string>();
-        private string[] _latestTargetFrameworkDirectories = Array.Empty<string>();
-        private bool _copyLocalDependenciesWhenParentReferenceInGac = true;
-        private Dictionary<string, MessageImportance> _showAssemblyFoldersExLocations = new Dictionary<string, MessageImportance>(StringComparer.OrdinalIgnoreCase);
-        private bool _logVerboseSearchResults = false;
+        private readonly Dictionary<string, MessageImportance> _showAssemblyFoldersExLocations = new Dictionary<string, MessageImportance>(StringComparer.OrdinalIgnoreCase);
+        private bool _logVerboseSearchResults;
         private WarnOrErrorOnTargetArchitectureMismatchBehavior _warnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatchBehavior.Warning;
-        private bool _unresolveFrameworkAssembliesFromHigherFrameworks = false;
 
         /// <summary>
         /// If set to true, it forces to unresolve framework assemblies with versions higher or equal the version of the target framework, regardless of the target framework
         /// </summary>
-        public bool UnresolveFrameworkAssembliesFromHigherFrameworks
-        {
-            get
-            {
-                return _unresolveFrameworkAssembliesFromHigherFrameworks;
-            }
-            set
-            {
-                _unresolveFrameworkAssembliesFromHigherFrameworks = value;
-            }
-        }
+        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get; set; } = false;
 
         /// <summary>
         /// If there is a mismatch between the targetprocessor architecture and the architecture of a primary reference.
@@ -139,14 +92,10 @@ public bool UnresolveFrameworkAssembliesFromHigherFrameworks
         /// </summary>
         public string WarnOrErrorOnTargetArchitectureMismatch
         {
-            get
-            {
-                return _warnOrErrorOnTargetArchitectureMismatch.ToString();
-            }
-
+            get => _warnOrErrorOnTargetArchitectureMismatch.ToString();
             set
             {
-                if (!Enum.TryParse<WarnOrErrorOnTargetArchitectureMismatchBehavior>(value, /*ignoreCase*/true, out _warnOrErrorOnTargetArchitectureMismatch))
+                if (!Enum.TryParse(value, /*ignoreCase*/true, out _warnOrErrorOnTargetArchitectureMismatch))
                 {
                     _warnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatchBehavior.Warning;
                 }
@@ -165,11 +114,7 @@ public string WarnOrErrorOnTargetArchitectureMismatch
         ///        so several steps can be skipped as an optimization: finding dependencies, 
         ///        satellite assemblies, etc.
         /// </summary>
-        public ITaskItem[] AssemblyFiles
-        {
-            get { return _assemblyFiles; }
-            set { _assemblyFiles = value; }
-        }
+        public ITaskItem[] AssemblyFiles { get; set; } = Array.Empty<TaskItem>();
 
         /// <summary>
         /// The list of directories which contain the redist lists for the most current 
@@ -177,34 +122,12 @@ public ITaskItem[] AssemblyFiles
         /// Then we will looks for the highest framework installed on the machine 
         /// for a given target framework identifier and use that.
         /// </summary>
-        public string[] LatestTargetFrameworkDirectories
-        {
-            get
-            {
-                return _latestTargetFrameworkDirectories;
-            }
-
-            set
-            {
-                _latestTargetFrameworkDirectories = value;
-            }
-        }
+        public string[] LatestTargetFrameworkDirectories { get; set; } = Array.Empty<string>();
 
         /// <summary>
         /// Should the framework attribute be ignored when checking to see if an assembly is compatible with the targeted framework.
         /// </summary>
-        public bool IgnoreTargetFrameworkAttributeVersionMismatch
-        {
-            get
-            {
-                return _ignoreTargetFrameworkAttributeVersionMismatch;
-            }
-
-            set
-            {
-                _ignoreTargetFrameworkAttributeVersionMismatch = value;
-            }
-        }
+        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get; set; } = false;
 
         /// <summary>
         /// Force dependencies to be walked even when a reference is marked with ExternallyResolved=true
@@ -221,7 +144,7 @@ public bool IgnoreTargetFrameworkAttributeVersionMismatch
         /// </summary>
         public string[] TargetFrameworkSubsets
         {
-            get { return _targetFrameworkSubsets; }
+            get => _targetFrameworkSubsets;
             set
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "TargetFrameworkSubsets");
@@ -264,11 +187,7 @@ public string[] TargetFrameworkSubsets
         ///         when true, we should treat this assembly as if it has no dependencies and should 
         ///         be completely embedded into the target assembly.
         /// </summary>
-        public ITaskItem[] Assemblies
-        {
-            get { return _assemblyNames; }
-            set { _assemblyNames = value; }
-        }
+        public ITaskItem[] Assemblies { get; set; } = Array.Empty<TaskItem>();
 
         /// <summary>
         /// A list of assembly files that can be part of the search and resolution process.
@@ -277,21 +196,13 @@ public ITaskItem[] Assemblies
         /// Assembly files in this list will be considered when SearchPaths contains
         /// {CandidateAssemblyFiles} as one of the paths to consider.
         /// </summary>
-        public string[] CandidateAssemblyFiles
-        {
-            get { return _candidateAssemblyFiles; }
-            set { _candidateAssemblyFiles = value; }
-        }
+        public string[] CandidateAssemblyFiles { get; set; } = Array.Empty<string>();
 
         /// <summary>
         /// A list of resolved SDK references which contain the sdk name, sdk location and the targeted configuration.
         /// These locations will only be searched if the reference has the SDKName metadata attached to it.
         /// </summary>
-        public ITaskItem[] ResolvedSDKReferences
-        {
-            get { return _resolvedSDKReferences; }
-            set { _resolvedSDKReferences = value; }
-        }
+        public ITaskItem[] ResolvedSDKReferences { get; set; } = Array.Empty<TaskItem>();
 
         /// <summary>
         /// Path to the target frameworks directory. Required to figure out CopyLocal status 
@@ -299,11 +210,7 @@ public ITaskItem[] ResolvedSDKReferences
         /// If not present, then no resulting items will be deemed CopyLocal='true' unless they explicity 
         /// have a Private='true' attribute on their source item.
         /// </summary>
-        public string[] TargetFrameworkDirectories
-        {
-            get { return _targetFrameworkDirectories; }
-            set { _targetFrameworkDirectories = value; }
-        }
+        public string[] TargetFrameworkDirectories { get; set; } = Array.Empty<string>();
 
         /// <summary>
         /// A list of XML files that contain assemblies that are expected to be installed on the target machine.
@@ -325,11 +232,7 @@ public string[] TargetFrameworkDirectories
         /// "FrameworkDirectory" metadata will be treated as though this metadata is set to the lone (unique) value passed
         /// to TargetFrameworkDirectories.
         /// </summary>
-        public ITaskItem[] InstalledAssemblyTables
-        {
-            get { return _installedAssemblyTables; }
-            set { _installedAssemblyTables = value; }
-        }
+        public ITaskItem[] InstalledAssemblyTables { get; set; } = Array.Empty<TaskItem>();
 
         /// <summary>
         /// A list of XML files that contain assemblies that are expected to be in the target subset
@@ -349,7 +252,7 @@ public ITaskItem[] InstalledAssemblyTables
         /// </summary>
         public ITaskItem[] InstalledAssemblySubsetTables
         {
-            get { return _installedAssemblySubsetTables; }
+            get => _installedAssemblySubsetTables;
             set
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "InstalledAssemblySubsetTables");
@@ -376,7 +279,7 @@ public ITaskItem[] InstalledAssemblySubsetTables
         /// </summary>
         public ITaskItem[] FullFrameworkAssemblyTables
         {
-            get { return _fullFrameworkAssemblyTables; }
+            get => _fullFrameworkAssemblyTables;
             set
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "FullFrameworkAssemblyTables");
@@ -390,11 +293,7 @@ public ITaskItem[] FullFrameworkAssemblyTables
         /// assembly tables (a.k.a Redist Lists) found in the RedistList directory underneath the provided
         /// TargetFrameworkDirectories.
         /// </summary>
-        public bool IgnoreDefaultInstalledAssemblyTables
-        {
-            get { return _ignoreDefaultInstalledAssemblyTables; }
-            set { _ignoreDefaultInstalledAssemblyTables = value; }
-        }
+        public bool IgnoreDefaultInstalledAssemblyTables { get; set; } = false;
 
         /// <summary>
         /// [default=false]
@@ -402,20 +301,12 @@ public bool IgnoreDefaultInstalledAssemblyTables
         /// assembly subset tables (a.k.a Subset Lists) found in the SubsetList directory underneath the provided
         /// TargetFrameworkDirectories.
         /// </summary>
-        public bool IgnoreDefaultInstalledAssemblySubsetTables
-        {
-            get { return _ignoreDefaultInstalledAssemblySubsetTables; }
-            set { _ignoreDefaultInstalledAssemblySubsetTables = value; }
-        }
+        public bool IgnoreDefaultInstalledAssemblySubsetTables { get; set; } = false;
 
         /// <summary>
         /// If the primary reference is a framework assembly ignore its version information and actually resolve the framework assembly from the currently targeted framework.
         /// </summary>
-        public bool IgnoreVersionForFrameworkReferences
-        {
-            get { return _ignoreVersionForFrameworkReferences; }
-            set { _ignoreVersionForFrameworkReferences = value; }
-        }
+        public bool IgnoreVersionForFrameworkReferences { get; set; } = false;
 
         /// <summary>
         /// The preferred target processor architecture. Used for resolving {GAC} references. 
@@ -429,20 +320,12 @@ public bool IgnoreVersionForFrameworkReferences
         /// If absent, then only consider assemblies in the GAC that have ProcessorArchitecture==MSIL or
         /// no ProcessorArchitecture (these are pre-Whidbey assemblies).
         /// </summary>
-        public string TargetProcessorArchitecture
-        {
-            get { return _targetProcessorArchitecture; }
-            set { _targetProcessorArchitecture = value; }
-        }
+        public string TargetProcessorArchitecture { get; set; } = null;
 
         /// <summary>
         /// What is the runtime we are targeting, is it 2.0.57027 or anotherone, It can have a v or not prefixed onto it.
         /// </summary>
-        public string TargetedRuntimeVersion
-        {
-            get { return _targetedRuntimeVersionRawValue; }
-            set { _targetedRuntimeVersionRawValue = value; }
-        }
+        public string TargetedRuntimeVersion { get; set; } = String.Empty;
 
         /// <summary>
         /// List of locations to search for assemblyFiles when resolving dependencies.
@@ -483,32 +366,20 @@ public string TargetedRuntimeVersion
         /// </summary>
         /// <value></value>
         [Required]
-        public string[] SearchPaths
-        {
-            get { return _searchPaths; }
-            set { _searchPaths = value; }
-        }
+        public string[] SearchPaths { get; set; } = Array.Empty<string>();
 
         /// <summary>
         /// [default=.exe;.dll]
         /// These are the assembly extensions that will be considered during references resolution.
         /// </summary>
-        public string[] AllowedAssemblyExtensions
-        {
-            get { return _allowedAssemblyExtensions; }
-            set { _allowedAssemblyExtensions = value; }
-        }
+        public string[] AllowedAssemblyExtensions { get; set; } = { ".winmd", ".dll", ".exe" };
 
 
         /// <summary>
         /// [default=.pdb;.xml]
         /// These are the extensions that will be considered when looking for related files.
         /// </summary>
-        public string[] AllowedRelatedFileExtensions
-        {
-            get { return _relatedFileExtensions; }
-            set { _relatedFileExtensions = value; }
-        }
+        public string[] AllowedRelatedFileExtensions { get; set; } = { ".pdb", ".xml", ".pri" };
 
 
         /// <summary>
@@ -518,21 +389,13 @@ public string[] AllowedRelatedFileExtensions
         /// If this parameter is passed in, then AutoUnify must be false, otherwise error.
         /// </summary>
         /// <value></value>
-        public string AppConfigFile
-        {
-            get { return _appConfigFile; }
-            set { _appConfigFile = value; }
-        }
+        public string AppConfigFile { get; set; }
 
         /// <summary>
         /// This is true if the project type supports "AutoGenerateBindingRedirects" (currently only for EXE projects).
         /// </summary>
         /// <value></value>
-        public bool SupportsBindingRedirectGeneration
-        {
-            get { return _supportsBindingRedirectGeneration; }
-            set { _supportsBindingRedirectGeneration = value; }
-        }
+        public bool SupportsBindingRedirectGeneration { get; set; }
 
         /// <summary>
         /// [default=false]
@@ -560,13 +423,8 @@ public bool SupportsBindingRedirectGeneration
         /// different versions of reference and dependent assemblies".
         /// </summary>
         /// <value></value>
-        public bool AutoUnify
-        {
-            get { return _autoUnify; }
-            set { _autoUnify = value; }
-        }
-
-
+        public bool AutoUnify { get; set; } = false;
+        
         /// <summary>
         ///  When determining if a dependency should be copied locally one of the checks done is to see if the 
         ///  parent reference in the project file has the Private metadata set or not. If that metadata is set then 
@@ -585,33 +443,21 @@ public bool AutoUnify
         /// 
         /// NOTE: If there are multiple parent reference and ANY of them does not come from the GAC then we will set copy local to true.
         /// </summary>
-        public bool CopyLocalDependenciesWhenParentReferenceInGac
-        {
-            get { return _copyLocalDependenciesWhenParentReferenceInGac; }
-            set { _copyLocalDependenciesWhenParentReferenceInGac = value; }
-        }
+        public bool CopyLocalDependenciesWhenParentReferenceInGac { get; set; } = true;
 
         /// <summary>
         /// [default=false]
         /// Enables legacy mode for CopyLocal determination. If true, referenced assemblies will not be copied locally if they
         /// are found in the GAC. If false, assemblies will be copied locally unless they were found only in the GAC.
         /// </summary>
-        public bool DoNotCopyLocalIfInGac
-        {
-            get;
-            set;
-        }
+        public bool DoNotCopyLocalIfInGac { get; set; }
 
         /// <summary>
         /// An optional file name that indicates where to save intermediate build state
         /// for this task. If not specified, then no inter-build caching will occur.
         /// </summary>
         /// <value></value>
-        public string StateFile
-        {
-            get { return _stateFile; }
-            set { _stateFile = value; }
-        }
+        public string StateFile { get; set; }
 
         /// <summary>
         /// If set, then dependencies will be found. Otherwise, only Primary references will be
@@ -620,11 +466,7 @@ public string StateFile
         /// Default is true.
         /// </summary>
         /// <value></value>
-        public bool FindDependencies
-        {
-            get { return _findDependencies; }
-            set { _findDependencies = value; }
-        }
+        public bool FindDependencies { get; set; } = true;
 
         /// <summary>
         /// If set, then satellites will be found.
@@ -632,11 +474,7 @@ public bool FindDependencies
         /// Default is true.
         /// </summary>
         /// <value></value>
-        public bool FindSatellites
-        {
-            get { return _findSatellites; }
-            set { _findSatellites = value; }
-        }
+        public bool FindSatellites { get; set; } = true;
 
         /// <summary>
         /// If set, then serialization assemblies will be found.
@@ -644,11 +482,7 @@ public bool FindSatellites
         /// Default is true.
         /// </summary>
         /// <value></value>
-        public bool FindSerializationAssemblies
-        {
-            get { return _findSerializationAssemblies; }
-            set { _findSerializationAssemblies = value; }
-        }
+        public bool FindSerializationAssemblies { get; set; } = true;
 
         /// <summary>
         /// If set, then related files (.pdbs and .xmls) will be found.
@@ -656,11 +490,7 @@ public bool FindSerializationAssemblies
         /// Default is true.
         /// </summary>
         /// <value></value>
-        public bool FindRelatedFiles
-        {
-            get { return _findRelatedFiles; }
-            set { _findRelatedFiles = value; }
-        }
+        public bool FindRelatedFiles { get; set; } = true;
 
         /// <summary>
         /// If set, then don't log any messages to the screen.
@@ -668,11 +498,7 @@ public bool FindRelatedFiles
         /// Default is false.
         /// </summary>
         /// <value></value>
-        public bool Silent
-        {
-            get { return _silent; }
-            set { _silent = value; }
-        }
+        public bool Silent { get; set; }
 
         /// <summary>
         /// The project target framework version.
@@ -680,11 +506,7 @@ public bool Silent
         /// Default is empty. which means there will be no filtering for the reference based on their target framework.
         /// </summary>
         /// <value></value>
-        public string TargetFrameworkVersion
-        {
-            get { return _projectTargetFrameworkAsString; }
-            set { _projectTargetFrameworkAsString = value; }
-        }
+        public string TargetFrameworkVersion { get; set; } = String.Empty;
 
         /// <summary>
         /// The target framework moniker we are targeting if any. This is used for logging purposes.
@@ -692,20 +514,12 @@ public string TargetFrameworkVersion
         /// Default is empty.
         /// </summary>
         /// <value></value>
-        public string TargetFrameworkMoniker
-        {
-            get { return _targetedFrameworkMoniker; }
-            set { _targetedFrameworkMoniker = value; }
-        }
+        public string TargetFrameworkMoniker { get; set; } = String.Empty;
 
         /// <summary>
         /// The display name of the target framework moniker, if any. This is only for logging.
         /// </summary>
-        public string TargetFrameworkMonikerDisplayName
-        {
-            get;
-            set;
-        }
+        public string TargetFrameworkMonikerDisplayName { get; set; }
 
         /// <summary>
         /// Provide a set of names which if seen in the TargetFrameworkSubset list will cause the ignoring 
@@ -715,11 +529,7 @@ public string TargetFrameworkMonikerDisplayName
         /// </summary>
         public string[] FullTargetFrameworkSubsetNames
         {
-            get
-            {
-                return _fullTargetFrameworkSubsetNames;
-            }
-
+            get => _fullTargetFrameworkSubsetNames;
             set
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "FullTargetFrameworkSubsetNames");
@@ -733,11 +543,7 @@ public string[] FullTargetFrameworkSubsetNames
         /// </summary>
         public string ProfileName
         {
-            get
-            {
-                return _profileName;
-            }
-
+            get => _profileName;
             set
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "profileName");
@@ -752,11 +558,7 @@ public string ProfileName
         /// </summary>
         public string[] FullFrameworkFolders
         {
-            get
-            {
-                return _fullFrameworkFolders;
-            }
-
+            get => _fullFrameworkFolders;
             set
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "FullFrameworkFolders");
@@ -777,10 +579,7 @@ public string[] FullFrameworkFolders
         ///     string Redist - The name (if any) of the redist that contains this assembly.
         /// </summary>
         [Output]
-        public ITaskItem[] ResolvedFiles
-        {
-            get { return _resolvedFiles; }
-        }
+        public ITaskItem[] ResolvedFiles => _resolvedFiles;
 
         /// <summary>
         /// A list of all n-th order paths-to-dependencies with the following attributes:
@@ -796,10 +595,7 @@ public ITaskItem[] ResolvedFiles
         /// Does not include first order primary references--this list is in ResolvedFiles.
         /// </summary>
         [Output]
-        public ITaskItem[] ResolvedDependencyFiles
-        {
-            get { return _resolvedDependencyFiles; }
-        }
+        public ITaskItem[] ResolvedDependencyFiles => _resolvedDependencyFiles;
 
         /// <summary>
         /// Related files are files like intellidoc (.XML) and symbols (.PDB) that have the same base
@@ -808,10 +604,7 @@ public ITaskItem[] ResolvedDependencyFiles
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
         /// </summary>
         [Output]
-        public ITaskItem[] RelatedFiles
-        {
-            get { return _relatedFiles; }
-        }
+        public ITaskItem[] RelatedFiles => _relatedFiles;
 
         /// <summary>
         /// Any satellite files found. These will be CopyLocal=true iff the reference or dependency 
@@ -821,10 +614,7 @@ public ITaskItem[] RelatedFiles
         ///       should be copied to. This is mainly for satellites.
         /// </summary>
         [Output]
-        public ITaskItem[] SatelliteFiles
-        {
-            get { return _satelliteFiles; }
-        }
+        public ITaskItem[] SatelliteFiles => _satelliteFiles;
 
         /// <summary>
         /// Any XML serialization assemblies found. These will be CopyLocal=true iff the reference or dependency 
@@ -832,20 +622,14 @@ public ITaskItem[] SatelliteFiles
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
         /// </summary>
         [Output]
-        public ITaskItem[] SerializationAssemblyFiles
-        {
-            get { return _serializationAssemblyFiles; }
-        }
+        public ITaskItem[] SerializationAssemblyFiles => _serializationAssemblyFiles;
 
         /// <summary>
         /// Scatter files associated with one of the given assemblies.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
         /// </summary>
         [Output]
-        public ITaskItem[] ScatterFiles
-        {
-            get { return _scatterFiles; }
-        }
+        public ITaskItem[] ScatterFiles => _scatterFiles;
 
         /// <summary>
         /// Returns every file in ResolvedFiles+ResolvedDependencyFiles+RelatedFiles+SatelliteFiles+ScatterFiles+SatelliteAssemblyFiles
@@ -853,10 +637,7 @@ public ITaskItem[] ScatterFiles
         /// </summary>
         /// <value></value>
         [Output]
-        public ITaskItem[] CopyLocalFiles
-        {
-            get { return _copyLocalFiles; }
-        }
+        public ITaskItem[] CopyLocalFiles => _copyLocalFiles;
 
         /// <summary>
         /// Regardless of the value of AutoUnify, returns one item for every distinct conflicting assembly 
@@ -868,15 +649,12 @@ public ITaskItem[] CopyLocalFiles
         ///  MaxVersion - the maximum version number.
         /// </summary>
         [Output]
-        public ITaskItem[] SuggestedRedirects
-        {
-            get { return _suggestedRedirects; }
-        }
+        public ITaskItem[] SuggestedRedirects => _suggestedRedirects;
 
         /// <summary>
         /// Storage for names of all files writen to disk.
         /// </summary>
-        private ArrayList _filesWritten = new ArrayList();
+        private readonly ArrayList _filesWritten = new ArrayList();
 
         /// <summary>
         /// The names of all files written to disk.
@@ -892,22 +670,13 @@ public ITaskItem[] FilesWritten
         /// Whether the assembly or any of its primary references depends on system.runtime. (Aka needs Facade references to resolve duplicate types)
         /// </summary>
         [Output]
-        public String DependsOnSystemRuntime
-        {
-            get;
-            private set;
-        }
+        public String DependsOnSystemRuntime { get; private set; }
 
         /// <summary>
         /// Whether the assembly or any of its primary references depends on netstandard
         /// </summary>
         [Output]
-        public String DependsOnNETStandard
-        {
-            get;
-            private set;
-        }
-
+        public String DependsOnNETStandard { get; private set; }
 
         #endregion
         #region Logging
@@ -1042,7 +811,6 @@ quiet at the engine level.
                                         assemblyIdentityAttributes.Add(new XAttribute("name", idealRemappingPartialAssemblyName.Name));
 
                                         // We use "neutral" for "Invariant Language (Invariant Country)" in assembly names.
-                                        var cultureString = idealRemappingPartialAssemblyName.CultureName;
                                         assemblyIdentityAttributes.Add(new XAttribute("culture", String.IsNullOrEmpty(idealRemappingPartialAssemblyName.CultureName) ? "neutral" : idealRemappingPartialAssemblyName.CultureName));
 
                                         var publicKeyToken = idealRemappingPartialAssemblyName.GetPublicKeyToken();
@@ -1098,9 +866,8 @@ quiet at the engine level.
                     // Log general resolution exceptions.
                     foreach (Exception error in generalResolutionExceptions)
                     {
-                        if (error is InvalidReferenceAssemblyNameException)
+                        if (error is InvalidReferenceAssemblyNameException e)
                         {
-                            InvalidReferenceAssemblyNameException e = (InvalidReferenceAssemblyNameException)error;
                             Log.LogWarningWithCodeFromResources("General.MalformedAssemblyName", e.SourceItemSpec);
                         }
                         else
@@ -1117,9 +884,9 @@ quiet at the engine level.
             {
                 foreach (Resolver r in dependencyTable.Resolvers)
                 {
-                    if (r is AssemblyFoldersExResolver)
+                    if (r is AssemblyFoldersExResolver resolver)
                     {
-                        AssemblyFoldersEx assemblyFoldersEx = ((AssemblyFoldersExResolver)r).AssemblyFoldersExLocations;
+                        AssemblyFoldersEx assemblyFoldersEx = resolver.AssemblyFoldersExLocations;
 
                         MessageImportance messageImportance = MessageImportance.Low;
                         if (assemblyFoldersEx != null && _showAssemblyFoldersExLocations.TryGetValue(r.SearchPath, out messageImportance))
@@ -1150,7 +917,9 @@ internal static string ByteArrayToString(byte[] a)
 
             var buffer = new StringBuilder(a.Length * 2);
             for (int i = 0; i < a.Length; ++i)
+            {
                 buffer.Append(a[i].ToString("x2", CultureInfo.InvariantCulture));
+            }
 
             return buffer.ToString();
         }
@@ -1246,7 +1015,7 @@ private void LogReference(Reference reference, string fusionName)
         /// Choose an importance level for reporting information about this reference.
         /// </summary>
         /// <param name="reference">The reference.</param>
-        private MessageImportance ChooseReferenceLoggingImportance(Reference reference)
+        private static MessageImportance ChooseReferenceLoggingImportance(Reference reference)
         {
             MessageImportance importance = MessageImportance.Low;
 
@@ -1275,13 +1044,13 @@ private void LogInputs()
             if (!Silent)
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "TargetFrameworkMoniker");
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", _targetedFrameworkMoniker);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", TargetFrameworkMoniker);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "TargetFrameworkMonikerDisplayName");
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", TargetFrameworkMonikerDisplayName);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "TargetedRuntimeVersion");
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", _targetedRuntimeVersionRawValue);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", TargetedRuntimeVersion);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "Assemblies");
                 foreach (ITaskItem item in Assemblies)
@@ -1308,7 +1077,7 @@ private void LogInputs()
                 {
                     try
                     {
-                        if (FileUtilities.HasExtension(file, _allowedAssemblyExtensions))
+                        if (FileUtilities.HasExtension(file, AllowedAssemblyExtensions))
                         {
                             Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", file);
                         }
@@ -1330,7 +1099,7 @@ private void LogInputs()
                 }
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "IgnoreInstalledAssemblyTable");
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", _ignoreDefaultInstalledAssemblyTables);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", IgnoreDefaultInstalledAssemblyTables);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "SearchPaths");
                 foreach (string path in SearchPaths)
@@ -1339,13 +1108,13 @@ private void LogInputs()
                 }
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "AllowedAssemblyExtensions");
-                foreach (string allowedAssemblyExtension in _allowedAssemblyExtensions)
+                foreach (string allowedAssemblyExtension in AllowedAssemblyExtensions)
                 {
                     Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", allowedAssemblyExtension);
                 }
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "AllowedRelatedFileExtensions");
-                foreach (string allowedRelatedFileExtension in _relatedFileExtensions)
+                foreach (string allowedRelatedFileExtension in AllowedRelatedFileExtensions)
                 {
                     Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", allowedRelatedFileExtension);
                 }
@@ -1357,10 +1126,10 @@ private void LogInputs()
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", AutoUnify.ToString());
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "CopyLocalDependenciesWhenParentReferenceInGac");
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", _copyLocalDependenciesWhenParentReferenceInGac);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", CopyLocalDependenciesWhenParentReferenceInGac);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "FindDependencies");
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", _findDependencies);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", FindDependencies);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "TargetProcessorArchitecture");
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", TargetProcessorArchitecture);
@@ -1376,7 +1145,7 @@ private void LogInputs()
                 }
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "IgnoreInstalledAssemblySubsetTable");
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", _ignoreDefaultInstalledAssemblySubsetTables);
+                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", IgnoreDefaultInstalledAssemblySubsetTables);
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "TargetFrameworkSubsets");
                 foreach (string subset in _targetFrameworkSubsets)
@@ -1400,7 +1169,7 @@ private void LogInputs()
                 }
 
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "LatestTargetFrameworkDirectories");
-                foreach (string latestFolder in _latestTargetFrameworkDirectories)
+                foreach (string latestFolder in LatestTargetFrameworkDirectories)
                 {
                     Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", latestFolder);
                 }
@@ -1418,12 +1187,10 @@ private void LogInputs()
         /// <summary>
         /// Log a specific item metadata.
         /// </summary>
-        /// <param name="item"></param>
-        /// <param name="attribute"></param>
         private void LogAttribute(ITaskItem item, string metadataName)
         {
             string metadataValue = item.GetMetadata(metadataName);
-            if (metadataValue != null && metadataValue.Length > 0)
+            if (!string.IsNullOrEmpty(metadataValue))
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.EightSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.LogAttributeFormat", metadataName, metadataValue));
             }
@@ -1471,7 +1238,7 @@ private void LogPrimaryOrDependency(Reference reference, string fusionName, Mess
                         }
                         else
                         {
-                            Log.LogMessageFromResources(importance, "ResolveAssemblyReference.FourSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.UnificationByAppConfig", unificationVersion.version, _appConfigFile, unificationVersion.referenceFullPath));
+                            Log.LogMessageFromResources(importance, "ResolveAssemblyReference.FourSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.UnificationByAppConfig", unificationVersion.version, AppConfigFile, unificationVersion.referenceFullPath));
                         }
                         break;
 
@@ -1531,8 +1298,7 @@ private void LogReferenceErrors(Reference reference, MessageImportance importanc
                     Debug.Assert(false, "Unexpected exception type.");
                 }
 
-                string messageOnly;
-                string warningCode = Log.ExtractMessageCode(message, out messageOnly);
+                string warningCode = Log.ExtractMessageCode(message, out string messageOnly);
 
                 // Treat as warning if this is primary and the problem wasn't with a dependency, otherwise, make it a comment.
                 if (reference.IsPrimary && !dependencyProblem)
@@ -1585,8 +1351,7 @@ private void LogAssembliesConsideredAndRejected(Reference reference, string fusi
                     if (logAssemblyFoldersMinimal)
                     {
                         // We not only need to track if we logged a message but also what importance. We want the logging of the assemblyfoldersex folder structure to match the same importance.
-                        MessageImportance messageImportance = MessageImportance.Low;
-                        if (!_showAssemblyFoldersExLocations.TryGetValue(location.SearchPath, out messageImportance))
+                        if (!_showAssemblyFoldersExLocations.TryGetValue(location.SearchPath, out MessageImportance messageImportance))
                         {
                             _showAssemblyFoldersExLocations.Add(location.SearchPath, importance);
                         }
@@ -1644,7 +1409,7 @@ private void LogAssembliesConsideredAndRejected(Reference reference, string fusi
                                 break;
                             }
                         case NoMatchReason.ProcessorArchitectureDoesNotMatch:
-                            Log.LogMessageFromResources(importance, "ResolveAssemblyReference.EightSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch", location.FileNameAttempted, location.AssemblyName.AssemblyName.ProcessorArchitecture.ToString(), _targetProcessorArchitecture));
+                            Log.LogMessageFromResources(importance, "ResolveAssemblyReference.EightSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.TargetedProcessorArchitectureDoesNotMatch", location.FileNameAttempted, location.AssemblyName.AssemblyName.ProcessorArchitecture.ToString(), TargetProcessorArchitecture));
                             break;
                         default:
                             Debug.Assert(false, "Should have handled this case.");
@@ -1844,7 +1609,7 @@ private void LogConflict(Reference reference, string fusionName)
         /// </summary>
         private void ReadStateFile()
         {
-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));
+            _cache = (SystemState)StateFileBase.DeserializeCache(StateFile, Log, typeof(SystemState));
 
             // Construct the cache if necessary.
             if (_cache == null)
@@ -1858,9 +1623,9 @@ private void ReadStateFile()
         /// </summary>
         private void WriteStateFile()
         {
-            if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
+            if (!string.IsNullOrEmpty(StateFile) && _cache.IsDirty)
             {
-                _cache.SerializeCache(_stateFile, Log);
+                _cache.SerializeCache(StateFile, Log);
             }
         }
         #endregion
@@ -1872,10 +1637,10 @@ private void WriteStateFile()
         /// <returns></returns>
         private DependentAssembly[] GetAssemblyRemappingsFromAppConfig()
         {
-            if (_appConfigFile != null)
+            if (AppConfigFile != null)
             {
                 AppConfig appConfig = new AppConfig();
-                appConfig.Load(_appConfigFile);
+                appConfig.Load(AppConfigFile);
 
                 return appConfig.Runtime.DependentAssemblies;
             }
@@ -1927,21 +1692,21 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                 try
                 {
                     FrameworkNameVersioning frameworkMoniker = null;
-                    if (!String.IsNullOrEmpty(_targetedFrameworkMoniker))
+                    if (!String.IsNullOrEmpty(TargetFrameworkMoniker))
                     {
                         try
                         {
-                            frameworkMoniker = new FrameworkNameVersioning(_targetedFrameworkMoniker);
+                            frameworkMoniker = new FrameworkNameVersioning(TargetFrameworkMoniker);
                         }
                         catch (ArgumentException)
                         {
                             // The exception doesn't contain the bad value, so log it ourselves
-                            Log.LogErrorWithCodeFromResources("ResolveAssemblyReference.InvalidParameter", "TargetFrameworkMoniker", _targetedFrameworkMoniker, String.Empty);
+                            Log.LogErrorWithCodeFromResources("ResolveAssemblyReference.InvalidParameter", "TargetFrameworkMoniker", TargetFrameworkMoniker, String.Empty);
                             return false;
                         }
                     }
 
-                    Version targetedRuntimeVersion = SetTargetedRuntimeVersion(_targetedRuntimeVersionRawValue);
+                    Version targetedRuntimeVersion = SetTargetedRuntimeVersion(TargetedRuntimeVersion);
 
                     // Log task inputs.
                     LogInputs();
@@ -1956,17 +1721,17 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     // Loop through all the target framework directories that were passed in,
                     // and ensure that they all have a trailing slash.  This is necessary
                     // for the string comparisons we will do later on.
-                    if (_targetFrameworkDirectories != null)
+                    if (TargetFrameworkDirectories != null)
                     {
-                        for (int i = 0; i < _targetFrameworkDirectories.Length; i++)
+                        for (int i = 0; i < TargetFrameworkDirectories.Length; i++)
                         {
-                            _targetFrameworkDirectories[i] = FileUtilities.EnsureTrailingSlash(_targetFrameworkDirectories[i]);
+                            TargetFrameworkDirectories[i] = FileUtilities.EnsureTrailingSlash(TargetFrameworkDirectories[i]);
                         }
                     }
 
 
                     // Validate the contents of the InstalledAssemblyTables parameter.
-                    AssemblyTableInfo[] installedAssemblyTableInfo = GetInstalledAssemblyTableInfo(_ignoreDefaultInstalledAssemblyTables, _installedAssemblyTables, new GetListPath(RedistList.GetRedistListPathsFromDisk), TargetFrameworkDirectories);
+                    AssemblyTableInfo[] installedAssemblyTableInfo = GetInstalledAssemblyTableInfo(IgnoreDefaultInstalledAssemblyTables, InstalledAssemblyTables, new GetListPath(RedistList.GetRedistListPathsFromDisk), TargetFrameworkDirectories);
                     AssemblyTableInfo[] whiteListSubsetTableInfo = null;
 
                     InstalledAssemblies installedAssemblies = null;
@@ -2084,7 +1849,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     getDirectories = _cache.CacheDelegate(getDirectories);
                     getRuntimeVersion = _cache.CacheDelegate(getRuntimeVersion);
 
-                    _projectTargetFramework = FrameworkVersionFromString(_projectTargetFrameworkAsString);
+                    _projectTargetFramework = FrameworkVersionFromString(TargetFrameworkVersion);
 
                     // Filter out all Assemblies that have SubType!='', or higher framework
                     FilterBySubtypeAndTargetFramework();
@@ -2104,7 +1869,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         }
                     }
 
-                    SystemProcessorArchitecture processorArchitecture = TargetProcessorArchitectureToEnumeration(_targetProcessorArchitecture);
+                    SystemProcessorArchitecture processorArchitecture = TargetProcessorArchitectureToEnumeration(TargetProcessorArchitecture);
 
                     ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache =
                         Traits.Instance.EscapeHatches.CacheAssemblyInformation
@@ -2115,16 +1880,16 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     ReferenceTable dependencyTable = new ReferenceTable
                     (
                         BuildEngine,
-                        _findDependencies,
-                        _findSatellites,
-                        _findSerializationAssemblies,
-                        _findRelatedFiles,
-                        _searchPaths,
-                        _allowedAssemblyExtensions,
-                        _relatedFileExtensions,
-                        _candidateAssemblyFiles,
-                        _resolvedSDKReferences,
-                        _targetFrameworkDirectories,
+                        FindDependencies,
+                        FindSatellites,
+                        FindSerializationAssemblies,
+                        FindRelatedFiles,
+                        SearchPaths,
+                        AllowedAssemblyExtensions,
+                        AllowedRelatedFileExtensions,
+                        CandidateAssemblyFiles,
+                        ResolvedSDKReferences,
+                        TargetFrameworkDirectories,
                         installedAssemblies,
                         processorArchitecture,
                         fileExists,
@@ -2142,16 +1907,16 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         _projectTargetFramework,
                         frameworkMoniker,
                         Log,
-                        _latestTargetFrameworkDirectories,
-                        _copyLocalDependenciesWhenParentReferenceInGac,
+                        LatestTargetFrameworkDirectories,
+                        CopyLocalDependenciesWhenParentReferenceInGac,
                         DoNotCopyLocalIfInGac,
                         getAssemblyPathInGac,
                         isWinMDFile,
-                        _ignoreVersionForFrameworkReferences,
+                        IgnoreVersionForFrameworkReferences,
                         readMachineTypeFromPEHeader,
                         _warnOrErrorOnTargetArchitectureMismatch,
-                        _ignoreTargetFrameworkAttributeVersionMismatch,
-                        _unresolveFrameworkAssembliesFromHigherFrameworks,
+                        IgnoreTargetFrameworkAttributeVersionMismatch,
+                        UnresolveFrameworkAssembliesFromHigherFrameworks,
                         assemblyMetadataCache
                         );
 
@@ -2160,7 +1925,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     // If AutoUnify, then compute the set of assembly remappings.
                     ArrayList generalResolutionExceptions = new ArrayList();
 
-                    subsetOrProfileName = targetingSubset && String.IsNullOrEmpty(_targetedFrameworkMoniker) ? subsetOrProfileName : _targetedFrameworkMoniker;
+                    subsetOrProfileName = targetingSubset && String.IsNullOrEmpty(TargetFrameworkMoniker) ? subsetOrProfileName : TargetFrameworkMoniker;
                     bool excludedReferencesExist = false;
 
                     DependentAssembly[] autoUnifiedRemappedAssemblies = null;
@@ -2173,8 +1938,8 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             // Use any app.config specified binding redirects so that later when we output suggested redirects
                             // for the GenerateBindingRedirects target, we don't suggest ones that the user already wrote
                             appConfigRemappedAssemblies,
-                            _assemblyFiles,
-                            _assemblyNames,
+                            AssemblyFiles,
+                            Assemblies,
                             generalResolutionExceptions
                         );
 
@@ -2210,7 +1975,7 @@ out autoUnifiedRemappedAssemblyReferences
                     DependentAssembly[] allRemappedAssemblies = CombineRemappedAssemblies(appConfigRemappedAssemblies, autoUnifiedRemappedAssemblies);
 
                     // Compute all dependencies.
-                    dependencyTable.ComputeClosure(allRemappedAssemblies, _assemblyFiles, _assemblyNames, generalResolutionExceptions);
+                    dependencyTable.ComputeClosure(allRemappedAssemblies, AssemblyFiles, Assemblies, generalResolutionExceptions);
 
                     try
                     {
@@ -2325,9 +2090,9 @@ out _copyLocalFiles
                     WriteStateFile();
 
                     // Save the new state out and put into the file exists if it is actually on disk.
-                    if (_stateFile != null && fileExists(_stateFile))
+                    if (StateFile != null && fileExists(StateFile))
                     {
-                        _filesWritten.Add(new TaskItem(_stateFile));
+                        _filesWritten.Add(new TaskItem(StateFile));
                     }
 
                     // Log the results.
@@ -2341,7 +2106,7 @@ out _copyLocalFiles
                         {
                             AssemblyNameExtension assemblyName = null;
 
-                            if (fileExists(item.ItemSpec) && !Reference.IsFrameworkFile(item.ItemSpec, _targetFrameworkDirectories))
+                            if (fileExists(item.ItemSpec) && !Reference.IsFrameworkFile(item.ItemSpec, TargetFrameworkDirectories))
                             {
                                 try
                                 {
@@ -2686,7 +2451,7 @@ private bool ShouldUseSubsetBlackList()
                 {
                     if (String.Equals(fullSubsetName, subsetName, StringComparison.OrdinalIgnoreCase))
                     {
-                        if (!_silent)
+                        if (!Silent)
                         {
                             Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.NoExclusionListBecauseofFullClientName", subsetName);
                         }
@@ -2708,7 +2473,7 @@ private bool ShouldUseSubsetBlackList()
                 return false;
             }
 
-            if (!_silent)
+            if (!Silent)
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.UsingExclusionList");
             }
@@ -2857,7 +2622,7 @@ private void FilterBySubtypeAndTargetFramework()
             foreach (ITaskItem assembly in Assemblies)
             {
                 string subType = assembly.GetMetadata(ItemMetadataNames.subType);
-                if (subType != null && subType.Length > 0)
+                if (!string.IsNullOrEmpty(subType))
                 {
                     Log.LogMessageFromResources(MessageImportance.Normal, "ResolveAssemblyReference.IgnoringBecauseNonEmptySubtype", assembly.ItemSpec, subType);
                 }
@@ -2872,7 +2637,7 @@ private void FilterBySubtypeAndTargetFramework()
             }
 
             // Save the array of assemblies filtered by SubType==''.
-            _assemblyNames = (ITaskItem[])assembliesLeft.ToArray(typeof(ITaskItem));
+            Assemblies = (ITaskItem[])assembliesLeft.ToArray(typeof(ITaskItem));
         }
 
         /// <summary>
@@ -2949,7 +2714,7 @@ private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, SystemPr
         /// Execute the task.
         /// </summary>
         /// <returns>True if there was success.</returns>
-        override public bool Execute()
+        public override bool Execute()
         {
             return Execute
             (
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index e51fa94318d..b83923da790 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -23,19 +23,13 @@ public class Copy : TaskExtension, ICancelableTask
         /// </summary>
         public Copy()
         {
-            this.RetryDelayMilliseconds = RetryDelayMillisecondsDefault;
+            RetryDelayMilliseconds = RetryDelayMillisecondsDefault;
         }
 
         #region Properties
 
-        private ITaskItem[] _sourceFiles = null;
-        private ITaskItem _destinationFolder = null;
-        private ITaskItem[] _destinationFiles = null;
-        private bool _skipUnchangedFiles = false;
-        private ITaskItem[] _copiedFiles = null;
-        private bool _canceling = false;
-        private bool _overwriteReadOnlyFiles = false;
-        private HashSet<string> _directoriesKnownToExist = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+        private bool _canceling;
+        private readonly HashSet<string> _directoriesKnownToExist = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Force the copy to retry even when it hits ERROR_ACCESS_DENIED -- normally we wouldn't retry in this case since 
@@ -44,45 +38,15 @@ public Copy()
         /// </summary>
         private static bool s_alwaysRetryCopy = Environment.GetEnvironmentVariable("MSBUILDALWAYSRETRY") != null;
 
-        /// <summary>
-        /// Default to retrying "on". This is for robustness. We know that there are some files (eg interop assys) that are 
-        /// just prone to colliding in shared output directories -- we will still warn, so that they can improve things, and
-        /// spot the other case where there's an actual build process bug, but we don't want to break the build for the 
-        /// sake of purity.
-        /// </summary>
-        private int _retries = 10;
-
         /// <summary>
         /// Default milliseconds to wait between necessary retries
         /// </summary>
         private const int RetryDelayMillisecondsDefault = 1000;
 
         [Required]
-        public ITaskItem[] SourceFiles
-        {
-            get
-            {
-                return _sourceFiles;
-            }
-
-            set
-            {
-                _sourceFiles = value;
-            }
-        }
+        public ITaskItem[] SourceFiles { get; set; }
 
-        public ITaskItem DestinationFolder
-        {
-            get
-            {
-                return _destinationFolder;
-            }
-
-            set
-            {
-                _destinationFolder = value;
-            }
-        }
+        public ITaskItem DestinationFolder { get; set; }
 
         /// <summary>
         /// How many times to attempt to copy, if all previous
@@ -90,92 +54,38 @@ public ITaskItem DestinationFolder
         /// Warning: using retries may mask a synchronization problem in your
         /// build process.
         /// </summary>
-        public int Retries
-        {
-            get { return _retries; }
-            set { _retries = value; }
-        }
+        public int Retries { get; set; } = 10;
 
         /// <summary>
         /// Delay between any necessary retries.
         /// Defaults to <see cref="RetryDelayMillisecondsDefault">RetryDelayMillisecondsDefault</see>
         /// </summary>
-        public int RetryDelayMilliseconds
-        {
-            get;
-            set;
-        }
+        public int RetryDelayMilliseconds { get; set; }
 
         /// <summary>
         /// Create Hard Links for the copied files rather than copy the files if possible to do so
         /// </summary>
-        public bool UseHardlinksIfPossible
-        {
-            get;
-            set;
-        }
+        public bool UseHardlinksIfPossible { get; set; }
 
         /// <summary>
         /// Create Symbolic Links for the copied files rather than copy the files if possible to do so
         /// </summary>
-        public bool UseSymboliclinksIfPossible
-        {
-            get;
-            set;
-        }
-
-        public bool SkipUnchangedFiles
-        {
-            get
-            {
-                return _skipUnchangedFiles;
-            }
+        public bool UseSymboliclinksIfPossible { get; set; }
 
-            set
-            {
-                _skipUnchangedFiles = value;
-            }
-        }
+        public bool SkipUnchangedFiles { get; set; }
 
         [Output]
-        public ITaskItem[] DestinationFiles
-        {
-            get
-            {
-                return _destinationFiles;
-            }
-
-            set
-            {
-                _destinationFiles = value;
-            }
-        }
+        public ITaskItem[] DestinationFiles { get; set; }
 
         // Subset that were successfully copied
         [Output]
-        public ITaskItem[] CopiedFiles
-        {
-            get
-            {
-                return _copiedFiles;
-            }
-        }
+        public ITaskItem[] CopiedFiles { get; private set; }
 
         /// <summary>
         /// Whether to overwrite files in the destination
         /// that have the read-only attribute set.
         /// </summary>
-        public bool OverwriteReadOnlyFiles
-        {
-            get
-            {
-                return _overwriteReadOnlyFiles;
-            }
-            set
-            {
-                _overwriteReadOnlyFiles = value;
-            }
-        }
+        public bool OverwriteReadOnlyFiles { get; set; }
 
         #endregion
 
@@ -283,7 +193,7 @@ FileState destinationFileState  // The destination file
 
             string destinationFolder = Path.GetDirectoryName(destinationFileState.Name);
 
-            if (destinationFolder != null && destinationFolder.Length > 0 && !_directoriesKnownToExist.Contains(destinationFolder))
+            if (!string.IsNullOrEmpty(destinationFolder) && !_directoriesKnownToExist.Contains(destinationFolder))
             {
                 if (!Directory.Exists(destinationFolder))
                 {
@@ -297,7 +207,7 @@ FileState destinationFileState  // The destination file
                 _directoriesKnownToExist.Add(destinationFolder);
             }
 
-            if (_overwriteReadOnlyFiles)
+            if (OverwriteReadOnlyFiles)
             {
                 MakeFileWriteable(destinationFileState, true);
                 destinationFileExists = destinationFileState.FileExists;
@@ -308,9 +218,13 @@ FileState destinationFileState  // The destination file
 
             // If we want to create hard or symbolic links, then try that first
             if (UseHardlinksIfPossible)
-                TryCopyViaLink("Copy.HardLinkComment", MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, ref linkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeHardLink(destination, source, ref errorMessage));
+            {
+                TryCopyViaLink("Copy.HardLinkComment", MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out linkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeHardLink(destination, source, ref errorMessage));
+            }
             else if (UseSymboliclinksIfPossible)
-                TryCopyViaLink("Copy.SymbolicLinkComment", MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, ref linkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeSymbolicLink(destination, source, ref errorMessage));
+            {
+                TryCopyViaLink("Copy.SymbolicLinkComment", MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out linkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeSymbolicLink(destination, source, ref errorMessage));
+            }
 
             // If the link was not created (either because the user didn't want one, or because it couldn't be created)
             // then let's copy the file
@@ -334,12 +248,12 @@ FileState destinationFileState  // The destination file
             return true;
         }
 
-        private void TryCopyViaLink(string linkComment, MessageImportance messageImportance, FileState sourceFileState, FileState destinationFileState, ref bool destinationFileExists, ref bool linkCreated, ref string errorMessage, Func<string, string, string, bool> createLink)
+        private void TryCopyViaLink(string linkComment, MessageImportance messageImportance, FileState sourceFileState, FileState destinationFileState, ref bool destinationFileExists, out bool linkCreated, ref string errorMessage, Func<string, string, string, bool> createLink)
         {
             // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
             Log.LogMessageFromResources(MessageImportance.Normal, linkComment, sourceFileState.Name, destinationFileState.Name);
 
-            if (!_overwriteReadOnlyFiles)
+            if (!OverwriteReadOnlyFiles)
             {
                 destinationFileExists = destinationFileState.FileExists;
             }
@@ -397,10 +311,10 @@ CopyFileWithState copyFile
         )
         {
             // If there are no source files then just return success.
-            if (_sourceFiles == null || _sourceFiles.Length == 0)
+            if (SourceFiles == null || SourceFiles.Length == 0)
             {
-                _destinationFiles = Array.Empty<TaskItem>();
-                _copiedFiles = Array.Empty<TaskItem>();
+                DestinationFiles = Array.Empty<TaskItem>();
+                CopiedFiles = Array.Empty<TaskItem>();
                 return true;
             }
 
@@ -414,7 +328,7 @@ CopyFileWithState copyFile
             // Environment variable stomps on user-requested value if it's set. 
             if (Environment.GetEnvironmentVariable("MSBUILDALWAYSOVERWRITEREADONLYFILES") != null)
             {
-                _overwriteReadOnlyFiles = true;
+                OverwriteReadOnlyFiles = true;
             }
 
             // Build up the sucessfully copied subset
@@ -428,13 +342,12 @@ CopyFileWithState copyFile
             Dictionary<string, string> filesActuallyCopied = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
             // Now that we have a list of destinationFolder files, copy from source to destinationFolder.
-            for (int i = 0; i < _sourceFiles.Length && !_canceling; ++i)
+            for (int i = 0; i < SourceFiles.Length && !_canceling; ++i)
             {
                 bool copyComplete = false;
-                string originalSource;
-                if (filesActuallyCopied.TryGetValue(_destinationFiles[i].ItemSpec, out originalSource))
+                if (filesActuallyCopied.TryGetValue(DestinationFiles[i].ItemSpec, out string originalSource))
                 {
-                    if (String.Equals(originalSource, _sourceFiles[i].ItemSpec, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(originalSource, SourceFiles[i].ItemSpec, StringComparison.OrdinalIgnoreCase))
                     {
                         // Already copied from this location, don't copy again.
                         copyComplete = true;
@@ -443,9 +356,9 @@ CopyFileWithState copyFile
 
                 if (!copyComplete)
                 {
-                    if (DoCopyIfNecessary(new FileState(_sourceFiles[i].ItemSpec), new FileState(_destinationFiles[i].ItemSpec), copyFile))
+                    if (DoCopyIfNecessary(new FileState(SourceFiles[i].ItemSpec), new FileState(DestinationFiles[i].ItemSpec), copyFile))
                     {
-                        filesActuallyCopied[_destinationFiles[i].ItemSpec] = _sourceFiles[i].ItemSpec;
+                        filesActuallyCopied[DestinationFiles[i].ItemSpec] = SourceFiles[i].ItemSpec;
                         copyComplete = true;
                     }
                     else
@@ -456,13 +369,13 @@ CopyFileWithState copyFile
 
                 if (copyComplete)
                 {
-                    _sourceFiles[i].CopyMetadataTo(_destinationFiles[i]);
-                    destinationFilesSuccessfullyCopied.Add(_destinationFiles[i]);
+                    SourceFiles[i].CopyMetadataTo(DestinationFiles[i]);
+                    destinationFilesSuccessfullyCopied.Add(DestinationFiles[i]);
                 }
             }
 
             // copiedFiles contains only the copies that were successful.
-            _copiedFiles = (ITaskItem[])destinationFilesSuccessfullyCopied.ToArray();
+            CopiedFiles = destinationFilesSuccessfullyCopied.ToArray();
 
             return success && !_canceling;
         }
@@ -470,7 +383,6 @@ CopyFileWithState copyFile
         /// <summary>
         /// Verify that the inputs are correct.
         /// </summary>
-        /// <returns></returns>
         private bool ValidateInputs()
         {
             if (Retries < 0)
@@ -486,23 +398,23 @@ private bool ValidateInputs()
             }
 
             // There must be a destinationFolder (either files or directory).
-            if (_destinationFiles == null && _destinationFolder == null)
+            if (DestinationFiles == null && DestinationFolder == null)
             {
                 Log.LogErrorWithCodeFromResources("Copy.NeedsDestination", "DestinationFiles", "DestinationFolder");
                 return false;
             }
 
             // There can't be two kinds of destination.
-            if (_destinationFiles != null && _destinationFolder != null)
+            if (DestinationFiles != null && DestinationFolder != null)
             {
                 Log.LogErrorWithCodeFromResources("Copy.ExactlyOneTypeOfDestination", "DestinationFiles", "DestinationFolder");
                 return false;
             }
 
             // If the caller passed in DestinationFiles, then its length must match SourceFiles.
-            if (_destinationFiles != null && _destinationFiles.Length != _sourceFiles.Length)
+            if (DestinationFiles != null && DestinationFiles.Length != SourceFiles.Length)
             {
-                Log.LogErrorWithCodeFromResources("General.TwoVectorsMustHaveSameLength", _destinationFiles.Length, _sourceFiles.Length, "DestinationFiles", "SourceFiles");
+                Log.LogErrorWithCodeFromResources("General.TwoVectorsMustHaveSameLength", DestinationFiles.Length, SourceFiles.Length, "DestinationFiles", "SourceFiles");
                 return false;
             }
 
@@ -522,34 +434,34 @@ private bool ValidateInputs()
         /// <returns></returns>
         private bool InitializeDestinationFiles()
         {
-            if (_destinationFiles == null)
+            if (DestinationFiles == null)
             {
                 // If the caller passed in DestinationFolder, convert it to DestinationFiles
-                _destinationFiles = new ITaskItem[_sourceFiles.Length];
+                DestinationFiles = new ITaskItem[SourceFiles.Length];
 
-                for (int i = 0; i < _sourceFiles.Length; ++i)
+                for (int i = 0; i < SourceFiles.Length; ++i)
                 {
                     // Build the correct path.
                     string destinationFile;
                     try
                     {
-                        destinationFile = Path.Combine(_destinationFolder.ItemSpec, Path.GetFileName(_sourceFiles[i].ItemSpec));
+                        destinationFile = Path.Combine(DestinationFolder.ItemSpec, Path.GetFileName(SourceFiles[i].ItemSpec));
                     }
                     catch (ArgumentException e)
                     {
-                        Log.LogErrorWithCodeFromResources("Copy.Error", _sourceFiles[i].ItemSpec, _destinationFolder.ItemSpec, e.Message);
+                        Log.LogErrorWithCodeFromResources("Copy.Error", SourceFiles[i].ItemSpec, DestinationFolder.ItemSpec, e.Message);
                         // Clear the outputs.
-                        _destinationFiles = Array.Empty<ITaskItem>();
+                        DestinationFiles = Array.Empty<ITaskItem>();
                         return false;
                     }
 
                     // Initialize the destinationFolder item.
                     // ItemSpec is unescaped, and the TaskItem constructor expects an escaped input, so we need to 
                     // make sure to re-escape it here. 
-                    _destinationFiles[i] = new TaskItem(EscapingUtilities.Escape(destinationFile));
+                    DestinationFiles[i] = new TaskItem(EscapingUtilities.Escape(destinationFile));
 
                     // Copy meta-data from source to destinationFolder.
-                    _sourceFiles[i].CopyMetadataTo(_destinationFiles[i]);
+                    SourceFiles[i].CopyMetadataTo(DestinationFiles[i]);
                 }
             }
 
@@ -569,7 +481,7 @@ private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationF
 
             try
             {
-                if (_skipUnchangedFiles && IsMatchingSizeAndTimeStamp(sourceFileState, destinationFileState))
+                if (SkipUnchangedFiles && IsMatchingSizeAndTimeStamp(sourceFileState, destinationFileState))
                 {
                     // If we got here, then the file's time and size match AND
                     // the user set the SkipUnchangedFiles flag which means we
@@ -611,14 +523,13 @@ private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationF
         /// </summary>
         private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationFileState, CopyFileWithState copyFile)
         {
-            bool? result = null;
             int retries = 0;
 
-            while (true && !_canceling)
+            while (!_canceling)
             {
                 try
                 {
-                    result = copyFile(sourceFileState, destinationFileState);
+                    bool? result = copyFile(sourceFileState, destinationFileState);
                     if (result.HasValue)
                     {
                         return result.Value;
@@ -639,7 +550,7 @@ e is NotSupportedException || // Colon in the middle of the path
                         int code = Marshal.GetHRForException(e);
 
                         LogDiagnostic("Got {0} copying {1} to {2} and HR is {3}", e.ToString(), sourceFileState.Name, destinationFileState.Name, code);
-                        if (code == Microsoft.Build.Tasks.NativeMethods.ERROR_ACCESS_DENIED)
+                        if (code == NativeMethods.ERROR_ACCESS_DENIED)
                         {
                             // ERROR_ACCESS_DENIED can either mean there's an ACL preventing us, or the file has the readonly bit set.
                             // In either case, that's likely not a race, and retrying won't help.
@@ -734,7 +645,7 @@ e is NotSupportedException || // Colon in the middle of the path
         /// <summary>
         /// Try to get a message to inform the user which processes have a lock on a given file.
         /// </summary>
-        private string GetLockedFileMessage(string file)
+        private static string GetLockedFileMessage(string file)
         {
             string message = string.Empty;
 #if !RUNTIME_TYPE_NETCORE && !MONO
@@ -760,17 +671,14 @@ private string GetLockedFileMessage(string file)
         /// <returns></returns>
         public override bool Execute()
         {
-            return Execute
-            (
-                new CopyFileWithState(CopyFileWithLogging)
-            );
+            return Execute(CopyFileWithLogging);
         }
 
         /// <summary>
         /// Compares two paths to see if they refer to the same file. We can't solve the general
         /// canonicalization problem, so we just compare strings on the full paths.
         /// </summary>
-        private bool PathsAreIdentical(string source, string destination)
+        private static bool PathsAreIdentical(string source, string destination)
         {
             string fullSourcePath = Path.GetFullPath(source);
             string fullDestinationPath = Path.GetFullPath(destination);
