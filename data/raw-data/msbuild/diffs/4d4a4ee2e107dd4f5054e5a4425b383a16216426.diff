diff --git a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
index 7a33e0d5343..c4f23a15244 100644
--- a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
+++ b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
@@ -2,9 +2,12 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.IO;
 using System.Reflection;
+using System.Text;
 using System.Xml;
+using System.Xml.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Exceptions;
@@ -13,76 +16,101 @@
 using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
 
-#nullable disable
+#pragma warning disable CA3075 // Insecure DTD processing in XML
+#pragma warning disable IDE0022 // Use expression body for method
+#pragma warning disable IDE0058 // Expression value is never used
+#pragma warning disable SA1010 // Opening square brackets should be spaced correctly
 
 namespace Microsoft.Build.UnitTests.Construction
 {
     /// <summary>
-    /// Tests for the ElementLocation class
+    /// Unit tests for <see cref="ElementLocation"/>.
     /// </summary>
     public class ElementLocation_Tests
     {
-        /// <summary>
-        /// Path to the common targets
-        /// </summary>
-        private string _pathToCommonTargets =
-#if FEATURE_INSTALLED_MSBUILD
-            Path.Combine(FrameworkLocationHelper.PathToDotNetFrameworkV45, "Microsoft.Common.targets");
-#else
-            Path.Combine(AppContext.BaseDirectory, "Microsoft.Common.targets");
-#endif
+        [Theory]
+        [MemberData(nameof(GetCreateTestCases))]
+        public void Create(string? file, int line, int column, string typeName)
+        {
+            ElementLocation location = ElementLocation.Create(file, line, column);
 
-        /// <summary>
-        /// Tests constructor specifying only file.
-        /// </summary>
-        [Fact]
-        public void ConstructorTest1()
+            Assert.Equal(file ?? "", location.File);
+            Assert.Equal(line, location.Line);
+            Assert.Equal(column, location.Column);
+
+            Assert.Contains(typeName, location.GetType().FullName);
+        }
+
+        [Theory]
+        [InlineData("file", -1, 0)]
+        [InlineData("file", 0, -1)]
+        [InlineData("file", int.MaxValue, -1)]
+        [InlineData("file", -1, int.MaxValue)]
+        [InlineData("file", -1, -1)]
+        [InlineData("file", int.MinValue, 0)]
+        [InlineData("file", 0, int.MinValue)]
+        [InlineData("file", int.MinValue, int.MinValue)]
+        public void Create_NegativeValuesThrow(string file, int line, int column)
         {
-            IElementLocation location = ElementLocation.Create("file", 65536, 0);
-            Assert.Equal("file", location.File);
-            Assert.Equal(65536, location.Line);
-            Assert.Equal(0, location.Column);
-            Assert.Contains("RegularElementLocation", location.GetType().FullName);
+            _ = Assert.Throws<InternalErrorException>(
+                () => ElementLocation.Create(file, line, column));
         }
 
-        /// <summary>
-        /// Tests constructor specifying only file.
-        /// </summary>
         [Fact]
-        public void ConstructorTest2()
+        public void Create_NullFile()
         {
-            IElementLocation location = ElementLocation.Create("file", 0, 65536);
-            Assert.Equal("file", location.File);
+            ElementLocation location = ElementLocation.Create(null);
+
+            Assert.Equal("", location.File);
             Assert.Equal(0, location.Line);
-            Assert.Equal(65536, location.Column);
-            Assert.Contains("RegularElementLocation", location.GetType().FullName);
+            Assert.Equal(0, location.Column);
         }
 
-        /// <summary>
-        /// Tests constructor specifying only file.
-        /// </summary>
-        [Fact]
-        public void ConstructorTest3()
+        [Theory]
+        [MemberData(nameof(GetCreateTestCases))]
+        public void RoundTripSerialisation(string? file, int line, int column, string typeName)
         {
-            IElementLocation location = ElementLocation.Create("file", 65536, 65537);
-            Assert.Equal("file", location.File);
-            Assert.Equal(65536, location.Line);
-            Assert.Equal(65537, location.Column);
-            Assert.Contains("RegularElementLocation", location.GetType().FullName);
+            ElementLocation location = ElementLocation.Create(file, line, column);
+
+            TranslationHelpers.GetWriteTranslator().Translate(ref location, ElementLocation.FactoryForDeserialization);
+            ElementLocation? deserializedLocation = null;
+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedLocation, ElementLocation.FactoryForDeserialization);
+            Assert.NotNull(deserializedLocation);
+
+            Assert.Equal(file ?? "", deserializedLocation.File);
+            Assert.Equal(line, deserializedLocation.Line);
+            Assert.Equal(column, deserializedLocation.Column);
+
+            Assert.Contains(typeName, deserializedLocation.GetType().FullName);
+        }
+
+        public static IEnumerable<object?[]> GetCreateTestCases()
+        {
+            yield return [null, 0, 0, "EmptyElementLocation"];
+            yield return ["", 0, 0, "EmptyElementLocation"];
+            yield return ["file", byte.MaxValue, 0, "SmallFileElementLocation"];
+            yield return ["file", byte.MaxValue + 1, 0, "SmallLineElementLocation"];
+            yield return ["file", 0, byte.MaxValue, "SmallFileElementLocation"];
+            yield return ["file", 0, byte.MaxValue + 1, "SmallColumnElementLocation"];
+            yield return ["file", ushort.MaxValue, 0, "SmallLineElementLocation"];
+            yield return ["file", ushort.MaxValue + 1, 0, "LargeLineElementLocation"];
+            yield return ["file", 0, ushort.MaxValue, "SmallColumnElementLocation"];
+            yield return ["file", 0, ushort.MaxValue + 1, "LargeColumnElementLocation"];
+            yield return ["file", ushort.MaxValue, ushort.MaxValue, "LargeFileElementLocation"];
+            yield return ["file", ushort.MaxValue + 1, ushort.MaxValue, "FullElementLocation"];
+            yield return ["file", ushort.MaxValue, ushort.MaxValue + 1, "FullElementLocation"];
+            yield return ["file", ushort.MaxValue + 1, ushort.MaxValue + 1, "FullElementLocation"];
         }
 
-        /// <summary>
-        /// Test equality
-        /// </summary>
         [Fact]
         public void Equality()
         {
-            IElementLocation location1 = ElementLocation.Create("file", 65536, 65537);
-            IElementLocation location2 = ElementLocation.Create("file", 0, 1);
-            IElementLocation location3 = ElementLocation.Create("file", 0, 65537);
-            IElementLocation location4 = ElementLocation.Create("file", 65536, 1);
-            IElementLocation location5 = ElementLocation.Create("file", 0, 1);
-            IElementLocation location6 = ElementLocation.Create("file", 65536, 65537);
+            ElementLocation location1 = ElementLocation.Create("file", line: 65536, column: 65537);
+            ElementLocation location2 = ElementLocation.Create("file", line: 0, column: 1);
+            ElementLocation location3 = ElementLocation.Create("file", line: 0, column: 65537);
+            ElementLocation location4 = ElementLocation.Create("file", line: 65536, column: 1);
+            ElementLocation location5 = ElementLocation.Create("file", line: 0, column: 1);
+            ElementLocation location6 = ElementLocation.Create("file", line: 65536, column: 65537);
 
             Assert.True(location1.Equals(location6));
             Assert.True(location2.Equals(location5));
@@ -93,362 +121,204 @@ public void Equality()
 
         /// <summary>
         /// Check it will use large element location when it should.
-        /// Using file as BIZARRELY XmlTextReader+StringReader crops or trims.
         /// </summary>
         [Fact]
         public void TestLargeElementLocationUsedLargeColumn()
         {
-            string file = null;
+            StringBuilder xml = new(capacity: 71_000);
+
+            xml.AppendLine(ObjectModelHelpers.CleanupFileContents(
+                """
+                <Project xmlns="msbuildnamespace" ToolsVersion="msbuilddefaulttoolsversion">
+                  <ItemGroup>
+                """));
+            xml.Append(' ', 70_000);
+            xml.Append("""
+                <x/>
+                  </ItemGroup>
+                </Project>
+                """);
 
-            try
-            {
-                file = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
+            Assert.Equal(71_000, xml.Capacity);
 
-                File.WriteAllText(file, ObjectModelHelpers.CleanupFileContents("<Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>\r\n<ItemGroup>") + new string(' ', 70000) + @"<x/></ItemGroup></Project>");
+            XmlDocumentWithLocation doc = new();
+            doc.LoadXml(xml.ToString());
 
-                ProjectRootElement.Open(file);
-            }
-            catch (InvalidProjectFileException ex)
-            {
-                Assert.Equal(70012, ex.ColumnNumber);
-                Assert.Equal(2, ex.LineNumber);
-            }
-            finally
-            {
-                File.Delete(file);
-            }
+            InvalidProjectFileException ex = Assert.Throws<InvalidProjectFileException>(
+                () => ProjectRootElement.Open(doc));
+
+            Assert.Equal(70_001, ex.ColumnNumber);
+            Assert.Equal(3, ex.LineNumber);
         }
 
         /// <summary>
         /// Check it will use large element location when it should.
-        /// Using file as BIZARRELY XmlTextReader+StringReader crops or trims.
         /// </summary>
         [Fact]
         public void TestLargeElementLocationUsedLargeLine()
         {
-            string file = null;
-
-            try
-            {
-                string longstring = String.Empty;
-
-                for (int i = 0; i < 7000; i++)
-                {
-                    longstring += "\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n";
-                }
-
-                file = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
-
-                File.WriteAllText(file, ObjectModelHelpers.CleanupFileContents("<Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>\r\n<ItemGroup>") + longstring + @" <x/></ItemGroup></Project>");
-
-                ProjectRootElement.Open(file);
-            }
-            catch (InvalidProjectFileException ex)
-            {
-                Assert.Equal(70002, ex.LineNumber);
-                Assert.Equal(2, ex.ColumnNumber);
-            }
-            finally
-            {
-                File.Delete(file);
-            }
-        }
-
-        /// <summary>
-        /// Tests serialization.
-        /// </summary>
-        [Fact]
-        public void SerializationTest()
-        {
-            IElementLocation location = ElementLocation.Create("file", 65536, 65537);
+            StringBuilder xml = new(capacity: 71_000);
 
-            TranslationHelpers.GetWriteTranslator().Translate(ref location, ElementLocation.FactoryForDeserialization);
-            IElementLocation deserializedLocation = null;
-            TranslationHelpers.GetReadTranslator().Translate(ref deserializedLocation, ElementLocation.FactoryForDeserialization);
-
-            Assert.Equal(location.File, deserializedLocation.File);
-            Assert.Equal(location.Line, deserializedLocation.Line);
-            Assert.Equal(location.Column, deserializedLocation.Column);
-            Assert.Contains("RegularElementLocation", location.GetType().FullName);
-        }
-
-        /// <summary>
-        /// Tests serialization of empty location.
-        /// </summary>
-        [Fact]
-        public void SerializationTestForEmptyLocation()
-        {
-            IElementLocation location = ElementLocation.EmptyLocation;
-
-            TranslationHelpers.GetWriteTranslator().Translate(ref location, ElementLocation.FactoryForDeserialization);
-            IElementLocation deserializedLocation = null;
-            TranslationHelpers.GetReadTranslator().Translate(ref deserializedLocation, ElementLocation.FactoryForDeserialization);
-
-            Assert.Equal(location.File, deserializedLocation.File);
-            Assert.Equal(location.Line, deserializedLocation.Line);
-            Assert.Equal(location.Column, deserializedLocation.Column);
-            Assert.Contains("SmallElementLocation", deserializedLocation.GetType().FullName);
-        }
-
-        /// <summary>
-        /// Tests constructor specifying file, line and column.
-        /// </summary>
-        [Fact]
-        public void ConstructorWithIndicesTest_SmallElementLocation()
-        {
-            IElementLocation location = ElementLocation.Create("file", 65535, 65534);
-            Assert.Equal("file", location.File);
-            Assert.Equal(65535, location.Line);
-            Assert.Equal(65534, location.Column);
-            Assert.Contains("SmallElementLocation", location.GetType().FullName);
-        }
-
-        /// <summary>
-        /// Tests constructor specifying file, negative line, column
-        /// </summary>
-        [Fact]
-        public void ConstructorWithNegativeIndicesTest1()
-        {
-            Assert.Throws<InternalErrorException>(() =>
-            {
-                ElementLocation.Create("file", -1, 2);
-            });
-        }
-        /// <summary>
-        /// Tests constructor specifying file, line, negative column
-        /// </summary>
-        [Fact]
-        public void ConstructorWithNegativeIndicesTest2n()
-        {
-            Assert.Throws<InternalErrorException>(() =>
-            {
-                ElementLocation.Create("file", 1, -2);
-            });
-        }
-        /// <summary>
-        /// Tests constructor with invalid null file.
-        /// </summary>
-        [Fact]
-        public void ConstructorTestNullFile()
-        {
-            IElementLocation location = ElementLocation.Create(null);
-            Assert.Equal(location.File, String.Empty);
-        }
+            xml.Append(ObjectModelHelpers.CleanupFileContents(
+                """
+                <Project xmlns="msbuildnamespace" ToolsVersion="msbuilddefaulttoolsversion">
+                  <ItemGroup>
+                """));
 
-        /// <summary>
-        /// Tests constructor specifying only file.
-        /// </summary>
-        [Fact]
-        public void ConstructorTest1_SmallElementLocation()
-        {
-            IElementLocation location = ElementLocation.Create("file", 65535, 0);
-            Assert.Equal("file", location.File);
-            Assert.Equal(65535, location.Line);
-            Assert.Equal(0, location.Column);
-            Assert.Contains("SmallElementLocation", location.GetType().FullName);
-        }
+            xml.Append('\n', 70_000);
 
-        /// <summary>
-        /// Tests constructor specifying only file.
-        /// </summary>
-        [Fact]
-        public void ConstructorTest2_SmallElementLocation()
-        {
-            IElementLocation location = ElementLocation.Create("file", 0, 65535);
-            Assert.Equal("file", location.File);
-            Assert.Equal(0, location.Line);
-            Assert.Equal(65535, location.Column);
-            Assert.Contains("SmallElementLocation", location.GetType().FullName);
-        }
+            xml.Append(
+                """
+                    <x/>
+                  </ItemGroup>
+                </Project>
+                """);
 
-        /// <summary>
-        /// Tests constructor specifying only file.
-        /// </summary>
-        [Fact]
-        public void ConstructorTest3_SmallElementLocation()
-        {
-            IElementLocation location = ElementLocation.Create("file", 65535, 65534);
-            Assert.Equal("file", location.File);
-            Assert.Equal(65535, location.Line);
-            Assert.Equal(65534, location.Column);
-            Assert.Contains("SmallElementLocation", location.GetType().FullName);
-        }
+            Assert.Equal(71_000, xml.Capacity);
 
-        /// <summary>
-        /// Tests serialization.
-        /// </summary>
-        [Fact]
-        public void SerializationTest_SmallElementLocation()
-        {
-            IElementLocation location = ElementLocation.Create("file", 65535, 2);
+            XmlDocumentWithLocation doc = new();
+            doc.LoadXml(xml.ToString());
 
-            TranslationHelpers.GetWriteTranslator().Translate(ref location, ElementLocation.FactoryForDeserialization);
-            IElementLocation deserializedLocation = null;
-            TranslationHelpers.GetReadTranslator().Translate(ref deserializedLocation, ElementLocation.FactoryForDeserialization);
+            InvalidProjectFileException ex = Assert.Throws<InvalidProjectFileException>(
+                () => ProjectRootElement.Open(doc));
 
-            Assert.Equal(location.File, deserializedLocation.File);
-            Assert.Equal(location.Line, deserializedLocation.Line);
-            Assert.Equal(location.Column, deserializedLocation.Column);
-            Assert.Contains("SmallElementLocation", location.GetType().FullName);
+            Assert.Equal(70_002, ex.LineNumber);
+            Assert.Equal(5, ex.ColumnNumber);
         }
 
-        /// <summary>
-        /// Test many of the getters
-        /// </summary>
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void LocationStringsMedleyReadOnlyLoad()
+        public void LocationsMatchWhenReadOnlyOrWriteable()
         {
-            string content = ObjectModelHelpers.CleanupFileContents(@"
-            <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
-                    <UsingTask TaskName='t' AssemblyName='a' Condition='true'/>
-                    <UsingTask TaskName='t' AssemblyFile='a' Condition='true'/>
-                    <ItemDefinitionGroup Condition='true' Label='l'>
-                        <m Condition='true'>  foo  bar
-  </m>
+            string content = ObjectModelHelpers.CleanupFileContents(
+                """
+                <Project ToolsVersion="msbuilddefaulttoolsversion" xmlns="msbuildnamespace">
+                        <UsingTask TaskName="t" AssemblyName="a" Condition="true"/>
+                        <UsingTask TaskName="t" AssemblyFile="a" Condition="true"/>
+                        <ItemDefinitionGroup Condition="true" Label="l">
+                            <m Condition="true">  foo  bar
+                </m>
                     </ItemDefinitionGroup>
                     <ItemGroup>
-                        <i Include='i' Condition='true' Exclude='r'>
-                            <m Condition='true'/>
+                        <i Include="i" Condition="true" Exclude="r">
+                            <m Condition="true"/>
                         </i>
                     </ItemGroup>
                     <PropertyGroup>
-                        <p Condition='true'/>
+                        <p Condition="true"/>
                     </PropertyGroup>
-                   <!-- A comment -->
-                    <Target Name='Build' Condition='true' Inputs='i' Outputs='o'>
+                    <!-- A comment -->
+                    <Target Name="Build" Condition="true" Inputs="i" Outputs="o">
                         <ItemGroup>
-                            <i Include='i' Condition='true' Exclude='r'>
-                                <m Condition='true'/>
+                            <i Include="i" Condition="true" Exclude="r">
+                                <m Condition="true"/>
                             </i>
-                            <i Remove='r'/>
+                            <i Remove="r"/>
                         </ItemGroup>
-                        <PropertyGroup xml:space= 'preserve'>             <x/>
-                            <p     Condition='true'/>
+                        <PropertyGroup xml:space= "preserve">             <x/>
+                            <p     Condition="true"/>
                         </PropertyGroup>
-                        <Error Text='xyz' ContinueOnError='true' Importance='high'/>
+                        <Error Text="xyz" ContinueOnError="true" Importance="high"/>
                     </Target>
-                    <Import Project='p' Condition='false'/>
+                    <Import Project="p" Condition="false"/>
                 </Project>
-                ");
+                """);
 
             string readWriteLoadLocations = GetLocations(content, readOnly: false);
             string readOnlyLoadLocations = GetLocations(content, readOnly: true);
 
-            Console.WriteLine(readWriteLoadLocations);
-
             Helpers.VerifyAssertLineByLine(readWriteLoadLocations, readOnlyLoadLocations);
+
+            static string GetLocations(string content, bool readOnly)
+            {
+                string file = FileUtilities.GetTemporaryFileName();
+
+                XmlDocumentWithLocation doc = new(loadAsReadOnly: readOnly, fullPath: file);
+                doc.LoadXml(content);
+
+                Assert.Equal(readOnly, doc.IsReadOnly);
+
+                XmlNodeList? allNodes = doc.SelectNodes("//*|//@*");
+
+                Assert.NotNull(allNodes);
+
+                StringBuilder locations = new();
+
+                foreach (object node in allNodes)
+                {
+                    PropertyInfo? property = node.GetType().GetProperty("Location", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
+
+                    var value = (ElementLocation?)property?.GetValue(node, null);
+
+                    if (value is not null) // null means attribute is not present
+                    {
+                        locations.Append(((XmlNode)node).Name).Append("==").Append(((XmlNode)node).Value ?? "").Append(":  ").Append(value.LocationString.Replace(file, """c:\foo\bar.csproj""")).Append("\r\n");
+                    }
+                }
+
+                return locations.ToString();
+            }
         }
 
-        /// <summary>
-        /// Save read only fails
-        /// </summary>
         [Fact]
-        public void SaveReadOnly1()
+        public void SaveReadOnly_FilePath_Throws()
         {
-            Assert.Throws<InvalidOperationException>(() =>
+            XmlDocumentWithLocation doc = new(loadAsReadOnly: true);
+
+            Assert.True(doc.IsReadOnly);
+
+            _ = Assert.Throws<InvalidOperationException>(() =>
             {
-                var doc = new XmlDocumentWithLocation(loadAsReadOnly: true);
-                doc.Load(_pathToCommonTargets);
-                Assert.True(doc.IsReadOnly);
                 doc.Save(FileUtilities.GetTemporaryFile());
             });
         }
 
-        /// <summary>
-        /// Save read only fails
-        /// </summary>
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void SaveReadOnly2()
+        public void SaveReadOnly_Stream_Throws()
         {
-            var doc = new XmlDocumentWithLocation(loadAsReadOnly: true);
-            doc.Load(_pathToCommonTargets);
+            XmlDocumentWithLocation doc = new(loadAsReadOnly: true);
+
             Assert.True(doc.IsReadOnly);
-            Assert.Throws<InvalidOperationException>(() =>
+
+            _ = Assert.Throws<InvalidOperationException>(() =>
             {
                 doc.Save(new MemoryStream());
             });
         }
 
-        /// <summary>
-        /// Save read only fails
-        /// </summary>
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void SaveReadOnly3()
+        public void SaveReadOnly_TextWriter_Throws()
         {
-            var doc = new XmlDocumentWithLocation(loadAsReadOnly: true);
-            doc.Load(_pathToCommonTargets);
+            XmlDocumentWithLocation doc = new(loadAsReadOnly: true);
+
             Assert.True(doc.IsReadOnly);
-            Assert.Throws<InvalidOperationException>(() =>
+
+            _ = Assert.Throws<InvalidOperationException>(() =>
             {
                 doc.Save(new StringWriter());
             });
         }
 
-        /// <summary>
-        /// Save read only fails
-        /// </summary>
         [Fact]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void SaveReadOnly4()
-        {
-            var doc = new XmlDocumentWithLocation(loadAsReadOnly: true);
-            doc.Load(_pathToCommonTargets);
-            Assert.True(doc.IsReadOnly);
-            using (XmlWriter wr = XmlWriter.Create(new FileStream(FileUtilities.GetTemporaryFileName(), FileMode.Create)))
-            {
-                Assert.Throws<InvalidOperationException>(() =>
-                {
-                    doc.Save(wr);
-                });
-            }
-        }
-
-        /// <summary>
-        /// Get location strings for the content, loading as readonly if specified
-        /// </summary>
-        private string GetLocations(string content, bool readOnly)
+        public void SaveReadOnly_XmlWriter_Throws()
         {
-            string file = null;
+            XmlDocumentWithLocation doc = new(loadAsReadOnly: true);
 
-            try
-            {
-                file = FileUtilities.GetTemporaryFileName();
-                File.WriteAllText(file, content);
-                var doc = new XmlDocumentWithLocation(loadAsReadOnly: readOnly);
-                doc.Load(file);
-                Assert.Equal(readOnly, doc.IsReadOnly);
-                var allNodes = doc.SelectNodes("//*|//@*");
+            Assert.True(doc.IsReadOnly);
 
-                string locations = String.Empty;
-                foreach (var node in allNodes)
-                {
-                    foreach (var property in node.GetType().GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
-                    {
-                        if (property.Name.Equals("Location"))
-                        {
-                            var value = ((ElementLocation)property.GetValue(node, null));
-
-                            if (value != null) // null means attribute is not present
-                            {
-                                locations += ((XmlNode)node).Name + "==" + ((XmlNode)node).Value ?? String.Empty + ":  " + value.LocationString + "\r\n";
-                            }
-                        }
-                    }
-                }
+            using XmlWriter wr = XmlWriter.Create(new MemoryStream());
 
-                return locations.Replace(file, "c:\\foo\\bar.csproj");
-            }
-            finally
+            _ = Assert.Throws<InvalidOperationException>(() =>
             {
-                File.Delete(file);
-            }
+                doc.Save(wr);
+            });
         }
     }
 }
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 2ce47830fd6..48fe3497c6c 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -2,7 +2,10 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
 using System.Diagnostics;
+using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
@@ -16,6 +19,8 @@ namespace Microsoft.Build.Construction
     /// <remarks>
     /// This object is IMMUTABLE, so that it can be passed around arbitrarily.
     /// DO NOT make these objects any larger. There are huge numbers of them and they are transmitted between nodes.
+    /// 
+    /// Although this class is called "element" location, it is also used for other XML node types, such as in <see cref="XmlAttributeWithLocation"/>.
     /// </remarks>
     [Serializable]
     public abstract class ElementLocation : IElementLocation, ITranslatable, IImmutable
@@ -26,7 +31,7 @@ public abstract class ElementLocation : IElementLocation, ITranslatable, IImmuta
         /// It is to be used for the project location when the project has not been given a name.
         /// In that case, it exists, but can't have a specific location.
         /// </summary>
-        public static ElementLocation EmptyLocation { get; } = new SmallElementLocation("", 0, 0);
+        public static ElementLocation EmptyLocation { get; } = new EmptyElementLocation();
 
         /// <summary>
         /// Gets the file from which this particular element originated.  It may
@@ -35,10 +40,7 @@ public abstract class ElementLocation : IElementLocation, ITranslatable, IImmuta
         /// If not known, returns empty string.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        public abstract string File
-        {
-            get;
-        }
+        public abstract string File { get; }
 
         /// <summary>
         /// Gets the line number where this element exists in its file.
@@ -46,10 +48,7 @@ public abstract string File
         /// Zero indicates "unknown location".
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        public abstract int Line
-        {
-            get;
-        }
+        public abstract int Line { get; }
 
         /// <summary>
         /// Gets the column number where this element exists in its file.
@@ -57,10 +56,7 @@ public abstract int Line
         /// Zero indicates "unknown location".
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        public abstract int Column
-        {
-            get;
-        }
+        public abstract int Column { get; }
 
         /// <summary>
         /// Gets the location in a form suitable for replacement
@@ -155,11 +151,15 @@ internal static ElementLocation FactoryForDeserialization(ITranslator translator
         /// This is the case when we are creating a new item, for example, and it has
         /// not been evaluated from some XML.
         /// </summary>
-        internal static ElementLocation Create(string file)
+        internal static ElementLocation Create(string? file)
         {
             return Create(file, 0, 0);
         }
 
+        private static string[] s_fileByIndex = new string[32];
+        private static int s_nextFileIndex;
+        private static ImmutableDictionary<string, int> s_indexByFile = ImmutableDictionary<string, int>.Empty.WithComparers(StringComparer.OrdinalIgnoreCase);
+
         /// <summary>
         /// Constructor for the case where we have most or all information.
         /// Numerical values must be 1-based, non-negative; 0 indicates unknown
@@ -169,74 +169,280 @@ internal static ElementLocation Create(string file)
         /// In AG there are 600 locations that have a file but zero line and column.
         /// In theory yet another derived class could be made for these to save 4 bytes each.
         /// </remarks>
-        internal static ElementLocation Create(string? file, int line, int column)
+        internal static ElementLocation Create(string? filePath, int line, int column)
         {
             // Combine line and column values with bitwise OR so we can perform various
             // checks on both values in a single comparison, reducing the amount of branching
             // in the code.
             int combinedValue = line | column;
 
-            if (string.IsNullOrEmpty(file) && combinedValue == 0)
+            if (string.IsNullOrEmpty(filePath) && combinedValue == 0)
             {
                 // When combinedValue is zero, it implies that both line and column are zero.
-                return EmptyLocation;
+                return EmptyElementLocation.Instance;
             }
 
-            // When combinedValue is negative, it implies that either line or column were negative
+            // When combinedValue is negative, it implies that either line or column were negative.
             ErrorUtilities.VerifyThrow(combinedValue > -1, "Use zero for unknown");
 
-            file ??= "";
+            // TODO store the last run's value and check if this is for the same file. If so, skip the dictionary lookup (tree walk).
+            int fileIndex = GetOrAddFileIndex(filePath);
+
+            Debug.Assert(Equals(filePath, LookupFileByIndex(fileIndex)));
+
+            // We use multiple packing schemes for this data. TypeSize below excludes the CLR's per-object overhead.
+            //
+            // Name                         TypeSize  FileIndex      Line           Column
+            //
+            // EmptyElementLocation         0         0 (max 0)       0 (max 0)       0 (max 0)
+            //
+            // SmallFileElementLocation     8         4 (max 65,535)  2 (max 256)     2 (max 256)
+            // SmallLineElementLocation     8         2 (max 256)     4 (max 65,535)  2 (max 256)
+            // SmallColumnElementLocation   8         2 (max 256)     2 (max 256)     4 (max 65,535)
+            //
+            // LargeFileElementLocation     16        8 (max 2b)      4 (max 65,535)  4 (max 65,535)
+            // LargeLineElementLocation     16        4 (max 65,535)  8 (max 2b)      4 (max 65,535)
+            // LargeColumnElementLocation   16        4 (max 65,535)  4 (max 65,535)  8 (max 2b)
+            //
+            // FullElementLocation          24        8 (max 2b)      8 (max 2b)      8 (max 2b)
+
+            // Check for empty first
+            if (fileIndex is 0 && line is 0 && column is 0)
+            {
+                return EmptyElementLocation.Instance;
+            }
+
+            combinedValue |= fileIndex;
 
+            // We want class sizes as multiples of 8 on 64-bit architectures, for alignment reasons.
+            // Any space used between these multiples leads to unused bytes in padding. We want to
+            // take advantage of these sizes effectively, so we check for various requirements and
+            // choose.
+            //
+            // Search in popularity order to reduce the number of branches taken through this code.
+            //
             // When combinedValue is less than a threshold, it implies that both line and column are less
             // than that threshold.
-            if (combinedValue <= ushort.MaxValue)
+
+            // Handle cases that fit in 0xFF and 0XFFFF.
+            if (combinedValue <= byte.MaxValue)
+            {
+                // All values fit within a byte. Pick one of the 8-byte types.
+                return new SmallFileElementLocation((ushort)fileIndex, (byte)line, (byte)column);
+            }
+            else if (combinedValue <= ushort.MaxValue)
             {
-                return new SmallElementLocation(file, (ushort)line, (ushort)column);
+                // At least one value needs ushort. Try to use an 8-byte type all the same.
+                if (line <= byte.MaxValue && column <= byte.MaxValue)
+                {
+                    // Only fileIndex needs 4 bytes
+                    return new SmallFileElementLocation((ushort)fileIndex, (byte)line, (byte)column);
+                }
+                else if (fileIndex <= byte.MaxValue && column <= byte.MaxValue)
+                {
+                    // Only line needs 4 bytes
+                    return new SmallLineElementLocation((byte)fileIndex, (ushort)line, (byte)column);
+                }
+                else if (fileIndex <= byte.MaxValue && line <= byte.MaxValue)
+                {
+                    // Only column needs 4 bytes
+                    return new SmallColumnElementLocation((byte)fileIndex, (byte)line, (ushort)column);
+                }
+                else
+                {
+                    // 
+                    return new LargeFileElementLocation(fileIndex, (ushort)line, (ushort)column);
+                }
             }
+            else
+            {
+                // At least one value needs int.
+                if (fileIndex <= short.MaxValue && column <= short.MaxValue)
+                {
+                    // Only line needs 8 bytes
+                    return new LargeLineElementLocation((ushort)fileIndex, line, (ushort)column);
+                }
+                else if (line <= short.MaxValue && column <= short.MaxValue)
+                {
+                    // Only fileIndex needs 8 bytes
+                    return new LargeFileElementLocation(fileIndex, (ushort)line, (ushort)column);
+                }
+                else if (fileIndex <= short.MaxValue && line <= short.MaxValue)
+                {
+                    // Only column needs 8 bytes
+                    return new LargeColumnElementLocation((ushort)fileIndex, (ushort)line, column);
+                }
+                else
+                {
+                    return new FullElementLocation(fileIndex, line, column);
+                }
+            }
+
+            static int GetOrAddFileIndex(string? file)
+            {
+                if (file is null)
+                {
+                    return 0;
+                }
+
+                if (s_indexByFile.TryGetValue(file, out int index))
+                {
+                    return index + 1;
+                }
+
+                return AddFile();
+
+                int AddFile()
+                {
+                    int index = Interlocked.Increment(ref s_nextFileIndex) - 1;
+
+                    SetValue(index);
+
+                    _ = ImmutableInterlocked.TryAdd(ref s_indexByFile, file, index);
+
+                    return index + 1;
+                }
+
+                void SetValue(int index)
+                {
+                    while (true)
+                    {
+                        string[] array = Volatile.Read(ref s_fileByIndex);
+
+                        if (index < array.Length)
+                        {
+                            array[index] = file;
+                            return;
+                        }
+
+                        // Need to grow the array
+
+                        // Wait for the last value to be non-null, so that we have all values to copy
+                        while (array[array.Length - 1] is null)
+                        {
+                            Thread.SpinWait(100);
+                        }
+
+                        int newArrayLength = array.Length * 2;
+
+                        while (index >= newArrayLength)
+                        {
+                            newArrayLength *= 2;
+                        }
+
+                        string[] newArray = new string[newArrayLength];
+                        array.AsSpan().CopyTo(newArray);
+                        newArray[index] = file;
+
+                        string[] exchanged = Interlocked.CompareExchange(ref s_fileByIndex, newArray, array);
+
+                        if (ReferenceEquals(exchanged, array))
+                        {
+                            // We replaced it
+                            return;
+                        }
 
-            return new RegularElementLocation(file, line, column);
+                        // Otherwise, loop around again. We can't just return exchanged here,
+                        // as theoretically the array might have been grown more than once.
+                    }
+                }
+            }
         }
 
-        /// <summary>
-        /// Rarer variation for when the line and column won't each fit in a ushort.
-        /// </summary>
-        private sealed class RegularElementLocation(string file, int line, int column) : ElementLocation
+        internal static string LookupFileByIndex(int index)
         {
-            /// <inheritdoc />
-            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-            public override string File { get; } = file;
+            if (index is 0)
+            {
+                return "";
+            }
+
+            index -= 1;
 
-            /// <inheritdoc />
-            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-            public override int Line { get; } = line;
+            Thread.MemoryBarrier();
 
-            /// <inheritdoc />
-            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-            public override int Column { get; } = column;
+            string[] array = Volatile.Read(ref s_fileByIndex);
+
+            while (index >= array.Length)
+            {
+                // Data race! Spin.
+                array = Volatile.Read(ref s_fileByIndex);
+            }
+
+            return array[index];
         }
 
-        /// <summary>
-        /// For when the line and column each fit in a short - under 65536
-        /// (almost always will: microsoft.common.targets is less than 5000 lines long)
-        /// When loading Australian Government, for example, there are over 31,000 ElementLocation
-        /// objects so this saves 4 bytes each = 123KB
-        ///
-        /// A "very small" variation that used two bytes (or halves of a short) would fit about half of them
-        /// and save 4 more bytes each, but the CLR packs each field to 4 bytes, so it isn't actually any smaller.
-        /// </summary>
-        private sealed class SmallElementLocation(string file, ushort line, ushort column) : ElementLocation
+        #region Element implementations
+
+#pragma warning disable SA1516 // Elements should be separated by blank line
+
+        private sealed class EmptyElementLocation() : ElementLocation
+        {
+            /// <summary>
+            /// Gets the singleton, immutable empty element location.
+            /// </summary>
+            /// <remarks>
+            /// Not to be be used when something is "missing". Use a <see langword="null"/> location for that.
+            /// Use only for the project location when the project has not been given a name.
+            /// In that case, it exists, but can't have a specific location.
+            /// </remarks>
+            public static EmptyElementLocation Instance { get; } = new();
+
+            public override string File => "";
+            public override int Line => 0;
+            public override int Column => 0;
+        }
+
+        private sealed class SmallFileElementLocation(ushort file, byte line, byte column) : ElementLocation
+        {
+            public override string File => LookupFileByIndex(file);
+            public override int Line => line;
+            public override int Column => column;
+        }
+        
+        private sealed class SmallLineElementLocation(byte file, ushort line, byte column) : ElementLocation
+        {
+            public override string File => LookupFileByIndex(file);
+            public override int Line => line;
+            public override int Column => column;
+        }
+        
+        private sealed class SmallColumnElementLocation(byte file, byte line, ushort column) : ElementLocation
         {
-            /// <inheritdoc />
-            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-            public override string File => file;
+            public override string File => LookupFileByIndex(file);
+            public override int Line => line;
+            public override int Column => column;
+        }
 
-            /// <inheritdoc />
-            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
+        private sealed class LargeFileElementLocation(int file, ushort line, ushort column) : ElementLocation
+        {
+            public override string File => LookupFileByIndex(file);
             public override int Line => line;
+            public override int Column => column;
+        }
 
-            /// <inheritdoc />
-            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
+        private sealed class LargeLineElementLocation(ushort file, int line, ushort column) : ElementLocation
+        {
+            public override string File => LookupFileByIndex(file);
+            public override int Line => line;
             public override int Column => column;
         }
+
+        private sealed class LargeColumnElementLocation(ushort file, ushort line, int column) : ElementLocation
+        {
+            public override string File => LookupFileByIndex(file);
+            public override int Line => line;
+            public override int Column => column;
+        }
+
+        private sealed class FullElementLocation(int file, int line, int column) : ElementLocation
+        {
+            public override string File => LookupFileByIndex(file);
+            public override int Line => line;
+            public override int Column => column;
+        }
+
+#pragma warning restore SA1516 // Elements should be separated by blank line
+
+        #endregion
     }
 }
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index 71f51e9f272..b70dcd17d88 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -84,6 +84,16 @@ internal XmlDocumentWithLocation(bool? loadAsReadOnly)
             _loadAsReadOnly = loadAsReadOnly;
         }
 
+        /// <summary>
+        /// Constructor that allows specifying the full path. Intended for unit tests only,
+        /// to avoid having to files to disk during tests just to see location paths populated.
+        /// </summary>
+        internal XmlDocumentWithLocation(bool? loadAsReadOnly, string fullPath)
+            : this(loadAsReadOnly)
+        {
+            _fullPath = fullPath;
+        }
+
         /// <summary>
         /// Whether to load files read only
         /// </summary>
