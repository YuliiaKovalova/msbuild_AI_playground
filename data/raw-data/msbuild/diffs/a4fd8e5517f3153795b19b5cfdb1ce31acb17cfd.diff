diff --git a/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
index 8cfb2d4a575..a0d79660060 100644
--- a/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -52,7 +53,11 @@ public void GetBuckets()
             properties.Set(ProjectPropertyInstance.Create("UnitTests", "unittests.foo"));
             properties.Set(ProjectPropertyInstance.Create("OBJ", "obj"));
 
-            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), MockElementLocation.Instance);
+            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(
+                parameters,
+                CreateLookup(itemsByType, properties),
+                MockElementLocation.Instance,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             Assert.Equal(5, buckets.Count);
 
@@ -62,7 +67,14 @@ public void GetBuckets()
                 XmlAttribute tempXmlAttribute = (new XmlDocument()).CreateAttribute("attrib");
                 tempXmlAttribute.Value = "'$(Obj)'=='obj'";
 
-                Assert.True(ConditionEvaluator.EvaluateCondition(tempXmlAttribute.Value, ParserOptions.AllowAll, bucket.Expander, ExpanderOptions.ExpandAll, Directory.GetCurrentDirectory(), MockElementLocation.Instance, null, new BuildEventContext(1, 2, 3, 4), FileSystems.Default));
+                Assert.True(ConditionEvaluator.EvaluateCondition(
+                    tempXmlAttribute.Value,
+                    ParserOptions.AllowAll,
+                    bucket.Expander, ExpanderOptions.ExpandAll,
+                    Directory.GetCurrentDirectory(),
+                    MockElementLocation.Instance,
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
                 Assert.Equal("a.doc;b.doc;c.doc;d.doc;e.doc", bucket.Expander.ExpandIntoStringAndUnescape("@(doc)", ExpanderOptions.ExpandItems, MockElementLocation.Instance));
                 Assert.Equal("unittests.foo", bucket.Expander.ExpandIntoStringAndUnescape("$(bogus)$(UNITTESTS)", ExpanderOptions.ExpandPropertiesAndMetadata, MockElementLocation.Instance));
             }
@@ -130,7 +142,11 @@ public void ValidUnqualifiedMetadataReference()
 
             PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
-            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), null);
+            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(
+                parameters,
+                CreateLookup(itemsByType, properties),
+                null,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             Assert.Equal(2, buckets.Count);
         }
 
@@ -164,7 +180,11 @@ public void InvalidUnqualifiedMetadataReference()
 
                 // This is expected to throw because not all items contain a value for metadata "Culture".
                 // Only a.foo has a Culture metadata.  b.foo does not.
-                BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), MockElementLocation.Instance);
+                BatchingEngine.PrepareBatchingBuckets(
+                    parameters,
+                    CreateLookup(itemsByType, properties),
+                    MockElementLocation.Instance,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             });
         }
         /// <summary>
@@ -185,7 +205,11 @@ public void NoItemsConsumed()
                 PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
                 // This is expected to throw because we have no idea what item list %(Culture) refers to.
-                BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), MockElementLocation.Instance);
+                BatchingEngine.PrepareBatchingBuckets(
+                    parameters,
+                    CreateLookup(itemsByType, properties),
+                    MockElementLocation.Instance,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             });
         }
         /// <summary>
@@ -211,7 +235,11 @@ public void Regress_Mutation_DuplicateBatchingBucketsAreFoldedTogether()
 
             PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
-            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), null);
+            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(
+                parameters,
+                CreateLookup(itemsByType, properties),
+                null,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             // If duplicate buckets have been folded correctly, then there will be exactly one bucket here
             // containing both a.foo and b.foo.
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index 66a27a4e9d6..f94ef7e8ec0 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -83,7 +83,7 @@ public void TestConstructorNullTarget()
                 BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
                 BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
                 Lookup lookup = new Lookup(new ItemDictionary<ProjectItemInstance>(project.Items), new PropertyDictionary<ProjectPropertyInstance>(project.Properties));
-                TargetEntry entry = new TargetEntry(requestEntry, this, null, lookup, null, TargetBuiltReason.None, _host, false);
+                TargetEntry entry = new TargetEntry(requestEntry, this, null, lookup, null, TargetBuiltReason.None, _host, null, false);
             });
         }
         /// <summary>
@@ -97,7 +97,7 @@ public void TestConstructorNullLookup()
                 ProjectInstance project = CreateTestProject(true /* Returns enabled */);
                 BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
                 BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
-                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), null, null, TargetBuiltReason.None, _host, false);
+                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), null, null, TargetBuiltReason.None, _host, null, false);
             });
         }
         /// <summary>
@@ -113,7 +113,7 @@ public void TestConstructorNullHost()
                 BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
 
                 Lookup lookup = new Lookup(new ItemDictionary<ProjectItemInstance>(project.Items), new PropertyDictionary<ProjectPropertyInstance>(project.Properties));
-                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), lookup, null, TargetBuiltReason.None, null, false);
+                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), lookup, null, TargetBuiltReason.None, null, null, false);
             });
         }
         /// <summary>
@@ -1025,7 +1025,7 @@ private TargetEntry CreateStandardTargetEntry(ProjectInstance project, string ta
             BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
 
             Lookup lookup = new Lookup(new ItemDictionary<ProjectItemInstance>(project.Items), new PropertyDictionary<ProjectPropertyInstance>(project.Properties));
-            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(targetName, project.Targets[targetName].Location), lookup, null, TargetBuiltReason.None, _host, false);
+            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(targetName, project.Targets[targetName].Location), lookup, null, TargetBuiltReason.None, _host, null, false);
             return entry;
         }
 
@@ -1041,7 +1041,7 @@ private TargetEntry CreateStandardTargetEntry(ProjectInstance project, string ta
             BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
             config.Project = project;
             BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[1] { "foo" }), config);
-            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(target, project.Targets[target].Location), baseEntry.Lookup, baseEntry, TargetBuiltReason.None, _host, false);
+            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(target, project.Targets[target].Location), baseEntry.Lookup, baseEntry, TargetBuiltReason.None, _host, null, false);
             return entry;
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index cd2a93acc25..015ea763ac2 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -569,7 +569,7 @@ private DependencyAnalysisResult PerformDependencyAnalysisTestHelper(
                 ProjectInstance p = project.CreateProjectInstance();
 
                 // now do the dependency analysis
-                ItemBucket itemBucket = new ItemBucket(null, null, new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), 0);
+                ItemBucket itemBucket = new ItemBucket(null, null, new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), null, 0);
                 TargetUpToDateChecker analyzer = new TargetUpToDateChecker(p, p.Targets["Build"], _mockHost, BuildEventContext.Invalid);
 
                 return analyzer.PerformDependencyAnalysis(itemBucket, false, out changedTargetInputs, out upToDateTargetInputs);
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index ba22e2beed0..f1c2df5d7b4 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1283,7 +1283,7 @@ private void InitializeHost(bool throwOnExecute)
             itemsByName.Add(item2);
             _twoItems = new ITaskItem[] { new TaskItem(item), new TaskItem(item2) };
 
-            _bucket = new ItemBucket(Array.Empty<string>(), new Dictionary<string, string>(), new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), 0);
+            _bucket = new ItemBucket(Array.Empty<string>(), new Dictionary<string, string>(), new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), null, 0);
             _host.FindTask(null);
             _host.InitializeForBatch(talc, _bucket, null);
             _parametersSetOnTask = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
diff --git a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
index 1e8bcaf1f14..91d8bec792d 100644
--- a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Engine.UnitTests.TestComparers;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -2184,8 +2185,7 @@ internal TaskRegistry CreateTaskRegistryAndRegisterTasks(List<ProjectUsingTaskEl
 
             string currentDir = Directory.GetCurrentDirectory();
             TaskRegistry.InitializeTaskRegistryFromUsingTaskElements(
-                _loggingService,
-                _loggerContext,
+                _targetLoggingContext,
                 usingTaskElements.Select(el => (el, currentDir)),
                 registry,
                 RegistryExpander,
@@ -2249,7 +2249,11 @@ internal static Expander<ProjectPropertyInstance, ProjectItemInstance> GetExpand
             secondaryItemsByName.ImportItems(thirdItemGroup);
             secondaryItemsByName.ImportItems(trueItemGroup);
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, secondaryItemsByName, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                pg,
+                secondaryItemsByName,
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             return expander;
         }
 
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index b33fd7a00ce..f9157225a69 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -6,8 +6,10 @@
 using System.IO;
 using System.Text.RegularExpressions;
 using System.Xml;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -34,9 +36,9 @@ public void OverrideTasksAreFoundInOverridePath()
             string overrideDir = NativeMethodsShared.IsWindows ? "c:\\msbuildoverridetasks" : "/msbuildoverridetasks";
             Toolset t = new Toolset("toolsversionname", dir, new PropertyDictionary<ProjectPropertyInstance>(), new ProjectCollection(), new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), overrideDir, new DirectoryExists(this.directoryExists));
 
-            LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
 
             string[] expectedRegisteredTasks = { "a1", "a2", "a3", "a4", "b1", "e1", "g1", "g2", "g3" };
             string[] expectedOverrideTasks = { "a1" /* special because it is in the override tasks file as well as in the tasks file*/, "oa1", "oa2", "og1", "ooo" };
@@ -79,8 +81,10 @@ public void OverrideTaskPathIsRelative()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", "msbuildoverridetasks");
@@ -96,8 +100,9 @@ public void OverrideTaskPathHasInvalidChars()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             mockLogger.AssertLogContains("MSB4194");
@@ -113,8 +118,9 @@ public void OverrideTaskPathHasTooLongOfAPath()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", tooLong);
@@ -131,8 +137,9 @@ public void OverrideTaskPathIsNotFound()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", "k:\\Thecatinthehat");
@@ -153,7 +160,8 @@ public void DefaultTasksAreFoundInToolsPath()
                 null,
                 new DirectoryExists(this.directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(null, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             string[] expectedRegisteredTasks = { "a1", "a2", "a3", "a4", "b1", "e1", "g1", "g2", "g3" };
             string[] unexpectedRegisteredTasks = { "c1", "d1", "f1", "11", "12", "13", "21" };
@@ -178,10 +186,11 @@ public void WarningLoggedIfNoDefaultTasksFound()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
 
             Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2\\doesntexist", new PropertyDictionary<ProjectPropertyInstance>(), new ProjectCollection(), new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), null, new DirectoryExists(this.directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(service, BuildEventContext.Invalid, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             string[] unexpectedRegisteredTasks = { "a1", "a2", "a3", "a4", "b1", "c1", "d1", "e1", "f1", "g1", "g2", "g3", "11", "12", "13", "21" };
 
@@ -201,9 +210,10 @@ public void InvalidToolPath()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
             Toolset t = new Toolset("toolsversionname", "invalid||path", new PropertyDictionary<ProjectPropertyInstance>(), p, new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), null, new DirectoryExists(this.directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(service, BuildEventContext.Invalid, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             Console.WriteLine(mockLogger.FullLog);
             Assert.Equal(1, mockLogger.WarningCount); // "Expected a warning for invalid character in toolpath"
@@ -221,19 +231,18 @@ public void VerifyTasksFilesAreInSortedOrder()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
             string dir = NativeMethodsShared.IsWindows ? "c:\\directory1\\directory2" : "/directory1/directory2";
             string overrideDir = NativeMethodsShared.IsWindows ? "c:\\msbuildoverridetasks" : "/msbuildoverridetasks";
             string[] foundFiles = Toolset.GetTaskFiles(
                 new DirectoryGetFiles(this.getFiles),
-                service,
-                BuildEventContext.Invalid,
+                loggingContext,
                 "*.tasks",
                 dir,
                 String.Empty);
             string[] foundoverrideFiles = Toolset.GetTaskFiles(
                 new DirectoryGetFiles(this.getFiles),
-                service,
-                BuildEventContext.Invalid,
+                loggingContext,
                 "*.overridetasks",
                 overrideDir,
                 String.Empty);
@@ -894,7 +903,9 @@ public void InlineTasksInDotTasksFile()
                 null,
                 new DirectoryExists(directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(null, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             // Did not crash due to trying to expand items without having items
         }
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 851061a1417..e8605bd9cd5 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -12,6 +12,7 @@
 
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -4390,9 +4391,8 @@ public void VerifyConditionEvaluatorResetStateOnFailure()
                     ExpanderOptions.ExpandProperties,
                     Directory.GetCurrentDirectory(),
                     MockElementLocation.Instance,
-                    null,
-                    new BuildEventContext(1, 2, 3, 4),
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
                 Assert.True(false, "Expect exception due to the value of property \"TargetOSFamily\" is not a number.");
             }
             catch (InvalidProjectFileException e)
@@ -4409,9 +4409,8 @@ public void VerifyConditionEvaluatorResetStateOnFailure()
                 ExpanderOptions.ExpandProperties,
                 Directory.GetCurrentDirectory(),
                 MockElementLocation.Instance,
-                null,
-                new BuildEventContext(1, 2, 3, 4),
-                FileSystems.Default));
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 90f06cf86c7..50ea7ea6258 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -95,7 +95,11 @@ public void ExpandAllIntoTaskItems3()
             itemsByType.ImportItems(ig);
             itemsByType.ImportItems(ig2);
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, itemsByType, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                pg,
+                itemsByType,
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             IList<TaskItem> itemsOut = expander.ExpandIntoTaskItemsLeaveEscaped("foo;bar;@(compile);@(resource)", ExpanderOptions.ExpandPropertiesAndItems, MockElementLocation.Instance);
 
@@ -802,7 +806,11 @@ private Expander<ProjectPropertyInstance, ProjectItemInstance> CreateExpander()
             ig.Add(i0);
             ig.Add(i1);
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, ig, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                pg,
+                ig,
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             return expander;
         }
@@ -2271,9 +2279,8 @@ public void PropertyFunctionInCondition()
                     ExpanderOptions.ExpandProperties,
                     Directory.GetCurrentDirectory(),
                     MockElementLocation.Instance,
-                    null,
-                    new BuildEventContext(1, 2, 3, 4),
-                    FileSystems.Default));
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
             Assert.True(
                 ConditionEvaluator.EvaluateCondition(
                     @"'$(PathRoot.EndsWith(" + Path.DirectorySeparatorChar + "))' == 'false'",
@@ -2282,9 +2289,8 @@ public void PropertyFunctionInCondition()
                     ExpanderOptions.ExpandProperties,
                     Directory.GetCurrentDirectory(),
                     MockElementLocation.Instance,
-                    null,
-                    new BuildEventContext(1, 2, 3, 4),
-                    FileSystems.Default));
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
index 856de263ffe..06b32c45258 100644
--- a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
@@ -4,7 +4,9 @@
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.UnitTests.BackEnd;
@@ -87,7 +89,11 @@ private ProjectInstanceExpander CreateExpander(Dictionary<string, string[]> item
         {
             var itemDictionary = ToItemDictionary(items);
 
-            return new ProjectInstanceExpander(new PropertyDictionary<ProjectPropertyInstance>(), itemDictionary, (IFileSystem)FileSystems.Default);
+            return new ProjectInstanceExpander(
+                new PropertyDictionary<ProjectPropertyInstance>(),
+                itemDictionary,
+                (IFileSystem)FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
         }
 
         private static ItemDictionary<ProjectItemInstance> ToItemDictionary(Dictionary<string, string[]> itemTypes)
diff --git a/src/Build.UnitTests/ExpressionTree_Tests.cs b/src/Build.UnitTests/ExpressionTree_Tests.cs
index 70ce8bb76d5..1c730e8d38d 100644
--- a/src/Build.UnitTests/ExpressionTree_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTree_Tests.cs
@@ -99,7 +99,7 @@ public void FunctionTests()
         {
             Parser p = new Parser();
             GenericExpressionNode tree;
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), new ItemDictionary<ProjectItemInstance>(), FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), new ItemDictionary<ProjectItemInstance>(), FileSystems.Default, null);
             expander.Metadata = new StringMetadataTable(null);
             bool value;
 
@@ -149,7 +149,7 @@ public void PropertyTests()
             propertyBag.Set(ProjectPropertyInstance.Create("x86", "x86"));
             propertyBag.Set(ProjectPropertyInstance.Create("no", "no"));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default, null);
             AssertParseEvaluate(p, "$(foo)", expander, true);
             AssertParseEvaluate(p, "!$(foo)", expander, false);
             // Test properties with strings
@@ -187,7 +187,7 @@ public void ItemListTests()
             itemBag.Add(new ProjectItemInstance(parentProject, "Compile", "baz.cs", parentProject.FullPath));
             itemBag.Add(new ProjectItemInstance(parentProject, "Boolean", "true", parentProject.FullPath));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "@(Compile) == 'foo.cs;bar.cs;baz.cs'", expander, true);
             AssertParseEvaluate(p, "@(Compile,' ') == 'foo.cs bar.cs baz.cs'", expander, true);
@@ -230,7 +230,7 @@ public void StringExpansionTests()
             propertyBag.Set(ProjectPropertyInstance.Create("AnotherTestQuote", "Here's Johnny!"));
             propertyBag.Set(ProjectPropertyInstance.Create("Atsign", "Test the @ replacement"));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "'simplestring: true foo.cs;bar.cs;baz.cs' == '$(simple): $(foo) @(compile)'", expander, true);
             AssertParseEvaluate(p, "'$(c1) $(c2)' == 'Another (complex) one. Another (complex) one.'", expander, true);
@@ -262,7 +262,7 @@ public void ComplexTests()
             propertyBag.Set(ProjectPropertyInstance.Create("c1", "Another (complex) one."));
             propertyBag.Set(ProjectPropertyInstance.Create("c2", "Another (complex) one."));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "(($(foo) != 'two' and $(bar)) and 5 >= 1) or $(one) == 1", expander, true);
             AssertParseEvaluate(p, "(($(foo) != 'twoo' or !$(bar)) and 5 >= 1) or $(two) == 1", expander, true);
@@ -283,7 +283,7 @@ public void InvalidItemInConditionEvaluation()
 
             PropertyDictionary<ProjectPropertyInstance> propertyBag = new PropertyDictionary<ProjectPropertyInstance>();
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluateThrow(p, "@(Compile) > 0", expander, null);
         }
@@ -312,7 +312,7 @@ public void OldSyntaxTests()
             propertyBag.Set(ProjectPropertyInstance.Create("c1", "Another (complex) one."));
             propertyBag.Set(ProjectPropertyInstance.Create("c2", "Another (complex) one."));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "(($(foo) != 'two' and $(bar)) and 5 >= 1) or $(one) == 1", expander, true);
         }
@@ -329,7 +329,7 @@ public void ConditionedPropertyUpdateTests()
             itemBag.Add(new ProjectItemInstance(parentProject, "Compile", "bar.cs", parentProject.FullPath));
             itemBag.Add(new ProjectItemInstance(parentProject, "Compile", "baz.cs", parentProject.FullPath));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default, null);
             Dictionary<string, List<string>> conditionedProperties = new Dictionary<string, List<string>>();
             ConditionEvaluator.IConditionEvaluationState state =
                                new ConditionEvaluator.ConditionEvaluationState<ProjectPropertyInstance, ProjectItemInstance>(
@@ -416,7 +416,7 @@ public void NotTests()
             propertyBag.Set(ProjectPropertyInstance.Create("foo", "4"));
             propertyBag.Set(ProjectPropertyInstance.Create("bar", "32"));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default, null);
 
             AssertParseEvaluate(p, "!true", expander, false);
             AssertParseEvaluate(p, "!(true)", expander, false);
diff --git a/src/Build.UnitTests/TestLoggingContext.cs b/src/Build.UnitTests/TestLoggingContext.cs
new file mode 100644
index 00000000000..c509d6a8bce
--- /dev/null
+++ b/src/Build.UnitTests/TestLoggingContext.cs
@@ -0,0 +1,29 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Engine.UnitTests
+{
+    internal sealed class TestLoggingContext : LoggingContext
+    {
+        public TestLoggingContext(ILoggingService loggingService, BuildEventContext eventContext) : base(
+            loggingService, eventContext)
+        {
+            IsValid = true;
+        }
+
+        public static LoggingContext CreateTestContext(BuildEventContext buildEventContext)
+        {
+            return new TestLoggingContext(
+                Build.BackEnd.Logging.LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1),
+                buildEventContext);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 9c59416ea49..9e9235a75c4 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1461,7 +1461,7 @@ private void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, Bui
             {
                 buildEventContext = new BuildEventContext(request.SubmissionId, 0, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
             }
-
+            
             var instances = ProjectInstance.LoadSolutionForBuild(
                 config.ProjectFullPath,
                 config.GlobalProperties,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index 646381478b9..aa0cb6e18f8 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -80,9 +81,10 @@ internal static class BatchingEngine
         internal static List<ItemBucket> PrepareBatchingBuckets(
             List<string> batchableObjectParameters,
             Lookup lookup,
-            ElementLocation elementLocation)
+            ElementLocation elementLocation,
+            LoggingContext loggingContext)
         {
-            return PrepareBatchingBuckets(batchableObjectParameters, lookup, null, elementLocation);
+            return PrepareBatchingBuckets(batchableObjectParameters, lookup, null, elementLocation, loggingContext);
         }
 
         /// <summary>
@@ -94,12 +96,14 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
         /// <param name="lookup"></param>
         /// <param name="implicitBatchableItemType">Any item type that can be considered an implicit input to this batchable object.
         /// This is useful for items inside targets, where the item name is plainly an item type that's an "input" to the object.</param>
+        /// <param name="loggingContext"></param>
         /// <returns>List containing ItemBucket objects, each one representing an execution batch.</returns>
         internal static List<ItemBucket> PrepareBatchingBuckets(
             List<string> batchableObjectParameters,
             Lookup lookup,
             string implicitBatchableItemType,
-            ElementLocation elementLocation)
+            ElementLocation elementLocation,
+            LoggingContext loggingContext)
         {
             if (batchableObjectParameters == null)
             {
@@ -160,7 +164,7 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
                 {
                     // If the batchable object consumes item metadata as well as items to be batched,
                     // we need to partition the items consumed by the object.
-                    buckets = BucketConsumedItems(lookup, itemListsToBeBatched, consumedMetadataReferences, elementLocation);
+                    buckets = BucketConsumedItems(lookup, itemListsToBeBatched, consumedMetadataReferences, elementLocation, loggingContext);
                 }
             }
 
@@ -170,7 +174,7 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
             {
                 // create a default bucket that references the project items and properties -- this way we always have a bucket
                 buckets = new List<ItemBucket>(1);
-                buckets.Add(new ItemBucket(null, null, lookup, buckets.Count));
+                buckets.Add(new ItemBucket(null, null, lookup, loggingContext, buckets.Count));
             }
 
             return buckets;
@@ -292,7 +296,8 @@ private static List<ItemBucket> BucketConsumedItems(
             Lookup lookup,
             Dictionary<string, ICollection<ProjectItemInstance>> itemListsToBeBatched,
             Dictionary<string, MetadataReference> consumedMetadataReferences,
-            ElementLocation elementLocation)
+            ElementLocation elementLocation,
+            LoggingContext loggingContext)
         {
             ErrorUtilities.VerifyThrow(itemListsToBeBatched.Count > 0, "Need item types consumed by the batchable object.");
             ErrorUtilities.VerifyThrow(consumedMetadataReferences.Count > 0, "Need item metadata consumed by the batchable object.");
@@ -329,7 +334,7 @@ private static List<ItemBucket> BucketConsumedItems(
                         // this item to the bucket.
                         if (matchingBucket == null)
                         {
-                            matchingBucket = new ItemBucket(itemListsToBeBatched.Keys, itemMetadataValues, lookup, buckets.Count);
+                            matchingBucket = new ItemBucket(itemListsToBeBatched.Keys, itemMetadataValues, lookup, loggingContext, buckets.Count);
 
                             // make sure to put the new bucket into the appropriate location
                             // in the sorted list as indicated by the binary search
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 08cc3e9f5e0..22da1937cd9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -58,7 +58,7 @@ internal override void ExecuteTask(Lookup lookup)
                 {
                     List<string> parameterValues = new List<string>();
                     GetBatchableValuesFromBuildItemGroupChild(parameterValues, child);
-                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, child.ItemType, _taskInstance.Location);
+                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, child.ItemType, _taskInstance.Location, LoggingContext);
 
                     // "Execute" each bucket
                     foreach (ItemBucket bucket in buckets)
@@ -70,9 +70,8 @@ internal override void ExecuteTask(Lookup lookup)
                             ExpanderOptions.ExpandAll,
                             Project.Directory,
                             child.ConditionLocation,
-                            LoggingContext.LoggingService,
-                            LoggingContext.BuildEventContext,
-                            FileSystems.Default);
+                            FileSystems.Default,
+                            LoggingContext);
 
                         if (condition)
                         {
@@ -177,8 +176,6 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     ExpanderOptions.ExpandAll,
                     Project.Directory,
                     metadataInstance.Location,
-                    LoggingContext.LoggingService,
-                    LoggingContext.BuildEventContext,
                     FileSystems.Default,
                     loggingContext: loggingContext);
 
@@ -216,9 +213,8 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 ExpanderOptions.ExpandAll,
                 Project.Directory,
                 child.KeepDuplicatesLocation,
-                LoggingContext.LoggingService,
-                LoggingContext.BuildEventContext,
-                FileSystems.Default);
+                FileSystems.Default,
+                LoggingContext);
 
             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd?.Count > 0)
             {
@@ -325,8 +321,6 @@ private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     ExpanderOptions.ExpandAll,
                     Project.Directory,
                     metadataInstance.ConditionLocation,
-                    LoggingContext.LoggingService,
-                    LoggingContext.BuildEventContext,
                     FileSystems.Default,
                     loggingContext: loggingContext);
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
index bd333b01ec8..433a89aec37 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
@@ -53,7 +53,7 @@ internal override void ExecuteTask(Lookup lookup)
                     // Find all the metadata references in order to create buckets
                     List<string> parameterValues = new List<string>();
                     GetBatchableValuesFromProperty(parameterValues, property);
-                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, property.Location);
+                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, property.Location, LoggingContext);
 
                     // "Execute" each bucket
                     foreach (ItemBucket bucket in buckets)
@@ -65,9 +65,8 @@ internal override void ExecuteTask(Lookup lookup)
                             ExpanderOptions.ExpandAll,
                             Project.Directory,
                             property.ConditionLocation,
-                            LoggingContext.LoggingService,
-                            LoggingContext.BuildEventContext,
-                            FileSystems.Default);
+                            FileSystems.Default,
+                            LoggingContext);
 
                         if (condition)
                         {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
index 21650e6448f..b4e8dc503d9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -69,11 +70,13 @@ private ItemBucket()
         /// <param name="itemNames">Item types being batched on: null indicates no batching is occurring</param>
         /// <param name="metadata">Hashtable of item metadata values: null indicates no batching is occurring</param>
         /// <param name="lookup">The <see cref="Lookup"/> to use for the items in the bucket.</param>
+        /// <param name="loggingContext"></param>
         /// <param name="bucketSequenceNumber">A sequence number indication what order the buckets were created in.</param>
         internal ItemBucket(
             ICollection<string> itemNames,
             Dictionary<string, string> metadata,
             Lookup lookup,
+            LoggingContext loggingContext,
             int bucketSequenceNumber)
         {
             ErrorUtilities.VerifyThrow(lookup != null, "Need lookup.");
@@ -95,7 +98,7 @@ internal ItemBucket(
             }
 
             _metadata = metadata;
-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default);
+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default, loggingContext);
 
             _bucketSequenceNumber = bucketSequenceNumber;
         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index bb3f3c87d9e..44619791b73 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -734,10 +734,10 @@ private async Task<bool> PushTargets(IList<TargetSpecification> targets, TargetE
                         }
                     }
                 }
-
+                
                 // Add to the list of targets to push.  We don't actually put it on the stack here because we could run into a circular dependency
                 // during this loop, in which case the target stack would be out of whack.
-                TargetEntry newEntry = new TargetEntry(_requestEntry, this as ITargetBuilderCallback, targetSpecification, baseLookup, parentTargetEntry, buildReason, _componentHost, stopProcessingOnCompletion);
+                TargetEntry newEntry = new TargetEntry(_requestEntry, this as ITargetBuilderCallback, targetSpecification, baseLookup, parentTargetEntry, buildReason, _componentHost, _projectLoggingContext, stopProcessingOnCompletion);
                 newEntry.ErrorTarget = addAsErrorTarget;
                 targetsToPush.Add(newEntry);
                 stopProcessingOnCompletion = false; // The first target on the stack (the last one to be run) always inherits the stopProcessing flag.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index bbfc80ae5d9..d971b5aee52 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -7,6 +7,7 @@
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
@@ -162,8 +163,17 @@ internal class TargetEntry : IEquatable<TargetEntry>
         /// <param name="parentTarget">The parent of this entry, if any.</param>
         /// <param name="buildReason">The reason the parent built this target.</param>
         /// <param name="host">The Build Component Host to use.</param>
+        /// <param name="loggingContext"></param>
         /// <param name="stopProcessingOnCompletion">True if the target builder should stop processing the current target stack when this target is complete.</param>
-        internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, TargetSpecification targetSpecification, Lookup baseLookup, TargetEntry parentTarget, TargetBuiltReason buildReason, IBuildComponentHost host, bool stopProcessingOnCompletion)
+        internal TargetEntry(
+            BuildRequestEntry requestEntry,
+            ITargetBuilderCallback targetBuilderCallback,
+            TargetSpecification targetSpecification,
+            Lookup baseLookup, TargetEntry parentTarget,
+            TargetBuiltReason buildReason,
+            IBuildComponentHost host,
+            LoggingContext loggingContext,
+            bool stopProcessingOnCompletion)
         {
             ErrorUtilities.VerifyThrowArgumentNull(requestEntry, nameof(requestEntry));
             ErrorUtilities.VerifyThrowArgumentNull(targetBuilderCallback, nameof(targetBuilderCallback));
@@ -176,7 +186,7 @@ internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targ
             _targetSpecification = targetSpecification;
             _parentTarget = parentTarget;
             _buildReason = buildReason;
-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(baseLookup, baseLookup, FileSystems.Default);
+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(baseLookup, baseLookup, FileSystems.Default, loggingContext);
             _state = TargetEntryState.Dependencies;
             _baseLookup = baseLookup;
             _host = host;
@@ -351,8 +361,6 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 ExpanderOptions.ExpandPropertiesAndItems,
                 _requestEntry.ProjectRootDirectory,
                 _target.ConditionLocation,
-                projectLoggingContext.LoggingService,
-                projectLoggingContext.BuildEventContext,
                 FileSystems.Default,
                 loggingContext: projectLoggingContext);
 
@@ -420,7 +428,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
 
                 // Generate the batching buckets.  Note that each bucket will get a lookup based on the baseLookup.  This lookup will be in its
                 // own scope, which we will collapse back down into the baseLookup at the bottom of the function.
-                List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location);
+                List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location, projectLoggingContext);
 
                 WorkUnitResult aggregateResult = new WorkUnitResult();
                 TargetLoggingContext targetLoggingContext = null;
@@ -612,14 +620,14 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                                  ExpanderOptions.ExpandPropertiesAndItems,
                                  requestEntry.ProjectRootDirectory,
                                  _target.KeepDuplicateOutputsLocation,
-                                 projectLoggingContext.LoggingService,
-                                 projectLoggingContext.BuildEventContext, FileSystems.Default);
+                                 FileSystems.Default,
+                                 projectLoggingContext);
 
                         // NOTE: we need to gather the outputs in batches, because the output specification may reference item metadata
                         // Also, we are using the baseLookup, which has possibly had changes made to it since the project started.  Because of this, the
                         // set of outputs calculated here may differ from those which would have been calculated at the beginning of the target.  It is
                         // assumed the user intended this.
-                        List<ItemBucket> batchingBuckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location);
+                        List<ItemBucket> batchingBuckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location, targetLoggingContext);
 
                         if (keepDupes)
                         {
@@ -704,8 +712,8 @@ internal List<TargetSpecification> GetErrorTargets(ProjectLoggingContext project
                     ExpanderOptions.ExpandPropertiesAndItems,
                     _requestEntry.ProjectRootDirectory,
                     errorTargetInstance.ConditionLocation,
-                    projectLoggingContext.LoggingService,
-                    projectLoggingContext.BuildEventContext, FileSystems.Default);
+                    FileSystems.Default,
+                    projectLoggingContext);
 
                 if (condition)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 485ee854f73..7de3911a32b 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -311,9 +311,9 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
 #endif
                         taskHost.IsOutOfProc, _cancellationToken);
                 }
-
+                
                 List<string> taskParameterValues = CreateListOfParameterValues();
-                buckets = BatchingEngine.PrepareBatchingBuckets(taskParameterValues, lookup, _targetChildInstance.Location);
+                buckets = BatchingEngine.PrepareBatchingBuckets(taskParameterValues, lookup, _targetChildInstance.Location, _targetLoggingContext);
 
                 Dictionary<string, string> lookupHash = null;
 
@@ -379,8 +379,6 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 ExpanderOptions.ExpandAll,
                 _buildRequestEntry.ProjectRootDirectory,
                 _targetChildInstance.ConditionLocation,
-                _targetLoggingContext.LoggingService,
-                _targetLoggingContext.BuildEventContext,
                 FileSystems.Default,
                 loggingContext: _targetLoggingContext);
 
@@ -1080,9 +1078,8 @@ private bool GatherTaskOutputs(TaskExecutionHost taskExecutionHost, TaskExecutio
                     ExpanderOptions.ExpandAll,
                     _buildRequestEntry.ProjectRootDirectory,
                     taskOutputSpecification.ConditionLocation,
-                    _targetLoggingContext.LoggingService,
-                    _targetLoggingContext.BuildEventContext,
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    _targetLoggingContext);
 
                 if (condition)
                 {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 39bf2fe89b5..f9dccc1991a 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -241,7 +241,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
                 )
                 {
                     throw new BuildCheckConfigurationException(
-                        $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
+                        $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'. Check the '[MSBuild]::RegisterAnalyzer' intrinsic function call in the analyzer package .props file.");
                 }
 
                 configurations = ConfigurationProvider.GetMergedConfigurations(userConfigs, analyzer);
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index baf4fa9a0e6..0c0edf27d9b 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -4264,7 +4264,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Prepares the data object for evaluation.
             /// </summary>
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext)
             {
                 DefaultTargets = null;
                 Properties = new PropertyDictionary<ProjectProperty>();
@@ -4272,7 +4272,7 @@ public void InitializeForEvaluation(IToolsetProvider toolsetProvider, Evaluation
                 Items = new ItemDictionary<ProjectItem>();
                 ItemsIgnoringCondition = new ItemDictionary<ProjectItem>();
                 ItemsByEvaluatedIncludeCache = new MultiDictionary<string, ProjectItem>(StringComparer.OrdinalIgnoreCase);
-                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, evaluationContext);
+                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, evaluationContext, loggingContext);
                 ItemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinition>(MSBuildNameIgnoreCaseComparer.Default);
                 Targets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
                 ImportClosure = new List<ResolvedImport>();
@@ -4282,7 +4282,7 @@ public void InitializeForEvaluation(IToolsetProvider toolsetProvider, Evaluation
                 AllEvaluatedItems = new List<ProjectItem>();
                 EvaluatedItemElements = new List<ProjectItemElement>();
                 EvaluationId = BuildEventContext.InvalidEvaluationId;
-
+                
                 _globalPropertiesToTreatAsLocal?.Clear();
 
                 // Include the main project in the list of imports, as this list is
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index ddcf37f6b30..c0f57858dae 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -497,6 +497,11 @@ string IItem.GetMetadataValueEscaped(string name)
 
                 if (metadatum != null && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
                 {
+                    // this.Project.LoggingService
+                    // this.Project.FullPath
+
+                    Debugger.Launch();
+
                     Expander<ProjectProperty, ProjectItem> expander = new Expander<ProjectProperty, ProjectItem>(null, null, new BuiltInMetadataTable(this), FileSystems.Default);
 
                     value = expander.ExpandIntoStringLeaveEscaped(metadatum.EvaluatedValueEscaped, ExpanderOptions.ExpandBuiltInMetadata, metadatum.Location);
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index bf9ae352007..dcde06d288f 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -9,6 +9,8 @@
 using System.Linq;
 using System.Xml;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
@@ -685,7 +687,7 @@ internal static Toolset FactoryForDeserialization(ITranslator translator)
         /// <summary>
         /// Given a search path and a task pattern get a list of task or override task files.
         /// </summary>
-        internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskPattern, string searchPath, string taskFileWarning)
+        internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, LoggingContext loggingContext, string taskPattern, string searchPath, string taskFileWarning)
         {
             string[] defaultTasksFiles = null;
 
@@ -703,8 +705,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
 
                 if (defaultTasksFiles.Length == 0)
                 {
-                    loggingServices.LogWarning(
-                        buildEventContext,
+                    loggingContext.LogWarning(
                         null,
                         new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
                         taskFileWarning,
@@ -715,8 +716,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                loggingServices.LogWarning(
-                    buildEventContext,
+                loggingContext.LogWarning(
                     null,
                     new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
                     taskFileWarning,
@@ -819,13 +819,12 @@ internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
         /// <summary>
         /// Return a task registry stub for the tasks in the *.tasks file for this toolset
         /// </summary>
-        /// <param name="loggingServices">The logging services used to log during task registration.</param>
-        /// <param name="buildEventContext">The build event context used to log during task registration.</param>
+        /// <param name="loggingContext">The logging context used to log during task registration.</param>
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
         /// <returns>The task registry</returns>
-        internal TaskRegistry GetTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        internal TaskRegistry GetTaskRegistry(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
-            RegisterDefaultTasks(loggingServices, buildEventContext, projectRootElementCache);
+            RegisterDefaultTasks(loggingContext, projectRootElementCache);
             return _defaultTaskRegistry;
         }
 
@@ -846,13 +845,12 @@ internal string GenerateSubToolsetVersionUsingVisualStudioVersion(IDictionary<st
         /// <summary>
         /// Return a task registry for the override tasks in the *.overridetasks file for this toolset
         /// </summary>
-        /// <param name="loggingServices">The logging services used to log during task registration.</param>
-        /// <param name="buildEventContext">The build event context used to log during task registration.</param>
+        /// <param name="loggingContext">The logging context used to log during task registration.</param>
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
         /// <returns>The task registry</returns>
-        internal TaskRegistry GetOverrideTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        internal TaskRegistry GetOverrideTaskRegistry(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
-            RegisterOverrideTasks(loggingServices, buildEventContext, projectRootElementCache);
+            RegisterOverrideTasks(loggingContext, projectRootElementCache);
             return _overrideTaskRegistry;
         }
 
@@ -867,10 +865,9 @@ internal TaskRegistry GetOverrideTaskRegistry(ILoggingService loggingServices, B
         /// 3) comment tags are always ignored regardless of their placement
         /// 4) the rest of the tags are expected to be &lt;UsingTask&gt; tags
         /// </remarks>
-        /// <param name="loggingServices">The logging services to use to log during this registration.</param>
-        /// <param name="buildEventContext">The build event context to use to log during this registration.</param>
+        /// <param name="loggingContext">The logging context to use to log during this registration.</param>
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
-        private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        private void RegisterDefaultTasks(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
             if (!_defaultTasksRegistrationAttempted)
             {
@@ -878,10 +875,10 @@ private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventCon
                 {
                     _defaultTaskRegistry = new TaskRegistry(projectRootElementCache);
 
-                    InitializeProperties(loggingServices, buildEventContext);
+                    InitializeProperties(loggingContext);
 
-                    string[] defaultTasksFiles = GetTaskFiles(_getFiles, loggingServices, buildEventContext, DefaultTasksFilePattern, ToolsPath, "DefaultTasksFileLoadFailureWarning");
-                    LoadAndRegisterFromTasksFile(defaultTasksFiles, loggingServices, buildEventContext, "DefaultTasksFileFailure", projectRootElementCache, _defaultTaskRegistry);
+                    string[] defaultTasksFiles = GetTaskFiles(_getFiles, loggingContext, DefaultTasksFilePattern, ToolsPath, "DefaultTasksFileLoadFailureWarning");
+                    LoadAndRegisterFromTasksFile(defaultTasksFiles, loggingContext, "DefaultTasksFileFailure", projectRootElementCache, _defaultTaskRegistry);
                 }
                 finally
                 {
@@ -893,7 +890,7 @@ private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventCon
         /// <summary>
         /// Initialize the properties which are used to evaluate the tasks files.
         /// </summary>
-        private void InitializeProperties(ILoggingService loggingServices, BuildEventContext buildEventContext)
+        private void InitializeProperties(LoggingContext loggingContext)
         {
             if (_expander != null)
             {
@@ -965,18 +962,18 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
 
                 propertyBag.ImportProperties(_globalProperties);
 
-                _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, FileSystems.Default);
+                _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, FileSystems.Default, loggingContext);
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                loggingServices.LogError(buildEventContext, new BuildEventFileInfo(/* this warning truly does not involve any file it is just gathering properties */String.Empty), "TasksPropertyBagError", e.Message);
+                loggingContext.LogError(new BuildEventFileInfo(/* this warning truly does not involve any file it is just gathering properties */String.Empty), "TasksPropertyBagError", e.Message);
             }
         }
 
         /// <summary>
         /// Used to load information about MSBuild override tasks i.e. tasks that override tasks declared in tasks or project files.
         /// </summary>
-        private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        private void RegisterOverrideTasks(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
             if (!_overrideTasksRegistrationAttempted)
             {
@@ -1005,23 +1002,23 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
                             if (!overrideDirectoryExists)
                             {
                                 string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", _overrideTasksPath);
-                                loggingServices.LogWarning(buildEventContext, null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
+                                loggingContext.LogWarning(null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
                             }
                         }
                     }
                     catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                     {
                         string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskProblemWithPath", _overrideTasksPath, e.Message);
-                        loggingServices.LogWarning(buildEventContext, null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
+                        loggingContext.LogWarning(null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
                     }
 
                     if (overrideDirectoryExists)
                     {
-                        InitializeProperties(loggingServices, buildEventContext);
-                        string[] overrideTasksFiles = GetTaskFiles(_getFiles, loggingServices, buildEventContext, OverrideTasksFilePattern, _overrideTasksPath, "OverrideTasksFileLoadFailureWarning");
+                        InitializeProperties(loggingContext);
+                        string[] overrideTasksFiles = GetTaskFiles(_getFiles, loggingContext, OverrideTasksFilePattern, _overrideTasksPath, "OverrideTasksFileLoadFailureWarning");
 
                         // Load and register any override tasks
-                        LoadAndRegisterFromTasksFile(overrideTasksFiles, loggingServices, buildEventContext, "OverrideTasksFileFailure", projectRootElementCache, _overrideTaskRegistry);
+                        LoadAndRegisterFromTasksFile(overrideTasksFiles, loggingContext, "OverrideTasksFileFailure", projectRootElementCache, _overrideTaskRegistry);
                     }
                 }
                 finally
@@ -1034,14 +1031,13 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
         /// <summary>
         /// Do the actual loading of the tasks or override tasks file and register the tasks in the task registry
         /// </summary>
-        private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskFileError, ProjectRootElementCacheBase projectRootElementCache, TaskRegistry registry)
+        private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, LoggingContext loggingContext, string taskFileError, ProjectRootElementCacheBase projectRootElementCache, TaskRegistry registry)
         {
             string currentTasksFile = null;
             try
             {
                 TaskRegistry.InitializeTaskRegistryFromUsingTaskElements<ProjectPropertyInstance, ProjectItemInstance>(
-                    loggingServices,
-                    buildEventContext,
+                    loggingContext,
                     EnumerateTasksRegistrations(),
                     registry,
                     _expander,
@@ -1056,7 +1052,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                loggingServices.LogError(buildEventContext, new BuildEventFileInfo(currentTasksFile),
+                loggingContext.LogError(new BuildEventFileInfo(currentTasksFile),
                     taskFileError, e.Message);
             }
 
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 0799d38db90..634767dbd32 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.IO;
 using System.Linq;
 using System.Runtime.CompilerServices;
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 115b26aafca..1426d207089 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -186,11 +186,9 @@ internal static bool EvaluateCondition<P, I>(
             ExpanderOptions expanderOptions,
             string evaluationDirectory,
             ElementLocation elementLocation,
-            ILoggingService loggingServices,
-            BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase? projectRootElementCache = null,
-            LoggingContext? loggingContext = null)
+            LoggingContext? loggingContext,
+            ProjectRootElementCacheBase? projectRootElementCache = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -202,11 +200,9 @@ internal static bool EvaluateCondition<P, I>(
                 conditionedPropertiesTable: null /* do not collect conditioned properties */,
                 evaluationDirectory,
                 elementLocation,
-                loggingServices,
-                buildEventContext,
                 fileSystem,
-                projectRootElementCache,
-                loggingContext);
+                loggingContext,
+                projectRootElementCache);
         }
 
         /// <summary>
@@ -224,18 +220,15 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
             Dictionary<string, List<string>>? conditionedPropertiesTable,
             string evaluationDirectory,
             ElementLocation elementLocation,
-            ILoggingService loggingServices,
-            BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase? projectRootElementCache = null,
-            LoggingContext? loggingContext = null)
+            LoggingContext? loggingContext,
+            ProjectRootElementCacheBase? projectRootElementCache = null)
             where P : class, IProperty
             where I : class, IItem
         {
             ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
             ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
             ErrorUtilities.VerifyThrowArgumentLength(evaluationDirectory, nameof(evaluationDirectory));
-            ErrorUtilities.VerifyThrowArgumentNull(buildEventContext, nameof(buildEventContext));
 
             // An empty condition is equivalent to a "true" condition.
             if (condition.Length == 0)
@@ -263,8 +256,8 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
                 var conditionParser = new Parser();
 
                 #region REMOVE_COMPAT_WARNING
-                conditionParser.LoggingServices = loggingServices;
-                conditionParser.LogBuildEventContext = buildEventContext;
+                conditionParser.LoggingServices = loggingContext?.LoggingService;
+                conditionParser.LogBuildEventContext = loggingContext?.BuildEventContext ?? BuildEventContext.Invalid;
                 #endregion
 
                 parsedExpression = conditionParser.Parse(condition, options, elementLocation);
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index a7864d4c3ae..404e29a7568 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -220,6 +220,8 @@ private Evaluator(
             ErrorUtilities.VerifyThrowInternalNull(loggingService, nameof(loggingService));
             ErrorUtilities.VerifyThrowInternalNull(buildEventContext, nameof(buildEventContext));
 
+            // Debugger.Launch();
+
             _evaluationLoggingContext = new EvaluationLoggingContext(
                 loggingService,
                 buildEventContext,
@@ -238,7 +240,7 @@ private Evaluator(
             }
 
             // Create containers for the evaluation results
-            data.InitializeForEvaluation(toolsetProvider, _evaluationContext);
+            data.InitializeForEvaluation(toolsetProvider, _evaluationContext, _evaluationLoggingContext);
 
             _expander = new Expander<P, I>(data, data, _evaluationContext, _evaluationLoggingContext);
 
@@ -711,8 +713,7 @@ private void Evaluate()
                 {
                     // Evaluate the usingtask and add the result into the data passed in
                     TaskRegistry.InitializeTaskRegistryFromUsingTaskElements<P, I>(
-                        _evaluationLoggingContext.LoggingService,
-                        _evaluationLoggingContext.BuildEventContext,
+                        _evaluationLoggingContext,
                         _usingTaskElements.Select(p => (p.Value, p.Key)),
                         _data.TaskRegistry,
                         _expander,
@@ -2390,8 +2391,6 @@ private bool EvaluateCondition(ProjectElement element, string condition, Expande
                     expanderOptions,
                     GetCurrentDirectoryForConditionEvaluation(element),
                     element.ConditionLocation,
-                    _evaluationLoggingContext.LoggingService,
-                    _evaluationLoggingContext.BuildEventContext,
                     _evaluationContext.FileSystem,
                     loggingContext: _evaluationLoggingContext);
 
@@ -2429,9 +2428,8 @@ private bool EvaluateConditionCollectingConditionedProperties(ProjectElement ele
                     _data.ConditionedProperties,
                     GetCurrentDirectoryForConditionEvaluation(element),
                     element.ConditionLocation,
-                    _evaluationLoggingContext.LoggingService,
-                    _evaluationLoggingContext.BuildEventContext,
                     _evaluationContext.FileSystem,
+                    _evaluationLoggingContext,
                     projectRootElementCache);
 
                 return result;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 561a10edca0..267c22487b3 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -326,31 +326,44 @@ private void FlushFirstValueIfNeeded()
         /// Creates an expander passing it some properties to use.
         /// Properties may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
+        internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem, LoggingContext loggingContext)
         {
             _properties = properties;
             _propertiesUsageTracker = new PropertiesUsageTracker();
             _fileSystem = fileSystem;
+            _loggingContext = loggingContext;
         }
 
+        /// <summary>
+        /// Creates an expander passing it some properties to use.
+        /// Properties may be null.
+        ///
+        /// Used for tests and for ToolsetReader - that operates agnostic on the project
+        ///   - so no logging context is passed, and no BuildCheck analysis will be executed.
+        /// </summary>
+        internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
+        : this(properties, fileSystem, null)
+        { }
+
         /// <summary>
         /// Creates an expander passing it some properties to use and the evaluation context.
         /// Properties may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationContext)
+        internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationContext, LoggingContext loggingContext)
         {
             _properties = properties;
             _propertiesUsageTracker = new PropertiesUsageTracker();
             _fileSystem = evaluationContext.FileSystem;
             EvaluationContext = evaluationContext;
+            _loggingContext = loggingContext;
         }
 
         /// <summary>
         /// Creates an expander passing it some properties and items to use.
         /// Either or both may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFileSystem fileSystem)
-            : this(properties, fileSystem)
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFileSystem fileSystem, LoggingContext loggingContext)
+            : this(properties, fileSystem, loggingContext)
         {
             _items = items;
         }
@@ -360,8 +373,8 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFile
         /// Creates an expander passing it some properties and items to use, and the evaluation context.
         /// Either or both may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext)
-            : this(properties, evaluationContext)
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext, LoggingContext loggingContext)
+            : this(properties, evaluationContext, loggingContext)
         {
             _items = items;
         }
@@ -385,8 +398,23 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, Evalu
         /// Creates an expander passing it some properties, items, and/or metadata to use.
         /// Any or all may be null.
         /// </summary>
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMetadataTable metadata, IFileSystem fileSystem, LoggingContext loggingContext)
+            : this(properties, items, fileSystem, loggingContext)
+        {
+            _metadata = metadata;
+        }
+
+        /// <summary>
+        /// Creates an expander passing it some properties, items, and/or metadata to use.
+        /// Any or all may be null.
+        ///
+        /// This is for the purpose of evaluations through API calls, that might not be able to pass the logging context
+        ///  - BuildCheck analysis won't be executed for those.
+        /// (for one of the calls we can actually pass IDataConsumingContext - as we have logging service and project)
+        /// 
+        /// </summary>
         internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMetadataTable metadata, IFileSystem fileSystem)
-            : this(properties, items, fileSystem)
+            : this(properties, items, fileSystem, null)
         {
             _metadata = metadata;
         }
@@ -2302,14 +2330,6 @@ internal static IEnumerable<KeyValuePair<string, S>> GetItemPairEnumerable(IEnum
                     }
                 }
 
-                /// <summary>
-                /// Intrinsic function that returns the number of items in the list.
-                /// </summary>
-                internal static IEnumerable<KeyValuePair<string, S>> Count(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
-                {
-                    yield return new KeyValuePair<string, S>(Convert.ToString(itemsOfType.Count(), CultureInfo.InvariantCulture), null /* no base item */);
-                }
-
                 /// <summary>
                 /// Intrinsic function that returns the specified built-in modifer value of the items in itemsOfType
                 /// Tuple is {current item include, item under transformation}.
@@ -3015,43 +3035,6 @@ internal MetadataMatchEvaluator(string itemSpec, IItem sourceOfMetadata, IElemen
                     _sourceOfMetadata = sourceOfMetadata;
                     _elementLocation = elementLocation;
                 }
-
-                /// <summary>
-                /// Expands the metadata in the match provided into a string result.
-                /// The match is expected to be the content of a transform.
-                /// For example, representing "%(Filename.obj)" in the original expression "@(Compile->'%(Filename.obj)')".
-                /// </summary>
-                internal string GetMetadataValueFromMatch(Match match)
-                {
-                    string name = match.Groups[RegularExpressions.NameGroup].Value;
-
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(match.Groups[RegularExpressions.ItemSpecificationGroup].Length == 0, _elementLocation, "QualifiedMetadataInTransformNotAllowed", match.Value, name);
-
-                    string value = null;
-                    try
-                    {
-                        if (FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(name))
-                        {
-                            // If we're not a ProjectItem or ProjectItemInstance, then ProjectDirectory will be null.
-                            // In that case, we're safe to get the current directory as we'll be running on TaskItems which
-                            // only exist within a target where we can trust the current directory
-                            string directoryToUse = _sourceOfMetadata.ProjectDirectory ?? Directory.GetCurrentDirectory();
-                            string definingProjectEscaped = _sourceOfMetadata.GetMetadataValueEscaped(FileUtilities.ItemSpecModifiers.DefiningProjectFullPath);
-
-                            value = FileUtilities.ItemSpecModifiers.GetItemSpecModifier(directoryToUse, _itemSpec, definingProjectEscaped, name);
-                        }
-                        else
-                        {
-                            value = _sourceOfMetadata.GetMetadataValueEscaped(name);
-                        }
-                    }
-                    catch (InvalidOperationException ex)
-                    {
-                        ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "CannotEvaluateItemMetadata", name, ex.Message);
-                    }
-
-                    return value;
-                }
             }
         }
 
@@ -5498,6 +5481,11 @@ internal void TrackRead(string propertyName, int startIndex, int endIndex, IElem
             // TODO: This might get executed even before the logging service and BuildComponentCollections
             //  are initialized (for the toolset initialization)
 
+            if (BuildCheckManagerProvider.GlobalBuildEngineDataConsumer is not null && loggingContext is null)
+            {
+                Debugger.Launch();
+            }
+
             // We are collecting the read data here - instead of in the PropertyTrackingEvaluatorDataWrapper
             //  because that one is used only during evaluation, however already not from within Targets
             BuildCheckManagerProvider.GlobalBuildEngineDataConsumer?.ProcessPropertyRead(
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 3d21ae23edd..26c06913959 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -212,7 +213,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Prepares the data block for a new evaluation pass
         /// </summary>
-        void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext);
+        void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext);
 
         /// <summary>
         /// Indicates to the data block that evaluation has completed,
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index cf78951e6d0..01f40a6f348 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -291,9 +291,9 @@ public ProjectTargetInstance GetTarget(string targetName)
                 return _wrappedData.GetTarget(targetName);
             }
 
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext)
             {
-                _wrappedData.InitializeForEvaluation(toolsetProvider, evaluationContext);
+                _wrappedData.InitializeForEvaluation(toolsetProvider, evaluationContext, loggingContext);
             }
 
             public void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 7479b6942d3..4ffbb2a60b9 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -54,7 +54,7 @@ public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> ite
             _outerEvaluatorData = data;
             _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext, loggingContext);
             _evaluatorData = new EvaluatorData(_outerEvaluatorData, _itemLists);
-            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext);
+            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext, loggingContext);
             _itemFactory = itemFactory;
             _loggingContext = loggingContext;
             _evaluationProfiler = evaluationProfiler;
@@ -90,8 +90,6 @@ private static bool EvaluateCondition(
                     expanderOptions,
                     GetCurrentDirectoryForConditionEvaluation(element, lazyEvaluator),
                     element.ConditionLocation,
-                    lazyEvaluator._loggingContext.LoggingService,
-                    lazyEvaluator._loggingContext.BuildEventContext,
                     lazyEvaluator.FileSystem,
                     loggingContext: lazyEvaluator._loggingContext);
                 MSBuildEventSource.Log.EvaluateConditionStop(condition, result);
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 281c8dc0be2..c9402df7ab5 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -147,7 +148,7 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         public IItemDictionary<I> Items => _wrapped.Items;
         public List<ProjectItemElement> EvaluatedItemElements => _wrapped.EvaluatedItemElements;
         public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => _wrapped.EnvironmentVariablePropertiesDictionary;
-        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext);
+        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext, loggingContext);
         public void FinishEvaluation() => _wrapped.FinishEvaluation();
         public void AddItem(I item) => _wrapped.AddItem(item);
         public void AddItemIgnoringCondition(I item) => _wrapped.AddItemIgnoringCondition(item);
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 68c39e341c1..28d48fbdf6d 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -14,6 +14,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.BuildCheck.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
@@ -59,6 +60,12 @@ public enum ProjectInstanceSettings
         ImmutableWithFastItemLookup = Immutable | 0x2
     }
 
+    internal interface IDataConsumingContext
+    {
+        public ILoggingService LoggingService { get; }
+        public string ProjectPath { get; }
+    }
+
     /// <summary>
     /// What the user gets when they clone off a ProjectInstance.
     /// They can hold onto this, change/query items and properties,
@@ -405,7 +412,7 @@ public ProjectInstance(Project project, ProjectInstanceSettings settings)
             {
                 this.EvaluatedItemElements.Add(item.Xml);
             }
-
+            
             _usingDifferentToolsVersionFromProjectFile = false;
             _originalProjectToolsVersion = project.ToolsVersion;
             _explicitToolsVersionSpecified = project.SubToolsetVersion != null;
@@ -1556,7 +1563,7 @@ ICollection<ProjectItemInstance> IItemProvider<ProjectItemInstance>.GetItems(str
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
         void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.
-            InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
+            InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext)
         {
             // All been done in the constructor.  We don't allow re-evaluation of project instances.
         }
@@ -2089,7 +2096,8 @@ public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<Fo
         /// </comment>
         public string ExpandString(string unexpandedValue)
         {
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default);
+            // possibly logging service (but might save the evaluationcontext - no it's invalidated after eval done)
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default, _loggingContext);
 
             string result = expander.ExpandIntoStringAndUnescape(unexpandedValue, ExpanderOptions.ExpandPropertiesAndItems, ProjectFileLocation);
 
@@ -2107,7 +2115,7 @@ public string ExpandString(string unexpandedValue)
         /// </comment>
         public bool EvaluateCondition(string condition)
         {
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default, _loggingContext);
 
             bool result = ConditionEvaluator.EvaluateCondition(
                 condition,
@@ -2116,9 +2124,8 @@ public bool EvaluateCondition(string condition)
                 ExpanderOptions.ExpandPropertiesAndItems,
                 Directory,
                 ProjectFileLocation,
-                null /* no logging service */,
-                BuildEventContext.Invalid,
-                FileSystems.Default);
+                FileSystems.Default,
+                this._loggingContext);
 
             return result;
         }
@@ -2894,6 +2901,12 @@ private static ProjectPropertyInstance InstantiateProjectPropertyInstance(Projec
             return instance;
         }
 
+        /// <summary>
+        /// Logging context - set during the evaluation.
+        /// Can be null - especially if the project was fetched from the cache.
+        /// </summary>
+        private LoggingContext _loggingContext;
+
         /// <summary>
         /// Common code for the constructors that evaluate directly.
         /// Global properties may be null.
@@ -2934,6 +2947,7 @@ private void Initialize(
             _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(MSBuildNameIgnoreCaseComparer.Default);
             _hostServices = buildParameters.HostServices;
             this.ProjectRootElementCache = buildParameters.ProjectRootElementCache;
+            _loggingContext = new AnalyzerLoggingContext(loggingService, buildEventContext);
 
             this.EvaluatedItemElements = new List<ProjectItemElement>();
 
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index cf6fc186770..a136486260d 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1296,11 +1296,13 @@ public string GetMetadataEscaped(string metadataName)
                         return metadatum.EvaluatedValueEscaped;
                     }
                 }
-
+                
                 metadatum = GetItemDefinitionMetadata(metadataName);
 
                 if (metadatum != null && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
                 {
+                    Debugger.Launch();
+
                     Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(null, null, new BuiltInMetadataTable(null, this), FileSystems.Default);
 
                     // We don't have a location to use, but this is very unlikely to error
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 5b65829e926..598819b3cd4 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -11,6 +11,7 @@
 using System.Reflection;
 using System.Threading;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
@@ -249,8 +250,7 @@ internal IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> TaskReg
         /// <typeparam name="P">A type derived from IProperty</typeparam>
         /// <typeparam name="I">A type derived from IItem</typeparam>
         internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
-            ILoggingService loggingService,
-            BuildEventContext buildEventContext,
+            LoggingContext loggingContext,
             IEnumerable<(ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile)> registrations,
             TaskRegistry taskRegistry,
             Expander<P, I> expander,
@@ -262,8 +262,7 @@ internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
             foreach ((ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile) registration in registrations)
             {
                 RegisterTasksFromUsingTaskElement(
-                    loggingService,
-                    buildEventContext,
+                    loggingContext,
                     registration.directoryOfImportingFile,
                     registration.projectUsingTaskXml,
                     taskRegistry,
@@ -284,8 +283,7 @@ internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
         /// <typeparam name="I">A type derived from IItem</typeparam>
         private static void RegisterTasksFromUsingTaskElement
             <P, I>(
-            ILoggingService loggingService,
-            BuildEventContext buildEventContext,
+            LoggingContext loggingContext,
             string directoryOfImportingFile,
             ProjectUsingTaskElement projectUsingTaskXml,
             TaskRegistry taskRegistry,
@@ -307,9 +305,8 @@ private static void RegisterTasksFromUsingTaskElement
                     expanderOptions,
                     projectUsingTaskXml.ContainingProject.DirectoryPath,
                     projectUsingTaskXml.ConditionLocation,
-                    loggingService,
-                    buildEventContext,
-                    fileSystem))
+                    fileSystem,
+                    loggingContext))
             {
                 return;
             }
@@ -444,7 +441,7 @@ private static void RegisterTasksFromUsingTaskElement
                 taskFactoryParameters.Add(XMakeAttributes.architecture, architecture == String.Empty ? XMakeAttributes.MSBuildArchitectureValues.any : architecture);
             }
 
-            taskRegistry.RegisterTask(taskName, AssemblyLoadInfo.Create(assemblyName, assemblyFile), taskFactory, taskFactoryParameters, parameterGroupAndTaskElementRecord, loggingService, buildEventContext, projectUsingTaskXml, ConversionUtilities.ValidBooleanTrue(overrideUsingTask));
+            taskRegistry.RegisterTask(taskName, AssemblyLoadInfo.Create(assemblyName, assemblyFile), taskFactory, taskFactoryParameters, parameterGroupAndTaskElementRecord, loggingContext, projectUsingTaskXml, ConversionUtilities.ValidBooleanTrue(overrideUsingTask));
         }
 
         private static Dictionary<string, string> CreateTaskFactoryParametersDictionary(int? initialCount = null)
@@ -547,7 +544,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             // Try the override task registry first
             if (_toolset != null)
             {
-                TaskRegistry toolsetRegistry = _toolset.GetOverrideTaskRegistry(targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext, RootElementCache);
+                TaskRegistry toolsetRegistry = _toolset.GetOverrideTaskRegistry(targetLoggingContext, RootElementCache);
                 taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
             }
 
@@ -606,7 +603,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             // If we didn't find the task but we have a fallback registry in the toolset state, try that one.
             if (taskRecord == null && _toolset != null)
             {
-                TaskRegistry toolsetRegistry = _toolset.GetTaskRegistry(targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext, RootElementCache);
+                TaskRegistry toolsetRegistry = _toolset.GetTaskRegistry(targetLoggingContext, RootElementCache);
                 taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
             }
 
@@ -687,8 +684,7 @@ private void RegisterTask(
             string taskFactory,
             Dictionary<string, string> taskFactoryParameters,
             RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord,
-            ILoggingService loggingService,
-            BuildEventContext context,
+            LoggingContext loggingContext,
             ProjectUsingTaskElement projectUsingTaskInXml,
             bool overrideTask = false)
         {
@@ -733,7 +729,7 @@ private void RegisterTask(
                     {
                         if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))
                         {
-                            loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), "DuplicateOverrideUsingTaskElement", taskName);
+                            loggingContext.LogError(new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), "DuplicateOverrideUsingTaskElement", taskName);
                             break;
                         }
                     }
@@ -745,7 +741,7 @@ private void RegisterTask(
                     List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();
                     unqualifiedTaskNameMatches.Add(newRecord);
                     _overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);
-                    loggingService.LogComment(context, MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
+                    loggingContext.LogComment(MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
                 }
             }
 
