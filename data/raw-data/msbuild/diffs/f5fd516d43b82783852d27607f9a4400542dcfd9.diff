diff --git a/MSBuild.sln b/MSBuild.sln
index 5c8326406f6..d1daf054f9e 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -80,6 +80,8 @@ Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild.VSSetup.Arm64", "sr
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.UnitTests.Shared", "src\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj", "{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}"
 EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.BuildCheck.UnitTests", "src\BuildCheck.UnitTests\Microsoft.Build.BuildCheck.UnitTests.csproj", "{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -864,6 +866,30 @@ Global
 		{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}.Release|x64.Build.0 = Release|x64
 		{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}.Release|x86.ActiveCfg = Release|Any CPU
 		{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}.Release|x86.Build.0 = Release|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|ARM64.ActiveCfg = Debug|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|ARM64.Build.0 = Debug|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|x64.ActiveCfg = Debug|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|x64.Build.0 = Debug|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|x86.Build.0 = Debug|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|ARM64.Build.0 = MachineIndependent|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|Any CPU.Build.0 = Release|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|ARM64.ActiveCfg = Release|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|ARM64.Build.0 = Release|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x64.ActiveCfg = Release|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x64.Build.0 = Release|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x86.ActiveCfg = Release|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x86.Build.0 = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/documentation/wiki/MSBuild-Tips-&-Tricks.md b/documentation/wiki/MSBuild-Tips-&-Tricks.md
index 17b137ae33d..9dc4d33b44c 100644
--- a/documentation/wiki/MSBuild-Tips-&-Tricks.md
+++ b/documentation/wiki/MSBuild-Tips-&-Tricks.md
@@ -120,3 +120,41 @@ The above explanations are only half the truth, though.
 * The `Directory.*.props`, `Directory.*.targets` et. al. also offer ways to extend your build. They are fairly well-known and documented:
   * [`Directory.Build.props` and `Directory.Build.targets`](https://learn.microsoft.com/visualstudio/msbuild/customize-by-directory)
   * [`Directory.Solution.props` and `Directory.Solution.targets`](https://learn.microsoft.com/visualstudio/msbuild/customize-solution-build) as well as `before.{solutionname}.sln.targets` and `after.{solutionname}.sln.targets` can be used to inject properties, item definitions, items and targets into your build
+
+
+## Using quotes in MSBuild properties
+There are times when MSBuild needs to be invoked with property arguments using the `/p:propertyName=propertyValue` syntax. However, the way of achieving the proper result can vary depending on the shell used to run the MSBuild (PowerShell, PowerShell Core, Command Prompt, etc.). 
+
+When the property value contains quotes (`"`), it may be handled differently depending on the interpreting shell.
+
+Let's explore the ways to pass property values that contain special symbols like `"`:
+
+Example project: 
+```
+<Project>
+  <Target Name="PrintPropertyValue">
+      <Message Text="Property value = ($(propertyValue))" Importance="high" />
+  </Target>
+</Project>
+```
+
+- CMD:
+  ```
+  msbuild.exe filename.proj /p:propertyValue="Hello, \"World!\""
+  ```
+
+  For more details about parsing in CMD and usage of special characters, please visit [this page](https://learn.microsoft.com/windows-server/administration/windows-commands/cmd)
+
+- Windows PowerShell:
+  ```
+  msbuild.exe filename.proj /p:propertyValue="Hello, \`"World!\`""
+  ```
+
+  For more details about parsing in Windows PowerShell 5.1 and usage of special characters, please visit [this page](https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_parsing?view=powershell-5.1)
+
+- PowerShell Core:
+  ```
+  msbuild.exe filename.proj /p:propertyValue="Hello, `"World!`""
+  ```
+
+  For more details about parsing in PowerShell (7.4 and higher) and usage of special characters, please visit [this page](https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_parsing?view=powershell-7.4)
\ No newline at end of file
diff --git a/eng/BootStrapMsBuild.props b/eng/BootStrapMsBuild.props
new file mode 100644
index 00000000000..858cf76ac54
--- /dev/null
+++ b/eng/BootStrapMsBuild.props
@@ -0,0 +1,21 @@
+<Project>
+
+  <!--
+  Construct a location of MSBuild bootstrap folder - to be used for deployment and for tests
+   relying on bootstrapped MSBuild
+   -->
+
+  <PropertyGroup>
+    <BootstrapDestination>$(ArtifactsBinDir)bootstrap\</BootstrapDestination>
+    <BootstrapDestination Condition="'$(Platform)' == 'x64' or '$(Platform)' == 'arm64'">$(BootstrapDestination)$(Platform)\</BootstrapDestination>
+    <BootstrapDestination>$(BootstrapDestination)$(TargetFramework.ToLowerInvariant())\MSBuild\</BootstrapDestination>
+  </PropertyGroup>
+  
+  <PropertyGroup Condition="$(TargetFramework.StartsWith('net4'))">
+    <BootstrapBinaryDestination>$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin</BootstrapBinaryDestination>
+  </PropertyGroup>
+  
+  <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
+    <BootstrapBinaryDestination>$(BootstrapDestination)</BootstrapBinaryDestination>
+  </PropertyGroup>
+</Project>
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMsBuild.targets
similarity index 97%
rename from eng/BootStrapMSBuild.targets
rename to eng/BootStrapMsBuild.targets
index 3aafd190c94..07531f6633b 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMsBuild.targets
@@ -7,15 +7,14 @@
    -->
 
   <PropertyGroup>
-    <BootstrapDestination>$(ArtifactsBinDir)bootstrap\</BootstrapDestination>
-    <BootstrapDestination Condition="'$(Platform)' == 'x64' or '$(Platform)' == 'arm64'">$(BootstrapDestination)$(Platform)\</BootstrapDestination>
-    <BootstrapDestination>$(BootstrapDestination)$(TargetFramework.ToLowerInvariant())\MSBuild\</BootstrapDestination>
-
     <BootstrapDependsOn Condition="$(TargetFramework.StartsWith('net4'))">BootstrapFull</BootstrapDependsOn>
     <BootstrapDependsOn Condition="!$(TargetFramework.StartsWith('net4'))">BootstrapNetCore</BootstrapDependsOn>
 
     <!-- Needed to ensure that RuntimeTargetsCopyLocalItems is populated for full framework -->
     <DisableRuntimeTargets>false</DisableRuntimeTargets>
+
+    <!-- Disable build acceleration for this non-standard project. The Bootstrap target must run after any of the dependencies changes.  -->
+    <AccelerateBuildsInVisualStudio>false</AccelerateBuildsInVisualStudio>
   </PropertyGroup>
 
   <Target Name="Bootstrap" DependsOnTargets="$(BootstrapDependsOn)"
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index da3091ab2b6..3112f090fca 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -91,9 +91,9 @@
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>fb50d1a45ed10b39b5f335bc3a4bdcaea9b951cf</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24202.15">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24212.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>cbca41cad4e21c29548e9e57d7135740b6f78df9</Sha>
+      <Sha>0b1fefc344701f2669b2190fbfda5ca588083605</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24204.3">
diff --git a/eng/Versions.props b/eng/Versions.props
index b92fc40650c..0aefadce05d 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -51,7 +51,7 @@
     <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24204.3</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24202.15</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24212.1</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.10.0-preview.2.97</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index 71cbf493110..b6e3c089135 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -115,13 +115,12 @@ try {
 
   # When using bootstrapped MSBuild:
   # - Turn off node reuse (so that bootstrapped MSBuild processes don't stay running and lock files)
-  # - Do run tests
-  # - Don't try to create a bootstrap deployment
+  # - Create bootstrap environment as it's required when also running tests
   if ($onlyDocChanged) {
     & $PSScriptRoot\Common\Build.ps1 -restore -build -ci /p:CreateBootstrap=false /nr:false @properties
   }
   else {
-    & $PSScriptRoot\Common\Build.ps1 -restore -build -test -ci /p:CreateBootstrap=false /nr:false @properties
+    & $PSScriptRoot\Common\Build.ps1 -restore -build -test -ci /p:CreateBootstrap=true /nr:false @properties
   }
 
   exit $lastExitCode
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index 06d4ba46e21..8edd377ec73 100755
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -80,11 +80,10 @@ export DOTNET_HOST_PATH="$_InitializeDotNetCli/dotnet"
 
 # When using bootstrapped MSBuild:
 # - Turn off node reuse (so that bootstrapped MSBuild processes don't stay running and lock files)
-# - Do run tests
-# - Don't try to create a bootstrap deployment
+# - Create bootstrap environment as it's required when also running tests
 if [ $onlyDocChanged = 0 ]
 then
-    . "$ScriptRoot/common/build.sh" --restore --build --test --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=false $properties $extra_properties
+    . "$ScriptRoot/common/build.sh" --restore --build --test --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=true $properties $extra_properties
 
 else
     . "$ScriptRoot/common/build.sh" --restore --build --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=false $properties $extra_properties
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index 4b8f3b07286..920e49b51e1 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -5,6 +5,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Engine.UnitTests.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -61,6 +62,8 @@ internal sealed class MockHost : MockLoggingService, IBuildComponentHost, IBuild
 
         private ISdkResolverService _sdkResolverService;
 
+        private IBuildCheckManagerProvider _buildCheckManagerProvider;
+
         #region SystemParameterFields
 
         #endregion;
@@ -126,6 +129,9 @@ public MockHost(BuildParameters buildParameters, ConfigCache overrideConfigCache
 
             _sdkResolverService = new MockSdkResolverService();
             ((IBuildComponent)_sdkResolverService).InitializeComponent(this);
+
+            _buildCheckManagerProvider = new NullBuildCheckManagerProvider();
+            ((IBuildComponent)_buildCheckManagerProvider).InitializeComponent(this);
         }
 
         /// <summary>
@@ -194,6 +200,7 @@ public IBuildComponent GetComponent(BuildComponentType type)
                 BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
                 BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
                 BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                BuildComponentType.BuildCheckManagerProvider => (IBuildComponent)_buildCheckManagerProvider,
                 _ => throw new ArgumentException("Unexpected type " + type),
             };
         }
diff --git a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
index 6266cb6e4c7..fae6fbcbeb6 100644
--- a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
+++ b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
@@ -28,10 +28,6 @@ public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)
     {
         _env = TestEnvironment.Create(output);
 
-        // Ignore environment variables that may have been set by the environment where the tests are running.
-        _env.SetEnvironmentVariable("MSBUILDLIVELOGGER", null);
-        _env.SetEnvironmentVariable("MSBUILDTERMINALLOGGER", null);
-
         TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);
         TransientTestFile projectFile = _env.CreateFile(logFolder, "myProj.proj", $"""
             <Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Hello">
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index 6e57337863d..f07bea4f265 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -19,6 +19,7 @@
 #endif
 [assembly: InternalsVisibleTo("Microsoft.Build.Framework.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+[assembly: InternalsVisibleTo("Microsoft.Build.BuildCheck.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.UnitTests.Shared, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 33fba22ca1e..25bcabbeed3 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -21,10 +21,13 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.BuildCheck.Logging;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Experimental;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
@@ -2952,7 +2955,12 @@ private void OnProjectStarted(object sender, ProjectStartedEventArgs e)
         /// <summary>
         /// Creates a logging service around the specified set of loggers.
         /// </summary>
-        private ILoggingService CreateLoggingService(IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> forwardingLoggers, ISet<string> warningsAsErrors, ISet<string> warningsNotAsErrors, ISet<string> warningsAsMessages)
+        private ILoggingService CreateLoggingService(
+            IEnumerable<ILogger> loggers,
+            IEnumerable<ForwardingLoggerRecord> forwardingLoggers,
+            ISet<string> warningsAsErrors,
+            ISet<string> warningsNotAsErrors,
+            ISet<string> warningsAsMessages)
         {
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
@@ -2976,6 +2984,18 @@ private ILoggingService CreateLoggingService(IEnumerable<ILogger> loggers, IEnum
             loggingService.WarningsNotAsErrors = warningsNotAsErrors;
             loggingService.WarningsAsMessages = warningsAsMessages;
 
+            if (_buildParameters.IsBuildCheckEnabled)
+            {
+                var buildCheckManagerProvider =
+                    ((IBuildComponentHost)this).GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider;
+                buildCheckManagerProvider!.Instance.SetDataSource(BuildCheckDataSource.EventArgs);
+
+                loggers = (loggers ?? Enumerable.Empty<ILogger>()).Concat(new[]
+                {
+                    new BuildCheckConnectorLogger(new AnalyzerLoggingContextFactory(loggingService), buildCheckManagerProvider.Instance)
+                });
+            }
+
             try
             {
                 if (loggers != null)
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 582532e5795..826fbadef56 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -10,6 +10,8 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
@@ -207,6 +209,8 @@ public class BuildParameters : ITranslatable
 
         private bool _question;
 
+        private bool _isBuildCheckEnabled;
+
         /// <summary>
         /// The settings used to load the project under build
         /// </summary>
@@ -309,6 +313,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             DiscardBuildResults = other.DiscardBuildResults;
             LowPriority = other.LowPriority;
             Question = other.Question;
+            IsBuildCheckEnabled = other.IsBuildCheckEnabled;
             ProjectCacheDescriptor = other.ProjectCacheDescriptor;
         }
 
@@ -834,6 +839,15 @@ public bool Question
             set => _question = value;
         }
 
+        /// <summary>
+        /// Gets or sets an indication of build analysis enablement.
+        /// </summary>
+        public bool IsBuildCheckEnabled
+        {
+            get => _isBuildCheckEnabled;
+            set => _isBuildCheckEnabled = value;
+        }
+
         /// <summary>
         /// Gets or sets the project cache description to use for all <see cref="BuildSubmission"/> or <see cref="GraphBuildSubmission"/>
         /// in addition to any potential project caches described in each project.
@@ -898,6 +912,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.TranslateEnum(ref _projectLoadSettings, (int)_projectLoadSettings);
             translator.Translate(ref _interactive);
             translator.Translate(ref _question);
+            translator.Translate(ref _isBuildCheckEnabled);
             translator.TranslateEnum(ref _projectIsolationMode, (int)_projectIsolationMode);
             translator.Translate(ref _reportFileAccesses);
 
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index 70a4bf0aeef..abcb6c22fb0 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -4,6 +4,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Components.Caching;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Shared;
 
@@ -76,6 +77,8 @@ public void RegisterDefaultFactories()
             // NodeEndpoint,
             _componentEntriesByType[BuildComponentType.LoggingService] = new BuildComponentEntry(BuildComponentType.LoggingService, null);
             _componentEntriesByType[BuildComponentType.RequestBuilder] = new BuildComponentEntry(BuildComponentType.RequestBuilder, RequestBuilder.CreateComponent, CreationPattern.CreateAlways);
+            // This conditionally registers real or no-op implementation based on BuildParameters
+            _componentEntriesByType[BuildComponentType.BuildCheckManagerProvider] = new BuildComponentEntry(BuildComponentType.BuildCheckManagerProvider, BuildCheckManagerProvider.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.TargetBuilder] = new BuildComponentEntry(BuildComponentType.TargetBuilder, TargetBuilder.CreateComponent, CreationPattern.CreateAlways);
             _componentEntriesByType[BuildComponentType.TaskBuilder] = new BuildComponentEntry(BuildComponentType.TaskBuilder, TaskBuilder.CreateComponent, CreationPattern.CreateAlways);
             _componentEntriesByType[BuildComponentType.RegisteredTaskObjectCache] = new BuildComponentEntry(BuildComponentType.RegisteredTaskObjectCache, RegisteredTaskObjectCache.CreateComponent, CreationPattern.Singleton);
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 297ac265e0e..7e72bd3a159 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -10,6 +10,7 @@
 using System.Threading;
 using System.Threading.Tasks.Dataflow;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -281,6 +282,9 @@ public void CleanupForBuild()
                         TraceEngine("CFB: Rethrowing shutdown exceptions");
                         throw new AggregateException(deactivateExceptions);
                     }
+
+                    var buildCheckManager = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance;
+                    buildCheckManager.FinalizeProcessing(_nodeLoggingContext);
                 },
                 isLastTask: true);
 
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index 5ae9d947906..8b2ded4d251 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -142,6 +142,11 @@ internal enum BuildComponentType
         /// The component which launches new MSBuild nodes.
         /// </summary>
         NodeLauncher,
+
+        /// <summary>
+        /// The Build Analyzer Manager.
+        /// </summary>
+        BuildCheckManagerProvider,
     }
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 340dfafc495..1a16e9f2190 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -98,6 +100,11 @@ internal sealed class EventSourceSink :
         /// This event is raised to log telemetry.
         /// </summary>
         public event TelemetryEventHandler TelemetryLogged;
+
+        /// <summary>
+        /// This event is raised to log BuildCheck events.
+        /// </summary>
+        internal event BuildCheckEventHandler BuildCheckEventRaised;
         #endregion
 
         #region Properties
@@ -263,6 +270,10 @@ public void Consume(BuildEventArgs buildEvent)
                 case TelemetryEventArgs telemetryEvent:
                     RaiseTelemetryEvent(null, telemetryEvent);
                     break;
+                case BuildCheckEventArgs buildCheckEvent:
+                    RaiseBuildCheckEvent(null, buildCheckEvent);
+                    break;
+
                 default:
                     ErrorUtilities.ThrowInternalError("Unknown event args type.");
                     break;
@@ -848,6 +859,40 @@ private void RaiseStatusEvent(object sender, BuildStatusEventArgs buildEvent)
             RaiseAnyEvent(sender, buildEvent);
         }
 
+        private void RaiseBuildCheckEvent(object sender, BuildCheckEventArgs buildEvent)
+        {
+            if (BuildCheckEventRaised != null)
+            {
+                try
+                {
+                    BuildCheckEventRaised(sender, buildEvent);
+                }
+                catch (LoggerException)
+                {
+                    // if a logger has failed politely, abort immediately
+                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
+                    // if a fellow logger is throwing in an event handler.
+                    this.UnregisterAllEventHandlers();
+                    throw;
+                }
+                catch (Exception exception)
+                {
+                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
+                    // if a fellow logger is throwing in an event handler.
+                    this.UnregisterAllEventHandlers();
+
+                    if (ExceptionHandling.IsCriticalException(exception))
+                    {
+                        throw;
+                    }
+
+                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
+                }
+            }
+
+            RaiseAnyEvent(sender, buildEvent);
+        }
+
         /// <summary>
         /// Raises a catch-all build event to all registered loggers.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 0214e3f4150..1a4693ba685 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -10,11 +10,13 @@
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -1102,6 +1104,11 @@ private async Task<BuildResult> BuildProject()
         {
             ErrorUtilities.VerifyThrow(_targetBuilder != null, "Target builder is null");
 
+            // We consider this the entrypoint for the project build for purposes of BuildCheck processing 
+
+            var buildCheckManager = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance;
+            buildCheckManager.SetDataSource(BuildCheckDataSource.BuildExecution);
+
             // Make sure it is null before loading the configuration into the request, because if there is a problem
             // we do not wand to have an invalid projectLoggingContext floating around. Also if this is null the error will be
             // logged with the node logging context
@@ -1114,6 +1121,11 @@ private async Task<BuildResult> BuildProject()
                 // Load the project
                 if (!_requestEntry.RequestConfiguration.IsLoaded)
                 {
+                    buildCheckManager.StartProjectEvaluation(
+                        BuildCheckDataSource.BuildExecution,
+                        _requestEntry.Request.ParentBuildEventContext,
+                        _requestEntry.RequestConfiguration.ProjectFullPath);
+
                     _requestEntry.RequestConfiguration.LoadProjectIntoConfiguration(
                         _componentHost,
                         RequestEntry.Request.BuildRequestDataFlags,
@@ -1132,62 +1144,90 @@ private async Task<BuildResult> BuildProject()
 
                 throw;
             }
+            finally
+            {
+                buildCheckManager.EndProjectEvaluation(
+                    BuildCheckDataSource.BuildExecution,
+                    _requestEntry.Request.ParentBuildEventContext);
+            }
 
             _projectLoggingContext = _nodeLoggingContext.LogProjectStarted(_requestEntry);
+            buildCheckManager.StartProjectRequest(
+                BuildCheckDataSource.BuildExecution,
+                _requestEntry.Request.ParentBuildEventContext);
 
-            // Now that the project has started, parse a few known properties which indicate warning codes to treat as errors or messages
-            //
-            ConfigureWarningsAsErrorsAndMessages();
+            try
+            {
+                // Now that the project has started, parse a few known properties which indicate warning codes to treat as errors or messages
+                ConfigureWarningsAsErrorsAndMessages();
 
-            // Make sure to extract known immutable folders from properties and register them for fast up-to-date check
-            ConfigureKnownImmutableFolders();
+                // Make sure to extract known immutable folders from properties and register them for fast up-to-date check
+                ConfigureKnownImmutableFolders();
 
-            // See comment on Microsoft.Build.Internal.Utilities.GenerateToolsVersionToUse
-            _requestEntry.RequestConfiguration.RetrieveFromCache();
-            if (_requestEntry.RequestConfiguration.Project.UsingDifferentToolsVersionFromProjectFile)
-            {
-                _projectLoggingContext.LogComment(MessageImportance.Low, "UsingDifferentToolsVersionFromProjectFile", _requestEntry.RequestConfiguration.Project.OriginalProjectToolsVersion, _requestEntry.RequestConfiguration.Project.ToolsVersion);
-            }
+                // See comment on Microsoft.Build.Internal.Utilities.GenerateToolsVersionToUse
+                _requestEntry.RequestConfiguration.RetrieveFromCache();
+                if (_requestEntry.RequestConfiguration.Project.UsingDifferentToolsVersionFromProjectFile)
+                {
+                    _projectLoggingContext.LogComment(MessageImportance.Low,
+                        "UsingDifferentToolsVersionFromProjectFile",
+                        _requestEntry.RequestConfiguration.Project.OriginalProjectToolsVersion,
+                        _requestEntry.RequestConfiguration.Project.ToolsVersion);
+                }
 
-            _requestEntry.Request.BuildEventContext = _projectLoggingContext.BuildEventContext;
+                _requestEntry.Request.BuildEventContext = _projectLoggingContext.BuildEventContext;
 
-            // Determine the set of targets we need to build
-            string[] allTargets = _requestEntry.RequestConfiguration.GetTargetsUsedToBuildRequest(_requestEntry.Request).ToArray();
+                // Determine the set of targets we need to build
+                string[] allTargets = _requestEntry.RequestConfiguration
+                    .GetTargetsUsedToBuildRequest(_requestEntry.Request).ToArray();
 
-            ProjectErrorUtilities.VerifyThrowInvalidProject(allTargets.Length > 0, _requestEntry.RequestConfiguration.Project.ProjectFileLocation, "NoTargetSpecified");
+                ProjectErrorUtilities.VerifyThrowInvalidProject(allTargets.Length > 0,
+                    _requestEntry.RequestConfiguration.Project.ProjectFileLocation, "NoTargetSpecified");
 
-            // Set the current directory to that required by the project.
-            SetProjectCurrentDirectory();
+                // Set the current directory to that required by the project.
+                SetProjectCurrentDirectory();
 
-            // Transfer results and state from the previous node, if necessary.
-            // In order for the check for target completeness for this project to be valid, all of the target results from the project must be present
-            // in the results cache.  It is possible that this project has been moved from its original node and when it was its results did not come
-            // with it.  This would be signified by the ResultsNode value in the configuration pointing to a different node than the current one.  In that
-            // case we will need to request those results be moved from their original node to this one.
-            if ((_requestEntry.RequestConfiguration.ResultsNodeId != Scheduler.InvalidNodeId) &&
-                (_requestEntry.RequestConfiguration.ResultsNodeId != _componentHost.BuildParameters.NodeId))
-            {
-                // This indicates to the system that we will block waiting for a results transfer.  We will block here until those results become available.
-                await BlockOnTargetInProgress(Microsoft.Build.BackEnd.BuildRequest.InvalidGlobalRequestId, null);
+                // Transfer results and state from the previous node, if necessary.
+                // In order for the check for target completeness for this project to be valid, all of the target results from the project must be present
+                // in the results cache.  It is possible that this project has been moved from its original node and when it was its results did not come
+                // with it.  This would be signified by the ResultsNode value in the configuration pointing to a different node than the current one.  In that
+                // case we will need to request those results be moved from their original node to this one.
+                if ((_requestEntry.RequestConfiguration.ResultsNodeId != Scheduler.InvalidNodeId) &&
+                    (_requestEntry.RequestConfiguration.ResultsNodeId != _componentHost.BuildParameters.NodeId))
+                {
+                    // This indicates to the system that we will block waiting for a results transfer.  We will block here until those results become available.
+                    await BlockOnTargetInProgress(Microsoft.Build.BackEnd.BuildRequest.InvalidGlobalRequestId, null);
+
+                    // All of the results should now be on this node.
+                    ErrorUtilities.VerifyThrow(
+                        _requestEntry.RequestConfiguration.ResultsNodeId == _componentHost.BuildParameters.NodeId,
+                        "Results for configuration {0} were not retrieved from node {1}",
+                        _requestEntry.RequestConfiguration.ConfigurationId,
+                        _requestEntry.RequestConfiguration.ResultsNodeId);
+                }
 
-                // All of the results should now be on this node.
-                ErrorUtilities.VerifyThrow(_requestEntry.RequestConfiguration.ResultsNodeId == _componentHost.BuildParameters.NodeId, "Results for configuration {0} were not retrieved from node {1}", _requestEntry.RequestConfiguration.ConfigurationId, _requestEntry.RequestConfiguration.ResultsNodeId);
-            }
+                // Build the targets
+                BuildResult result = await _targetBuilder.BuildTargets(_projectLoggingContext, _requestEntry, this,
+                    allTargets, _requestEntry.RequestConfiguration.BaseLookup, _cancellationTokenSource.Token);
 
-            // Build the targets
-            BuildResult result = await _targetBuilder.BuildTargets(_projectLoggingContext, _requestEntry, this, allTargets, _requestEntry.RequestConfiguration.BaseLookup, _cancellationTokenSource.Token);
+                result = _requestEntry.Request.ProxyTargets == null
+                    ? result
+                    : CopyTargetResultsFromProxyTargetsToRealTargets(result);
 
-            result = _requestEntry.Request.ProxyTargets == null
-                ? result
-                : CopyTargetResultsFromProxyTargetsToRealTargets(result);
+                if (MSBuildEventSource.Log.IsEnabled())
+                {
+                    MSBuildEventSource.Log.BuildProjectStop(_requestEntry.RequestConfiguration.ProjectFullPath,
+                        string.Join(", ", allTargets));
+                }
 
-            if (MSBuildEventSource.Log.IsEnabled())
+                return result;
+            }
+            finally
             {
-                MSBuildEventSource.Log.BuildProjectStop(_requestEntry.RequestConfiguration.ProjectFullPath, string.Join(", ", allTargets));
+                buildCheckManager.EndProjectRequest(
+                    BuildCheckDataSource.BuildExecution,
+                    _requestEntry.Request.ParentBuildEventContext);
             }
 
-            return result;
-
             BuildResult CopyTargetResultsFromProxyTargetsToRealTargets(BuildResult resultFromTargetBuilder)
             {
                 var proxyTargetMapping = _requestEntry.Request.ProxyTargets.ProxyTargetToRealTargetMap;
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index eda42874f86..27e1b307aab 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -475,6 +475,7 @@ internal void LoadProjectIntoConfiguration(
                 {
                     projectLoadSettings |= ProjectLoadSettings.FailOnUnresolvedSdk;
                 }
+
                 return new ProjectInstance(
                     ProjectFullPath,
                     globalProperties,
diff --git a/src/Build/BuildCheck/API/BuildAnalyzer.cs b/src/Build/BuildCheck/API/BuildAnalyzer.cs
new file mode 100644
index 00000000000..f249dc98cc5
--- /dev/null
+++ b/src/Build/BuildCheck/API/BuildAnalyzer.cs
@@ -0,0 +1,48 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using Microsoft.Build.BuildCheck.Infrastructure;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Base class for build analyzers.
+/// Same base will be used for custom and built-in analyzers.
+/// <see cref="BuildAnalyzer"/> is a unit of build analysis execution, but it can contain multiple rules - each representing a distinct violation.
+/// </summary>
+public abstract class BuildAnalyzer : IDisposable
+{
+    /// <summary>
+    /// Friendly name of the analyzer.
+    /// Should be unique - as it will be used in the tracing stats, infrastructure error messages, etc.
+    /// </summary>
+    public abstract string FriendlyName { get; }
+
+    /// <summary>
+    /// Single or multiple rules supported by the analyzer.
+    /// </summary>
+    public abstract IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; }
+
+    /// <summary>
+    /// Optional initialization of the analyzer.
+    /// </summary>
+    /// <param name="configurationContext">
+    /// Custom data (not recognized by the infrastructure) passed from .editorconfig
+    /// Currently the custom data has to be identical for all rules in the analyzer and all projects.
+    /// </param>
+    public abstract void Initialize(ConfigurationContext configurationContext);
+
+    /// <summary>
+    /// Used by the implementors to subscribe to data and events they are interested in.
+    /// </summary>
+    /// <param name="registrationContext">
+    /// The context that enables subscriptions for data pumping from the infrastructure.
+    /// </param>
+    public abstract void RegisterActions(IBuildCheckRegistrationContext registrationContext);
+
+    public virtual void Dispose()
+    { }
+}
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
new file mode 100644
index 00000000000..4940db20fd1
--- /dev/null
+++ b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
@@ -0,0 +1,45 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Configuration for a build analyzer.
+/// Default values can be specified by the Analyzer in code.
+/// Users can overwrite the defaults by explicit settings in the .editorconfig file.
+/// Each rule can have its own configuration, which can differ per each project.
+/// The <see cref="EvaluationAnalysisScope"/> setting must be same for all rules in the same analyzer (but can differ between projects)
+/// </summary>
+public class BuildAnalyzerConfiguration
+{
+    // Defaults to be used if any configuration property is not specified neither as default
+    //  nor in the editorconfig configuration file.
+    public static BuildAnalyzerConfiguration Default { get; } = new()
+    {
+        EvaluationAnalysisScope = BuildCheck.EvaluationAnalysisScope.ProjectOnly,
+        Severity = BuildAnalyzerResultSeverity.Info,
+        IsEnabled = false,
+    };
+
+    public static BuildAnalyzerConfiguration Null { get; } = new();
+
+    /// <summary>
+    /// This applies only to specific events, that can distinguish whether they are directly inferred from
+    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from analysis.
+    ///
+    /// If not supported by the data source - then the setting is ignored
+    /// </summary>
+    public EvaluationAnalysisScope? EvaluationAnalysisScope { get; internal init; }
+
+    /// <summary>
+    /// The severity of the result for the rule.
+    /// </summary>
+    public BuildAnalyzerResultSeverity? Severity { get; internal init; }
+
+    /// <summary>
+    /// Whether the analyzer rule is enabled.
+    /// If all rules within the analyzer are not enabled, it will not be run.
+    /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.
+    /// </summary>
+    public bool? IsEnabled { get; internal init; }
+}
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs b/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
new file mode 100644
index 00000000000..412a014be06
--- /dev/null
+++ b/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
@@ -0,0 +1,14 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// The severity of reported result (or preconfigured or user configured severity for a rule).
+/// </summary>
+public enum BuildAnalyzerResultSeverity
+{
+    Info,
+    Warning,
+    Error,
+}
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs b/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
new file mode 100644
index 00000000000..8b43dad4999
--- /dev/null
+++ b/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
@@ -0,0 +1,55 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Represents a rule that is a unit of build analysis.
+/// <see cref="BuildAnalyzer"/> is a unit of executing the analysis, but it can be discovering multiple distinct violation types,
+///  for this reason a single <see cref="BuildAnalyzer"/> can expose multiple <see cref="BuildAnalyzerRule"/>s.
+/// </summary>
+public class BuildAnalyzerRule
+{
+    public BuildAnalyzerRule(string id, string title, string description, string messageFormat,
+        BuildAnalyzerConfiguration defaultConfiguration)
+    {
+        Id = id;
+        Title = title;
+        Description = description;
+        MessageFormat = messageFormat;
+        DefaultConfiguration = defaultConfiguration;
+    }
+
+    /// <summary>
+    /// The identification of the rule.
+    ///
+    /// Some background on ids:
+    ///  * https://github.com/dotnet/roslyn-analyzers/blob/main/src/Utilities/Compiler/DiagnosticCategoryAndIdRanges.txt
+    ///  * https://github.com/dotnet/roslyn/issues/40351
+    ///
+    /// Quick suggestion now - let's force external ids to start with 'X', for ours - avoid 'MSB'
+    ///  maybe - BT - build static/styling; BA - build authoring; BE - build execution/environment; BC - build configuration
+    /// </summary>
+    public string Id { get; }
+
+    /// <summary>
+    /// The descriptive short summary of the rule.
+    /// </summary>
+    public string Title { get; }
+
+    /// <summary>
+    /// More detailed description of the violation the rule can be reporting (with possible suggestions).
+    /// </summary>
+    public string Description { get; }
+
+    /// <summary>
+    /// Message format that will be used by the actual reports (<see cref="BuildCheckResult"/>) - those will just supply the actual arguments.
+    /// </summary>
+    public string MessageFormat { get; }
+
+    /// <summary>
+    /// The default configuration - overridable by the user via .editorconfig.
+    /// If no user specified configuration is provided, this default will be used.
+    /// </summary>
+    public BuildAnalyzerConfiguration DefaultConfiguration { get; }
+}
diff --git a/src/Build/BuildCheck/API/BuildCheckResult.cs b/src/Build/BuildCheck/API/BuildCheckResult.cs
new file mode 100644
index 00000000000..03a69e02939
--- /dev/null
+++ b/src/Build/BuildCheck/API/BuildCheckResult.cs
@@ -0,0 +1,56 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Representation of a single report of a single finding from a BuildAnalyzer
+/// Each rule has upfront known message format - so only the concrete arguments are added
+/// Optionally a location is attached - in the near future we might need to support multiple locations
+///  (for 2 cases - a) grouped result for multiple occurrences; b) a single report for a finding resulting from combination of multiple locations)
+/// </summary>
+public sealed class BuildCheckResult : IBuildCheckResult
+{
+    public static BuildCheckResult Create(BuildAnalyzerRule rule, ElementLocation location, params string[] messageArgs)
+    {
+        return new BuildCheckResult(rule, location, messageArgs);
+    }
+
+    public BuildCheckResult(BuildAnalyzerRule buildAnalyzerRule, ElementLocation location, string[] messageArgs)
+    {
+        BuildAnalyzerRule = buildAnalyzerRule;
+        Location = location;
+        MessageArgs = messageArgs;
+    }
+
+    internal BuildEventArgs ToEventArgs(BuildAnalyzerResultSeverity severity)
+        => severity switch
+        {
+            BuildAnalyzerResultSeverity.Info => new BuildCheckResultMessage(this),
+            BuildAnalyzerResultSeverity.Warning => new BuildCheckResultWarning(this),
+            BuildAnalyzerResultSeverity.Error => new BuildCheckResultError(this),
+            _ => throw new ArgumentOutOfRangeException(nameof(severity), severity, null),
+        };
+
+    public BuildAnalyzerRule BuildAnalyzerRule { get; }
+
+    /// <summary>
+    /// Optional location of the finding (in near future we might need to support multiple locations).
+    /// </summary>
+    public ElementLocation Location { get; }
+
+    public string LocationString => Location.LocationString;
+
+    public string[] MessageArgs { get; }
+    public string MessageFormat => BuildAnalyzerRule.MessageFormat;
+
+    public string FormatMessage() =>
+        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}{BuildAnalyzerRule.Id}: {string.Format(BuildAnalyzerRule.MessageFormat, MessageArgs)}";
+
+    private string? _message;
+}
diff --git a/src/Build/BuildCheck/API/ConfigurationContext.cs b/src/Build/BuildCheck/API/ConfigurationContext.cs
new file mode 100644
index 00000000000..49dcdcfafec
--- /dev/null
+++ b/src/Build/BuildCheck/API/ConfigurationContext.cs
@@ -0,0 +1,40 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Microsoft.Build.BuildCheck.Infrastructure;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Holder of an optional configuration from .editorconfig file (not recognized by the infrastructure)
+/// </summary>
+public class ConfigurationContext
+{
+    private ConfigurationContext(CustomConfigurationData[] customConfigurationData)
+    {
+        CustomConfigurationData = customConfigurationData;
+    }
+
+    internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData)
+    {
+        if (!customConfigurationData.Any(BuildCheck.CustomConfigurationData.NotNull))
+        {
+            return Null;
+        }
+
+        return new ConfigurationContext(
+            customConfigurationData
+                .Where(BuildCheck.CustomConfigurationData.NotNull)
+                .ToArray());
+    }
+
+    internal static ConfigurationContext Null { get; } = new(Array.Empty<CustomConfigurationData>());
+
+    /// <summary>
+    /// Custom configuration data - per each rule that has some specified.
+    /// </summary>
+    public IReadOnlyList<CustomConfigurationData> CustomConfigurationData { get; init; }
+}
diff --git a/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs b/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs
new file mode 100644
index 00000000000..39781649359
--- /dev/null
+++ b/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs
@@ -0,0 +1,33 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// For datasource events that can differentiate from where exactly they originate - e.g.
+///  For a condition string or AST - was that directly in hte analyzed project or imported?
+///
+/// Ignored by infrastructure if the current datasource doesn't support this level of setting.
+/// </summary>
+public enum EvaluationAnalysisScope
+{
+    /// <summary>
+    /// Only the data from currently analyzed project will be sent to the analyzer. Imports will be discarded.
+    /// </summary>
+    ProjectOnly,
+
+    /// <summary>
+    /// Only the data from currently analyzed project and imports from files under the entry project or solution will be sent to the analyzer. Other imports will be discarded.
+    /// </summary>
+    ProjectWithImportsFromCurrentWorkTree,
+
+    /// <summary>
+    /// Imports from SDKs will not be sent to the analyzer. Other imports will be sent.
+    /// </summary>
+    ProjectWithImportsWithoutSdks,
+
+    /// <summary>
+    /// All data will be sent to the analyzer.
+    /// </summary>
+    ProjectWithAllImports,
+}
diff --git a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
new file mode 100644
index 00000000000..04cdf5aa87f
--- /dev/null
+++ b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
@@ -0,0 +1,12 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+public interface IBuildCheckRegistrationContext
+{
+    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction);
+    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction);
+}
diff --git a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs b/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
new file mode 100644
index 00000000000..f9c6fb6f75e
--- /dev/null
+++ b/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
@@ -0,0 +1,27 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Acquisition;
+
+// https://github.com/dotnet/msbuild/issues/9633
+// Acquisition
+//  define the data that will be passed to the acquisition module (and remoted if needed)
+internal class AnalyzerAcquisitionData(string data)
+{
+    public string Data { get; init; } = data;
+}
+
+internal static class AnalyzerAcquisitionDataExtensions
+{
+    public static AnalyzerAcquisitionData ToAnalyzerAcquisitionData(this BuildCheckAcquisitionEventArgs eventArgs) =>
+        new(eventArgs.AcquisitionData);
+
+    public static BuildCheckAcquisitionEventArgs ToBuildEventArgs(this AnalyzerAcquisitionData data) => new(data.Data);
+}
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
new file mode 100644
index 00000000000..e2ab0ff880c
--- /dev/null
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -0,0 +1,22 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BuildCheck.Analyzers;
+using Microsoft.Build.BuildCheck.Infrastructure;
+
+namespace Microsoft.Build.BuildCheck.Acquisition;
+
+internal class BuildCheckAcquisitionModule
+{
+    private static T Construct<T>() where T : new() => new();
+    public BuildAnalyzerFactory CreateBuildAnalyzerFactory(AnalyzerAcquisitionData analyzerAcquisitionData)
+    {
+        // Acquisition module - https://github.com/dotnet/msbuild/issues/9633
+        return Construct<SharedOutputPathAnalyzer>;
+    }
+}
diff --git a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs b/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
new file mode 100644
index 00000000000..174fb305b83
--- /dev/null
+++ b/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
@@ -0,0 +1,93 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Analyzers;
+
+internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
+{
+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0101", "ConflictingOutputPath",
+        "Two projects should not share their OutputPath nor IntermediateOutputPath locations",
+        "Projects {0} and {1} have conflicting output paths: {2}.",
+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+
+    public override string FriendlyName => "MSBuild.SharedOutputPathAnalyzer";
+
+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } =[SupportedRule];
+
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        /* This is it - no custom configuration */
+    }
+
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+    {
+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+    }
+
+    private readonly Dictionary<string, string> _projectsPerOutputPath = new(StringComparer.CurrentCultureIgnoreCase);
+    private readonly HashSet<string> _projects = new(StringComparer.CurrentCultureIgnoreCase);
+
+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    {
+        if (!_projects.Add(context.Data.ProjectFilePath))
+        {
+            return;
+        }
+
+        string? binPath, objPath;
+
+        context.Data.EvaluatedProperties.TryGetValue("OutputPath", out binPath);
+        context.Data.EvaluatedProperties.TryGetValue("IntermediateOutputPath", out objPath);
+
+        string? absoluteBinPath = CheckAndAddFullOutputPath(binPath, context);
+        if (
+            !string.IsNullOrEmpty(objPath) && !string.IsNullOrEmpty(absoluteBinPath) &&
+            !objPath.Equals(binPath, StringComparison.CurrentCultureIgnoreCase)
+            && !objPath.Equals(absoluteBinPath, StringComparison.CurrentCultureIgnoreCase)
+        )
+        {
+            CheckAndAddFullOutputPath(objPath, context);
+        }
+    }
+
+    private string? CheckAndAddFullOutputPath(string? path, BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    {
+        if (string.IsNullOrEmpty(path))
+        {
+            return path;
+        }
+
+        string projectPath = context.Data.ProjectFilePath;
+
+        if (!Path.IsPathRooted(path))
+        {
+            path = Path.Combine(Path.GetDirectoryName(projectPath)!, path);
+        }
+
+        if (_projectsPerOutputPath.TryGetValue(path!, out string? conflictingProject))
+        {
+            context.ReportResult(BuildCheckResult.Create(
+                SupportedRule,
+                // Populating precise location tracked via https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=58661732
+                ElementLocation.EmptyLocation,
+                Path.GetFileName(projectPath),
+                Path.GetFileName(conflictingProject),
+                path!));
+        }
+        else
+        {
+            _projectsPerOutputPath[path!] = projectPath;
+        }
+
+        return path;
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
new file mode 100644
index 00000000000..c2c36c813f9
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
@@ -0,0 +1,34 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+/// <summary>
+/// Counterpart type for BuildAnalyzerConfiguration - with all properties non-nullable
+/// </summary>
+internal sealed class BuildAnalyzerConfigurationInternal
+{
+    public BuildAnalyzerConfigurationInternal(string ruleId, EvaluationAnalysisScope evaluationAnalysisScope, BuildAnalyzerResultSeverity severity, bool isEnabled)
+    {
+        RuleId = ruleId;
+        EvaluationAnalysisScope = evaluationAnalysisScope;
+        Severity = severity;
+        IsEnabled = isEnabled;
+    }
+
+    public string RuleId { get; }
+    public EvaluationAnalysisScope EvaluationAnalysisScope { get; }
+    public BuildAnalyzerResultSeverity Severity { get; }
+    public bool IsEnabled { get; }
+
+    // Intentionally not checking the RuleId
+    //  as for analyzers with multiple rules, we can squash config to a single one,
+    //  if the ruleId is the only thing differing.
+    public bool IsSameConfigurationAs(BuildAnalyzerConfigurationInternal? other) =>
+        other != null &&
+        Severity == other.Severity &&
+        IsEnabled == other.IsEnabled &&
+        EvaluationAnalysisScope == other.EvaluationAnalysisScope;
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
new file mode 100644
index 00000000000..06e0aaa2439
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
@@ -0,0 +1,75 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+/// <summary>
+/// A wrapping, enriching class for BuildAnalyzer - so that we have additional data and functionality.
+/// </summary>
+internal sealed class BuildAnalyzerWrapper
+{
+    private readonly Stopwatch _stopwatch = new Stopwatch();
+
+    public BuildAnalyzerWrapper(BuildAnalyzer buildAnalyzer)
+    {
+        BuildAnalyzer = buildAnalyzer;
+    }
+
+    internal BuildAnalyzer BuildAnalyzer { get; }
+    private bool _isInitialized = false;
+
+    // Let's optimize for the scenario where users have a single .editorconfig file that applies to the whole solution.
+    // In such case - configuration will be same for all projects. So we do not need to store it per project in a collection.
+    internal BuildAnalyzerConfigurationInternal? CommonConfig { get; private set; }
+
+    // start new project
+    internal void StartNewProject(
+        string fullProjectPath,
+        IReadOnlyList<BuildAnalyzerConfigurationInternal> userConfigs)
+    {
+        if (!_isInitialized)
+        {
+            _isInitialized = true;
+            CommonConfig = userConfigs[0];
+
+            if (userConfigs.Count == 1)
+            {
+                return;
+            }
+        }
+
+        // The Common configuration is not common anymore - let's nullify it and we will need to fetch configuration per project.
+        if (CommonConfig == null || !userConfigs.All(t => t.IsSameConfigurationAs(CommonConfig)))
+        {
+            CommonConfig = null;
+        }
+    }
+
+    // to be used on eval node (BuildCheckDataSource.BuildExecution)
+    internal void Uninitialize()
+    {
+        _isInitialized = false;
+    }
+
+    internal TimeSpan Elapsed => _stopwatch.Elapsed;
+
+    internal void ClearStats() => _stopwatch.Reset();
+
+    internal CleanupScope StartSpan()
+    {
+        _stopwatch.Start();
+        return new CleanupScope(_stopwatch.Stop);
+    }
+
+    internal readonly struct CleanupScope(Action disposeAction) : IDisposable
+    {
+        public void Dispose() => disposeAction();
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
new file mode 100644
index 00000000000..9995aef71b3
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -0,0 +1,137 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+/// <summary>
+/// A manager of the runs of the analyzers - deciding based on configuration of what to run and what to postfilter.
+/// </summary>
+internal sealed class BuildCheckCentralContext
+{
+    private record CallbackRegistry(
+        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>>)> EvaluatedPropertiesActions,
+        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ParsedItemsAnalysisData>>)> ParsedItemsActions)
+    {
+        public CallbackRegistry() : this([],[]) { }
+    }
+
+    // In a future we can have callbacks per project as well
+    private readonly CallbackRegistry _globalCallbacks = new();
+
+    // This we can potentially use to subscribe for receiving evaluated props in the
+    //  build event args. However - this needs to be done early on, when analyzers might not be known yet
+    internal bool HasEvaluatedPropertiesActions => _globalCallbacks.EvaluatedPropertiesActions.Any();
+    internal bool HasParsedItemsActions => _globalCallbacks.ParsedItemsActions.Any();
+
+    internal void RegisterEvaluatedPropertiesAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
+        // Here we might want to communicate to node that props need to be sent.
+        //  (it was being communicated via MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION)
+        => RegisterAction(analyzer, evaluatedPropertiesAction, _globalCallbacks.EvaluatedPropertiesActions);
+
+    internal void RegisterParsedItemsAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
+        => RegisterAction(analyzer, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
+
+    private void RegisterAction<T>(
+        BuildAnalyzerWrapper wrappedAnalyzer,
+        Action<BuildCheckDataContext<T>> handler,
+        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> handlersRegistry)
+        where T : AnalysisData
+    {
+        void WrappedHandler(BuildCheckDataContext<T> context)
+        {
+            using var _ = wrappedAnalyzer.StartSpan();
+            handler(context);
+        }
+
+        lock (handlersRegistry)
+        {
+            handlersRegistry.Add((wrappedAnalyzer, WrappedHandler));
+        }
+    }
+
+    internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
+    {
+        _globalCallbacks.EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == analyzer);
+        _globalCallbacks.ParsedItemsActions.RemoveAll(a => a.Item1 == analyzer);
+    }
+
+    internal void RunEvaluatedPropertiesActions(
+        EvaluatedPropertiesAnalysisData evaluatedPropertiesAnalysisData,
+        LoggingContext loggingContext,
+        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult>
+            resultHandler)
+        => RunRegisteredActions(_globalCallbacks.EvaluatedPropertiesActions, evaluatedPropertiesAnalysisData,
+            loggingContext, resultHandler);
+
+    internal void RunParsedItemsActions(
+        ParsedItemsAnalysisData parsedItemsAnalysisData,
+        LoggingContext loggingContext,
+        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult>
+            resultHandler)
+        => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsAnalysisData,
+            loggingContext, resultHandler);
+
+    private void RunRegisteredActions<T>(
+        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
+        T analysisData,
+        LoggingContext loggingContext,
+        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult> resultHandler)
+    where T : AnalysisData
+    {
+        string projectFullPath = analysisData.ProjectFilePath;
+
+        // Alternatively we might want to actually do this all in serial, but asynchronously (blocking queue)
+        Parallel.ForEach(
+            registeredCallbacks,
+            new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount },
+            /* (BuildAnalyzerWrapper2, Action<BuildAnalysisContext<T>>) */
+            analyzerCallback =>
+            {
+                // Tracing - https://github.com/dotnet/msbuild/issues/9629 - we might want to account this entire block
+                //  to the relevant analyzer (with only the currently accounted part as being the 'core-execution' subspan)
+
+                BuildAnalyzerConfigurationInternal? commonConfig = analyzerCallback.Item1.CommonConfig;
+                BuildAnalyzerConfigurationInternal[] configPerRule;
+
+                if (commonConfig != null)
+                {
+                    if (!commonConfig.IsEnabled)
+                    {
+                        return;
+                    }
+
+                    configPerRule = new[] { commonConfig };
+                }
+                else
+                {
+                    configPerRule =
+                        ConfigurationProvider.GetMergedConfigurations(projectFullPath,
+                            analyzerCallback.Item1.BuildAnalyzer);
+                    if (configPerRule.All(c => !c.IsEnabled))
+                    {
+                        return;
+                    }
+                }
+
+                // Here we might want to check the configPerRule[0].EvaluationAnalysisScope - if the input data supports that
+                // The decision and implementation depends on the outcome of the investigation tracked in:
+                // https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57851137
+
+                BuildCheckDataContext<T> context = new BuildCheckDataContext<T>(
+                    analyzerCallback.Item1,
+                    loggingContext,
+                    configPerRule,
+                    resultHandler,
+                    analysisData);
+
+                analyzerCallback.Item2(context);
+            });
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
new file mode 100644
index 00000000000..29a0a8acf50
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
@@ -0,0 +1,21 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal sealed class BuildCheckConfigurationException : Exception
+{
+    /// <summary>
+    /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.
+    /// This exception usually leads to defuncting the particular analyzer for the rest of the build (even if issue occured with a single project).
+    /// </summary>
+    public BuildCheckConfigurationException(string message) : base(message)
+    {
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
new file mode 100644
index 00000000000..9be71d2a288
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -0,0 +1,93 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+internal sealed class BuildCheckConnectorLogger(IBuildAnalysisLoggingContextFactory loggingContextFactory, IBuildCheckManager buildCheckManager)
+    : ILogger
+{
+    public LoggerVerbosity Verbosity { get; set; }
+    public string? Parameters { get; set; }
+
+    public void Initialize(IEventSource eventSource)
+    {
+        eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+        eventSource.BuildFinished += EventSource_BuildFinished;
+    }
+
+    private void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
+    {
+        if (e is ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs)
+        {
+            if (projectEvaluationFinishedEventArgs.ProjectFile?.EndsWith(".metaproj") ?? false)
+            {
+                return;
+            }
+
+            buildCheckManager.ProcessEvaluationFinishedEventArgs(
+                loggingContextFactory.CreateLoggingContext(e.BuildEventContext!),
+                projectEvaluationFinishedEventArgs);
+
+            buildCheckManager.EndProjectEvaluation(BuildCheckDataSource.EventArgs, e.BuildEventContext!);
+        }
+        else if (e is ProjectEvaluationStartedEventArgs projectEvaluationStartedEventArgs)
+        {
+            // Skip autogenerated transient projects (as those are not user projects to be analyzed)
+            if (projectEvaluationStartedEventArgs.ProjectFile?.EndsWith(".metaproj") ?? false)
+            {
+                return;
+            }
+
+            buildCheckManager.StartProjectEvaluation(BuildCheckDataSource.EventArgs, e.BuildEventContext!,
+                projectEvaluationStartedEventArgs.ProjectFile!);
+        }
+        else if (e is ProjectStartedEventArgs projectStartedEvent)
+        {
+            buildCheckManager.StartProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!);
+        }
+        else if (e is ProjectFinishedEventArgs projectFinishedEventArgs)
+        {
+            buildCheckManager.EndProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!);
+        }
+        else if (e is BuildCheckEventArgs buildCheckBuildEventArgs)
+        {
+            if (buildCheckBuildEventArgs is BuildCheckTracingEventArgs tracingEventArgs)
+            {
+                _stats.Merge(tracingEventArgs.TracingData, (span1, span2) => span1 + span2);
+            }
+            else if (buildCheckBuildEventArgs is BuildCheckAcquisitionEventArgs acquisitionEventArgs)
+            {
+                buildCheckManager.ProcessAnalyzerAcquisition(acquisitionEventArgs.ToAnalyzerAcquisitionData());
+            }
+        }
+    }
+
+    private readonly Dictionary<string, TimeSpan> _stats = new Dictionary<string, TimeSpan>();
+
+    private void EventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
+    {
+        _stats.Merge(buildCheckManager.CreateTracingStats(), (span1, span2) => span1 + span2);
+        string msg = string.Join(Environment.NewLine, _stats.Select(a => a.Key + ": " + a.Value));
+
+        BuildEventContext buildEventContext = e.BuildEventContext ?? new BuildEventContext(
+            BuildEventContext.InvalidNodeId, BuildEventContext.InvalidTargetId,
+            BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
+
+        LoggingContext loggingContext = loggingContextFactory.CreateLoggingContext(buildEventContext);
+
+        // Tracing: https://github.com/dotnet/msbuild/issues/9629
+        loggingContext.LogCommentFromText(MessageImportance.High, msg);
+    }
+
+    public void Shutdown()
+    { }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
new file mode 100644
index 00000000000..19a4e3d6967
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
@@ -0,0 +1,21 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Threading;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal sealed class BuildCheckRegistrationContext(BuildAnalyzerWrapper analyzerWrapper, BuildCheckCentralContext buildCheckCentralContext) : IBuildCheckRegistrationContext
+{
+    public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
+    {
+        buildCheckCentralContext.RegisterEvaluatedPropertiesAction(analyzerWrapper, evaluatedPropertiesAction);
+    }
+
+    public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
+    {
+        buildCheckCentralContext.RegisterParsedItemsAction(analyzerWrapper, parsedItemsAction);
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
new file mode 100644
index 00000000000..2cc02231114
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -0,0 +1,382 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Diagnostics;
+using System.Diagnostics.Tracing;
+using System.IO;
+using System.Linq;
+using System.Runtime.ConstrainedExecution;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Components.Caching;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.BuildCheck.Analyzers;
+using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal delegate BuildAnalyzer BuildAnalyzerFactory();
+internal delegate BuildAnalyzerWrapper BuildAnalyzerWrapperFactory(ConfigurationContext configurationContext);
+
+/// <summary>
+/// The central manager for the BuildCheck - this is the integration point with MSBuild infrastructure.
+/// </summary>
+internal sealed class BuildCheckManagerProvider : IBuildCheckManagerProvider
+{
+    private static IBuildCheckManager? s_globalInstance;
+    internal static IBuildCheckManager GlobalInstance => s_globalInstance ?? throw new InvalidOperationException("BuildCheckManagerProvider not initialized");
+
+    public IBuildCheckManager Instance => GlobalInstance;
+
+    internal static IBuildComponent CreateComponent(BuildComponentType type)
+    {
+        ErrorUtilities.VerifyThrow(type == BuildComponentType.BuildCheckManagerProvider, "Cannot create components of type {0}", type);
+        return new BuildCheckManagerProvider();
+    }
+
+    public void InitializeComponent(IBuildComponentHost host)
+    {
+        ErrorUtilities.VerifyThrow(host != null, "BuildComponentHost was null");
+
+        if (s_globalInstance == null)
+        {
+            IBuildCheckManager instance;
+            if (host!.BuildParameters.IsBuildCheckEnabled)
+            {
+                instance = new BuildCheckManager(host.LoggingService);
+            }
+            else
+            {
+                instance = new NullBuildCheckManager();
+            }
+
+            // We are fine with the possibility of double creation here - as the construction is cheap
+            //  and without side effects and the actual backing field is effectively immutable after the first assignment.
+            Interlocked.CompareExchange(ref s_globalInstance, instance, null);
+        }
+    }
+
+    public void ShutdownComponent() => GlobalInstance.Shutdown();
+
+
+    private sealed class BuildCheckManager : IBuildCheckManager
+    {
+        private readonly TracingReporter _tracingReporter = new TracingReporter();
+        private readonly BuildCheckCentralContext _buildCheckCentralContext = new();
+        private readonly ILoggingService _loggingService;
+        private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry =[];
+        private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
+        private readonly BuildEventsProcessor _buildEventsProcessor;
+        private readonly BuildCheckAcquisitionModule _acquisitionModule = new();
+
+        private bool IsInProcNode => _enabledDataSources[(int)BuildCheckDataSource.EventArgs] &&
+                                     _enabledDataSources[(int)BuildCheckDataSource.BuildExecution];
+
+        /// <summary>
+        /// Notifies the manager that the data source will be used -
+        ///   so it should register the built-in analyzers for the source if it hasn't been done yet.
+        /// </summary>
+        /// <param name="buildCheckDataSource"></param>
+        public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
+        {
+            if (!_enabledDataSources[(int)buildCheckDataSource])
+            {
+                _enabledDataSources[(int)buildCheckDataSource] = true;
+                RegisterBuiltInAnalyzers(buildCheckDataSource);
+            }
+        }
+
+        public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData)
+        {
+            if (IsInProcNode)
+            {
+                var factory = _acquisitionModule.CreateBuildAnalyzerFactory(acquisitionData);
+                RegisterCustomAnalyzer(BuildCheckDataSource.EventArgs, factory);
+            }
+            else
+            {
+                BuildCheckAcquisitionEventArgs eventArgs = acquisitionData.ToBuildEventArgs();
+
+                // We may want to pass the real context here (from evaluation)
+                eventArgs.BuildEventContext = new BuildEventContext(
+                    BuildEventContext.InvalidNodeId,
+                    BuildEventContext.InvalidProjectInstanceId,
+                    BuildEventContext.InvalidProjectContextId,
+                    BuildEventContext.InvalidTargetId,
+                    BuildEventContext.InvalidTaskId);
+
+                _loggingService.LogBuildEvent(eventArgs);
+            }
+        }
+
+        internal BuildCheckManager(ILoggingService loggingService)
+        {
+            _loggingService = loggingService;
+            _buildEventsProcessor = new(_buildCheckCentralContext);
+        }
+
+        private static T Construct<T>() where T : new() => new();
+        private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][] s_builtInFactoriesPerDataSource =
+        [
+            // BuildCheckDataSource.EventArgs
+            [
+                ([SharedOutputPathAnalyzer.SupportedRule.Id], SharedOutputPathAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathAnalyzer>)
+            ],
+            // BuildCheckDataSource.Execution
+            []
+        ];
+
+        private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
+        {
+            _analyzersRegistry.AddRange(
+                s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
+                    .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+        }
+
+        /// <summary>
+        /// To be used by acquisition module
+        /// Registeres the custom analyzer, the construction of analyzer is deferred until the first using project is encountered
+        /// </summary>
+        internal void RegisterCustomAnalyzer(
+            BuildCheckDataSource buildCheckDataSource,
+            BuildAnalyzerFactory factory,
+            string[] ruleIds,
+            bool defaultEnablement)
+        {
+            if (_enabledDataSources[(int)buildCheckDataSource])
+            {
+                _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(factory, ruleIds, defaultEnablement));
+            }
+        }
+
+        /// <summary>
+        /// To be used by acquisition module
+        /// Registeres the custom analyzer, the construction of analyzer is needed during registration
+        /// </summary>
+        internal void RegisterCustomAnalyzer(
+            BuildCheckDataSource buildCheckDataSource,
+            BuildAnalyzerFactory factory)
+        {
+            if (_enabledDataSources[(int)buildCheckDataSource])
+            {
+                var instance = factory();
+                _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(factory,
+                    instance.SupportedRules.Select(r => r.Id).ToArray(),
+                    instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
+            }
+        }
+
+        private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryContext, string projectFullPath, BuildEventContext buildEventContext)
+        {
+            // For custom analyzers - it should run only on projects where referenced
+            //  (otherwise error out - https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57849480)
+            //  on others it should work similarly as disabling them.
+            // Disabled analyzer should not only post-filter results - it shouldn't even see the data 
+
+            BuildAnalyzerWrapper wrapper;
+            BuildAnalyzerConfigurationInternal[] configurations;
+            if (analyzerFactoryContext.MaterializedAnalyzer == null)
+            {
+                BuildAnalyzerConfiguration[] userConfigs =
+                    ConfigurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+
+                if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
+                {
+                    // the analyzer was not yet instantiated nor mounted - so nothing to do here now.
+                    return;
+                }
+
+                CustomConfigurationData[] customConfigData =
+                    ConfigurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+
+                ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData);
+
+                wrapper = analyzerFactoryContext.Factory(configurationContext);
+                analyzerFactoryContext.MaterializedAnalyzer = wrapper;
+                BuildAnalyzer analyzer = wrapper.BuildAnalyzer;
+
+                // This is to facilitate possible perf improvement for custom analyzers - as we might want to
+                //  avoid loading the assembly and type just to check if it's supported.
+                // If we expose a way to declare the enablement status and rule ids during registration (e.g. via
+                //  optional arguments of the intrinsic property function) - we can then avoid loading it.
+                // But once loaded - we should verify that the declared enablement status and rule ids match the actual ones.
+                if (
+                    analyzer.SupportedRules.Count != analyzerFactoryContext.RuleIds.Length
+                    ||
+                    !analyzer.SupportedRules.Select(r => r.Id)
+                        .SequenceEqual(analyzerFactoryContext.RuleIds, StringComparer.CurrentCultureIgnoreCase)
+                )
+                {
+                    throw new BuildCheckConfigurationException(
+                        $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
+                }
+
+                configurations = ConfigurationProvider.GetMergedConfigurations(userConfigs, analyzer);
+
+                // technically all analyzers rules could be disabled, but that would mean
+                // that the provided 'IsEnabledByDefault' value wasn't correct - the only
+                // price to be paid in that case is slight performance cost.
+
+                // Create the wrapper and register to central context
+                wrapper.StartNewProject(projectFullPath, configurations);
+                var wrappedContext = new BuildCheckRegistrationContext(wrapper, _buildCheckCentralContext);
+                analyzer.RegisterActions(wrappedContext);
+            }
+            else
+            {
+                wrapper = analyzerFactoryContext.MaterializedAnalyzer;
+
+                configurations = ConfigurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
+
+                ConfigurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
+                    analyzerFactoryContext.RuleIds[0]);
+
+                // Update the wrapper
+                wrapper.StartNewProject(projectFullPath, configurations);
+            }
+
+            if (configurations.GroupBy(c => c.EvaluationAnalysisScope).Count() > 1)
+            {
+                throw new BuildCheckConfigurationException(
+                    string.Format("All rules for a single analyzer should have the same EvaluationAnalysisScope for a single project (violating rules: [{0}], project: {1})",
+                        analyzerFactoryContext.RuleIds.ToCsvString(),
+                        projectFullPath));
+            }
+        }
+
+        private void SetupAnalyzersForNewProject(string projectFullPath, BuildEventContext buildEventContext)
+        {
+            // Only add analyzers here
+            // On an execution node - we might remove and dispose the analyzers once project is done
+
+            // If it's already constructed - just control the custom settings do not differ
+
+            List<BuildAnalyzerFactoryContext> analyzersToRemove = new();
+            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            {
+                try
+                {
+                    SetupSingleAnalyzer(analyzerFactoryContext, projectFullPath, buildEventContext);
+                }
+                catch (BuildCheckConfigurationException e)
+                {
+                    _loggingService.LogErrorFromText(buildEventContext, null, null, null,
+                        new BuildEventFileInfo(projectFullPath),
+                        e.Message);
+                    analyzersToRemove.Add(analyzerFactoryContext);
+                }
+            }
+
+            analyzersToRemove.ForEach(c =>
+            {
+                _analyzersRegistry.Remove(c);
+                _loggingService.LogCommentFromText(buildEventContext, MessageImportance.High, $"Dismounting analyzer '{c.FriendlyName}'");
+            });
+            foreach (var analyzerToRemove in analyzersToRemove.Select(a => a.MaterializedAnalyzer).Where(a => a != null))
+            {
+                _buildCheckCentralContext.DeregisterAnalyzer(analyzerToRemove!);
+                _tracingReporter.AddStats(analyzerToRemove!.BuildAnalyzer.FriendlyName, analyzerToRemove.Elapsed);
+                analyzerToRemove.BuildAnalyzer.Dispose();
+            }
+        }
+
+
+        public void ProcessEvaluationFinishedEventArgs(
+            AnalyzerLoggingContext buildAnalysisContext,
+            ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
+            => _buildEventsProcessor
+                .ProcessEvaluationFinishedEventArgs(buildAnalysisContext, evaluationFinishedEventArgs);
+
+        // Tracing: https://github.com/dotnet/msbuild/issues/9629
+        public Dictionary<string, TimeSpan> CreateTracingStats()
+        {
+            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            {
+                if (analyzerFactoryContext.MaterializedAnalyzer != null)
+                {
+                    _tracingReporter.AddStats(analyzerFactoryContext.FriendlyName,
+                        analyzerFactoryContext.MaterializedAnalyzer.Elapsed);
+                    analyzerFactoryContext.MaterializedAnalyzer.ClearStats();
+                }
+            }
+
+            return _tracingReporter.TracingStats;
+        }
+
+        public void FinalizeProcessing(LoggingContext loggingContext)
+        {
+            if (IsInProcNode)
+            {
+                // We do not want to send tracing stats from in-proc node
+                return;
+            }
+
+            BuildCheckTracingEventArgs eventArgs =
+                new(CreateTracingStats()) { BuildEventContext = loggingContext.BuildEventContext };
+            loggingContext.LogBuildEvent(eventArgs);
+        }
+
+        public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext,
+            string fullPath)
+        {
+            if (buildCheckDataSource == BuildCheckDataSource.EventArgs && IsInProcNode)
+            {
+                // Skipping this event - as it was already handled by the in-proc node.
+                // This is because in-proc node has the BuildEventArgs source and BuildExecution source
+                //  both in a single manager. The project started is first encountered by the execution before the EventArg is sent
+                return;
+            }
+
+            SetupAnalyzersForNewProject(fullPath, buildEventContext);
+        }
+
+        /*
+         *
+         * Following methods are for future use (should we decide to approach in-execution analysis)
+         *
+         */
+
+
+        public void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        {
+        }
+
+        public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        {
+        }
+
+        public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        {
+        }
+
+        public void Shutdown()
+        { /* Too late here for any communication to the main node or for logging anything */ }
+
+        private class BuildAnalyzerFactoryContext(
+            BuildAnalyzerFactory factory,
+            string[] ruleIds,
+            bool isEnabledByDefault)
+        {
+            public BuildAnalyzerWrapperFactory Factory { get; init; } = configContext =>
+            {
+                BuildAnalyzer ba = factory();
+                ba.Initialize(configContext);
+                return new BuildAnalyzerWrapper(ba);
+            };
+            public BuildAnalyzerWrapper? MaterializedAnalyzer { get; set; }
+            public string[] RuleIds { get; init; } = ruleIds;
+            public bool IsEnabledByDefault { get; init; } = isEnabledByDefault;
+            public string FriendlyName => MaterializedAnalyzer?.BuildAnalyzer.FriendlyName ?? factory().FriendlyName;
+        }
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
new file mode 100644
index 00000000000..9514f0a7ca0
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -0,0 +1,86 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Diagnostics;
+using System.Diagnostics.Tracing;
+using System.IO;
+using System.Linq;
+using System.Runtime.ConstrainedExecution;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Components.Caching;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Analyzers;
+using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal class BuildEventsProcessor(BuildCheckCentralContext buildCheckCentralContext)
+{
+    private readonly SimpleProjectRootElementCache _cache = new SimpleProjectRootElementCache();
+    private readonly BuildCheckCentralContext _buildCheckCentralContext = buildCheckCentralContext;
+
+    // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
+    internal void ProcessEvaluationFinishedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
+    {
+        Dictionary<string, string> propertiesLookup = new Dictionary<string, string>();
+        Internal.Utilities.EnumerateProperties(evaluationFinishedEventArgs.Properties, propertiesLookup,
+            static (dict, kvp) => dict.Add(kvp.Key, kvp.Value));
+
+        EvaluatedPropertiesAnalysisData analysisData =
+            new(evaluationFinishedEventArgs.ProjectFile!, propertiesLookup);
+
+        _buildCheckCentralContext.RunEvaluatedPropertiesActions(analysisData, buildAnalysisContext, ReportResult);
+
+        if (_buildCheckCentralContext.HasParsedItemsActions)
+        {
+            ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(
+                evaluationFinishedEventArgs.ProjectFile!, /*unused*/
+                null, /*unused*/null, _cache, false /*Not explicitly loaded - unused*/);
+
+            ParsedItemsAnalysisData itemsAnalysisData = new(evaluationFinishedEventArgs.ProjectFile!,
+                new ItemsHolder(xml.Items, xml.ItemGroups));
+
+            _buildCheckCentralContext.RunParsedItemsActions(itemsAnalysisData, buildAnalysisContext, ReportResult);
+        }
+    }
+
+    private static void ReportResult(
+        BuildAnalyzerWrapper analyzerWrapper,
+        LoggingContext loggingContext,
+        BuildAnalyzerConfigurationInternal[] configPerRule,
+        BuildCheckResult result)
+    {
+        if (!analyzerWrapper.BuildAnalyzer.SupportedRules.Contains(result.BuildAnalyzerRule))
+        {
+            loggingContext.LogErrorFromText(null, null, null,
+                BuildEventFileInfo.Empty,
+                $"The analyzer '{analyzerWrapper.BuildAnalyzer.FriendlyName}' reported a result for a rule '{result.BuildAnalyzerRule.Id}' that it does not support.");
+            return;
+        }
+
+        BuildAnalyzerConfigurationInternal config = configPerRule.Length == 1
+            ? configPerRule[0]
+            : configPerRule.First(r =>
+                r.RuleId.Equals(result.BuildAnalyzerRule.Id, StringComparison.CurrentCultureIgnoreCase));
+
+        if (!config.IsEnabled)
+        {
+            return;
+        }
+
+        BuildEventArgs eventArgs = result.ToEventArgs(config.Severity);
+        eventArgs.BuildEventContext = loggingContext.BuildEventContext;
+        loggingContext.LogBuildEvent(eventArgs);
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
new file mode 100644
index 00000000000..67c2155500e
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -0,0 +1,206 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.Json.Serialization;
+using System.Text.Json;
+using Microsoft.Build.Experimental.BuildCheck;
+using System.Configuration;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+
+// Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)
+// Tracked via: https://github.com/dotnet/msbuild/issues/9828
+internal static class ConfigurationProvider
+{
+    // We might want to have a mechanism for removing unneeded configurations
+    //  (disabled rules and analyzers that need to run in different node)
+    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();
+
+    // This is just a testing implementation for quicker unblock of testing.
+    // Real implementation will use .editorconfig file.
+    // Sample json:
+    /////*lang=json,strict*/
+    ////"""
+    ////    {
+    ////        "ABC123": {
+    ////            "IsEnabled": true,
+    ////            "Severity": "Info"
+    ////        },
+    ////        "COND0543": {
+    ////            "IsEnabled": false,
+    ////            "Severity": "Error",
+    ////    		"EvaluationAnalysisScope": "AnalyzedProjectOnly",
+    ////    		"CustomSwitch": "QWERTY"
+    ////        },
+    ////        "BLA": {
+    ////            "IsEnabled": false
+    ////        }
+    ////    }
+    ////    """
+    //
+    // Plus there will need to be a mechanism of distinguishing different configs in different folders
+    //  - e.g. - what to do if we analyze two projects (not sharing output path) and they have different .editorconfig files?
+    private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration()
+    {
+        const string configFileName = "editorconfig.json";
+        string configPath = configFileName;
+
+        if (!File.Exists(configPath))
+        {
+            // This is just a dummy implementation for testing purposes
+            var dir = Environment.CurrentDirectory;
+            configPath = Path.Combine(dir, configFileName);
+
+            if (!File.Exists(configPath))
+            {
+                return new Dictionary<string, BuildAnalyzerConfiguration>();
+            }
+        }
+
+        var json = File.ReadAllText(configPath);
+        var DeserializationOptions = new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() } };
+        return JsonSerializer.Deserialize<Dictionary<string, BuildAnalyzerConfiguration>>(json, DeserializationOptions) ??
+               new Dictionary<string, BuildAnalyzerConfiguration>();
+    }
+
+    /// <summary>
+    /// Gets the user specified unrecognized configuration for the given analyzer rule.
+    /// 
+    /// The configuration module should as well check that CustomConfigurationData
+    ///  for a particular rule is equal across the whole build (for all projects)  - otherwise it should error out.
+    /// This should apply to all rules for which the configuration is fetched.
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <param name="ruleId"></param>
+    /// <returns></returns>
+    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)
+    {
+        return CustomConfigurationData.Null;
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <param name="ruleId"></param>
+    /// <throws><see cref="BuildCheckConfigurationException"/> If CustomConfigurationData differs in a build for a same ruleId</throws>
+    /// <returns></returns>
+    public static void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
+    {
+        // TBD
+    }
+
+    public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+        string projectFullPath,
+        BuildAnalyzer analyzer)
+        => FillConfiguration(projectFullPath, analyzer.SupportedRules, GetMergedConfiguration);
+
+    public static BuildAnalyzerConfiguration[] GetUserConfigurations(
+        string projectFullPath,
+        IReadOnlyList<string> ruleIds)
+        => FillConfiguration(projectFullPath, ruleIds, GetUserConfiguration);
+
+    public static CustomConfigurationData[] GetCustomConfigurations(
+        string projectFullPath,
+        IReadOnlyList<string> ruleIds)
+        => FillConfiguration(projectFullPath, ruleIds, GetCustomConfiguration);
+
+    public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+        BuildAnalyzerConfiguration[] userConfigs,
+        BuildAnalyzer analyzer)
+    {
+        var configurations = new BuildAnalyzerConfigurationInternal[userConfigs.Length];
+
+        for (int idx = 0; idx < userConfigs.Length; idx++)
+        {
+            configurations[idx] = ConfigurationProvider.MergeConfiguration(
+                analyzer.SupportedRules[idx].Id,
+                analyzer.SupportedRules[idx].DefaultConfiguration,
+                userConfigs[idx]);
+        }
+
+        return configurations;
+    }
+
+    private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPath, IReadOnlyList<TRule> ruleIds, Func<string, TRule, TConfig> configurationProvider)
+    {
+        TConfig[] configurations = new TConfig[ruleIds.Count];
+        for (int i = 0; i < ruleIds.Count; i++)
+        {
+            configurations[i] = configurationProvider(projectFullPath, ruleIds[i]);
+        }
+
+        return configurations;
+    }
+
+    /// <summary>
+    /// Gets effective user specified (or default) configuration for the given analyzer rule.
+    /// The configuration values CAN be null upon this operation.
+    /// 
+    /// The configuration module should as well check that BuildAnalyzerConfigurationInternal.EvaluationAnalysisScope
+    ///  for all rules is equal - otherwise it should error out.
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <param name="ruleId"></param>
+    /// <returns></returns>
+    public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
+    {
+        if (!_editorConfig.TryGetValue(ruleId, out BuildAnalyzerConfiguration? editorConfig))
+        {
+            editorConfig = BuildAnalyzerConfiguration.Null;
+        }
+
+        return editorConfig;
+    }
+
+    /// <summary>
+    /// Gets effective configuration for the given analyzer rule.
+    /// The configuration values are guaranteed to be non-null upon this merge operation.
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <param name="analyzerRule"></param>
+    /// <returns></returns>
+    public static BuildAnalyzerConfigurationInternal GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
+        => GetMergedConfiguration(projectFullPath, analyzerRule.Id, analyzerRule.DefaultConfiguration);
+
+    public static BuildAnalyzerConfigurationInternal MergeConfiguration(
+        string ruleId,
+        BuildAnalyzerConfiguration defaultConfig,
+        BuildAnalyzerConfiguration editorConfig)
+        => new BuildAnalyzerConfigurationInternal(
+            ruleId: ruleId,
+            evaluationAnalysisScope: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationAnalysisScope),
+            isEnabled: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.IsEnabled),
+            severity: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.Severity));
+
+    private static BuildAnalyzerConfigurationInternal GetMergedConfiguration(
+        string projectFullPath,
+        string ruleId,
+        BuildAnalyzerConfiguration defaultConfig)
+        => MergeConfiguration(ruleId, defaultConfig, GetUserConfiguration(projectFullPath, ruleId));
+
+    private static T GetConfigValue<T>(
+        BuildAnalyzerConfiguration editorConfigValue,
+        BuildAnalyzerConfiguration defaultValue,
+        Func<BuildAnalyzerConfiguration, T?> propertyGetter) where T : struct
+        => propertyGetter(editorConfigValue) ??
+           propertyGetter(defaultValue) ??
+           EnsureNonNull(propertyGetter(BuildAnalyzerConfiguration.Default));
+
+    private static T EnsureNonNull<T>(T? value) where T : struct
+    {
+        if (value is null)
+        {
+            throw new InvalidOperationException("Value is null");
+        }
+
+        return value.Value;
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
new file mode 100644
index 00000000000..d200d48ee66
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
@@ -0,0 +1,64 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Holder for the key-value pairs of unstructured data from .editorconfig file,
+///  that were attribute to a particular rule, but were not recognized by the infrastructure.
+/// The configuration data that is recognized by the infrastructure is passed as <see cref="BuildAnalyzerConfiguration"/>.
+/// </summary>
+/// <param name="ruleId"></param>
+public class CustomConfigurationData(string ruleId)
+{
+    public static CustomConfigurationData Null { get; } = new(string.Empty);
+
+    public static bool NotNull(CustomConfigurationData data) => !Null.Equals(data);
+
+    /// <summary>
+    /// Identifier of the rule that the configuration data is for.
+    /// </summary>
+    public string RuleId { get; init; } = ruleId;
+
+    /// <summary>
+    /// Key-value pairs of unstructured data from .editorconfig file.
+    /// E.g. if in editorconfig file we'd have:
+    /// [*.csrpoj]
+    /// build_analyzer.microsoft.BC0101.name_of_targets_to_restrict = "Build,CoreCompile,ResolveAssemblyReferences"
+    ///
+    /// the ConfigurationData would be:
+    /// "name_of_targets_to_restrict" -> "Build,CoreCompile,ResolveAssemblyReferences"
+    /// </summary>
+    public IReadOnlyDictionary<string, string>? ConfigurationData { get; init; }
+
+    public override bool Equals(object? obj)
+    {
+        if (ReferenceEquals(null, obj))
+        {
+            return false;
+        }
+
+        if (ReferenceEquals(this, obj))
+        {
+            return true;
+        }
+
+        if (obj.GetType() != this.GetType())
+        {
+            return false;
+        }
+
+        return Equals((CustomConfigurationData)obj);
+    }
+
+    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);
+
+    public override int GetHashCode() => (ConfigurationData != null ? ConfigurationData.GetHashCode() : 0);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
new file mode 100644
index 00000000000..ca91897ad44
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -0,0 +1,54 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+internal enum BuildCheckDataSource
+{
+    EventArgs,
+    BuildExecution,
+
+    ValuesCount = BuildExecution + 1
+}
+
+/// <summary>
+/// The central manager for the BuildCheck - this is the integration point with MSBuild infrastructure.
+/// </summary>
+internal interface IBuildCheckManager
+{
+    void ProcessEvaluationFinishedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs);
+
+    void SetDataSource(BuildCheckDataSource buildCheckDataSource);
+
+    void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData);
+
+    Dictionary<string, TimeSpan> CreateTracingStats();
+
+    void FinalizeProcessing(LoggingContext loggingContext);
+
+    // All those to be called from RequestBuilder,
+    //  but as well from the ConnectorLogger - as even if interleaved, it gives the info
+    //  to manager about what analyzers need to be materialized and configuration fetched.
+    // No unloading of analyzers is yet considered - once loaded it stays for whole build.
+
+    void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext, string fullPath);
+    void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
+    void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
+    void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
+
+    void Shutdown();
+}
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs
new file mode 100644
index 00000000000..6b8bdea6080
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs
@@ -0,0 +1,17 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal interface IBuildCheckManagerProvider : IBuildComponent
+{
+    IBuildCheckManager Instance { get; }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
new file mode 100644
index 00000000000..00ed2266d09
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -0,0 +1,51 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal class NullBuildCheckManager : IBuildCheckManager
+{
+    public void Shutdown() { }
+
+    public void ProcessEvaluationFinishedEventArgs(AnalyzerLoggingContext buildAnalysisContext,
+        ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs)
+    { }
+
+    public void SetDataSource(BuildCheckDataSource buildCheckDataSource) { }
+    public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData) { }
+
+    public Dictionary<string, TimeSpan> CreateTracingStats() => throw new NotImplementedException();
+
+    public void FinalizeProcessing(LoggingContext loggingContext)
+    { }
+
+    public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext,
+        string fullPath)
+    { }
+
+    public void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    { }
+
+    public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    { }
+
+    public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    { }
+
+    public void YieldProject(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    { }
+
+    public void ResumeProject(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    { }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs
new file mode 100644
index 00000000000..c6dcbd84f8d
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs
@@ -0,0 +1,20 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal class NullBuildCheckManagerProvider : IBuildCheckManagerProvider
+{
+    public IBuildCheckManager Instance { get; } = new NullBuildCheckManager();
+
+    public void InitializeComponent(IBuildComponentHost host) { }
+    public void ShutdownComponent() { }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
new file mode 100644
index 00000000000..2d6d850737b
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
@@ -0,0 +1,27 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal class TracingReporter
+{
+    internal Dictionary<string, TimeSpan> TracingStats { get; } = new();
+
+    public void AddStats(string name, TimeSpan subtotal)
+    {
+        if (TracingStats.TryGetValue(name, out TimeSpan existing))
+        {
+            TracingStats[name] = existing + subtotal;
+        }
+        else
+        {
+            TracingStats[name] = subtotal;
+        }
+    }
+}
diff --git a/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs b/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs
new file mode 100644
index 00000000000..1b3eb9cb4bb
--- /dev/null
+++ b/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs
@@ -0,0 +1,22 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.BuildCheck.Logging;
+
+internal class AnalyzerLoggingContext : LoggingContext
+{
+    public AnalyzerLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
+        : base(loggingService, eventContext)
+    {
+        IsValid = true;
+    }
+
+    public AnalyzerLoggingContext(LoggingContext baseContext) : base(baseContext)
+    {
+        IsValid = true;
+    }
+}
diff --git a/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs b/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs
new file mode 100644
index 00000000000..baee4b681be
--- /dev/null
+++ b/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs
@@ -0,0 +1,13 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.BuildCheck.Logging;
+internal class AnalyzerLoggingContextFactory(ILoggingService loggingService) : IBuildAnalysisLoggingContextFactory
+{
+    public AnalyzerLoggingContext CreateLoggingContext(BuildEventContext eventContext) =>
+        new AnalyzerLoggingContext(loggingService, eventContext);
+}
diff --git a/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs b/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs
new file mode 100644
index 00000000000..e5188703ff7
--- /dev/null
+++ b/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs
@@ -0,0 +1,12 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+internal interface IBuildAnalysisLoggingContextFactory
+{
+    AnalyzerLoggingContext CreateLoggingContext(BuildEventContext eventContext);
+}
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
new file mode 100644
index 00000000000..d0738fe6b71
--- /dev/null
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -0,0 +1,64 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Base for a data passed from infrastructure to build analyzers.
+/// </summary>
+/// <param name="projectFilePath">Currently build project.</param>
+public abstract class AnalysisData(string projectFilePath)
+{
+    /// <summary>
+    /// Full path to the project file being built.
+    /// </summary>
+    public string ProjectFilePath { get; } = projectFilePath;
+}
+
+/// <summary>
+/// Data passed from infrastructure to build analyzers.
+/// </summary>
+/// <typeparam name="T">The type of the actual data for analysis.</typeparam>
+public class BuildCheckDataContext<T> where T : AnalysisData
+{
+    private readonly BuildAnalyzerWrapper _analyzerWrapper;
+    private readonly LoggingContext _loggingContext;
+    private readonly BuildAnalyzerConfigurationInternal[] _configPerRule;
+    private readonly Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult> _resultHandler;
+
+    internal BuildCheckDataContext(
+        BuildAnalyzerWrapper analyzerWrapper,
+        LoggingContext loggingContext,
+        BuildAnalyzerConfigurationInternal[] configPerRule,
+        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult> resultHandler,
+        T data)
+    {
+        _analyzerWrapper = analyzerWrapper;
+        _loggingContext = loggingContext;
+        _configPerRule = configPerRule;
+        _resultHandler = resultHandler;
+        Data = data;
+    }
+
+    /// <summary>
+    /// Method for reporting the result of the build analyzer rule.
+    /// </summary>
+    /// <param name="result"></param>
+    public void ReportResult(BuildCheckResult result)
+        => _resultHandler(_analyzerWrapper, _loggingContext, _configPerRule, result);
+
+    /// <summary>
+    /// Data to be analyzed.
+    /// </summary>
+    public T Data { get; }
+}
diff --git a/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs b/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
new file mode 100644
index 00000000000..f3a336a41ec
--- /dev/null
+++ b/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
@@ -0,0 +1,20 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Logging;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// BuildCheck OM data representing the evaluated properties of a project.
+/// </summary>
+public class EvaluatedPropertiesAnalysisData : AnalysisData
+{
+    internal EvaluatedPropertiesAnalysisData(
+        string projectFilePath,
+        IReadOnlyDictionary<string, string> evaluatedProperties) :
+        base(projectFilePath) => EvaluatedProperties = evaluatedProperties;
+
+    public IReadOnlyDictionary<string, string> EvaluatedProperties { get; }
+}
diff --git a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs b/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
new file mode 100644
index 00000000000..a6b34446258
--- /dev/null
+++ b/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
@@ -0,0 +1,55 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Extension methods for <see cref="ProjectItemElement"/>.
+/// </summary>
+public static class ItemTypeExtensions
+{
+    public static IEnumerable<ProjectItemElement> GetItemsOfType(this IEnumerable<ProjectItemElement> items,
+        string itemType)
+    {
+        return items.Where(i =>
+            MSBuildNameIgnoreCaseComparer.Default.Equals(i.ItemType, itemType));
+    }
+}
+
+/// <summary>
+/// Holder for evaluated items and item groups.
+/// </summary>
+/// <param name="items"></param>
+/// <param name="itemGroups"></param>
+public class ItemsHolder(IEnumerable<ProjectItemElement> items, IEnumerable<ProjectItemGroupElement> itemGroups)
+{
+    public IEnumerable<ProjectItemElement> Items { get; } = items;
+    public IEnumerable<ProjectItemGroupElement> ItemGroups { get; } = itemGroups;
+
+    public IEnumerable<ProjectItemElement> GetItemsOfType(string itemType)
+    {
+        return Items.GetItemsOfType(itemType);
+    }
+}
+
+/// <summary>
+/// BuildCheck OM data representing the evaluated items of a project.
+/// </summary>
+public class ParsedItemsAnalysisData : AnalysisData
+{
+    internal ParsedItemsAnalysisData(
+        string projectFilePath,
+        ItemsHolder itemsHolder) :
+        base(projectFilePath) => ItemsHolder = itemsHolder;
+
+    public ItemsHolder ItemsHolder { get; }
+}
diff --git a/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs b/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
new file mode 100644
index 00000000000..96efc8ff2fd
--- /dev/null
+++ b/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
@@ -0,0 +1,51 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+internal static class EnumerableExtensions
+{
+    /// <summary>
+    /// Concatenates items of input sequence into csv string.
+    /// </summary>
+    /// <typeparam name="T"></typeparam>
+    /// <param name="source">Sequence to be turned into csv string.</param>
+    /// <param name="useSpace">Indicates whether space should be inserted between commas and following items.</param>
+    /// <returns>Csv string.</returns>
+    public static string ToCsvString<T>(this IEnumerable<T>? source, bool useSpace = true)
+    {
+        return source == null ? "<NULL>" : string.Join(useSpace ? ", " : ",", source);
+    }
+
+    /// <summary>
+    /// Adds a content of given dictionary to current dictionary.
+    /// </summary>
+    /// <typeparam name="TKey"></typeparam>
+    /// <typeparam name="TValue"></typeparam>
+    /// <param name="dict">Dictionary to receive another values.</param>
+    /// <param name="another">Dictionary to be merged into current.</param>
+    /// <param name="mergeValues">Way of resolving keys conflicts.</param>
+    public static void Merge<TKey, TValue>(
+        this IDictionary<TKey, TValue> dict,
+        IReadOnlyDictionary<TKey, TValue> another,
+        Func<TValue, TValue, TValue> mergeValues)
+    {
+        foreach (var pair in another)
+        {
+            if (!dict.TryGetValue(pair.Key, out TValue? value))
+            {
+                dict[pair.Key] = pair.Value;
+            }
+            else
+            {
+                dict[pair.Key] = mergeValues(value, pair.Value);
+            }
+        }
+    }
+}
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 2dd2bb89a95..c9bf42b48b2 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -80,7 +80,7 @@ public string LocationString
         /// It is to be used for the project location when the project has not been given a name.
         /// In that case, it exists, but can't have a specific location.
         /// </summary>
-        internal static ElementLocation EmptyLocation
+        public static ElementLocation EmptyLocation
         {
             get { return s_emptyElementLocation; }
         }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 6d41abd7891..dc2d2ed13ca 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -120,6 +120,9 @@
     <Compile Include="..\Shared\TaskLoggingHelperExtension.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\TaskLoggingHelperExtension.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IsExternalInit.cs">
+      <Link>BuildCheck\Utilities\IsExternalInit.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\TaskParameter.cs" />
     <Compile Include="..\Shared\TaskParameterTypeVerifier.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
@@ -153,6 +156,37 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
+    <Compile Include="BuildCheck\Acquisition\AnalyzerAcquisitionData.cs" />
+    <Compile Include="BuildCheck\Acquisition\BuildCheckAcquisitionModule.cs" />
+    <Compile Include="BuildCheck\Analyzers\SharedOutputPathAnalyzer.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckConfigurationException.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildEventsProcessor.cs" />
+    <Compile Include="BuildCheck\Infrastructure\IBuildCheckManagerProvider.cs" />
+    <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManager.cs" />
+    <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManagerProvider.cs" />
+    <Compile Include="BuildCheck\Infrastructure\TracingReporter.cs" />
+    <Compile Include="BuildCheck\OM\BuildCheckDataContext.cs" />
+    <Compile Include="BuildCheck\API\BuildAnalyzer.cs" />
+    <Compile Include="BuildCheck\API\BuildAnalyzerConfiguration.cs" />
+    <Compile Include="BuildCheck\API\BuildCheckResult.cs" />
+    <Compile Include="BuildCheck\API\BuildAnalyzerResultSeverity.cs" />
+    <Compile Include="BuildCheck\API\BuildAnalyzerRule.cs" />
+    <Compile Include="BuildCheck\API\ConfigurationContext.cs" />
+    <Compile Include="BuildCheck\API\EvaluationAnalysisScope.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildAnalyzerConfigurationInternal.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildAnalyzerWrapper.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckCentralContext.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckConnectorLogger.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckContext.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckManagerProvider.cs" />
+    <Compile Include="BuildCheck\Infrastructure\ConfigurationProvider.cs" />
+    <Compile Include="BuildCheck\Infrastructure\CustomConfigurationData.cs" />
+    <Compile Include="BuildCheck\API\IBuildCheckRegistrationContext.cs" />
+    <Compile Include="BuildCheck\Infrastructure\IBuildCheckManager.cs" />
+    <Compile Include="BuildCheck\Logging\IBuildAnalysisLoggingContextFactory.cs" />
+    <Compile Include="BuildCheck\OM\EvaluatedPropertiesAnalysisData.cs" />
+    <Compile Include="BuildCheck\OM\ParsedItemsAnalysisData.cs" />
+    <Compile Include="BuildCheck\Utilities\EnumerableExtensions.cs" />
     <Compile Include="Evaluation\IItemTypeDefinition.cs" />
     <Compile Include="FileAccess\DesiredAccess.cs" />
     <Compile Include="FileAccess\FileAccessData.cs" />
@@ -160,6 +194,8 @@
     <Compile Include="FileAccess\ProcessData.cs" />
     <Compile Include="FileAccess\ReportedFileOperation.cs" />
     <Compile Include="FileAccess\RequestedAccess.cs" />
+    <Compile Include="BuildCheck\Logging\AnalyzerLoggingContext.cs" />
+    <Compile Include="BuildCheck\Logging\AnalyzerLoggingContextFactory.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
@@ -682,11 +718,7 @@
   <!-- Extract binding redirects for MSBuild and dependencies from MSBuild.exe.config into a source file.
        This allows us to create secondary AppDomains with the same redirects at run-time, see
        https://github.com/dotnet/msbuild/blob/main/documentation/NETFramework-NGEN.md#nugetframeworks -->
-  <Target Name="GenerateAppDomainConfig"
-          Inputs="..\MSBuild\app.config;..\MSBuild\app.amd64.config;$(MSBuildThisFileFullPath)"
-          Outputs="$(NuGetFrameworkWrapperRedirects_FilePath)"
-          BeforeTargets="CoreCompile"
-          Condition="'$(FeatureAppDomain)' == 'true'">
+  <Target Name="GenerateAppDomainConfig" Inputs="..\MSBuild\app.config;..\MSBuild\app.amd64.config;$(MSBuildThisFileFullPath)" Outputs="$(NuGetFrameworkWrapperRedirects_FilePath)" BeforeTargets="CoreCompile" Condition="'$(FeatureAppDomain)' == 'true'">
     <PropertyGroup>
       <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>
       <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/*</BindingRedirectXPath>
diff --git a/src/UnitTests.Shared/AssemblyInfo.cs b/src/BuildCheck.UnitTests/AssemblyInfo.cs
similarity index 100%
rename from src/UnitTests.Shared/AssemblyInfo.cs
rename to src/BuildCheck.UnitTests/AssemblyInfo.cs
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
new file mode 100644
index 00000000000..248b66ea6b0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
@@ -0,0 +1,43 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Xunit;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class BuildAnalyzerConfigurationInternalTests
+{
+    [Theory]
+    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning, true, true)]
+    [InlineData("ruleId2", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning, true, true)]
+    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Error, true, false)]
+    public void IsSameConfigurationAsTest(
+        string secondRuleId,
+        EvaluationAnalysisScope secondScope,
+        BuildAnalyzerResultSeverity secondSeverity,
+        bool secondEnabled,
+        bool isExpectedToBeSame)
+    {
+        BuildAnalyzerConfigurationInternal configuration1 = new BuildAnalyzerConfigurationInternal(
+                       ruleId: "ruleId",
+                       evaluationAnalysisScope: EvaluationAnalysisScope.ProjectOnly,
+                       severity: BuildAnalyzerResultSeverity.Warning,
+                       isEnabled: true);
+
+        BuildAnalyzerConfigurationInternal configuration2 = new BuildAnalyzerConfigurationInternal(
+            ruleId: secondRuleId,
+            evaluationAnalysisScope: secondScope,
+            severity: secondSeverity,
+            isEnabled: secondEnabled);
+
+        configuration1.IsSameConfigurationAs(configuration2).ShouldBe(isExpectedToBeSame);
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
new file mode 100644
index 00000000000..a0007d2c103
--- /dev/null
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -0,0 +1,137 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EndToEndTests : IDisposable
+{
+    private readonly TestEnvironment _env;
+    public EndToEndTests(ITestOutputHelper output)
+    {
+        _env = TestEnvironment.Create(output);
+
+        // this is needed to ensure the binary logger does not pollute the environment
+        _env.WithEnvironmentInvariant();
+    }
+
+    public void Dispose() => _env.Dispose();
+
+    [Theory]
+    [InlineData(true, true)]
+    [InlineData(false, true)]
+    [InlineData(false, false)]
+    public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool analysisRequested)
+    {
+        string contents = $"""
+            <Project Sdk="Microsoft.NET.Sdk" DefaultTargets="Hello">
+                
+                <PropertyGroup>
+                <OutputType>Exe</OutputType>
+                <TargetFramework>net8.0</TargetFramework>
+                <ImplicitUsings>enable</ImplicitUsings>
+                <Nullable>enable</Nullable>
+                </PropertyGroup>
+                  
+                <PropertyGroup Condition="$(Test) == true">
+                <TestProperty>Test</TestProperty>
+                </PropertyGroup>
+                 
+                <ItemGroup>
+                <ProjectReference Include=".\FooBar-Copy.csproj" />
+                </ItemGroup>
+                  
+                <Target Name="Hello">
+                <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
+                </Target>
+                
+            </Project>
+            """;
+
+        string contents2 = $"""
+            <Project Sdk="Microsoft.NET.Sdk">
+                               
+                <PropertyGroup>
+                <OutputType>Exe</OutputType>
+                <TargetFramework>net8.0</TargetFramework>
+                <ImplicitUsings>enable</ImplicitUsings>
+                <Nullable>enable</Nullable>
+                </PropertyGroup>
+                                 
+                <PropertyGroup Condition="$(Test) == true">
+                <TestProperty>Test</TestProperty>
+                </PropertyGroup>
+                                
+                <ItemGroup>
+                <Reference Include="bin/foo.dll" />
+                </ItemGroup>
+                                
+                <Target Name="Hello">
+                <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
+                </Target>
+                               
+            </Project>
+            """;
+        TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
+        TransientTestFile projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
+        TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
+
+        // var cache = new SimpleProjectRootElementCache();
+        // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);
+
+
+        TransientTestFile config = _env.CreateFile(workFolder, "editorconfig.json",
+            /*lang=json,strict*/
+            """
+            {
+                "BC0101": {
+                    "IsEnabled": true,
+                    "Severity": "Error"
+                },
+                "COND0543": {
+                    "IsEnabled": false,
+                    "Severity": "Error",
+                    "EvaluationAnalysisScope": "AnalyzedProjectOnly",
+                    "CustomSwitch": "QWERTY"
+                },
+                "BLA": {
+                    "IsEnabled": false
+                }
+            }
+            """);
+
+        // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
+        // This discrepancy breaks path equality checks in analyzers if we pass to MSBuild full path to the initial project.
+        // See if there is a way of fixing it in the engine - tracked: https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=55702688.
+        _env.SetCurrentDirectory(Path.GetDirectoryName(projectFile.Path));
+
+        _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", buildInOutOfProcessNode ? "1" : "0");
+        _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore" +
+            (analysisRequested ? " -analyze" : string.Empty), out bool success);
+        _env.Output.WriteLine(output);
+        success.ShouldBeTrue();
+        // The conflicting outputs warning appears - but only if analysis was requested
+        if (analysisRequested)
+        {
+            output.ShouldContain("BC0101");
+        }
+        else
+        {
+            output.ShouldNotContain("BC0101");
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
new file mode 100644
index 00000000000..3aa9eaff7d1
--- /dev/null
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -0,0 +1,37 @@
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <!-- Don't build a netfx version of this unit with dotnet, as the netfx bootstrap layout created with 'dotnet build' is incomplete. -->
+    <TargetFrameworks>$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
+    <TargetFrameworks Condition="'$(MSBuildRuntimeType)' == 'Full'">$(FullFrameworkTFM);$(TargetFrameworks)</TargetFrameworks>
+
+    <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
+    <IsPackable>false</IsPackable>
+    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
+    <ProjectReference Include="..\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj" />
+    <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <PackageReference Include="System.Collections.Immutable" />
+    <PackageReference Include="Shouldly" />
+    <PackageReference Include="System.Net.Http" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <Service Include="{82a7f48d-3b50-4b1e-b82e-3ada8210c358}" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <None Include="..\Shared\UnitTests\App.config">
+      <Link>App.config</Link>
+      <SubType>Designer</SubType>
+    </None>
+    <None Include="..\Shared\UnitTests\xunit.runner.json">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+  </ItemGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
new file mode 100644
index 00000000000..05d1266d2ac
--- /dev/null
+++ b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
@@ -0,0 +1,46 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Xml;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.UnitTests;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class ParsedItemsAnalysisDataTests
+{
+    [Fact]
+    public void ItemsHolder_GetItemsOfType_ShouldFilterProperly()
+    {
+        ProjectRootElement root = ProjectRootElement.Create();
+
+        ProjectItemElement el1 = ProjectItemElement.CreateDisconnected("ItemB", root);
+        ProjectItemElement el2 = ProjectItemElement.CreateDisconnected("ItemB", root);
+        ProjectItemElement el3 = ProjectItemElement.CreateDisconnected("ItemA", root);
+        ProjectItemElement el4 = ProjectItemElement.CreateDisconnected("ItemB", root);
+        ProjectItemElement el5 = ProjectItemElement.CreateDisconnected("ItemA", root);
+
+        var items = new List<ProjectItemElement>()
+        {
+            el1,
+            el2,
+            el3,
+            el4,
+            el5
+        };
+        var itemsHolder = new ItemsHolder(items, new List<ProjectItemGroupElement>());
+
+        var itemsA = itemsHolder.GetItemsOfType("ItemA").ToList();
+        var itemsB = itemsHolder.GetItemsOfType("ItemB").ToList();
+
+        itemsA.ShouldBeSameIgnoringOrder(new List<ProjectItemElement>() { el3, el5 });
+        itemsB.ShouldBeSameIgnoringOrder(new List<ProjectItemElement>() { el1, el2, el4 });
+    }
+}
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
new file mode 100644
index 00000000000..8a6faa13fb4
--- /dev/null
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -0,0 +1,158 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Base class for all build check event args.
+/// Not intended to be extended by external code.
+/// </summary>
+internal abstract class BuildCheckEventArgs : BuildEventArgs
+{ }
+
+/// <summary>
+/// Transport mean for the BuildCheck tracing data from additional nodes.
+/// </summary>
+/// <param name="tracingData"></param>
+internal sealed class BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> tracingData) : BuildCheckEventArgs
+{
+    internal BuildCheckTracingEventArgs() : this(new Dictionary<string, TimeSpan>())
+    { }
+
+    public Dictionary<string, TimeSpan> TracingData { get; private set; } = tracingData;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write7BitEncodedInt(TracingData.Count);
+        foreach (KeyValuePair<string, TimeSpan> kvp in TracingData)
+        {
+            writer.Write(kvp.Key);
+            writer.Write(kvp.Value.Ticks);
+        }
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        int count = reader.Read7BitEncodedInt();
+        TracingData = new Dictionary<string, TimeSpan>(count);
+        for (int i = 0; i < count; i++)
+        {
+            string key = reader.ReadString();
+            TimeSpan value = TimeSpan.FromTicks(reader.ReadInt64());
+
+            TracingData.Add(key, value);
+        }
+    }
+}
+
+internal sealed class BuildCheckAcquisitionEventArgs(string acquisitionData) : BuildCheckEventArgs
+{
+    internal BuildCheckAcquisitionEventArgs() : this(string.Empty)
+    { }
+
+    public string AcquisitionData { get; private set; } = acquisitionData;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write(AcquisitionData);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        AcquisitionData = reader.ReadString();
+    }
+}
+internal sealed class BuildCheckResultWarning : BuildWarningEventArgs
+{
+    public BuildCheckResultWarning(IBuildCheckResult result)
+    {
+        this.Message = result.FormatMessage();
+    }
+
+    internal BuildCheckResultWarning() { }
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write(Message!);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        Message = reader.ReadString();
+    }
+
+    public override string? Message { get; protected set; }
+}
+
+internal sealed class BuildCheckResultError : BuildErrorEventArgs
+{
+    public BuildCheckResultError(IBuildCheckResult result)
+    {
+        this.Message = result.FormatMessage();
+    }
+
+    internal BuildCheckResultError() { }
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write(Message!);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        Message = reader.ReadString();
+    }
+
+    public override string? Message { get; protected set; }
+}
+
+internal sealed class BuildCheckResultMessage : BuildMessageEventArgs
+{
+    public BuildCheckResultMessage(IBuildCheckResult result)
+    {
+        this.Message = result.FormatMessage();
+    }
+
+    internal BuildCheckResultMessage() { }
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+
+        writer.Write(Message!);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+
+        Message = reader.ReadString();
+    }
+
+    public override string? Message { get; protected set; }
+}
diff --git a/src/Framework/BuildCheck/IBuildCheckResult.cs b/src/Framework/BuildCheck/IBuildCheckResult.cs
new file mode 100644
index 00000000000..1d471e6c9bc
--- /dev/null
+++ b/src/Framework/BuildCheck/IBuildCheckResult.cs
@@ -0,0 +1,25 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Holder for the reported result of a build cop rule.
+/// </summary>
+internal interface IBuildCheckResult
+{
+    /// <summary>
+    /// Optional location of the finding (in near future we might need to support multiple locations).
+    /// </summary>
+    string LocationString { get; }
+    string[] MessageArgs { get; }
+    string MessageFormat { get; }
+
+    string FormatMessage();
+}
diff --git a/src/Framework/Features.cs b/src/Framework/Features.cs
index e5910b3cf5f..ec1183c94f5 100644
--- a/src/Framework/Features.cs
+++ b/src/Framework/Features.cs
@@ -42,6 +42,7 @@ public static class Features
     {
         private static readonly Dictionary<string, FeatureStatus> _featureStatusMap = new Dictionary<string, FeatureStatus>
         {
+            { "BuildCheck.Beta", FeatureStatus.Preview },
             { "EvaluationContext_SharedSDKCachePolicy", FeatureStatus.Available }, // EvaluationContext supports the SharingPolicy.SharedSDKCache flag.
             { "TerminalLogger_MultiLineHandler", FeatureStatus.Available }, // TerminalLogger has better explicit support for rendering multi-line messages
             // Add more features here.
diff --git a/src/Framework/IEventSource.cs b/src/Framework/IEventSource.cs
index 187c105d386..8e5402b6fd3 100644
--- a/src/Framework/IEventSource.cs
+++ b/src/Framework/IEventSource.cs
@@ -3,6 +3,8 @@
 
 #nullable disable
 
+using Microsoft.Build.Experimental.BuildCheck;
+
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -75,6 +77,11 @@ namespace Microsoft.Build.Framework
     /// </summary>
     public delegate void AnyEventHandler(object sender, BuildEventArgs e);
 
+    /// <summary>
+    /// Type of handler for BuildCheckEventRaised events
+    /// </summary>
+    internal delegate void BuildCheckEventHandler(object sender, BuildCheckEventArgs e);
+
     /// <summary>
     /// This interface defines the events raised by the build engine.
     /// Loggers use this interface to subscribe to the events they
diff --git a/src/Framework/Properties/AssemblyInfo.cs b/src/Framework/Properties/AssemblyInfo.cs
index 1f0b9011081..633749084f0 100644
--- a/src/Framework/Properties/AssemblyInfo.cs
+++ b/src/Framework/Properties/AssemblyInfo.cs
@@ -45,6 +45,7 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+[assembly: InternalsVisibleTo("Microsoft.Build.BuildCheck.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 // Ideally we wouldn't need to IVT to OM.UnitTests, which is supposed to test
 // only the public surface area of Microsoft.Build. However, there's a bunch
 // of shared code in Framework that's used there, and we can still avoid IVT
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index d678ab57d35..8e9d1e09d00 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -133,6 +133,7 @@ public Traits()
         public readonly bool DebugEngine = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildDebugEngine"));
         public readonly bool DebugScheduler;
         public readonly bool DebugNodeCommunication;
+        public readonly bool DebugUnitTests = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildDebugUnitTests"));
 
         public readonly bool InProcNodeDisabled = Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") == "1";
 
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index d2b2b866183..8a2a558e452 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -1,4 +1,6 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <Import Project="$(RepoRoot)eng\BootStrapMsBuild.props" />
 
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
@@ -43,9 +45,9 @@
     <Copy SourceFiles="$(PublishDir)$(AssemblyName).deps.json" DestinationFiles="$(PublishDir)MSBuild.deps.json" SkipUnchangedFiles="true" />
   </Target>
 
-  <Import Project="..\Package\GetBinPaths.targets" Condition="$(TargetFramework.StartsWith('net4'))"/>
-  <Import Project="..\Package\GetBinPaths.Arm64.targets" Condition="$(TargetFramework.StartsWith('net4'))"/>
+  <Import Project="..\Package\GetBinPaths.targets" Condition="$(TargetFramework.StartsWith('net4'))" />
+  <Import Project="..\Package\GetBinPaths.Arm64.targets" Condition="$(TargetFramework.StartsWith('net4'))" />
 
-  <Import Project="$(RepoRoot)eng\BootStrapMSBuild.targets" />
+  <Import Project="$(RepoRoot)eng\BootStrapMsBuild.targets" />
 
 </Project>
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 53e4555fcf2..6ffae8dfb52 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -1185,6 +1185,7 @@ public void InvalidToolsVersionErrors()
                                         graphBuildOptions: null,
                                         lowPriority: false,
                                         question: false,
+                                        isBuildCheckEnabled: false,
                                         inputResultsCaches: null,
                                         outputResultsCache: null,
                                         saveProjectResult: false,
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index 16fbed5a461..2de493e68b9 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -68,7 +68,7 @@ public class MSBuildServer_Tests : IDisposable
         <ProcessIdTask>
             <Output PropertyName=""PID"" TaskParameter=""Pid"" />
         </ProcessIdTask>
-        <Message Text=""Server ID is $(PID)"" Importance=""High"" />
+        <Message Text=""[Work around Github issue #9667 with --interactive]Server ID is $(PID)"" Importance=""High"" />
     </Target>
 </Project>";
         private static string sleepingTaskContentsFormat = @$"
@@ -313,8 +313,8 @@ public void PropertyMSBuildStartupDirectoryOnServer()
         <ProcessIdTask>
             <Output PropertyName=""PID"" TaskParameter=""Pid"" />
         </ProcessIdTask>
-        <Message Text=""Server ID is $(PID)"" Importance=""High"" />
-		<Message Text="":MSBuildStartupDirectory:$(MSBuildStartupDirectory):"" Importance=""high"" />
+        <Message Text=""[Work around Github issue #9667 with --interactive]Server ID is $(PID)"" Importance=""High"" />
+		<Message Text=""[Work around Github issue #9667 with --interactive]:MSBuildStartupDirectory:$(MSBuildStartupDirectory):"" Importance=""high"" />
 	</Target>
 </Project>";
 
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Linux.verified.txt
index 34897dfd415..1cd4aa011ed 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Linux.verified.txt
@@ -1,6 +1,6 @@
 ﻿]9;4;3;\  project test [32;1msucceeded[m (0.2s)
 [?25l[1F
 [?25h
+Test summary: total: 10, [31;1mfailed: 1[m, succeeded: 7, skipped: 2, duration: 1.0s
 Build [32;1msucceeded[m in 5.0s
-Test run [31;1mfailed[m. Total: 10 Failed: 1 Passed: 7 Skipped: 2, Duration: 1.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.OSX.verified.txt
index 6615c0644e7..18ffc7942a8 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.OSX.verified.txt
@@ -1,5 +1,5 @@
 ﻿  project test [32;1msucceeded[m (0.2s)
 [?25l[1F
 [?25h
+Test summary: total: 10, [31;1mfailed: 1[m, succeeded: 7, skipped: 2, duration: 1.0s
 Build [32;1msucceeded[m in 5.0s
-Test run [31;1mfailed[m. Total: 10 Failed: 1 Passed: 7 Skipped: 2, Duration: 1.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Windows.verified.txt
index 34897dfd415..1cd4aa011ed 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Windows.verified.txt
@@ -1,6 +1,6 @@
 ﻿]9;4;3;\  project test [32;1msucceeded[m (0.2s)
 [?25l[1F
 [?25h
+Test summary: total: 10, [31;1mfailed: 1[m, succeeded: 7, skipped: 2, duration: 1.0s
 Build [32;1msucceeded[m in 5.0s
-Test run [31;1mfailed[m. Total: 10 Failed: 1 Passed: 7 Skipped: 2, Duration: 1.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 1c3aed6df74..375cbf871fa 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -2657,6 +2657,11 @@ public void EndToEndVersionMessage(string arguments, bool shouldContainVersionMe
         [InlineData("/v:normal /bl", MessageImportance.Low)] // v:normal but with binary logger so everything must be logged
         [InlineData("/v:minimal /bl", MessageImportance.Low)] // v:minimal but with binary logger so everything must be logged
         [InlineData("/v:quiet /bl", MessageImportance.Low)] // v:quiet but with binary logger so everything must be logged
+        [InlineData("/v:diagnostic /analyze", MessageImportance.Low)]
+        [InlineData("/v:detailed /analyze", MessageImportance.Low)]
+        [InlineData("/v:normal /analyze", MessageImportance.Low)] // v:normal but with analyzers so everything must be logged
+        [InlineData("/v:minimal /analyze", MessageImportance.Low)] // v:minimal but with analyzers so everything must be logged
+        [InlineData("/v:quiet /analyze", MessageImportance.Low)] // v:quiet but with analyzers so everything must be logged
         public void EndToEndMinimumMessageImportance(string arguments, MessageImportance expectedMinimumMessageImportance)
         {
             using TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create();
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index a4d81b8e2e3..e7800bdf4ca 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -99,6 +99,7 @@ internal enum ParameterizedSwitch
             WarningsNotAsErrors,
             WarningsAsMessages,
             BinaryLogger,
+            Analyze,
             Restore,
             ProfileEvaluation,
             RestoreProperty,
@@ -267,6 +268,7 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "warnnotaserror", "noerr" },           ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false),
             new ParameterizedSwitchInfo(  new string[] { "warnasmessage", "nowarn" },           ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "binarylogger", "bl" },                ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "analyze", },                     ParameterizedSwitch.Analyze,                    null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "restore", "r" },                      ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "profileevaluation", "prof" },         ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false),
             new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false),
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index c6ddf821ce0..1129806b5c5 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1641,10 +1641,25 @@
       {4}: duration in seconds with 1 decimal point
     </comment>
   </data>
-  <data name="TestSummary" xml:space="preserve">
-    <value>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</value>
-    <comment>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</comment>
+  <data name="TestSummary_BannerAndTotal" xml:space="preserve">
+    <value>Test summary: total: {0}</value>
+    <comment>{0} whole number</comment>
+  </data>
+  <data name="TestSummary_Duration" xml:space="preserve">
+    <value>duration: {0}s</value>
+    <comment>{0} whole number</comment>
+  </data>
+  <data name="TestSummary_Failed" xml:space="preserve">
+    <value>failed: {0}</value>
+    <comment>{0} whole number</comment>
+  </data>
+  <data name="TestSummary_Skipped" xml:space="preserve">
+    <value>skipped: {0}</value>
+    <comment>{0} whole number</comment>
+  </data>
+  <data name="TestSummary_Succeeded" xml:space="preserve">
+    <value>succeeded: {0}</value>
+    <comment>{0} whole number</comment>
   </data>
   <!-- **** TerminalLogger strings end **** -->
     <!--
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index fe8f7c4a859..7372c383379 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -1702,11 +1702,30 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Testovací běh {0}. Celkem: {1}, neúspěšné: {2}, úspěšné: {3}, přeskočeno: {4}, doba trvání: {5} s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 5e22ec6e196..8514e6959d2 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1690,11 +1690,30 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Testlauf {0}. Gesamt: {1} Fehlgeschlagen: {2} Erfolgreich: {3} Übersprungen: {4}, Dauer: {5}s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 4dac587cf5c..c676c505e7a 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1696,11 +1696,30 @@ Esta marca es experimental y puede que no funcione según lo previsto.
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Serie de pruebas {0}. Total: {1} error: {2} Pasado: {3} Omitido: {4}, Duración: {5}s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 9886752a310..f8a69c82bd7 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1689,11 +1689,30 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Série de tests : {0}. Total : {1} Échec : {2}, Réussi : {3}, Ignoré : {4}, Durée : {5} s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index d633ec372ff..3047992c2d9 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -1700,11 +1700,30 @@ Nota: livello di dettaglio dei logger di file
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Esecuzione dei test {0}. Totale: {1} non superati: {2} superati: {3} ignorati: {4}, durata: {5}s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index ff16124ddbd..1cf1e7ea303 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1689,11 +1689,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">{0}　をテスト実行します。合計: {1} 不合格: {2} 合格: {3} スキップ: {4}、期間: {5} 秒</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index dd8ec661d08..046f55d8df9 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1689,11 +1689,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">{0} 테스트를 실행합니다. 합계: {1} 실패: {2} 통과: {3} 건너뜀: {4}, 기간: {5}초</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 6e010c6afe3..b537f9674ef 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -1700,11 +1700,30 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Przebieg testu {0}. Łącznie: {1} niepowodzenie: {2} zakończone powodzeniem: {3} pominięto: {4}, czas trwania: {5}s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index fd52acfedc7..bc8d315f35d 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1690,11 +1690,30 @@ arquivo de resposta.
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Execução de teste {0}. Total: {1} Falha: {2} Aprovado: {3} Ignorado: {4}, Duração: {5}s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 46e56814216..932577e7171 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1688,11 +1688,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Тестовый запуск {0}. Всего: {1}, не пройдено: {2}, пройдено: {3}, пропущено: {4}, длительность: {5} с</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 6fcdffc386d..bb6eff23b2a 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1693,11 +1693,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">Test çalıştırması {0}. Toplam: {1} Başarısız: {2} Geçti: {3} Atlandı: {4}, Süre: {5}s</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 85f89d32be5..e9ec6e93f0e 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1689,11 +1689,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">测试运行 {0}。总计: {1} 失败: {2} 通过: {3} 跳过: {4}, 持续时间: {5} 秒</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 62f632fc19a..26882d5ab4b 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1689,11 +1689,30 @@
       {4}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
-      <trans-unit id="TestSummary">
-        <source>Test run {0}. Total: {1} Failed: {2} Passed: {3} Skipped: {4}, Duration: {5}s</source>
-        <target state="translated">測試回合 {0}。總計: {1} 失敗: {2} 傳遞: {3} 跳過: {4}, 期間: {5} 秒</target>
-        <note>{0} string, localized result e.g. Failed surrounded by ANSI colors.
-{1-5} whole number</note>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="new">Test summary: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="new">duration: {0}s</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="new">failed: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="new">skipped: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="new">succeeded: {0}</target>
+        <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index dd13fbe28aa..9dfb90a1750 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -11,12 +11,10 @@
 using System.Text.RegularExpressions;
 using System.Diagnostics;
 using Microsoft.Build.Framework.Logging;
+using System.Globalization;
 
 #if NET7_0_OR_GREATER
 using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
-
-
 #endif
 #if NETFRAMEWORK
 using Microsoft.IO;
@@ -389,6 +387,31 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)
                 string buildResult = RenderBuildResult(e.Succeeded, _buildErrorsCount, _buildWarningsCount);
 
                 Terminal.WriteLine("");
+                if(_testRunSummaries.Any())
+                {
+                    var total = _testRunSummaries.Sum(t => t.Total);
+                    var failed = _testRunSummaries.Sum(t => t.Failed);
+                    var passed = _testRunSummaries.Sum(t => t.Passed);
+                    var skipped = _testRunSummaries.Sum(t => t.Skipped);
+                    var testDuration = (_testStartTime != null && _testEndTime != null ? (_testEndTime - _testStartTime).Value.TotalSeconds : 0).ToString("F1");
+
+                    var colorizeFailed = failed > 0;
+                    var colorizePassed = passed > 0 && _buildErrorsCount == 0 && failed == 0;
+                    var colorizeSkipped = skipped > 0 && skipped == total && _buildErrorsCount == 0 && failed == 0;
+
+                    string summaryAndTotalText = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("TestSummary_BannerAndTotal", total);
+                    string failedText = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("TestSummary_Failed", failed);
+                    string passedText = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("TestSummary_Succeeded", passed);
+                    string skippedText = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("TestSummary_Skipped", skipped);
+                    string durationText = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("TestSummary_Duration", testDuration);
+
+                    failedText = colorizeFailed ? AnsiCodes.Colorize(failedText.ToString(), TerminalColor.Red) : failedText;
+                    passedText = colorizePassed ? AnsiCodes.Colorize(passedText.ToString(), TerminalColor.Green) : passedText;
+                    skippedText = colorizeSkipped ? AnsiCodes.Colorize(skippedText.ToString(), TerminalColor.Yellow) : skippedText;
+
+                    Terminal.WriteLine(string.Join(CultureInfo.CurrentCulture.TextInfo.ListSeparator + " ", summaryAndTotalText, failedText, passedText, skippedText, durationText));
+                }
+
                 if (_restoreFailed)
                 {
                     Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("RestoreCompleteWithMessage",
@@ -401,27 +424,6 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)
                         buildResult,
                         duration));
                 }
-
-                if (_testRunSummaries.Any())
-                {
-                    var total = _testRunSummaries.Sum(t => t.Total);
-                    var failed = _testRunSummaries.Sum(t => t.Failed);
-                    var passed = _testRunSummaries.Sum(t => t.Passed);
-                    var skipped = _testRunSummaries.Sum(t => t.Skipped);
-                    var testDuration = (_testStartTime != null && _testEndTime != null ? (_testEndTime - _testStartTime).Value.TotalSeconds : 0).ToString("F1");
-
-                    var colorizedResult = _testRunSummaries.Any(t => t.Failed > 0) || (_buildErrorsCount > 0)
-                        ? AnsiCodes.Colorize(ResourceUtilities.GetResourceString("BuildResult_Failed"), TerminalColor.Red)
-                        : AnsiCodes.Colorize(ResourceUtilities.GetResourceString("BuildResult_Succeeded"), TerminalColor.Green);
-
-                    Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("TestSummary",
-                        colorizedResult,
-                        total,
-                        failed,
-                        passed,
-                        skipped,
-                        testDuration));
-                }
             }
         }
         finally
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 213b842ae6a..3b993859747 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -717,6 +717,7 @@ public static ExitType Execute(
                 string[] inputResultsCaches = null;
                 string outputResultsCache = null;
                 bool question = false;
+                bool isBuildCheckEnabled = false;
                 string[] getProperty = Array.Empty<string>();
                 string[] getItem = Array.Empty<string>();
                 string[] getTargetResult = Array.Empty<string>();
@@ -764,6 +765,7 @@ public static ExitType Execute(
 #endif
                                             ref lowPriority,
                                             ref question,
+                                            ref isBuildCheckEnabled,
                                             ref getProperty,
                                             ref getItem,
                                             ref getTargetResult,
@@ -866,6 +868,7 @@ public static ExitType Execute(
                                     graphBuildOptions,
                                     lowPriority,
                                     question,
+                                    isBuildCheckEnabled,
                                     inputResultsCaches,
                                     outputResultsCache,
                                     saveProjectResult: outputPropertiesItemsOrTargetResults,
@@ -1252,6 +1255,7 @@ internal static bool BuildProject(
             GraphBuildOptions graphBuildOptions,
             bool lowPriority,
             bool question,
+            bool isBuildCheckEnabled,
             string[] inputResultsCaches,
             string outputResultsCache,
             bool saveProjectResult,
@@ -1453,6 +1457,7 @@ internal static bool BuildProject(
                     parameters.InputResultsCacheFiles = inputResultsCaches;
                     parameters.OutputResultsCacheFile = outputResultsCache;
                     parameters.Question = question;
+                    parameters.IsBuildCheckEnabled = isBuildCheckEnabled;
 #if FEATURE_REPORTFILEACCESSES
                     parameters.ReportFileAccesses = reportFileAccesses;
 #endif
@@ -2447,6 +2452,7 @@ private static bool ProcessCommandLineSwitches(
 #endif
             ref bool lowPriority,
             ref bool question,
+            ref bool isBuildCheckEnabled,
             ref string[] getProperty,
             ref string[] getItem,
             ref string[] getTargetResult,
@@ -2577,6 +2583,7 @@ private static bool ProcessCommandLineSwitches(
 #endif
                                                            ref lowPriority,
                                                            ref question,
+                                                           ref isBuildCheckEnabled,
                                                            ref getProperty,
                                                            ref getItem,
                                                            ref getTargetResult,
@@ -2662,6 +2669,8 @@ private static bool ProcessCommandLineSwitches(
 
                     question = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Question);
 
+                    isBuildCheckEnabled = IsBuildCheckEnabled(commandLineSwitches);
+
                     inputResultsCaches = ProcessInputResultsCaches(commandLineSwitches);
 
                     outputResultsCache = ProcessOutputResultsCache(commandLineSwitches);
@@ -2734,6 +2743,13 @@ private static bool ProcessCommandLineSwitches(
             return invokeBuild;
         }
 
+        private static bool IsBuildCheckEnabled(CommandLineSwitches commandLineSwitches)
+        {
+            // Opt-in behavior to be determined by: https://github.com/dotnet/msbuild/issues/9723
+            bool isAnalysisEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Analyze);
+            return isAnalysisEnabled;
+        }
+
         private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)
         {
             aggregatedParameters = AggregateParameters(commandLineSwitches);
diff --git a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
index 9e4f47ac424..845c52c7b8c 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
+++ b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
@@ -21,6 +21,7 @@ folder InstallDir:\MSBuild\Current\Bin\arm64
   file source=$(Arm64BinPath)Microsoft.Common.overridetasks
   file source=$(Arm64BinPath)Microsoft.Common.targets
   file source=$(Arm64BinPath)Microsoft.Common.tasks
+  file source=$(Arm64BinPath)Microsoft.Common.Test.targets
   file source=$(Arm64BinPath)Microsoft.Managed.targets
   file source=$(Arm64BinPath)Microsoft.Managed.Before.targets
   file source=$(Arm64BinPath)Microsoft.Managed.After.targets
diff --git a/src/Shared/IsExternalInit.cs b/src/Shared/IsExternalInit.cs
new file mode 100644
index 00000000000..ae2ffb321cd
--- /dev/null
+++ b/src/Shared/IsExternalInit.cs
@@ -0,0 +1,9 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace System.Runtime.CompilerServices
+{
+    // Needed so we can use init setters in full fw or netstandard
+    //  (details: https://developercommunity.visualstudio.com/t/error-cs0518-predefined-type-systemruntimecompiler/1244809)
+    internal static class IsExternalInit { }
+}
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 81eacb5e604..291594fcfdc 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -9,6 +9,11 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 
+#if !TASKHOST
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.BuildCheck.Infrastructure;
+#endif
+
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
 using Microsoft.Build.Collections;
 using Microsoft.Build.Framework.Profiler;
@@ -210,6 +215,31 @@ internal enum LoggingEventType : int
         /// Event is a <see cref="GeneratedFileUsedEventArgs"/>
         /// </summary>
         GeneratedFileUsedEvent = 34,
+        
+        /// <summary>
+        /// Event is <see cref="BuildCheckResultMessage"/>
+        /// </summary>
+        BuildCheckMessageEvent = 35,
+
+        /// <summary>
+        /// Event is <see cref="BuildCheckResultWarning"/>
+        /// </summary>
+        BuildCheckWarningEvent = 36,
+
+        /// <summary>
+        /// Event is <see cref="BuildCheckResultError"/>
+        /// </summary>
+        BuildCheckErrorEvent = 37,
+
+        /// <summary>
+        /// Event is <see cref="BuildCheckTracingEventArgs"/>
+        /// </summary>
+        BuildCheckTracingEvent = 38,
+
+        /// <summary>
+        /// Event is <see cref="BuildCheckAcquisitionEventArgs"/>
+        /// </summary>
+        BuildCheckAcquisitionEvent = 39,
     }
     #endregion
 
@@ -617,6 +647,11 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.PropertyReassignment => new PropertyReassignmentEventArgs(),
                 LoggingEventType.UninitializedPropertyRead => new UninitializedPropertyReadEventArgs(),
                 LoggingEventType.GeneratedFileUsedEvent => new GeneratedFileUsedEventArgs(),
+                LoggingEventType.BuildCheckMessageEvent => new BuildCheckResultMessage(),
+                LoggingEventType.BuildCheckWarningEvent => new BuildCheckResultWarning(),
+                LoggingEventType.BuildCheckErrorEvent => new BuildCheckResultError(),
+                LoggingEventType.BuildCheckAcquisitionEvent => new BuildCheckAcquisitionEventArgs(),
+                LoggingEventType.BuildCheckTracingEvent => new BuildCheckTracingEventArgs(),
 #endif
                 _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
             };
@@ -732,6 +767,26 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.GeneratedFileUsedEvent;
             }
+            else if (eventType == typeof(BuildCheckResultMessage))
+            {
+                return LoggingEventType.BuildCheckMessageEvent;
+            }
+            else if (eventType == typeof(BuildCheckResultWarning))
+            {
+                return LoggingEventType.BuildCheckWarningEvent;
+            }
+            else if (eventType == typeof(BuildCheckResultError))
+            {
+                return LoggingEventType.BuildCheckErrorEvent;
+            }
+            else if (eventType == typeof(BuildCheckAcquisitionEventArgs))
+            {
+                return LoggingEventType.BuildCheckAcquisitionEvent;
+            }
+            else if (eventType == typeof(BuildCheckTracingEventArgs))
+            {
+                return LoggingEventType.BuildCheckTracingEvent;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 38700fed179..bbba6eab034 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Reflection;
 using System.Text;
 using Microsoft.Build.Evaluation;
@@ -169,7 +170,10 @@ public void Timeout()
             Assert.False(result);
             Assert.Equal(expectedExitCode, exec.ExitCode);
             ((MockEngine)exec.BuildEngine).AssertLogContains("MSB5002");
-            Assert.Equal(1, ((MockEngine)exec.BuildEngine).Warnings);
+            int warningsCount = ((MockEngine)exec.BuildEngine).Warnings;
+            warningsCount.ShouldBe(1,
+                $"Expected 1 warning, encountered {warningsCount}: " + string.Join(",",
+                    ((MockEngine)exec.BuildEngine).WarningEvents.Select(w => w.Message)));
 
             // ToolTask does not log an error on timeout.
             Assert.Equal(0, ((MockEngine)exec.BuildEngine).Errors);
diff --git a/src/UnitTests.Shared/BootstrapLocationAttribute.cs b/src/UnitTests.Shared/BootstrapLocationAttribute.cs
new file mode 100644
index 00000000000..7f8627a69b3
--- /dev/null
+++ b/src/UnitTests.Shared/BootstrapLocationAttribute.cs
@@ -0,0 +1,13 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
+namespace Microsoft.Build.UnitTests.Shared;
+
+[System.AttributeUsage(System.AttributeTargets.Assembly)]
+internal sealed class BootstrapLocationAttribute(string bootstrapMsbuildBinaryLocation)
+    : System.Attribute
+{
+    public string BootstrapMsbuildBinaryLocation { get; } = bootstrapMsbuildBinaryLocation;
+}
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 0bade6a09d5..fee3abf670f 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -1,6 +1,6 @@
 <Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
-    <TargetFrameworks>$(FullFrameworkTFM);$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
+    <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <AssemblyName>Microsoft.Build.UnitTests.Shared</AssemblyName>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
     <IsShipping>false</IsShipping>
@@ -18,5 +18,21 @@
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
+    <ProjectReference Include="..\MSBuild.Bootstrap\MSBuild.Bootstrap.csproj">
+      <Private>false</Private>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+
+  <ItemGroup>
+    <Compile Include="..\Shared\IsExternalInit.cs" />
+  </ItemGroup>
+
+  <Import Project="..\..\eng\BootStrapMsBuild.props" />
+
+  <ItemGroup>
+    <AssemblyAttribute Include="Microsoft.Build.UnitTests.Shared.BootstrapLocationAttribute">
+      <_Parameter1>$(BootstrapBinaryDestination)</_Parameter1>
+    </AssemblyAttribute>
   </ItemGroup>
 </Project>
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index c1e96f7a6cb..6310534a391 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -4,7 +4,11 @@
 using System;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
+using System.IO;
+using System.Reflection;
+using Microsoft.Build.Framework;
 using Xunit.Abstractions;
+using System.Linq;
 
 #nullable disable
 
@@ -48,6 +52,21 @@ public static string ExecMSBuild(string pathToMsBuildExe, string msbuildParamete
             return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper);
         }
 
+        public static string ExecBootstrapedMSBuild(string msbuildParameters, out bool successfulExit, bool shellExecute = false, ITestOutputHelper outputHelper = null)
+        {
+            BootstrapLocationAttribute attribute = Assembly.GetExecutingAssembly().GetCustomAttribute<BootstrapLocationAttribute>()
+                                                   ?? throw new InvalidOperationException("This test assembly does not have the BootstrapLocationAttribute");
+
+            string binaryFolder = attribute.BootstrapMsbuildBinaryLocation;
+#if NET
+            string pathToExecutable = EnvironmentProvider.GetDotnetExePath()!;
+            msbuildParameters = Path.Combine(binaryFolder, "MSBuild.dll") + " " + msbuildParameters;
+#else
+            string pathToExecutable = Path.Combine(binaryFolder, "MSBuild.exe");
+#endif
+            return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper);
+        }
+
         private static void AdjustForShellExecution(ref string pathToExecutable, ref string arguments)
         {
             if (NativeMethodsShared.IsWindows)
@@ -108,7 +127,11 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
                 p.BeginErrorReadLine();
                 p.StandardInput.Dispose();
 
-                if (!p.WaitForExit(30_000))
+                if (Traits.Instance.DebugUnitTests)
+                {
+                    p.WaitForExit();
+                }
+                else if (!p.WaitForExit(30_000))
                 {
                     // Let's not create a unit test for which we need more than 30 sec to execute.
                     // Please consider carefully if you would like to increase the timeout.
diff --git a/src/UnitTests.Shared/TestEnvironment.cs b/src/UnitTests.Shared/TestEnvironment.cs
index 86e85d3cd51..d961178b298 100644
--- a/src/UnitTests.Shared/TestEnvironment.cs
+++ b/src/UnitTests.Shared/TestEnvironment.cs
@@ -53,6 +53,10 @@ public static TestEnvironment Create(ITestOutputHelper output = null, bool ignor
                 env.WithInvariant(new BuildFailureLogInvariant());
             }
 
+            // Clear these two environment variables first in case pre-setting affects the test.
+            env.SetEnvironmentVariable("MSBUILDLIVELOGGER", null);
+            env.SetEnvironmentVariable("MSBUILDTERMINALLOGGER", null);
+
             return env;
         }
 
@@ -83,10 +87,10 @@ private void Cleanup()
             {
                 _disposed = true;
 
-                // Reset test variants
-                foreach (var variant in _variants)
+                // Reset test variants in reverse order to get back to original state.
+                for (int i = _variants.Count - 1; i >= 0; i--)
                 {
-                    variant.Revert();
+                    _variants[i].Revert();
                 }
 
                 // Assert invariants
diff --git a/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json b/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
new file mode 100644
index 00000000000..52c4467e930
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
@@ -0,0 +1,49 @@
+{
+    "$schema": "http://json.schemastore.org/template",
+    "author": "Microsoft",
+    "classifications": [
+      "Common",
+      "Library"
+    ],
+    "name": "MSBuild custom analyzer skeleton project.",
+    "generatorVersions": "[1.0.0.0-*)",
+    "description": "A project for creating a MSBuild analyzer library that targets .NET Standard",
+    "groupIdentity": "Microsoft.AnalyzerTemplate",
+    "identity": "Microsoft.AnalyzerTemplate",
+    "shortName": "msbuildanalyzer",
+    "tags": {
+      "language": "C#",
+      "type": "project"
+    },
+    "sourceName": "Company.AnalyzerTemplate",
+    "preferNameDirectory": true,
+    "primaryOutputs": [
+      {
+        "path": "Company.AnalyzerTemplate.csproj"
+      }
+   ],
+   "symbols": {
+    "MicrosoftBuildVersion": {
+      "type": "parameter",
+      "description": "Overrides the default Microsoft.Build version where analyzer's interfaces are placed",
+      "datatype": "text",
+      "defaultValue": "17.11.0",
+      "replaces": "1.0.0-MicrosoftBuildPackageVersion",
+      "displayName": "Microsoft.Build default package version override"
+    }
+   },
+    "postActions": [
+      {
+        "id": "restore",
+        "condition": "(!skipRestore)",
+        "description": "Restore NuGet packages required by this project.",
+        "manualInstructions": [
+          {
+            "text": "Run 'dotnet restore'"
+          }
+        ],
+        "actionId": "210D431B-A78B-4D2F-B762-4ED3E3EA9025",
+        "continueOnError": true
+      }
+    ]
+  }
\ No newline at end of file
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs b/template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs
new file mode 100644
index 00000000000..e6d225f21dd
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs
@@ -0,0 +1,34 @@
+﻿using System;
+
+namespace Company.AnalyzerTemplate
+{
+    public sealed class Analyzer1 : BuildAnalyzer
+    {
+        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("X01234", "Title",
+            "Description", "Category",
+            "Message format: {0}",
+            new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+
+        public override string FriendlyName => "Company.Analyzer1";
+
+        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } =[SupportedRule];
+
+        public override void Initialize(ConfigurationContext configurationContext)
+        {
+            // configurationContext to be used only if analyzer needs external configuration data.
+        }
+
+        public override void RegisterActions(IBuildCopRegistrationContext registrationContext)
+        {
+            registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+        }
+        
+        private void EvaluatedPropertiesAction(BuildCopDataContext<EvaluatedPropertiesAnalysisData> context)
+        {
+            context.ReportResult(BuildCopResult.Create(
+                SupportedRule,
+                ElementLocation.EmptyLocation,
+                "Argument for the message format");
+        }
+    }
+}
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj b/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
new file mode 100644
index 00000000000..b18c65a87dd
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
@@ -0,0 +1,45 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <TargetFramework>netstandard2.0</TargetFramework>
+    <DevelopmentDependency>true</DevelopmentDependency>
+    <IncludeBuildOutput>false</IncludeBuildOutput>
+    <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
+    <!-- The output structure was modified for msbuild development needs.-->
+    <NoWarn>NU5101;NU5128</NoWarn>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <None Include="Directory.Build.props" Pack="true" PackagePath="build\Directory.Build.props" />
+    <Content Include="README.md" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <!-- Please add IncludeInPackage field to all third party dependencies. See the example below.-->
+    <PackageReference Include="Microsoft.Build" PrivateAssets="all" IncludeInPackage="true" />
+  </ItemGroup>
+
+  <Target Name="AddNuGetDlls" BeforeTargets="_GetPackageFiles">
+    <!-- Merge the collection of PackageReference and Assemblies using the NuGetPackageId key.
+       This produces a new list containing the DLL path and the "IncludeInPackage" metadata-->
+    <JoinItems Left="@(ResolvedCompileFileDefinitions)" LeftKey="NuGetPackageId" LeftMetadata="*" Right="@(PackageReference)" RightKey="" RightMetadata="*" ItemSpecToUse="Left">
+    <Output TaskParameter="JoinResult" ItemName="_PackagesToPack" />
+    </JoinItems>
+
+    <ItemGroup>
+    <!-- Remove NETStandard DLLs -->
+    <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(NuGetPackageId) == 'NETStandard.Library'" />
+    <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(_PackagesToPack.IncludeInPackage) != 'true'" />
+    </ItemGroup>
+
+    <Message Importance="High" Text="Adding DLLs from the following packages: @(_PackagesToPack->'%(NuGetPackageId)')" />
+
+    <ItemGroup>
+    <!-- Update the collection of items to pack with the DLLs from the NuGet packages -->
+    <None Include="@(_PackagesToPack)" Pack="true" PackagePath="lib" Visible="false" />
+
+    <!-- Add the DLL produced by the current project to the NuGet package -->
+    <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="lib" Visible="false" />
+    </ItemGroup>
+  </Target>
+</Project>
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Directory.Build.props b/template_feed/Microsoft.AnalyzerTemplate/Directory.Build.props
new file mode 100644
index 00000000000..3b752b831cc
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/Directory.Build.props
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildAnalyzer>$([MSBuild]::RegisterAnalyzer($(MSBuildThisFileDirectory)..\lib\Company.AnalyzerTemplate.dll))</MSBuildAnalyzer>
+  </PropertyGroup>
+  <ItemGroup>
+    <PackageVersion Include="Microsoft.Build" Version="1.0.0-MicrosoftBuildPackageVersion" />
+  </ItemGroup>
+</Project>
diff --git a/template_feed/Microsoft.AnalyzerTemplate/README.md b/template_feed/Microsoft.AnalyzerTemplate/README.md
new file mode 100644
index 00000000000..4f29145e7f0
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Analyzer Template
+
+## Overview
+MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild analyzer libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom analysis rules.
+
+## Getting Started
+To use the MSBuild Custom Analyzer Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildanalyzer
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildanalyzer -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
\ No newline at end of file
