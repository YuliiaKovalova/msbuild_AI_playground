diff --git a/.editorconfig b/.editorconfig
index 4a47432ae4f..90ed95160d4 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -15,6 +15,9 @@ trim_trailing_whitespace = true
 [project.json]
 indent_size = 2
 
+[*.txt]
+insert_final_newline = false
+
 # C# files
 [*.cs]
 # New line preferences
@@ -210,7 +213,7 @@ dotnet_analyzer_diagnostic.category-Style.severity = warning
 dotnet_diagnostic.IDE0004.severity = suggestion
 
 # IDE0005: Remove unnecessary usings/imports
-dotnet_diagnostic.IDE0005.severity = warning
+dotnet_diagnostic.IDE0005.severity = none
 
 # Use explicit type instead of 'var'
 dotnet_diagnostic.IDE0008.severity = suggestion
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 38f88c99b08..d538f655a85 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -234,8 +234,4 @@ jobs:
     continueOnError: true
     condition: always()
 
-- template: /eng/common/templates/job/source-build.yml
-  parameters:
-    platform:
-      name: 'Managed'
-      container: 'mcr.microsoft.com/dotnet-buildtools/prereqs:centos-7'
+- template: /eng/common/templates/jobs/source-build.yml
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 62ce1c7f273..343cec26283 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -265,7 +265,7 @@ stages:
     - task: ms-vseng.MicroBuildTasks.521a94ea-9e68-468a-8167-6dcf361ea776.MicroBuildCleanup@1
       displayName: Execute cleanup tasks
       condition: succeededOrFailed()
-      
+
     - template: /eng/common/templates/steps/component-governance.yml
       parameters:
         ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), or(startsWith(variables['Build.SourceBranch'], 'refs/heads/vs'), eq(variables['Build.SourceBranch'], 'refs/heads/main'))) }}:
@@ -273,11 +273,7 @@ stages:
         ${{ else }}:
           disableComponentGovernance: true
 
-  - template: /eng/common/templates/job/source-build.yml
-    parameters:
-      platform:
-        name: 'Managed'
-        container: 'mcr.microsoft.com/dotnet-buildtools/prereqs:centos-7'
+  - template: /eng/common/templates/jobs/source-build.yml
 
   - template: /eng/common/templates/job/publish-build-assets.yml
     parameters:
diff --git a/NuGet.config b/NuGet.config
index 744064495eb..4e9907ea835 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -6,7 +6,8 @@
     <add key="dotnet-public" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public/nuget/v3/index.json" />
     <add key="dotnet-tools" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json" />
     <add key="dotnet6" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json" />
-    <add key="msbuild17.7" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/darc-pub-DotNet-msbuild-Trusted-5785ed5c/nuget/v3/index.json" />
+    <add key="dotnet8" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json" />
+    <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
   </packageSources>
   <disabledPackageSources />
 </configuration>
diff --git a/documentation/README.md b/documentation/README.md
index ec88f6bcae7..199be8361fb 100644
--- a/documentation/README.md
+++ b/documentation/README.md
@@ -74,7 +74,7 @@ The folder contains collection of docs and references for MSBuild, detailed info
 ### Logging
 
 * [Binary log](wiki/Binary-Log.md)
-* [Live logger: how to opt in](livelogger/Opt-In-Mechanism.md)
+* [Terminal logger: how to opt in](terminallogger/Opt-In-Mechanism.md)
 
 ## Archived Designs
 * [Resolve Assembly Reference as a service](specs/rar-as-service.md)
diff --git a/documentation/terminallogger/Opt-In-Mechanism.md b/documentation/terminallogger/Opt-In-Mechanism.md
index 2092a1feaba..f6d63e7f4ac 100644
--- a/documentation/terminallogger/Opt-In-Mechanism.md
+++ b/documentation/terminallogger/Opt-In-Mechanism.md
@@ -15,7 +15,7 @@ Using the `/terminallogger` or `/tl` command line switches, users are able to op
 
 ### Enabling for all builds
 
-Users can set the `MSBUILDLIVELOGGER` environment variable to enable TerminalLogger without adding a swtich to all build invocations.
+Users can set the `MSBUILDTERMINALLOGGER` environment variable to enable TerminalLogger without adding a swtich to all build invocations.
 
 ### TerminalLogger parameters
 
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index d002c7c00b4..02e1e308112 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -68,6 +68,9 @@
     <ItemGroup>
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\*.targets" />
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\*.props" />
+      <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\Tracker*.dll" />
+      <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\Tracker*.exe" />
+      <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\FileTracker*.dll" />
       <SdkResolverFiles Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\**\*.*" />
       <NuGetSdkResolverManifest Include= "$(RepoRoot)src\MSBuild\SdkResolvers\VS\Microsoft.Build.NuGetSdkResolver.xml" Condition="'$(MonoBuild)' != 'true'" />
       <NuGetSdkResolverManifest Include= "$(RepoRoot)src\MSBuild\SdkResolvers\Standalone\Microsoft.Build.NuGetSdkResolver.xml" Condition="'$(MonoBuild)' == 'true'" />
diff --git a/eng/Packages.props b/eng/Packages.props
index 3c231e9c52c..ac8df77f629 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -29,8 +29,6 @@
     <PackageVersion Include="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
     <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
     <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
-    <PackageVersion Include="xunit.assert" Version="$(XUnitVersion)" />
     <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
-    <PackageVersion Include="xunit.core" Version="$(XUnitVersion)" />
   </ItemGroup>
 </Project>
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 55d6f6f03d1..15a527720b7 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -5,38 +5,14 @@
   <IgnorePatterns>
     <UsagePattern IdentityGlob="Microsoft.SourceBuild.Intermediate.*/*" />
 
-    <!-- These dependencies are a result of building for netframework TFMs. These are filtered out
-         in full source-build, and would be filtered out if msbuild was using an 8.0 arcade + 8.0 SDK -->
-         <UsagePattern IdentityGlob="Microsoft.NETFramework.ReferenceAssemblies/*1.0.3*" />
-         <UsagePattern IdentityGlob="Microsoft.NETFramework.ReferenceAssemblies.net472/*1.0.3*" />
-
     <!-- Baseline 7.0 dependencies until msbuild targets net8 and uses a net8 arcade, SBRP, etc.
          These cannot be added to 7.0 SBRP, because they would are produced in the 7.0 build. -->
-    <UsagePattern IdentityGlob="Microsoft.Bcl.AsyncInterfaces/*7.0.0*" />
-    <UsagePattern IdentityGlob="Microsoft.Win32.SystemEvents/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.CodeDom/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Collections.Immutable/*7.0.0*" />
     <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*7.0.0*" />
     <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Drawing.Common/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Formats.Asn1/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Reflection.Metadata/*7.0.0*" />
     <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Resources.Extensions/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*7.0.2*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*7.0.1*" />
-    <UsagePattern IdentityGlob="System.Text.Encoding.CodePages/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Encodings.Web/*7.0.0*" />
     <UsagePattern IdentityGlob="System.Text.Json/*7.0.3*" />
-    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Windows.Extensions/*7.0.0*" />
   </IgnorePatterns>
   <Usages>
-    <Usage Id="Microsoft.Build.Tasks.Git" Version="8.0.0-beta.23211.2" />
-    <Usage Id="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23211.1" IsDirectDependency="true" IsAutoReferenced="true" />
-    <Usage Id="Microsoft.SourceLink.AzureRepos.Git" Version="8.0.0-beta.23211.2" IsDirectDependency="true" IsAutoReferenced="true" />
-    <Usage Id="Microsoft.SourceLink.Common" Version="8.0.0-beta.23211.2" />
-    <Usage Id="Microsoft.SourceLink.GitHub" Version="8.0.0-beta.23211.2" IsDirectDependency="true" IsAutoReferenced="true" />
   </Usages>
 </UsageData>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index b8add39cd0f..2758bb113ec 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,11 +1,16 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ProductDependencies>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="7.0.0-alpha.1.23219.1">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.23428.2">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>525b6c35cc5c5c9b80b47044be2e4e77858d505a</Sha>
+      <Sha>26ce96327dd346534926c4551f8b8d62a6fc724f</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.CodeDom" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
     <!-- Necessary for source-build due to being a transitive dependency of System.Reflection.MetadataLoadContext.
       This allows the package to be retrieved from previously-source-built artifacts and flow in as dependencies
       of the packages produced by msbuild. -->
@@ -31,41 +36,55 @@
       <Uri>https://github.com/dotnet/runtime</Uri>
       <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
     </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Resources.Extensions" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
     <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
       and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Security.Cryptography.Pkcs" Version="7.0.0">
+    <Dependency Name="System.Security.Cryptography.Pkcs" Version="7.0.2">
       <Uri>https://github.com/dotnet/runtime</Uri>
       <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
     </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Security.Cryptography.Xml" Version="7.0.1">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Security.Permissions" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
+    <Dependency Name="System.Text.Json" Version="7.0.3">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>5b20af47d99620150c53eaf5db8636fdf730b126</Sha>
+    </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23213.1">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23425.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>fb14cae30eacbe844468ac297b3d4c61e0bb9dc0</Sha>
+      <Sha>90c167d5c57de4a8bced566379dbd893556c94e8</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.SourceLink.GitHub" Version="8.0.0-beta.23211.2" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
-      <Uri>https://github.com/dotnet/sourcelink</Uri>
-      <Sha>4cf2eb17c295905edeca76a9afe6dda42988359e</Sha>
-      <SourceBuild RepoName="sourcelink" ManagedOnly="true" />
-    </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23211.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23423.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
       <Uri>https://github.com/dotnet/xliff-tasks</Uri>
-      <Sha>ce5066cd85c138c257a981f9c95257e9c577a5ee</Sha>
+      <Sha>ed9a83526483c094fb51e7000b6f816ce6cb0325</Sha>
       <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.7.0-rc.111">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.8.0-preview.1.82">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>13f2b6af6e9864711e815cfbffd7aa5015c52cec</Sha>
+      <Sha>7bb6ca5f6930d23fd93820dfc9c6a4373c8fd691</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.7.0-3.23361.9">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.8.0-2.23426.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>91c9c05370d84a902010c9e1f80aebcc3a467792</Sha>
+      <Sha>34268d1bb9370c7b01c742303a895a99daf10d6a</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23313.5">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.23425.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>91616785a1a6578c83f7e93d98c34a1eb83d6223</Sha>
+      <Sha>90c167d5c57de4a8bced566379dbd893556c94e8</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 7a14d0aced2..58866d8cc69 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -48,15 +48,14 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23313.5</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.23425.2</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.7.0-3.23361.9</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.7.0-rc.111</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.8.0-2.23426.1</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.8.0-preview.1.82</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.3</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
-    <XunitVersion>2.4.2</XunitVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index b7c52ebd20f..46d471d042b 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -92,7 +92,7 @@ try {
   {
     $buildToolPath = $dotnetExePath
     $buildToolCommand = Join-Path $bootstrapRoot "net8.0\MSBuild\MSBuild.dll"
-    $buildToolFramework = "netcoreapp3.1"
+    $buildToolFramework = "net8.0"
   }
 
   # Use separate artifacts folder for stage 2
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index 07e6ae8036e..ceb2b343329 100755
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -64,7 +64,7 @@ if [ $host_type = "core" ]
 then
   _InitializeBuildTool="$_InitializeDotNetCli/dotnet"
   _InitializeBuildToolCommand="$bootstrapRoot/net8.0/MSBuild/MSBuild.dll"
-  _InitializeBuildToolFramework="netcoreapp3.1"
+  _InitializeBuildToolFramework="net8.0"
 elif [ $host_type = "mono" ]
 then
   export _InitializeBuildTool="mono"
diff --git a/eng/common/SetupNugetSources.ps1 b/eng/common/SetupNugetSources.ps1
index 6e997239451..6c65e81925f 100644
--- a/eng/common/SetupNugetSources.ps1
+++ b/eng/common/SetupNugetSources.ps1
@@ -153,7 +153,7 @@ if ($dotnet31Source -ne $null) {
     AddPackageSource -Sources $sources -SourceName "dotnet3.1-internal-transport" -SourceEndPoint "https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v2" -Creds $creds -Username $userName -Password $Password
 }
 
-$dotnetVersions = @('5','6','7')
+$dotnetVersions = @('5','6','7','8')
 
 foreach ($dotnetVersion in $dotnetVersions) {
     $feedPrefix = "dotnet" + $dotnetVersion;
diff --git a/eng/common/SetupNugetSources.sh b/eng/common/SetupNugetSources.sh
index 8af7d899db1..d387c7eac95 100644
--- a/eng/common/SetupNugetSources.sh
+++ b/eng/common/SetupNugetSources.sh
@@ -105,7 +105,7 @@ if [ "$?" == "0" ]; then
     PackageSources+=('dotnet3.1-internal-transport')
 fi
 
-DotNetVersions=('5' '6' '7')
+DotNetVersions=('5' '6' '7' '8')
 
 for DotNetVersion in ${DotNetVersions[@]} ; do
     FeedPrefix="dotnet${DotNetVersion}";
diff --git a/eng/common/cross/build-rootfs.sh b/eng/common/cross/build-rootfs.sh
index 1deadcc676e..9caf9b021db 100755
--- a/eng/common/cross/build-rootfs.sh
+++ b/eng/common/cross/build-rootfs.sh
@@ -27,6 +27,7 @@ __AlpineArch=armv7
 __FreeBSDArch=arm
 __FreeBSDMachineArch=armv7
 __IllumosArch=arm7
+__HaikuArch=arm
 __QEMUArch=arm
 __UbuntuArch=armhf
 __UbuntuRepo="http://ports.ubuntu.com/"
@@ -70,7 +71,7 @@ __AlpinePackages+=" krb5-dev"
 __AlpinePackages+=" openssl-dev"
 __AlpinePackages+=" zlib-dev"
 
-__FreeBSDBase="12.3-RELEASE"
+__FreeBSDBase="12.4-RELEASE"
 __FreeBSDPkg="1.17.0"
 __FreeBSDABI="12"
 __FreeBSDPackages="libunwind"
@@ -85,8 +86,12 @@ __IllumosPackages+=" mit-krb5"
 __IllumosPackages+=" openssl"
 __IllumosPackages+=" zlib"
 
-__HaikuPackages="gmp"
+__HaikuPackages="gcc_syslibs"
+__HaikuPackages+=" gcc_syslibs_devel"
+__HaikuPackages+=" gmp"
 __HaikuPackages+=" gmp_devel"
+__HaikuPackages+=" icu66"
+__HaikuPackages+=" icu66_devel"
 __HaikuPackages+=" krb5"
 __HaikuPackages+=" krb5_devel"
 __HaikuPackages+=" libiconv"
@@ -95,6 +100,10 @@ __HaikuPackages+=" llvm12_libunwind"
 __HaikuPackages+=" llvm12_libunwind_devel"
 __HaikuPackages+=" mpfr"
 __HaikuPackages+=" mpfr_devel"
+__HaikuPackages+=" openssl"
+__HaikuPackages+=" openssl_devel"
+__HaikuPackages+=" zlib"
+__HaikuPackages+=" zlib_devel"
 
 # ML.NET dependencies
 __UbuntuPackages+=" libomp5"
@@ -210,6 +219,7 @@ while :; do
             __FreeBSDArch=amd64
             __FreeBSDMachineArch=amd64
             __illumosArch=x86_64
+            __HaikuArch=x86_64
             __UbuntuRepo="http://archive.ubuntu.com/ubuntu/"
             ;;
         x86)
@@ -330,7 +340,7 @@ while :; do
             ;;
         freebsd13)
             __CodeName=freebsd
-            __FreeBSDBase="13.0-RELEASE"
+            __FreeBSDBase="13.2-RELEASE"
             __FreeBSDABI="13"
             __SkipUnmount=1
             ;;
@@ -340,7 +350,6 @@ while :; do
             ;;
         haiku)
             __CodeName=haiku
-            __BuildArch=x64
             __SkipUnmount=1
             ;;
         --skipunmount)
@@ -559,67 +568,54 @@ elif [[ "$__CodeName" == "illumos" ]]; then
 elif [[ "$__CodeName" == "haiku" ]]; then
     JOBS=${MAXJOBS:="$(getconf _NPROCESSORS_ONLN)"}
 
-    echo "Building Haiku sysroot for x86_64"
+    echo "Building Haiku sysroot for $__HaikuArch"
     mkdir -p "$__RootfsDir/tmp"
-    cd "$__RootfsDir/tmp"
-    git clone -b hrev56235  https://review.haiku-os.org/haiku
-    git clone -b btrev43195 https://review.haiku-os.org/buildtools
-    cd "$__RootfsDir/tmp/buildtools" && git checkout 7487388f5110021d400b9f3b88e1a7f310dc066d
-
-    # Fetch some unmerged patches
-    cd "$__RootfsDir/tmp/haiku"
-    ## Add development build profile (slimmer than nightly)
-    git fetch origin refs/changes/64/4164/1 && git -c commit.gpgsign=false cherry-pick FETCH_HEAD
-
-    # Build jam
-    cd "$__RootfsDir/tmp/buildtools/jam"
-    make
-
-    # Configure cross tools
-    echo "Building cross-compiler"
-    mkdir -p "$__RootfsDir/generated"
-    cd "$__RootfsDir/generated"
-    "$__RootfsDir/tmp/haiku/configure" -j"$JOBS" --sysroot "$__RootfsDir" --cross-tools-source "$__RootfsDir/tmp/buildtools" --build-cross-tools x86_64
-
-    # Build Haiku packages
-    echo "Building Haiku"
-    echo 'HAIKU_BUILD_PROFILE = "development-raw" ;' > UserProfileConfig
-    "$__RootfsDir/tmp/buildtools/jam/jam0" -j"$JOBS" -q '<build>package' '<repository>Haiku'
-
-    BaseUrl="https://depot.haiku-os.org/__api/v2/pkg/get-pkg"
-
-    # Download additional packages
-    echo "Downloading additional required packages"
+    pushd "$__RootfsDir/tmp"
+
+    mkdir "$__RootfsDir/tmp/download"
+
+    echo "Downloading Haiku package tool"
+    git clone https://github.com/haiku/haiku-toolchains-ubuntu --depth 1 $__RootfsDir/tmp/script
+    wget -O "$__RootfsDir/tmp/download/hosttools.zip" $($__RootfsDir/tmp/script/fetch.sh --hosttools)
+    unzip -o "$__RootfsDir/tmp/download/hosttools.zip" -d "$__RootfsDir/tmp/bin"
+
+    DepotBaseUrl="https://depot.haiku-os.org/__api/v2/pkg/get-pkg"
+    HpkgBaseUrl="https://eu.hpkg.haiku-os.org/haiku/master/$__HaikuArch/current"
+
+    # Download Haiku packages
+    echo "Downloading Haiku packages"
     read -ra array <<<"$__HaikuPackages"
     for package in "${array[@]}"; do
         echo "Downloading $package..."
         # API documented here: https://github.com/haiku/haikudepotserver/blob/master/haikudepotserver-api2/src/main/resources/api2/pkg.yaml#L60
         # The schema here: https://github.com/haiku/haikudepotserver/blob/master/haikudepotserver-api2/src/main/resources/api2/pkg.yaml#L598
-        hpkgDownloadUrl="$(wget -qO- --post-data='{"name":"'"$package"'","repositorySourceCode":"haikuports_x86_64","versionType":"LATEST","naturalLanguageCode":"en"}' \
-            --header='Content-Type:application/json' "$BaseUrl" | jq -r '.result.versions[].hpkgDownloadURL')"
-        wget -P "$__RootfsDir/generated/download" "$hpkgDownloadUrl"
+        hpkgDownloadUrl="$(wget -qO- --post-data='{"name":"'"$package"'","repositorySourceCode":"haikuports_'$__HaikuArch'","versionType":"LATEST","naturalLanguageCode":"en"}' \
+            --header='Content-Type:application/json' "$DepotBaseUrl" | jq -r '.result.versions[].hpkgDownloadURL')"
+        wget -P "$__RootfsDir/tmp/download" "$hpkgDownloadUrl"
+    done
+    for package in haiku haiku_devel; do
+        echo "Downloading $package..."
+        hpkgVersion="$(wget -qO- $HpkgBaseUrl | sed -n 's/^.*version: "\([^"]*\)".*$/\1/p')"
+        wget -P "$__RootfsDir/tmp/download" "$HpkgBaseUrl/packages/$package-$hpkgVersion-1-$__HaikuArch.hpkg"
     done
 
-    # Setup the sysroot
-    echo "Setting up sysroot and extracting needed packages"
+    # Set up the sysroot
+    echo "Setting up sysroot and extracting required packages"
     mkdir -p "$__RootfsDir/boot/system"
-    for file in "$__RootfsDir/generated/objects/haiku/x86_64/packaging/packages/"*.hpkg; do
-        "$__RootfsDir/generated/objects/linux/x86_64/release/tools/package/package" extract -C "$__RootfsDir/boot/system" "$file"
-    done
-    for file in "$__RootfsDir/generated/download/"*.hpkg; do
-        "$__RootfsDir/generated/objects/linux/x86_64/release/tools/package/package" extract -C "$__RootfsDir/boot/system" "$file"
+    for file in "$__RootfsDir/tmp/download/"*.hpkg; do
+        echo "Extracting $file..."
+        LD_LIBRARY_PATH="$__RootfsDir/tmp/bin" "$__RootfsDir/tmp/bin/package" extract -C "$__RootfsDir/boot/system" "$file"
     done
 
+    # Download buildtools
+    echo "Downloading Haiku buildtools"
+    wget -O "$__RootfsDir/tmp/download/buildtools.zip" $($__RootfsDir/tmp/script/fetch.sh --buildtools --arch=$__HaikuArch)
+    unzip -o "$__RootfsDir/tmp/download/buildtools.zip" -d "$__RootfsDir"
+
     # Cleaning up temporary files
     echo "Cleaning up temporary files"
+    popd
     rm -rf "$__RootfsDir/tmp"
-    for name in "$__RootfsDir/generated/"*; do
-        if [[ "$name" =~ "cross-tools-" ]]; then
-            : # Keep the cross-compiler
-        else
-            rm -rf "$name"
-        fi
-    done
 elif [[ -n "$__CodeName" ]]; then
 
     if [[ "$__SkipSigCheck" == "0" ]]; then
diff --git a/eng/common/cross/toolchain.cmake b/eng/common/cross/toolchain.cmake
index 1c9d212d135..a88d643c8a7 100644
--- a/eng/common/cross/toolchain.cmake
+++ b/eng/common/cross/toolchain.cmake
@@ -6,6 +6,7 @@ unset(FREEBSD)
 unset(ILLUMOS)
 unset(ANDROID)
 unset(TIZEN)
+unset(HAIKU)
 
 set(TARGET_ARCH_NAME $ENV{TARGET_BUILD_ARCH})
 if(EXISTS ${CROSS_ROOTFS}/bin/freebsd-version)
@@ -16,6 +17,7 @@ elseif(EXISTS ${CROSS_ROOTFS}/usr/platform/i86pc)
   set(ILLUMOS 1)
 elseif(EXISTS ${CROSS_ROOTFS}/boot/system/develop/headers/config/HaikuConfig.h)
   set(CMAKE_SYSTEM_NAME Haiku)
+  set(HAIKU 1)
 else()
   set(CMAKE_SYSTEM_NAME Linux)
   set(LINUX 1)
@@ -67,13 +69,25 @@ elseif(TARGET_ARCH_NAME STREQUAL "armv6")
   endif()
 elseif(TARGET_ARCH_NAME STREQUAL "ppc64le")
   set(CMAKE_SYSTEM_PROCESSOR ppc64le)
-  set(TOOLCHAIN "powerpc64le-linux-gnu")
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/powerpc64le-alpine-linux-musl)
+    set(TOOLCHAIN "powerpc64le-alpine-linux-musl")
+  else()
+    set(TOOLCHAIN "powerpc64le-linux-gnu")
+  endif()
 elseif(TARGET_ARCH_NAME STREQUAL "riscv64")
   set(CMAKE_SYSTEM_PROCESSOR riscv64)
-  set(TOOLCHAIN "riscv64-linux-gnu")
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/riscv64-alpine-linux-musl)
+    set(TOOLCHAIN "riscv64-alpine-linux-musl")
+  else()
+    set(TOOLCHAIN "riscv64-linux-gnu")
+  endif()
 elseif(TARGET_ARCH_NAME STREQUAL "s390x")
   set(CMAKE_SYSTEM_PROCESSOR s390x)
-  set(TOOLCHAIN "s390x-linux-gnu")
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/s390x-alpine-linux-musl)
+    set(TOOLCHAIN "s390x-alpine-linux-musl")
+  else()
+    set(TOOLCHAIN "s390x-linux-gnu")
+  endif()
 elseif(TARGET_ARCH_NAME STREQUAL "x64")
   set(CMAKE_SYSTEM_PROCESSOR x86_64)
   if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/x86_64-alpine-linux-musl)
@@ -88,11 +102,15 @@ elseif(TARGET_ARCH_NAME STREQUAL "x64")
   elseif(ILLUMOS)
     set(TOOLCHAIN "x86_64-illumos")
   elseif(HAIKU)
-    set(TOOLCHAIN "x64_64-unknown-haiku")
+    set(TOOLCHAIN "x86_64-unknown-haiku")
   endif()
 elseif(TARGET_ARCH_NAME STREQUAL "x86")
   set(CMAKE_SYSTEM_PROCESSOR i686)
-  set(TOOLCHAIN "i686-linux-gnu")
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/i586-alpine-linux-musl)
+    set(TOOLCHAIN "i586-alpine-linux-musl")
+  else()
+    set(TOOLCHAIN "i686-linux-gnu")
+  endif()
   if(TIZEN)
     set(TIZEN_TOOLCHAIN "i586-tizen-linux-gnu/9.2.0")
   endif()
@@ -198,10 +216,8 @@ elseif(HAIKU)
             return()
         endif()
 
-        set(SEARCH_PATH "${CROSS_ROOTFS}/generated/cross-tools-x86_64/bin")
-
         find_program(EXEC_LOCATION_${exec}
-            PATHS ${SEARCH_PATH}
+            PATHS "${CROSS_ROOTFS}/cross-tools-x86_64/bin"
             NAMES
             "${TOOLSET_PREFIX}${exec}${CLR_CMAKE_COMPILER_FILE_NAME_VERSION}"
             "${TOOLSET_PREFIX}${exec}")
@@ -266,8 +282,11 @@ elseif(TARGET_ARCH_NAME MATCHES "^(arm64|x64)$")
     add_toolchain_linker_flag("-Wl,--rpath-link=${CROSS_ROOTFS}/usr/lib64/gcc/${TIZEN_TOOLCHAIN}")
   endif()
 elseif(TARGET_ARCH_NAME STREQUAL "x86")
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/i586-alpine-linux-musl)
+    add_toolchain_linker_flag("--target=${TOOLCHAIN}")
+    add_toolchain_linker_flag("-Wl,--rpath-link=${CROSS_ROOTFS}/usr/lib/gcc/${TOOLCHAIN}")
+  endif()
   add_toolchain_linker_flag(-m32)
-
   if(TIZEN)
     add_toolchain_linker_flag("-B${CROSS_ROOTFS}/usr/lib/gcc/${TIZEN_TOOLCHAIN}")
     add_toolchain_linker_flag("-L${CROSS_ROOTFS}/lib")
@@ -277,6 +296,9 @@ elseif(TARGET_ARCH_NAME STREQUAL "x86")
 elseif(ILLUMOS)
   add_toolchain_linker_flag("-L${CROSS_ROOTFS}/lib/amd64")
   add_toolchain_linker_flag("-L${CROSS_ROOTFS}/usr/amd64/lib")
+elseif(HAIKU)
+  add_toolchain_linker_flag("-lnetwork")
+  add_toolchain_linker_flag("-lroot")
 endif()
 
 # Specify compile options
@@ -307,6 +329,9 @@ if(TARGET_ARCH_NAME MATCHES "^(arm|armel)$")
     add_compile_options(-mfloat-abi=softfp)
   endif()
 elseif(TARGET_ARCH_NAME STREQUAL "x86")
+  if(EXISTS ${CROSS_ROOTFS}/usr/lib/gcc/i586-alpine-linux-musl)
+    add_compile_options(--target=${TOOLCHAIN})
+  endif()
   add_compile_options(-m32)
   add_compile_options(-Wno-error=unused-command-line-argument)
 endif()
diff --git a/eng/common/cross/x64/sources.list.bionic b/eng/common/cross/x64/sources.list.bionic
new file mode 100644
index 00000000000..a71ccadcffa
--- /dev/null
+++ b/eng/common/cross/x64/sources.list.bionic
@@ -0,0 +1,11 @@
+deb http://archive.ubuntu.com/ubuntu/ bionic main restricted universe
+deb-src http://archive.ubuntu.com/ubuntu/ bionic main restricted universe
+
+deb http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted universe
+deb-src http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted universe
+
+deb http://archive.ubuntu.com/ubuntu/ bionic-backports main restricted
+deb-src http://archive.ubuntu.com/ubuntu/ bionic-backports main restricted
+
+deb http://archive.ubuntu.com/ubuntu/ bionic-security main restricted universe multiverse
+deb-src http://archive.ubuntu.com/ubuntu/ bionic-security main restricted universe multiverse
diff --git a/eng/common/dotnet-install.sh b/eng/common/dotnet-install.sh
index abd045a3247..7e69e3a9e24 100755
--- a/eng/common/dotnet-install.sh
+++ b/eng/common/dotnet-install.sh
@@ -54,6 +54,10 @@ cpuname=$(uname -m)
 case $cpuname in
   arm64|aarch64)
     buildarch=arm64
+    if [ "$(getconf LONG_BIT)" -lt 64 ]; then
+        # This is 32-bit OS running on 64-bit CPU (for example Raspberry Pi OS)
+        buildarch=arm
+    fi
     ;;
   loongarch64)
     buildarch=loongarch64
diff --git a/eng/common/loc/P22DotNetHtmlLocalization.lss b/eng/common/loc/P22DotNetHtmlLocalization.lss
index 858a0b237c6..5d892d61939 100644
Binary files a/eng/common/loc/P22DotNetHtmlLocalization.lss and b/eng/common/loc/P22DotNetHtmlLocalization.lss differ
diff --git a/eng/common/native/init-compiler.sh b/eng/common/native/init-compiler.sh
index 7aee4213e1b..f5c1ec7eafe 100644
--- a/eng/common/native/init-compiler.sh
+++ b/eng/common/native/init-compiler.sh
@@ -63,8 +63,8 @@ if [ -z "$CLR_CC" ]; then
     # Set default versions
     if [ -z "$majorVersion" ]; then
         # note: gcc (all versions) and clang versions higher than 6 do not have minor version in file name, if it is zero.
-        if [ "$compiler" = "clang" ]; then versions="16 15 14 13 12 11 10 9 8 7 6.0 5.0 4.0 3.9 3.8 3.7 3.6 3.5"
-        elif [ "$compiler" = "gcc" ]; then versions="12 11 10 9 8 7 6 5 4.9"; fi
+        if [ "$compiler" = "clang" ]; then versions="17 16 15 14 13 12 11 10 9 8 7 6.0 5.0 4.0 3.9 3.8 3.7 3.6 3.5"
+        elif [ "$compiler" = "gcc" ]; then versions="13 12 11 10 9 8 7 6 5 4.9"; fi
 
         for version in $versions; do
             _major="${version%%.*}"
diff --git a/eng/common/native/init-distro-rid.sh b/eng/common/native/init-distro-rid.sh
new file mode 100644
index 00000000000..de1687b2ccb
--- /dev/null
+++ b/eng/common/native/init-distro-rid.sh
@@ -0,0 +1,130 @@
+#!/usr/bin/env bash
+
+# getNonPortableDistroRid
+#
+# Input:
+#   targetOs: (str)
+#   targetArch: (str)
+#   rootfsDir: (str)
+#
+# Return:
+#   non-portable rid
+getNonPortableDistroRid()
+{
+    local targetOs="$1"
+    local targetArch="$2"
+    local rootfsDir="$3"
+    local nonPortableRid=""
+
+    if [ "$targetOs" = "linux" ]; then
+        if [ -e "${rootfsDir}/etc/os-release" ]; then
+            source "${rootfsDir}/etc/os-release"
+
+            if [[ "${ID}" == "rhel" || "${ID}" == "rocky" || "${ID}" == "alpine" ]]; then
+                # remove the last version digit
+                VERSION_ID="${VERSION_ID%.*}"
+            fi
+
+            if [[ "${VERSION_ID:-}" =~ ^([[:digit:]]|\.)+$ ]]; then
+                nonPortableRid="${ID}.${VERSION_ID}-${targetArch}"
+            else
+                # Rolling release distros either do not set VERSION_ID, set it as blank or
+                # set it to non-version looking string (such as TEMPLATE_VERSION_ID on ArchLinux);
+                # so omit it here to be consistent with everything else.
+                nonPortableRid="${ID}-${targetArch}"
+            fi
+
+        elif [ -e "${rootfsDir}/android_platform" ]; then
+            source "$rootfsDir"/android_platform
+            nonPortableRid="$RID"
+        fi
+    fi
+
+    if [ "$targetOs" = "freebsd" ]; then
+        # $rootfsDir can be empty. freebsd-version is shell script and it should always work.
+        __freebsd_major_version=$($rootfsDir/bin/freebsd-version | { read v; echo "${v%%.*}"; })
+        nonPortableRid="freebsd.$__freebsd_major_version-${targetArch}"
+    elif command -v getprop && getprop ro.product.system.model 2>&1 | grep -qi android; then
+        __android_sdk_version=$(getprop ro.build.version.sdk)
+        nonPortableRid="android.$__android_sdk_version-${targetArch}"
+    elif [ "$targetOs" = "illumos" ]; then
+        __uname_version=$(uname -v)
+        case "$__uname_version" in
+            omnios-*)
+                __omnios_major_version=$(echo "${__uname_version:8:2}")
+                nonPortableRid=omnios."$__omnios_major_version"-"$targetArch"
+            ;;
+            joyent_*)
+                __smartos_major_version=$(echo "${__uname_version:7:4}")
+                nonPortableRid=smartos."$__smartos_major_version"-"$targetArch"
+            ;;
+            illumos_*)
+                nonPortableRid=openindiana-"$targetArch"
+            ;;
+        esac
+    elif [ "$targetOs" = "solaris" ]; then
+        __uname_version=$(uname -v)
+        __solaris_major_version=$(echo "${__uname_version%.*}")
+        nonPortableRid=solaris."$__solaris_major_version"-"$targetArch"
+    elif [ "$targetOs" = "haiku" ]; then
+        __uname_release=$(uname -r)
+        nonPortableRid=haiku.r"$__uname_release"-"$targetArch"
+    fi
+
+    echo "$(echo $nonPortableRid | tr '[:upper:]' '[:lower:]')"
+}
+
+# initDistroRidGlobal
+#
+# Input:
+#   os: (str)
+#   arch: (str)
+#   rootfsDir?: (nullable:string)
+#
+# Return:
+#   None
+#
+# Notes:
+#
+# It is important to note that the function does not return anything, but it
+# exports the following variables on success:
+#
+#   __DistroRid   : Non-portable rid of the target platform.
+#   __PortableTargetOS  : OS-part of the portable rid that corresponds to the target platform.
+#
+initDistroRidGlobal()
+{
+    local targetOs="$1"
+    local targetArch="$2"
+    local rootfsDir=""
+    if [ "$#" -ge 3 ]; then
+        rootfsDir="$3"
+    fi
+
+    if [ -n "${rootfsDir}" ]; then
+        # We may have a cross build. Check for the existence of the rootfsDir
+        if [ ! -e "${rootfsDir}" ]; then
+            echo "Error rootfsDir has been passed, but the location is not valid."
+            exit 1
+        fi
+    fi
+
+    __DistroRid=$(getNonPortableDistroRid "${targetOs}" "${targetArch}" "${rootfsDir}")
+
+    if [ -z "${__PortableTargetOS:-}" ]; then
+        __PortableTargetOS="$targetOs"
+
+        STRINGS="$(command -v strings || true)"
+        if [ -z "$STRINGS" ]; then
+            STRINGS="$(command -v llvm-strings || true)"
+        fi
+
+        # Check for musl-based distros (e.g Alpine Linux, Void Linux).
+        if "${rootfsDir}/usr/bin/ldd" --version 2>&1 | grep -q musl ||
+                ( [ -n "$STRINGS" ] && "$STRINGS" "${rootfsDir}/usr/bin/ldd" 2>&1 | grep -q musl ); then
+            __PortableTargetOS="linux-musl"
+        fi
+    fi
+
+    export __DistroRid __PortableTargetOS
+}
diff --git a/eng/common/native/init-os-and-arch.sh b/eng/common/native/init-os-and-arch.sh
new file mode 100644
index 00000000000..e693617a6c2
--- /dev/null
+++ b/eng/common/native/init-os-and-arch.sh
@@ -0,0 +1,80 @@
+#!/usr/bin/env bash
+
+# Use uname to determine what the OS is.
+OSName=$(uname -s | tr '[:upper:]' '[:lower:]')
+
+if command -v getprop && getprop ro.product.system.model 2>&1 | grep -qi android; then
+    OSName="android"
+fi
+
+case "$OSName" in
+freebsd|linux|netbsd|openbsd|sunos|android|haiku)
+    os="$OSName" ;;
+darwin)
+    os=osx ;;
+*)
+    echo "Unsupported OS $OSName detected!"
+    exit 1 ;;
+esac
+
+# On Solaris, `uname -m` is discouraged, see https://docs.oracle.com/cd/E36784_01/html/E36870/uname-1.html
+# and `uname -p` returns processor type (e.g. i386 on amd64).
+# The appropriate tool to determine CPU is isainfo(1) https://docs.oracle.com/cd/E36784_01/html/E36870/isainfo-1.html.
+if [ "$os" = "sunos" ]; then
+    if uname -o 2>&1 | grep -q illumos; then
+        os="illumos"
+    else
+        os="solaris"
+    fi
+    CPUName=$(isainfo -n)
+else
+    # For the rest of the operating systems, use uname(1) to determine what the CPU is.
+    CPUName=$(uname -m)
+fi
+
+case "$CPUName" in
+    arm64|aarch64)
+        arch=arm64
+        ;;
+
+    loongarch64)
+        arch=loongarch64
+        ;;
+
+    riscv64)
+        arch=riscv64
+        ;;
+
+    amd64|x86_64)
+        arch=x64
+        ;;
+
+    armv7l|armv8l)
+        if (NAME=""; . /etc/os-release; test "$NAME" = "Tizen"); then
+            arch=armel
+        else
+            arch=arm
+        fi
+        ;;
+
+    armv6l)
+        arch=armv6
+        ;;
+
+    i[3-6]86)
+        echo "Unsupported CPU $CPUName detected, build might not succeed!"
+        arch=x86
+        ;;
+
+    s390x)
+        arch=s390x
+        ;;
+
+    ppc64le)
+        arch=ppc64le
+        ;;
+    *)
+        echo "Unknown CPU $CPUName detected!"
+        exit 1
+        ;;
+esac
diff --git a/eng/common/sdk-task.ps1 b/eng/common/sdk-task.ps1
index e10a5968797..6c4ac6fec1a 100644
--- a/eng/common/sdk-task.ps1
+++ b/eng/common/sdk-task.ps1
@@ -64,7 +64,7 @@ try {
       $GlobalJson.tools | Add-Member -Name "vs" -Value (ConvertFrom-Json "{ `"version`": `"16.5`" }") -MemberType NoteProperty
     }
     if( -not ($GlobalJson.tools.PSObject.Properties.Name -match "xcopy-msbuild" )) {
-      $GlobalJson.tools | Add-Member -Name "xcopy-msbuild" -Value "17.4.1" -MemberType NoteProperty
+      $GlobalJson.tools | Add-Member -Name "xcopy-msbuild" -Value "17.6.0-2" -MemberType NoteProperty
     }
     if ($GlobalJson.tools."xcopy-msbuild".Trim() -ine "none") {
         $xcopyMSBuildToolsFolder = InitializeXCopyMSBuild $GlobalJson.tools."xcopy-msbuild" -install $true
diff --git a/eng/common/sdl/configure-sdl-tool.ps1 b/eng/common/sdl/configure-sdl-tool.ps1
index bdbf49e6c71..27f5a4115fc 100644
--- a/eng/common/sdl/configure-sdl-tool.ps1
+++ b/eng/common/sdl/configure-sdl-tool.ps1
@@ -17,7 +17,9 @@ Param(
   # Optional: Additional params to add to any tool using PoliCheck.
   [string[]] $PoliCheckAdditionalRunConfigParams,
   # Optional: Additional params to add to any tool using CodeQL/Semmle.
-  [string[]] $CodeQLAdditionalRunConfigParams
+  [string[]] $CodeQLAdditionalRunConfigParams,
+  # Optional: Additional params to add to any tool using Binskim.
+  [string[]] $BinskimAdditionalRunConfigParams
 )
 
 $ErrorActionPreference = 'Stop'
@@ -69,22 +71,34 @@ try {
     $gdnConfigFile = Join-Path $gdnConfigPath "$toolConfigName-configure.gdnconfig"
 
     # For some tools, add default and automatic args.
-    if ($tool.Name -eq 'credscan') {
-      if ($targetDirectory) {
-        $tool.Args += "`"TargetDirectory < $TargetDirectory`""
+    switch -Exact ($tool.Name) {
+      'credscan' {
+        if ($targetDirectory) {
+          $tool.Args += "`"TargetDirectory < $TargetDirectory`""
+        }
+        $tool.Args += "`"OutputType < pre`""
+        $tool.Args += $CrScanAdditionalRunConfigParams
       }
-      $tool.Args += "`"OutputType < pre`""
-      $tool.Args += $CrScanAdditionalRunConfigParams
-    } elseif ($tool.Name -eq 'policheck') {
-      if ($targetDirectory) {
-        $tool.Args += "`"Target < $TargetDirectory`""
+      'policheck' {
+        if ($targetDirectory) {
+          $tool.Args += "`"Target < $TargetDirectory`""
+        }
+        $tool.Args += $PoliCheckAdditionalRunConfigParams
       }
-      $tool.Args += $PoliCheckAdditionalRunConfigParams
-    } elseif ($tool.Name -eq 'semmle' -or $tool.Name -eq 'codeql') {
-      if ($targetDirectory) {
-        $tool.Args += "`"SourceCodeDirectory < $TargetDirectory`""
+      {$_ -in 'semmle', 'codeql'} {
+        if ($targetDirectory) {
+          $tool.Args += "`"SourceCodeDirectory < $TargetDirectory`""
+        }
+        $tool.Args += $CodeQLAdditionalRunConfigParams
+      }
+      'binskim' {
+        if ($targetDirectory) {
+          # Binskim crashes due to specific PDBs. GitHub issue: https://github.com/microsoft/binskim/issues/924.
+          # We are excluding all `_.pdb` files from the scan.
+          $tool.Args += "`"Target < $TargetDirectory\**;-:file|$TargetDirectory\**\_.pdb`""
+        }
+        $tool.Args += $BinskimAdditionalRunConfigParams
       }
-      $tool.Args += $CodeQLAdditionalRunConfigParams
     }
 
     # Create variable pointing to the args array directly so we can use splat syntax later.
diff --git a/eng/common/sdl/execute-all-sdl-tools.ps1 b/eng/common/sdl/execute-all-sdl-tools.ps1
index 4797e012c7d..4715d75e974 100644
--- a/eng/common/sdl/execute-all-sdl-tools.ps1
+++ b/eng/common/sdl/execute-all-sdl-tools.ps1
@@ -35,6 +35,7 @@ Param(
   [string[]] $CrScanAdditionalRunConfigParams,                                                   # Optional: Additional Params to custom build a CredScan run config in the format @("xyz:abc","sdf:1")
   [string[]] $PoliCheckAdditionalRunConfigParams,                                                # Optional: Additional Params to custom build a Policheck run config in the format @("xyz:abc","sdf:1")
   [string[]] $CodeQLAdditionalRunConfigParams,                                                   # Optional: Additional Params to custom build a Semmle/CodeQL run config in the format @("xyz < abc","sdf < 1")
+  [string[]] $BinskimAdditionalRunConfigParams,                                                  # Optional: Additional Params to custom build a Binskim run config in the format @("xyz < abc","sdf < 1")
   [bool] $BreakOnFailure=$False                                                                  # Optional: Fail the build if there were errors during the run
 )
 
@@ -107,7 +108,8 @@ try {
           -GuardianLoggerLevel $GuardianLoggerLevel `
           -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams `
           -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams `
-          -CodeQLAdditionalRunConfigParams $CodeQLAdditionalRunConfigParams
+          -CodeQLAdditionalRunConfigParams $CodeQLAdditionalRunConfigParams `
+          -BinskimAdditionalRunConfigParams $BinskimAdditionalRunConfigParams
         if ($BreakOnFailure) {
           Exit-IfNZEC "Sdl"
         }
diff --git a/eng/common/sdl/extract-artifact-packages.ps1 b/eng/common/sdl/extract-artifact-packages.ps1
index 7f28d9c59ec..f031ed5b25e 100644
--- a/eng/common/sdl/extract-artifact-packages.ps1
+++ b/eng/common/sdl/extract-artifact-packages.ps1
@@ -35,31 +35,33 @@ try {
     param( 
       [string] $PackagePath                                 # Full path to a NuGet package
     )
-    
+
     if (!(Test-Path $PackagePath)) {
       Write-PipelineTelemetryError -Category 'Build' -Message "Input file does not exist: $PackagePath"
       ExitWithExitCode 1
     }
-    
+
     $RelevantExtensions = @('.dll', '.exe', '.pdb')
     Write-Host -NoNewLine 'Extracting ' ([System.IO.Path]::GetFileName($PackagePath)) '...'
-  
+
     $PackageId = [System.IO.Path]::GetFileNameWithoutExtension($PackagePath)
     $ExtractPath = Join-Path -Path $using:ExtractPath -ChildPath $PackageId
-  
+
     Add-Type -AssemblyName System.IO.Compression.FileSystem
-  
+
     [System.IO.Directory]::CreateDirectory($ExtractPath);
-  
+
     try {
       $zip = [System.IO.Compression.ZipFile]::OpenRead($PackagePath)
   
       $zip.Entries | 
       Where-Object {$RelevantExtensions -contains [System.IO.Path]::GetExtension($_.Name)} |
         ForEach-Object {
-            $TargetFile = Join-Path -Path $ExtractPath -ChildPath $_.Name
-  
-            [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, $TargetFile, $true)
+            $TargetPath = Join-Path -Path $ExtractPath -ChildPath (Split-Path -Path $_.FullName)
+            [System.IO.Directory]::CreateDirectory($TargetPath);
+
+            $TargetFile = Join-Path -Path $ExtractPath -ChildPath $_.FullName
+            [System.IO.Compression.ZipFileExtensions]::ExtractToFile($_, $TargetFile)
           }
     }
     catch {
diff --git a/eng/common/sdl/trim-assets-version.ps1 b/eng/common/sdl/trim-assets-version.ps1
new file mode 100644
index 00000000000..a2e00487704
--- /dev/null
+++ b/eng/common/sdl/trim-assets-version.ps1
@@ -0,0 +1,75 @@
+<#
+.SYNOPSIS
+Install and run the 'Microsoft.DotNet.VersionTools.Cli' tool with the 'trim-artifacts-version' command to trim the version from the NuGet assets file name.
+
+.PARAMETER InputPath
+Full path to directory where artifact packages are stored
+
+.PARAMETER Recursive
+Search for NuGet packages recursively
+
+#>
+
+Param(
+  [string] $InputPath,
+  [bool] $Recursive = $true
+)
+
+$CliToolName = "Microsoft.DotNet.VersionTools.Cli"
+
+function Install-VersionTools-Cli {
+  param(
+      [Parameter(Mandatory=$true)][string]$Version
+  )
+
+  Write-Host "Installing the package '$CliToolName' with a version of '$version' ..."
+  $feed = "https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json"
+
+  $argumentList = @("tool", "install", "--local", "$CliToolName", "--add-source $feed", "--no-cache", "--version $Version", "--create-manifest-if-needed")
+  Start-Process "$dotnet" -Verbose -ArgumentList $argumentList -NoNewWindow -Wait
+}
+
+# -------------------------------------------------------------------
+
+if (!(Test-Path $InputPath)) {
+  Write-Host "Input Path '$InputPath' does not exist"
+  ExitWithExitCode 1
+}
+
+$ErrorActionPreference = 'Stop'
+Set-StrictMode -Version 2.0
+
+$disableConfigureToolsetImport = $true
+$global:LASTEXITCODE = 0
+
+# `tools.ps1` checks $ci to perform some actions. Since the SDL
+# scripts don't necessarily execute in the same agent that run the
+# build.ps1/sh script this variable isn't automatically set.
+$ci = $true
+. $PSScriptRoot\..\tools.ps1
+
+try {
+  $dotnetRoot = InitializeDotNetCli -install:$true
+  $dotnet = "$dotnetRoot\dotnet.exe"
+
+  $toolsetVersion = Read-ArcadeSdkVersion
+  Install-VersionTools-Cli -Version $toolsetVersion
+
+  $cliToolFound = (& "$dotnet" tool list --local | Where-Object {$_.Split(' ')[0] -eq $CliToolName})
+  if ($null -eq $cliToolFound) {
+    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "The '$CliToolName' tool is not installed."
+    ExitWithExitCode 1
+  }
+
+  Exec-BlockVerbosely {
+    & "$dotnet" $CliToolName trim-assets-version `
+      --assets-path $InputPath `
+      --recursive $Recursive
+    Exit-IfNZEC "Sdl"
+  }
+}
+catch {
+  Write-Host $_
+  Write-PipelineTelemetryError -Force -Category 'Sdl' -Message $_
+  ExitWithExitCode 1
+}
\ No newline at end of file
diff --git a/eng/common/templates/job/execute-sdl.yml b/eng/common/templates/job/execute-sdl.yml
index 7aabaa18017..7870f93bc17 100644
--- a/eng/common/templates/job/execute-sdl.yml
+++ b/eng/common/templates/job/execute-sdl.yml
@@ -105,6 +105,11 @@ jobs:
         downloadPath: $(Build.ArtifactStagingDirectory)\artifacts
         checkDownloadedFiles: true
 
+  - powershell: eng/common/sdl/trim-assets-version.ps1
+      -InputPath $(Build.ArtifactStagingDirectory)\artifacts
+    displayName: Trim the version from the NuGet packages
+    continueOnError: ${{ parameters.sdlContinueOnError }}
+
   - powershell: eng/common/sdl/extract-artifact-packages.ps1
       -InputPath $(Build.ArtifactStagingDirectory)\artifacts\BlobArtifacts
       -ExtractPath $(Build.ArtifactStagingDirectory)\artifacts\BlobArtifacts
diff --git a/eng/common/templates/job/job.yml b/eng/common/templates/job/job.yml
index 7b714ec2a80..e20ee3a983c 100644
--- a/eng/common/templates/job/job.yml
+++ b/eng/common/templates/job/job.yml
@@ -25,7 +25,7 @@ parameters:
   enablePublishTestResults: false
   enablePublishUsingPipelines: false
   enableBuildRetry: false
-  disableComponentGovernance: false
+  disableComponentGovernance: ''
   componentGovernanceIgnoreDirectories: ''
   mergeTestResults: false
   testRunTitle: ''
@@ -159,11 +159,16 @@ jobs:
         uploadRichNavArtifacts: ${{ coalesce(parameters.richCodeNavigationUploadArtifacts, false) }}
       continueOnError: true
 
-  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), ne(parameters.disableComponentGovernance, 'true')) }}:
-      - task: ComponentGovernanceComponentDetection@0
-        continueOnError: true
-        inputs:
-          ignoreDirectories: ${{ parameters.componentGovernanceIgnoreDirectories }}
+  - template: /eng/common/templates/steps/component-governance.yml
+    parameters:
+      ${{ if eq(parameters.disableComponentGovernance, '') }}:
+        ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), eq(parameters.runAsPublic, 'false'), or(startsWith(variables['Build.SourceBranch'], 'refs/heads/release/'), startsWith(variables['Build.SourceBranch'], 'refs/heads/dotnet/'), startsWith(variables['Build.SourceBranch'], 'refs/heads/microsoft/'), eq(variables['Build.SourceBranch'], 'refs/heads/main'))) }}:
+          disableComponentGovernance: false
+        ${{ else }}:
+          disableComponentGovernance: true
+      ${{ else }}:
+        disableComponentGovernance: ${{ parameters.disableComponentGovernance }}
+      componentGovernanceIgnoreDirectories: ${{ parameters.componentGovernanceIgnoreDirectories }}
 
   - ${{ if eq(parameters.enableMicrobuild, 'true') }}:
     - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
diff --git a/eng/common/templates/steps/component-governance.yml b/eng/common/templates/steps/component-governance.yml
index babc2757d8d..0ecec47b0c9 100644
--- a/eng/common/templates/steps/component-governance.yml
+++ b/eng/common/templates/steps/component-governance.yml
@@ -1,5 +1,6 @@
 parameters:
   disableComponentGovernance: false
+  componentGovernanceIgnoreDirectories: ''
 
 steps:
 - ${{ if eq(parameters.disableComponentGovernance, 'true') }}:
@@ -7,4 +8,6 @@ steps:
     displayName: Set skipComponentGovernanceDetection variable
 - ${{ if ne(parameters.disableComponentGovernance, 'true') }}:
   - task: ComponentGovernanceComponentDetection@0
-    continueOnError: true
\ No newline at end of file
+    continueOnError: true
+    inputs:
+      ignoreDirectories: ${{ parameters.componentGovernanceIgnoreDirectories }}
\ No newline at end of file
diff --git a/eng/common/templates/steps/execute-sdl.yml b/eng/common/templates/steps/execute-sdl.yml
index 9dd5709f66d..07426fde05d 100644
--- a/eng/common/templates/steps/execute-sdl.yml
+++ b/eng/common/templates/steps/execute-sdl.yml
@@ -33,7 +33,7 @@ steps:
 
 - ${{ if ne(parameters.overrideParameters, '') }}:
   - powershell: ${{ parameters.executeAllSdlToolsScript }} ${{ parameters.overrideParameters }}
-    displayName: Execute SDL
+    displayName: Execute SDL (Overridden)
     continueOnError: ${{ parameters.sdlContinueOnError }}
     condition: ${{ parameters.condition }}
 
diff --git a/eng/common/templates/steps/source-build.yml b/eng/common/templates/steps/source-build.yml
index a97a185a367..41bbb915736 100644
--- a/eng/common/templates/steps/source-build.yml
+++ b/eng/common/templates/steps/source-build.yml
@@ -68,6 +68,11 @@ steps:
       runtimeOsArgs='/p:RuntimeOS=${{ parameters.platform.runtimeOS }}'
     fi
 
+    baseOsArgs=
+    if [ '${{ parameters.platform.baseOS }}' != '' ]; then
+      baseOsArgs='/p:BaseOS=${{ parameters.platform.baseOS }}'
+    fi
+
     publishArgs=
     if [ '${{ parameters.platform.skipPublishValidation }}' != 'true' ]; then
       publishArgs='--publish'
@@ -86,6 +91,7 @@ steps:
       $internalRestoreArgs \
       $targetRidArgs \
       $runtimeOsArgs \
+      $baseOsArgs \
       /p:SourceBuildNonPortable=${{ parameters.platform.nonPortable }} \
       /p:ArcadeBuildFromSource=true \
       /p:AssetManifestFileName=$assetManifestFileName
@@ -112,3 +118,12 @@ steps:
     artifactName: BuildLogs_SourceBuild_${{ parameters.platform.name }}_Attempt$(System.JobAttempt)
   continueOnError: true
   condition: succeededOrFailed()
+
+# Manually inject component detection so that we can ignore the source build upstream cache, which contains
+# a nupkg cache of input packages (a local feed).
+# This path must match the upstream cache path in property 'CurrentRepoSourceBuiltNupkgCacheDir'
+# in src\Microsoft.DotNet.Arcade.Sdk\tools\SourceBuild\SourceBuildArcade.targets
+- task: ComponentGovernanceComponentDetection@0
+  displayName: Component Detection (Exclude upstream cache)
+  inputs:
+    ignoreDirectories: '$(Build.SourcesDirectory)/artifacts/source-build/self/src/artifacts/obj/source-built-upstream-cache'
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index e56d2b9e55b..aa74ab4a81e 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -287,6 +287,25 @@ function InstallDotNet([string] $dotnetRoot,
   [string] $runtimeSourceFeedKey = '',
   [switch] $noPath) {
 
+  $dotnetVersionLabel = "'sdk v$version'"
+
+  if ($runtime -ne '' -and $runtime -ne 'sdk') {
+    $runtimePath = $dotnetRoot
+    $runtimePath = $runtimePath + "\shared"
+    if ($runtime -eq "dotnet") { $runtimePath = $runtimePath + "\Microsoft.NETCore.App" }
+    if ($runtime -eq "aspnetcore") { $runtimePath = $runtimePath + "\Microsoft.AspNetCore.App" }
+    if ($runtime -eq "windowsdesktop") { $runtimePath = $runtimePath + "\Microsoft.WindowsDesktop.App" }
+    $runtimePath = $runtimePath + "\" + $version
+  
+    $dotnetVersionLabel = "runtime toolset '$runtime/$architecture v$version'"
+
+    if (Test-Path $runtimePath) {
+      Write-Host "  Runtime toolset '$runtime/$architecture v$version' already installed."
+      $installSuccess = $true
+      Exit
+    }
+  }
+
   $installScript = GetDotNetInstallScript $dotnetRoot
   $installParameters = @{
     Version = $version
@@ -323,18 +342,18 @@ function InstallDotNet([string] $dotnetRoot,
     } else {
       $location = "public location";
     }
-    Write-Host "Attempting to install dotnet from $location."
+    Write-Host "  Attempting to install $dotnetVersionLabel from $location."
     try {
       & $installScript @variation
       $installSuccess = $true
       break
     }
     catch {
-      Write-Host "Failed to install dotnet from $location."
+      Write-Host "  Failed to install $dotnetVersionLabel from $location."
     }
   }
   if (-not $installSuccess) {
-    Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Failed to install dotnet from any of the specified locations."
+    Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Failed to install $dotnetVersionLabel from any of the specified locations."
     ExitWithExitCode 1
   }
 }
@@ -360,13 +379,13 @@ function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements =
   }
 
   # Minimum VS version to require.
-  $vsMinVersionReqdStr = '16.8'
+  $vsMinVersionReqdStr = '17.6'
   $vsMinVersionReqd = [Version]::new($vsMinVersionReqdStr)
 
   # If the version of msbuild is going to be xcopied,
   # use this version. Version matches a package here:
-  # https://dev.azure.com/dnceng/public/_packaging?_a=package&feed=dotnet-eng&package=RoslynTools.MSBuild&protocolType=NuGet&version=17.4.1&view=overview
-  $defaultXCopyMSBuildVersion = '17.4.1'
+  # https://dev.azure.com/dnceng/public/_artifacts/feed/dotnet-eng/NuGet/RoslynTools.MSBuild/versions/17.6.0-2
+  $defaultXCopyMSBuildVersion = '17.6.0-2'
 
   if (!$vsRequirements) {
     if (Get-Member -InputObject $GlobalJson.tools -Name 'vs') {
@@ -399,7 +418,8 @@ function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements =
   # Locate Visual Studio installation or download x-copy msbuild.
   $vsInfo = LocateVisualStudio $vsRequirements
   if ($vsInfo -ne $null) {
-    $vsInstallDir = $vsInfo.installationPath
+    # Ensure vsInstallDir has a trailing slash
+    $vsInstallDir = Join-Path $vsInfo.installationPath "\"
     $vsMajorVersion = $vsInfo.installationVersion.Split('.')[0]
 
     InitializeVisualStudioEnvironmentVariables $vsInstallDir $vsMajorVersion
@@ -651,6 +671,10 @@ function InitializeNativeTools() {
   }
 }
 
+function Read-ArcadeSdkVersion() {
+  return $GlobalJson.'msbuild-sdks'.'Microsoft.DotNet.Arcade.Sdk'
+}
+
 function InitializeToolset() {
   if (Test-Path variable:global:_ToolsetBuildProj) {
     return $global:_ToolsetBuildProj
@@ -658,7 +682,7 @@ function InitializeToolset() {
 
   $nugetCache = GetNuGetPackageCachePath
 
-  $toolsetVersion = $GlobalJson.'msbuild-sdks'.'Microsoft.DotNet.Arcade.Sdk'
+  $toolsetVersion = Read-ArcadeSdkVersion
   $toolsetLocationFile = Join-Path $ToolsetDir "$toolsetVersion.txt"
 
   if (Test-Path $toolsetLocationFile) {
@@ -743,8 +767,8 @@ function MSBuild() {
       (Join-Path $basePath (Join-Path netcoreapp2.1 'Microsoft.DotNet.Arcade.Sdk.dll'))
       (Join-Path $basePath (Join-Path netcoreapp3.1 'Microsoft.DotNet.ArcadeLogging.dll')),
       (Join-Path $basePath (Join-Path netcoreapp3.1 'Microsoft.DotNet.Arcade.Sdk.dll'))
-      (Join-Path $basePath (Join-Path net8.0 'Microsoft.DotNet.ArcadeLogging.dll')),
-      (Join-Path $basePath (Join-Path net8.0 'Microsoft.DotNet.Arcade.Sdk.dll'))
+      (Join-Path $basePath (Join-Path net7.0 'Microsoft.DotNet.ArcadeLogging.dll')),
+      (Join-Path $basePath (Join-Path net7.0 'Microsoft.DotNet.Arcade.Sdk.dll'))
     )
     $selectedPath = $null
     foreach ($path in $possiblePaths) {
diff --git a/eng/common/tools.sh b/eng/common/tools.sh
index 23da693b1ae..e8d47894334 100755
--- a/eng/common/tools.sh
+++ b/eng/common/tools.sh
@@ -184,6 +184,35 @@ function InstallDotNetSdk {
 function InstallDotNet {
   local root=$1
   local version=$2
+  local runtime=$4
+
+  local dotnetVersionLabel="'$runtime v$version'"
+  if [[ -n "${4:-}" ]] && [ "$4" != 'sdk' ]; then
+    runtimePath="$root"
+    runtimePath="$runtimePath/shared"
+    case "$runtime" in
+      dotnet)
+        runtimePath="$runtimePath/Microsoft.NETCore.App"
+        ;;
+      aspnetcore)
+        runtimePath="$runtimePath/Microsoft.AspNetCore.App"
+        ;;
+      windowsdesktop)
+        runtimePath="$runtimePath/Microsoft.WindowsDesktop.App"
+        ;;
+      *)
+        ;;
+    esac
+    runtimePath="$runtimePath/$version"
+
+    dotnetVersionLabel="runtime toolset '$runtime/$architecture v$version'"
+
+    if [ -d "$runtimePath" ]; then
+      echo "  Runtime toolset '$runtime/$architecture v$version' already installed."
+      local installSuccess=1
+      return
+    fi
+  fi
 
   GetDotNetInstallScript "$root"
   local install_script=$_GetDotNetInstallScript
@@ -228,17 +257,17 @@ function InstallDotNet {
   for variationName in "${variations[@]}"; do
     local name="$variationName[@]"
     local variation=("${!name}")
-    echo "Attempting to install dotnet from $variationName."
+    echo "  Attempting to install $dotnetVersionLabel from $variationName."
     bash "$install_script" "${variation[@]}" && installSuccess=1
     if [[ "$installSuccess" -eq 1 ]]; then
       break
     fi
 
-    echo "Failed to install dotnet from $variationName."
+    echo "  Failed to install $dotnetVersionLabel from $variationName."
   done
 
   if [[ "$installSuccess" -eq 0 ]]; then
-    Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install dotnet SDK from any of the specified locations."
+    Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install $dotnetVersionLabel from any of the specified locations."
     ExitWithExitCode 1
   fi
 }
@@ -428,8 +457,8 @@ function MSBuild {
     possiblePaths+=( "$toolset_dir/netcoreapp2.1/Microsoft.DotNet.Arcade.Sdk.dll" )
     possiblePaths+=( "$toolset_dir/netcoreapp3.1/Microsoft.DotNet.ArcadeLogging.dll" )
     possiblePaths+=( "$toolset_dir/netcoreapp3.1/Microsoft.DotNet.Arcade.Sdk.dll" )
-    possiblePaths+=( "$toolset_dir/net8.0/Microsoft.DotNet.ArcadeLogging.dll" )
-    possiblePaths+=( "$toolset_dir/net8.0/Microsoft.DotNet.Arcade.Sdk.dll" )
+    possiblePaths+=( "$toolset_dir/net7.0/Microsoft.DotNet.ArcadeLogging.dll" )
+    possiblePaths+=( "$toolset_dir/net7.0/Microsoft.DotNet.Arcade.Sdk.dll" )
     for path in "${possiblePaths[@]}"; do
       if [[ -f $path ]]; then
         selectedPath=$path
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index b953ddad88b..4a6756eff0a 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -13,6 +13,9 @@
     <PackageVersion Include="BenchmarkDotNet" Version="0.13.1" />
     <PackageVersion Update="BenchmarkDotNet" Condition="'$(BenchmarkDotNetVersion)' != ''" Version="$(BenchmarkDotNetVersion)" />
 
+    <PackageVersion Include="FluentAssertions" Version="6.11.0" />
+    <PackageVersion Update="FluentAssertions" Condition="'$(FluentAssertionsVersion)' != ''" Version="$(FluentAssertionsVersion)" />
+
     <PackageVersion Include="LargeAddressAware" Version="1.0.5" />
     <PackageVersion Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
 
diff --git a/global.json b/global.json
index 02e7ca90e50..d9967b3a53d 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "8.0.100-preview.3.23178.7",
+    "dotnet": "8.0.100-preview.7.23376.3",
     "vs": {
-      "version": "17.4.1"
+      "version": "17.6.0"
     },
-    "xcopy-msbuild": "17.4.1"
+    "xcopy-msbuild": "17.6.0-2"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.23213.1"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.23425.2"
   }
 }
diff --git a/src/BannedSymbols.txt b/src/BannedSymbols.txt
index f11ba0906af..c369fe9d42b 100644
--- a/src/BannedSymbols.txt
+++ b/src/BannedSymbols.txt
@@ -1,2 +1,7 @@
 M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char);CompareInfo.IndexOf can unexpectedly allocate strings--use string.IndexOf
 P:Microsoft.Build.Construction.ProjectElementContainer.Children;Use ChildrenEnumerable instead to avoid boxing
+M:System.Xml.XmlReader.Create(System.String);Do not pass paths to XmlReader.Create--use the Stream overload
+M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings);Do not pass paths to XmlReader.Create--use the Stream overload
+M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext);Do not pass paths to XmlReader.Create--use the Stream overload
+M:System.Xml.XPath.XPathDocument.#ctor(System.String);Do not pass string paths to XPathDocument ctor--use the Stream overload
+M:System.Xml.XPath.XPathDocument.#ctor(System.String,System.Xml.XmlSpace);Do not pass string paths to XPathDocument ctor--use the Stream overload
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index c4c4e0b9c59..fbdf4b3742f 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -95,6 +95,49 @@ public void AccessorsWithMetadata()
             Assert.Equal("v2", item.GetMetadataValue("m2"));
         }
 
+        /// <summary>
+        /// Basic ProjectItemInstance with metadata added using ImportMetadata
+        /// </summary>
+        [Fact]
+        public void AccessorsWithImportedMetadata()
+        {
+            ProjectItemInstance item = GetItemInstance();
+
+            ((IMetadataContainer)item).ImportMetadata(new Dictionary<string, string>
+            {
+                { "m1", "v1" },
+                { "m2", "v2" },
+            });
+
+            Assert.Equal("m1", item.GetMetadata("m1").Name);
+            Assert.Equal("m2", item.GetMetadata("m2").Name);
+            Assert.Equal("v1", item.GetMetadataValue("m1"));
+            Assert.Equal("v2", item.GetMetadataValue("m2"));
+        }
+
+        /// <summary>
+        /// ImportMetadata adds and overwrites metadata, does not delete existing metadata
+        /// </summary>
+        [Fact]
+        public void ImportMetadataAddsAndOverwrites()
+        {
+            ProjectItemInstance item = GetItemInstance();
+
+            item.SetMetadata("m1", "v1");
+            item.SetMetadata("m2", "v0");
+
+            ((IMetadataContainer) item).ImportMetadata(new Dictionary<string, string>
+            {
+                { "m2", "v2" },
+                { "m3", "v3" },
+            });
+
+            // m1 was not deleted, m2 was overwritten, m3 was added
+            Assert.Equal("v1", item.GetMetadataValue("m1"));
+            Assert.Equal("v2", item.GetMetadataValue("m2"));
+            Assert.Equal("v3", item.GetMetadataValue("m3"));
+        }
+
         /// <summary>
         /// Get metadata not present
         /// </summary>
@@ -106,6 +149,56 @@ public void GetMissingMetadata()
             Assert.Equal(String.Empty, item.GetMetadataValue("X"));
         }
 
+        [Fact]
+        public void CopyMetadataToTaskItem()
+        {
+            ProjectItemInstance fromItem = GetItemInstance();
+
+            fromItem.SetMetadata("m1", "v1");
+            fromItem.SetMetadata("m2", "v2");
+
+            ITaskItem toItem = new Utilities.TaskItem();
+
+            ((ITaskItem)fromItem).CopyMetadataTo(toItem);
+
+            Assert.Equal("v1", toItem.GetMetadata("m1"));
+            Assert.Equal("v2", toItem.GetMetadata("m2"));
+        }
+
+#if FEATURE_APPDOMAIN
+        private sealed class RemoteTaskItemFactory : MarshalByRefObject
+        {
+            public ITaskItem CreateTaskItem() => new Utilities.TaskItem();
+        }
+
+        [Fact]
+        public void CopyMetadataToRemoteTaskItem()
+        {
+            ProjectItemInstance fromItem = GetItemInstance();
+
+            fromItem.SetMetadata("m1", "v1");
+            fromItem.SetMetadata("m2", "v2");
+
+            AppDomain appDomain = null;
+            try
+            {
+                appDomain = AppDomain.CreateDomain("CopyMetadataToRemoteTaskItem", null, AppDomain.CurrentDomain.SetupInformation);
+                RemoteTaskItemFactory itemFactory = (RemoteTaskItemFactory)appDomain.CreateInstanceFromAndUnwrap(typeof(RemoteTaskItemFactory).Module.FullyQualifiedName, typeof(RemoteTaskItemFactory).FullName);
+
+                ITaskItem toItem = itemFactory.CreateTaskItem();
+
+                ((ITaskItem)fromItem).CopyMetadataTo(toItem);
+
+                Assert.Equal("v1", toItem.GetMetadata("m1"));
+                Assert.Equal("v2", toItem.GetMetadata("m2"));
+            }
+            finally
+            {
+                AppDomain.Unload(appDomain);
+            }
+        }
+#endif
+
         /// <summary>
         /// Set include
         /// </summary>
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
index f07ab76dd54..e3531211645 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
@@ -34,14 +34,14 @@ public LinkPair(T view, T real)
 
         public void VerifyNotSame(LinkPair<T> other)
         {
-            Assert.NotSame((object)this.View, (object)other.View);
-            Assert.NotSame((object)this.Real, (object)other.Real);
+            Assert.NotEqual((object)this.View, (object)other.View);
+            Assert.NotEqual((object)this.Real, (object)other.Real);
         }
 
         public void VerifySame(LinkPair<T> other)
         {
-            Assert.Same((object)this.View, (object)other.View);
-            Assert.Same((object)this.Real, (object)other.Real);
+            Assert.Equal((object)this.View, (object)other.View);
+            Assert.Equal((object)this.Real, (object)other.Real);
         }
 
         public void VerifySetter(bool finalValue, Func<T, bool> getter, Action<T, bool> setter)
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index ba1e8c7b4eb..d850b213576 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -181,36 +181,6 @@ public void TestSerializeEnum()
             Assert.Equal(value, deserializedValue);
         }
 
-        /// <summary>
-        /// Tests serializing using the DotNet serializer.
-        /// </summary>
-        [Fact]
-        public void TestSerializeDotNet()
-        {
-            ArgumentNullException value = new ArgumentNullException("The argument was null", new InsufficientMemoryException());
-            TranslationHelpers.GetWriteTranslator().TranslateDotNet(ref value);
-
-            ArgumentNullException deserializedValue = null;
-            TranslationHelpers.GetReadTranslator().TranslateDotNet(ref deserializedValue);
-
-            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
-        }
-
-        /// <summary>
-        /// Tests serializing using the DotNet serializer passing in null.
-        /// </summary>
-        [Fact]
-        public void TestSerializeDotNetNull()
-        {
-            ArgumentNullException value = null;
-            TranslationHelpers.GetWriteTranslator().TranslateDotNet(ref value);
-
-            ArgumentNullException deserializedValue = null;
-            TranslationHelpers.GetReadTranslator().TranslateDotNet(ref deserializedValue);
-
-            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
-        }
-
         [Fact]
         public void TestSerializeException()
         {
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
new file mode 100644
index 00000000000..f454dc1161d
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
@@ -0,0 +1,163 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+using Xunit.NetCore.Extensions;
+using static Microsoft.Build.UnitTests.ObjectModelHelpers;
+
+#nullable disable
+
+namespace Microsoft.Build.Engine.UnitTests.BackEnd
+{
+    public class BuildManager_Logging_Tests : IDisposable
+    {
+        private string _mainProject = @"
+<Project>
+
+  <Target Name=`MainTarget`>
+    <MSBuild Projects=`{0}` Targets=`ChildTarget` />
+  </Target>
+
+</Project>";
+
+        private string _childProjectWithCustomBuildEvent = $@"
+<Project>
+
+    <UsingTask TaskName=""CustomBuildEventTask"" AssemblyFile=""{Assembly.GetExecutingAssembly().Location}"" />
+    <Target Name=`ChildTarget`>
+        <CustomBuildEventTask />
+    </Target>
+
+</Project>";
+
+
+        /// <summary>
+        /// The mock logger for testing.
+        /// </summary>
+        private readonly MockLogger _logger;
+
+        /// <summary>
+        /// The standard build manager for each test.
+        /// </summary>
+        private readonly BuildManager _buildManager;
+
+        /// <summary>
+        /// The project collection used.
+        /// </summary>
+        private readonly ProjectCollection _projectCollection;
+
+        private readonly TestEnvironment _env;
+        private readonly ITestOutputHelper _output;
+
+        /// <summary>
+        /// SetUp
+        /// </summary>
+        public BuildManager_Logging_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+            // Ensure that any previous tests which may have been using the default BuildManager do not conflict with us.
+            BuildManager.DefaultBuildManager.Dispose();
+
+            _logger = new MockLogger(output);
+            _buildManager = new BuildManager();
+            _projectCollection = new ProjectCollection();
+
+            _env = TestEnvironment.Create(output);
+        }
+
+        [DotNetOnlyTheory]
+        [InlineData("1", true)]
+        // [InlineData("0", true)] <-- explicitly opting out on core will lead to node crash (as documented)
+        [InlineData(null, true)]
+        public void Build_WithCustomBuildArgs_NetCore(string envVariableValue, bool isWarningExpected)
+            => TestCustomEventWarning<BuildErrorEventArgs>(envVariableValue, isWarningExpected);
+
+        [WindowsFullFrameworkOnlyTheory]
+        [InlineData("1", true)]
+        [InlineData("0", false)]
+        [InlineData(null, false)]
+        public void Build_WithCustomBuildArgs_Framework(string envVariableValue, bool isWarningExpected) =>
+            TestCustomEventWarning<BuildWarningEventArgs>(envVariableValue, isWarningExpected);
+
+        private void TestCustomEventWarning<T>(string envVariableValue, bool isWarningExpected) where T : LazyFormattedBuildEventArgs
+        {
+            var testFiles = _env.CreateTestProjectWithFiles(string.Empty, new[] { "main", "child1" }, string.Empty);
+
+            ILoggingService service = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+            service.RegisterLogger(_logger);
+
+            _env.SetEnvironmentVariable("MSBUILDCUSTOMBUILDEVENTWARNING", envVariableValue);
+            _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
+
+            _buildManager.BeginBuild(BuildParameters);
+
+            try
+            {
+                var child1ProjectPath = testFiles.CreatedFiles[1];
+                var cleanedUpChildContents = CleanupFileContents(_childProjectWithCustomBuildEvent);
+                File.WriteAllText(child1ProjectPath, cleanedUpChildContents);
+
+                var mainProjectPath = testFiles.CreatedFiles[0];
+                var cleanedUpMainContents = CleanupFileContents(string.Format(_mainProject, child1ProjectPath));
+                File.WriteAllText(mainProjectPath, cleanedUpMainContents);
+
+                var buildRequestData = new BuildRequestData(
+                   mainProjectPath,
+                   new Dictionary<string, string>(),
+                   MSBuildConstants.CurrentToolsVersion,
+                   new[] { "MainTarget" },
+                   null);
+
+                var submission = _buildManager.PendBuildRequest(buildRequestData);
+                var result = submission.Execute();
+                var allEvents = _logger.AllBuildEvents;
+
+                if (isWarningExpected)
+                {
+                    allEvents.OfType<T>().ShouldHaveSingleItem();
+                    allEvents.First(x => x is T).Message.ShouldContain(
+                        string.Format(ResourceUtilities.GetResourceString("DeprecatedEventSerialization"),
+                        "MyCustomBuildEventArgs"));
+                }
+                else
+                {
+                    allEvents.OfType<T>().ShouldBeEmpty();
+                }
+            }
+            finally
+            {
+                _buildManager.EndBuild();
+            }
+        }
+
+        private BuildParameters BuildParameters => new BuildParameters(_projectCollection)
+        {
+            DisableInProcNode = true,
+            EnableNodeReuse = false,
+            Loggers = new ILogger[] { _logger }
+        };
+
+        /// <summary>
+        /// TearDown
+        /// </summary>
+        public void Dispose()
+        {
+            _buildManager.Dispose();
+            _projectCollection.Dispose();
+            _env.Dispose();
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/CustomBuildEventTask.cs b/src/Build.UnitTests/BackEnd/CustomBuildEventTask.cs
new file mode 100644
index 00000000000..4309ea61ea6
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/CustomBuildEventTask.cs
@@ -0,0 +1,25 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+#nullable disable
+
+namespace Microsoft.Build.UnitTests
+{
+    public class CustomBuildEventTask : Task
+    {
+        public override bool Execute()
+        {
+            MyCustomBuildEventArgs customBuildEvent = new() { RawMessage = "A message from MyCustomBuildEventArgs" };
+            BuildEngine.LogCustomEvent(customBuildEvent);
+
+            return true;
+        }
+
+        [Serializable]
+        public sealed class MyCustomBuildEventArgs : CustomBuildEventArgs { }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
new file mode 100644
index 00000000000..27b30d71997
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
@@ -0,0 +1,85 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+using System;
+using System.Globalization;
+using System.Linq;
+using Microsoft.Build.Framework.Telemetry;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests.Telemetry;
+
+public class LoggingConfigurationTelemetry_Tests
+{
+    [Fact]
+    public void LoggingConfigurationTelemetryIsThere()
+    {
+        KnownTelemetry.LoggingConfigurationTelemetry.ShouldNotBeNull();
+    }
+
+    [Fact]
+    public void BuildTelemetryConstructedHasNoProperties()
+    {
+        LoggingConfigurationTelemetry telemetry = new();
+
+        telemetry.EventName.ShouldBe("loggingConfiguration");
+        telemetry.TerminalLogger.ShouldBe(false);
+        telemetry.TerminalLoggerUserIntent.ShouldBeNull();
+        telemetry.TerminalLoggerUserIntentSource.ShouldBeNull();
+        telemetry.TerminalLoggerDefault.ShouldBeNull();
+        telemetry.TerminalLoggerDefaultSource.ShouldBeNull();
+        telemetry.ConsoleLogger.ShouldBe(false);
+        telemetry.ConsoleLoggerType.ShouldBeNull();
+        telemetry.ConsoleLoggerVerbosity.ShouldBeNull();
+        telemetry.FileLogger.ShouldBe(false);
+        telemetry.FileLoggerVerbosity.ShouldBeNull();
+        telemetry.FileLoggersCount.ShouldBe(0);
+        telemetry.FileLoggerVerbosity.ShouldBeNull();
+        telemetry.BinaryLogger.ShouldBe(false);
+        telemetry.BinaryLoggerUsedDefaultName.ShouldBe(false);
+
+        telemetry.UpdateEventProperties();
+        telemetry.Properties.Where(kv => kv.Value != bool.FalseString).ShouldBeEmpty();
+    }
+
+    [Fact]
+    public void BuildTelemetryCreateProperProperties()
+    {
+        LoggingConfigurationTelemetry telemetry = new()
+        {
+            TerminalLogger = true,
+            TerminalLoggerUserIntent = "on",
+            TerminalLoggerUserIntentSource = "arg",
+            TerminalLoggerDefault = "auto",
+            TerminalLoggerDefaultSource = "sdk",
+            ConsoleLogger = true,
+            ConsoleLoggerType = "serial",
+            ConsoleLoggerVerbosity = "minimal",
+            FileLogger = true,
+            FileLoggerType = "serial",
+            FileLoggersCount = 2,
+            FileLoggerVerbosity = "normal",
+            BinaryLogger = true,
+            BinaryLoggerUsedDefaultName = true
+        };
+
+        telemetry.UpdateEventProperties();
+
+        telemetry.Properties["TerminalLogger"].ShouldBe(bool.TrueString);
+        telemetry.Properties["TerminalLoggerUserIntent"].ShouldBe("on");
+        telemetry.Properties["TerminalLoggerUserIntentSource"].ShouldBe("arg");
+        telemetry.Properties["TerminalLoggerDefault"].ShouldBe("auto");
+        telemetry.Properties["TerminalLoggerDefaultSource"].ShouldBe("sdk");
+        telemetry.Properties["ConsoleLogger"].ShouldBe(bool.TrueString);
+        telemetry.Properties["ConsoleLoggerType"].ShouldBe("serial");
+        telemetry.Properties["ConsoleLoggerVerbosity"].ShouldBe("minimal");
+        telemetry.Properties["FileLogger"].ShouldBe(bool.TrueString);
+        telemetry.Properties["FileLoggerType"].ShouldBe("serial");
+        telemetry.Properties["FileLoggersCount"].ShouldBe("2");
+        telemetry.Properties["FileLoggerVerbosity"].ShouldBe("normal");
+        telemetry.Properties["BinaryLogger"].ShouldBe(bool.TrueString);
+        telemetry.Properties["BinaryLoggerUsedDefaultName"].ShouldBe(bool.TrueString);
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 13de6f28e6f..2d9699376c1 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using FluentAssertions;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -57,8 +58,21 @@ public void VerifyEventType()
             ProjectStartedEventArgs projectStarted = new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null);
             ProjectFinishedEventArgs projectFinished = new ProjectFinishedEventArgs("message", "help", "ProjectFile", true);
             ExternalProjectStartedEventArgs externalStartedEvent = new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames");
+            ExternalProjectFinishedEventArgs externalFinishedEvent = new("message", "help", "senderName", "projectFile", true);
             ProjectEvaluationStartedEventArgs evaluationStarted = new ProjectEvaluationStartedEventArgs();
             ProjectEvaluationFinishedEventArgs evaluationFinished = new ProjectEvaluationFinishedEventArgs();
+            AssemblyLoadBuildEventArgs assemblyLoad = new(AssemblyLoadingContext.Evaluation, null, null, "path", Guid.NewGuid(), null);
+            ExtendedBuildErrorEventArgs extError = new("extError", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
+            ExtendedBuildWarningEventArgs extWarning = new("extWarn", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
+            ExtendedBuildMessageEventArgs extMessage = new("extMsg", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", MessageImportance.Normal);
+            ExtendedCustomBuildEventArgs extCustom = new("extCustom", "message", "help", "sender");
+            CriticalBuildMessageEventArgs criticalMessage = new("Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "Sender", DateTime.Now, "arg1");
+            PropertyInitialValueSetEventArgs propInit = new("prop", "val", "propsource", "message", "help", "sender", MessageImportance.Normal);
+            MetaprojectGeneratedEventArgs metaProjectGenerated = new("metaName", "path", "message");
+            PropertyReassignmentEventArgs propReassign = new("prop", "prevValue", "newValue", "loc", "message", "help", "sender", MessageImportance.Normal);
+            ResponseFileUsedEventArgs responseFileUsed = new("path");
+            UninitializedPropertyReadEventArgs uninitializedPropertyRead = new("prop", "message", "help", "sender", MessageImportance.Normal);
+            EnvironmentVariableReadEventArgs environmentVariableRead = new("env", "message", "help", "sender", MessageImportance.Normal);
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -76,7 +90,20 @@ public void VerifyEventType()
             VerifyLoggingPacket(projectFinished, LoggingEventType.ProjectFinishedEvent);
             VerifyLoggingPacket(evaluationStarted, LoggingEventType.ProjectEvaluationStartedEvent);
             VerifyLoggingPacket(evaluationFinished, LoggingEventType.ProjectEvaluationFinishedEvent);
-            VerifyLoggingPacket(externalStartedEvent, LoggingEventType.CustomEvent);
+            VerifyLoggingPacket(externalStartedEvent, LoggingEventType.ExternalProjectStartedEvent);
+            VerifyLoggingPacket(externalFinishedEvent, LoggingEventType.ExternalProjectFinishedEvent);
+            VerifyLoggingPacket(assemblyLoad, LoggingEventType.AssemblyLoadEvent);
+            VerifyLoggingPacket(extError, LoggingEventType.ExtendedBuildErrorEvent);
+            VerifyLoggingPacket(extWarning, LoggingEventType.ExtendedBuildWarningEvent);
+            VerifyLoggingPacket(extMessage, LoggingEventType.ExtendedBuildMessageEvent);
+            VerifyLoggingPacket(extCustom, LoggingEventType.ExtendedCustomEvent);
+            VerifyLoggingPacket(criticalMessage, LoggingEventType.CriticalBuildMessage);
+            VerifyLoggingPacket(propInit, LoggingEventType.PropertyInitialValueSet);
+            VerifyLoggingPacket(metaProjectGenerated, LoggingEventType.MetaprojectGenerated);
+            VerifyLoggingPacket(propReassign, LoggingEventType.PropertyReassignment);
+            VerifyLoggingPacket(responseFileUsed, LoggingEventType.ResponseFileUsedEvent);
+            VerifyLoggingPacket(uninitializedPropertyRead, LoggingEventType.UninitializedPropertyRead);
+            VerifyLoggingPacket(environmentVariableRead, LoggingEventType.EnvironmentVariableReadEvent);
         }
 
         private static BuildEventContext CreateBuildEventContext()
@@ -218,6 +245,13 @@ public void TestTranslation()
             {
                 BuildEventArgs[] testArgs = new BuildEventArgs[]
                 {
+                    new ResponseFileUsedEventArgs("path"),
+                    new UninitializedPropertyReadEventArgs("prop", "message", "help", "sender", MessageImportance.Normal),
+                    new EnvironmentVariableReadEventArgs("env", "message", "help", "sender", MessageImportance.Normal) { BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6) },
+                    new PropertyReassignmentEventArgs("prop", "prevValue", "newValue", "loc", "message", "help", "sender", MessageImportance.Normal),
+                    new PropertyInitialValueSetEventArgs("prop", "val", "propsource", "message", "help", "sender", MessageImportance.Normal),
+                    new MetaprojectGeneratedEventArgs("metaName", "path", "message"),
+                    new CriticalBuildMessageEventArgs("Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "Sender", DateTime.Now, "arg1"),
                     new BuildFinishedEventArgs("Message", "Keyword", true),
                     new BuildStartedEventArgs("Message", "Help"),
                     new BuildMessageEventArgs("Message", "help", "sender", MessageImportance.Low),
@@ -236,11 +270,36 @@ public void TestTranslation()
                     new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null),
                     new ProjectFinishedEventArgs("message", "help", "ProjectFile", true),
                     new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames"),
+                    new ExternalProjectFinishedEventArgs("message", "help", "senderName", "projectFile", true),
                     CreateProjectEvaluationStarted(),
                     CreateProjectEvaluationFinished(),
-                    CreateTargetSkipped()
+                    new AssemblyLoadBuildEventArgs(AssemblyLoadingContext.Evaluation, "init", "aname", "path", Guid.NewGuid(), "domain", MessageImportance.Normal),
+                    CreateTargetSkipped(),
+                    new ExtendedBuildErrorEventArgs("extError", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", DateTime.UtcNow, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
+                    new ExtendedBuildWarningEventArgs("extWarn", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", DateTime.UtcNow, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
+                    new ExtendedBuildMessageEventArgs("extWarn", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", MessageImportance.Normal, DateTime.UtcNow, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
+                    new ExtendedCustomBuildEventArgs("extCustom", "message", "help", "sender", DateTime.UtcNow, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
                 };
-
                 foreach (BuildEventArgs arg in testArgs)
                 {
                     LogMessagePacket packet = new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(0, arg));
@@ -250,7 +309,17 @@ public void TestTranslation()
 
                     LogMessagePacket deserializedPacket = tempPacket as LogMessagePacket;
 
-                    CompareLogMessagePackets(packet, deserializedPacket);
+                    packet.Should().BeEquivalentTo(deserializedPacket, options => options
+                        .RespectingRuntimeTypes());
+
+                    BuildEventArgs args = packet.NodeBuildEvent?.Value;
+                    BuildEventArgs desArgs = deserializedPacket?.NodeBuildEvent?.Value;
+                    desArgs.Should().BeEquivalentTo(args, options => options
+                        .RespectingRuntimeTypes()
+                        // Since we use struct DictionaryEntry of class TaskItemData, generated DictionaryEntry.Equals compare TaskItemData by references.
+                        // Bellow will instruct equivalency test to not use DictionaryEntry.Equals but its public members for equivalency tests.
+                        .ComparingByMembers<DictionaryEntry>() 
+                        .WithTracing(), "Roundtrip deserialization of message type {0} should be equivalent", args.GetType().Name);
                 }
             }
             finally
@@ -273,249 +342,6 @@ private static void VerifyLoggingPacket(BuildEventArgs buildEvent, LoggingEventT
             Assert.True(Object.ReferenceEquals(buildEvent, packet.NodeBuildEvent.Value.Value)); // "Expected buildEvent to have the same object reference as packet.BuildEvent"
         }
 
-        /// <summary>
-        /// Compares two BuildEventArgs objects for equivalence.
-        /// </summary>
-        private void CompareNodeBuildEventArgs(KeyValuePair<int, BuildEventArgs> leftTuple, KeyValuePair<int, BuildEventArgs> rightTuple, bool expectInvalidBuildEventContext)
-        {
-            BuildEventArgs left = leftTuple.Value;
-            BuildEventArgs right = rightTuple.Value;
-
-            if (expectInvalidBuildEventContext)
-            {
-                Assert.Equal(BuildEventContext.Invalid, right.BuildEventContext);
-            }
-            else
-            {
-                Assert.Equal(left.BuildEventContext, right.BuildEventContext);
-            }
-
-            Assert.Equal(leftTuple.Key, rightTuple.Key);
-            Assert.Equal(left.HelpKeyword, right.HelpKeyword);
-            Assert.Equal(left.Message, right.Message);
-            Assert.Equal(left.SenderName, right.SenderName);
-            Assert.Equal(left.ThreadId, right.ThreadId);
-            Assert.Equal(left.Timestamp, right.Timestamp);
-        }
-
-        /// <summary>
-        /// Compares two LogMessagePacket objects for equivalence.
-        /// </summary>
-        private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket right)
-        {
-            Assert.Equal(left.EventType, right.EventType);
-            Assert.Equal(left.NodeBuildEvent.Value.Value.GetType(), right.NodeBuildEvent.Value.Value.GetType());
-
-            CompareNodeBuildEventArgs(left.NodeBuildEvent.Value, right.NodeBuildEvent.Value, left.EventType == LoggingEventType.CustomEvent /* expectInvalidBuildEventContext */);
-
-            switch (left.EventType)
-            {
-                case LoggingEventType.BuildErrorEvent:
-                    BuildErrorEventArgs leftError = left.NodeBuildEvent.Value.Value as BuildErrorEventArgs;
-                    BuildErrorEventArgs rightError = right.NodeBuildEvent.Value.Value as BuildErrorEventArgs;
-                    Assert.NotNull(leftError);
-                    Assert.NotNull(rightError);
-                    Assert.Equal(leftError.Code, rightError.Code);
-                    Assert.Equal(leftError.ColumnNumber, rightError.ColumnNumber);
-                    Assert.Equal(leftError.EndColumnNumber, rightError.EndColumnNumber);
-                    Assert.Equal(leftError.EndLineNumber, rightError.EndLineNumber);
-                    Assert.Equal(leftError.File, rightError.File);
-                    Assert.Equal(leftError.LineNumber, rightError.LineNumber);
-                    Assert.Equal(leftError.Message, rightError.Message);
-                    Assert.Equal(leftError.Subcategory, rightError.Subcategory);
-                    break;
-
-                case LoggingEventType.BuildFinishedEvent:
-                    BuildFinishedEventArgs leftFinished = left.NodeBuildEvent.Value.Value as BuildFinishedEventArgs;
-                    BuildFinishedEventArgs rightFinished = right.NodeBuildEvent.Value.Value as BuildFinishedEventArgs;
-                    Assert.NotNull(leftFinished);
-                    Assert.NotNull(rightFinished);
-                    Assert.Equal(leftFinished.Succeeded, rightFinished.Succeeded);
-                    break;
-
-                case LoggingEventType.BuildMessageEvent:
-                    BuildMessageEventArgs leftMessage = left.NodeBuildEvent.Value.Value as BuildMessageEventArgs;
-                    BuildMessageEventArgs rightMessage = right.NodeBuildEvent.Value.Value as BuildMessageEventArgs;
-                    Assert.NotNull(leftMessage);
-                    Assert.NotNull(rightMessage);
-                    Assert.Equal(leftMessage.Importance, rightMessage.Importance);
-                    break;
-
-                case LoggingEventType.BuildStartedEvent:
-                    BuildStartedEventArgs leftBuildStart = left.NodeBuildEvent.Value.Value as BuildStartedEventArgs;
-                    BuildStartedEventArgs rightBuildStart = right.NodeBuildEvent.Value.Value as BuildStartedEventArgs;
-                    Assert.NotNull(leftBuildStart);
-                    Assert.NotNull(rightBuildStart);
-                    break;
-
-                case LoggingEventType.BuildWarningEvent:
-                    BuildWarningEventArgs leftBuildWarn = left.NodeBuildEvent.Value.Value as BuildWarningEventArgs;
-                    BuildWarningEventArgs rightBuildWarn = right.NodeBuildEvent.Value.Value as BuildWarningEventArgs;
-                    Assert.NotNull(leftBuildWarn);
-                    Assert.NotNull(rightBuildWarn);
-                    Assert.Equal(leftBuildWarn.Code, rightBuildWarn.Code);
-                    Assert.Equal(leftBuildWarn.ColumnNumber, rightBuildWarn.ColumnNumber);
-                    Assert.Equal(leftBuildWarn.EndColumnNumber, rightBuildWarn.EndColumnNumber);
-                    Assert.Equal(leftBuildWarn.EndLineNumber, rightBuildWarn.EndLineNumber);
-                    Assert.Equal(leftBuildWarn.File, rightBuildWarn.File);
-                    Assert.Equal(leftBuildWarn.LineNumber, rightBuildWarn.LineNumber);
-                    Assert.Equal(leftBuildWarn.Subcategory, rightBuildWarn.Subcategory);
-                    break;
-
-                case LoggingEventType.CustomEvent:
-                    ExternalProjectStartedEventArgs leftCustom = left.NodeBuildEvent.Value.Value as ExternalProjectStartedEventArgs;
-                    ExternalProjectStartedEventArgs rightCustom = right.NodeBuildEvent.Value.Value as ExternalProjectStartedEventArgs;
-                    Assert.NotNull(leftCustom);
-                    Assert.NotNull(rightCustom);
-                    Assert.Equal(leftCustom.ProjectFile, rightCustom.ProjectFile);
-                    Assert.Equal(leftCustom.TargetNames, rightCustom.TargetNames);
-                    break;
-
-                case LoggingEventType.ProjectFinishedEvent:
-                    ProjectFinishedEventArgs leftProjectFinished = left.NodeBuildEvent.Value.Value as ProjectFinishedEventArgs;
-                    ProjectFinishedEventArgs rightProjectFinished = right.NodeBuildEvent.Value.Value as ProjectFinishedEventArgs;
-                    Assert.NotNull(leftProjectFinished);
-                    Assert.NotNull(rightProjectFinished);
-                    Assert.Equal(leftProjectFinished.ProjectFile, rightProjectFinished.ProjectFile);
-                    Assert.Equal(leftProjectFinished.Succeeded, rightProjectFinished.Succeeded);
-                    break;
-
-                case LoggingEventType.ProjectStartedEvent:
-                    ProjectStartedEventArgs leftProjectStarted = left.NodeBuildEvent.Value.Value as ProjectStartedEventArgs;
-                    ProjectStartedEventArgs rightProjectStarted = right.NodeBuildEvent.Value.Value as ProjectStartedEventArgs;
-                    Assert.NotNull(leftProjectStarted);
-                    Assert.NotNull(rightProjectStarted);
-                    Assert.Equal(leftProjectStarted.ParentProjectBuildEventContext, rightProjectStarted.ParentProjectBuildEventContext);
-                    Assert.Equal(leftProjectStarted.ProjectFile, rightProjectStarted.ProjectFile);
-                    Assert.Equal(leftProjectStarted.ProjectId, rightProjectStarted.ProjectId);
-                    Assert.Equal(leftProjectStarted.TargetNames, rightProjectStarted.TargetNames);
-
-                    // UNDONE: (Serialization.) We don't actually serialize the items at this time.
-                    // Assert.AreEqual(leftProjectStarted.Items, rightProjectStarted.Items);
-                    // UNDONE: (Serialization.) We don't actually serialize properties at this time.
-                    // Assert.AreEqual(leftProjectStarted.Properties, rightProjectStarted.Properties);
-                    break;
-
-                case LoggingEventType.ProjectEvaluationStartedEvent:
-                    ProjectEvaluationStartedEventArgs leftEvaluationStarted = left.NodeBuildEvent.Value.Value as ProjectEvaluationStartedEventArgs;
-                    ProjectEvaluationStartedEventArgs rightEvaluationStarted = right.NodeBuildEvent.Value.Value as ProjectEvaluationStartedEventArgs;
-                    Assert.NotNull(leftEvaluationStarted);
-                    Assert.NotNull(rightEvaluationStarted);
-                    Assert.Equal(leftEvaluationStarted.ProjectFile, rightEvaluationStarted.ProjectFile);
-                    break;
-
-                case LoggingEventType.ProjectEvaluationFinishedEvent:
-                    ProjectEvaluationFinishedEventArgs leftEvaluationFinished = left.NodeBuildEvent.Value.Value as ProjectEvaluationFinishedEventArgs;
-                    ProjectEvaluationFinishedEventArgs rightEvaluationFinished = right.NodeBuildEvent.Value.Value as ProjectEvaluationFinishedEventArgs;
-                    Assert.NotNull(leftEvaluationFinished);
-                    Assert.NotNull(rightEvaluationFinished);
-                    Assert.Equal(leftEvaluationFinished.ProjectFile, rightEvaluationFinished.ProjectFile);
-                    Assert.Equal(leftEvaluationFinished.ProfilerResult, rightEvaluationFinished.ProfilerResult);
-                    Assert.Equal(
-                        TranslationHelpers.GetPropertiesString(leftEvaluationFinished.GlobalProperties),
-                        TranslationHelpers.GetPropertiesString(rightEvaluationFinished.GlobalProperties));
-                    Assert.Equal(
-                        TranslationHelpers.GetPropertiesString(leftEvaluationFinished.Properties),
-                        TranslationHelpers.GetPropertiesString(rightEvaluationFinished.Properties));
-                    Assert.Equal(
-                        TranslationHelpers.GetMultiItemsString(leftEvaluationFinished.Items),
-                        TranslationHelpers.GetMultiItemsString(rightEvaluationFinished.Items));
-                    break;
-
-                case LoggingEventType.TargetFinishedEvent:
-                    TargetFinishedEventArgs leftTargetFinished = left.NodeBuildEvent.Value.Value as TargetFinishedEventArgs;
-                    TargetFinishedEventArgs rightTargetFinished = right.NodeBuildEvent.Value.Value as TargetFinishedEventArgs;
-                    Assert.NotNull(leftTargetFinished);
-                    Assert.NotNull(rightTargetFinished);
-                    Assert.Equal(leftTargetFinished.ProjectFile, rightTargetFinished.ProjectFile);
-                    Assert.Equal(leftTargetFinished.Succeeded, rightTargetFinished.Succeeded);
-                    Assert.Equal(leftTargetFinished.TargetFile, rightTargetFinished.TargetFile);
-                    Assert.Equal(leftTargetFinished.TargetName, rightTargetFinished.TargetName);
-                    // TODO: target output translation is a special case and is done in TranslateTargetFinishedEvent
-                    // Assert.Equal(leftTargetFinished.TargetOutputs, rightTargetFinished.TargetOutputs);
-                    break;
-
-                case LoggingEventType.TargetStartedEvent:
-                    TargetStartedEventArgs leftTargetStarted = left.NodeBuildEvent.Value.Value as TargetStartedEventArgs;
-                    TargetStartedEventArgs rightTargetStarted = right.NodeBuildEvent.Value.Value as TargetStartedEventArgs;
-                    Assert.NotNull(leftTargetStarted);
-                    Assert.NotNull(rightTargetStarted);
-                    Assert.Equal(leftTargetStarted.ProjectFile, rightTargetStarted.ProjectFile);
-                    Assert.Equal(leftTargetStarted.TargetFile, rightTargetStarted.TargetFile);
-                    Assert.Equal(leftTargetStarted.TargetName, rightTargetStarted.TargetName);
-                    break;
-
-                case LoggingEventType.TargetSkipped:
-                    TargetSkippedEventArgs leftTargetSkipped = left.NodeBuildEvent.Value.Value as TargetSkippedEventArgs;
-                    TargetSkippedEventArgs rightTargetSkipped = right.NodeBuildEvent.Value.Value as TargetSkippedEventArgs;
-                    Assert.Equal(leftTargetSkipped.BuildReason, rightTargetSkipped.BuildReason);
-                    Assert.Equal(leftTargetSkipped.SkipReason, rightTargetSkipped.SkipReason);
-                    Assert.Equal(leftTargetSkipped.BuildEventContext, rightTargetSkipped.BuildEventContext);
-                    Assert.Equal(leftTargetSkipped.OriginalBuildEventContext, rightTargetSkipped.OriginalBuildEventContext);
-                    Assert.Equal(leftTargetSkipped.Condition, rightTargetSkipped.Condition);
-                    Assert.Equal(leftTargetSkipped.EvaluatedCondition, rightTargetSkipped.EvaluatedCondition);
-                    Assert.Equal(leftTargetSkipped.Importance, rightTargetSkipped.Importance);
-                    Assert.Equal(leftTargetSkipped.OriginallySucceeded, rightTargetSkipped.OriginallySucceeded);
-                    Assert.Equal(leftTargetSkipped.ProjectFile, rightTargetSkipped.ProjectFile);
-                    Assert.Equal(leftTargetSkipped.TargetFile, rightTargetSkipped.TargetFile);
-                    Assert.Equal(leftTargetSkipped.TargetName, rightTargetSkipped.TargetName);
-                    Assert.Equal(leftTargetSkipped.ParentTarget, rightTargetSkipped.ParentTarget);
-                    break;
-
-                case LoggingEventType.TaskCommandLineEvent:
-                    TaskCommandLineEventArgs leftCommand = left.NodeBuildEvent.Value.Value as TaskCommandLineEventArgs;
-                    TaskCommandLineEventArgs rightCommand = right.NodeBuildEvent.Value.Value as TaskCommandLineEventArgs;
-                    Assert.NotNull(leftCommand);
-                    Assert.NotNull(rightCommand);
-                    Assert.Equal(leftCommand.CommandLine, rightCommand.CommandLine);
-                    Assert.Equal(leftCommand.Importance, rightCommand.Importance);
-                    Assert.Equal(leftCommand.TaskName, rightCommand.TaskName);
-                    break;
-
-                case LoggingEventType.TaskParameterEvent:
-                    var leftTaskParameter = left.NodeBuildEvent.Value.Value as TaskParameterEventArgs;
-                    var rightTaskParameter = right.NodeBuildEvent.Value.Value as TaskParameterEventArgs;
-                    Assert.NotNull(leftTaskParameter);
-                    Assert.NotNull(rightTaskParameter);
-                    Assert.Equal(leftTaskParameter.Kind, rightTaskParameter.Kind);
-                    Assert.Equal(leftTaskParameter.ItemType, rightTaskParameter.ItemType);
-                    Assert.Equal(leftTaskParameter.Items.Count, rightTaskParameter.Items.Count);
-                    Assert.Equal(leftTaskParameter.Message, rightTaskParameter.Message);
-                    Assert.Equal(leftTaskParameter.BuildEventContext, rightTaskParameter.BuildEventContext);
-                    Assert.Equal(leftTaskParameter.Timestamp, rightTaskParameter.Timestamp);
-                    Assert.Equal(leftTaskParameter.LineNumber, rightTaskParameter.LineNumber);
-                    Assert.Equal(leftTaskParameter.ColumnNumber, rightTaskParameter.ColumnNumber);
-                    break;
-
-                case LoggingEventType.TaskFinishedEvent:
-                    TaskFinishedEventArgs leftTaskFinished = left.NodeBuildEvent.Value.Value as TaskFinishedEventArgs;
-                    TaskFinishedEventArgs rightTaskFinished = right.NodeBuildEvent.Value.Value as TaskFinishedEventArgs;
-                    Assert.NotNull(leftTaskFinished);
-                    Assert.NotNull(rightTaskFinished);
-                    Assert.Equal(leftTaskFinished.ProjectFile, rightTaskFinished.ProjectFile);
-                    Assert.Equal(leftTaskFinished.Succeeded, rightTaskFinished.Succeeded);
-                    Assert.Equal(leftTaskFinished.TaskFile, rightTaskFinished.TaskFile);
-                    Assert.Equal(leftTaskFinished.TaskName, rightTaskFinished.TaskName);
-                    break;
-
-                case LoggingEventType.TaskStartedEvent:
-                    TaskStartedEventArgs leftTaskStarted = left.NodeBuildEvent.Value.Value as TaskStartedEventArgs;
-                    TaskStartedEventArgs rightTaskStarted = right.NodeBuildEvent.Value.Value as TaskStartedEventArgs;
-                    Assert.NotNull(leftTaskStarted);
-                    Assert.NotNull(rightTaskStarted);
-                    Assert.Equal(leftTaskStarted.ProjectFile, rightTaskStarted.ProjectFile);
-                    Assert.Equal(leftTaskStarted.TaskFile, rightTaskStarted.TaskFile);
-                    Assert.Equal(leftTaskStarted.TaskName, rightTaskStarted.TaskName);
-                    Assert.Equal(leftTaskStarted.LineNumber, rightTaskStarted.LineNumber);
-                    Assert.Equal(leftTaskStarted.ColumnNumber, rightTaskStarted.ColumnNumber);
-                    break;
-
-                default:
-                    Assert.True(false, string.Format("Unexpected logging event type {0}", left.EventType));
-                    break;
-            }
-        }
-
         #endregion
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
index 8d7f7f5936d..64ffc8fba5c 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
@@ -17,228 +17,973 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     public class TaskBuilderTestTask : IGeneratedTask
     {
+        /// <summary>
+        /// A custom <see cref="IConvertible"/> value type.
+        /// </summary>
+        /// <remarks>
+        /// Types like this one can be used only as Output parameter types because they can be converted to string
+        /// but not from string.
+        /// </remarks>
+        [Serializable]
+        public struct CustomStruct : IConvertible
+        {
+            private readonly object _value;
+
+            /// <summary>
+            /// Using <see cref="IConvertible"/> as the type of the <see cref="_value"/> field triggers a BinaryFormatter bug.
+            /// </summary>
+            private IConvertible Value => (IConvertible)_value;
+
+            public CustomStruct(IConvertible value)
+            {
+                _value = value;
+            }
+
+            public TypeCode GetTypeCode() => Value.GetTypeCode();
+            public bool ToBoolean(IFormatProvider provider) => Value.ToBoolean(provider);
+            public byte ToByte(IFormatProvider provider) => Value.ToByte(provider);
+            public char ToChar(IFormatProvider provider) => Value.ToChar(provider);
+            public DateTime ToDateTime(IFormatProvider provider) => Value.ToDateTime(provider);
+            public decimal ToDecimal(IFormatProvider provider) => Value.ToDecimal(provider);
+            public double ToDouble(IFormatProvider provider) => Value.ToDouble(provider);
+            public short ToInt16(IFormatProvider provider) => Value.ToInt16(provider);
+            public int ToInt32(IFormatProvider provider) => Value.ToInt32(provider);
+            public long ToInt64(IFormatProvider provider) => Value.ToInt64(provider);
+            public sbyte ToSByte(IFormatProvider provider) => Value.ToSByte(provider);
+            public float ToSingle(IFormatProvider provider) => Value.ToSingle(provider);
+            public string ToString(IFormatProvider provider) => Value.ToString(provider);
+            public object ToType(Type conversionType, IFormatProvider provider) => Value.ToType(conversionType, provider);
+            public ushort ToUInt16(IFormatProvider provider) => Value.ToUInt16(provider);
+            public uint ToUInt32(IFormatProvider provider) => Value.ToUInt32(provider);
+            public ulong ToUInt64(IFormatProvider provider) => Value.ToUInt64(provider);
+        }
+
+        /// <summary>
+        /// The <see cref="CustomStruct"/> value returned from <see cref="CustomStructOutput"/>.
+        /// </summary>
+        internal static readonly CustomStruct s_customStruct = new CustomStruct(42);
+
+        /// <summary>
+        /// The <see cref="CustomStruct[]"/> value returned from <see cref="CustomStructArrayOutput"/>.
+        /// </summary>
+        internal static readonly CustomStruct[] s_customStructArray = new CustomStruct[] { new CustomStruct(43), new CustomStruct(44) };
+
         /// <summary>
         /// The task host.
         /// </summary>
-        private ITestTaskHost _testTaskHost;
+        private ITestTaskHost _testTaskHost;
+
+        /// <summary>
+        /// The value to return from Execute.
+        /// </summary>
+        private bool _executeReturnValue;
+
+        /// <summary>
+        /// The value for the BoolOutput.
+        /// </summary>
+        private bool _boolOutput;
+
+        /// <summary>
+        /// The value for the BoolArrayOutput.
+        /// </summary>
+        private bool[] _boolArrayOutput;
+
+        /// <summary>
+        /// The value for the ByteOutput.
+        /// </summary>
+        private byte _byteOutput;
+
+        /// <summary>
+        /// The value for the ByteArrayOutput.
+        /// </summary>
+        private byte[] _byteArrayOutput;
+
+        /// <summary>
+        /// The value for the SByteOutput.
+        /// </summary>
+        private sbyte _sbyteOutput;
+
+        /// <summary>
+        /// The value for the SByteArrayOutput.
+        /// </summary>
+        private sbyte[] _sbyteArrayOutput;
+
+        /// <summary>
+        /// The value for the DoubleOutput.
+        /// </summary>
+        private double _doubleOutput;
+
+        /// <summary>
+        /// The value for the DoubleArrayOutput.
+        /// </summary>
+        private double[] _doubleArrayOutput;
+
+        /// <summary>
+        /// The value for the FloatOutput.
+        /// </summary>
+        private float _floatOutput;
+
+        /// <summary>
+        /// The value for the FloatArrayOutput.
+        /// </summary>
+        private float[] _floatArrayOutput;
+
+        /// <summary>
+        /// The value for the ShortOutput.
+        /// </summary>
+        private short _shortOutput;
+
+        /// <summary>
+        /// The value for the ShortArrayOutput.
+        /// </summary>
+        private short[] _shortArrayOutput;
+
+        /// <summary>
+        /// The value for the UShortOutput.
+        /// </summary>
+        private ushort _ushortOutput;
+
+        /// <summary>
+        /// The value for the UShortArrayOutput.
+        /// </summary>
+        private ushort[] _ushortArrayOutput;
+
+        /// <summary>
+        /// The value for the IntOutput.
+        /// </summary>
+        private int _intOutput;
+
+        /// <summary>
+        /// The value for the IntArrayOutput.
+        /// </summary>
+        private int[] _intArrayOutput;
+
+        /// <summary>
+        /// The value for the UIntOutput.
+        /// </summary>
+        private uint _uintOutput;
+
+        /// <summary>
+        /// The value for the UIntArrayOutput.
+        /// </summary>
+        private uint[] _uintArrayOutput;
+
+        /// <summary>
+        /// The value for the LongOutput.
+        /// </summary>
+        private long _longOutput;
+
+        /// <summary>
+        /// The value for the LongArrayOutput.
+        /// </summary>
+        private long[] _longArrayOutput;
+
+        /// <summary>
+        /// The value for the ULongOutput.
+        /// </summary>
+        private ulong _ulongOutput;
+
+        /// <summary>
+        /// The value for the ULongArrayOutput.
+        /// </summary>
+        private ulong[] _ulongArrayOutput;
+
+        /// <summary>
+        /// The value for the DecimalOutput.
+        /// </summary>
+        private decimal _decimalOutput;
+
+        /// <summary>
+        /// The value for the DecimalArrayOutput.
+        /// </summary>
+        private decimal[] _decimalArrayOutput;
+
+        /// <summary>
+        /// The value for the CharOutput.
+        /// </summary>
+        private char _charOutput;
+
+        /// <summary>
+        /// The value for the CharArrayOutput.
+        /// </summary>
+        private char[] _charArrayOutput;
+
+        /// <summary>
+        /// The value for the StringOutput.
+        /// </summary>
+        private string _stringOutput;
+
+        /// <summary>
+        /// The value for the StringArrayOutput.
+        /// </summary>
+        private string[] _stringArrayOutput;
+
+        /// <summary>
+        /// The value for the DateTimeOutput.
+        /// </summary>
+        private DateTime _dateTimeOutput;
+
+        /// <summary>
+        /// The value for the DateTimeArrayOutput.
+        /// </summary>
+        private DateTime[] _dateTimeArrayOutput;
+
+        /// <summary>
+        /// The value for the ItemOutput.
+        /// </summary>
+        private ITaskItem _itemOutput;
+
+        /// <summary>
+        /// The value for the ItemArrayOutput.
+        /// </summary>
+        private ITaskItem[] _itemArrayOutput;
+
+        /// <summary>
+        /// Property determining if Execute() should throw or not.
+        /// </summary>
+        public bool ThrowOnExecute
+        {
+            internal get;
+            set;
+        }
+
+        /// <summary>
+        /// A boolean parameter.
+        /// </summary>
+        public bool BoolParam
+        {
+            set
+            {
+                _boolOutput = value;
+                _testTaskHost?.ParameterSet("BoolParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A boolean array parameter.
+        /// </summary>
+        public bool[] BoolArrayParam
+        {
+            set
+            {
+                _boolArrayOutput = value;
+                _testTaskHost?.ParameterSet("BoolArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A byte parameter.
+        /// </summary>
+        public byte ByteParam
+        {
+            set
+            {
+                _byteOutput = value;
+                _testTaskHost?.ParameterSet("ByteParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A byte array parameter.
+        /// </summary>
+        public byte[] ByteArrayParam
+        {
+            set
+            {
+                _byteArrayOutput = value;
+                _testTaskHost?.ParameterSet("ByteArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An sbyte parameter.
+        /// </summary>
+        public sbyte SByteParam
+        {
+            set
+            {
+                _sbyteOutput = value;
+                _testTaskHost?.ParameterSet("SByteParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An sbyte array parameter.
+        /// </summary>
+        public sbyte[] SByteArrayParam
+        {
+            set
+            {
+                _sbyteArrayOutput = value;
+                _testTaskHost?.ParameterSet("SByteArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A double parameter.
+        /// </summary>
+        public double DoubleParam
+        {
+            set
+            {
+                _doubleOutput = value;
+                _testTaskHost?.ParameterSet("DoubleParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A double array parameter.
+        /// </summary>
+        public double[] DoubleArrayParam
+        {
+            set
+            {
+                _doubleArrayOutput = value;
+                _testTaskHost?.ParameterSet("DoubleArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A float parameter.
+        /// </summary>
+        public float FloatParam
+        {
+            set
+            {
+                _floatOutput = value;
+                _testTaskHost?.ParameterSet("FloatParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A float array parameter.
+        /// </summary>
+        public float[] FloatArrayParam
+        {
+            set
+            {
+                _floatArrayOutput = value;
+                _testTaskHost?.ParameterSet("FloatArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A short parameter.
+        /// </summary>
+        public short ShortParam
+        {
+            set
+            {
+                _shortOutput = value;
+                _testTaskHost?.ParameterSet("ShortParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A short array parameter.
+        /// </summary>
+        public short[] ShortArrayParam
+        {
+            set
+            {
+                _shortArrayOutput = value;
+                _testTaskHost?.ParameterSet("ShortArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A ushort parameter.
+        /// </summary>
+        public ushort UShortParam
+        {
+            set
+            {
+                _ushortOutput = value;
+                _testTaskHost?.ParameterSet("UShortParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A ushort array parameter.
+        /// </summary>
+        public ushort[] UShortArrayParam
+        {
+            set
+            {
+                _ushortArrayOutput = value;
+                _testTaskHost?.ParameterSet("UShortArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An integer parameter.
+        /// </summary>
+        public int IntParam
+        {
+            set
+            {
+                _intOutput = value;
+                _testTaskHost?.ParameterSet("IntParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An integer array parameter.
+        /// </summary>
+        public int[] IntArrayParam
+        {
+            set
+            {
+                _intArrayOutput = value;
+                _testTaskHost?.ParameterSet("IntArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A uint parameter.
+        /// </summary>
+        public uint UIntParam
+        {
+            set
+            {
+                _uintOutput = value;
+                _testTaskHost?.ParameterSet("UIntParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A uint array parameter.
+        /// </summary>
+        public uint[] UIntArrayParam
+        {
+            set
+            {
+                _uintArrayOutput = value;
+                _testTaskHost?.ParameterSet("UIntArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A long parameter.
+        /// </summary>
+        public long LongParam
+        {
+            set
+            {
+                _longOutput = value;
+                _testTaskHost?.ParameterSet("LongParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A long array parameter.
+        /// </summary>
+        public long[] LongArrayParam
+        {
+            set
+            {
+                _longArrayOutput = value;
+                _testTaskHost?.ParameterSet("LongArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A ulong parameter.
+        /// </summary>
+        public ulong ULongParam
+        {
+            set
+            {
+                _ulongOutput = value;
+                _testTaskHost?.ParameterSet("ULongParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A ulong array parameter.
+        /// </summary>
+        public ulong[] ULongArrayParam
+        {
+            set
+            {
+                _ulongArrayOutput = value;
+                _testTaskHost?.ParameterSet("ULongArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A decimal parameter.
+        /// </summary>
+        public decimal DecimalParam
+        {
+            set
+            {
+                _decimalOutput = value;
+                _testTaskHost?.ParameterSet("DecimalParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A decimal array parameter.
+        /// </summary>
+        public decimal[] DecimalArrayParam
+        {
+            set
+            {
+                _decimalArrayOutput = value;
+                _testTaskHost?.ParameterSet("DecimalArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A char parameter.
+        /// </summary>
+        public char CharParam
+        {
+            set
+            {
+                _charOutput = value;
+                _testTaskHost?.ParameterSet("CharParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A char array parameter.
+        /// </summary>
+        public char[] CharArrayParam
+        {
+            set
+            {
+                _charArrayOutput = value;
+                _testTaskHost?.ParameterSet("CharArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A string parameter.
+        /// </summary>
+        public string StringParam
+        {
+            set
+            {
+                _stringOutput = value;
+                _testTaskHost?.ParameterSet("StringParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A string array parameter.
+        /// </summary>
+        public string[] StringArrayParam
+        {
+            set
+            {
+                _stringArrayOutput = value;
+                _testTaskHost?.ParameterSet("StringArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A DateTime parameter.
+        /// </summary>
+        public DateTime DateTimeParam
+        {
+            set
+            {
+                _dateTimeOutput = value;
+                _testTaskHost?.ParameterSet("DateTimeParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A DateTime array parameter.
+        /// </summary>
+        public DateTime[] DateTimeArrayParam
+        {
+            set
+            {
+                _dateTimeArrayOutput = value;
+                _testTaskHost?.ParameterSet("DateTimeArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An item parameter.
+        /// </summary>
+        public ITaskItem ItemParam
+        {
+            set
+            {
+                _itemOutput = value;
+                _testTaskHost?.ParameterSet("ItemParam", value);
+            }
+        }
 
         /// <summary>
-        /// The value to return from Execute
+        /// An item array parameter.
         /// </summary>
-        private bool _executeReturnValue;
+        public ITaskItem[] ItemArrayParam
+        {
+            set
+            {
+                _itemArrayOutput = value;
+                _testTaskHost?.ParameterSet("ItemArrayParam", value);
+            }
+        }
 
         /// <summary>
-        /// The value for the BoolOutput
+        /// The Execute return value parameter.
         /// </summary>
-        private bool _boolOutput;
+        [Required]
+        public bool ExecuteReturnParam
+        {
+            set
+            {
+                _executeReturnValue = value;
+                _testTaskHost?.ParameterSet("ExecuteReturnParam", value);
+            }
+        }
 
         /// <summary>
-        /// The value for the BoolArrayOutput
+        /// A boolean output.
         /// </summary>
-        private bool[] _boolArrayOutput;
+        [Output]
+        public bool BoolOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("BoolOutput", _boolOutput);
+                return _boolOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the IntOutput
+        /// A boolean array output.
         /// </summary>
-        private int _intOutput;
+        [Output]
+        public bool[] BoolArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("BoolArrayOutput", _boolArrayOutput);
+                return _boolArrayOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the IntArrayOutput
+        /// A byte output.
         /// </summary>
-        private int[] _intArrayOutput;
+        [Output]
+        public byte ByteOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("ByteOutput", _byteOutput);
+                return _byteOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the StringOutput
+        /// A byte array output.
         /// </summary>
-        private string _stringOutput;
+        [Output]
+        public byte[] ByteArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("ByteArrayOutput", _byteArrayOutput);
+                return _byteArrayOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the StringArrayOutput
+        /// An sbyte output.
         /// </summary>
-        private string[] _stringArrayOutput;
+        [Output]
+        public sbyte SByteOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("SByteOutput", _sbyteOutput);
+                return _sbyteOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the ItemOutput
+        /// An sbyte array output.
         /// </summary>
-        private ITaskItem _itemOutput;
+        [Output]
+        public sbyte[] SByteArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("SByteArrayOutput", _sbyteArrayOutput);
+                return _sbyteArrayOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the ItemArrayOutput
+        /// A double output.
         /// </summary>
-        private ITaskItem[] _itemArrayOutput;
+        [Output]
+        public double DoubleOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DoubleOutput", _doubleOutput);
+                return _doubleOutput;
+            }
+        }
 
         /// <summary>
-        /// Property determining if Execute() should throw or not.
+        /// A double array output.
         /// </summary>
-        public bool ThrowOnExecute
+        [Output]
+        public double[] DoubleArrayOutput
         {
-            internal get;
-            set;
+            get
+            {
+                _testTaskHost?.OutputRead("DoubleArrayOutput", _doubleArrayOutput);
+                return _doubleArrayOutput;
+            }
         }
 
         /// <summary>
-        /// A boolean parameter
+        /// A float output.
         /// </summary>
-        public bool BoolParam
+        [Output]
+        public float FloatOutput
         {
-            set
+            get
             {
-                _boolOutput = value;
-                _testTaskHost?.ParameterSet("BoolParam", value);
+                _testTaskHost?.OutputRead("FloatOutput", _floatOutput);
+                return _floatOutput;
             }
         }
 
         /// <summary>
-        /// A boolean array parameter
+        /// A float array output.
         /// </summary>
-        public bool[] BoolArrayParam
+        [Output]
+        public float[] FloatArrayOutput
         {
-            set
+            get
             {
-                _boolArrayOutput = value;
-                _testTaskHost?.ParameterSet("BoolArrayParam", value);
+                _testTaskHost?.OutputRead("FloatArrayOutput", _floatArrayOutput);
+                return _floatArrayOutput;
             }
         }
 
         /// <summary>
-        /// An integer parameter
+        /// A short output.
         /// </summary>
-        public int IntParam
+        [Output]
+        public short ShortOutput
         {
-            set
+            get
             {
-                _intOutput = value;
-                _testTaskHost?.ParameterSet("IntParam", value);
+                _testTaskHost?.OutputRead("ShortOutput", _shortOutput);
+                return _shortOutput;
             }
         }
 
         /// <summary>
-        /// An integer array parameter.
+        /// A short array output.
         /// </summary>
-        public int[] IntArrayParam
+        [Output]
+        public short[] ShortArrayOutput
         {
-            set
+            get
             {
-                _intArrayOutput = value;
-                _testTaskHost?.ParameterSet("IntArrayParam", value);
+                _testTaskHost?.OutputRead("ShortArrayOutput", _shortArrayOutput);
+                return _shortArrayOutput;
             }
         }
 
         /// <summary>
-        /// A string parameter.
+        /// A ushort output.
         /// </summary>
-        public string StringParam
+        [Output]
+        public ushort UShortOutput
         {
-            set
+            get
             {
-                _stringOutput = value;
-                _testTaskHost?.ParameterSet("StringParam", value);
+                _testTaskHost?.OutputRead("UShortOutput", _ushortOutput);
+                return _ushortOutput;
             }
         }
 
         /// <summary>
-        /// A string array parameter.
+        /// A ushort array output.
         /// </summary>
-        public string[] StringArrayParam
+        [Output]
+        public ushort[] UShortArrayOutput
         {
-            set
+            get
             {
-                _stringArrayOutput = value;
-                _testTaskHost?.ParameterSet("StringArrayParam", value);
+                _testTaskHost?.OutputRead("UShortArrayOutput", _ushortArrayOutput);
+                return _ushortArrayOutput;
             }
         }
 
         /// <summary>
-        /// An item parameter.
+        /// An integer output.
         /// </summary>
-        public ITaskItem ItemParam
+        [Output]
+        public int IntOutput
         {
-            set
+            get
             {
-                _itemOutput = value;
-                _testTaskHost?.ParameterSet("ItemParam", value);
+                _testTaskHost?.OutputRead("IntOutput", _intOutput);
+                return _intOutput;
             }
         }
 
         /// <summary>
-        /// An item array parameter.
+        /// An integer array output.
         /// </summary>
-        public ITaskItem[] ItemArrayParam
+        [Output]
+        public int[] IntArrayOutput
         {
-            set
+            get
             {
-                _itemArrayOutput = value;
-                _testTaskHost?.ParameterSet("ItemArrayParam", value);
+                _testTaskHost?.OutputRead("IntArrayOutput", _intArrayOutput);
+                return _intArrayOutput;
             }
         }
 
         /// <summary>
-        /// The Execute return value parameter.
+        /// A uint output.
         /// </summary>
-        [Required]
-        public bool ExecuteReturnParam
+        [Output]
+        public uint UIntOutput
         {
-            set
+            get
             {
-                _executeReturnValue = value;
-                _testTaskHost?.ParameterSet("ExecuteReturnParam", value);
+                _testTaskHost?.OutputRead("UIntOutput", _uintOutput);
+                return _uintOutput;
             }
         }
 
         /// <summary>
-        /// A boolean output.
+        /// A uint array output.
         /// </summary>
         [Output]
-        public bool BoolOutput
+        public uint[] UIntArrayOutput
         {
             get
             {
-                _testTaskHost?.OutputRead("BoolOutput", _boolOutput);
-                return _boolOutput;
+                _testTaskHost?.OutputRead("UIntArrayOutput", _uintArrayOutput);
+                return _uintArrayOutput;
             }
         }
 
         /// <summary>
-        /// A boolean array output
+        /// A long output.
         /// </summary>
         [Output]
-        public bool[] BoolArrayOutput
+        public long LongOutput
         {
             get
             {
-                _testTaskHost?.OutputRead("BoolArrayOutput", _boolArrayOutput);
-                return _boolArrayOutput;
+                _testTaskHost?.OutputRead("LongOutput", _longOutput);
+                return _longOutput;
             }
         }
 
         /// <summary>
-        /// An integer output
+        /// A long array output.
         /// </summary>
         [Output]
-        public int IntOutput
+        public long[] LongArrayOutput
         {
             get
             {
-                _testTaskHost?.OutputRead("IntOutput", _intOutput);
-                return _intOutput;
+                _testTaskHost?.OutputRead("LongArrayOutput", _longArrayOutput);
+                return _longArrayOutput;
             }
         }
 
         /// <summary>
-        /// An integer array output
+        /// A ulong output.
         /// </summary>
         [Output]
-        public int[] IntArrayOutput
+        public ulong ULongOutput
         {
             get
             {
-                _testTaskHost?.OutputRead("IntArrayOutput", _intArrayOutput);
-                return _intArrayOutput;
+                _testTaskHost?.OutputRead("ULongOutput", _ulongOutput);
+                return _ulongOutput;
+            }
+        }
+
+        /// <summary>
+        /// A ulong array output.
+        /// </summary>
+        [Output]
+        public ulong[] ULongArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("ULongArrayOutput", _ulongArrayOutput);
+                return _ulongArrayOutput;
+            }
+        }
+
+        /// <summary>
+        /// A decimal output.
+        /// </summary>
+        [Output]
+        public decimal DecimalOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DecimalOutput", _decimalOutput);
+                return _decimalOutput;
+            }
+        }
+
+        /// <summary>
+        /// A decimal array output.
+        /// </summary>
+        [Output]
+        public decimal[] DecimalArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DecimalArrayOutput", _decimalArrayOutput);
+                return _decimalArrayOutput;
+            }
+        }
+
+        /// <summary>
+        /// A char output.
+        /// </summary>
+        [Output]
+        public char CharOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("CharOutput", _charOutput);
+                return _charOutput;
+            }
+        }
+
+        /// <summary>
+        /// A char array output.
+        /// </summary>
+        [Output]
+        public char[] CharArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("CharArrayOutput", _charArrayOutput);
+                return _charArrayOutput;
             }
         }
 
         /// <summary>
-        /// A string output
+        /// A string output.
         /// </summary>
         [Output]
         public string StringOutput
@@ -290,7 +1035,59 @@ public string NullStringOutput
         }
 
         /// <summary>
-        /// A null ITaskItem output
+        /// A DateTime output
+        /// </summary>
+        [Output]
+        public DateTime DateTimeOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DateTimeOutput", _dateTimeOutput);
+                return _dateTimeOutput;
+            }
+        }
+
+        /// <summary>
+        /// A DateTime array output.
+        /// </summary>
+        [Output]
+        public DateTime[] DateTimeArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DateTimeArrayOutput", _dateTimeArrayOutput);
+                return _dateTimeArrayOutput;
+            }
+        }
+
+        /// <summary>
+        /// A CustomStruct output.
+        /// </summary>
+        [Output]
+        public CustomStruct CustomStructOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("CustomStructOutput", s_customStruct);
+                return s_customStruct;
+            }
+        }
+
+        /// <summary>
+        /// A CustomStruct array output.
+        /// </summary>
+        [Output]
+        public CustomStruct[] CustomStructArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("CustomStructArrayOutput", s_customStructArray);
+                return s_customStructArray;
+            }
+        }
+
+        /// <summary>
+        /// A null ITaskItem output.
         /// </summary>
         [Output]
         public ITaskItem NullITaskItemOutput
@@ -303,7 +1100,7 @@ public ITaskItem NullITaskItemOutput
         }
 
         /// <summary>
-        /// A null string array output
+        /// A null string array output.
         /// </summary>
         [Output]
         public string[] NullStringArrayOutput
@@ -316,7 +1113,7 @@ public string[] NullStringArrayOutput
         }
 
         /// <summary>
-        /// A null ITaskItem array output
+        /// A null ITaskItem array output.
         /// </summary>
         [Output]
         public ITaskItem[] NullITaskItemArrayOutput
@@ -329,7 +1126,7 @@ public ITaskItem[] NullITaskItemArrayOutput
         }
 
         /// <summary>
-        /// A string array output
+        /// A string array output.
         /// </summary>
         [Output]
         public string[] StringArrayOutput
@@ -342,7 +1139,7 @@ public string[] StringArrayOutput
         }
 
         /// <summary>
-        /// A task item output
+        /// A task item output.
         /// </summary>
         [Output]
         public ITaskItem ItemOutput
@@ -355,7 +1152,7 @@ public ITaskItem ItemOutput
         }
 
         /// <summary>
-        /// A task item array output
+        /// A task item array output.
         /// </summary>
         [Output]
         public ITaskItem[] ItemArrayOutput
@@ -368,7 +1165,7 @@ public ITaskItem[] ItemArrayOutput
         }
 
         /// <summary>
-        /// A task item array output that is null
+        /// A task item array output that is null.
         /// </summary>
         [Output]
         public ITaskItem[] ItemArrayNullOutput
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index 7ca94153d09..f4644d4e358 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1029,6 +1029,25 @@ public void TestTaskResolutionFailureWithNoUsingTask()
             _logger.AssertLogContains("MSB4036");
         }
 
+        /// <summary>
+        /// https://github.com/dotnet/msbuild/issues/8864
+        /// </summary>
+        [Fact]
+        public void TestTaskDictionaryOutputItems()
+        {
+            string customTaskPath = Assembly.GetExecutingAssembly().Location;
+            MockLogger ml = ObjectModelHelpers.BuildProjectExpectSuccess($"""
+                    <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                        <UsingTask TaskName=`TaskThatReturnsDictionaryTaskItem` AssemblyFile=`{customTaskPath}`/>
+                        <Target Name=`Build`>
+                           <TaskThatReturnsDictionaryTaskItem Key="a" Value="b">
+                                <Output TaskParameter="DictionaryTaskItemOutput" ItemName="Outputs"/>
+                            </TaskThatReturnsDictionaryTaskItem>
+                        </Target>
+                    </Project>
+                """);
+            ml.AssertLogContains("a=b");
+        }
         #endregion
 
         #region ITestTaskHost Members
@@ -1423,11 +1442,11 @@ private ProjectInstance CreateTestProject()
                     <Target Name='Skip' Inputs='testProject.proj' Outputs='testProject.proj' />
 
                     <Target Name='Error' >
-                        <ErrorTask1 ContinueOnError='True'/>                    
-                        <ErrorTask2 ContinueOnError='False'/>  
-                        <ErrorTask3 /> 
-                        <OnError ExecuteTargets='Foo'/>                  
-                        <OnError ExecuteTargets='Bar'/>                  
+                        <ErrorTask1 ContinueOnError='True'/>
+                        <ErrorTask2 ContinueOnError='False'/>
+                        <ErrorTask3 />
+                        <OnError ExecuteTargets='Foo'/>
+                        <OnError ExecuteTargets='Bar'/>
                     </Target>
 
                     <Target Name='Foo' Inputs='foo.cpp' Outputs='foo.o'>
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index a3226a7df75..5c82a444f39 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -3,7 +3,10 @@
 
 using System;
 using System.Diagnostics;
+using System.Globalization;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.BackEnd;
 
@@ -58,37 +61,170 @@ public void TaskNodesDieAfterBuild()
             }
         }
 
-        [Fact]
-        public void VariousParameterTypesCanBeTransmittedToAndRecievedFromTaskHost()
+        [DotNetOnlyTheory]
+        [InlineData(false)]
+        // [InlineData(true)] <-- explicitly opting out on core will lead to node crash
+        public void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost_NetCore(
+            bool testLegacyImplementation)
+            => VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(testLegacyImplementation);
+
+        [WindowsFullFrameworkOnlyTheory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost_Framework(
+            bool testLegacyImplementation)
+            => VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(testLegacyImplementation);
+
+        private void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(bool testLegacyImplementation)
         {
             using TestEnvironment env = TestEnvironment.Create(_output);
 
+            ChangeWaves.ResetStateForTests();
+            if (testLegacyImplementation)
+            {
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+
+            string boolParam = "True";
+            string boolArrayParam = "False;True;False";
+            string byteParam = "42";
+            string byteArrayParam = "11;22;33";
+            string sbyteParam = "-42";
+            string sbyteArrayParam = "-11;-22;-33";
+            string doubleParam = "3.14";
+            string doubleArrayParam = "3.14;2.72";
+            string floatParam = "0.5";
+            string floatArrayParam = "0.6;0.7;0.8";
+            string shortParam = "-100";
+            string shortArrayParam = "-200;-300;999";
+            string ushortParam = "100";
+            string ushortArrayParam = "200;300;999";
+            string intParam = "-314";
+            string intArrayParam = "42;-67;98";
+            string uintParam = "314";
+            string uintArrayParam = "4200000;67;98";
+            string longParam = "-120000000000";
+            string longArrayParam = "-120000000000;0;1";
+            string ulongParam = "120000000000";
+            string ulongArrayParam = "120000000000;0;1";
+            string decimalParam = "0.999999999999";
+            string decimalArrayParam = "-0.999999999999";
+            string charParam = "A";
+            string charArrayParam = "A;b;2";
+            string stringParam = "stringParamInput";
+            string stringArrayParam = "stringArrayParamInput1;stringArrayParamInput2;stringArrayParamInput3";
+            string dateTimeParam = "01/01/2001 10:15:00";
+            string dateTimeArrayParam = "01/01/2001 10:15:00;02/02/2002 11:30:00;03/03/2003 12:45:00";
+
             string projectContents = $@"
 <Project>
     <UsingTask TaskName=""{nameof(TaskBuilderTestTask)}"" AssemblyFile=""{typeof(TaskBuilderTestTask).Assembly.Location}"" TaskFactory=""TaskHostFactory"" />
-    <Target Name='{nameof(VariousParameterTypesCanBeTransmittedToAndRecievedFromTaskHost)}'>
+    <Target Name='{nameof(VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost)}'>
         <{nameof(TaskBuilderTestTask)}
             ExecuteReturnParam=""true""
-            BoolParam=""true""
-            BoolArrayParam=""false;true;false""
-            IntParam=""314""
-            IntArrayParam=""42;67;98""
-            StringParam=""stringParamInput""
-            StringArrayParam=""stringArrayParamInput1;stringArrayParamInput2;stringArrayParamInput3"">
+            BoolParam=""{boolParam}""
+            BoolArrayParam=""{boolArrayParam}""
+            ByteParam=""{byteParam}""
+            ByteArrayParam=""{byteArrayParam}""
+            SByteParam=""{sbyteParam}""
+            SByteArrayParam=""{sbyteArrayParam}""
+            DoubleParam=""{doubleParam}""
+            DoubleArrayParam=""{doubleArrayParam}""
+            FloatParam=""{floatParam}""
+            FloatArrayParam=""{floatArrayParam}""
+            ShortParam=""{shortParam}""
+            ShortArrayParam=""{shortArrayParam}""
+            UShortParam=""{ushortParam}""
+            UShortArrayParam=""{ushortArrayParam}""
+            IntParam=""{intParam}""
+            IntArrayParam=""{intArrayParam}""
+            UIntParam=""{uintParam}""
+            UIntArrayParam=""{uintArrayParam}""
+            LongParam=""{longParam}""
+            LongArrayParam=""{longArrayParam}""
+            ULongParam=""{ulongParam}""
+            ULongArrayParam=""{ulongArrayParam}""
+            DecimalParam=""{decimalParam}""
+            DecimalArrayParam=""{decimalArrayParam}""
+            CharParam=""{charParam}""
+            CharArrayParam=""{charArrayParam}""
+            StringParam=""{stringParam}""
+            StringArrayParam=""{stringArrayParam}""
+            DateTimeParam=""{dateTimeParam}""
+            DateTimeArrayParam=""{dateTimeArrayParam}"">
 
             <Output PropertyName=""BoolOutput"" TaskParameter=""BoolOutput"" />
             <Output PropertyName=""BoolArrayOutput"" TaskParameter=""BoolArrayOutput"" />
+            <Output PropertyName=""ByteOutput"" TaskParameter=""ByteOutput"" />
+            <Output PropertyName=""ByteArrayOutput"" TaskParameter=""ByteArrayOutput"" />
+            <Output PropertyName=""SByteOutput"" TaskParameter=""SByteOutput"" />
+            <Output PropertyName=""SByteArrayOutput"" TaskParameter=""SByteArrayOutput"" />
+            <Output PropertyName=""DoubleOutput"" TaskParameter=""DoubleOutput"" />
+            <Output PropertyName=""DoubleArrayOutput"" TaskParameter=""DoubleArrayOutput"" />
+            <Output PropertyName=""FloatOutput"" TaskParameter=""FloatOutput"" />
+            <Output PropertyName=""FloatArrayOutput"" TaskParameter=""FloatArrayOutput"" />
+            <Output PropertyName=""ShortOutput"" TaskParameter=""ShortOutput"" />
+            <Output PropertyName=""ShortArrayOutput"" TaskParameter=""ShortArrayOutput"" />
+            <Output PropertyName=""UShortOutput"" TaskParameter=""UShortOutput"" />
+            <Output PropertyName=""UShortArrayOutput"" TaskParameter=""UShortArrayOutput"" />
             <Output PropertyName=""IntOutput"" TaskParameter=""IntOutput"" />
             <Output PropertyName=""IntArrayOutput"" TaskParameter=""IntArrayOutput"" />
-            <Output PropertyName=""EnumOutput"" TaskParameter=""EnumOutput"" />
+            <Output PropertyName=""UIntOutput"" TaskParameter=""UIntOutput"" />
+            <Output PropertyName=""UIntArrayOutput"" TaskParameter=""UIntArrayOutput"" />
+            <Output PropertyName=""LongOutput"" TaskParameter=""LongOutput"" />
+            <Output PropertyName=""LongArrayOutput"" TaskParameter=""LongArrayOutput"" />
+            <Output PropertyName=""ULongOutput"" TaskParameter=""ULongOutput"" />
+            <Output PropertyName=""ULongArrayOutput"" TaskParameter=""ULongArrayOutput"" />
+            <Output PropertyName=""DecimalOutput"" TaskParameter=""DecimalOutput"" />
+            <Output PropertyName=""DecimalArrayOutput"" TaskParameter=""DecimalArrayOutput"" />
+            <Output PropertyName=""CharOutput"" TaskParameter=""CharOutput"" />
+            <Output PropertyName=""CharArrayOutput"" TaskParameter=""CharArrayOutput"" />
             <Output PropertyName=""StringOutput"" TaskParameter=""StringOutput"" />
             <Output PropertyName=""StringArrayOutput"" TaskParameter=""StringArrayOutput"" />
+            <Output PropertyName=""DateTimeOutput"" TaskParameter=""DateTimeOutput"" />
+            <Output PropertyName=""DateTimeArrayOutput"" TaskParameter=""DateTimeArrayOutput"" />
+            <Output PropertyName=""CustomStructOutput"" TaskParameter=""CustomStructOutput"" />
+            <Output PropertyName=""EnumOutput"" TaskParameter=""EnumOutput"" />
         </{nameof(TaskBuilderTestTask)}>
     </Target>
 </Project>";
             TransientTestProjectWithFiles project = env.CreateTestProjectWithFiles(projectContents);
             ProjectInstance projectInstance = new(project.ProjectFile);
             projectInstance.Build(new[] { new MockLogger(env.Output) }).ShouldBeTrue();
+
+            projectInstance.GetPropertyValue("BoolOutput").ShouldBe(boolParam);
+            projectInstance.GetPropertyValue("BoolArrayOutput").ShouldBe(boolArrayParam);
+            projectInstance.GetPropertyValue("ByteOutput").ShouldBe(byteParam);
+            projectInstance.GetPropertyValue("ByteArrayOutput").ShouldBe(byteArrayParam);
+            projectInstance.GetPropertyValue("SByteOutput").ShouldBe(sbyteParam);
+            projectInstance.GetPropertyValue("SByteArrayOutput").ShouldBe(sbyteArrayParam);
+            projectInstance.GetPropertyValue("DoubleOutput").ShouldBe(doubleParam);
+            projectInstance.GetPropertyValue("DoubleArrayOutput").ShouldBe(doubleArrayParam);
+            projectInstance.GetPropertyValue("FloatOutput").ShouldBe(floatParam);
+            projectInstance.GetPropertyValue("FloatArrayOutput").ShouldBe(floatArrayParam);
+            projectInstance.GetPropertyValue("ShortOutput").ShouldBe(shortParam);
+            projectInstance.GetPropertyValue("ShortArrayOutput").ShouldBe(shortArrayParam);
+            projectInstance.GetPropertyValue("UShortOutput").ShouldBe(ushortParam);
+            projectInstance.GetPropertyValue("UShortArrayOutput").ShouldBe(ushortArrayParam);
+            projectInstance.GetPropertyValue("IntOutput").ShouldBe(intParam);
+            projectInstance.GetPropertyValue("IntArrayOutput").ShouldBe(intArrayParam);
+            projectInstance.GetPropertyValue("UIntOutput").ShouldBe(uintParam);
+            projectInstance.GetPropertyValue("UIntArrayOutput").ShouldBe(uintArrayParam);
+            projectInstance.GetPropertyValue("LongOutput").ShouldBe(longParam);
+            projectInstance.GetPropertyValue("LongArrayOutput").ShouldBe(longArrayParam);
+            projectInstance.GetPropertyValue("ULongOutput").ShouldBe(ulongParam);
+            projectInstance.GetPropertyValue("ULongArrayOutput").ShouldBe(ulongArrayParam);
+            projectInstance.GetPropertyValue("DecimalOutput").ShouldBe(decimalParam);
+            projectInstance.GetPropertyValue("DecimalArrayOutput").ShouldBe(decimalArrayParam);
+            projectInstance.GetPropertyValue("CharOutput").ShouldBe(charParam);
+            projectInstance.GetPropertyValue("CharArrayOutput").ShouldBe(charArrayParam);
+            projectInstance.GetPropertyValue("StringOutput").ShouldBe(stringParam);
+            projectInstance.GetPropertyValue("StringArrayOutput").ShouldBe(stringArrayParam);
+            projectInstance.GetPropertyValue("DateTimeOutput").ShouldBe(dateTimeParam);
+            projectInstance.GetPropertyValue("DateTimeArrayOutput").ShouldBe(dateTimeArrayParam);
+            projectInstance.GetPropertyValue("CustomStructOutput").ShouldBe(TaskBuilderTestTask.s_customStruct.ToString(CultureInfo.InvariantCulture));
+            projectInstance.GetPropertyValue("EnumOutput").ShouldBe(TargetBuiltReason.BeforeTargets.ToString());
         }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
index 8f4a5d6c1aa..3fe12dd13fe 100644
--- a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
@@ -385,6 +385,61 @@ public void TestLogCustomEventNotSerializableSP()
             Assert.Equal("testCustomBuildEvent", _customLogger.LastCustom.Message);
         }
 
+        /// <summary>
+        /// Test that extended custom events are logged properly
+        /// </summary>
+        [Fact]
+        public void TestLogExtendedCustomEventNotSerializableMP()
+        {
+            _mockHost.BuildParameters.MaxNodeCount = 4;
+
+            // Log the custom event args.  (Pretend that the task actually did this.)
+            _taskHost.LogCustomEvent(new ExtendedCustomBuildEventArgs("testExtCustomBuildEvent", "ext message", null, null));
+
+            // Make sure our custom logger received the actual custom event and not some fake.
+            Assert.True(_customLogger.LastCustom is ExtendedCustomBuildEventArgs); // "Expected custom build Event"
+            Assert.Equal("ext message", _customLogger.LastCustom.Message);
+        }
+
+        [Fact]
+        public void TestLogExtendedCustomErrorNotSerializableMP()
+        {
+            _mockHost.BuildParameters.MaxNodeCount = 4;
+
+            // Log the custom event args.  (Pretend that the task actually did this.)
+            _taskHost.LogErrorEvent(new ExtendedBuildErrorEventArgs("testExtCustomBuildError", null, null, null, 0, 0, 0, 0,"ext err message", null, null));
+
+            // Make sure our custom logger received the actual custom event and not some fake.
+            Assert.True(_customLogger.LastError is ExtendedBuildErrorEventArgs); // "Expected custom build Event"
+            Assert.Equal("ext err message", _customLogger.LastError.Message);
+        }
+
+        [Fact]
+        public void TestLogExtendedCustomWarningNotSerializableMP()
+        {
+            _mockHost.BuildParameters.MaxNodeCount = 4;
+
+            // Log the custom event args.  (Pretend that the task actually did this.)
+            _taskHost.LogWarningEvent(new ExtendedBuildWarningEventArgs("testExtCustomBuildWarning", null, null, null, 0, 0, 0, 0, "ext warn message", null, null));
+
+            // Make sure our custom logger received the actual custom event and not some fake.
+            Assert.True(_customLogger.LastWarning is ExtendedBuildWarningEventArgs); // "Expected custom build Event"
+            Assert.Equal("ext warn message", _customLogger.LastWarning.Message);
+        }
+
+        [Fact]
+        public void TestLogExtendedCustomMessageNotSerializableMP()
+        {
+            _mockHost.BuildParameters.MaxNodeCount = 4;
+
+            // Log the custom event args.  (Pretend that the task actually did this.)
+            _taskHost.LogMessageEvent(new ExtendedBuildMessageEventArgs("testExtCustomBuildMessage", "ext message", null, null, MessageImportance.Normal));
+
+            // Make sure our custom logger received the actual custom event and not some fake.
+            Assert.True(_customLogger.LastMessage is ExtendedBuildMessageEventArgs); // "Expected custom build Event"
+            Assert.Equal("ext message", _customLogger.LastMessage.Message);
+        }
+
         /// <summary>
         /// Test that errors are logged properly
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskThatReturnsDictionaryTaskItem.cs b/src/Build.UnitTests/BackEnd/TaskThatReturnsDictionaryTaskItem.cs
new file mode 100644
index 00000000000..c258beb89a4
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/TaskThatReturnsDictionaryTaskItem.cs
@@ -0,0 +1,210 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using Microsoft.Build.Framework;
+
+#nullable disable
+
+namespace Microsoft.Build.Engine.UnitTests;
+/// <summary>
+/// Task that returns a custom ITaskItem implementation that has a custom IDictionary type returned from CloneCustomMetadata()
+/// </summary>
+public sealed class TaskThatReturnsDictionaryTaskItem : Utilities.Task
+{
+    public string Key { get; set; }
+    public string Value { get; set; }
+
+    public override bool Execute()
+    {
+        var metaValue = new MinimalDictionary<string, string>
+        {
+            { Key, Value }
+        };
+        DictionaryTaskItemOutput = new MinimalDictionaryTaskItem(metaValue);
+        return true;
+    }
+
+    [Output]
+    public ITaskItem DictionaryTaskItemOutput { get; set; }
+
+    internal sealed class MinimalDictionaryTaskItem : ITaskItem
+    {
+        private MinimalDictionary<string, string> _metaData = new MinimalDictionary<string, string>();
+
+        public MinimalDictionaryTaskItem(MinimalDictionary<string, string> metaValue)
+        {
+            _metaData = metaValue;
+        }
+
+        public string ItemSpec { get => $"{nameof(MinimalDictionaryTaskItem)}spec"; set => throw new NotImplementedException(); }
+
+        public ICollection MetadataNames => throw new NotImplementedException();
+
+        public int MetadataCount => throw new NotImplementedException();
+
+        ICollection ITaskItem.MetadataNames => throw new NotImplementedException();
+
+        public IDictionary CloneCustomMetadata() => _metaData;
+
+        public string GetMetadata(string metadataName)
+        {
+            if (String.IsNullOrEmpty(metadataName))
+            {
+                throw new ArgumentNullException(nameof(metadataName));
+            }
+
+            string value = (string)_metaData[metadataName];
+            return value;
+        }
+
+        public void SetMetadata(string metadataName, string metadataValue) => throw new NotImplementedException();
+        public void RemoveMetadata(string metadataName) => throw new NotImplementedException();
+        public void CopyMetadataTo(ITaskItem destinationItem) => throw new NotImplementedException();
+    }
+}
+
+public sealed class MinimalDictionary<TKey, TValue> : IDictionary
+{
+    private List<TKey> _keys = new List<TKey>();
+    private List<TValue> _values = new List<TValue>();
+
+    public object this[object key]
+    {
+        get
+        {
+            int index = _keys.IndexOf((TKey)key);
+            return index == -1 ? throw new KeyNotFoundException() : (object)_values[index];
+        }
+        set
+        {
+            int index = _keys.IndexOf((TKey)key);
+            if (index == -1)
+            {
+                _keys.Add((TKey)key);
+                _values.Add((TValue)value);
+            }
+            else
+            {
+                _values[index] = (TValue)value;
+            }
+        }
+    }
+
+    public bool IsFixedSize => false;
+
+    public bool IsReadOnly => false;
+
+    public ICollection Keys => _keys;
+
+    public ICollection Values => _values;
+
+    public int Count => _keys.Count;
+
+    public bool IsSynchronized => false;
+
+    public object SyncRoot => throw new NotSupportedException();
+
+    public void Add(object key, object value)
+    {
+        if (_keys.Contains((TKey)key))
+        {
+            throw new ArgumentException("An item with the same key has already been added.");
+        }
+
+        _keys.Add((TKey)key);
+        _values.Add((TValue)value);
+    }
+
+    public void Clear()
+    {
+        _keys.Clear();
+        _values.Clear();
+    }
+
+    public bool Contains(object key)
+    {
+        return _keys.Contains((TKey)key);
+    }
+
+    public void CopyTo(Array array, int index)
+    {
+        if (array == null)
+        {
+            throw new ArgumentNullException(nameof(array));
+        }
+
+        if (array.Rank != 1)
+        {
+            throw new ArgumentException("Array must be one-dimensional.", nameof(array));
+        }
+
+        if (index < 0 || index > array.Length)
+        {
+            throw new ArgumentOutOfRangeException(nameof(index));
+        }
+
+        if (array.Length - index < Count)
+        {
+            throw new ArgumentException("The number of elements in the source is greater than the available space from index to the end of the destination array.");
+        }
+
+        for (int i = 0; i < Count; i++)
+        {
+            array.SetValue(new KeyValuePair<TKey, TValue>(_keys[i], _values[i]), index + i);
+        }
+    }
+
+    public IDictionaryEnumerator GetEnumerator() => new MinimalDictionaryEnumerator(_keys, _values);
+
+    public void Remove(object key)
+    {
+        int index = _keys.IndexOf((TKey)key);
+        if (index != -1)
+        {
+            _keys.RemoveAt(index);
+            _values.RemoveAt(index);
+        }
+    }
+
+    IEnumerator IEnumerable.GetEnumerator()
+    {
+        for (int i = 0; i < Count; i++)
+        {
+            yield return new KeyValuePair<TKey, TValue>(_keys[i], _values[i]);
+        }
+    }
+
+    private sealed class MinimalDictionaryEnumerator : IDictionaryEnumerator
+    {
+        private List<TKey> _keys;
+        private List<TValue> _values;
+        private int _index = -1;
+
+        public MinimalDictionaryEnumerator(List<TKey> keys, List<TValue> values)
+        {
+            _keys = keys;
+            _values = values;
+        }
+
+        public object Current => Entry;
+
+        public object Key => _keys[_index];
+
+        public object Value => _values[_index];
+
+        public DictionaryEntry Entry => new DictionaryEntry(Key, Value);
+
+        public bool MoveNext()
+        {
+            return ++_index < _keys.Count;
+        }
+
+        public void Reset()
+        {
+            _index = -1;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 168cca02bbe..9963b2338b5 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
+using Shouldly;
 using Xunit;
 
 #nullable disable
@@ -27,6 +28,26 @@ public BuildEventArgsSerializationTests()
             _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
         }
 
+        [Fact]
+        public void WriteBlobFromStream()
+        {
+            byte[] bytes = new byte[] { 1, 2, 3, 4, 5 };
+            MemoryStream inputStream = new MemoryStream(bytes);
+
+            MemoryStream outputStream = new MemoryStream();
+            using BinaryWriter binaryWriter = new BinaryWriter(outputStream);
+            BuildEventArgsWriter writer = new BuildEventArgsWriter(binaryWriter);
+
+            writer.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, inputStream);
+            binaryWriter.Flush();
+
+            outputStream.Position = 0;
+            BinaryReader binaryReader = new BinaryReader(outputStream);
+            Assert.Equal(BinaryLogRecordKind.ProjectImportArchive, (BinaryLogRecordKind)binaryReader.Read7BitEncodedInt());
+            Assert.Equal(bytes.Length, binaryReader.Read7BitEncodedInt());
+            Assert.Equal(bytes, binaryReader.ReadBytes(bytes.Length));
+        }
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
@@ -242,6 +263,40 @@ public void RoundtripBuildErrorEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool useArguments)
+        {
+            var args = new ExtendedBuildErrorEventArgs(
+                "extendedDataType",
+                "Subcategory",
+                "Code",
+                "File",
+                1,
+                2,
+                3,
+                4,
+                "Message with arguments: '{0}'",
+                "Help",
+                "SenderName",
+                DateTime.Parse("9/1/2021 12:02:07 PM"),
+                useArguments ? new object[] { "argument0" } : null);
+
+            // For now we don't serialize extended data into binary log
+            Roundtrip<BuildErrorEventArgs>(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
@@ -274,6 +329,40 @@ public void RoundtripBuildWarningEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool useArguments)
+        {
+            var args = new ExtendedBuildWarningEventArgs(
+                "extendedDataType",
+                "Subcategory",
+                "Code",
+                "File",
+                1,
+                2,
+                3,
+                4,
+                "Message with arguments: '{0}'",
+                "Help",
+                "SenderName",
+                DateTime.Parse("9/1/2021 12:02:07 PM"),
+                useArguments ? new object[] { "argument0" } : null);
+
+            // For now we don't serialize extended data into binary log
+            Roundtrip<BuildWarningEventArgs>(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
@@ -308,6 +397,122 @@ public void RoundtripBuildMessageEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool useArguments)
+        {
+            var args = new ExtendedBuildMessageEventArgs(
+                "extendedDataType",
+                "Subcategory",
+                "Code",
+                "File",
+                1, 
+                2,
+                3,
+                4,
+                "Message",
+                "Help",
+                "SenderName",
+                MessageImportance.High,
+                DateTime.Parse("12/12/2015 06:11:56 PM"),
+                useArguments ? new object[] { "argument0" } : null);
+
+            Roundtrip<BuildMessageEventArgs>(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.Importance.ToString(),
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
+        [Fact]
+        public void RoundtripAssemblyLoadBuild()
+        {
+            string assemblyName = Guid.NewGuid().ToString();
+            string assemblyPath = Guid.NewGuid().ToString();
+            Guid mvid = Guid.NewGuid();
+            string loadingInitiator = Guid.NewGuid().ToString();
+            string appDomainName = Guid.NewGuid().ToString();
+            AssemblyLoadingContext context =
+                (AssemblyLoadingContext)(new Random().Next(Enum.GetNames(typeof(AssemblyLoadingContext)).Length));
+
+            AssemblyLoadBuildEventArgs args = new(context, loadingInitiator, assemblyName, assemblyPath, mvid, appDomainName);
+
+            Roundtrip(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.Importance.ToString(),
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => e.LoadingContext.ToString(),
+                e => e.AssemblyName,
+                e => e.AssemblyPath,
+                e => e.MVID.ToString(),
+                e => e.AppDomainDescriptor,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ExtendedCustomBuildEventArgs_SerializedAsMessage(bool withOptionalData)
+        {
+            ExtendedCustomBuildEventArgs args = new(
+                type: "TypeOfExtendedCustom",
+                message: withOptionalData ? "a message with args {0} {1}" : null,
+                helpKeyword: withOptionalData ? "MSBT123" : null,
+                senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+                eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+                messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
+
+
+            var memoryStream = new MemoryStream();
+            var binaryWriter = new BinaryWriter(memoryStream);
+            var buildEventArgsWriter = new BuildEventArgsWriter(binaryWriter);
+            buildEventArgsWriter.Write(args);
+
+            memoryStream.Position = 0;
+            var binaryReader = new BinaryReader(memoryStream);
+
+            using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
+            var deserialized = buildEventArgsReader.Read();
+            BuildMessageEventArgs desArgs = (BuildMessageEventArgs)deserialized;
+
+            desArgs.ShouldBeOfType(typeof(BuildMessageEventArgs));
+
+            desArgs.Message.ShouldBe(args.Message);
+            desArgs.HelpKeyword.ShouldBe(args.HelpKeyword);
+            desArgs.SenderName.ShouldBe(args.SenderName);
+            desArgs.Importance.ShouldBe(MessageImportance.Normal);
+            desArgs.Timestamp.ShouldBe(args.Timestamp);
+
+            if (withOptionalData)
+            {
+                desArgs.BuildEventContext.ShouldBe(args.BuildEventContext);
+            }
+            else
+            {
+                desArgs.BuildEventContext.ShouldBe(BuildEventContext.Invalid);
+            }
+        }
+
         [Fact]
         public void RoundtripResponseFileUsedEventArgs()
         {
@@ -669,7 +874,7 @@ private void Roundtrip<T>(T args, params Func<T, string>[] fieldsToCompare)
             Assert.Equal(length, memoryStream.Position);
 
             Assert.NotNull(deserializedArgs);
-            Assert.Equal(args.GetType(), deserializedArgs.GetType());
+            Assert.Equal(typeof(T), deserializedArgs.GetType());
 
             foreach (var field in fieldsToCompare)
             {
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index 84c24cb12b0..278c11f36ed 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -282,7 +282,7 @@ public void CanBeMSBuildFileRejectsMSBuildLikeFiles()
                 string solutionFileContents =
                     @"
                     Microsoft Visual Studio Solution File, Format Version 8.00
-                        Project('{F14B399A-7131-4C87-9E4B-1186C45EF12D}') = 'PrtProj', '" + Path.GetFileName(rptprojPath) + @"', '{CCCCCCCC-9925-4D57-9DAF-E0A9D936ABDB}'
+                        Project('{F14B399A-7131-4C87-9E4B-1186C45EF12D}') = 'RptProj', '" + Path.GetFileName(rptprojPath) + @"', '{CCCCCCCC-9925-4D57-9DAF-E0A9D936ABDB}'
                             ProjectSection(ProjectDependencies) = postProject
                             EndProjectSection
                         EndProject
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 997f7dd24dc..431ea412875 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -695,8 +695,9 @@ private void AssertSolutionBasedGraph(
             var globalProperties = currentSolutionConfiguration != null
                 ? new Dictionary<string, string>
                 {
-                    ["Configuration"] = currentSolutionConfiguration.ConfigurationName,
-                    ["Platform"] = currentSolutionConfiguration.PlatformName
+                    // Intentionally use mismatched casing to ensure it's properly normalized.
+                    ["Configuration"] = currentSolutionConfiguration.ConfigurationName.ToUpperInvariant(),
+                    ["Platform"] = currentSolutionConfiguration.PlatformName.ToUpperInvariant()
                 }
                 : new Dictionary<string, string>();
 
@@ -706,6 +707,9 @@ private void AssertSolutionBasedGraph(
                     globalProperties),
                 _env.CreateProjectCollection().Collection);
 
+            // Exactly 1 node per project
+            graph.ProjectNodes.Count.ShouldBe(graph.ProjectNodes.Select(GetProjectPath).Distinct().Count());
+
             // in the solution, all nodes are entry points
             graphFromSolution.EntryPointNodes.Select(GetProjectPath)
                 .ShouldBeSetEquivalentTo(graph.ProjectNodes.Select(GetProjectPath));
@@ -724,19 +728,9 @@ private void AssertSolutionBasedGraph(
 
             foreach (var node in graphFromSolution.ProjectNodes)
             {
-                // Project references get duplicated, once as entry points from the solution (handled in the if block) and once as nodes
-                // produced by ProjectReference items (handled in the else block).
-                if (node.ReferencingProjects.Count == 0)
-                {
-                    var expectedProjectConfiguration = actualProjectConfigurations[GetProjectNumber(node).ToString()][expectedCurrentConfiguration];
-                    GetConfiguration(node).ShouldBe(expectedProjectConfiguration.ConfigurationName);
-                    GetPlatform(node).ShouldBe(expectedProjectConfiguration.PlatformName);
-                }
-                else
-                {
-                    GetConfiguration(node).ShouldBe(GetConfiguration(node.ReferencingProjects.First()));
-                    GetPlatform(node).ShouldBe(GetPlatform(node.ReferencingProjects.First()));
-                }
+                var expectedProjectConfiguration = actualProjectConfigurations[GetProjectNumber(node).ToString()][expectedCurrentConfiguration];
+                GetConfiguration(node).ShouldBe(expectedProjectConfiguration.ConfigurationName);
+                GetPlatform(node).ShouldBe(expectedProjectConfiguration.PlatformName);
             }
         }
 
diff --git a/src/Build.UnitTests/InvalidProjectFileException_Tests.cs b/src/Build.UnitTests/InvalidProjectFileException_Tests.cs
index 499927b7c47..8e1d50c18d6 100644
--- a/src/Build.UnitTests/InvalidProjectFileException_Tests.cs
+++ b/src/Build.UnitTests/InvalidProjectFileException_Tests.cs
@@ -22,42 +22,6 @@ public InvalidProjectFileExceptionTests(ITestOutputHelper output)
             _testOutput = output;
         }
 
-        /// <summary>
-        /// Verify I implemented ISerializable correctly
-        /// </summary>
-        [Fact]
-        public void SerializeDeserialize()
-        {
-            InvalidProjectFileException e = new InvalidProjectFileException(
-                "projectFile",
-                1, 2, 3, 4,
-                "message",
-                "errorSubcategory",
-                "errorCode",
-                "helpKeyword");
-
-            using (MemoryStream memstr = new MemoryStream())
-            {
-                BinaryFormatter frm = new BinaryFormatter();
-
-                frm.Serialize(memstr, e);
-                memstr.Position = 0;
-
-                InvalidProjectFileException e2 = (InvalidProjectFileException)frm.Deserialize(memstr);
-
-                Assert.Equal(e.ColumnNumber, e2.ColumnNumber);
-                Assert.Equal(e.EndColumnNumber, e2.EndColumnNumber);
-                Assert.Equal(e.EndLineNumber, e2.EndLineNumber);
-                Assert.Equal(e.ErrorCode, e2.ErrorCode);
-                Assert.Equal(e.ErrorSubcategory, e2.ErrorSubcategory);
-                Assert.Equal(e.HasBeenLogged, e2.HasBeenLogged);
-                Assert.Equal(e.HelpKeyword, e2.HelpKeyword);
-                Assert.Equal(e.LineNumber, e2.LineNumber);
-                Assert.Equal(e.Message, e2.Message);
-                Assert.Equal(e.ProjectFile, e2.ProjectFile);
-            }
-        }
-
         /// <summary>
         /// Verify that nesting an IPFE copies the error code
         /// </summary>
diff --git a/src/Build.UnitTests/LoggerException_Tests.cs b/src/Build.UnitTests/LoggerException_Tests.cs
deleted file mode 100644
index 6a052a7ee27..00000000000
--- a/src/Build.UnitTests/LoggerException_Tests.cs
+++ /dev/null
@@ -1,49 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.IO;
-using System.Runtime.Serialization.Formatters.Binary;
-using Microsoft.Build.Exceptions;
-using Microsoft.Build.Framework;
-using Xunit;
-
-#nullable disable
-
-namespace Microsoft.Build.UnitTests
-{
-    public class InternalLoggerExceptionTests
-    {
-        /// <summary>
-        /// Verify I implemented ISerializable correctly
-        /// </summary>
-        [Fact]
-        public void SerializeDeserialize()
-        {
-            InternalLoggerException e = new InternalLoggerException(
-                "message",
-                new Exception("innerException"),
-                new BuildStartedEventArgs("evMessage", "evHelpKeyword"),
-                "errorCode",
-                "helpKeyword",
-                false);
-
-            using (MemoryStream memstr = new MemoryStream())
-            {
-                BinaryFormatter frm = new BinaryFormatter();
-
-                frm.Serialize(memstr, e);
-                memstr.Position = 0;
-
-                InternalLoggerException e2 = (InternalLoggerException)frm.Deserialize(memstr);
-
-                Assert.Equal(e.BuildEventArgs.Message, e2.BuildEventArgs.Message);
-                Assert.Equal(e.BuildEventArgs.HelpKeyword, e2.BuildEventArgs.HelpKeyword);
-                Assert.Equal(e.ErrorCode, e2.ErrorCode);
-                Assert.Equal(e.HelpKeyword, e2.HelpKeyword);
-                Assert.Equal(e.Message, e2.Message);
-                Assert.Equal(e.InnerException.Message, e2.InnerException.Message);
-            }
-        }
-    }
-}
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index ff426e28362..92fc5c72239 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -16,7 +16,7 @@
 
   <ItemGroup>
     <Reference Include="System.IO.Compression" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
-
+    <PackageReference Include="FluentAssertions" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
diff --git a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
deleted file mode 100644
index 66ef134bbe3..00000000000
--- a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
+++ /dev/null
@@ -1,68 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Text;
-using System.Xml;
-using Microsoft.Build.Construction;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework.Profiler;
-using Microsoft.Build.UnitTests.BackEnd;
-using Xunit;
-
-#nullable disable
-
-namespace Microsoft.Build.UnitTests
-{
-    // Although this tests the ProfilerResult API from Microsoft.Build.Framework, it uses the
-    //  construction APIs in Microsoft.Build in the test, so this test is in the Microsoft.Build tests
-    public class ProjectEvaluationFinishedEventArgs_Tests
-    {
-        /// <summary>
-        /// Roundtrip serialization tests for <see cref="ProfilerResult"/>
-        /// </summary>
-        [MemberData(nameof(GetProfilerResults))]
-        [Theory]
-        public void ProfilerResultRoundTrip(ProfilerResult profilerResult)
-        {
-            var writeTranslator = TranslationHelpers.GetWriteTranslator();
-            ProfilerResult deserializedResult = default;
-
-            writeTranslator.TranslateDotNet(ref profilerResult);
-
-            var readTranslator = TranslationHelpers.GetReadTranslator();
-
-            readTranslator.TranslateDotNet(ref deserializedResult);
-
-            Assert.Equal(deserializedResult, profilerResult);
-        }
-
-        public static IEnumerable<object[]> GetProfilerResults()
-        {
-            yield return new object[] { new ProfilerResult(new Dictionary<EvaluationLocation, ProfiledLocation>()) };
-
-            yield return new object[] { new ProfilerResult(new Dictionary<EvaluationLocation, ProfiledLocation>
-            {
-                {new EvaluationLocation(0, null, EvaluationPass.TotalEvaluation, "1", "myFile", 42, "elementName", "description", EvaluationLocationKind.Condition), new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2) },
-                {new EvaluationLocation(1, 0, EvaluationPass.Targets, "1", null, null, null, null, EvaluationLocationKind.Glob), new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2) },
-                {new EvaluationLocation(2, 0, EvaluationPass.LazyItems, "2", null, null, null, null, EvaluationLocationKind.Element), new ProfiledLocation(TimeSpan.Zero, TimeSpan.Zero, 0) }
-            }) };
-
-            var element = new ProjectRootElement(
-                XmlReader.Create(new MemoryStream(Encoding.UTF8.GetBytes(
-                    "<Project />"))),
-                new ProjectRootElementCache(false), false, false);
-
-            yield return new object[] { new ProfilerResult(new Dictionary<EvaluationLocation, ProfiledLocation>
-            {
-                {EvaluationLocation.CreateLocationForCondition(null, EvaluationPass.UsingTasks, "1", "myFile", 42, "conditionCase"), new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2) },
-                {EvaluationLocation.CreateLocationForProject(null, EvaluationPass.InitialProperties, "1", "myFile", 42, element),
-                    new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2) },
-                {EvaluationLocation.CreateLocationForGlob(null, EvaluationPass.InitialProperties, "1", "myFile", 42, "glob description"),
-                new ProfiledLocation(TimeSpan.MaxValue, TimeSpan.MinValue, 2) }
-            }) };
-        }
-    }
-}
diff --git a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
new file mode 100644
index 00000000000..84e458f6a54
--- /dev/null
+++ b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
@@ -0,0 +1,237 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Framework.Telemetry;
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.UnitTests;
+
+/// <summary>
+/// End to end tests for the terminal logger configuration.
+/// We need to execute msbuild process as tested code path is also in XMake.cs.
+/// Also verifies that the telemetry is logged correctly.
+/// Because we need to test the telemetry for the terminal logger, we need to use the MockLogger which outputs all telemetry properties.
+/// </summary>
+public class TerminalLoggerConfiguration_Tests : IDisposable
+{
+    private readonly TestEnvironment _env;
+
+    private readonly string _cmd;
+    private readonly ITestOutputHelper _output;
+
+    public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)
+    {
+        _env = TestEnvironment.Create(output);
+        _output = output;
+
+        // Ignore environment variables that may have been set by the environment where the tests are running.
+        _env.SetEnvironmentVariable("MSBUILDLIVELOGGER", null);
+        _env.SetEnvironmentVariable("MSBUILDTERMINALLOGGER", null);
+
+        TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);
+        TransientTestFile projectFile = _env.CreateFile(logFolder, "myProj.proj", $"""
+            <Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Hello">
+                <Target Name="Hello">
+                  <Message Text="Hello, world!" />
+                </Target>
+            </Project>
+            """);
+        _cmd = $"{projectFile.Path} -target:Hello -logger:{typeof(MockLogger).FullName},{typeof(MockLogger).Assembly.Location};ReportTelemetry";
+    }
+
+    /// <summary>
+    /// TearDown
+    /// </summary>
+    public void Dispose()
+    {
+        _env.Dispose();
+    }
+
+    [Theory]
+    [InlineData("on")]
+    [InlineData("true")]
+    public void TerminalLoggerOn(string tlValue)
+    {
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tl:{tlValue}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = true,
+            TerminalLoggerDefault = bool.FalseString,
+            TerminalLoggerDefaultSource = "msbuild",
+            TerminalLoggerUserIntent = tlValue,
+            TerminalLoggerUserIntentSource = "arg",
+            ConsoleLogger = false,
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldBeTerminalLog(output);
+    }
+
+    [Theory]
+    [InlineData("")]
+    [InlineData("auto")]
+    public void TerminalLoggerWithTlAutoIsOff(string tlValue)
+    {
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tl:{tlValue}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = false,
+            TerminalLoggerDefault = bool.FalseString,
+            TerminalLoggerDefaultSource = "msbuild",
+            TerminalLoggerUserIntent = tlValue,
+            TerminalLoggerUserIntentSource = "arg",
+            ConsoleLogger = true,
+            ConsoleLoggerType = "parallel",
+            ConsoleLoggerVerbosity = "normal",
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldNotBeTerminalLog(output);
+    }
+
+
+    [Fact]
+    public void TerminalLoggerDefaultByEnv()
+    {
+        _env.SetEnvironmentVariable("DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER", bool.TrueString);
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tlp:default={bool.TrueString}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = true,
+            TerminalLoggerDefault = bool.TrueString,
+            TerminalLoggerDefaultSource = "DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER",
+            TerminalLoggerUserIntent = null,
+            TerminalLoggerUserIntentSource = null,
+            ConsoleLogger = false,
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldBeTerminalLog(output);
+    }
+
+    [Theory]
+    [InlineData("MSBUILDLIVELOGGER")]
+    [InlineData("MSBUILDTERMINALLOGGER")]
+    public void TerminalLoggerOnByEnv(string envVarSource)
+    {
+        _env.SetEnvironmentVariable(envVarSource, bool.TrueString);
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = true,
+            TerminalLoggerDefault = bool.FalseString,
+            TerminalLoggerDefaultSource = "msbuild",
+            TerminalLoggerUserIntent = bool.TrueString,
+            TerminalLoggerUserIntentSource = envVarSource,
+            ConsoleLogger = false,
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldBeTerminalLog(output);
+    }
+
+    [Theory]
+    [InlineData("on")]
+    [InlineData("true")]
+    public void TerminalLoggerDefaultOn(string defaultValue)
+    {
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tlp:default={defaultValue}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = true,
+            TerminalLoggerDefault = defaultValue,
+            TerminalLoggerDefaultSource = "sdk",
+            TerminalLoggerUserIntent = null,
+            TerminalLoggerUserIntentSource = null,
+            ConsoleLogger = false,
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldBeTerminalLog(output);
+    }
+
+    [Theory]
+    [InlineData("off")]
+    [InlineData("false")]
+    public void TerminalLoggerDefaultOff(string defaultValue)
+    {
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tlp:default={defaultValue} -v:m", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = false,
+            TerminalLoggerDefault = defaultValue,
+            TerminalLoggerDefaultSource = "sdk",
+            TerminalLoggerUserIntent = null,
+            TerminalLoggerUserIntentSource = null,
+            ConsoleLogger = true,
+            ConsoleLoggerVerbosity = "minimal",
+            ConsoleLoggerType = "parallel", 
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldNotBeTerminalLog(output);
+    }
+
+    private static void ShouldBeTerminalLog(string output) => output.ShouldContain("\x1b[?25l");
+    private static void ShouldNotBeTerminalLog(string output) => output.ShouldNotContain("\x1b[?25l");
+}
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 66e67c82d3c..4c8bda783c3 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -335,13 +335,13 @@ private enum BuildManagerState
             Idle,
 
             /// <summary>
-            /// This is the state the BuildManager is in after <see cref="BeginBuild(BuildParameters)"/> has been called but before <see cref="EndBuild"/> has been called.
-            /// <see cref="BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.PendBuildRequest(GraphBuildRequestData)"/>, <see cref="BuildManager.BuildRequest(GraphBuildRequestData)"/>, and <see cref="BuildManager.EndBuild"/> may be called in this state.
+            /// This is the state the BuildManager is in after <see cref="BeginBuild(BuildParameters)"/> has been called but before <see cref="EndBuild()"/> has been called.
+            /// <see cref="BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.PendBuildRequest(GraphBuildRequestData)"/>, <see cref="BuildManager.BuildRequest(GraphBuildRequestData)"/>, and <see cref="BuildManager.EndBuild()"/> may be called in this state.
             /// </summary>
             Building,
 
             /// <summary>
-            /// This is the state the BuildManager is in after <see cref="BuildManager.EndBuild"/> has been called but before all existing submissions have completed.
+            /// This is the state the BuildManager is in after <see cref="BuildManager.EndBuild()"/> has been called but before all existing submissions have completed.
             /// </summary>
             WaitingForBuildToComplete
         }
@@ -566,6 +566,10 @@ public void BeginBuild(BuildParameters parameters)
                 // Log deferred messages and response files
                 LogDeferredMessages(loggingService, _deferredBuildMessages);
 
+                // Log known deferred telemetry
+                KnownTelemetry.LoggingConfigurationTelemetry.UpdateEventProperties();
+                loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.LoggingConfigurationTelemetry.EventName, KnownTelemetry.LoggingConfigurationTelemetry.Properties);
+
                 InitializeCaches();
 
                 _projectCacheService = new ProjectCacheService(
diff --git a/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs b/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs
index c3b525eec89..1bcd3206909 100644
--- a/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs
+++ b/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs
@@ -31,7 +31,7 @@ internal LogMessagePacket(KeyValuePair<int, BuildEventArgs>? nodeBuildEvent)
         /// Constructor for deserialization
         /// </summary>
         private LogMessagePacket(ITranslator translator)
-            : base(translator)
+            : base(translator, new TargetFinishedTranslator(TranslateTargetFinishedEvent))
         {
         }
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
index aa7efb8cd72..2bc967775f9 100644
--- a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
@@ -51,6 +51,9 @@ internal NodeFailedToLaunchException(string errorCode, string message)
         /// <summary>
         /// Constructor for deserialization.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected NodeFailedToLaunchException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
@@ -82,6 +85,9 @@ public string ErrorDescription
         /// </summary>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index dc8467773b0..2f95ae3f180 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -218,17 +218,17 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <summary>
         /// A list of warnings to treat as errors for an associated <see cref="BuildEventContext"/>.  If an empty set, all warnings are treated as errors.
         /// </summary>
-        private IDictionary<int, ISet<string>> _warningsAsErrorsByProject;
+        private IDictionary<WarningsConfigKey, ISet<string>> _warningsAsErrorsByProject;
 
         /// <summary>
         /// A list of warnings to not to be promoted to errors for an associated <see cref="BuildEventContext"/>.
         /// </summary>
-        private IDictionary<int, ISet<string>> _warningsNotAsErrorsByProject;
+        private IDictionary<WarningsConfigKey, ISet<string>> _warningsNotAsErrorsByProject;
 
         /// <summary>
         /// A list of warnings to treat as messages for an associated <see cref="BuildEventContext"/>.
         /// </summary>
-        private IDictionary<int, ISet<string>> _warningsAsMessagesByProject;
+        private IDictionary<WarningsConfigKey, ISet<string>> _warningsAsMessagesByProject;
 
         /// <summary>
         /// The minimum message importance that must be logged because there is a possibility that a logger consumes it.
@@ -623,9 +623,9 @@ public ICollection<string> GetWarningsAsMessages(BuildEventContext context)
         /// <param name="warningsByProject">A dictionary of all warnings to be treated special by for which projects.</param>
         /// <param name="warnings">Warning codes we already know should be promoted, demoted, or not promoted as relevant.</param>
         /// <returns></returns>
-        private ICollection<string> GetWarningsForProject(BuildEventContext context, IDictionary<int, ISet<string>> warningsByProject, ISet<string> warnings)
+        private ICollection<string> GetWarningsForProject(BuildEventContext context, IDictionary<WarningsConfigKey, ISet<string>> warningsByProject, ISet<string> warnings)
         {
-            int key = GetWarningsAsErrorOrMessageKey(context);
+            WarningsConfigKey key = GetWarningsConfigKey(context);
 
             if (warningsByProject != null && warningsByProject.TryGetValue(key, out ISet<string> newWarnings))
             {
@@ -678,13 +678,13 @@ public void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet<stri
         /// <param name="warningsByProject">Dictionary with what warnings are currently known (by project) that we will add to.</param>
         /// <param name="buildEventContext">Context for the project to be added</param>
         /// <param name="codes">Codes to add</param>
-        private void AddWarningsAsMessagesOrErrors(ref IDictionary<int, ISet<string>> warningsByProject, BuildEventContext buildEventContext, ISet<string> codes)
+        private void AddWarningsAsMessagesOrErrors(ref IDictionary<WarningsConfigKey, ISet<string>> warningsByProject, BuildEventContext buildEventContext, ISet<string> codes)
         {
             lock (_lockObject)
             {
-                int key = GetWarningsAsErrorOrMessageKey(buildEventContext);
+                WarningsConfigKey key = GetWarningsConfigKey(buildEventContext);
 
-                warningsByProject ??= new ConcurrentDictionary<int, ISet<string>>();
+                warningsByProject ??= new ConcurrentDictionary<WarningsConfigKey, ISet<string>>();
 
                 if (!warningsByProject.ContainsKey(key))
                 {
@@ -901,9 +901,60 @@ public void PacketReceived(int node, INodePacket packet)
 
             LogMessagePacket loggingPacket = (LogMessagePacket)packet;
             InjectNonSerializedData(loggingPacket);
+
+            WarnOnDeprecatedCustomArgsSerialization(loggingPacket);
+
             ProcessLoggingEvent(loggingPacket.NodeBuildEvent);
         }
 
+        /// <summary>
+        /// Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet.
+        /// Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom
+        /// EventArgs derived from existing EventArgs.
+        /// </summary>
+        private void WarnOnDeprecatedCustomArgsSerialization(LogMessagePacket loggingPacket)
+        {
+            if (loggingPacket.EventType == LoggingEventType.CustomEvent
+                && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8)
+                && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
+            {
+                BuildEventArgs buildEvent = loggingPacket.NodeBuildEvent.Value.Value;
+                BuildEventContext buildEventContext = buildEvent?.BuildEventContext ?? BuildEventContext.Invalid;
+
+                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
+                    out string warningCode,
+                    out string helpKeyword,
+                    "DeprecatedEventSerialization",
+                    buildEvent?.GetType().Name ?? string.Empty);
+
+                BuildWarningEventArgs warning = new(
+                    null,
+                    warningCode,
+                    BuildEventFileInfo.Empty.File,
+                    BuildEventFileInfo.Empty.Line,
+                    BuildEventFileInfo.Empty.Column,
+                    BuildEventFileInfo.Empty.EndLine,
+                    BuildEventFileInfo.Empty.EndColumn,
+                    message,
+                    helpKeyword,
+                    "MSBuild");
+
+                warning.BuildEventContext = buildEventContext;
+                if (warning.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
+                {
+                    warning.ProjectFile = buildEvent switch
+                    {
+                        BuildMessageEventArgs buildMessageEvent => buildMessageEvent.ProjectFile,
+                        BuildErrorEventArgs buildErrorEvent => buildErrorEvent.ProjectFile,
+                        BuildWarningEventArgs buildWarningEvent => buildWarningEvent.ProjectFile,
+                        _ => null,
+                    };
+                }
+
+                ProcessLoggingEvent(warning);
+            }
+        }
+
         /// <summary>
         /// Register an instantiated logger which implements the ILogger interface. This logger will be registered to a specific event
         /// source (the central logger event source) which will receive all logging messages for a given build.
@@ -1243,19 +1294,18 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
         #endregion
 
         #region Private Methods
-        private static int GetWarningsAsErrorOrMessageKey(BuildEventContext buildEventContext)
+        private static WarningsConfigKey GetWarningsConfigKey(BuildEventContext buildEventContext)
         {
-            var hash = 17;
-            hash = (hash * 31) + buildEventContext.ProjectInstanceId;
-            hash = (hash * 31) + buildEventContext.ProjectContextId;
-            return hash;
+            return new WarningsConfigKey(buildEventContext.ProjectInstanceId, buildEventContext.ProjectContextId);
         }
 
-        private static int GetWarningsAsErrorOrMessageKey(BuildEventArgs buildEventArgs)
+        private static WarningsConfigKey GetWarningsConfigKey(BuildEventArgs buildEventArgs)
         {
-            return GetWarningsAsErrorOrMessageKey(buildEventArgs.BuildEventContext);
+            return GetWarningsConfigKey(buildEventArgs.BuildEventContext);
         }
 
+        private readonly record struct WarningsConfigKey(int InstanceId, int ContextId);
+
         /// <summary>
         /// Create a logging thread to process the logging queue.
         /// </summary>
@@ -1438,42 +1488,93 @@ private void RouteBuildEvent(object loggingEvent)
             {
                 if (ShouldTreatWarningAsMessage(warningEvent))
                 {
-                    buildEventArgs = new BuildMessageEventArgs(
-                        warningEvent.Subcategory,
-                        warningEvent.Code,
-                        warningEvent.File,
-                        warningEvent.LineNumber,
-                        warningEvent.ColumnNumber,
-                        warningEvent.EndLineNumber,
-                        warningEvent.EndColumnNumber,
-                        warningEvent.Message,
-                        warningEvent.HelpKeyword,
-                        warningEvent.SenderName,
-                        MessageImportance.Low,
-                        warningEvent.Timestamp)
+                    if (buildEventArgs is ExtendedBuildWarningEventArgs extWarningEvent)
                     {
-                        BuildEventContext = warningEvent.BuildEventContext,
-                        ProjectFile = warningEvent.ProjectFile,
-                    };
+                        buildEventArgs = new ExtendedBuildMessageEventArgs(
+                                extWarningEvent.ExtendedType,
+                                extWarningEvent.Subcategory,
+                                extWarningEvent.Code,
+                                extWarningEvent.File,
+                                extWarningEvent.LineNumber,
+                                extWarningEvent.ColumnNumber,
+                                extWarningEvent.EndLineNumber,
+                                extWarningEvent.EndColumnNumber,
+                                extWarningEvent.Message,
+                                extWarningEvent.HelpKeyword,
+                                extWarningEvent.SenderName,
+                                MessageImportance.Low,
+                                extWarningEvent.Timestamp)
+                        {
+                            BuildEventContext = warningEvent.BuildEventContext,
+                            ProjectFile = warningEvent.ProjectFile,
+                            ExtendedMetadata = extWarningEvent.ExtendedMetadata,
+                            ExtendedData = extWarningEvent.ExtendedData,
+                        };
+                    }
+                    else
+                    {
+                        buildEventArgs = new BuildMessageEventArgs(
+                            warningEvent.Subcategory,
+                            warningEvent.Code,
+                            warningEvent.File,
+                            warningEvent.LineNumber,
+                            warningEvent.ColumnNumber,
+                            warningEvent.EndLineNumber,
+                            warningEvent.EndColumnNumber,
+                            warningEvent.Message,
+                            warningEvent.HelpKeyword,
+                            warningEvent.SenderName,
+                            MessageImportance.Low,
+                            warningEvent.Timestamp)
+                        {
+                            BuildEventContext = warningEvent.BuildEventContext,
+                            ProjectFile = warningEvent.ProjectFile,
+                        };
+                    }
                 }
                 else if (ShouldTreatWarningAsError(warningEvent))
                 {
-                    buildEventArgs = new BuildErrorEventArgs(
-                        warningEvent.Subcategory,
-                        warningEvent.Code,
-                        warningEvent.File,
-                        warningEvent.LineNumber,
-                        warningEvent.ColumnNumber,
-                        warningEvent.EndLineNumber,
-                        warningEvent.EndColumnNumber,
-                        warningEvent.Message,
-                        warningEvent.HelpKeyword,
-                        warningEvent.SenderName,
-                        warningEvent.Timestamp)
+                    if (warningEvent is ExtendedBuildWarningEventArgs extWarningEvent)
                     {
-                        BuildEventContext = warningEvent.BuildEventContext,
-                        ProjectFile = warningEvent.ProjectFile,
-                    };
+                        buildEventArgs = new ExtendedBuildErrorEventArgs(
+                            extWarningEvent.ExtendedType,
+                            extWarningEvent.Subcategory,
+                            extWarningEvent.Code,
+                            extWarningEvent.File,
+                            extWarningEvent.LineNumber,
+                            extWarningEvent.ColumnNumber,
+                            extWarningEvent.EndLineNumber,
+                            extWarningEvent.EndColumnNumber,
+                            extWarningEvent.Message,
+                            extWarningEvent.HelpKeyword,
+                            extWarningEvent.SenderName,
+                            extWarningEvent.Timestamp)
+                        {
+                            BuildEventContext = warningEvent.BuildEventContext,
+                            ProjectFile = warningEvent.ProjectFile,
+                            ExtendedMetadata = extWarningEvent.ExtendedMetadata,
+                            ExtendedData = extWarningEvent.ExtendedData,
+                        };
+                    }
+                    else
+                    {
+                        buildEventArgs = new BuildErrorEventArgs(
+                            warningEvent.Subcategory,
+                            warningEvent.Code,
+                            warningEvent.File,
+                            warningEvent.LineNumber,
+                            warningEvent.ColumnNumber,
+                            warningEvent.EndLineNumber,
+                            warningEvent.EndColumnNumber,
+                            warningEvent.Message,
+                            warningEvent.HelpKeyword,
+                            warningEvent.SenderName,
+                            warningEvent.Timestamp)
+                        {
+                            BuildEventContext = warningEvent.BuildEventContext,
+                            ProjectFile = warningEvent.ProjectFile,
+                        };
+                    }
                 }
             }
 
@@ -1485,7 +1586,7 @@ private void RouteBuildEvent(object loggingEvent)
 
             if (buildEventArgs is ProjectFinishedEventArgs projectFinishedEvent && projectFinishedEvent.BuildEventContext != null)
             {
-                int key = GetWarningsAsErrorOrMessageKey(projectFinishedEvent);
+                WarningsConfigKey key = GetWarningsConfigKey(projectFinishedEvent);
                 _warningsAsErrorsByProject?.Remove(key);
                 _warningsNotAsErrorsByProject?.Remove(key);
                 _warningsAsMessagesByProject?.Remove(key);
@@ -1657,8 +1758,8 @@ private void UpdateMinimumMessageImportance(ILogger logger)
                 // The null logger has no effect on minimum verbosity.
                 Execution.BuildManager.NullLogger => null,
 
-                // The live logger consumes only high priority messages.
-                _ => innerLogger.GetType().FullName == "Microsoft.Build.Logging.LiveLogger.LiveLogger"
+                // The terminal logger consumes only high priority messages.
+                _ => innerLogger.GetType().FullName == "Microsoft.Build.Logging.TerminalLogger.TerminalLogger"
                     ? MessageImportance.High
                     // If the logger is not on our allow list, there are no importance guarantees. Fall back to "any importance".
                     : MessageImportance.Low,
@@ -1757,7 +1858,7 @@ private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent)
             // This only applies if the user specified <MSBuildWarningsAsMessages /> and there is a valid ProjectInstanceId
             if (_warningsAsMessagesByProject != null && warningEvent.BuildEventContext != null && warningEvent.BuildEventContext.ProjectInstanceId != BuildEventContext.InvalidProjectInstanceId)
             {
-                if (_warningsAsMessagesByProject.TryGetValue(GetWarningsAsErrorOrMessageKey(warningEvent), out ISet<string> codesByProject))
+                if (_warningsAsMessagesByProject.TryGetValue(GetWarningsConfigKey(warningEvent), out ISet<string> codesByProject))
                 {
                     return codesByProject?.Contains(warningEvent.Code) == true;
                 }
@@ -1768,7 +1869,7 @@ private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent)
 
         private bool WarningAsErrorNotOverriden(BuildWarningEventArgs warningEvent)
         {
-            int key = GetWarningsAsErrorOrMessageKey(warningEvent);
+            WarningsConfigKey key = GetWarningsConfigKey(warningEvent);
 
             return WarningsNotAsErrors?.Contains(warningEvent.Code) != true && !(_warningsNotAsErrorsByProject?.TryGetValue(key, out ISet<string> notToError) == true && notToError.Contains(warningEvent.Code));
         }
@@ -1795,7 +1896,7 @@ private bool ShouldTreatWarningAsError(BuildWarningEventArgs warningEvent)
             if (_warningsAsErrorsByProject != null && warningEvent.BuildEventContext != null && warningEvent.BuildEventContext.ProjectInstanceId != BuildEventContext.InvalidProjectInstanceId)
             {
                 // Attempt to get the list of warnings to treat as errors for the current project
-                int key = GetWarningsAsErrorOrMessageKey(warningEvent);
+                WarningsConfigKey key = GetWarningsConfigKey(warningEvent);
                 if (_warningsAsErrorsByProject.TryGetValue(key, out ISet<string> codesByProject))
                 {
                     // We create an empty set if all warnings should be treated as errors so that should be checked first.
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 9d1cefe040d..e34e70cca44 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -315,7 +315,7 @@ private bool IsDesignTimeBuild(BuildRequestConfiguration buildRequestConfigurati
             string? designTimeBuild = buildRequestConfiguration.GlobalProperties[DesignTimeProperties.DesignTimeBuild]?.EvaluatedValue;
             string? buildingProject = buildRequestConfiguration.GlobalProperties[DesignTimeProperties.BuildingProject]?.EvaluatedValue;
             return ConversionUtilities.ConvertStringToBool(designTimeBuild, nullOrWhitespaceIsFalse: true)
-                || (buildingProject != null && !ConversionUtilities.ConvertStringToBool(designTimeBuild, nullOrWhitespaceIsFalse: true));
+                || (buildingProject != null && !ConversionUtilities.ConvertStringToBool(buildingProject, nullOrWhitespaceIsFalse: true));
         }
 
         public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancellationToken)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 096c90e5ff9..72d42315df5 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -413,27 +413,28 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
 
             // Split Include on any semicolons, and take each split in turn
             var includeSplits = ExpressionShredder.SplitSemiColonSeparatedList(evaluatedInclude);
-            ProjectItemInstanceFactory itemFactory = new ProjectItemInstanceFactory(this.Project, originalItem.ItemType);
+            ProjectItemInstanceFactory itemFactory = new ProjectItemInstanceFactory(Project, originalItem.ItemType);
+
+            // EngineFileUtilities.GetFileListEscaped api invocation evaluates excludes by default.
+            // If the code process any expression like "@(x)", we need to handle excludes explicitly using EvaluateExcludePaths().
+            bool anyTransformExprProceeded = false;
 
             foreach (string includeSplit in includeSplits)
             {
                 // If expression is "@(x)" copy specified list with its metadata, otherwise just treat as string
-                bool throwaway;
-
-                IList<ProjectItemInstance> itemsFromSplit = expander.ExpandSingleItemVectorExpressionIntoItems(includeSplit,
+                IList<ProjectItemInstance> itemsFromSplit = expander.ExpandSingleItemVectorExpressionIntoItems(
+                    includeSplit,
                     itemFactory,
                     ExpanderOptions.ExpandItems,
                     false /* do not include null expansion results */,
-                    out throwaway,
+                    out _,
                     originalItem.IncludeLocation);
 
                 if (itemsFromSplit != null)
                 {
                     // Expression is in form "@(X)", so add these items directly.
-                    foreach (ProjectItemInstance item in itemsFromSplit)
-                    {
-                        items.Add(item);
-                    }
+                    items.AddRange(itemsFromSplit);
+                    anyTransformExprProceeded = true;
                 }
                 else
                 {
@@ -463,35 +464,18 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
                 }
             }
 
-            // Evaluate, split, expand and subtract any Exclude
-            HashSet<string> excludesUnescapedForComparison = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
-
-            foreach (string excludeSplit in excludes)
+            // There is a need to Evaluate Exclude part explicitly because of of the expressions had the form "@(X)".
+            if (anyTransformExprProceeded)
             {
-                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(
-                    Project.Directory,
-                    excludeSplit,
-                    loggingMechanism: LoggingContext,
-                    excludeLocation: originalItem.ExcludeLocation);
+                // Calculate all Exclude
+                var excludesUnescapedForComparison = EvaluateExcludePaths(excludes, originalItem.ExcludeLocation);
 
-                foreach (string excludeSplitFile in excludeSplitFiles)
-                {
-                    excludesUnescapedForComparison.Add(excludeSplitFile.NormalizeForPathComparison());
-                }
-            }
-
-            List<ProjectItemInstance> remainingItems = new List<ProjectItemInstance>();
-
-            for (int i = 0; i < items.Count; i++)
-            {
-                if (!excludesUnescapedForComparison.Contains(((IItem)items[i]).EvaluatedInclude.NormalizeForPathComparison()))
-                {
-                    remainingItems.Add(items[i]);
-                }
+                // Subtract any Exclude
+                items = items
+                    .Where(i => !excludesUnescapedForComparison.Contains(((IItem)i).EvaluatedInclude.NormalizeForPathComparison()))
+                    .ToList();
             }
 
-            items = remainingItems;
-
             // Filter the metadata as appropriate
             if (keepMetadata != null)
             {
@@ -519,6 +503,32 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
             return items;
         }
 
+        /// <summary>
+        /// Returns a list of all items specified in Exclude parameter.
+        /// If no items match, returns empty list.
+        /// </summary>
+        /// <param name="excludes">The items to match</param>
+        /// <param name="excludeLocation">The specification to match against the items.</param>
+        /// <returns>A list of matching items</returns>
+        private HashSet<string> EvaluateExcludePaths(IReadOnlyList<string> excludes, ElementLocation excludeLocation)
+        {
+            HashSet<string> excludesUnescapedForComparison = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+            foreach (string excludeSplit in excludes)
+            {
+                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(
+                    Project.Directory,
+                    excludeSplit,
+                    loggingMechanism: LoggingContext,
+                    excludeLocation: excludeLocation);
+                foreach (string excludeSplitFile in excludeSplitFiles)
+                {
+                    excludesUnescapedForComparison.Add(excludeSplitFile.NormalizeForPathComparison());
+                }
+            }
+
+            return excludesUnescapedForComparison;
+        }
+
         /// <summary>
         /// Returns a list of all items in the provided item group whose itemspecs match the specification, after it is split and any wildcards are expanded.
         /// If no items match, returns null.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 3e0ea3b7abf..939370ab515 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -1079,7 +1079,11 @@ internal void MarkAsInactive()
         /// </summary>
         internal bool IsEventSerializable(BuildEventArgs e)
         {
-            if (!e.GetType().GetTypeInfo().IsSerializable)
+#pragma warning disable SYSLIB0050
+            // Types which are not serializable and are not IExtendedBuildEventArgs as
+            // those always implement custom serialization by WriteToStream and CreateFromStream.
+            if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)
+#pragma warning restore SYSLIB0050
             {
                 _taskLoggingContext.LogWarning(null, new BuildEventFileInfo(string.Empty), "ExpectedEventToBeSerializable", e.GetType().Name);
                 return false;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
index 68a14ae42a9..85943ff9442 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
@@ -110,7 +110,12 @@ private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader, str
                                     string pattern = reader.ReadElementContentAsString();
                                     try
                                     {
-                                        manifest.ResolvableSdkRegex = new Regex(pattern, RegexOptions.Compiled | RegexOptions.CultureInvariant, TimeSpan.FromMilliseconds(SdkResolverPatternRegexTimeoutMsc));
+                                        RegexOptions regexOptions = RegexOptions.CultureInvariant;
+                                        // For the kind of patterns used here, compiled regexes on .NET Framework tend to run slower than interpreted ones.
+#if RUNTIME_TYPE_NETCORE
+                                        regexOptions |= RegexOptions.Compiled;
+#endif
+                                        manifest.ResolvableSdkRegex = new Regex(pattern, regexOptions, TimeSpan.FromMilliseconds(SdkResolverPatternRegexTimeoutMsc));
                                     }
                                     catch (ArgumentException ex)
                                     {
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 83a74bee7d6..619c476a1f6 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -572,7 +572,28 @@ private void SendPacket(INodePacket packet)
         {
             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
             {
+#if RUNTIME_TYPE_NETCORE
+                if (packet is LogMessagePacketBase logMessage
+                    && logMessage.EventType == LoggingEventType.CustomEvent 
+                    && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) 
+                    && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
+                {
+                    BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;
+
+                    // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>
+                    // Since BinaryFormatter is deprecated in dotnet 8+, log error so users discover root cause easier
+                    // then by reading CommTrace where it would be otherwise logged as critical infra error.
+                    _loggingService.LogError(_loggingContext?.BuildEventContext ?? BuildEventContext.Invalid, null, BuildEventFileInfo.Empty,
+                            "DeprecatedEventSerialization",
+                            buildEvent?.GetType().Name ?? string.Empty);
+                }
+                else
+                {
+                    _nodeEndpoint.SendData(packet);
+                }
+#else
                 _nodeEndpoint.SendData(packet);
+#endif
             }
         }
 
diff --git a/src/Build/BackEnd/Shared/BuildAbortedException.cs b/src/Build/BackEnd/Shared/BuildAbortedException.cs
index 09f107a93f8..d62a1504c70 100644
--- a/src/Build/BackEnd/Shared/BuildAbortedException.cs
+++ b/src/Build/BackEnd/Shared/BuildAbortedException.cs
@@ -91,6 +91,9 @@ protected override void InitializeCustomState(IDictionary<string, string> state)
         /// Protected constructor used for (de)serialization. 
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected BuildAbortedException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
@@ -109,6 +112,9 @@ protected BuildAbortedException(SerializationInfo info, StreamingContext context
         /// </summary>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/Build/BackEnd/Shared/CircularDependencyException.cs b/src/Build/BackEnd/Shared/CircularDependencyException.cs
index 11ea521d9ed..fd51ccb5cc1 100644
--- a/src/Build/BackEnd/Shared/CircularDependencyException.cs
+++ b/src/Build/BackEnd/Shared/CircularDependencyException.cs
@@ -39,6 +39,9 @@ internal CircularDependencyException(string message, Exception inner)
         /// <summary>
         /// Constructor for deserialization.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected CircularDependencyException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index b2eee81b3f7..4418a48a63d 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -333,7 +333,7 @@ bool ITaskExecutionHost.SetTaskParameters(IDictionary<string, (string, ElementLo
             // Get the properties that exist on this task.  We need to gather all of the ones that are marked
             // "required" so that we can keep track of whether or not they all get set.
             var setParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            IDictionary<string, string> requiredParameters = GetNamesOfPropertiesWithRequiredAttribute();
+            IReadOnlyDictionary<string, string> requiredParameters = GetNamesOfPropertiesWithRequiredAttribute();
 
             // look through all the attributes of the task element
             foreach (KeyValuePair<string, (string, ElementLocation)> parameter in parameters)
@@ -1540,10 +1540,10 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
         /// Returns them as keys in a dictionary.
         /// </summary>
         /// <returns>Gets a list of properties which are required.</returns>
-        private IDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute()
+        private IReadOnlyDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute()
         {
             ErrorUtilities.VerifyThrow(_taskFactoryWrapper != null, "Expected taskFactoryWrapper to not be null");
-            IDictionary<string, string> requiredParameters = null;
+            IReadOnlyDictionary<string, string> requiredParameters = null;
 
             try
             {
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
index 4bfa02007df..e979313ca70 100644
--- a/src/Build/CompatibilitySuppressions.xml
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -1,42 +1,6 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- Need to suppress due to AppCompat limitation https://github.com/dotnet/sdk/issues/32922 -->
-  <Suppression>
-    <DiagnosticId>CP0007</DiagnosticId>
-    <Target>T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverException</Target>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0007</DiagnosticId>
-    <Target>T:Microsoft.Build.Exceptions.BuildAbortedException</Target>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0007</DiagnosticId>
-    <Target>T:Microsoft.Build.Exceptions.CircularDependencyException</Target>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0007</DiagnosticId>
-    <Target>T:Microsoft.Build.Exceptions.InternalLoggerException</Target>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0007</DiagnosticId>
-    <Target>T:Microsoft.Build.Exceptions.InvalidProjectFileException</Target>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0007</DiagnosticId>
-    <Target>T:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException</Target>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0007</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.ProjectCache.ProjectCacheException</Target>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
   <!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
   <Suppression>
     <DiagnosticId>PKV006</DiagnosticId>
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index b2540919cf2..a59fdb60e4d 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -1635,5 +1635,5 @@ internal string GetProjectRelativePathByGuid(string projectGuid)
         }
 
         #endregion
-    } // class SolutionParser
+    } // class SolutionFile
 } // namespace Microsoft.Build.Construction
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index f016e922451..5d2bf851cef 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -1548,6 +1548,13 @@ public bool TryUnloadProject(ProjectRootElement projectRootElement)
             }
         }
 
+        /// <summary>
+        /// Logs a BuildFinished event. This is used specifically when a ProjectCollection is created but never actually built, yet a BuildFinished event
+        /// is still desired. As an example, if a Project is just meant to be evaluated, but a binlog is also collected, that binlog should be able to
+        /// say the build succeeded or failed. This provides a mechanism to achieve that.
+        /// </summary>
+        public void LogBuildFinishedEvent(bool success) => _loggingService.LogBuildFinished(success);
+
         /// <summary>
         /// Called by a Project object to load itself into this collection.
         /// If the project was already loaded under a different name, it is unloaded.
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index 74fbd3dfb6f..1db485e55ea 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -108,6 +108,9 @@ internal InternalLoggerException(
         /// </summary>
         /// <param name="info"></param>
         /// <param name="context"></param>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private InternalLoggerException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
@@ -125,6 +128,9 @@ private InternalLoggerException(SerializationInfo info, StreamingContext context
         /// <param name="context"></param>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index 8a15be32d42..7bc6e4a135d 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -85,6 +85,9 @@ internal InvalidProjectFileException(string message, InvalidProjectFileException
         /// </summary>
         /// <param name="info"></param>
         /// <param name="context"></param>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private InvalidProjectFileException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
@@ -107,6 +110,9 @@ private InvalidProjectFileException(SerializationInfo info, StreamingContext con
         /// <param name="context"></param>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index 77996c97504..1ebc9c9d1b1 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -55,6 +55,9 @@ public InvalidToolsetDefinitionException(string message, Exception innerExceptio
         /// <summary>
         /// Basic constructor.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected InvalidToolsetDefinitionException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
@@ -94,6 +97,9 @@ public InvalidToolsetDefinitionException(string message, string errorCode, Excep
         /// <param name="context"></param>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/Build/Errors/RegistryException.cs b/src/Build/Errors/RegistryException.cs
index e3aee195277..11d37991996 100644
--- a/src/Build/Errors/RegistryException.cs
+++ b/src/Build/Errors/RegistryException.cs
@@ -57,6 +57,9 @@ public RegistryException(string message, string source)
         /// <summary>
         /// Since this class implements Iserializable this constructor is required to be implemented.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected RegistryException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
             // We don't have any reason at the moment to do any custom serizlization or deserialization, this methods was added
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 075090e0f9a..6e812c58767 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -3315,7 +3315,7 @@ internal static Function<T> ExtractPropertyFunction(
                         ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidFunctionStaticMethodSyntax", expressionFunction, String.Empty);
                     }
 
-                    var typeName = expressionRoot.Slice(1, typeEndIndex - 1).ToString();
+                    var typeName = Strings.WeakIntern(expressionRoot.Slice(1, typeEndIndex - 1));
                     var methodStartIndex = typeEndIndex + 1;
 
                     if (expressionRoot.Length > methodStartIndex + 2 && expressionRoot[methodStartIndex] == ':' && expressionRoot[methodStartIndex + 1] == ':')
@@ -3373,7 +3373,7 @@ internal static Function<T> ExtractPropertyFunction(
                     var rootEndIndex = expressionRoot.IndexOf('.');
 
                     // If this is an instance function rather than a static, then we'll capture the name of the property referenced
-                    var functionReceiver = expressionRoot.Slice(0, rootEndIndex).Trim().ToString();
+                    var functionReceiver = Strings.WeakIntern(expressionRoot.Slice(0, rootEndIndex).Trim());
 
                     // If propertyValue is null (we're not recursing), then we're expecting a valid property name
                     if (propertyValue == null && !IsValidPropertyName(functionReceiver))
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index c555a10d0e2..360843f9b58 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -156,10 +156,7 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
 
                     // Grab the name, but continue to verify it's a well-formed expression
                     // before we store it.
-                    string name = expression.Substring(startOfName, i - startOfName);
-
-                    // return the item that we're working with
-                    string itemName = name;
+                    string itemName = Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startOfName, i - startOfName));
 
                     SinkWhitespace(expression, ref i);
                     bool transformOrFunctionFound = true;
@@ -251,10 +248,10 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
                         subExpressions = new List<ItemExpressionCapture>();
                     }
 
-                    // Create an expression capture that encompases the entire expression between the @( and the )
+                    // Create an expression capture that encompasses the entire expression between the @( and the )
                     // with the item name and any separator contained within it
                     // and each transform expression contained within it (i.e. each ->XYZ)
-                    ItemExpressionCapture expressionCapture = new ItemExpressionCapture(startPoint, endPoint - startPoint, expression.Substring(startPoint, endPoint - startPoint), itemName, separator, separatorStart, transformExpressions);
+                    ItemExpressionCapture expressionCapture = new ItemExpressionCapture(startPoint, endPoint - startPoint, Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startPoint, endPoint - startPoint)), itemName, separator, separatorStart, transformExpressions);
                     subExpressions.Add(expressionCapture);
 
                     continue;
@@ -601,7 +598,7 @@ private static ItemExpressionCapture SinkItemFunctionExpression(string expressio
 
                     if (endFunctionArguments > startFunctionArguments)
                     {
-                        capture.FunctionArguments = expression.Substring(startFunctionArguments, endFunctionArguments - startFunctionArguments);
+                        capture.FunctionArguments = Microsoft.NET.StringTools.Strings.WeakIntern(expression.AsSpan(startFunctionArguments, endFunctionArguments - startFunctionArguments));
                     }
 
                     return capture;
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 553c0af61ad..a92da0f73f9 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -258,7 +258,7 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
             ProjectGraphEntryPoint solutionEntryPoint = entryPoints.Single();
             ImmutableDictionary<string, string>.Builder solutionGlobalPropertiesBuilder = ImmutableDictionary.CreateBuilder(
                 keyComparer: StringComparer.OrdinalIgnoreCase,
-                valueComparer: StringComparer.OrdinalIgnoreCase);
+                valueComparer: StringComparer.Ordinal);
 
             if (solutionEntryPoint.GlobalProperties != null)
             {
@@ -279,9 +279,11 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
 
             IReadOnlyCollection<ProjectInSolution> projectsInSolution = GetBuildableProjects(solution);
 
+            // Mimic behavior of SolutionProjectGenerator
             SolutionConfigurationInSolution currentSolutionConfiguration = SelectSolutionConfiguration(solution, solutionEntryPoint.GlobalProperties);
+            solutionGlobalPropertiesBuilder["Configuration"] = currentSolutionConfiguration.ConfigurationName;
+            solutionGlobalPropertiesBuilder["Platform"] = currentSolutionConfiguration.PlatformName;
 
-            // Mimic behavior of SolutionProjectGenerator
             string solutionConfigurationXml = SolutionProjectGenerator.GetSolutionConfiguration(solution, currentSolutionConfiguration);
             solutionGlobalPropertiesBuilder["CurrentSolutionConfigurationContents"] = solutionConfigurationXml;
             solutionGlobalPropertiesBuilder["BuildingSolutionFile"] = "true";
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index a04f3c9c0ad..4db93ab3bb0 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -8,6 +8,9 @@
 using System.Diagnostics.CodeAnalysis;
 using System.IO;
 using System.Linq;
+#if FEATURE_APPDOMAIN
+using System.Runtime.Remoting;
+#endif
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -521,6 +524,8 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
 
         IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata() => _taskItem.EnumerateMetadata();
 
+        void IMetadataContainer.ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata) => _taskItem.ImportMetadata(metadata);
+
         #region IMetadataTable Members
 
         /// <summary>
@@ -1034,6 +1039,19 @@ public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
                 }
             }
 
+            /// <summary>
+            /// Sets the given metadata.
+            /// Equivalent to calling <see cref="SetMetadata(string,string)"/> for each item in <paramref name="metadata"/>.
+            /// </summary>
+            /// <param name="metadata">The metadata to set.</param>
+            public void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
+            {
+                ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
+
+                _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                _directMetadata.ImportProperties(metadata.Select(kvp => new ProjectMetadataInstance(kvp.Key, kvp.Value, allowItemSpecModifiers: true)));
+            }
+
             /// <summary>
             /// Used to return metadata from another AppDomain. Can't use yield return because the
             /// generated state machine is not marked as [Serializable], so we need to allocate.
@@ -1371,9 +1389,7 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                     originalItemSpec = destinationItem.GetMetadata("OriginalItemSpec");
                 }
 
-                TaskItem destinationAsTaskItem = destinationItem as TaskItem;
-
-                if (destinationAsTaskItem != null && destinationAsTaskItem._directMetadata == null)
+                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem._directMetadata == null)
                 {
                     ProjectInstance.VerifyThrowNotImmutable(destinationAsTaskItem._isImmutable);
 
@@ -1391,6 +1407,24 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                         destinationAsTaskItem._itemDefinitions.AddRange(_itemDefinitions);
                     }
                 }
+                else if (destinationItem is IMetadataContainer destinationItemAsMetadataContainer)
+                {
+                    // The destination implements IMetadataContainer so we can use the ImportMetadata bulk-set operation.
+                    IEnumerable<ProjectMetadataInstance> metadataEnumerable = MetadataCollection;
+                    IEnumerable<KeyValuePair<string, string>> metadataToImport = metadataEnumerable
+                        .Where(metadatum => string.IsNullOrEmpty(destinationItem.GetMetadata(metadatum.Name)))
+                        .Select(metadatum => new KeyValuePair<string, string>(metadatum.Name, GetMetadataEscaped(metadatum.Name)));
+
+#if FEATURE_APPDOMAIN
+                    if (RemotingServices.IsTransparentProxy(destinationItem))
+                    {
+                        // Linq is not serializable so materialize the collection before making the call.
+                        metadataToImport = metadataToImport.ToList();
+                    }
+#endif
+
+                    destinationItemAsMetadataContainer.ImportMetadata(metadataToImport);
+                }
                 else
                 {
                     // OK, most likely the destination item was a Microsoft.Build.Utilities.TaskItem.
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 379987804ae..25c8c79067b 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -337,7 +337,11 @@ internal void MarkAsInactive()
         /// </summary>
         internal bool IsEventSerializable(BuildEventArgs e)
         {
-            if (!e.GetType().GetTypeInfo().IsSerializable)
+#pragma warning disable SYSLIB0050
+            // Types which are not serializable and are not IExtendedBuildEventArgs as
+            // those always implement custom serialization by WriteToStream and CreateFromStream.
+            if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)
+#pragma warning restore SYSLIB0050
             {
                 _loggingContext.LogWarning(null, new BuildEventFileInfo(string.Empty), "ExpectedEventToBeSerializable", e.GetType().Name);
                 return false;
diff --git a/src/Build/Instance/TaskFactoryWrapper.cs b/src/Build/Instance/TaskFactoryWrapper.cs
index 58dcc1b4e7b..4f7d6eb4f01 100644
--- a/src/Build/Instance/TaskFactoryWrapper.cs
+++ b/src/Build/Instance/TaskFactoryWrapper.cs
@@ -8,8 +8,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Execution
 {
     /// <summary>
@@ -19,30 +17,50 @@ internal sealed class TaskFactoryWrapper
     {
         #region Data
 
+        private struct PropertyData
+        {
+            /// <summary>
+            /// Cache of names of required properties on this type
+            /// </summary>
+            public readonly IReadOnlyDictionary<string, string> NamesOfPropertiesWithRequiredAttribute;
+
+            /// <summary>
+            /// Cache of names of output properties on this type
+            /// </summary>
+            public readonly IReadOnlyDictionary<string, string> NamesOfPropertiesWithOutputAttribute;
+
+            /// <summary>
+            /// Cache of names of properties on this type whose names are ambiguous
+            /// </summary>
+            public readonly IReadOnlyDictionary<string, string> NamesOfPropertiesWithAmbiguousMatches;
+
+            /// <summary>
+            /// Cache of PropertyInfos for this type
+            /// </summary>
+            public readonly IReadOnlyDictionary<string, TaskPropertyInfo> PropertyInfoCache;
+
+            public PropertyData(
+                IReadOnlyDictionary<string, string> namesOfPropertiesWithRequiredAttribute,
+                IReadOnlyDictionary<string, string> namesOfPropertiesWithOutputAttribute,
+                IReadOnlyDictionary<string, string> namesOfPropertiesWithAmbiguousMatches,
+                IReadOnlyDictionary<string, TaskPropertyInfo> propertyInfoCache)
+            {
+                NamesOfPropertiesWithRequiredAttribute = namesOfPropertiesWithRequiredAttribute;
+                NamesOfPropertiesWithOutputAttribute = namesOfPropertiesWithOutputAttribute;
+                NamesOfPropertiesWithAmbiguousMatches = namesOfPropertiesWithAmbiguousMatches;
+                PropertyInfoCache = propertyInfoCache;
+            }
+        }
+
         /// <summary>
         /// Factory which is wrapped by the wrapper
         /// </summary>
         private ITaskFactory _taskFactory;
 
         /// <summary>
-        /// Cache of names of required properties on this type
-        /// </summary>
-        private IDictionary<string, string> _namesOfPropertiesWithRequiredAttribute;
-
-        /// <summary>
-        /// Cache of names of output properties on this type
-        /// </summary>
-        private IDictionary<string, string> _namesOfPropertiesWithOutputAttribute;
-
-        /// <summary>
-        /// Cache of names of properties on this type whose names are ambiguous
-        /// </summary>
-        private IDictionary<string, string> _namesOfPropertiesWithAmbiguousMatches;
-
-        /// <summary>
-        /// Cache of PropertyInfos for this type
+        /// Wrapper of lazy initializable property data.
         /// </summary>
-        private IDictionary<string, TaskPropertyInfo> _propertyInfoCache;
+        private Lazy<PropertyData> _propertyData;
 
         /// <summary>
         /// The name of the task this factory can create.
@@ -70,6 +88,7 @@ internal TaskFactoryWrapper(ITaskFactory taskFactory, LoadedType taskFactoryLoad
             _taskName = taskName;
             TaskFactoryLoadedType = taskFactoryLoadInfo;
             _factoryIdentityParameters = factoryIdentityParameters;
+            _propertyData = new Lazy<PropertyData>(PopulatePropertyInfo);
         }
 
         #endregion
@@ -101,13 +120,11 @@ public ITaskFactory TaskFactory
         /// Caches the result - since it can't change during the build.
         /// </summary>
         /// <returns></returns>
-        public IDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute
+        public IReadOnlyDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute
         {
             get
             {
-                PopulatePropertyInfoCacheIfNecessary();
-
-                return _namesOfPropertiesWithRequiredAttribute;
+                return _propertyData.Value.NamesOfPropertiesWithRequiredAttribute;
             }
         }
 
@@ -116,13 +133,11 @@ public IDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute
         /// Caches the result - since it can't change during the build.
         /// </summary>
         /// <returns></returns>
-        public IDictionary<string, string> GetNamesOfPropertiesWithOutputAttribute
+        public IReadOnlyDictionary<string, string> GetNamesOfPropertiesWithOutputAttribute
         {
             get
             {
-                PopulatePropertyInfoCacheIfNecessary();
-
-                return _namesOfPropertiesWithOutputAttribute;
+                return _propertyData.Value.NamesOfPropertiesWithOutputAttribute;
             }
         }
 
@@ -158,18 +173,16 @@ public IDictionary<string, string> FactoryIdentityParameters
         /// </summary>
         /// <param name="propertyName">property name</param>
         /// <returns>PropertyInfo</returns>
-        public TaskPropertyInfo GetProperty(string propertyName)
+        public TaskPropertyInfo? GetProperty(string propertyName)
         {
-            PopulatePropertyInfoCacheIfNecessary();
-
-            TaskPropertyInfo propertyInfo;
-            if (!_propertyInfoCache.TryGetValue(propertyName, out propertyInfo))
+            TaskPropertyInfo? propertyInfo;
+            if (!_propertyData.Value.PropertyInfoCache.TryGetValue(propertyName, out propertyInfo))
             {
                 return null;
             }
             else
             {
-                if (_namesOfPropertiesWithAmbiguousMatches.ContainsKey(propertyName))
+                if (_propertyData.Value.NamesOfPropertiesWithAmbiguousMatches.ContainsKey(propertyName))
                 {
                     // See comment in PopulatePropertyInfoCache
                     throw new AmbiguousMatchException();
@@ -187,7 +200,7 @@ internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object val
             ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
             ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
-            IGeneratedTask generatedTask = task as IGeneratedTask;
+            IGeneratedTask? generatedTask = task as IGeneratedTask;
             if (generatedTask != null)
             {
                 generatedTask.SetPropertyValue(property, value);
@@ -195,29 +208,29 @@ internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object val
             else
             {
                 ReflectableTaskPropertyInfo propertyInfo = (ReflectableTaskPropertyInfo)property;
-                propertyInfo.Reflection.SetValue(task, value, null);
+                propertyInfo.Reflection?.SetValue(task, value, null);
             }
         }
 
         /// <summary>
         /// Gets the value of a given property on the given task.
         /// </summary>
-        internal object GetPropertyValue(ITask task, TaskPropertyInfo property)
+        internal object? GetPropertyValue(ITask task, TaskPropertyInfo property)
         {
             ErrorUtilities.VerifyThrowArgumentNull(task, nameof(task));
             ErrorUtilities.VerifyThrowArgumentNull(property, nameof(property));
 
-            IGeneratedTask generatedTask = task as IGeneratedTask;
+            IGeneratedTask? generatedTask = task as IGeneratedTask;
             if (generatedTask != null)
             {
                 return generatedTask.GetPropertyValue(property);
             }
             else
             {
-                ReflectableTaskPropertyInfo propertyInfo = property as ReflectableTaskPropertyInfo;
+                ReflectableTaskPropertyInfo? propertyInfo = property as ReflectableTaskPropertyInfo;
                 if (propertyInfo != null)
                 {
-                    return propertyInfo.Reflection.GetValue(task, null);
+                    return propertyInfo.Reflection?.GetValue(task, null);
                 }
                 else
                 {
@@ -242,77 +255,79 @@ internal bool IsCreatableByFactory(string taskName)
         /// <summary>
         /// Populate the cache of PropertyInfos for this type
         /// </summary>
-        private void PopulatePropertyInfoCacheIfNecessary()
+        private PropertyData PopulatePropertyInfo()
         {
-            if (_propertyInfoCache == null)
+            Dictionary<string, TaskPropertyInfo>? propertyInfoCache = null;
+            Dictionary<string, string>? namesOfPropertiesWithRequiredAttribute = null;
+            Dictionary<string, string>? namesOfPropertiesWithOutputAttribute = null;
+            Dictionary<string, string>? namesOfPropertiesWithAmbiguousMatches = null;
+
+            bool taskTypeImplementsIGeneratedTask = typeof(IGeneratedTask).IsAssignableFrom(_taskFactory.TaskType);
+            TaskPropertyInfo[] propertyInfos = _taskFactory.GetTaskParameters();
+
+            for (int i = 0; i < propertyInfos.Length; i++)
             {
-                bool taskTypeImplementsIGeneratedTask = typeof(IGeneratedTask).IsAssignableFrom(_taskFactory.TaskType);
-                TaskPropertyInfo[] propertyInfos = _taskFactory.GetTaskParameters();
+                // If the task implements IGeneratedTask, we must use the TaskPropertyInfo the factory gives us.
+                // Otherwise, we never have to hand the TaskPropertyInfo back to the task or factory, so we replace
+                // theirs with one of our own that will allow us to cache reflection data per-property.
+                TaskPropertyInfo propertyInfo = propertyInfos[i];
+                if (!taskTypeImplementsIGeneratedTask)
+                {
+                    propertyInfo = new ReflectableTaskPropertyInfo(propertyInfo, _taskFactory.TaskType);
+                }
 
-                for (int i = 0; i < propertyInfos.Length; i++)
+                try
                 {
-                    // If the task implements IGeneratedTask, we must use the TaskPropertyInfo the factory gives us.
-                    // Otherwise, we never have to hand the TaskPropertyInfo back to the task or factory, so we replace
-                    // theirs with one of our own that will allow us to cache reflection data per-property.
-                    TaskPropertyInfo propertyInfo = propertyInfos[i];
-                    if (!taskTypeImplementsIGeneratedTask)
+                    if (propertyInfoCache == null)
                     {
-                        propertyInfo = new ReflectableTaskPropertyInfo(propertyInfo, _taskFactory.TaskType);
+                        propertyInfoCache = new Dictionary<string, TaskPropertyInfo>(StringComparer.OrdinalIgnoreCase);
                     }
 
-                    try
-                    {
-                        if (_propertyInfoCache == null)
-                        {
-                            _propertyInfoCache = new Dictionary<string, TaskPropertyInfo>(StringComparer.OrdinalIgnoreCase);
-                        }
-
-                        _propertyInfoCache.Add(propertyInfo.Name, propertyInfo);
-                    }
-                    catch (ArgumentException)
+                    propertyInfoCache.Add(propertyInfo.Name, propertyInfo);
+                }
+                catch (ArgumentException)
+                {
+                    // We have encountered a duplicate entry in our hashtable; if we had used BindingFlags.IgnoreCase this
+                    // would have produced an AmbiguousMatchException. In the old code, before this cache existed,
+                    // that wouldn't have been thrown unless and until the project actually tried to set this ambiguous parameter.
+                    // So rather than fail here, we store a list of ambiguous names and throw later, when one of them
+                    // is requested.
+                    if (namesOfPropertiesWithAmbiguousMatches == null)
                     {
-                        // We have encountered a duplicate entry in our hashtable; if we had used BindingFlags.IgnoreCase this
-                        // would have produced an AmbiguousMatchException. In the old code, before this cache existed,
-                        // that wouldn't have been thrown unless and until the project actually tried to set this ambiguous parameter.
-                        // So rather than fail here, we store a list of ambiguous names and throw later, when one of them
-                        // is requested.
-                        if (_namesOfPropertiesWithAmbiguousMatches == null)
-                        {
-                            _namesOfPropertiesWithAmbiguousMatches = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                        }
-
-                        _namesOfPropertiesWithAmbiguousMatches[propertyInfo.Name] = String.Empty;
+                        namesOfPropertiesWithAmbiguousMatches = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                     }
 
-                    if (propertyInfos[i].Required)
-                    {
-                        if (_namesOfPropertiesWithRequiredAttribute == null)
-                        {
-                            _namesOfPropertiesWithRequiredAttribute = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                        }
-
-                        // we have a require attribute defined, keep a record of that
-                        _namesOfPropertiesWithRequiredAttribute[propertyInfo.Name] = String.Empty;
-                    }
+                    namesOfPropertiesWithAmbiguousMatches[propertyInfo.Name] = String.Empty;
+                }
 
-                    if (propertyInfos[i].Output)
+                if (propertyInfos[i].Required)
+                {
+                    if (namesOfPropertiesWithRequiredAttribute == null)
                     {
-                        if (_namesOfPropertiesWithOutputAttribute == null)
-                        {
-                            _namesOfPropertiesWithOutputAttribute = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                        }
-
-                        // we have a output attribute defined, keep a record of that
-                        _namesOfPropertiesWithOutputAttribute[propertyInfo.Name] = String.Empty;
+                        namesOfPropertiesWithRequiredAttribute = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                     }
+
+                    // we have a require attribute defined, keep a record of that
+                    namesOfPropertiesWithRequiredAttribute[propertyInfo.Name] = String.Empty;
                 }
 
-                _propertyInfoCache ??= ReadOnlyEmptyDictionary<string, TaskPropertyInfo>.Instance;
+                if (propertyInfos[i].Output)
+                {
+                    if (namesOfPropertiesWithOutputAttribute == null)
+                    {
+                        namesOfPropertiesWithOutputAttribute = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                    }
 
-                _namesOfPropertiesWithRequiredAttribute ??= ReadOnlyEmptyDictionary<string, string>.Instance;
-                _namesOfPropertiesWithOutputAttribute ??= ReadOnlyEmptyDictionary<string, string>.Instance;
-                _namesOfPropertiesWithAmbiguousMatches ??= ReadOnlyEmptyDictionary<string, string>.Instance;
+                    // we have a output attribute defined, keep a record of that
+                    namesOfPropertiesWithOutputAttribute[propertyInfo.Name] = String.Empty;
+                }
             }
+
+            return new PropertyData(
+                (IReadOnlyDictionary<string, string>?)namesOfPropertiesWithRequiredAttribute ?? ReadOnlyEmptyDictionary<string, string>.Instance,
+                (IReadOnlyDictionary<string, string>?)namesOfPropertiesWithOutputAttribute ?? ReadOnlyEmptyDictionary<string, string>.Instance,
+                (IReadOnlyDictionary<string, string>?)namesOfPropertiesWithAmbiguousMatches ?? ReadOnlyEmptyDictionary<string, string>.Instance,
+                (IReadOnlyDictionary<string, TaskPropertyInfo>?)propertyInfoCache ?? ReadOnlyEmptyDictionary<string, TaskPropertyInfo>.Instance);
         }
         #endregion
     }
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index ced46f85b03..3627688d174 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -1479,7 +1479,7 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                                         initialized = factory.Initialize(RegisteredName, ParameterGroupAndTaskBody.UsingTaskParameters, ParameterGroupAndTaskBody.InlineTaskXmlBody, taskFactoryLoggingHost);
 
                                         // TaskFactoryParameters will always be null unless specifically created to have runtime and architecture parameters.
-                                        if (TaskFactoryParameters != null)
+                                        if (initialized && TaskFactoryParameters != null)
                                         {
                                             targetLoggingContext.LogWarning(
                                                 null,
@@ -1493,7 +1493,7 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                                     }
 
                                     // Throw an error if the ITaskFactory did not set the TaskType property.  If the property is null, it can cause NullReferenceExceptions in our code
-                                    if (factory.TaskType == null)
+                                    if (initialized && factory.TaskType == null)
                                     {
                                         throw new InvalidOperationException(AssemblyResources.GetString("TaskFactoryTaskTypeIsNotSet"));
                                     }
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index b7014cd6ac2..f4143ccaae7 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -272,12 +272,7 @@ internal void WriteLinePretty(int indentLevel, string formattedString)
         /// </summary>
         internal void IsRunningWithCharacterFileType()
         {
-            runningWithCharacterFileType = false;
-
-            if (NativeMethodsShared.IsWindows)
-            {
-                runningWithCharacterFileType = ConsoleConfiguration.OutputIsScreen;
-            }
+            runningWithCharacterFileType = NativeMethodsShared.IsWindows && ConsoleConfiguration.OutputIsScreen;
         }
 
         /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index 8bdcfbf09d9..a19a06c2d37 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -9,8 +9,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Logging
 {
     /// <summary>
@@ -28,6 +26,11 @@ static BinaryLogReplayEventSource()
             _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
         }
 
+        /// <summary>
+        /// Raised once <see cref="BuildEventArgsReader"/> is created during replaying
+        /// </summary>
+        public event Action<IBuildEventArgsReaderNotifications>? NotificationsSourceCreated;
+
         /// <summary>
         /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
         /// </summary>
@@ -38,48 +41,67 @@ public void Replay(string sourceFilePath)
         }
 
         /// <summary>
-        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// Creates a <see cref="BinaryReader"/> for the provided binary log file.
+        /// Performs decompression and buffering in the optimal way.
+        /// Caller is responsible for disposing the returned reader.
         /// </summary>
-        /// <param name="sourceFilePath">The full file path of the binary log file</param>
-        /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
-        public void Replay(string sourceFilePath, CancellationToken cancellationToken)
+        /// <param name="sourceFilePath"></param>
+        /// <returns>BinaryReader of the given binlog file.</returns>
+        public static BinaryReader OpenReader(string sourceFilePath)
         {
-            using (var stream = new FileStream(sourceFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
+            Stream? stream = null;
+            try
             {
-                var gzipStream = new GZipStream(stream, CompressionMode.Decompress, leaveOpen: true);
+                stream = new FileStream(sourceFilePath, FileMode.Open, FileAccess.Read, FileShare.Read);
+                var gzipStream = new GZipStream(stream, CompressionMode.Decompress, leaveOpen: false);
 
                 // wrapping the GZipStream in a buffered stream significantly improves performance
                 // and the max throughput is reached with a 32K buffer. See details here:
                 // https://github.com/dotnet/runtime/issues/39233#issuecomment-745598847
                 var bufferedStream = new BufferedStream(gzipStream, 32768);
-                var binaryReader = new BinaryReader(bufferedStream);
+                return new BinaryReader(bufferedStream);
+            }
+            catch(Exception)
+            {
+                stream?.Dispose();
+                throw;
+            }
+        }
 
-                int fileFormatVersion = binaryReader.ReadInt32();
+        /// <summary>
+        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// </summary>
+        /// <param name="sourceFilePath">The full file path of the binary log file</param>
+        /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
+        public void Replay(string sourceFilePath, CancellationToken cancellationToken)
+        {
+            using var binaryReader = OpenReader(sourceFilePath);
+            Replay(binaryReader, cancellationToken);
+        }
 
-                // the log file is written using a newer version of file format
-                // that we don't know how to read
-                if (fileFormatVersion > BinaryLogger.FileFormatVersion)
-                {
-                    var text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnsupportedLogFileFormat", fileFormatVersion, BinaryLogger.FileFormatVersion);
-                    throw new NotSupportedException(text);
-                }
+        /// <summary>
+        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// </summary>
+        /// <param name="binaryReader">The binary log content binary reader - caller is responsible for disposing.</param>
+        /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
+        public void Replay(BinaryReader binaryReader, CancellationToken cancellationToken)
+        {
+            int fileFormatVersion = binaryReader.ReadInt32();
 
-                using var reader = new BuildEventArgsReader(binaryReader, fileFormatVersion);
-                while (true)
-                {
-                    if (cancellationToken.IsCancellationRequested)
-                    {
-                        return;
-                    }
+            // the log file is written using a newer version of file format
+            // that we don't know how to read
+            if (fileFormatVersion > BinaryLogger.FileFormatVersion)
+            {
+                var text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnsupportedLogFileFormat", fileFormatVersion, BinaryLogger.FileFormatVersion);
+                throw new NotSupportedException(text);
+            }
 
-                    BuildEventArgs instance = reader.Read();
-                    if (instance == null)
-                    {
-                        break;
-                    }
+            using var reader = new BuildEventArgsReader(binaryReader, fileFormatVersion);
+            NotificationsSourceCreated?.Invoke(reader);
 
-                    Dispatch(instance);
-                }
+            while (!cancellationToken.IsCancellationRequested && reader.Read() is { } instance)
+            {
+                Dispatch(instance);
             }
         }
     }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 28a16df7c9c..fb8e59007e3 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -5,6 +5,7 @@
 using System.IO;
 using System.IO.Compression;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
@@ -191,6 +192,8 @@ public void Initialize(IEventSource eventSource)
             LogInitialInfo();
 
             eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+
+            KnownTelemetry.LoggingConfigurationTelemetry.BinaryLogger = true;
         }
 
         private void EventArgsWriter_EmbedFile(string filePath)
@@ -239,7 +242,14 @@ public void Shutdown()
                     {
                         using (FileStream fileStream = File.OpenRead(archiveFilePath))
                         {
-                            eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, fileStream);
+                            if (fileStream.Length > int.MaxValue)
+                            {
+                                LogMessage("Imported files archive exceeded 2GB limit and it's not embedded.");
+                            }
+                            else
+                            {
+                                eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, fileStream);
+                            }
                         }
 
                         File.Delete(archiveFilePath);
@@ -349,6 +359,7 @@ private void ProcessParameters()
             {
                 FilePath = "msbuild.binlog";
             }
+            KnownTelemetry.LoggingConfigurationTelemetry.BinaryLoggerUsedDefaultName = FilePath == "msbuild.binlog";
 
             try
             {
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index ddb7520a7fd..4b13c438721 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -13,14 +13,12 @@
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Logging
 {
     /// <summary>
     /// Deserializes and returns BuildEventArgs-derived objects from a BinaryReader
     /// </summary>
-    public class BuildEventArgsReader : IDisposable
+    public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposable
     {
         private readonly BinaryReader binaryReader;
         private readonly int fileFormatVersion;
@@ -45,13 +43,13 @@ public class BuildEventArgsReader : IDisposable
         /// A "page-file" for storing strings we've read so far. Keeping them in memory would OOM the 32-bit MSBuild
         /// when reading large binlogs. This is a no-op in a 64-bit process.
         /// </summary>
-        private StringStorage stringStorage = new StringStorage();
+        private readonly StringStorage stringStorage = new StringStorage();
 
         // reflection is needed to set these three fields because public constructors don't provide
         // a way to set these from the outside
-        private static FieldInfo buildEventArgsFieldThreadId =
+        private static FieldInfo? buildEventArgsFieldThreadId =
             typeof(BuildEventArgs).GetField("threadId", BindingFlags.Instance | BindingFlags.NonPublic);
-        private static FieldInfo buildEventArgsFieldSenderName =
+        private static FieldInfo? buildEventArgsFieldSenderName =
             typeof(BuildEventArgs).GetField("senderName", BindingFlags.Instance | BindingFlags.NonPublic);
 
         /// <summary>
@@ -67,18 +65,27 @@ public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion)
 
         public void Dispose()
         {
-            if (stringStorage != null)
-            {
-                stringStorage.Dispose();
-                stringStorage = null;
-            }
+            stringStorage.Dispose();
         }
 
+        /// <summary>
+        /// An event that allows the subscriber to be notified when a string is read from the binary log.
+        /// Subscriber may adjust the string by setting <see cref="StringReadEventArgs.StringToBeUsed"/> property.
+        /// The passed event arg can be reused and should not be stored.
+        /// </summary>
+        public event Action<StringReadEventArgs>? StringReadDone;
+
+        /// <summary>
+        /// An event that allows the caller to be notified when a string is encountered in the binary log.
+        /// BinaryReader passed in ctor is at the beginning of the string at this point.
+        /// </summary>
+        public event Action? StringEncountered;
+
         /// <summary>
         /// Raised when the log reader encounters a binary blob embedded in the stream.
         /// The arguments include the blob kind and the byte buffer with the contents.
         /// </summary>
-        internal event Action<BinaryLogRecordKind, byte[]> OnBlobRead;
+        internal event Action<BinaryLogRecordKind, byte[]>? OnBlobRead;
 
         /// <summary>
         /// Reads the next log record from the <see cref="BinaryReader"/>.
@@ -87,7 +94,7 @@ public void Dispose()
         /// The next <see cref="BuildEventArgs"/>.
         /// If there are no more records, returns <see langword="null"/>.
         /// </returns>
-        public BuildEventArgs Read()
+        public BuildEventArgs? Read()
         {
             BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();
 
@@ -114,7 +121,7 @@ public BuildEventArgs Read()
                 recordKind = (BinaryLogRecordKind)ReadInt32();
             }
 
-            BuildEventArgs result = null;
+            BuildEventArgs? result = null;
             switch (recordKind)
             {
                 case BinaryLogRecordKind.EndOfFile:
@@ -242,8 +249,10 @@ private IDictionary<string, string> GetNameValueList(int id)
                 var dictionary = ArrayDictionary<string, string>.Create(list.Length);
                 for (int i = 0; i < list.Length; i++)
                 {
-                    string key = GetStringFromRecord(list[i].keyIndex);
-                    string value = GetStringFromRecord(list[i].valueIndex);
+                    string? key = GetStringFromRecord(list[i].keyIndex);
+                    // passing null forward would require changes to API surface of existing events
+                    // (BuildStartedEventArgs.BuildEnvironment and ProjectStartedEventArgs.GlobalProperties)
+                    string value = GetStringFromRecord(list[i].valueIndex) ?? string.Empty;
                     if (key != null)
                     {
                         dictionary.Add(key, value);
@@ -258,6 +267,7 @@ private IDictionary<string, string> GetNameValueList(int id)
                 $"NameValueList record number {recordNumber} is invalid: index {id} is not within {stringRecords.Count}.");
         }
 
+        private readonly StringReadEventArgs stringReadEventArgs = new StringReadEventArgs(string.Empty);
         private void ReadStringRecord()
         {
             string text = ReadString();
@@ -304,11 +314,11 @@ private BuildEventArgs ReadTargetSkippedEventArgs()
             var targetName = ReadOptionalString();
             var parentTarget = ReadOptionalString();
 
-            string condition = null;
-            string evaluatedCondition = null;
+            string? condition = null;
+            string? evaluatedCondition = null;
             bool originallySucceeded = false;
             TargetSkipReason skipReason = TargetSkipReason.None;
-            BuildEventContext originalBuildEventContext = null;
+            BuildEventContext? originalBuildEventContext = null;
             if (fileFormatVersion >= 13)
             {
                 condition = ReadOptionalString();
@@ -381,7 +391,9 @@ private BuildEventArgs ReadBuildFinishedEventArgs()
         private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            var projectFile = ReadDeduplicatedString();
+            // Null message arg is not expected by the ProjectEvaluationStartedEventArgs
+            // Ensuring the non-null value - to avoid a need for public API change
+            var projectFile = ReadDeduplicatedString() ?? string.Empty;
 
             var e = new ProjectEvaluationStartedEventArgs(
                 ResourceUtilities.GetResourceString("EvaluationStarted"),
@@ -396,7 +408,8 @@ private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            var projectFile = ReadDeduplicatedString();
+            // Null message arg is not expected
+            var projectFile = ReadDeduplicatedString() ?? string.Empty;
 
             var e = new ProjectEvaluationFinishedEventArgs(
                 ResourceUtilities.GetResourceString("EvaluationFinished"),
@@ -408,7 +421,7 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
 
             if (fileFormatVersion >= 12)
             {
-                IEnumerable globalProperties = null;
+                IEnumerable? globalProperties = null;
                 if (ReadBoolean())
                 {
                     globalProperties = ReadStringDictionary();
@@ -448,7 +461,7 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
         private BuildEventArgs ReadProjectStartedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            BuildEventContext parentContext = null;
+            BuildEventContext? parentContext = null;
             if (ReadBoolean())
             {
                 parentContext = ReadBuildEventContext();
@@ -459,7 +472,7 @@ private BuildEventArgs ReadProjectStartedEventArgs()
             var targetNames = ReadDeduplicatedString();
             var toolsVersion = ReadOptionalString();
 
-            IDictionary<string, string> globalProperties = null;
+            IDictionary<string, string>? globalProperties = null;
 
             if (fileFormatVersion > 6)
             {
@@ -747,10 +760,10 @@ private BuildEventArgs ReadPropertyReassignmentEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
 
-            string propertyName = ReadDeduplicatedString();
-            string previousValue = ReadDeduplicatedString();
-            string newValue = ReadDeduplicatedString();
-            string location = ReadDeduplicatedString();
+            string? propertyName = ReadDeduplicatedString();
+            string? previousValue = ReadDeduplicatedString();
+            string? newValue = ReadDeduplicatedString();
+            string? location = ReadDeduplicatedString();
 
             var e = new PropertyReassignmentEventArgs(
                 propertyName,
@@ -769,7 +782,7 @@ private BuildEventArgs ReadPropertyReassignmentEventArgs()
         private BuildEventArgs ReadUninitializedPropertyReadEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
-            string propertyName = ReadDeduplicatedString();
+            string? propertyName = ReadDeduplicatedString();
 
             var e = new UninitializedPropertyReadEventArgs(
                 propertyName,
@@ -786,9 +799,9 @@ private BuildEventArgs ReadPropertyInitialValueSetEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
 
-            string propertyName = ReadDeduplicatedString();
-            string propertyValue = ReadDeduplicatedString();
-            string propertySource = ReadDeduplicatedString();
+            string? propertyName = ReadDeduplicatedString();
+            string? propertyValue = ReadDeduplicatedString();
+            string? propertySource = ReadDeduplicatedString();
 
             var e = new PropertyInitialValueSetEventArgs(
                 propertyName,
@@ -808,11 +821,11 @@ private AssemblyLoadBuildEventArgs ReadAssemblyLoadEventArgs()
             var fields = ReadBuildEventArgsFields(readImportance: false);
 
             AssemblyLoadingContext context = (AssemblyLoadingContext)ReadInt32();
-            string loadingInitiator = ReadDeduplicatedString();
-            string assemblyName = ReadDeduplicatedString();
-            string assemblyPath = ReadDeduplicatedString();
+            string? loadingInitiator = ReadDeduplicatedString();
+            string? assemblyName = ReadDeduplicatedString();
+            string? assemblyPath = ReadDeduplicatedString();
             Guid mvid = ReadGuid();
-            string appDomainName = ReadDeduplicatedString();
+            string? appDomainName = ReadDeduplicatedString();
 
             var e = new AssemblyLoadBuildEventArgs(
                 context,
@@ -923,7 +936,7 @@ private BuildEventArgsFields ReadBuildEventArgsFields(bool readImportance = fals
             if ((flags & BuildEventArgsFieldFlags.Arguments) != 0)
             {
                 int count = ReadInt32();
-                object[] arguments = new object[count];
+                object?[] arguments = new object[count];
                 for (int i = 0; i < count; i++)
                 {
                     arguments[i] = ReadDeduplicatedString();
@@ -946,12 +959,12 @@ private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields
 
             if ((fields.Flags & BuildEventArgsFieldFlags.ThreadId) != 0)
             {
-                buildEventArgsFieldThreadId.SetValue(buildEventArgs, fields.ThreadId);
+                buildEventArgsFieldThreadId?.SetValue(buildEventArgs, fields.ThreadId);
             }
 
             if ((fields.Flags & BuildEventArgsFieldFlags.SenderName) != 0)
             {
-                buildEventArgsFieldSenderName.SetValue(buildEventArgs, fields.SenderName);
+                buildEventArgsFieldSenderName?.SetValue(buildEventArgs, fields.SenderName);
             }
 
             if ((fields.Flags & BuildEventArgsFieldFlags.Timestamp) != 0)
@@ -960,7 +973,7 @@ private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields
             }
         }
 
-        private IEnumerable ReadPropertyList()
+        private IEnumerable? ReadPropertyList()
         {
             var properties = ReadStringDictionary();
             if (properties == null || properties.Count == 0)
@@ -1007,7 +1020,7 @@ private BuildEventContext ReadBuildEventContext()
             return result;
         }
 
-        private IDictionary<string, string> ReadStringDictionary()
+        private IDictionary<string, string>? ReadStringDictionary()
         {
             if (fileFormatVersion < 10)
             {
@@ -1024,7 +1037,7 @@ private IDictionary<string, string> ReadStringDictionary()
             return record;
         }
 
-        private IDictionary<string, string> ReadLegacyStringDictionary()
+        private IDictionary<string, string>? ReadLegacyStringDictionary()
         {
             int count = ReadInt32();
             if (count == 0)
@@ -1046,16 +1059,16 @@ private IDictionary<string, string> ReadLegacyStringDictionary()
 
         private ITaskItem ReadTaskItem()
         {
-            string itemSpec = ReadDeduplicatedString();
+            string? itemSpec = ReadDeduplicatedString();
             var metadata = ReadStringDictionary();
 
             var taskItem = new TaskItemData(itemSpec, metadata);
             return taskItem;
         }
 
-        private IEnumerable ReadProjectItems()
+        private IEnumerable? ReadProjectItems()
         {
-            IList<DictionaryEntry> list;
+            IList<DictionaryEntry>? list;
 
             // starting with format version 10 project items are grouped by name
             // so we only have to write the name once, and then the count of items
@@ -1088,7 +1101,7 @@ private IEnumerable ReadProjectItems()
                 list = new List<DictionaryEntry>();
                 for (int i = 0; i < count; i++)
                 {
-                    string itemType = ReadDeduplicatedString();
+                    string itemType = ReadDeduplicatedString()!;
                     var items = ReadTaskItemList();
                     if (items != null)
                     {
@@ -1110,7 +1123,7 @@ private IEnumerable ReadProjectItems()
 
                 while (true)
                 {
-                    string itemType = ReadDeduplicatedString();
+                    string itemType = ReadDeduplicatedString()!;
                     if (string.IsNullOrEmpty(itemType))
                     {
                         break;
@@ -1135,7 +1148,7 @@ private IEnumerable ReadProjectItems()
             return list;
         }
 
-        private IEnumerable ReadTaskItemList()
+        private IEnumerable? ReadTaskItemList()
         {
             int count = ReadInt32();
             if (count == 0)
@@ -1156,10 +1169,18 @@ private IEnumerable ReadTaskItemList()
 
         private string ReadString()
         {
-            return binaryReader.ReadString();
+            this.StringEncountered?.Invoke();
+            string text = binaryReader.ReadString();
+            if (this.StringReadDone != null)
+            {
+                stringReadEventArgs.Reuse(text);
+                StringReadDone(stringReadEventArgs);
+                text = stringReadEventArgs.StringToBeUsed;
+            }
+            return text;
         }
 
-        private string ReadOptionalString()
+        private string? ReadOptionalString()
         {
             if (fileFormatVersion < 10)
             {
@@ -1176,7 +1197,7 @@ private string ReadOptionalString()
             return ReadDeduplicatedString();
         }
 
-        private string ReadDeduplicatedString()
+        private string? ReadDeduplicatedString()
         {
             if (fileFormatVersion < 10)
             {
@@ -1187,7 +1208,7 @@ private string ReadDeduplicatedString()
             return GetStringFromRecord(index);
         }
 
-        private string GetStringFromRecord(int index)
+        private string? GetStringFromRecord(int index)
         {
             if (index == 0)
             {
@@ -1310,11 +1331,11 @@ internal class StringPosition
         /// </summary>
         internal class StringStorage : IDisposable
         {
-            private readonly string filePath;
-            private FileStream stream;
-            private StreamWriter streamWriter;
-            private readonly StreamReader streamReader;
-            private readonly StringBuilder stringBuilder;
+            private readonly string? filePath;
+            private FileStream? stream;
+            private StreamWriter? streamWriter;
+            private readonly StreamReader? streamReader;
+            private readonly StringBuilder? stringBuilder;
 
             public const int StringSizeThreshold = 1024;
 
@@ -1368,9 +1389,9 @@ public object Add(string text)
 
                 var stringPosition = new StringPosition();
 
-                stringPosition.FilePosition = stream.Position;
+                stringPosition.FilePosition = stream!.Position;
 
-                streamWriter.Write(text);
+                streamWriter!.Write(text);
 
                 stringPosition.StringLength = text.Length;
                 return stringPosition;
@@ -1385,16 +1406,16 @@ public string Get(object storedString)
 
                 var position = (StringPosition)storedString;
 
-                stream.Position = position.FilePosition;
-                stringBuilder.Length = position.StringLength;
+                stream!.Position = position.FilePosition;
+                stringBuilder!.Length = position.StringLength;
                 for (int i = 0; i < position.StringLength; i++)
                 {
-                    char ch = (char)streamReader.Read();
+                    char ch = (char)streamReader!.Read();
                     stringBuilder[i] = ch;
                 }
 
                 stream.Position = stream.Length;
-                streamReader.DiscardBufferedData();
+                streamReader!.DiscardBufferedData();
 
                 string result = stringBuilder.ToString();
                 stringBuilder.Clear();
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 7b40c84f4be..bc96814843e 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -156,6 +156,7 @@ Base types and inheritance ("EventArgs" suffix omitted):
                     TaskCommandLine
                     TaskParameter
                     UninitializedPropertyRead
+                    ExtendedMessage
                 BuildStatus
                     TaskStarted
                     TaskFinished
@@ -168,11 +169,13 @@ Base types and inheritance ("EventArgs" suffix omitted):
                     ProjectEvaluationStarted
                     ProjectEvaluationFinished
                 BuildError
+                    ExtendedBuildError
                 BuildWarning
+                    ExtendedBuildWarning
                 CustomBuild
                     ExternalProjectStarted
                     ExternalProjectFinished
-
+                    ExtendedCustomBuild
         */
 
         private void WriteCore(BuildEventArgs e)
@@ -220,12 +223,17 @@ public void WriteBlob(BinaryLogRecordKind kind, byte[] bytes)
 
         public void WriteBlob(BinaryLogRecordKind kind, Stream stream)
         {
+            if (stream.Length > int.MaxValue)
+            {
+                throw new ArgumentOutOfRangeException(nameof(stream));
+            }
+
             // write the blob directly to the underlying writer,
             // bypassing the memory stream
             using var redirection = RedirectWritesToOriginalWriter();
 
             Write(kind);
-            Write(stream.Length);
+            Write((int)stream.Length);
             Write(stream);
         }
 
diff --git a/src/Build/Logging/BinaryLogger/IBuildEventArgsReaderNotifications.cs b/src/Build/Logging/BinaryLogger/IBuildEventArgsReaderNotifications.cs
new file mode 100644
index 00000000000..415bd7c71fd
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/IBuildEventArgsReaderNotifications.cs
@@ -0,0 +1,13 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// An interface for notifications from BuildEventArgsReader
+    /// </summary>
+    public interface IBuildEventArgsReaderNotifications : IBuildEventStringsReader
+    {
+        /* For future use */
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/IBuildEventStringsReader.cs b/src/Build/Logging/BinaryLogger/IBuildEventStringsReader.cs
new file mode 100644
index 00000000000..e9e7651ee78
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/IBuildEventStringsReader.cs
@@ -0,0 +1,26 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// An interface for notifications about reading strings from the binary log.
+    /// </summary>
+    public interface IBuildEventStringsReader
+    {
+        /// <summary>
+        /// An event that allows the subscriber to be notified when a string is read from the binary log.
+        /// Subscriber may adjust the string by setting <see cref="StringReadEventArgs.StringToBeUsed"/> property.
+        /// The passed event arg can be reused and should not be stored.
+        /// </summary>
+        public event Action<StringReadEventArgs>? StringReadDone;
+
+        /// <summary>
+        /// An event that allows the caller to be notified when a string is encountered in the binary log.
+        /// BinaryReader passed in ctor is at the beginning of the string at this point.
+        /// </summary>
+        public event Action? StringEncountered;
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/StringReadEventArgs.cs b/src/Build/Logging/BinaryLogger/StringReadEventArgs.cs
new file mode 100644
index 00000000000..e2a4c83d3cb
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/StringReadEventArgs.cs
@@ -0,0 +1,35 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// An event args for <see cref="IBuildEventStringsReader.StringReadDone"/> callback.
+    /// </summary>
+    public sealed class StringReadEventArgs : EventArgs
+    {
+        /// <summary>
+        /// The original string that was read from the binary log.
+        /// </summary>
+        public string OriginalString { get; private set; }
+
+        /// <summary>
+        /// The adjusted string (or the original string of none subscriber replaced it) that will be used by the reader.
+        /// </summary>
+        public string StringToBeUsed { get; set; }
+
+        public StringReadEventArgs(string str)
+        {
+            OriginalString = str;
+            StringToBeUsed = str;
+        }
+
+        internal void Reuse(string newValue)
+        {
+            OriginalString = newValue;
+            StringToBeUsed = newValue;
+        }
+    }
+}
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index be295c3bf94..136b0c94d7f 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -4,6 +4,7 @@
 using System;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 using BaseConsoleLogger = Microsoft.Build.BackEnd.Logging.BaseConsoleLogger;
 using ParallelConsoleLogger = Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger;
@@ -158,10 +159,26 @@ private void InitializeBaseConsoleLogger()
             if (_numberOfProcessors == 1 && !useMPLogger)
             {
                 _consoleLogger = new SerialConsoleLogger(_verbosity, _write, _colorSet, _colorReset);
+                if (this is FileLogger)
+                {
+                    KnownTelemetry.LoggingConfigurationTelemetry.FileLoggerType = "serial";
+                }
+                else
+                {
+                    KnownTelemetry.LoggingConfigurationTelemetry.ConsoleLoggerType = "serial";
+                }
             }
             else
             {
                 _consoleLogger = new ParallelConsoleLogger(_verbosity, _write, _colorSet, _colorReset);
+                if (this is FileLogger)
+                {
+                    KnownTelemetry.LoggingConfigurationTelemetry.FileLoggerType = "parallel";
+                }
+                else
+                {
+                    KnownTelemetry.LoggingConfigurationTelemetry.ConsoleLoggerType = "parallel";
+                }
             }
 
             if (_showSummary != null)
@@ -339,6 +356,12 @@ public virtual void Initialize(IEventSource eventSource, int nodeCount)
             _numberOfProcessors = nodeCount;
             InitializeBaseConsoleLogger();
             _consoleLogger.Initialize(eventSource, nodeCount);
+
+            if (this is not FileLogger)
+            {
+                KnownTelemetry.LoggingConfigurationTelemetry.ConsoleLogger = true;
+                KnownTelemetry.LoggingConfigurationTelemetry.ConsoleLoggerVerbosity = Verbosity.ToString();
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Logging/FileLogger.cs b/src/Build/Logging/FileLogger.cs
index 180d58a2a08..bd0abc891b9 100644
--- a/src/Build/Logging/FileLogger.cs
+++ b/src/Build/Logging/FileLogger.cs
@@ -7,6 +7,7 @@
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -87,6 +88,9 @@ private void InitializeFileLogger(IEventSource eventSource, int nodeCount)
             // Finally, ask the base console logger class to initialize. It may
             // want to make decisions based on our verbosity, so we do this last.
             base.Initialize(eventSource, nodeCount);
+            KnownTelemetry.LoggingConfigurationTelemetry.FileLoggersCount++;
+            KnownTelemetry.LoggingConfigurationTelemetry.FileLogger = true;
+            KnownTelemetry.LoggingConfigurationTelemetry.FileLoggerVerbosity = Verbosity.ToString();
 
             if (!SkipProjectStartedText && Verbosity >= LoggerVerbosity.Normal)
             {
diff --git a/src/Build/Logging/SimpleErrorLogger.cs b/src/Build/Logging/SimpleErrorLogger.cs
new file mode 100644
index 00000000000..b895ab67f64
--- /dev/null
+++ b/src/Build/Logging/SimpleErrorLogger.cs
@@ -0,0 +1,84 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Logging.SimpleErrorLogger
+{
+    /// <summary>
+    /// This logger ignores all message-level output, writing errors and warnings to
+    /// standard error, colored red and yellow respectively.
+    ///
+    /// It is currently used only when the user requests information about specific
+    /// properties, items, or target results. In that case, we write the desired output
+    /// to standard out, but we do not want it polluted with any other kinds of information.
+    /// Users still might want diagnostic information if something goes wrong, so still
+    /// output that as necessary.
+    /// </summary>
+    public sealed class SimpleErrorLogger : INodeLogger
+    {
+        private readonly bool acceptAnsiColorCodes;
+        private readonly uint? originalConsoleMode;
+        public SimpleErrorLogger()
+        {
+            (acceptAnsiColorCodes, _, originalConsoleMode) = NativeMethods.QueryIsScreenAndTryEnableAnsiColorCodes(NativeMethods.StreamHandleType.StdErr);
+        }
+
+        public bool HasLoggedErrors { get; private set; } = false;
+
+        public LoggerVerbosity Verbosity
+        {
+            get => LoggerVerbosity.Minimal;
+            set { }
+        }
+
+        public string Parameters
+        {
+            get => string.Empty;
+            set { }
+        }
+
+        public void Initialize(IEventSource eventSource, int nodeCount)
+        {
+            eventSource.ErrorRaised += HandleErrorEvent;
+            eventSource.WarningRaised += HandleWarningEvent;
+        }
+
+        private void HandleErrorEvent(object sender, BuildErrorEventArgs e)
+        {
+            HasLoggedErrors = true;
+            LogErrorEvent(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true), "\x1b[31;1m");
+        }
+
+        private void HandleWarningEvent(object sender, BuildWarningEventArgs e)
+        {
+            LogErrorEvent(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true), "\x1b[33;1m");
+        }
+
+        private void LogErrorEvent(string s, string color)
+        {
+            if (acceptAnsiColorCodes)
+            {
+                Console.Error.Write(color);
+                Console.Error.Write(s);
+                Console.Error.WriteLine("\x1b[m");
+            }
+            else
+            {
+                Console.Error.Write(s);
+            }
+        }
+
+        public void Initialize(IEventSource eventSource)
+        {
+            Initialize(eventSource, 1);
+        }
+
+        public void Shutdown()
+        {
+            NativeMethods.RestoreConsoleMode(originalConsoleMode, NativeMethods.StreamHandleType.StdErr);
+        }
+    }
+}
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 88b6ef02c60..39a953f2948 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -33,7 +33,6 @@
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
-    <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
     <PackageReference Include="System.Reflection.MetadataLoadContext" />
@@ -47,6 +46,7 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <Reference Include="System.IO.Compression" />
     <PackageReference Include="System.Memory" />
+    <PackageReference Include="System.Text.Json" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
@@ -159,6 +159,9 @@
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
     <Compile Include="Evaluation\IItemTypeDefinition.cs" />
+    <Compile Include="Logging\BinaryLogger\IBuildEventArgsReaderNotifications.cs" />
+    <Compile Include="Logging\BinaryLogger\IBuildEventStringsReader.cs" />
+    <Compile Include="Logging\BinaryLogger\StringReadEventArgs.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
@@ -624,6 +627,7 @@
     <Compile Include="Logging\ParallelLogger\ParallelConsoleLogger.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="Logging\SimpleErrorLogger.cs" />
     <Compile Include="Logging\ParallelLogger\ConsoleOutputAligner.cs" />
     <Compile Include="Logging\FileLogger.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 9585808d321..0fb219fdd76 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: Nelze kopírovat z objektu tohoto typu.</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: Položka {2} odkazuje na {0} položek a položka {3} odkazuje na {1} položek. Musí mít stejný počet položek.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,7 +467,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">Jedná se o neošetřenou výjimku v MSBuildu – HLASUJTE PROSÍM PRO EXISTUJÍCÍ PROBLÉM NEBO VYTVOŘTE NOVÝ NA https://aka.ms/msbuild/unhandled.
+        <target state="translated">Jedná se o neošetřenou výjimku v MSBuildu – HLASUJTE PROSÍM PRO EXISTUJÍCÍ PROBLÉM NEBO VYTVOŘTE NOVÝ NA https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
@@ -1475,7 +1475,7 @@
       </trans-unit>
       <trans-unit id="SolutionVenusProjectSkipped">
         <source>Skipping because the "$(AspNetConfiguration)" configuration is not supported for this web project.  You can use the AspNetConfiguration property to override the configuration used for building web projects, by adding /p:AspNetConfiguration=&lt;value&gt; to the command line. Currently web projects only support Debug and Release configurations.</source>
-        <target state="translated">Vynecháno, protože konfigurace "$(AspNetConfiguration)" není pro tento webový projekt podporována. Pomocí vlastnosti AspNetConfiguration můžete přepsat konfiguraci používanou k sestavování webových projektů, a to přidáním příkazu /p:AspNetConfiguration=&lt;hodnota&gt; do příkazového řádku. Webové projekty nyní podporují pouze konfigurace Debug a Release.</target>
+        <target state="translated">Vynecháno, protože konfigurace $(AspNetConfiguration) není pro tento webový projekt podporována. Pomocí vlastnosti AspNetConfiguration můžete přepsat konfiguraci používanou k sestavování webových projektů, a to přidáním příkazu /p:AspNetConfiguration=&lt;hodnota&gt; do příkazového řádku. Webové projekty nyní podporují pouze konfigurace Debug a Release.</target>
         <note>
     UE: This is not an error, so doesn't need an error code.
     LOCALIZATION: Do NOT localize "AspNetConfiguration", "Debug", "Release".
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index f4e7c8fecf2..34f2984b55a 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: Aus einem Objekt dieses Typs kann nicht kopiert werden.</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: "{2}" verweist auf {0} Element(e), und "{3}" verweist auf {1} Element(e). Die Anzahl von Elementen muss identisch sein.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,7 +467,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">Dies ist eine nicht behandelte Ausnahme in MSBuild. RUFEN SIE EIN VORHANDENES PROBLEM AUF, ODER ERSTELLEN SIE EIN NEUES UNTER https://aka.ms/msbuild/unhandled.
+        <target state="translated">Dies ist eine nicht behandelte Ausnahme in MSBuild. RUFEN SIE EIN VORHANDENES PROBLEM AUF, ODER ERSTELLEN SIE EIN NEUES UNTER https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index cd9f379d43a..ad3fa5bce70 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: No se puede copiar desde un objeto de ese tipo.</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: "{2}" hace referencia a {0} elementos y "{3}" hace referencia a {1} elementos. Deben tener el mismo número de elementos.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,7 +467,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">Esta es una excepción no controlada en MSBuild. VOTE POR UN PROBLEMA EXISTENTE O PRESENTE UNO NUEVO EN https://aka.ms/msbuild/unhandled.
+        <target state="translated">Esta es una excepción no controlada en MSBuild. VOTE POR UN PROBLEMA EXISTENTE O PRESENTE UNO NUEVO EN https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index e276978cc62..62958ed7308 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: Impossible de copier à partir d’un objet de ce type.</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: "{2}" fait référence à {0} élément(s) et "{3}", à {1} élément(s). Ils doivent avoir le même nombre d'éléments.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,7 +467,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">Il s’agit d’une exception non gérée dans MSBuild -- VOTEZ POUR UN PROBLÈME EXISTANT OU ENTREZ UN NOUVEAU FICHIER À https://aka.ms/msbuild/unhandled.
+        <target state="translated">Il s’agit d’une exception non gérée dans MSBuild –– VOTEZ POUR UN PROBLÈME EXISTANT OU ENTREZ UN NOUVEAU FICHIER À https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index b7732e4b757..b78569055ff 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: non è possibile eseguire la copia dall'oggetto di quel tipo.</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: "{2}" fa riferimento a {0} elemento/i, mentre "{3}" fa riferimento a {1} elemento/i. Devono avere lo stesso numero di elementi.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,7 +467,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">Si tratta di un'eccezione non gestita in MSBuild-- ESEGUIRE L'UPVOTE DI UN PROBLEMA ESISTENTE O DI UN FILE NUOVO IN https://aka.ms/msbuild/unhandled.
+        <target state="translated">Si tratta di un'eccezione non gestita in MSBuild-- ESEGUIRE L'UPVOTE DI UN PROBLEMA ESISTENTE O DI UN FILE NUOVO IN https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index a721324c65e..6b1cdb3452c 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: その型のオブジェクトからコピーできません。</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: "{2}" は {0} 項目を参照し、"{3}" は {1} 項目を参照します。これらは同じ項目数を持たなければなりません。</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,7 +467,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">これは MSBuild でハンドルされない例外です -- 既存の問題に賛成票を投じるか、https://aka.ms/msbuild/unhandled で新しい問題を提起してください。
+        <target state="translated">これは MSBuild でハンドルされない例外です -- 既存の問題に賛成票を投じるか、https://aka.ms/msbuild/unhandled で新しい問題を提起してください。
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 7b986d98b1f..76064b46602 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: 해당 형식의 개체에서 복사할 수 없습니다.</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: "{2}"은(는) 항목을 {0}개 참조하고 "{3}"은(는) 항목을 {1}개 참조합니다. 참조하는 항목 수는 같아야 합니다.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,8 +467,8 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">MSBuild에서 처리되지 않은 예외입니다. https://aka.ms/msbuild/unhandled에서 기존 문제에 찬성 투표하거나 새 문제를 제출하세요.
- {0}</target>
+        <target state="translated">MSBuild에서 처리되지 않은 예외입니다. https://aka.ms/msbuild/unhandled에서 기존 문제에 찬성 투표하거나 새 문제를 제출하세요.
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="UninitializedPropertyRead">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index dbd317cfae4..a4ea3f9b1d4 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: Nie można skopiować z obiektu tego typu.</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: „{2}” odwołuje się do następującej liczby elementów: {0}, a „{3}” odwołuje się do następującej liczby elementów: {1}. Liczba tych elementów musi być taka sama.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,7 +467,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">To jest nieobsługiwany wyjątek w programie MSBuild — POPRZYJ ISTNIEJĄCY PROBLEM LUB ZAREJESTRUJ NOWY NA https://aka.ms/msbuild/unhandled.
+        <target state="translated">Jest to nieobsługiwany wyjątek w aplikacji MSBuild -- ZAGŁOSUJ NA ISTNIEJĄCY PROBLEM LUB ZAGŁOSUJ NA NOWY NA https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 10b8f1a51e8..6ca0dd891e9 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: Não é possível copiar do objeto desse tipo.</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: "{2}" refere-se ao(s) item(ns) {0} e "{3}" refere-se ao(s) item(ns) {1}. Eles devem ter o mesmo número de itens.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,7 +467,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">Esta é uma exceção sem tratamento no MSBuild -- VOTE A FAVOR DE UM PROBLEMA EXISTENTE OU REGISTRE UM NOVO EM https://aka.ms/msbuild/unhandled.
+        <target state="translated">Esta é uma exceção não tratada no MSBuild -- POR FAVOR, APOIE UM PROBLEMA EXISTENTE OU ARQUIVE UM NOVO EM https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 2b9e1c4de45..d54d3bca5a4 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: не удается скопировать из объекта этого типа.</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: "{2}" ссылается на следующее число элементов: {0}, а "{3}" — на {1}. Число элементов должно быть одинаковым.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,7 +467,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">Это необработанное исключение в MSBuild — ПРОГОЛОСУЙТЕ ЗА СУЩЕСТВУЮЩУЮ ПРОБЛЕМУ ИЛИ СОЗДАЙТЕ НОВУЮ на сайте https://aka.ms/msbuild/unhandled.
+        <target state="translated">Это необработанное исключение в MSBuild. Проголосуйте за существующую проблему или сообщите о новой по адресу https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index aac28e01115..2d211d40f45 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: Bu türdeki nesneden kopyalanamadı.</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: "{2}", {0} öğeye; "{3}", {1} öğeye başvuruyor. Aynı sayıda öğeye sahip olmaları gerekir.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,7 +467,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">Bu, MSBuild'de işlenmeyen bir özel durumdur -- LÜTFEN MEVCUT BIR SORUNA DESTEK OYU VERIN VEYA MEVCUT BIR SORUNU BİLDİRİN: https://aka.ms/msbuild/unhandled.
+        <target state="translated">Bu, MSBuild'de işlenmeyen bir istisnadır -- LÜTFEN MEVCUT BİR SORUNU OYLAYIN VEYA https://aka.ms/msbuild/unhandled ADRESİNDE YENİ BİR SORUN DOSYALAYIN
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index d8de24d8d8c..1d2c6843628 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: 无法从该类型的对象复制。</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: “{2}”引用 {0} 个项，而“{3}”引用 {1} 个项。它们必须具有相同的项数。</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,7 +467,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">这是 MSBuild 中未经处理的异常 -- 请对现有问题投赞成票或在 https://aka.ms/msbuild/unhandled 上提交新问题。
+        <target state="translated">这是 MSBuild 中未经处理的异常 -- 请对现有问题投赞成票或在 https://aka.ms/msbuild/unhandled 上提交新问题
     {0}</target>
         <note />
       </trans-unit>
@@ -2396,7 +2396,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
       </trans-unit>
       <trans-unit id="InvalidSdkFormat">
         <source>MSB4229: The value "{0}" is not valid for an Sdk specification. The attribute should be a semicolon-delimited list of Sdk-name/minimum-version pairs, separated by a forward slash.</source>
-        <target state="translated">MSB4229: 值“{0}”对 Sdk 规范无效。此属性应该是以分号分隔的Sdk-name/minimum-version 对 (用正斜杠分隔) 的列表。</target>
+        <target state="translated">MSB4229: 值“{0}”对 Sdk 规范无效。此属性应该是以分号分隔的Sdk-name/minimum-version 对（用正斜杠分隔）的列表。</target>
         <note>{StrBegin="MSB4229: "}</note>
       </trans-unit>
       <trans-unit id="TaskInstantiationFailureNotSupported">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 3312d3e49fc..c073146888d 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -57,7 +57,7 @@
       </trans-unit>
       <trans-unit id="CannotCopyFromElementOfThatType">
         <source>MSB4277: Cannot copy from object of that type.</source>
-        <target state="new">MSB4277: Cannot copy from object of that type.</target>
+        <target state="translated">MSB4277: 無法從該類型的物件複製。</target>
         <note>{StrBegin="MSB4277: "}</note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
@@ -141,7 +141,7 @@
       </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
-        <target state="new">MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</target>
+        <target state="translated">MSB3094: "{2}" 參考 {0} 個項目，"{3}" 則參考 {1} 個項目。兩者參考的項目數目必須相同。</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
@@ -467,7 +467,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="needs-review-translation">這是 MSBuild 中未處理的例外狀況 -- 請針對現有的問題附議，或在 https://aka.ms/msbuild/unhandled 提交新的問題。
+        <target state="translated">這是 MSBuild 中未處理的例外狀況 -- 請針對現有的問題附議，或在 https://aka.ms/msbuild/unhandled 提交新的問題
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index a0dd2580e23..0c26f6e1a8b 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -191,8 +191,10 @@ private static string[] GetFileList(
             FileMatcher.SearchAction action = FileMatcher.SearchAction.None;
             string excludeFileSpec = string.Empty;
 
-            if (!FilespecHasWildcards(filespecEscaped) ||
-                FilespecMatchesLazyWildcard(filespecEscaped, forceEvaluateWildCards))
+            var noWildcards = !FilespecHasWildcards(filespecEscaped) || FilespecMatchesLazyWildcard(filespecEscaped, forceEvaluateWildCards);
+
+            // It is possible to return original string if no wildcard matches and no entries in Exclude set. 
+            if (noWildcards && excludeSpecsEscaped?.Any() != true)
             {
                 // Just return the original string.
                 fileList = new string[] { returnEscaped ? filespecEscaped : EscapingUtilities.UnescapeAll(filespecEscaped) };
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 67e5223c258..68295e63b40 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -49,12 +49,6 @@
   </PropertyGroup>
 
   <ItemGroup Condition="'$(IsUnitTestProject)' == 'true'">
-    <!-- MSBuild isn't xunit analyzer clean, so remove the reference to the xunit package added by the repo toolset and
-         replace it with references to xunit.core and xunit.assert. -->
-    <PackageReference Remove="xunit" />
-    <PackageReference Include="xunit.core" />
-    <PackageReference Include="xunit.assert" />
-
     <!-- Force updated reference to this package because xunit and shouldly
          are netstandard1.6 and transitively bring in an old reference -->
     <PackageReference Include="System.Security.Cryptography.X509Certificates" />
diff --git a/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs b/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
index f0cdf2232cd..f93d085bef2 100644
--- a/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
@@ -31,7 +31,6 @@ public void SerializationDeserializationTest()
             AssemblyLoadBuildEventArgs argDeserialized = new();
             int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
             argDeserialized.CreateFromStream(br, packetVersion);
-
             argDeserialized.LoadingInitiator.ShouldBe(loadingInitiator);
             argDeserialized.AssemblyName.ShouldBe(assemblyName);
             argDeserialized.AssemblyPath.ShouldBe(assemblyPath);
diff --git a/src/Framework.UnitTests/EventArgs_Tests.cs b/src/Framework.UnitTests/EventArgs_Tests.cs
index c2af0cbdef1..04a1c9e61ea 100644
--- a/src/Framework.UnitTests/EventArgs_Tests.cs
+++ b/src/Framework.UnitTests/EventArgs_Tests.cs
@@ -53,27 +53,6 @@ public void EventArgsCtors()
         }
         #endregion
 
-        /// <summary>
-        /// Verify a whidbey project started event can be deserialized, the whidbey event is stored in a serialized base64 string.
-        /// </summary>
-        [Fact]
-        public void TestDeserialization()
-        {
-            string base64OldProjectStarted = "AAEAAAD/////AQAAAAAAAAAMAgAAAFxNaWNyb3NvZnQuQnVpbGQuRnJhbWV3b3JrLCBWZXJzaW9uPTIuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49YjAzZjVmN2YxMWQ1MGEzYQUBAAAAMU1pY3Jvc29mdC5CdWlsZC5GcmFtZXdvcmsuUHJvamVjdFN0YXJ0ZWRFdmVudEFyZ3MHAAAAC3Byb2plY3RGaWxlC3RhcmdldE5hbWVzFkJ1aWxkRXZlbnRBcmdzK21lc3NhZ2UaQnVpbGRFdmVudEFyZ3MraGVscEtleXdvcmQZQnVpbGRFdmVudEFyZ3Mrc2VuZGVyTmFtZRhCdWlsZEV2ZW50QXJncyt0aW1lc3RhbXAXQnVpbGRFdmVudEFyZ3MrdGhyZWFkSWQBAQEBAQAADQgCAAAABgMAAAALcHJvamVjdEZpbGUGBAAAAAt0YXJnZXROYW1lcwYFAAAAB21lc3NhZ2UGBgAAAAtoZWxwS2V5d29yZAYHAAAAB01TQnVpbGQBl5vjTYvIiAsAAAAL";
-            BinaryFormatter bf = new BinaryFormatter();
-            MemoryStream ms = new MemoryStream();
-            byte[] binaryObject = Convert.FromBase64String(base64OldProjectStarted);
-            ms.Write(binaryObject, 0, binaryObject.Length);
-            ms.Position = 0;
-            ProjectStartedEventArgs pse = (ProjectStartedEventArgs)bf.Deserialize(ms);
-            pse.Message.ShouldBe("message", StringCompareShould.IgnoreCase);
-            pse.ProjectFile.ShouldBe("projectFile", StringCompareShould.IgnoreCase);
-            pse.ProjectId.ShouldBe(-1);
-            pse.TargetNames.ShouldBe("targetNames", StringCompareShould.IgnoreCase);
-            pse.BuildEventContext.ShouldBe(BuildEventContext.Invalid);
-            pse.ParentProjectBuildEventContext.ShouldBe(BuildEventContext.Invalid);
-        }
-
         /// <summary>
         /// Verify the BuildEventContext is exercised
         /// </summary>
diff --git a/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs b/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs
new file mode 100644
index 00000000000..d1bcb987a1f
--- /dev/null
+++ b/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs
@@ -0,0 +1,218 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using FluentAssertions;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests;
+
+public class ExtendedBuildEventArgs_Tests
+{
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedCustomBuildEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedCustomBuildEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { {"m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedCustomBuildEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedErrorEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedBuildErrorEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            subcategory: withOptionalData ? "sub-type" : null,
+            code: withOptionalData ? "a-code" : null,
+            file: withOptionalData ? ".\\dev\\my.csproj" : null,
+            lineNumber: withOptionalData ? 1 : default,
+            columnNumber: withOptionalData ? 2 : default,
+            endLineNumber: withOptionalData ? 3 : default,
+            endColumnNumber: withOptionalData ? 4 : default,
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            helpLink: withOptionalData ? "(001)2234456" : null,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+        {
+            ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+            ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { { "m1", "v1" }, { "m2", "v2" } } : null,
+            BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+        };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedBuildErrorEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
+
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedWarningEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedBuildWarningEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            subcategory: withOptionalData ? "sub-type" : null,
+            code: withOptionalData ? "a-code" : null,
+            file: withOptionalData ? ".\\dev\\my.csproj" : null,
+            lineNumber: withOptionalData ? 1 : default,
+            columnNumber: withOptionalData ? 2 : default,
+            endLineNumber: withOptionalData ? 3 : default,
+            endColumnNumber: withOptionalData ? 4 : default,
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            helpLink: withOptionalData ? "(001)2234456" : null,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+        {
+            ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+            ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { { "m1", "v1" }, { "m2", "v2" } } : null,
+            BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+        };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedBuildWarningEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedMessageEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedBuildMessageEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            subcategory: withOptionalData ? "sub-type" : null,
+            code: withOptionalData ? "a-code" : null,
+            file: withOptionalData ? ".\\dev\\my.csproj" : null,
+            lineNumber: withOptionalData ? 1 : default,
+            columnNumber: withOptionalData ? 2 : default,
+            endLineNumber: withOptionalData ? 3 : default,
+            endColumnNumber: withOptionalData ? 4 : default,
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            importance: withOptionalData ? MessageImportance.Normal : default,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+        {
+            ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+            ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { { "m1", "v1" }, { "m2", "v2" } } : null,
+            BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+        };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedBuildMessageEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
+    [Fact]
+    public void ExtendedCustomBuildEventArgs_Ctors()
+    {
+        var ea = new ExtendedCustomBuildEventArgs();
+        ea = new ExtendedCustomBuildEventArgs("type");
+        ea = new ExtendedCustomBuildEventArgs("type", "Message {0}", "Help", "sender");
+        ea = new ExtendedCustomBuildEventArgs("type", "Message {0}", "Help", "sender", DateTime.Now);
+        ea = new ExtendedCustomBuildEventArgs("type", "Message {0}", "Help", "sender", DateTime.Now, "arg1");
+        ea = new ExtendedCustomBuildEventArgs("type");
+        ea = new ExtendedCustomBuildEventArgs("type", null, null, null);
+        ea = new ExtendedCustomBuildEventArgs("type", null, null, null, default(DateTime));
+        ea = new ExtendedCustomBuildEventArgs("type", null, null, null, default(DateTime), null);
+    }
+
+    [Fact]
+    public void ExtendedBuildErrorEventArgs_Ctors()
+    {
+        var ea = new ExtendedBuildErrorEventArgs();
+        ea = new ExtendedBuildErrorEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender");
+        ea = new ExtendedBuildErrorEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", DateTime.Now);
+        ea = new ExtendedBuildErrorEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", DateTime.Now, "Message");
+        ea = new ExtendedBuildErrorEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", "HelpLink", DateTime.Now, "Message");
+        ea = new ExtendedBuildErrorEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null);
+        ea = new ExtendedBuildErrorEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, DateTime.Now);
+        ea = new ExtendedBuildErrorEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, null, DateTime.Now, null);
+    }
+
+    [Fact]
+    public void ExtendedBuildWarningEventArgs_Ctors()
+    {
+        var ea = new ExtendedBuildWarningEventArgs();
+        ea = new ExtendedBuildWarningEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender");
+        ea = new ExtendedBuildWarningEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", DateTime.Now);
+        ea = new ExtendedBuildWarningEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", DateTime.Now, "Message");
+        ea = new ExtendedBuildWarningEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", "HelpLink", DateTime.Now, "Message");
+        ea = new ExtendedBuildWarningEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null);
+        ea = new ExtendedBuildWarningEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, DateTime.Now);
+        ea = new ExtendedBuildWarningEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, null, DateTime.Now, null);
+    }
+
+    [Fact]
+    public void ExtendedBuildMessageEventArgs_Ctors()
+    {
+        var ea = new ExtendedBuildMessageEventArgs();
+        ea = new ExtendedBuildMessageEventArgs("type");
+        ea = new ExtendedBuildMessageEventArgs("type", "Message", "HelpKeyword", "sender", MessageImportance.High);
+        ea = new ExtendedBuildMessageEventArgs("type", "Message", "HelpKeyword", "sender", MessageImportance.High, DateTime.Now);
+        ea = new ExtendedBuildMessageEventArgs("type", "Message", "HelpKeyword", "sender", MessageImportance.High, DateTime.Now, "arg1");
+        ea = new ExtendedBuildMessageEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", MessageImportance.High);
+        ea = new ExtendedBuildMessageEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", MessageImportance.High, DateTime.Now);
+        ea = new ExtendedBuildMessageEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", MessageImportance.High, DateTime.Now, "Message");
+        ea = new ExtendedBuildMessageEventArgs("type");
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, default);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, default, DateTime.Now);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, default, default, null);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, default);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, default, DateTime.Now);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, default, DateTime.Now, null);
+    }
+}
diff --git a/src/Framework.UnitTests/LoggerException_Tests.cs b/src/Framework.UnitTests/LoggerException_Tests.cs
deleted file mode 100644
index abc8c6fc726..00000000000
--- a/src/Framework.UnitTests/LoggerException_Tests.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.IO;
-using System.Runtime.Serialization.Formatters.Binary;
-using Microsoft.Build.Framework;
-using Shouldly;
-using Xunit;
-
-#nullable disable
-
-namespace Microsoft.Build.UnitTests
-{
-    public class LoggerExceptionTests
-    {
-        /// <summary>
-        /// Verify I implemented ISerializable correctly
-        /// </summary>
-        [Fact]
-        public void SerializeDeserialize()
-        {
-            LoggerException e = new LoggerException("message",
-                new Exception("innerException"),
-                "errorCode",
-                "helpKeyword");
-
-            using (MemoryStream memstr = new MemoryStream())
-            {
-                BinaryFormatter frm = new BinaryFormatter();
-
-                frm.Serialize(memstr, e);
-                memstr.Position = 0;
-
-                LoggerException e2 = (LoggerException)frm.Deserialize(memstr);
-
-                e2.ErrorCode.ShouldBe(e.ErrorCode);
-                e2.HelpKeyword.ShouldBe(e.HelpKeyword);
-                e2.Message.ShouldBe(e.Message);
-                e2.InnerException.ShouldNotBeNull();
-                e2.InnerException.Message.ShouldBe(e.InnerException?.Message);
-            }
-        }
-
-        /// <summary>
-        /// Verify I implemented ISerializable correctly, using other ctor
-        /// </summary>
-        [Fact]
-        public void SerializeDeserialize2()
-        {
-            LoggerException e = new LoggerException("message");
-
-            using (MemoryStream memstr = new MemoryStream())
-            {
-                BinaryFormatter frm = new BinaryFormatter();
-
-                frm.Serialize(memstr, e);
-                memstr.Position = 0;
-
-                LoggerException e2 = (LoggerException)frm.Deserialize(memstr);
-
-                e2.ErrorCode.ShouldBeNull();
-                e2.HelpKeyword.ShouldBeNull();
-                e2.Message.ShouldBe(e.Message);
-                e2.InnerException.ShouldBeNull();
-            }
-        }
-    }
-}
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index e3b953a332a..09c42cc408e 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -11,6 +11,7 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Include="FluentAssertions" />
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
     <PackageReference Include="Shouldly" />
diff --git a/src/Framework/AssemblyLoadBuildEventArgs.cs b/src/Framework/AssemblyLoadBuildEventArgs.cs
index 4c6c8292cbc..49f827b19c9 100644
--- a/src/Framework/AssemblyLoadBuildEventArgs.cs
+++ b/src/Framework/AssemblyLoadBuildEventArgs.cs
@@ -20,7 +20,7 @@ public AssemblyLoadBuildEventArgs(
             AssemblyLoadingContext loadingContext,
             string? loadingInitiator,
             string? assemblyName,
-            string assemblyPath,
+            string? assemblyPath,
             Guid mvid,
             string? customAppDomainDescriptor,
             MessageImportance importance = MessageImportance.Low)
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index a2eab07d302..995cfebfbc7 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -116,6 +116,26 @@ public void Translate(ref bool value)
                 value = _reader.ReadBoolean();
             }
 
+            /// <summary>
+            /// Translates an <see langword="bool"/> array.
+            /// </summary>
+            /// <param name="array">The array to be translated.</param>
+            public void Translate(ref bool[] array)
+            {
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                array = new bool[count];
+
+                for (int i = 0; i < count; i++)
+                {
+                    array[i] = _reader.ReadBoolean();
+                }
+            }
+
             /// <summary>
             /// Translates a byte.
             /// </summary>
@@ -808,6 +828,26 @@ public void Translate(ref bool value)
                 _writer.Write(value);
             }
 
+            /// <summary>
+            /// Translates an <see langword="bool"/> array.
+            /// </summary>
+            /// <param name="array">The array to be translated.</param>
+            public void Translate(ref bool[] array)
+            {
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = array.Length;
+                _writer.Write(count);
+
+                for (int i = 0; i < count; i++)
+                {
+                    _writer.Write(array[i]);
+                }
+            }
+
             /// <summary>
             /// Translates a byte.
             /// </summary>
diff --git a/src/Framework/BuildException/BuildExceptionBase.cs b/src/Framework/BuildException/BuildExceptionBase.cs
index acb93434e0e..07db4994b93 100644
--- a/src/Framework/BuildException/BuildExceptionBase.cs
+++ b/src/Framework/BuildException/BuildExceptionBase.cs
@@ -31,6 +31,9 @@ private protected BuildExceptionBase(
     { }
 
     // This is needed to allow opting back in to BinaryFormatter serialization
+#if NET8_0_OR_GREATER
+    [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
     private protected BuildExceptionBase(SerializationInfo info, StreamingContext context)
         : base(info, context)
     { }
diff --git a/src/Framework/BuildStartedEventArgs.cs b/src/Framework/BuildStartedEventArgs.cs
index d4c2882c4f9..09073ee9540 100644
--- a/src/Framework/BuildStartedEventArgs.cs
+++ b/src/Framework/BuildStartedEventArgs.cs
@@ -53,7 +53,7 @@ public BuildStartedEventArgs(
         public BuildStartedEventArgs(
             string? message,
             string? helpKeyword,
-            IDictionary<string, string> environmentOfBuild)
+            IDictionary<string, string>? environmentOfBuild)
             : this(message, helpKeyword, DateTime.UtcNow)
         {
             environmentOnBuildStart = environmentOfBuild;
diff --git a/src/Framework/ExtendedBuildErrorEventArgs.cs b/src/Framework/ExtendedBuildErrorEventArgs.cs
new file mode 100644
index 00000000000..85d10939236
--- /dev/null
+++ b/src/Framework/ExtendedBuildErrorEventArgs.cs
@@ -0,0 +1,126 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework;
+
+/// <summary>
+/// Generic custom error events including extended data for event enriching.
+/// Extended data are implemented by <see cref="IExtendedBuildEventArgs"/>
+/// </summary>
+public sealed class ExtendedBuildErrorEventArgs : BuildErrorEventArgs, IExtendedBuildEventArgs
+{
+    /// <inheritdoc />
+    public string ExtendedType { get; set; }
+
+    /// <inheritdoc />
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+
+    /// <inheritdoc />
+    public string? ExtendedData { get; set; }
+
+    /// <summary>
+    /// Default constructor. Used for deserialization.
+    /// </summary>
+    internal ExtendedBuildErrorEventArgs() : this("undefined") { }
+
+    /// <summary>
+    /// This constructor specifies only type of extended data.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    public ExtendedBuildErrorEventArgs(string type) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows all event data to be initialized
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    public ExtendedBuildErrorEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    public ExtendedBuildErrorEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, eventTimestamp) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedBuildErrorEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp, params object[]? messageArgs)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="helpLink">A link pointing to more information about the error </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedBuildErrorEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, string? helpLink, DateTime eventTimestamp, params object[]? messageArgs)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, helpLink, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+        writer.WriteExtendedBuildEventData(this);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+        reader.ReadExtendedBuildEventData(this);
+    }
+}
diff --git a/src/Framework/ExtendedBuildMessageEventArgs.cs b/src/Framework/ExtendedBuildMessageEventArgs.cs
new file mode 100644
index 00000000000..53ec510c8da
--- /dev/null
+++ b/src/Framework/ExtendedBuildMessageEventArgs.cs
@@ -0,0 +1,144 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework;
+
+/// <summary>
+/// Generic custom build events including extended data for event enriching.
+/// Extended data are implemented by <see cref="IExtendedBuildEventArgs"/>
+/// </summary>
+public sealed class ExtendedBuildMessageEventArgs : BuildMessageEventArgs, IExtendedBuildEventArgs
+{
+    /// <inheritdoc />
+    public string ExtendedType { get; set; }
+
+    /// <inheritdoc />
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+
+    /// <inheritdoc />
+    public string? ExtendedData { get; set; }
+
+    /// <summary>
+    /// Default constructor. Used for deserialization.
+    /// </summary>
+    internal ExtendedBuildMessageEventArgs() : this("undefined") { }
+
+    /// <summary>
+    /// This constructor specifies only type of extended data.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    public ExtendedBuildMessageEventArgs(string type) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows all event data to be initialized
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="importance">importance of the message</param>
+    public ExtendedBuildMessageEventArgs(string type, string? message, string? helpKeyword, string? senderName, MessageImportance importance)
+        : base(message, helpKeyword, senderName, importance) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="importance">importance of the message</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    public ExtendedBuildMessageEventArgs(string type, string? message, string? helpKeyword, string? senderName, MessageImportance importance, DateTime eventTimestamp)
+        : base(message, helpKeyword, senderName, importance, eventTimestamp) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="importance">importance of the message</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedBuildMessageEventArgs(string type, string? message, string? helpKeyword, string? senderName, MessageImportance importance, DateTime eventTimestamp, params object[]? messageArgs)
+        : base(message, helpKeyword, senderName, importance, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows all event data to be initialized
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="importance">importance of the message</param>
+    public ExtendedBuildMessageEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, MessageImportance importance)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, importance) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="importance">importance of the message</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    public ExtendedBuildMessageEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, MessageImportance importance, DateTime eventTimestamp)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, importance, eventTimestamp) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="importance">importance of the message</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedBuildMessageEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, MessageImportance importance, DateTime eventTimestamp, params object[]? messageArgs)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, importance, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+        writer.WriteExtendedBuildEventData(this);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+        reader.ReadExtendedBuildEventData(this);
+    }
+}
diff --git a/src/Framework/ExtendedBuildWarningEventArgs.cs b/src/Framework/ExtendedBuildWarningEventArgs.cs
new file mode 100644
index 00000000000..9481d2bfbdc
--- /dev/null
+++ b/src/Framework/ExtendedBuildWarningEventArgs.cs
@@ -0,0 +1,126 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework;
+
+/// <summary>
+/// Generic custom warning events including extended data for event enriching.
+/// Extended data are implemented by <see cref="IExtendedBuildEventArgs"/>
+/// </summary>
+public sealed class ExtendedBuildWarningEventArgs : BuildWarningEventArgs, IExtendedBuildEventArgs
+{
+    /// <inheritdoc />
+    public string ExtendedType { get; set; }
+
+    /// <inheritdoc />
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+
+    /// <inheritdoc />
+    public string? ExtendedData { get; set; }
+
+    /// <summary>
+    /// Default constructor. Used for deserialization.
+    /// </summary>
+    internal ExtendedBuildWarningEventArgs() : this("undefined") { }
+
+    /// <summary>
+    /// This constructor specifies only type of extended data.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    public ExtendedBuildWarningEventArgs(string type) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows all event data to be initialized
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    public ExtendedBuildWarningEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    public ExtendedBuildWarningEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, eventTimestamp) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedBuildWarningEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp, params object[]? messageArgs)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor which allows a timestamp to be set
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="subcategory">event sub-category</param>
+    /// <param name="code">event code</param>
+    /// <param name="file">file associated with the event</param>
+    /// <param name="lineNumber">line number (0 if not applicable)</param>
+    /// <param name="columnNumber">column number (0 if not applicable)</param>
+    /// <param name="endLineNumber">end line number (0 if not applicable)</param>
+    /// <param name="endColumnNumber">end column number (0 if not applicable)</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="helpLink">A link pointing to more information about the error </param>
+    /// <param name="senderName">name of event sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">message arguments</param>
+    public ExtendedBuildWarningEventArgs(string type, string? subcategory, string? code, string? file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber,
+        string? message, string? helpKeyword, string? senderName, string? helpLink, DateTime eventTimestamp, params object[]? messageArgs)
+        : base(subcategory, code, file, lineNumber, columnNumber, endLineNumber, endColumnNumber, message, helpKeyword, senderName, helpLink, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+        writer.WriteExtendedBuildEventData(this);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+        reader.ReadExtendedBuildEventData(this);
+    }
+}
diff --git a/src/Framework/ExtendedCustomBuildEventArgs.cs b/src/Framework/ExtendedCustomBuildEventArgs.cs
new file mode 100644
index 00000000000..0669c025843
--- /dev/null
+++ b/src/Framework/ExtendedCustomBuildEventArgs.cs
@@ -0,0 +1,80 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework;
+
+/// <summary>
+/// Generic custom event.
+/// Extended data are implemented by <see cref="IExtendedBuildEventArgs"/>
+/// </summary>
+public sealed class ExtendedCustomBuildEventArgs : CustomBuildEventArgs, IExtendedBuildEventArgs
+{
+    /// <inheritdoc />
+    public string ExtendedType { get; set; }
+
+    /// <inheritdoc />
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+
+    /// <inheritdoc />
+    public string? ExtendedData { get; set; }
+
+    /// <summary>
+    /// This constructor allows event data to be initialized.
+    /// </summary>
+    /// <seealso cref="IExtendedBuildEventArgs.ExtendedType"/>
+    internal ExtendedCustomBuildEventArgs() : this("undefined") {}
+
+    /// <summary>
+    /// This constructor allows event data to be initialized.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <seealso cref="IExtendedBuildEventArgs.ExtendedType"/>
+    public ExtendedCustomBuildEventArgs(string type) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows event data to be initialized.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of sender</param>
+    public ExtendedCustomBuildEventArgs(string type, string? message, string? helpKeyword, string? senderName) : base(message, helpKeyword, senderName) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows event data to be initialized including timestamp.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    public ExtendedCustomBuildEventArgs(string type, string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp) : base(message, helpKeyword, senderName, eventTimestamp) => ExtendedType = type;
+
+    /// <summary>
+    /// This constructor allows event data to be initialized including timestamp.
+    /// </summary>
+    /// <param name="type">Type of <see cref="IExtendedBuildEventArgs.ExtendedType"/>.</param>
+    /// <param name="message">text message</param>
+    /// <param name="helpKeyword">help keyword </param>
+    /// <param name="senderName">name of sender</param>
+    /// <param name="eventTimestamp">Timestamp when event was created</param>
+    /// <param name="messageArgs">Message arguments</param>
+    public ExtendedCustomBuildEventArgs(string type, string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp, params object[]? messageArgs) : base(message, helpKeyword, senderName, eventTimestamp, messageArgs) => ExtendedType = type;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        base.WriteToStream(writer);
+        writer.WriteExtendedBuildEventData(this);
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        base.CreateFromStream(reader, version);
+        reader.ReadExtendedBuildEventData(this);
+    }
+}
diff --git a/src/Framework/ExternalProjectFinishedEventArgs.cs b/src/Framework/ExternalProjectFinishedEventArgs.cs
index e3960625c3a..4417569e8fc 100644
--- a/src/Framework/ExternalProjectFinishedEventArgs.cs
+++ b/src/Framework/ExternalProjectFinishedEventArgs.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -16,6 +18,8 @@ namespace Microsoft.Build.Framework
     // immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both
     // forward and backward compatibility
+    // NOTE: Although this class has been modified and do not longer relay on [Serializable]
+    // and BinaryFormatter. We have left it [Serializable] for backward compatibility reasons.
     [Serializable]
     public class ExternalProjectFinishedEventArgs : CustomBuildEventArgs
     {
@@ -93,5 +97,19 @@ public bool Succeeded
                 return succeeded;
             }
         }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+            writer.WriteOptionalString(projectFile);
+            writer.Write(succeeded);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+            projectFile = reader.ReadOptionalString();
+            succeeded = reader.ReadBoolean();
+        }
     }
 }
diff --git a/src/Framework/ExternalProjectStartedEventArgs.cs b/src/Framework/ExternalProjectStartedEventArgs.cs
index 80488df82e9..0d25191f08e 100644
--- a/src/Framework/ExternalProjectStartedEventArgs.cs
+++ b/src/Framework/ExternalProjectStartedEventArgs.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -16,6 +18,8 @@ namespace Microsoft.Build.Framework
     // immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both
     // forward and backward compatibility
+    // NOTE: Although this class has been modified and do not longer relay on [Serializable]
+    // and BinaryFormatter. We have left it [Serializable] for backward compatibility reasons.
     [Serializable]
     public class ExternalProjectStartedEventArgs : CustomBuildEventArgs
     {
@@ -95,5 +99,19 @@ public string TargetNames
                 return targetNames;
             }
         }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+            writer.WriteOptionalString(projectFile);
+            writer.WriteOptionalString(targetNames);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+            projectFile = reader.ReadOptionalString();
+            targetNames = reader.ReadOptionalString();
+        }
     }
 }
diff --git a/src/Framework/IExtendedBuildEventArgs.cs b/src/Framework/IExtendedBuildEventArgs.cs
new file mode 100644
index 00000000000..0c73ddb914f
--- /dev/null
+++ b/src/Framework/IExtendedBuildEventArgs.cs
@@ -0,0 +1,33 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework;
+
+/// <summary>
+/// Interface for Extended EventArgs to allow enriching particular events with extended data.
+/// Deriving from EventArgs will be deprecated soon and using Extended EventArgs is recommended for custom Event Args.
+/// </summary>
+public interface IExtendedBuildEventArgs
+{
+    /// <summary>
+    /// Unique string identifying type of extended data so receiver side knows how to interpret, deserialize and handle <see cref="ExtendedData"/>.
+    /// </summary>
+    string ExtendedType { get; set; }
+
+    /// <summary>
+    /// Metadata of <see cref="ExtendedData"/>.
+    /// Example usage:
+    ///   - data which needed in custom code to properly routing this message without interpreting/deserializing <see cref="ExtendedData"/>.
+    ///   - simple extended data can be transferred in form of dictionary key-value per one extended property.
+    /// </summary>
+    Dictionary<string, string?>? ExtendedMetadata { get; set; }
+
+    /// <summary>
+    /// Transparent data as string.
+    /// Custom code is responsible to serialize and deserialize this string to structured data - if needed.
+    /// Custom code can use any serialization they deem safe - e.g. json for textual data, base64 for binary data...
+    /// </summary>
+    string? ExtendedData { get; set; }
+}
diff --git a/src/Framework/IMetadataContainer.cs b/src/Framework/IMetadataContainer.cs
index 7762bc33e31..cc6588f9839 100644
--- a/src/Framework/IMetadataContainer.cs
+++ b/src/Framework/IMetadataContainer.cs
@@ -20,5 +20,17 @@ internal interface IMetadataContainer
         /// in the binary logger.
         /// </summary>
         IEnumerable<KeyValuePair<string, string>> EnumerateMetadata();
+
+        /// <summary>
+        /// Sets the given metadata. The operation is equivalent to calling
+        /// <see cref="ITaskItem.SetMetadata"/> on all metadata, but takes
+        /// advantage of a faster bulk-set operation where applicable. The
+        /// implementation may not perform the same parameter validation
+        /// as SetMetadata.
+        /// </summary>
+        /// <param name="metadata">The metadata to set. The keys are assumed
+        /// to be unique and values are assumed to be escaped.
+        /// </param>
+        void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata);
     }
 }
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index abe32f8d96f..930cc45f6b2 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -104,6 +104,12 @@ BinaryWriter Writer
         /// <param name="value">The value to be translated.</param>
         void Translate(ref bool value);
 
+        /// <summary>
+        /// Translates an <see langword="bool"/> array.
+        /// </summary>
+        /// <param name="array">The array to be translated.</param>
+        void Translate(ref bool[] array);
+
         /// <summary>
         /// Translates a byte.
         /// </summary>
diff --git a/src/Framework/InternalErrorException.cs b/src/Framework/InternalErrorException.cs
index 4aef7c049ea..e024e3f67a5 100644
--- a/src/Framework/InternalErrorException.cs
+++ b/src/Framework/InternalErrorException.cs
@@ -75,6 +75,9 @@ private InternalErrorException(string message, Exception innerException, bool ca
         /// Private constructor used for (de)serialization. The constructor is private as this class is sealed
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private InternalErrorException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
diff --git a/src/Framework/LoggerException.cs b/src/Framework/LoggerException.cs
index a671142368a..05e457d90ee 100644
--- a/src/Framework/LoggerException.cs
+++ b/src/Framework/LoggerException.cs
@@ -82,6 +82,9 @@ public LoggerException(string message, Exception innerException, string errorCod
         /// </summary>
         /// <param name="info">Serialization info</param>
         /// <param name="context">Streaming context</param>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected LoggerException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
@@ -97,6 +100,9 @@ protected LoggerException(SerializationInfo info, StreamingContext context)
         /// <param name="context">Streaming context</param>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
@@ -121,7 +127,7 @@ protected override void InitializeCustomState(IDictionary<string, string> state)
             helpKeyword = state[nameof(helpKeyword)];
         }
 
-        #endregion
+#endregion
 
         #region Properties
 
diff --git a/src/Framework/MetaProjectGeneratedEventArgs.cs b/src/Framework/MetaProjectGeneratedEventArgs.cs
index c18111d9459..1a529ed7171 100644
--- a/src/Framework/MetaProjectGeneratedEventArgs.cs
+++ b/src/Framework/MetaProjectGeneratedEventArgs.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.Shared;
+using System.IO;
 
 #nullable disable
 
@@ -27,5 +29,19 @@ public MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPa
             this.metaprojectXml = metaprojectXml;
             this.ProjectFile = metaprojectPath;
         }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            writer.WriteOptionalString(metaprojectXml);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            metaprojectXml = reader.ReadOptionalString();
+        }
     }
 }
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index c71d9f49ff6..e31b42aa0e4 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -35,6 +35,7 @@ internal static class NativeMethods
     internal const uint RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = 0x40;
     internal const uint FILE_TYPE_CHAR = 0x0002;
     internal const Int32 STD_OUTPUT_HANDLE = -11;
+    internal const Int32 STD_ERROR_HANDLE = -12;
     internal const uint ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004;
     internal const uint RPC_S_CALLPENDING = 0x80010115;
     internal const uint E_ABORT = (uint)0x80004004;
@@ -76,6 +77,12 @@ internal static class NativeMethods
 
     #region Enums
 
+    internal enum StreamHandleType
+    {
+        StdOut = STD_OUTPUT_HANDLE,
+        StdErr = STD_ERROR_HANDLE,
+    };
+
     private enum PROCESSINFOCLASS : int
     {
         ProcessBasicInformation = 0,
@@ -1481,11 +1488,11 @@ internal static void VerifyThrowWin32Result(int result)
     }
 
 #if !CLR2COMPATIBILITY
-    internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalConsoleMode) QueryIsScreenAndTryEnableAnsiColorCodes()
+    internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalConsoleMode) QueryIsScreenAndTryEnableAnsiColorCodes(StreamHandleType handleType = StreamHandleType.StdOut)
     {
         if (Console.IsOutputRedirected)
         {
-            // There's no ANSI terminal support is console output is redirected.
+            // There's no ANSI terminal support if console output is redirected.
             return (acceptAnsiColorCodes: false, outputIsScreen: false, originalConsoleMode: null);
         }
 
@@ -1496,8 +1503,8 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
         {
             try
             {
-                IntPtr stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
-                if (GetConsoleMode(stdOut, out uint consoleMode))
+                IntPtr outputStream = GetStdHandle((int)handleType);
+                if (GetConsoleMode(outputStream, out uint consoleMode))
                 {
                     if ((consoleMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == ENABLE_VIRTUAL_TERMINAL_PROCESSING)
                     {
@@ -1508,7 +1515,7 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
                     {
                         originalConsoleMode = consoleMode;
                         consoleMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
-                        if (SetConsoleMode(stdOut, consoleMode) && GetConsoleMode(stdOut, out consoleMode))
+                        if (SetConsoleMode(outputStream, consoleMode) && GetConsoleMode(outputStream, out consoleMode))
                         {
                             // We only know if vt100 is supported if the previous call actually set the new flag, older
                             // systems ignore the setting.
@@ -1516,7 +1523,7 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
                         }
                     }
 
-                    uint fileType = GetFileType(stdOut);
+                    uint fileType = GetFileType(outputStream);
                     // The std out is a char type (LPT or Console).
                     outputIsScreen = fileType == FILE_TYPE_CHAR;
                     acceptAnsiColorCodes &= outputIsScreen;
@@ -1537,11 +1544,11 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
         return (acceptAnsiColorCodes, outputIsScreen, originalConsoleMode);
     }
 
-    internal static void RestoreConsoleMode(uint? originalConsoleMode)
+    internal static void RestoreConsoleMode(uint? originalConsoleMode, StreamHandleType handleType = StreamHandleType.StdOut)
     {
         if (IsWindows && originalConsoleMode is not null)
         {
-            IntPtr stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
+            IntPtr stdOut = GetStdHandle((int)handleType);
             _ = SetConsoleMode(stdOut, originalConsoleMode.Value);
         }
     }
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index 539fae2b5e1..eba6c9ac5ab 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -76,11 +76,11 @@ public ProjectStartedEventArgs(
             int projectId,
             string message,
             string helpKeyword,
-            string projectFile,
-            string targetNames,
-            IEnumerable properties,
-            IEnumerable items,
-            BuildEventContext parentBuildEventContext)
+            string? projectFile,
+            string? targetNames,
+            IEnumerable? properties,
+            IEnumerable? items,
+            BuildEventContext? parentBuildEventContext)
             : this(projectId, message, helpKeyword, projectFile, targetNames, properties, items, parentBuildEventContext, DateTime.UtcNow)
         {
         }
@@ -103,13 +103,13 @@ public ProjectStartedEventArgs(
             int projectId,
             string message,
             string helpKeyword,
-            string projectFile,
-            string targetNames,
-            IEnumerable properties,
-            IEnumerable items,
-            BuildEventContext parentBuildEventContext,
-            IDictionary<string, string> globalProperties,
-            string toolsVersion)
+            string? projectFile,
+            string? targetNames,
+            IEnumerable? properties,
+            IEnumerable? items,
+            BuildEventContext? parentBuildEventContext,
+            IDictionary<string, string>? globalProperties,
+            string? toolsVersion)
             : this(projectId, message, helpKeyword, projectFile, targetNames, properties, items, parentBuildEventContext)
         {
             this.GlobalProperties = globalProperties;
@@ -130,10 +130,10 @@ public ProjectStartedEventArgs(
         public ProjectStartedEventArgs(
             string message,
             string helpKeyword,
-            string projectFile,
-            string targetNames,
-            IEnumerable properties,
-            IEnumerable items,
+            string? projectFile,
+            string? targetNames,
+            IEnumerable? properties,
+            IEnumerable? items,
             DateTime eventTimestamp)
             : base(message, helpKeyword, "MSBuild", eventTimestamp)
         {
@@ -160,11 +160,11 @@ public ProjectStartedEventArgs(
             int projectId,
             string message,
             string helpKeyword,
-            string projectFile,
-            string targetNames,
-            IEnumerable properties,
-            IEnumerable items,
-            BuildEventContext parentBuildEventContext,
+            string? projectFile,
+            string? targetNames,
+            IEnumerable? properties,
+            IEnumerable? items,
+            BuildEventContext? parentBuildEventContext,
             DateTime eventTimestamp)
             : this(message, helpKeyword, projectFile, targetNames, properties, items, eventTimestamp)
         {
diff --git a/src/Framework/PropertyInitialValueSetEventArgs.cs b/src/Framework/PropertyInitialValueSetEventArgs.cs
index 2f623ad6648..318755fcde3 100644
--- a/src/Framework/PropertyInitialValueSetEventArgs.cs
+++ b/src/Framework/PropertyInitialValueSetEventArgs.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -56,5 +58,23 @@ public PropertyInitialValueSetEventArgs(
         /// The source of the property.
         /// </summary>
         public string PropertySource { get; set; }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            writer.WriteOptionalString(PropertyName);
+            writer.WriteOptionalString(PropertyValue);
+            writer.WriteOptionalString(PropertySource);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            PropertyName = reader.ReadOptionalString();
+            PropertyValue = reader.ReadOptionalString();
+            PropertySource = reader.ReadOptionalString();
+        }
     }
 }
diff --git a/src/Framework/PropertyReassignmentEventArgs.cs b/src/Framework/PropertyReassignmentEventArgs.cs
index 7c3c81f92e2..29ec2935e0b 100644
--- a/src/Framework/PropertyReassignmentEventArgs.cs
+++ b/src/Framework/PropertyReassignmentEventArgs.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -79,5 +81,25 @@ public override string Message
                 return RawMessage;
             }
         }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            writer.WriteOptionalString(PropertyName);
+            writer.WriteOptionalString(NewValue);
+            writer.WriteOptionalString(PreviousValue);
+            writer.WriteOptionalString(Location);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            PropertyName = reader.ReadOptionalString();
+            NewValue = reader.ReadOptionalString();
+            PreviousValue = reader.ReadOptionalString();
+            Location = reader.ReadOptionalString();
+        }
     }
 }
diff --git a/src/Framework/ResponseFileUsedEventArgs.cs b/src/Framework/ResponseFileUsedEventArgs.cs
index bc027518a67..7e9f132a262 100644
--- a/src/Framework/ResponseFileUsedEventArgs.cs
+++ b/src/Framework/ResponseFileUsedEventArgs.cs
@@ -17,7 +17,7 @@ public ResponseFileUsedEventArgs()
         /// <summary>
         /// Initialize a new instance of the ResponseFileUsedEventArgs class.
         /// </summary>
-        public ResponseFileUsedEventArgs(string responseFilePath) : base()
+        public ResponseFileUsedEventArgs(string? responseFilePath) : base()
         {
             ResponseFilePath = responseFilePath;
         }
diff --git a/src/Framework/TaskItemData.cs b/src/Framework/TaskItemData.cs
index ca25414fa27..48c3410d7d8 100644
--- a/src/Framework/TaskItemData.cs
+++ b/src/Framework/TaskItemData.cs
@@ -49,6 +49,9 @@ public TaskItemData(ITaskItem original)
 
         IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata() => Metadata;
 
+        void IMetadataContainer.ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
+            => throw new InvalidOperationException($"{nameof(TaskItemData)} does not support write operations");
+
         public int MetadataCount => Metadata.Count;
 
         public ICollection MetadataNames => (ICollection)Metadata.Keys;
diff --git a/src/Framework/Telemetry/KnownTelemetry.cs b/src/Framework/Telemetry/KnownTelemetry.cs
index 2a335fa0930..7685bdda537 100644
--- a/src/Framework/Telemetry/KnownTelemetry.cs
+++ b/src/Framework/Telemetry/KnownTelemetry.cs
@@ -15,4 +15,9 @@ internal static class KnownTelemetry
     /// Null means there are no prior collected build telemetry data, new clean instance shall be created for particular build.
     /// </summary>
     public static BuildTelemetry? PartialBuildTelemetry { get; set; }
+
+    /// <summary>
+    /// Describes how logging was configured.
+    /// </summary>
+    public static LoggingConfigurationTelemetry LoggingConfigurationTelemetry { get; } = new LoggingConfigurationTelemetry();
 }
diff --git a/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs b/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
new file mode 100644
index 00000000000..5281c43b9d2
--- /dev/null
+++ b/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
@@ -0,0 +1,150 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Globalization;
+
+namespace Microsoft.Build.Framework.Telemetry;
+
+internal class LoggingConfigurationTelemetry : TelemetryBase
+{
+    public override string EventName => "loggingConfiguration";
+
+    /// <summary>
+    /// True if terminal logger was used.
+    /// </summary>
+    public bool TerminalLogger { get; set; }
+
+    /// <summary>
+    /// What was user intent:
+    ///   on | true -> user intent to enable logging
+    ///   off | false -> user intent to disable logging
+    ///   auto -> user intent to use logging if terminal allows it
+    ///   null -> no user intent, using default
+    /// </summary>
+    public string? TerminalLoggerUserIntent { get; set; }
+
+    /// <summary>
+    /// How was user intent signaled:
+    ///   arg -> from command line argument or rsp file
+    ///   MSBUILDTERMINALLOGGER -> from environment variable
+    ///   MSBUILDLIVELOGGER -> from environment variable
+    ///   null -> no user intent
+    /// </summary>
+    public string? TerminalLoggerUserIntentSource { get; set; }
+
+    /// <summary>
+    /// The default behavior of terminal logger if user intent is not specified:
+    ///   on | true -> enable logging
+    ///   off | false -> disable logging
+    ///   auto -> use logging if terminal allows it
+    ///   null -> unspecified
+    /// </summary>
+    public string? TerminalLoggerDefault { get; set; }
+
+    /// <summary>
+    /// How was default behavior signaled:
+    ///   sdk -> from SDK
+    ///   DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER -> from environment variable
+    ///   msbuild -> MSBuild hardcoded default
+    ///   null -> unspecified
+    /// </summary>
+    public string? TerminalLoggerDefaultSource { get; set; }
+
+    /// <summary>
+    /// True if console logger was used.
+    /// </summary>
+    public bool ConsoleLogger { get; set; }
+
+    /// <summary>
+    /// Type of console logger: serial | parallel
+    /// </summary>
+    public string? ConsoleLoggerType { get; set; }
+
+    /// <summary>
+    /// Verbosity of console logger: quiet | minimal | normal | detailed | diagnostic
+    /// </summary>
+    public string? ConsoleLoggerVerbosity { get; set; }
+
+
+    /// <summary>
+    /// True if file logger was used.
+    /// </summary>
+    public bool FileLogger { get; set; }
+
+    /// <summary>
+    /// Type of file logger: serial | parallel
+    /// </summary>
+    public string? FileLoggerType { get; set; }
+
+    /// <summary>
+    /// Number of file loggers.
+    /// </summary>
+    public int FileLoggersCount { get; set; }
+
+    /// <summary>
+    /// Verbosity of file logger: quiet | minimal | normal | detailed | diagnostic
+    /// </summary>
+    public string? FileLoggerVerbosity { get; set; }
+
+    /// <summary>
+    /// True if binary logger was used.
+    /// </summary>
+    public bool BinaryLogger { get; set; }
+
+    /// <summary>
+    /// True if binary logger used default name i.e. no LogFile was specified.
+    /// </summary>
+    public bool BinaryLoggerUsedDefaultName { get; set; }
+
+    public override void UpdateEventProperties()
+    {
+        Properties["TerminalLogger"] = TerminalLogger.ToString(CultureInfo.InvariantCulture);
+
+        if (TerminalLoggerUserIntent != null)
+        {
+            Properties["TerminalLoggerUserIntent"] = TerminalLoggerUserIntent;
+        }
+
+        if (TerminalLoggerUserIntentSource != null)
+        {
+            Properties["TerminalLoggerUserIntentSource"] = TerminalLoggerUserIntentSource;
+        }
+
+        if (TerminalLoggerDefault != null)
+        {
+            Properties["TerminalLoggerDefault"] = TerminalLoggerDefault;
+        }
+
+        if (TerminalLoggerDefaultSource != null)
+        {
+            Properties["TerminalLoggerDefaultSource"] = TerminalLoggerDefaultSource;
+        }
+
+        Properties["ConsoleLogger"] = ConsoleLogger.ToString(CultureInfo.InvariantCulture);
+        if (ConsoleLoggerType != null)
+        {
+            Properties["ConsoleLoggerType"] = ConsoleLoggerType;
+        }
+
+        if (ConsoleLoggerVerbosity != null)
+        {
+            Properties["ConsoleLoggerVerbosity"] = ConsoleLoggerVerbosity;
+        }
+
+        Properties["FileLogger"] = FileLogger.ToString(CultureInfo.InvariantCulture);
+        if (FileLoggerType != null)
+        {
+            Properties["FileLoggerType"] = FileLoggerType;
+            Properties["FileLoggersCount"] = FileLoggersCount.ToString(CultureInfo.InvariantCulture);
+        }
+
+        if (FileLoggerVerbosity != null)
+        {
+            Properties["FileLoggerVerbosity"] = FileLoggerVerbosity;
+        }
+
+        Properties["BinaryLogger"] = BinaryLogger.ToString(CultureInfo.InvariantCulture);
+        Properties["BinaryLoggerUsedDefaultName"] = BinaryLoggerUsedDefaultName.ToString(CultureInfo.InvariantCulture);
+    }
+}
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 24d86c42fd5..9be74ea1bc8 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -372,6 +372,29 @@ public SdkReferencePropertyExpansionMode? SdkReferencePropertyExpansion
             }
         }
 
+        /// <summary>
+        /// Allows displaying the deprecation warning for BinaryFormatter in your current environment.
+        /// </summary>
+        public bool EnableWarningOnCustomBuildEvent
+        {
+            get
+            {
+                var value = Environment.GetEnvironmentVariable("MSBUILDCUSTOMBUILDEVENTWARNING");
+
+                if (value == null)
+                {
+                    // If variable is not set explicitly, for .NETCORE warning appears.
+#if RUNTIME_TYPE_NETCORE
+                    return true;
+#else
+                    return false;
+#endif
+                }
+
+                return value == "1";
+            }
+        }
+
         private static bool? ParseNullableBoolFromEnvironmentVariable(string environmentVariable)
         {
             var value = Environment.GetEnvironmentVariable(environmentVariable);
diff --git a/src/Framework/UninitializedPropertyReadEventArgs.cs b/src/Framework/UninitializedPropertyReadEventArgs.cs
index ef638c5e101..781c8c33bc8 100644
--- a/src/Framework/UninitializedPropertyReadEventArgs.cs
+++ b/src/Framework/UninitializedPropertyReadEventArgs.cs
@@ -2,6 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -42,5 +44,18 @@ public UninitializedPropertyReadEventArgs(
         /// The name of the uninitialized property that was read.
         /// </summary>
         public string PropertyName { get; set; }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            writer.WriteOptionalString(PropertyName);
+        }
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            PropertyName = reader.ReadOptionalString();
+        }
     }
 }
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 551114540e1..d151bc71199 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
+using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
@@ -167,13 +168,13 @@ public void DistributedFileLoggerSwitchIdentificationTests(string distributedfil
         [InlineData("terminallogger")]
         [InlineData("TerminalLogger")]
         [InlineData("TERMINALLOGGER")]
-        public void LiveLoggerSwitchIdentificationTests(string livelogger)
+        public void TerminalLoggerSwitchIdentificationTests(string terminallogger)
         {
             CommandLineSwitches.ParameterizedSwitch parameterlessSwitch;
             string duplicateSwitchErrorMessage;
 
-            CommandLineSwitches.IsParameterizedSwitch(livelogger, out parameterlessSwitch, out duplicateSwitchErrorMessage, out bool multipleParametersAllowed, out string missingParametersErrorMessage, out bool unquoteParameters, out bool emptyParametersAllowed).ShouldBeTrue();
-            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.LiveLogger);
+            CommandLineSwitches.IsParameterizedSwitch(terminallogger, out parameterlessSwitch, out duplicateSwitchErrorMessage, out bool multipleParametersAllowed, out string missingParametersErrorMessage, out bool unquoteParameters, out bool emptyParametersAllowed).ShouldBeTrue();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.TerminalLogger);
             duplicateSwitchErrorMessage.ShouldBeNull();
             multipleParametersAllowed.ShouldBeTrue();
             missingParametersErrorMessage.ShouldBeNull();
@@ -203,6 +204,28 @@ public void FileLoggerParametersIdentificationTests(string fileloggerparameters)
             unquoteParameters.ShouldBeTrue();
         }
 
+        [Theory]
+        [InlineData("tlp")]
+        [InlineData("TLP")]
+        [InlineData("terminalLoggerParameters")]
+        [InlineData("TERMINALLOGGERPARAMETERS")]
+        public void TerminalLoggerParametersIdentificationTests(string terminalLoggerParameters)
+        {
+            CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
+            string duplicateSwitchErrorMessage;
+            bool multipleParametersAllowed;
+            string missingParametersErrorMessage;
+            bool unquoteParameters;
+            bool emptyParametersAllowed;
+
+            CommandLineSwitches.IsParameterizedSwitch(terminalLoggerParameters, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.TerminalLoggerParameters);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldNotBeNull();
+            unquoteParameters.ShouldBeTrue();
+        }
+
 #if FEATURE_NODE_REUSE
         [Theory]
         [InlineData("nr")]
@@ -477,6 +500,60 @@ public void PreprocessSwitchIdentificationTests(string preprocess)
             unquoteParameters.ShouldBeTrue();
         }
 
+        [Fact]
+        public void GetPropertySwitchIdentificationTest()
+        {
+            CommandLineSwitches.IsParameterizedSwitch(
+                "getProperty",
+                out CommandLineSwitches.ParameterizedSwitch parameterizedSwitch,
+                out string duplicateSwitchErrorMessage,
+                out bool multipleParametersAllowed,
+                out string missingParametersErrorMessage,
+                out _,
+                out _);
+
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GetProperty);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldNotBeNullOrEmpty();
+        }
+
+        [Fact]
+        public void GetItemSwitchIdentificationTest()
+        {
+            CommandLineSwitches.IsParameterizedSwitch(
+                "getItem",
+                out CommandLineSwitches.ParameterizedSwitch parameterizedSwitch,
+                out string duplicateSwitchErrorMessage,
+                out bool multipleParametersAllowed,
+                out string missingParametersErrorMessage,
+                out _,
+                out _);
+
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GetItem);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldNotBeNullOrEmpty();
+        }
+
+        [Fact]
+        public void GetTargetResultSwitchIdentificationTest()
+        {
+            CommandLineSwitches.IsParameterizedSwitch(
+                "getTargetResult",
+                out CommandLineSwitches.ParameterizedSwitch parameterizedSwitch,
+                out string duplicateSwitchErrorMessage,
+                out bool multipleParametersAllowed,
+                out string missingParametersErrorMessage,
+                out _,
+                out _);
+
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GetTargetResult);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldNotBeNullOrEmpty();
+        }
+
         [Theory]
         [InlineData("targets")]
         [InlineData("tArGeTs")]
@@ -1020,6 +1097,7 @@ public void InvalidToolsVersionErrors()
                     filename = FileUtilities.GetTemporaryFileName();
                     ProjectRootElement project = ProjectRootElement.Create();
                     project.Save(filename);
+                    BuildResult buildResult = null;
                     MSBuildApp.BuildProject(
                                         filename,
                                         null,
@@ -1051,6 +1129,8 @@ public void InvalidToolsVersionErrors()
                                         question: false,
                                         inputResultsCaches: null,
                                         outputResultsCache: null,
+                                        saveProjectResult: false,
+                                        ref buildResult,
                                         commandLine: null);
                 }
                 finally
@@ -1369,6 +1449,26 @@ public void ProcessGraphBuildSwitch(string[] parameters, GraphBuildOptions expec
             }
         }
 
+        /// <summary>
+        /// Verifies that the /target switch is parsed properly with invalid characters.
+        /// </summary>
+        [Fact]
+        public void ProcessInvalidTargetSwitch()
+        {
+            string projectContent = """
+                <Project>
+                </Project>
+                """;
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            string project = testEnvironment.CreateTestProjectWithFiles("project.proj", projectContent).ProjectFile;
+
+#if FEATURE_GET_COMMANDLINE
+            MSBuildApp.Execute(@"msbuild.exe " + project + " /t:foo.bar").ShouldBe(MSBuildApp.ExitType.SwitchError);
+#else
+            MSBuildApp.Execute(new[] { @"msbuild.exe", project, "/t:foo.bar" }).ShouldBe(MSBuildApp.ExitType.SwitchError);
+#endif
+        }
+
         /// <summary>
         /// Verifies that when the /profileevaluation switch is used with invalid filenames an error is shown.
         /// </summary>
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index 87759cd7929..1f0489284ab 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -71,10 +71,12 @@ public class MSBuildServer_Tests : IDisposable
         <Message Text=""Server ID is $(PID)"" Importance=""High"" />
     </Target>
 </Project>";
-        private static string sleepingTaskContents = @$"
+        private static string sleepingTaskContentsFormat = @$"
 <Project>
 <UsingTask TaskName=""SleepingTask"" AssemblyFile=""{Assembly.GetExecutingAssembly().Location}"" />
     <Target Name='Sleep'>
+        <!-- create a marker file that represents the build is started. -->
+        <WriteLinesToFile File=""{{0}}"" />
         <SleepingTask SleepTime=""100000"" />
     </Target>
 </Project>";
@@ -106,22 +108,23 @@ public void MSBuildServerTest()
             pidOfServerProcess.ShouldBe(ParseNumber(output, "Server ID is "), "Node used by both the first and second build should be the same.");
 
             // Prep to kill the long-lived task we're about to start.
-            Task t = Task.Run(() =>
+            TransientTestFile markerFile = _env.ExpectFile();
+            string? dir = Path.GetDirectoryName(markerFile.Path);
+            using var watcher = new System.IO.FileSystemWatcher(dir!);
+            watcher.Created += (o, e) =>
             {
-                // Wait for the long-lived task to start
-                // If this test seems to fail randomly, increase this time.
-                Thread.Sleep(1000);
-
+                _output.WriteLine($"The marker file {markerFile.Path} was created. The build task has been started. Ready to kill the server.");
                 // Kill the server
                 Process.GetProcessById(pidOfServerProcess).KillTree(1000);
-            });
+                _output.WriteLine($"The old server was killed.");
+            };
+            watcher.Filter = Path.GetFileName(markerFile.Path);
+            watcher.EnableRaisingEvents = true;
 
             // Start long-lived task execution
-            TransientTestFile sleepProject = _env.CreateFile("napProject.proj", sleepingTaskContents);
+            TransientTestFile sleepProject = _env.CreateFile("napProject.proj", string.Format(sleepingTaskContentsFormat, markerFile.Path));
             RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, sleepProject.Path, out _);
 
-            t.Wait();
-
             // Ensure that a new build can still succeed and that its server node is different.
             output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out success, false, _output);
 
@@ -176,7 +179,9 @@ public void BuildsWhileBuildIsRunningOnServer()
         {
             _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
             TransientTestFile project = _env.CreateFile("testProject.proj", printPidContents);
-            TransientTestFile sleepProject = _env.CreateFile("napProject.proj", sleepingTaskContents);
+
+            TransientTestFile markerFile = _env.ExpectFile();
+            TransientTestFile sleepProject = _env.CreateFile("napProject.proj", string.Format(sleepingTaskContentsFormat, markerFile.Path));
 
             int pidOfServerProcess;
             Task t;
@@ -185,13 +190,25 @@ public void BuildsWhileBuildIsRunningOnServer()
             pidOfServerProcess = ParseNumber(output, "Server ID is ");
             _env.WithTransientProcess(pidOfServerProcess);
 
+            string? dir = Path.GetDirectoryName(markerFile.Path);
+            using var watcher = new System.IO.FileSystemWatcher(dir!);
+            ManualResetEvent mre = new ManualResetEvent(false);
+            watcher.Created += (o, e) =>
+            {
+                _output.WriteLine($"The marker file {markerFile.Path} was created. The build task has been started.");
+                mre.Set();
+            };
+            watcher.Filter = Path.GetFileName(markerFile.Path);
+            watcher.EnableRaisingEvents = true;
             t = Task.Run(() =>
             {
                 RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, sleepProject.Path, out _, false, _output);
             });
 
             // The server will soon be in use; make sure we don't try to use it before that happens.
-            Thread.Sleep(1000);
+            _output.WriteLine("Waiting for the server to be in use.");
+            mre.WaitOne();
+            _output.WriteLine("It's OK to go ahead.");
 
             Environment.SetEnvironmentVariable("MSBUILDUSESERVER", "0");
 
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
similarity index 94%
rename from src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.verified.txt
rename to src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
index 5420c4eab35..0777ef5cc91 100644
--- a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
@@ -2,4 +2,4 @@
   project [36;1mtfName[m Build (0.0s)
 [?25h[?25l[2F
   project [36;1mtf2[m Build (0.0s)[K
-[?25h
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
new file mode 100644
index 00000000000..d860724e3ab
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
@@ -0,0 +1,5 @@
+﻿[?25l[1F
+  project [36;1mtfName[m Build (0.0s)
+[?25h[?25l[2F
+  project [36;1mtf2[m Build (0.0s)[K
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
new file mode 100644
index 00000000000..0777ef5cc91
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
@@ -0,0 +1,5 @@
+﻿]9;4;3;\[?25l[1F
+  project [36;1mtfName[m Build (0.0s)
+[?25h[?25l[2F
+  project [36;1mtf2[m Build (0.0s)[K
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesShowsCurrent.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
similarity index 87%
rename from src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesShowsCurrent.verified.txt
rename to src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
index 0fb8b744327..d0cb5b914e0 100644
--- a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesShowsCurrent.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
@@ -1,3 +1,3 @@
 ﻿]9;4;3;\[?25l[1F
   project Build (0.0s)
-[?25h
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
new file mode 100644
index 00000000000..edce93c06c4
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
@@ -0,0 +1,3 @@
+﻿[?25l[1F
+  project Build (0.0s)
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
new file mode 100644
index 00000000000..d0cb5b914e0
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
@@ -0,0 +1,3 @@
+﻿]9;4;3;\[?25l[1F
+  project Build (0.0s)
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_Failed.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
similarity index 84%
rename from src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_Failed.verified.txt
rename to src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
index a761905358e..e397b179c6b 100644
--- a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_Failed.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
@@ -1,4 +1,4 @@
 ﻿]9;4;3;\[?25l[1F
 [?25h
 Build [31;1mfailed[m in 0.0s
-]9;4;0;\
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
new file mode 100644
index 00000000000..5dac0df45b6
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
@@ -0,0 +1,3 @@
+﻿[?25l[1F
+[?25h
+Build [31;1mfailed[m in 0.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
new file mode 100644
index 00000000000..e397b179c6b
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
@@ -0,0 +1,4 @@
+﻿]9;4;3;\[?25l[1F
+[?25h
+Build [31;1mfailed[m in 0.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_FailedWithErrors.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
similarity index 57%
rename from src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_FailedWithErrors.verified.txt
rename to src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
index 3657a549d75..0041a7257fe 100644
--- a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_FailedWithErrors.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
@@ -1,6 +1,6 @@
 ﻿]9;4;3;\  project [31;1mfailed with errors[m (0.0s)
-[31;1m    ❌︎[7D[6C MSBUILD : error : Error![m
+    directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
 Build [31;1mfailed with errors[m in 0.0s
-]9;4;0;\
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
new file mode 100644
index 00000000000..cf0d8f1d6c9
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
@@ -0,0 +1,5 @@
+﻿  project [31;1mfailed with errors[m (0.0s)
+    directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
+[?25l[1F
+[?25h
+Build [31;1mfailed with errors[m in 0.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
new file mode 100644
index 00000000000..0041a7257fe
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
@@ -0,0 +1,6 @@
+﻿]9;4;3;\  project [31;1mfailed with errors[m (0.0s)
+    directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
+[?25l[1F
+[?25h
+Build [31;1mfailed with errors[m in 0.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_SucceededWithWarnings.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
similarity index 58%
rename from src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_SucceededWithWarnings.verified.txt
rename to src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
index 405fa3a221f..86c02fdb8df 100644
--- a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_SucceededWithWarnings.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
@@ -1,6 +1,6 @@
 ﻿]9;4;3;\  project [33;1msucceeded with warnings[m (0.0s)
-[33;1m    ⚠︎[7D[6C MSBUILD : warning : Warning![m
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
 [?25l[1F
 [?25h
 Build [33;1msucceeded with warnings[m in 0.0s
-]9;4;0;\
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
new file mode 100644
index 00000000000..43510237153
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
@@ -0,0 +1,5 @@
+﻿  project [33;1msucceeded with warnings[m (0.0s)
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+[?25l[1F
+[?25h
+Build [33;1msucceeded with warnings[m in 0.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
new file mode 100644
index 00000000000..86c02fdb8df
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
@@ -0,0 +1,6 @@
+﻿]9;4;3;\  project [33;1msucceeded with warnings[m (0.0s)
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+[?25l[1F
+[?25h
+Build [33;1msucceeded with warnings[m in 0.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintsBuildSummary_Succeeded.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
similarity index 85%
rename from src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintsBuildSummary_Succeeded.verified.txt
rename to src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
index f62b3f5ddba..e6169b4e163 100644
--- a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintsBuildSummary_Succeeded.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
@@ -1,4 +1,4 @@
 ﻿]9;4;3;\[?25l[1F
 [?25h
 Build [32;1msucceeded[m in 0.0s
-]9;4;0;\
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
new file mode 100644
index 00000000000..de2ebf4c55e
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
@@ -0,0 +1,3 @@
+﻿[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 0.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
new file mode 100644
index 00000000000..e6169b4e163
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
@@ -0,0 +1,4 @@
+﻿]9;4;3;\[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 0.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/LiveLogger_Tests.cs b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
similarity index 63%
rename from src/MSBuild.UnitTests/LiveLogger_Tests.cs
rename to src/MSBuild.UnitTests/TerminalLogger_Tests.cs
index 1a359d69aad..ed9f0458fba 100644
--- a/src/MSBuild.UnitTests/LiveLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
@@ -6,23 +6,26 @@
 using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
+using System.Text;
 using System.Text.RegularExpressions;
 using System.Threading;
 using System.Threading.Tasks;
-
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Logging.LiveLogger;
-
+using Microsoft.Build.Logging;
+using Microsoft.Build.Logging.TerminalLogger;
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
 using VerifyTests;
 using VerifyXunit;
 using Xunit;
-
 using static VerifyXunit.Verifier;
 
 namespace Microsoft.Build.UnitTests
 {
     [UsesVerify]
-    public class LiveLogger_Tests : IEventSource, IDisposable
+    public class TerminalLogger_Tests : IEventSource, IDisposable
     {
         private const int _nodeCount = 8;
         private const string _eventSender = "Test";
@@ -31,7 +34,7 @@ public class LiveLogger_Tests : IEventSource, IDisposable
         private StringWriter _outputWriter = new();
 
         private readonly Terminal _mockTerminal;
-        private readonly LiveLogger _liveLogger;
+        private readonly TerminalLogger _terminallogger;
 
         private readonly DateTime _buildStartTime = new DateTime(2023, 3, 30, 16, 30, 0);
         private readonly DateTime _buildFinishTime = new DateTime(2023, 3, 30, 16, 30, 5);
@@ -40,12 +43,12 @@ public class LiveLogger_Tests : IEventSource, IDisposable
 
         private static Regex s_elapsedTime = new($@"\d+{Regex.Escape(CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator)}\ds", RegexOptions.Compiled);
 
-        public LiveLogger_Tests()
+        public TerminalLogger_Tests()
         {
             _mockTerminal = new Terminal(_outputWriter);
-            _liveLogger = new LiveLogger(_mockTerminal);
+            _terminallogger = new TerminalLogger(_mockTerminal);
 
-            _liveLogger.Initialize(this, _nodeCount);
+            _terminallogger.Initialize(this, _nodeCount);
 
             UseProjectRelativeDirectory("Snapshots");
 
@@ -98,7 +101,7 @@ public LiveLogger_Tests()
 
         public void Dispose()
         {
-            _liveLogger.Shutdown();
+            _terminallogger.Shutdown();
         }
 
         #endregion
@@ -170,7 +173,7 @@ private TaskFinishedEventArgs MakeTaskFinishedEventArgs(string projectFile, stri
 
         private BuildWarningEventArgs MakeWarningEventArgs(string warning)
         {
-            return new BuildWarningEventArgs("", "", "", 0, 0, 0, 0, warning, null, null)
+            return new BuildWarningEventArgs("", "AA0000", "directory/file", 1, 2, 3, 4, warning, null, null)
             {
                 BuildEventContext = MakeBuildEventContext(),
             };
@@ -178,7 +181,7 @@ private BuildWarningEventArgs MakeWarningEventArgs(string warning)
 
         private BuildErrorEventArgs MakeErrorEventArgs(string error)
         {
-            return new BuildErrorEventArgs("", "", "", 0, 0, 0, 0, error, null, null)
+            return new BuildErrorEventArgs("", "AA0000", "directory/file", 1, 2, 3, 4, error, null, null)
             {
                 BuildEventContext = MakeBuildEventContext(),
             };
@@ -212,7 +215,7 @@ public Task PrintsBuildSummary_Succeeded()
         {
             InvokeLoggerCallbacksForSimpleProject(succeeded: true, () => { });
 
-            return Verify(_outputWriter.ToString(), _settings);
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
         }
 
         [Fact]
@@ -223,25 +226,25 @@ public Task PrintBuildSummary_SucceededWithWarnings()
                 WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("Warning!"));
             });
 
-            return Verify(_outputWriter.ToString(), _settings);
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
         }
 
         [Fact]
         public Task PrintBuildSummary_Failed()
         {
             InvokeLoggerCallbacksForSimpleProject(succeeded: false, () => { });
-            return Verify(_outputWriter.ToString(), _settings);
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
         }
 
         [Fact]
         public Task PrintBuildSummary_FailedWithErrors()
         {
-           InvokeLoggerCallbacksForSimpleProject(succeeded: false, () =>
-           {
-               ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Error!"));
-           });
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, () =>
+            {
+                ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Error!"));
+            });
 
-           return Verify(_outputWriter.ToString(), _settings);
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
         }
 
         #endregion
@@ -251,9 +254,9 @@ public void DisplayNodesShowsCurrent()
         {
             InvokeLoggerCallbacksForSimpleProject(succeeded: false, async () =>
             {
-                _liveLogger.DisplayNodes();
+                _terminallogger.DisplayNodes();
 
-                await Verify(_outputWriter.ToString(), _settings);
+                await Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
             });
         }
 
@@ -270,7 +273,7 @@ public async Task DisplayNodesOverwritesWithNewTargetFramework()
             TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
             TaskStarted?.Invoke(_eventSender, MakeTaskStartedEventArgs(_projectFile, "Task"));
 
-            _liveLogger.DisplayNodes();
+            _terminallogger.DisplayNodes();
 
             // This is a bit fast and loose with the events that would be fired
             // in a real "stop building that TF for the project and start building
@@ -281,9 +284,72 @@ public async Task DisplayNodesOverwritesWithNewTargetFramework()
             ProjectStarted?.Invoke(_eventSender, pse2);
             TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
 
-            _liveLogger.DisplayNodes();
+            _terminallogger.DisplayNodes();
 
-            await Verify(_outputWriter.ToString(), _settings);
+            await Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
+
+        [Fact]
+        public void TestTerminalLoggerTogetherWithOtherLoggers()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            { 
+                string contents = @"
+<Project>
+    <ItemGroup>
+        <Compile Include=""MyItem1.cs"" />
+        <Compile Include=""MyItem2.cs"" />
+    </ItemGroup>
+    <PropertyGroup>
+        <MyProp1>MyProperty1</MyProp1>
+    </PropertyGroup>
+    <Target Name = ""Build"">
+        <Message Text = ""Build target is executing."" Importance = ""High"" />
+    </Target>
+</Project>";
+                TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
+                TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
+
+                BinaryLogger loggerWithTL = new();
+                string logFileWithTL = env.ExpectFile(".binlog").Path;
+                loggerWithTL.Parameters = logFileWithTL;
+
+                BinaryLogger loggerWithoutTL = new();
+                string logFileWithoutTL = env.ExpectFile(".binlog").Path;
+                loggerWithoutTL.Parameters = logFileWithoutTL;
+
+                // Execute MSBuild with binary, file and terminal loggers
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} /m /bl:{logFileWithTL} -flp:logfile={Path.Combine(logFolder.Path, "logFileWithTL.log")};verbosity=diagnostic -tl:on", out bool success);
+                success.ShouldBeTrue();
+
+                // Execute MSBuild with binary and file loggers
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} /m /bl:{logFileWithoutTL} -flp:logfile={Path.Combine(logFolder.Path, "logFileWithoutTL.log")};verbosity=diagnostic", out success);
+                success.ShouldBeTrue();
+
+                // Read the binary log and replay into mockLogger
+                var mockLogFromPlaybackWithTL = new MockLogger();
+                var binaryLogReaderWithTL = new BinaryLogReplayEventSource();
+                mockLogFromPlaybackWithTL.Initialize(binaryLogReaderWithTL);
+
+                var mockLogFromPlaybackWithoutTL = new MockLogger();
+                var binaryLogReaderWithoutTL = new BinaryLogReplayEventSource();
+                mockLogFromPlaybackWithoutTL.Initialize(binaryLogReaderWithoutTL);
+
+                binaryLogReaderWithTL.Replay(logFileWithTL);
+                binaryLogReaderWithoutTL.Replay(logFileWithoutTL);
+
+                // Check that amount of events, warnings, errors is equal in both cases. Presence of other loggers should not change behavior
+                mockLogFromPlaybackWithoutTL.Errors.Count.ShouldBe(mockLogFromPlaybackWithTL.Errors.Count);
+                mockLogFromPlaybackWithoutTL.Warnings.Count.ShouldBe(mockLogFromPlaybackWithTL.Warnings.Count);
+                mockLogFromPlaybackWithoutTL.AllBuildEvents.Count.ShouldBe(mockLogFromPlaybackWithTL.AllBuildEvents.Count);
+
+                // Check presence of some items and properties and that they have at least 1 item and property
+                mockLogFromPlaybackWithoutTL.EvaluationFinishedEvents.ShouldContain(x => (x.Items != null) && x.Items.GetEnumerator().MoveNext());
+                mockLogFromPlaybackWithTL.EvaluationFinishedEvents.ShouldContain(x => (x.Items != null) && x.Items.GetEnumerator().MoveNext());
+
+                mockLogFromPlaybackWithoutTL.EvaluationFinishedEvents.ShouldContain(x => (x.Properties != null) && x.Properties.GetEnumerator().MoveNext());
+                mockLogFromPlaybackWithTL.EvaluationFinishedEvents.ShouldContain(x => (x.Properties != null) && x.Properties.GetEnumerator().MoveNext());
+            }
         }
     }
 }
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index dd838ef172f..d9654d4e38c 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -566,6 +566,7 @@ public void InvalidVerbosity()
                 MSBuildApp.ProcessVerbositySwitch("loquacious");
             });
         }
+
         [Fact]
         public void ValidMaxCPUCountSwitch()
         {
@@ -617,6 +618,78 @@ public void InvalidMaxCPUCountSwitch4()
             });
         }
 
+        [Theory]
+        [InlineData("-getProperty:Foo;Bar", true, "EvalValue", false, false, false, true)]
+        [InlineData("-getProperty:Foo;Bar -t:Build", true, "TargetValue", false, false, false, true)]
+        [InlineData("-getItem:MyItem", false, "", true, false, false, true)]
+        [InlineData("-getItem:MyItem -t:Build", false, "", true, true, false, true)]
+        [InlineData("-getItem:WrongItem -t:Build", false, "", false, false, false, true)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem -t:Build", true, "TargetValue", true, true, false, true)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem", true, "EvalValue", true, false, false, true)]
+        [InlineData("-getProperty:Foo;Bar -getTargetResult:MyTarget", true, "TargetValue", false, false, true, true)]
+        [InlineData("-getProperty:Foo;Bar", true, "EvalValue", false, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -t:Build", true, "TargetValue", false, false, false, false)]
+        [InlineData("-getItem:MyItem", false, "", true, false, false, false)]
+        [InlineData("-getItem:MyItem -t:Build", false, "", true, true, false, false)]
+        [InlineData("-getItem:WrongItem -t:Build", false, "", false, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem -t:Build", true, "TargetValue", true, true, false, false)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem", true, "EvalValue", true, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -getTargetResult:MyTarget", true, "TargetValue", false, false, true, false)]
+        public void ExecuteAppWithGetPropertyItemAndTargetResult(
+            string extraSwitch,
+            bool fooPresent,
+            string fooResult,
+            bool itemIncludesAlwaysThere,
+            bool itemIncludesTargetItem,
+            bool targetResultPresent,
+            bool isGraphBuild)
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile project = env.CreateFile("testProject.csproj", @"
+<Project>
+
+  <PropertyGroup>
+    <Foo>EvalValue</Foo>
+    <Baz>InnocuousValue</Baz>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <MyItem Include=""itemAlwaysThere"" Metadatum=""metadatumValue"" />
+  </ItemGroup>
+
+  <Target Name=""MyTarget"" BeforeTargets=""Build"">
+    <PropertyGroup>
+      <Foo>TargetValue</Foo>
+    </PropertyGroup>
+    <ItemGroup>
+      <MyItem Include=""targetItem"" Metadato=""OtherMetadatum"" />
+    </ItemGroup>
+  </Target>
+
+  <Target Name=""Build"">
+
+  </Target>
+
+</Project>
+");
+            string graph = isGraphBuild ? "--graph" : "";
+            string results = RunnerUtilities.ExecMSBuild($" {project.Path} {extraSwitch} {graph}", out bool success);
+            success.ShouldBeTrue();
+            if (fooPresent)
+            {
+                results.ShouldContain($"\"Foo\": \"{fooResult}\"");
+                results.ShouldContain("\"Bar\": \"\"");
+            }
+
+            results.ShouldNotContain("InnocuousValue");
+
+            results.Contains("itemAlwaysThere").ShouldBe(itemIncludesAlwaysThere);
+            results.Contains("targetItem").ShouldBe(itemIncludesTargetItem);
+
+            results.Contains("MyTarget").ShouldBe(targetResultPresent);
+            results.Contains("\"Result\": \"Success\"").ShouldBe(targetResultPresent);
+        }
+
         /// <summary>
         /// Regression test for bug where the MSBuild.exe command-line app
         /// would sometimes set the UI culture to just "en" which is considered a "neutral" UI
diff --git a/src/MSBuild/CommandLineSwitchException.cs b/src/MSBuild/CommandLineSwitchException.cs
index 50cca72257a..364fce6da5d 100644
--- a/src/MSBuild/CommandLineSwitchException.cs
+++ b/src/MSBuild/CommandLineSwitchException.cs
@@ -46,6 +46,9 @@ private CommandLineSwitchException(
         /// <summary>
         /// Serialization constructor
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private CommandLineSwitchException(
             SerializationInfo info,
             StreamingContext context) :
@@ -94,6 +97,9 @@ internal string CommandLineArg
         /// </summary>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 5b2f7e67fb4..d5d2b08a104 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -89,7 +89,8 @@ internal enum ParameterizedSwitch
             FileLoggerParameters7,
             FileLoggerParameters8,
             FileLoggerParameters9,
-            LiveLogger,
+            TerminalLogger,
+            TerminalLoggerParameters,
             NodeReuse,
             Preprocess,
             Targets,
@@ -108,6 +109,9 @@ internal enum ParameterizedSwitch
             LowPriority,
             Question,
             DetailedSummary,
+            GetProperty,
+            GetItem,
+            GetTargetResult,
             NumberOfParameterizedSwitches,
         }
 
@@ -246,7 +250,9 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters7", "flp7" },     ParameterizedSwitch.FileLoggerParameters7,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters8", "flp8" },     ParameterizedSwitch.FileLoggerParameters8,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters9", "flp9" },     ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "livelogger", "ll", "terminallogger", "tl" }, ParameterizedSwitch.LiveLogger,          null,                           true,          null,                                  true,   true),
+            // To not break existing use, keep supporting live logger switches
+            new ParameterizedSwitchInfo(  new string[] { "livelogger", "ll", "terminallogger", "tl" }, ParameterizedSwitch.TerminalLogger,      null,                           true,           null,                                  true,   true),
+            new ParameterizedSwitchInfo(  new string[] { "terminalloggerparameters", "tlp" },   ParameterizedSwitch.TerminalLoggerParameters,   null,                           false,          "MissingTerminalLoggerParameterError", true,   false),
             new ParameterizedSwitchInfo(  new string[] { "nodereuse", "nr" },                   ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false),
             new ParameterizedSwitchInfo(  new string[] { "preprocess", "pp" },                  ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "targets", "ts" },                     ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false),
@@ -265,6 +271,9 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getProperty" },                       ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getItem" },                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",             true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getTargetResult" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",             true,   false),
         };
 
         /// <summary>
diff --git a/src/MSBuild/InitializationException.cs b/src/MSBuild/InitializationException.cs
index ff5a5e21ade..fea748158ae 100644
--- a/src/MSBuild/InitializationException.cs
+++ b/src/MSBuild/InitializationException.cs
@@ -51,6 +51,9 @@ private InitializationException(
         /// <summary>
         /// Serialization constructor
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private InitializationException(
             SerializationInfo info,
             StreamingContext context) :
@@ -87,6 +90,9 @@ public override string Message
         /// </summary>
 #if FEATURE_SECURITY_PERMISSIONS
         [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
+#endif
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
 #endif
         public override void GetObjectData(SerializationInfo info, StreamingContext context)
         {
diff --git a/src/MSBuild/JsonOutputFormatter.cs b/src/MSBuild/JsonOutputFormatter.cs
new file mode 100644
index 00000000000..095f0761386
--- /dev/null
+++ b/src/MSBuild/JsonOutputFormatter.cs
@@ -0,0 +1,163 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Text.Json;
+using System.Text.Json.Nodes;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.CommandLine
+{
+    /// <summary>
+    /// This class is intended to take in names of properties, items, and/or target results and some means of computing
+    /// those data, then format them in a json object and provide a convenient means to stringify them.
+    /// </summary>
+    internal sealed class JsonOutputFormatter
+    {
+        private static readonly JsonSerializerOptions s_options = new() { AllowTrailingCommas = false, WriteIndented = true };
+        private readonly JsonNode _topLevelNode = new JsonObject();
+
+        public override string ToString()
+        {
+            return _topLevelNode.ToJsonString(s_options);
+        }
+
+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)
+        {
+            if (propertyNames.Length == 0)
+            {
+                return;
+            }
+
+            ErrorUtilities.VerifyThrow(_topLevelNode["Properties"] is null, "Should not add multiple lists of properties to the json format.");
+
+            JsonNode propertiesNode = new JsonObject();
+            foreach (string property in propertyNames)
+            {
+                propertiesNode[property] = getProperty(property);
+            }
+
+            _topLevelNode["Properties"] = propertiesNode;
+        }
+
+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)
+        {
+            if (itemNames.Length == 0)
+            {
+                return;
+            }
+
+            ErrorUtilities.VerifyThrow(_topLevelNode["Items"] is null, "Should not add multiple lists of items to the json format.");
+
+            JsonNode itemsNode = new JsonObject();
+            foreach (string itemName in itemNames)
+            {
+                JsonArray itemArray = new();
+                foreach (ProjectItemInstance item in project.GetItems(itemName))
+                {
+                    JsonObject jsonItem = new();
+                    jsonItem["Identity"] = item.GetMetadataValue("Identity");
+                    foreach (string metadatumName in item.MetadataNames)
+                    {
+                        if (metadatumName.Equals("Identity"))
+                        {
+                            continue;
+                        }
+
+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);
+                    }
+
+                    itemArray.Add(jsonItem);
+                }
+
+                itemsNode[itemName] = itemArray;
+            }
+
+            _topLevelNode["Items"] = itemsNode;
+        }
+
+        internal void AddItemsInJsonFormat(string[] itemNames, Project project)
+        {
+            if (itemNames.Length == 0)
+            {
+                return;
+            }
+
+            ErrorUtilities.VerifyThrow(_topLevelNode["Items"] is null, "Should not add multiple lists of items to the json format.");
+
+            JsonObject itemsNode = new();
+            foreach (string itemName in itemNames)
+            {
+                JsonArray itemArray = new();
+                foreach (ProjectItem item in project.GetItems(itemName))
+                {
+                    JsonObject jsonItem = new();
+                    jsonItem["Identity"] = item.GetMetadataValue("Identity");
+                    foreach (ProjectMetadata metadatum in item.Metadata)
+                    {
+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;
+                    }
+
+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)
+                    {
+                        if (metadatumName.Equals("Identity"))
+                        {
+                            continue;
+                        }
+
+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);
+                    }
+
+                    itemArray.Add(jsonItem);
+                }
+
+                itemsNode[itemName] = itemArray;
+            }
+
+            _topLevelNode["Items"] = itemsNode;
+        }
+
+        internal void AddTargetResultsInJsonFormat(string[] targetNames, BuildResult result)
+        {
+            if (targetNames.Length == 0)
+            {
+                return;
+            }
+
+            ErrorUtilities.VerifyThrow(_topLevelNode["TargetResults"] is null, "Should not add multiple lists of target results to the json format.");
+
+            JsonObject targetResultsNode = new();
+            foreach (string targetName in targetNames)
+            {
+                TargetResult targetResult = result.ResultsByTarget[targetName];
+                JsonObject targetResults = new();
+                targetResults["Result"] = targetResult.ResultCode.ToString();
+                JsonArray outputArray = new();
+                foreach (ITaskItem item in targetResult.Items)
+                {
+                    JsonObject jsonItem = new();
+                    jsonItem["Identity"] = item.GetMetadata("Identity");
+                    foreach (string metadatumName in item.MetadataNames)
+                    {
+                        if (metadatumName.Equals("Identity"))
+                        {
+                            continue;
+                        }
+
+                        jsonItem[metadatumName] = item.GetMetadata(metadatumName);
+                    }
+
+                    outputArray.Add(jsonItem);
+                }
+
+                targetResults["Items"] = outputArray;
+                targetResultsNode[targetName] = targetResults;
+            }
+
+            _topLevelNode["TargetResults"] = targetResultsNode;
+        }
+    }
+}
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 219437cdacf..3ca22b8e510 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -103,6 +103,9 @@
     <Compile Include="..\Shared\Modifiers.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\XMakeElements.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs" />
     <Compile Include="..\Shared\IKeyed.cs" />
@@ -172,7 +175,7 @@
     <Compile Include="DistributedLoggerRecord.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="LiveLogger\*.cs" />
+    <Compile Include="TerminalLogger\*.cs" />
     <Compile Include="InitializationException.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -186,6 +189,7 @@
     <Compile Include="OutOfProcTaskAppDomainWrapperBase.cs" />
     <Compile Include="OutOfProcTaskAppDomainWrapper.cs" />
     <Compile Include="PerformanceLogEventListener.cs" />
+    <Compile Include="JsonOutputFormatter.cs" />
     <Compile Include="XMake.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -244,7 +248,7 @@
 
   <!-- Xsds are not TF or arch-specific so copy once them in the outer build -->
   <Target Name="CopyXsds" BeforeTargets="Build" Condition="'$(IsInnerBuild)' != 'true'">
-    <Copy SourceFiles="@(XsdsForVS)" DestinationFiles="@(XsdsForVS-&gt;'$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'xsd'))%(RecursiveDir)%(Filename)%(Extension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" />
+    <Copy SourceFiles="@(XsdsForVS)" DestinationFiles="@(XsdsForVS-&gt;'$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'xsd'))%(RecursiveDir)%(Filename)%(Extension)')" SkipUnchangedFiles="true" />
   </Target>
 
   <!-- Include MSBuild.deps.json and MSBuild.runtimeconfig.json in ContentWithTargetPath so they will be copied to the output folder of projects
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index f1f7c3b7ffe..1a0c3871a2d 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -1146,7 +1146,11 @@ private void SendBuildEvent(BuildEventArgs e)
         {
             if (_nodeEndpoint?.LinkStatus == LinkStatus.Active)
             {
-                if (!e.GetType().GetTypeInfo().IsSerializable)
+#pragma warning disable SYSLIB0050
+                // Types which are not serializable and are not IExtendedBuildEventArgs as
+                // those always implement custom serialization by WriteToStream and CreateFromStream.
+                if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)
+#pragma warning disable SYSLIB0050
                 {
                     // log a warning and bail.  This will end up re-calling SendBuildEvent, but we know for a fact
                     // that the warning that we constructed is serializable, so everything should be good.
@@ -1154,7 +1158,8 @@ private void SendBuildEvent(BuildEventArgs e)
                     return;
                 }
 
-                _nodeEndpoint.SendData(new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(_currentConfiguration.NodeId, e)));
+                LogMessagePacket logMessage = new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(_currentConfiguration.NodeId, e));
+                _nodeEndpoint.SendData(logMessage);
             }
         }
 
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 94b963cb2ec..328cb2dcdd4 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1033,6 +1033,37 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
+  <data name="MissingGetPropertyError" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
+  <data name="MissingGetItemError" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
+  <data name="MissingGetTargetResultError" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
+  <data name="SolutionBuildInvalidForCommandLineEvaluation" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <data name="MissingToolsVersionError" UESanitized="false" Visibility="Public">
     <value>MSBUILD : error MSB1039: Specify the version of the toolset.</value>
     <comment>
@@ -1167,6 +1198,15 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
+  <data name="MissingTerminalLoggerParameterError" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <data name="MissingNodeReuseParameterError" UESanitized="true" Visibility="Public">
     <value>MSBUILD : error MSB1041: Specify one or more parameters for node reuse if using the -nodeReuse switch</value>
     <comment>{StrBegin="MSBUILD : error MSB1041: "}
@@ -1244,6 +1284,15 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
+  <data name="InvalidTerminalLoggerValue" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <data name="AbortingBuild" UESanitized="true" Visibility="Public">
     <value>Attempting to cancel the build...</value>
   </data>
@@ -1379,7 +1428,13 @@
   <data name="UnsupportedSwitchForSolutionFiles" Visibility="Public">
     <value>The '{0}' switch is not supported for solution files.</value>
   </data>
-  <!-- **** LiveLogger strings begin **** -->
+  <data name="NameInvalid" Visibility="Public">
+    <value>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB5016: "}
+    </comment>
+  </data>
+  <!-- **** TerminalLogger strings begin **** -->
   <data name="RestoreComplete" xml:space="preserve">
     <value>Restore complete ({0}s)</value>
     <comment>
@@ -1405,31 +1460,31 @@
   <data name="BuildResult_FailedWithErrors" xml:space="preserve">
     <value>failed with errors</value>
     <comment>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </comment>
   </data>
   <data name="BuildResult_FailedWithWarnings" xml:space="preserve">
     <value>failed with warnings</value>
     <comment>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </comment>
   </data>
   <data name="BuildResult_Failed" xml:space="preserve">
     <value>failed</value>
     <comment>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </comment>
   </data>
   <data name="BuildResult_Succeeded" xml:space="preserve">
     <value>succeeded</value>
     <comment>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </comment>
   </data>
   <data name="BuildResult_SucceededWithWarnings" xml:space="preserve">
     <value>succeeded with warnings</value>
     <comment>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </comment>
   </data>
   <data name="ProjectFinished_NoTF" xml:space="preserve">
@@ -1481,12 +1536,23 @@
       {4}: duration in seconds with 1 decimal point
     </comment>
   </data>
-  <!-- **** LiveLogger strings end **** -->
-
+  <data name="BuildFailedWithPropertiesItemsOrTargetResultsRequested" xml:space="preserve">
+    <value>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</value>
+  </data>
+  <data name="TerminalLoggerNotUsedDisabled" xml:space="preserve">
+    <value>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</value>
+  </data>
+  <data name="TerminalLoggerNotUsedNotSupported" xml:space="preserve">
+    <value>Terminal Logger was not used because the output is not supported.</value>
+  </data>
+  <data name="TerminalLoggerNotUsedRedirected" xml:space="preserve">
+    <value>Terminal Logger was not used because the output is being redirected to a file.</value>
+  </data>
+  <!-- **** TerminalLogger strings end **** -->
     <!--
         The command line message bucket is: MSB1001 - MSB1999
 
-        Next error code should be MSB1065.
+        Next error code should be MSB1067.
 
         Don't forget to update this comment after using the new code.
   -->
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 696651c235e..f2b85eea526 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Sestavení {0} za {1}s</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">neúspěšné</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">selhalo s chybami</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">selhalo s upozorněními</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">úspěšné</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">úspěšně dokončeno s upozorněními</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -102,6 +107,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: Hodnota terminálového protokolovacího nástroje není platná. Mělo by to být auto, true nebo false. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -525,17 +540,20 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;logger&gt;   Použít daný protokolovací nástroj k protokolování událostí nástroje MSBuild. Pokud chcete zadat 
-                     více protokolovacích nástrojů, musíte je zadat jednotlivě.
-                     Syntaxe hodnoty &lt;logger&gt; je:
-                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
-                     Syntaxe hodnoty &lt;logger class&gt; je:
-                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
-                     Syntaxe hodnoty &lt;logger assembly&gt; je:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+        <target state="translated">  -logger:&lt;protok_nást&gt;   Použít daný protokolovací nástroj k protokolování
+                     událostí nástroje MSBuild. Chcete-li zadat více protokolovacích.
+                     nástrojů, musíte je zadat jednotlivě.
+                     Syntaxe hodnoty &lt;protok_nást&gt;:
+                        [&lt;třída_protok_nást&gt;,]&lt;sestavení_protok_nást&gt;
+                        [;&lt;param_protok_nást&gt;]
+                     Syntaxe hodnoty &lt;třída_protok_nást&gt;:
+                        [&lt;část/úpl_obor_názvů&gt;.]&lt;náz_tř_protok_nást&gt;
+                     Syntaxe hodnoty &lt;sestavení_protok_nást&gt;:
+                        {&lt;název_sestavení&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavení&gt;}
                      Parametry protokolovacího nástroje určují, jak MSBuild vytvoří protokolovací nástroj.
-                     Parametry &lt;logger parameters&gt; jsou volitelné a předávají se
-                     protokolovacímu nástroji přesně v tom tvaru, v jakém byly zadány. (Krátký tvar: -l)
+                     Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se 
+                     protokolovacímu nástroji přesně v tom tvaru, v jakém
+                     byly zadány. (Krátký tvar: -l)
                      Příklady:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
@@ -804,20 +822,23 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
-        <target state="translated">  -distributedLogger:&lt;central logger&gt;*&lt;forwarding logger&gt;
-                     Použít zadaný protokolovací nástroj pro protokolování událostí z nástroje MSBuild; ke každému uzlu připojit
-                     jinou instanci protokolovacího nástroje. Pokud chcete zadat více
-                     protokolovacích nástrojů, uveďte je jednotlivě.
+        <target state="translated">  -distributedlogger:&lt;centr_protok_nást&gt;*&lt;předáv_protok_nást&gt;                     
+                     Použít zadaný protokolovací nástroj pro protokolování událostí
+                     z nástroje MSBuild; ke každému uzlu připojit jinou instanci 
+                     protokolovacího nástroje. Chcete-li zadat více 
+                     protokolovacích nástrojů, uveďte je jednotlivě. 
                      (Krátký tvar: -dl)
-                     Syntaxe hodnoty &lt;logger&gt; je:
-                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
-                     Syntaxe hodnoty &lt;logger class&gt; je:
-                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
-                     Syntaxe hodnoty &lt;logger assembly&gt; je:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     Syntaxe hodnoty &lt;protok_nást&gt;:
+                        [&lt;třída_protok_nást&gt;,]&lt;sestav_protok_nást&gt;
+                        [;&lt;param_protok_nást&gt;]
+                     Syntaxe hodnoty &lt;třída_protok_nást&gt;:
+                        [&lt;část/úpl_obor_názvů&gt;.]&lt;náz_tř_protok_nást&gt;
+                     Syntaxe hodnoty &lt;sestav_protok_nást&gt;:
+                        {&lt;název_sestavení&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavení&gt;}
                      Parametry protokolovacího nástroje určují, jak MSBuild vytvoří protokolovací nástroj.
                      Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se
-                     protokolovacímu nástroji přesně v zadaném tvaru. (Krátký tvar: -l)
+                     protokolovacímu nástroji přesně v zadaném tvaru.
+                     (Krátký tvar: -l)
                      Příklady:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
@@ -1005,7 +1026,7 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                                              Verbosity=diagnostic;Encoding=UTF-8
 
                        -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1278,6 +1299,33 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <target state="translated">Protokoly MSBuild a informace o ladění budou dostupné v „{0}“</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Zadejte protokolovací nástroj.</target>
@@ -1329,6 +1377,16 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: Pokud používáte přepínač -terminalLoggerParameters, zadejte jeden nebo více parametrů pro terminálový protokolovací nástroj.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1365,6 +1423,13 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: Název {0} obsahuje neplatný znak {1}.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1538,6 +1603,14 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1553,6 +1626,21 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <target state="translated">MSBUILD : error MSB1059: Cíle se nepovedlo vypsat. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Terminálový protokolovač se nepoužil, protože sestavení se spouští v kontextu procesu (např. dotnet test), který požaduje přímý přístup k datovému proudu stdout.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Terminálový protokolovač se nepoužil, protože výstup se nepodporuje.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Terminálový protokolovač se nepoužil, protože výstup se přesměrovává do souboru.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Pro tento přepínač se nepoužívají žádné parametry.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 4890de22d59..f29f73bd6ed 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Erstellen von {0} in {1}s</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">Fehlgeschlagen</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">Fehlgeschlagen mit Fehlern</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">Fehlgeschlagen mit Warnungen</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">Erfolgreich</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">Erfolgreich mit Warnungen</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -101,6 +106,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: Der Terminalprotokollierungswert ist ungültig. Es sollte "auto", "true" oder "false" sein. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1271,6 +1286,33 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <target state="translated">MSBuild-Protokolle und Debuginformationen befinden sich auf "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Geben Sie eine Protokollierung an.</target>
@@ -1322,6 +1364,16 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: Geben Sie mindestens einen Parameter für die Terminalprotokollierung an, wenn Sie den Schalter "-terminalLoggerParameters" verwenden.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1358,6 +1410,13 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: Der Name "{0}" enthält ein ungültiges Zeichen "{1}".</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1531,6 +1590,14 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1546,6 +1613,21 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <target state="translated">MSBUILD : error MSB1059: Ziele konnten nicht ausgegeben werden. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Die Terminalprotokollierung wurde nicht verwendet, da der Build im Kontext eines Prozesses (z. B. "dotnet test") ausgeführt wird, der direkten Zugriff auf den stdout-Stream anfordert.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Die Terminalprotokollierung wurde nicht verwendet, da die Ausgabe nicht unterstützt wird.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Die Terminalprotokollierung wurde nicht verwendet, da die Ausgabe an eine Datei umgeleitet wird.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Der Schalter erlaubt keine Parameter.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index c97e3a646ee..65032455f70 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Compilación {0} en {1}s</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">erróneo</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">error con errores</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">error con advertencias</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">realizado correctamente</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">correcto con advertencias</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -101,6 +106,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: El valor del registrador de terminales no es válido. Debe ser uno de "auto", "true", o "false".{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1278,6 +1293,33 @@
         <target state="translated">Los registros de MSBuild y la información de depuración estarán en "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Especifique un registrador.</target>
@@ -1329,6 +1371,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: Especifique uno o más parámetros para el registrador de terminales si utiliza la opción -terminalLoggerParameters</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1365,6 +1417,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: El nombre "{0}" contiene un carácter no válido "{1}".</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1538,6 +1597,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1553,6 +1620,21 @@
         <target state="translated">MSBUILD : error MSB1059: No se pudieron imprimir los destinos. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">No se usó el terminal de Logger porque la compilación se ejecuta en el contexto de un proceso (por ejemplo, "dotnet test") que solicita acceso directo a la secuencia stdout.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">No se usó el terminal de Logger porque no se admite la salida.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">No se usó el terminal de Logger porque la salida se está redirigiendo a un archivo.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Este modificador no tiene ningún parámetro.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index d477903f11c..80312d77ab5 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Générer {0} dans {1}s</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">échec</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">a échoué avec des erreurs</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">a échoué avec des avertissements</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">a réussi</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">a réussi avec des avertissements</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -101,6 +106,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: La valeur du journal du terminal n’est pas valide. Il doit s’agir de 'auto', 'true' ou 'false'. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1271,6 +1286,33 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <target state="translated">Les journaux MSBuild et les informations de débogage seront au "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Spécifiez un journal.</target>
@@ -1322,6 +1364,16 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: spécifiez un ou plusieurs paramètres pour l’enregistreur d’événements de terminal si vous utilisez le commutateur -terminalLoggerParameters</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1358,6 +1410,13 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: le nom «{0}» contient un caractère non valide «{1}».</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1531,6 +1590,14 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1546,6 +1613,21 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <target state="translated">MSBUILD : error MSB1059: les cibles n'ont pas pu être imprimées. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">L’enregistreur d’événements de terminal n’a pas été utilisé, car la build est exécutée dans le contexte d’un processus (par exemple, 'dotnet test') qui demande un accès direct au flux stdout.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">L’enregistreur d’événements de terminal n’a pas été utilisé, car la sortie n’est pas prise en charge.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">L’enregistreur d’événements du terminal n’a pas été utilisé car la sortie est redirigée vers un fichier.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Ce commutateur n'accepte aucun paramètre.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index c73aa55fa05..9a391602b01 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Compilazione {0} in {1}s</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">non riuscito</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">non riuscito con errori</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">non riuscito con avvisi</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">operazione riuscita</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">completato con avvisi</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -101,6 +106,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: il valore del logger del terminale non è valido. Deve essere 'auto', 'true' o 'false'. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -935,8 +950,9 @@ Nota: livello di dettaglio dei logger di file
                      è la directory corrente. Per impostazione predefinita, ai
                      file viene assegnato il nome "MSBuild&lt;idnodo&gt;.log". Il
                      percorso dei file e altri parametri di fileLogger possono
-                     essere specificati aggiungendo l'opzione "-fileLoggerParameters".
+                     essere specificati aggiungendo l'opzione
 
+                     "-fileLoggerParameters".
                      Se il nome di un file di log viene impostato con l'opzione
                      fileLoggerParameters, il logger distribuito userà il nome
                      file come modello e aggiungerà l'ID del nodo per creare un
@@ -1281,6 +1297,33 @@ Nota: livello di dettaglio dei logger di file
         <target state="translated">I log e le informazioni di debug di MSBuild sono contenuti in "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: specificare un logger.</target>
@@ -1332,6 +1375,16 @@ Nota: livello di dettaglio dei logger di file
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: specificare uno o più parametri per il logger del terminale se si usa l'opzione -terminalLoggerParameters</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1368,6 +1421,13 @@ Nota: livello di dettaglio dei logger di file
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: il nome "{0}" contiene un carattere non valido "{1}".</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1541,6 +1601,14 @@ Nota: livello di dettaglio dei logger di file
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1556,6 +1624,21 @@ Nota: livello di dettaglio dei logger di file
         <target state="translated">MSBUILD : error MSB1059: non è stato possibile stampare le destinazioni. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Il logger di terminale non è stato usato perché la compilazione viene eseguita nel contesto di un processo (ad esempio 'dotnet test') che richiede l'accesso diretto al flusso stdout.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Il logger del terminale non è stato usato perché l'output non è supportato.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Il logger del terminale non è stato usato perché l'output viene reindirizzato a un file.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: questa opzione non accetta parametri.</target>
@@ -1939,15 +2022,16 @@ Esegue la profilatura della valutazione di MSBuild e scrive
                        -restoreProperty:IsRestore=true;MyProperty=value
     </source>
         <target state="translated">  -restoreProperty:&lt;n&gt;=&lt;v&gt;
-                     Imposta queste proprietà a livello di progetto o ne esegue
-                     l'override solo durante il ripristino e non usa le
-                     proprietà specificate con l'argomento -property.
-                     &lt;v&gt; rappresenta il nome della proprietà e &lt;v&gt; il
-                     valore della proprietà. Usare il punto e virgola o la
-                     virgola per delimitare più proprietà o specificare ogni proprietà separatamente.
-                     (Forma breve: -rp)
-                     Esempio:
-                       -restoreProperty:IsRestore=true;MyProperty=value
+                      Imposta queste proprietà a livello di progetto o ne esegue
+                      l'override solo durante il ripristino e non usa le
+                      proprietà specificate con l'argomento -property.
+                      &lt;v&gt; rappresenta il nome della proprietà e &lt;v&gt; il
+                      valore della proprietà. Usare il punto e virgola o la
+                      virgola per delimitare più proprietà o specificare ogni
+                      proprietà separatamente.
+                      Forma breve: -rp.
+                      Esempio:
+                        -restoreProperty:IsRestore=true;MyProperty=value
     </target>
         <note>
       LOCALIZATION: "-restoreProperty" and "-rp" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 5f6a0724a12..35aa68724fe 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">{1} 秒後に {0} をビルド</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">失敗しました</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">エラーで失敗しました</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">失敗し、警告が発生しました</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">成功しました</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">警告付きで成功</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -101,6 +106,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: ターミナル ロガーの値が無効です。'auto'、'true'、または 'false' のいずれかである必要があります。 {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1271,6 +1286,33 @@
         <target state="translated">MSBuild のログとデバッグ情報は、"{0}" にあります。</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Logger を指定してください。</target>
@@ -1322,6 +1364,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters スイッチを使用する場合は、このスイッチにターミナル ロガーのパラメーターを 1 つ以上指定してください</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1358,6 +1410,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: 名前 "{0}" に無効な文字 "{1}" が含まれています。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1531,6 +1590,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1546,6 +1613,21 @@
         <target state="translated">MSBUILD : error MSB1059: ターゲットを出力できませんでした。{0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">ビルドは stdout ストリームへの直接アクセスを要求するプロセス (例: 'dotnet test') のコンテキストで実行されるため、ターミナル ロガーは使用されませんでした。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">出力がサポートされていないため、ターミナル ロガーは使用されませんでした。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">出力がファイルにリダイレクトされているため、ターミナル ロガーは使用されませんでした。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: このスイッチにはパラメーターを指定できません。</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 5b6404ff8be..47d973d6a67 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">{0} 빌드({1}초)</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">실패</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">실패(오류 발생)</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">실패(경고 발생)</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">성공</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">성공(경고 발생)</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -101,6 +106,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: 터미널 로거 값이 잘못되었습니다. 'auto', 'true' 또는 'false' 중 하나여야 합니다. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1271,6 +1286,33 @@
         <target state="translated">MSBuild 로그 및 디버그 정보는 "{0}"에 있습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: 로거를 지정하십시오.</target>
@@ -1322,6 +1364,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters 스위치를 사용하는 경우 터미널 로거에 대해 하나 이상의 매개 변수를 지정하세요.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1358,6 +1410,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: "{0}" 이름에 잘못된 문자 "{1}"이(가) 사용되었습니다.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1531,6 +1590,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1546,6 +1613,21 @@
         <target state="translated">MSBUILD : error MSB1059: 대상을 출력할 수 없습니다. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">빌드가 stdout 스트림에 대한 직접 액세스를 요청하는 프로세스(예: 'dotnet test')의 컨텍스트에서 실행되기 때문에 터미널 로거는 사용되지 않았습니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">출력이 지원되지 않아 터미널 로거를 사용하지 않았습니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">출력이 파일로 리디렉션되기 때문에 터미널 로거가 사용되지 않았습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: 이 스위치에는 매개 변수를 지정할 수 없습니다.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index a201a075ab6..9d9bfb601d7 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Kompiluj {0} w {1}s</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">niepowodzenie</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">zakończono niepowodzeniem, z błędami</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">zakończono niepowodzeniem, z ostrzeżeniami.</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">powodzenie</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">zakończono powodzeniem, z ostrzeżeniem</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -101,6 +106,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: Wartość rejestratora terminali jest nieprawidłowa. Powinna to być wartość „auto”, „true” lub „false”. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -525,14 +540,17 @@
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;rejestrator&gt;  Umożliwia użycie podanego rejestratora do rejestrowania zdarzeń pochodzących
-                     z programu MSBuild. Aby określić wiele rejestratorów, określ każdy z nich osobno.
+        <target state="translated">  -logger:&lt;rejestrator&gt;  Umożliwia użycie podanego rejestratora do rejestrowania
+                         zdarzeń pochodzących z programu MSBuild. Aby określić
+                     wiele rejestratorów, określ każdy z nich osobno.
                      Składnia elementu &lt;rejestrator&gt;:
-                      [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt; [;&lt;parametry rejestratora&gt;]
+                        [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;
+                        [;&lt;parametry rejestratora&gt;]
                      Składnia elementu &lt;klasa rejestratora&gt;:
-                       [&lt;częściowa lub pełna przestrzeń nazw&gt;.] &lt;nazwa klasy rejestratora&gt;
+                        [&lt;częściowa lub pełna przestrzeń nazw&gt;.]
+                        &lt;nazwa klasy rejestratora&gt;
                      Składnia elementu &lt;zestaw rejestratora&gt;:
-                       {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
+                        {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
                      Wartości &lt;parametry rejestratora&gt; są opcjonalne i są
                      przekazywane do rejestratora dokładnie tak, jak zostały
                      wpisane. (Krótka wersja: -l)
@@ -927,11 +945,13 @@
                      create a log file for each node.
     </source>
         <target state="translated">  -distributedFileLogger
-                     Rejestruje dane wyjściowe kompilacji w wielu plikach dziennika,po jednym pliku
-                     na węzeł programu MSBuild. Początkową lokalizacją tych plików
-                     jest bieżący katalog. Domyślnie pliki mają nazwę
+                     Rejestruje dane wyjściowe kompilacji w wielu plikach
+                     dziennika, po jednym pliku na węzeł programu MSBuild.
+                     Początkową lokalizacją tych plików jest bieżący katalog.
+                     Domyślnie pliki mają nazwę
                      „MSBuild&lt;identyfikator węzła&gt;.log”. Lokalizację plików
                      i inne parametry rejestratora plików można określić
+
                      przez dodanie przełącznika „-fileLoggerParameters”.
 
                      Jeśli nazwa pliku zostanie ustawiona za pomocą przełącznika
@@ -1277,6 +1297,33 @@
         <target state="translated">Dzienniki i informacje debugowania programu MSBuild będą znajdować się w lokalizacji „{0}”</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: określ rejestrator.</target>
@@ -1328,6 +1375,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: W przypadku korzystania z przełącznika -terminalLoggerParameters określ co najmniej jeden parametr dla rejestratora terminalu</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1364,6 +1421,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: nazwa „{0}” zawiera nieprawidłowy znak „{1}”.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1537,6 +1601,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1552,6 +1624,21 @@
         <target state="translated">MSBUILD : error MSB1059: Nie można wydrukować elementów docelowych. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Rejestrator terminali nie został użyty, ponieważ kompilacja jest uruchamiana w kontekście procesu (np. „dotnet test”), który żąda bezpośredniego dostępu do strumienia StdOut.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Rejestrator terminali nie został użyty, ponieważ dane wyjściowe nie są obsługiwane.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Rejestrator terminali nie został użyty, ponieważ dane wyjściowe są przekierowywane do pliku.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: ten przełącznik nie ma żadnych parametrów.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 7099c69d7bd..4c60b3fbda2 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Construir {0} em {1}s</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">falhou</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">falhou com erros</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">falhou com avisos</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">êxito</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">êxito com avisos</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -101,6 +106,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: o valor do agente de terminal não é válido. O valor deve ser "auto", "true" ou "false". {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1272,6 +1287,33 @@ arquivo de resposta.
         <target state="translated">Os logs e as informações de depuração do MSBuild estarão no "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Especificar um agente de log.</target>
@@ -1323,6 +1365,16 @@ arquivo de resposta.
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: Especifique um ou mais parâmetros para o agente de terminal se estiver usando a opção -terminalLoggerParameters</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1359,6 +1411,13 @@ arquivo de resposta.
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: O nome "{0}" contém um caractere inválido "{1}".</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1532,6 +1591,14 @@ arquivo de resposta.
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1547,6 +1614,21 @@ arquivo de resposta.
         <target state="translated">MSBUILD : error MSB1059: não foi possível imprimir destinos. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">O Agente de Terminal não foi usado porque a compilação é executada no contexto de um processo (por exemplo, 'dotnet test') que solicita acesso direto ao fluxo stdout.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">O Agente de Terminal não foi usado porque não há suporte para a saída.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">O Agente de Terminal não foi usado porque a saída está sendo redirecionada para um arquivo.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Esta opção não aceita parâmetros.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index ffda16e7ca3..e94db7008c0 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Сборка {0} через {1} с</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">сбой</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">сбой с ошибками</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">сбой с предупреждениями</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">успешно выполнено</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">успешно выполнено с предупреждением</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -101,6 +106,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="new">MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1270,6 +1285,33 @@
         <target state="translated">Журналы MSBuild и отладочные сведения будут доступны по адресу "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: укажите журнал.</target>
@@ -1321,6 +1363,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: укажите один или несколько параметров для регистратора терминала при использовании переключателя -terminalLoggerParameters</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1357,6 +1409,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: Имя "{0}" содержит недопустимый символ "{1}".</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1530,6 +1589,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1545,6 +1612,21 @@
         <target state="translated">MSBUILD : error MSB1059: не удалось вывести целевые объекты. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Средство ведения журнала терминалов не используется, так как сборка выполняется в контексте процесса (например, "dotnet test"), который запрашивает прямой доступ к потоку stdout.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Средство ведения журнала терминалов не используется, так как выходные данные не поддерживаются.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Средство ведения журнала терминалов не используется, так как выходные данные перенаправляются в файл.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: у этого ключа нет параметров.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 2e8fde26de2..f2ee8ee03a4 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">"{1}" sn'de {0} oluşturun</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">başarısız oldu</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">hatalarla başarısız oldu</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">uyarılarla başarısız oldu</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">başarılı</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">uyarılarla birlikte başarılı</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -101,6 +106,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: Terminal günlükçüsü değeri geçerli değil. Değer şunlardan biri olmalıdır: 'otomatik', 'doğru' veya 'yanlış'. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -836,9 +851,10 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;uzantılar&gt;
-                     Hangi proje dosyasının oluşturulacağı belirlenirken
-                     yoksayılacak uzantıların listesi. Birden çok uzantıyı
-                     birbirinden ayırmak için noktalı virgül veya virgül kullanın.
+                     Hangi proje dosyasının oluşturulacağı belirlenirken 
+                     yoksayılacak uzantıların listesi. Birden çok uzantıyı 
+                     birbirinden ayırmak için noktalı virgül veya 
+                     virgül kullanın.
                      (Kısa biçim: -ignore)
                      Örnek:
                        -ignoreProjectExtensions:.sln
@@ -928,6 +944,7 @@
                      Dosyaların konumu ve fileLogger'ın diğer parametreleri 
                      "/fileLoggerParameters" anahtarının eklenmesi yoluyla
                      belirtilebilir.
+
                      Günlük dosyası adı fileLoggerParameters anahtarı
                      aracılığıyla ayarlanırsa dağıtılmış günlükçü fileName 
                      değerini şablon olarak kullanıp her düğümün günlük dosyasını
@@ -974,31 +991,32 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parametreler&gt;
                      Dosya günlükçüleri için ek parametreler sağlar.
-                     Bu anahtarın olması karşılık gelen -fileLogger[n]
+                     Bu anahtarın olması karşılık gelen -fileLogger[n] 
                      anahtarının olduğu anlamına gelir.
                      "n" varsa, 1-9 arasında bir rakam olabilir.
-                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters
-                     bunlar tarafından da kullanılır; -distributedFileLogger açıklamasına bakın.
+                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters 
+                     bunlar tarafından da kullanılır; -distributedFileLogger 
+                     açıklamasına bakın.
                      (Kısa biçim: -flp[n])
-                     Konsol günlükçüsü için listelenenlerle aynı parametreler
+                     Konsol günlükçüsü için listelenenlerle aynı parametreler 
                      kullanılabilir. Kullanılabilecek bazı ek parametreler:
-                        LogFile--Oluşturma günlüğünün yazılacağı günlük
+                        LogFile--Oluşturma günlüğünün yazılacağı günlük 
                             dosyasının yolu.
-                        Append--Derleme günlüğünün gün dosyasının sonuna mı
-                            ekleneceğini yoksa üzerine mi yazılacağını
-                            belirler. Anahtar ayarlandığında oluşturma günlüğü
-                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında
-                            varolan günlük dosyasının üzerine yazılır.
+                        Append--Derleme günlüğünün gün dosyasının sonuna mı 
+                            ekleneceğini yoksa üzerine mi yazılacağını 
+                            belirler. Anahtar ayarlandığında oluşturma günlüğü 
+                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında 
+                            varolan günlük dosyasının üzerine yazılır. 
                             Varsayılan: günlük dosyasının sonuna eklenmez.
-                        Encoding--Dosyanın kodlamasını belirtir; örneğin,
+                        Encoding--Dosyanın kodlamasını belirtir; örneğin, 
                             UTF-8, Unicode veya ASCII
                      Varsayılan ayrıntı düzeyi ayarı Detailed'dır.
                      Örnekler:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1022,7 +1040,8 @@
                        -nr:true
     </source>
         <target state="translated">  -nodeReuse:&lt;parametreler&gt;
-                     MSBuild düğümlerinin yeniden kullanımını etkinleştirir veya devre dışı bırakır.
+                     MSBuild düğümlerinin yeniden kullanımını etkinleştirir
+                     veya devre dışı bırakır.
                      Parametreler:
                      True --Derleme tamamlandıktan sonra düğümler kalır ve
                             izleyen derlemelerde yeniden kullanılır (varsayılan)
@@ -1271,6 +1290,33 @@
         <target state="translated">MSBuild günlükleri ve hata ayıklama bilgileri "{0}" yolunda olacak</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Günlükçü belirtin.</target>
@@ -1322,6 +1368,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters anahtarı kullanılıyorsa terminal günlükçüsü için bir veya birden çok parametre belirtin</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1358,6 +1414,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: "{0}" adı "{1}" geçersiz karakterini içeriyor.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1531,6 +1594,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1546,6 +1617,21 @@
         <target state="translated">MSBUILD : error MSB1059: Hedefler yazdırılamadı. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">Derleme StdOut akışına doğrudan erişim isteyen bir işlem (ör. 'dotnet test') bağlamında çalıştığı için Terminal Günlükçüsü kullanılmadı.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">Çıkış desteklenmediğinden Terminal Günlükçüsü kullanılmadı.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">Çıkış bir dosyaya yeniden yönlendirildiği için Terminal Günlükçüsü kullanılmadı.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Bu anahtar parametreyle kullanılmaz.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 863ffedade5..d1f839fc7b7 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">在 {1} 中生成 {0}</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">失败</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">失败，出现错误</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">失败，出现警告</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">已成功</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">成功，但出现警告</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -101,6 +106,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: 终端记录器值无效。它应为 "auto"、"true" 或 "false" 之一。{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1271,6 +1286,33 @@
         <target state="translated">MSBuild 日志和调试信息将位于"{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: 请指定记录器。</target>
@@ -1322,6 +1364,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: 为终端记录器指定一个或多个参数 (如果使用 -terminalLoggerParameters 开关)</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1358,6 +1410,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: 名称“{0}”包含无效字符“{1}”。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1531,6 +1590,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1546,6 +1613,21 @@
         <target state="translated">MSBUILD : error MSB1059: 无法打印目标。{0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">未使用终端记录器，因为生成是在请求直接访问 stdout 流的进程的上下文中运行的(如“dotnet test”)。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">未使用终端记录器，因为不支持输出。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">未使用终端记录器，因为正在将输出重定向到文件。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: 此开关不采用任何参数。</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index fcf5a24ad65..4e6f1da310b 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="new">Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">在 {1} 秒內建置 {0}</target>
@@ -23,35 +28,35 @@
         <source>failed</source>
         <target state="translated">失敗</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithErrors">
         <source>failed with errors</source>
         <target state="translated">失敗但有錯誤</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_FailedWithWarnings">
         <source>failed with warnings</source>
         <target state="translated">失敗但有警告</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_Succeeded">
         <source>succeeded</source>
         <target state="translated">成功</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="BuildResult_SucceededWithWarnings">
         <source>succeeded with warnings</source>
         <target state="translated">成功但有警告</target>
         <note>
-      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
     </note>
       </trans-unit>
       <trans-unit id="CommandLine">
@@ -101,6 +106,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidTerminalLoggerValue">
+        <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
+        <target state="translated">MSBUILD : error MSB1065: 終端機記錄器值無效。它應該是 'auto'、'true' 或 'false' 其中之一。{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1065: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1271,6 +1286,33 @@
         <target state="translated">MSBuild 記錄和偵錯工具資訊將位於 "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: 指定記錄器。</target>
@@ -1322,6 +1364,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="translated">MSBUILD : error MSB1066: 如果使用 -terminalLoggerParameters 參數，請為終端機記錄器指定一或多個參數</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
@@ -1358,6 +1410,13 @@
         <note>
       {StrBegin="MSBUILD : error MSB1024: "}UE: The user did something like msbuild -validate:foo.xsd -validate:bar.xsd. We only allow one schema to be specified.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="NameInvalid">
+        <source>MSBUILD : error MSB5016: The name "{0}" contains an invalid character "{1}".</source>
+        <target state="translated">MSBUILD : error MSB5016: 名稱 "{0}" 包含無效字元 "{1}"。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB5016: "}
     </note>
       </trans-unit>
       <trans-unit id="NotWarnAsErrorWithoutWarnAsError">
@@ -1531,6 +1590,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1546,6 +1613,21 @@
         <target state="translated">MSBUILD : error MSB1059: 無法列印目標。{0}</target>
         <note>{StrBegin="MSBUILD : error MSB1059: "}</note>
       </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedDisabled">
+        <source>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</source>
+        <target state="translated">因為組建是在要求直接存取 stdout 資料流的處理常式 (例如 'dotnet test') 內容中執行，所以未使用終端記錄器。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedNotSupported">
+        <source>Terminal Logger was not used because the output is not supported.</source>
+        <target state="translated">因為不支援輸出，所以未使用終端記錄器。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TerminalLoggerNotUsedRedirected">
+        <source>Terminal Logger was not used because the output is being redirected to a file.</source>
+        <target state="translated">因為輸出正重新導向至檔案，所以未使用終端記錄器。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: 這個參數不使用任何參數。</target>
diff --git a/src/MSBuild/LiveLogger/AnsiCodes.cs b/src/MSBuild/TerminalLogger/AnsiCodes.cs
similarity index 71%
rename from src/MSBuild/LiveLogger/AnsiCodes.cs
rename to src/MSBuild/TerminalLogger/AnsiCodes.cs
index 2984f957dc4..016260d55f8 100644
--- a/src/MSBuild/LiveLogger/AnsiCodes.cs
+++ b/src/MSBuild/TerminalLogger/AnsiCodes.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-namespace Microsoft.Build.Logging.LiveLogger;
+namespace Microsoft.Build.Logging.TerminalLogger;
 
 /// <summary>
 /// A collection of standard ANSI/VT100 control codes.
@@ -16,11 +16,19 @@ internal static class AnsiCodes
     /// <summary>
     /// Select graphic rendition.
     /// </summary>
-    /// <remarks>\
+    /// <remarks>
     /// Print <see cref="CSI"/>color-code<see cref="SetColor"/> to change text color.
     /// </remarks>
     public const string SetColor = ";1m";
 
+    /// <summary>
+    /// Select graphic rendition - set bold mode.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/><see cref="SetBold"/> to change text to bold.
+    /// </remarks>
+    public const string SetBold = "1m";
+
     /// <summary>
     /// A shortcut to reset color back to normal.
     /// </summary>
@@ -95,13 +103,23 @@ internal static class AnsiCodes
     public const string ShowCursor = "\x1b[?25h";
 
     /// <summary>
-    /// Set progress state to a busy spinner.
+    /// Set progress state to a busy spinner. <br/>
+    /// Note: this code works only on ConEmu terminals, and conflicts with push a notification code on iTerm2.
     /// </summary>
+    /// <remarks>
+    /// <see href="https://conemu.github.io/en/AnsiEscapeCodes.html#ConEmu_specific_OSC">ConEmu specific OSC codes.</see><br/>
+    /// <see href="https://iterm2.com/documentation-escape-codes.html">iTerm2 proprietary escape codes.</see>
+    /// </remarks>
     public const string SetProgressIndeterminate = "\x1b]9;4;3;\x1b\\";
 
     /// <summary>
-    /// Remove progress state, restoring taskbar status to normal.
+    /// Remove progress state, restoring taskbar status to normal. <br/>
+    /// Note: this code works only on ConEmu terminals, and conflicts with push a notification code on iTerm2.
     /// </summary>
+    /// <remarks>
+    /// <see href="https://conemu.github.io/en/AnsiEscapeCodes.html#ConEmu_specific_OSC">ConEmu specific OSC codes.</see><br/>
+    /// <see href="https://iterm2.com/documentation-escape-codes.html">iTerm2 proprietary escape codes.</see>
+    /// </remarks>
     public const string RemoveProgress = "\x1b]9;4;0;\x1b\\";
 
     public static string Colorize(string? s, TerminalColor color)
@@ -113,4 +131,14 @@ public static string Colorize(string? s, TerminalColor color)
 
         return $"{CSI}{(int)color}{SetColor}{s}{SetDefaultColor}";
     }
+
+    public static string MakeBold(string? s)
+    {
+        if (string.IsNullOrWhiteSpace(s))
+        {
+            return s ?? "";
+        }
+
+        return $"{CSI}{SetBold}{s}{SetDefaultColor}";
+    }
 }
diff --git a/src/MSBuild/LiveLogger/BuildMessage.cs b/src/MSBuild/TerminalLogger/BuildMessage.cs
similarity index 86%
rename from src/MSBuild/LiveLogger/BuildMessage.cs
rename to src/MSBuild/TerminalLogger/BuildMessage.cs
index 93a9cf26f94..a204690d041 100644
--- a/src/MSBuild/LiveLogger/BuildMessage.cs
+++ b/src/MSBuild/TerminalLogger/BuildMessage.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-namespace Microsoft.Build.Logging.LiveLogger;
+namespace Microsoft.Build.Logging.TerminalLogger;
 
 /// <summary>
 /// Represents a piece of diagnostic output (message/warning/error).
diff --git a/src/MSBuild/LiveLogger/ITerminal.cs b/src/MSBuild/TerminalLogger/ITerminal.cs
similarity index 89%
rename from src/MSBuild/LiveLogger/ITerminal.cs
rename to src/MSBuild/TerminalLogger/ITerminal.cs
index ace2f0656c3..04a6dd8039f 100644
--- a/src/MSBuild/LiveLogger/ITerminal.cs
+++ b/src/MSBuild/TerminalLogger/ITerminal.cs
@@ -3,10 +3,10 @@
 
 using System;
 
-namespace Microsoft.Build.Logging.LiveLogger;
+namespace Microsoft.Build.Logging.TerminalLogger;
 
 /// <summary>
-/// An abstraction of a terminal, built specifically to fit the <see cref="LiveLogger"/> needs.
+/// An abstraction of a terminal, built specifically to fit the <see cref="TerminalLogger"/> needs.
 /// </summary>
 internal interface ITerminal : IDisposable
 {
@@ -20,6 +20,11 @@ internal interface ITerminal : IDisposable
     /// </summary>
     int Height { get; }
 
+    /// <summary>
+    /// <see langword="true"/> if the terminal emulator supports progress reporting.
+    /// </summary>
+    bool SupportsProgressReporting { get; }
+
     /// <summary>
     /// Starts buffering the text passed via the <c>Write*</c> methods.
     /// </summary>
diff --git a/src/MSBuild/LiveLogger/MessageSeverity.cs b/src/MSBuild/TerminalLogger/MessageSeverity.cs
similarity index 84%
rename from src/MSBuild/LiveLogger/MessageSeverity.cs
rename to src/MSBuild/TerminalLogger/MessageSeverity.cs
index 4b63a7317b2..07aa9058be3 100644
--- a/src/MSBuild/LiveLogger/MessageSeverity.cs
+++ b/src/MSBuild/TerminalLogger/MessageSeverity.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-namespace Microsoft.Build.Logging.LiveLogger;
+namespace Microsoft.Build.Logging.TerminalLogger;
 
 /// <summary>
 /// Enumerates the supported message severities.
diff --git a/src/MSBuild/LiveLogger/Project.cs b/src/MSBuild/TerminalLogger/Project.cs
similarity index 97%
rename from src/MSBuild/LiveLogger/Project.cs
rename to src/MSBuild/TerminalLogger/Project.cs
index d5c414907b4..5ed03039bcc 100644
--- a/src/MSBuild/LiveLogger/Project.cs
+++ b/src/MSBuild/TerminalLogger/Project.cs
@@ -5,7 +5,7 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 
-namespace Microsoft.Build.Logging.LiveLogger;
+namespace Microsoft.Build.Logging.TerminalLogger;
 
 /// <summary>
 /// Represents a project being built.
diff --git a/src/MSBuild/LiveLogger/Terminal.cs b/src/MSBuild/TerminalLogger/Terminal.cs
similarity index 92%
rename from src/MSBuild/LiveLogger/Terminal.cs
rename to src/MSBuild/TerminalLogger/Terminal.cs
index 381bdca31c5..91565e1f797 100644
--- a/src/MSBuild/LiveLogger/Terminal.cs
+++ b/src/MSBuild/TerminalLogger/Terminal.cs
@@ -3,12 +3,13 @@
 
 using System;
 using System.IO;
+using System.Runtime.InteropServices;
 using System.Text;
 #if NETFRAMEWORK
 using Microsoft.Build.Shared;
 #endif
 
-namespace Microsoft.Build.Logging.LiveLogger;
+namespace Microsoft.Build.Logging.TerminalLogger;
 
 /// <summary>
 /// An <see cref="ITerminal"/> implementation for ANSI/VT100 terminals.
@@ -62,6 +63,12 @@ public int Width
         }
     }
 
+    /// <inheritdoc/>
+    /// <remarks>
+    /// https://github.com/dotnet/msbuild/issues/8958: iTerm2 treats ;9 code to post a notification instead, so disable progress reporting on Mac.
+    /// </remarks>
+    public bool SupportsProgressReporting { get; } = !RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
+
     public Terminal()
     {
         _originalOutputEncoding = Console.OutputEncoding;
diff --git a/src/MSBuild/LiveLogger/TerminalColor.cs b/src/MSBuild/TerminalLogger/TerminalColor.cs
similarity index 89%
rename from src/MSBuild/LiveLogger/TerminalColor.cs
rename to src/MSBuild/TerminalLogger/TerminalColor.cs
index ec27040eb3e..683b4d683b8 100644
--- a/src/MSBuild/LiveLogger/TerminalColor.cs
+++ b/src/MSBuild/TerminalLogger/TerminalColor.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-namespace Microsoft.Build.Logging.LiveLogger;
+namespace Microsoft.Build.Logging.TerminalLogger;
 
 /// <summary>
 /// Enumerates the text colors supported by <see cref="ITerminal"/>.
diff --git a/src/MSBuild/LiveLogger/LiveLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
similarity index 90%
rename from src/MSBuild/LiveLogger/LiveLogger.cs
rename to src/MSBuild/TerminalLogger/TerminalLogger.cs
index ccfc71e3825..ffb06c9e550 100644
--- a/src/MSBuild/LiveLogger/LiveLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -9,13 +9,14 @@
 using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using System.Runtime.InteropServices;
 #if NETFRAMEWORK
 using Microsoft.IO;
 #else
 using System.IO;
 #endif
 
-namespace Microsoft.Build.Logging.LiveLogger;
+namespace Microsoft.Build.Logging.TerminalLogger;
 
 /// <summary>
 /// A logger which updates the console output "live" during the build.
@@ -23,7 +24,7 @@ namespace Microsoft.Build.Logging.LiveLogger;
 /// <remarks>
 /// Uses ANSI/VT100 control codes to erase and overwrite lines as the build is progressing.
 /// </remarks>
-internal sealed class LiveLogger : INodeLogger
+internal sealed class TerminalLogger : INodeLogger
 {
     /// <summary>
     /// A wrapper over the project context ID passed to us in <see cref="IEventSource"/> logger events.
@@ -144,9 +145,9 @@ public override string ToString()
     /// List of events the logger needs as parameters to the <see cref="ConfigurableForwardingLogger"/>.
     /// </summary>
     /// <remarks>
-    /// If LiveLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main
+    /// If TerminalLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main
     /// node using an instance of <see cref="ConfigurableForwardingLogger"/> with the following parameters.
-    /// Important: Note that LiveLogger is special-cased in <see cref="BackEnd.Logging.LoggingService.UpdateMinimumMessageImportance"/>
+    /// Important: Note that TerminalLogger is special-cased in <see cref="BackEnd.Logging.LoggingService.UpdateMinimumMessageImportance"/>
     /// so changing this list may impact the minimum message importance logging optimization.
     /// </remarks>
     public static readonly string[] ConfigurableForwardingLoggerParameters =
@@ -163,10 +164,15 @@ public override string ToString()
             "ERROREVENT"
     };
 
+    /// <summary>
+    /// The two directory separator characters to be passed to methods like <see cref="String.IndexOfAny(char[])"/>.
+    /// </summary>
+    private static readonly char[] PathSeparators = { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar };
+
     /// <summary>
     /// Default constructor, used by the MSBuild logger infra.
     /// </summary>
-    public LiveLogger()
+    public TerminalLogger()
     {
         Terminal = new Terminal();
     }
@@ -174,7 +180,7 @@ public LiveLogger()
     /// <summary>
     /// Internal constructor accepting a custom <see cref="ITerminal"/> for testing.
     /// </summary>
-    internal LiveLogger(ITerminal terminal)
+    internal TerminalLogger(ITerminal terminal)
     {
         Terminal = terminal;
         _manualRefresh = true;
@@ -210,6 +216,11 @@ public void Initialize(IEventSource eventSource)
         eventSource.MessageRaised += MessageRaised;
         eventSource.WarningRaised += WarningRaised;
         eventSource.ErrorRaised += ErrorRaised;
+
+        if (eventSource is IEventSource4 eventSource4)
+        {
+            eventSource4.IncludeEvaluationPropertiesAndItems();
+        }
     }
 
     /// <inheritdoc/>
@@ -235,7 +246,10 @@ private void BuildStarted(object sender, BuildStartedEventArgs e)
 
         _buildStartTime = e.Timestamp;
 
-        Terminal.Write(AnsiCodes.SetProgressIndeterminate);
+        if (Terminal.SupportsProgressReporting)
+        {
+            Terminal.Write(AnsiCodes.SetProgressIndeterminate);
+        }
     }
 
     /// <summary>
@@ -270,7 +284,11 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)
         }
         finally
         {
-            Terminal.Write(AnsiCodes.RemoveProgress);
+            if (Terminal.SupportsProgressReporting)
+            {
+                Terminal.Write(AnsiCodes.RemoveProgress);
+            }
+
             Terminal.EndUpdate();
         }
 
@@ -448,26 +466,7 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
                     {
                         foreach (BuildMessage buildMessage in project.BuildMessages)
                         {
-                            TerminalColor color = buildMessage.Severity switch
-                            {
-                                MessageSeverity.Warning => TerminalColor.Yellow,
-                                MessageSeverity.Error => TerminalColor.Red,
-                                _ => TerminalColor.Default,
-                            };
-                            char symbol = buildMessage.Severity switch
-                            {
-                                MessageSeverity.Warning => '⚠',
-                                MessageSeverity.Error => '❌',
-                                _ => ' ',
-                            };
-
-                            // The error and warning symbols may be rendered with different width on some terminals. To make sure that the message text
-                            // is always aligned, we print the symbol, move back to the start of the line, then move forward to the desired column, and
-                            // finally print the message text.
-                            int maxSymbolWidth = 2;
-                            int messageStartColumn = Indentation.Length + Indentation.Length + maxSymbolWidth;
-                            Terminal.WriteColorLine(color, $"{Indentation}{Indentation}{symbol}\uFE0E{AnsiCodes.CSI}{messageStartColumn + 1}{AnsiCodes.MoveBackward}" +
-                                $"{AnsiCodes.CSI}{messageStartColumn}{AnsiCodes.MoveForward} {buildMessage.Message}");
+                            Terminal.WriteLine($"{Indentation}{Indentation}{buildMessage.Message}");
                         }
                     }
 
@@ -570,7 +569,20 @@ private void WarningRaised(object sender, BuildWarningEventArgs e)
         var buildEventContext = e.BuildEventContext;
         if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
-            string message = EventArgsFormatting.FormatEventMessage(e, false);
+            string message = EventArgsFormatting.FormatEventMessage(
+                category: AnsiCodes.Colorize("warning", TerminalColor.Yellow),
+                subcategory: e.Subcategory,
+                message: e.Message,
+                code: AnsiCodes.Colorize(e.Code, TerminalColor.Yellow),
+                file: HighlightFileName(e.File),
+                projectFile: null,
+                lineNumber: e.LineNumber,
+                endLineNumber: e.EndLineNumber,
+                columnNumber: e.ColumnNumber,
+                endColumnNumber: e.EndColumnNumber,
+                threadId: e.ThreadId,
+                logOutputProperties: null);
+
             project.AddBuildMessage(MessageSeverity.Warning, message);
         }
     }
@@ -583,7 +595,20 @@ private void ErrorRaised(object sender, BuildErrorEventArgs e)
         var buildEventContext = e.BuildEventContext;
         if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
-            string message = EventArgsFormatting.FormatEventMessage(e, false);
+            string message = EventArgsFormatting.FormatEventMessage(
+                category: AnsiCodes.Colorize("error", TerminalColor.Red),
+                subcategory: e.Subcategory,
+                message: e.Message,
+                code: AnsiCodes.Colorize(e.Code, TerminalColor.Red),
+                file: HighlightFileName(e.File),
+                projectFile: null,
+                lineNumber: e.LineNumber,
+                endLineNumber: e.EndLineNumber,
+                columnNumber: e.ColumnNumber,
+                endColumnNumber: e.EndColumnNumber,
+                threadId: e.ThreadId,
+                logOutputProperties: null);
+
             project.AddBuildMessage(MessageSeverity.Error, message);
         }
     }
@@ -829,5 +854,21 @@ private int NodeIndexForContext(BuildEventContext context)
         return context.NodeId - 1;
     }
 
+    /// <summary>
+    /// Colorizes the filename part of the given path.
+    /// </summary>
+    private static string? HighlightFileName(string? path)
+    {
+        if (path == null)
+        {
+            return null;
+        }
+
+        int index = path.LastIndexOfAny(PathSeparators);
+        return index >= 0
+            ? $"{path.Substring(0, index + 1)}{AnsiCodes.MakeBold(path.Substring(index + 1))}"
+            : path;
+    }
+
     #endregion
 }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index fb86829c8d1..d57971461d4 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -17,28 +17,30 @@
 using System.Text;
 using System.Text.RegularExpressions;
 using System.Threading;
-
+using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Graph;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
-
-using FileLogger = Microsoft.Build.Logging.FileLogger;
+using Microsoft.Build.Utilities;
+using static Microsoft.Build.CommandLine.MSBuildApp;
+using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
 using ConsoleLogger = Microsoft.Build.Logging.ConsoleLogger;
-using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
+using FileLogger = Microsoft.Build.Logging.FileLogger;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
-using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
-using LiveLogger = Microsoft.Build.Logging.LiveLogger.LiveLogger;
-using Microsoft.Build.Shared.Debugging;
-using Microsoft.Build.Experimental;
-using Microsoft.Build.Framework.Telemetry;
-using Microsoft.Build.Internal;
+using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
+using SimpleErrorLogger = Microsoft.Build.Logging.SimpleErrorLogger.SimpleErrorLogger;
+using TerminalLogger = Microsoft.Build.Logging.TerminalLogger.TerminalLogger;
 
 #nullable disable
 
@@ -707,6 +709,10 @@ public static ExitType Execute(
                 string[] inputResultsCaches = null;
                 string outputResultsCache = null;
                 bool question = false;
+                string[] getProperty = Array.Empty<string>();
+                string[] getItem = Array.Empty<string>();
+                string[] getTargetResult = Array.Empty<string>();
+                BuildResult result = null;
 
                 GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile, out _);
                 bool buildCanBeInvoked = ProcessCommandLineSwitches(
@@ -743,6 +749,9 @@ public static ExitType Execute(
                                             ref outputResultsCache,
                                             ref lowPriority,
                                             ref question,
+                                            ref getProperty,
+                                            ref getItem,
+                                            ref getTargetResult,
                                             recursing: false,
 #if FEATURE_GET_COMMANDLINE
                                             commandLine);
@@ -776,12 +785,31 @@ public static ExitType Execute(
 
                     DateTime t1 = DateTime.Now;
 
+                    bool outputPropertiesItemsOrTargetResults = getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0;
+
                     // If the primary file passed to MSBuild is a .binlog file, play it back into passed loggers
                     // as if a build is happening
                     if (FileUtilities.IsBinaryLogFilename(projectFile))
                     {
                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);
                     }
+                    else if (outputPropertiesItemsOrTargetResults && FileUtilities.IsSolutionFilename(projectFile))
+                    {
+                        exitType = ExitType.BuildError;
+                        CommandLineSwitchException.Throw("SolutionBuildInvalidForCommandLineEvaluation",
+                            getProperty.Length > 0 ? "getProperty" :
+                            getItem.Length > 0 ? "getItem" :
+                            "getTargetResult");
+                    }
+                    else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))
+                    {
+                        using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))
+                        {
+                            Project project = collection.LoadProject(projectFile, globalProperties, toolsVersion);
+                            exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project);
+                            collection.LogBuildFinishedEvent(exitType == ExitType.Success);
+                        }
+                    }
                     else // regular build
                     {
                         // if everything checks out, and sufficient information is available to start building
@@ -816,6 +844,8 @@ public static ExitType Execute(
                                     question,
                                     inputResultsCaches,
                                     outputResultsCache,
+                                    saveProjectResult: outputPropertiesItemsOrTargetResults,
+                                    ref result,
                                     commandLine))
                         {
                             exitType = ExitType.BuildError;
@@ -828,6 +858,11 @@ public static ExitType Execute(
 
                     string timerOutputFilename = Environment.GetEnvironmentVariable("MSBUILDTIMEROUTPUTS");
 
+                    if (outputPropertiesItemsOrTargetResults && targets?.Length > 0 && result is not null)
+                    {
+                        exitType = OutputBuildInformationInJson(result, getProperty, getItem, getTargetResult, loggers, exitType);
+                    }
+
                     if (!string.IsNullOrEmpty(timerOutputFilename))
                     {
                         AppendOutputFile(timerOutputFilename, (long)elapsedTime.TotalMilliseconds);
@@ -985,6 +1020,64 @@ public static ExitType Execute(
             return exitType;
         }
 
+        private static ExitType OutputPropertiesAfterEvaluation(string[] getProperty, string[] getItem, Project project)
+        {
+            try
+            {
+                // Special case if the user requests exactly one property: skip json formatting
+                if (getProperty.Length == 1 && getItem.Length == 0)
+                {
+                    Console.WriteLine(project.GetPropertyValue(getProperty[0]));
+                }
+                else
+                {
+                    JsonOutputFormatter jsonOutputFormatter = new();
+                    jsonOutputFormatter.AddPropertiesInJsonFormat(getProperty, property => project.GetPropertyValue(property));
+                    jsonOutputFormatter.AddItemsInJsonFormat(getItem, project);
+                    Console.WriteLine(jsonOutputFormatter.ToString());
+                }
+
+                return ExitType.Success;
+            }
+            catch (InvalidProjectFileException e)
+            {
+                Console.Error.WriteLine(e.Message);
+                return ExitType.BuildError;
+            }
+        }
+
+        private static ExitType OutputBuildInformationInJson(BuildResult result, string[] getProperty, string[] getItem, string[] getTargetResult, ILogger[] loggers, ExitType exitType)
+        {
+            ProjectInstance builtProject = result.ProjectStateAfterBuild;
+
+            ILogger logger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);
+            if (logger is not null)
+            {
+                exitType = exitType == ExitType.Success && (logger as SimpleErrorLogger).HasLoggedErrors ? ExitType.BuildError : exitType;
+            }
+
+            if (builtProject is null)
+            {
+                // Build failed; do not proceed
+                Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildFailedWithPropertiesItemsOrTargetResultsRequested"));
+            }
+            // Special case if the user requests exactly one property: skip the json formatting
+            else if (getProperty.Length == 1 && getItem.Length == 0 && getTargetResult.Length == 0)
+            {
+                Console.WriteLine(builtProject.GetPropertyValue(getProperty[0]));
+            }
+            else
+            {
+                JsonOutputFormatter jsonOutputFormatter = new();
+                jsonOutputFormatter.AddPropertiesInJsonFormat(getProperty, property => builtProject.GetPropertyValue(property));
+                jsonOutputFormatter.AddItemInstancesInJsonFormat(getItem, builtProject);
+                jsonOutputFormatter.AddTargetResultsInJsonFormat(getTargetResult, result);
+                Console.WriteLine(jsonOutputFormatter.ToString());
+            }
+
+            return exitType;
+        }
+
         /// <summary>
         /// Handler for when CTRL-C or CTRL-BREAK is called.
         /// CTRL-BREAK means "die immediately"
@@ -1137,6 +1230,8 @@ internal static bool BuildProject(
             bool question,
             string[] inputResultsCaches,
             string outputResultsCache,
+            bool saveProjectResult,
+            ref BuildResult result,
 #if FEATURE_GET_COMMANDLINE
             string commandLine)
 #else
@@ -1359,7 +1454,8 @@ internal static bool BuildProject(
 
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
 
-                    BuildResultCode? result = null;
+                    result = null;
+                    GraphBuildResult graphResult = null;
 
                     if (!Traits.Instance.EscapeHatches.DoNotSendDeferredMessagesToBuildManager)
                     {
@@ -1403,21 +1499,30 @@ internal static bool BuildProject(
                             BuildRequestData buildRequest = null;
                             if (!restoreOnly)
                             {
+                                // By default, the project state is thrown out after a build. The ProvideProjectStateAfterBuild flag adds the project state after build
+                                // to the BuildResult passed back at the end of the build. This can then be used to find the value of properties, items, etc. after the
+                                // build is complete.
+                                BuildRequestDataFlags flags = BuildRequestDataFlags.None;
+                                if (saveProjectResult)
+                                {
+                                    flags |= BuildRequestDataFlags.ProvideProjectStateAfterBuild;
+                                }
+
                                 if (graphBuildOptions != null)
                                 {
-                                    graphBuildRequest = new GraphBuildRequestData(new[] { new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, BuildRequestDataFlags.None, graphBuildOptions);
+                                    graphBuildRequest = new GraphBuildRequestData(new[] { new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, flags, graphBuildOptions);
                                 }
                                 else
                                 {
-                                    buildRequest = new BuildRequestData(projectFile, globalProperties, toolsVersion, targets, null);
+                                    buildRequest = new BuildRequestData(projectFile, globalProperties, toolsVersion, targets, null, flags);
                                 }
                             }
 
                             if (enableRestore || restoreOnly)
                             {
-                                (result, exception) = ExecuteRestore(projectFile, toolsVersion, buildManager, restoreProperties.Count > 0 ? restoreProperties : globalProperties);
+                                result = ExecuteRestore(projectFile, toolsVersion, buildManager, restoreProperties.Count > 0 ? restoreProperties : globalProperties);
 
-                                if (result != BuildResultCode.Success)
+                                if (result.OverallResult != BuildResultCode.Success)
                                 {
                                     return false;
                                 }
@@ -1427,17 +1532,38 @@ internal static bool BuildProject(
                             {
                                 if (graphBuildOptions != null)
                                 {
-                                    (result, exception) = ExecuteGraphBuild(buildManager, graphBuildRequest);
+                                    graphResult = ExecuteGraphBuild(buildManager, graphBuildRequest);
+
+                                    if (saveProjectResult)
+                                    {
+                                        ProjectGraphEntryPoint entryPoint = graphBuildRequest.ProjectGraphEntryPoints.Single();
+                                        if (!entryPoint.GlobalProperties.ContainsKey(PropertyNames.IsGraphBuild))
+                                        {
+                                            entryPoint.GlobalProperties[PropertyNames.IsGraphBuild] = "true";
+                                        }
+
+                                        result = graphResult.ResultsByNode.Single(
+                                            nodeResultKvp =>
+                                            nodeResultKvp.Key.ProjectInstance.FullPath.Equals(entryPoint.ProjectFile) &&
+                                            nodeResultKvp.Key.ProjectInstance.GlobalProperties.Count == entryPoint.GlobalProperties.Count &&
+                                            nodeResultKvp.Key.ProjectInstance.GlobalProperties.All(propertyKvp => entryPoint.GlobalProperties.TryGetValue(propertyKvp.Key, out string entryValue) &&
+                                                                                                                                        entryValue.Equals(propertyKvp.Value)))
+                                            .Value;
+                                    }
+                                    else
+                                    {
+                                        success = graphResult.OverallResult == BuildResultCode.Success;
+                                    }
                                 }
                                 else
                                 {
-                                    (result, exception) = ExecuteBuild(buildManager, buildRequest);
+                                    result = ExecuteBuild(buildManager, buildRequest);
                                 }
                             }
 
-                            if (result != null && exception == null)
+                            if (result != null && result.Exception == null)
                             {
-                                success = result == BuildResultCode.Success;
+                                success = result.OverallResult == BuildResultCode.Success;
                             }
                         }
                         finally
@@ -1580,7 +1706,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
             return messages;
         }
 
-        private static (BuildResultCode result, Exception exception) ExecuteBuild(BuildManager buildManager, BuildRequestData request)
+        private static BuildResult ExecuteBuild(BuildManager buildManager, BuildRequestData request)
         {
             BuildSubmission submission;
             lock (s_buildLock)
@@ -1596,11 +1722,10 @@ private static (BuildResultCode result, Exception exception) ExecuteBuild(BuildM
                 }
             }
 
-            var result = submission.Execute();
-            return (result.OverallResult, result.Exception);
+            return submission.Execute();
         }
 
-        private static (BuildResultCode result, Exception exception) ExecuteGraphBuild(BuildManager buildManager, GraphBuildRequestData request)
+        private static GraphBuildResult ExecuteGraphBuild(BuildManager buildManager, GraphBuildRequestData request)
         {
             GraphBuildSubmission submission;
             lock (s_buildLock)
@@ -1616,11 +1741,10 @@ private static (BuildResultCode result, Exception exception) ExecuteGraphBuild(B
                 }
             }
 
-            GraphBuildResult result = submission.Execute();
-            return (result.OverallResult, result.Exception);
+            return submission.Execute();
         }
 
-        private static (BuildResultCode result, Exception exception) ExecuteRestore(string projectFile, string toolsVersion, BuildManager buildManager, Dictionary<string, string> globalProperties)
+        private static BuildResult ExecuteRestore(string projectFile, string toolsVersion, BuildManager buildManager, Dictionary<string, string> globalProperties)
         {
             // Make a copy of the global properties
             Dictionary<string, string> restoreGlobalProperties = new Dictionary<string, string>(globalProperties);
@@ -2261,6 +2385,9 @@ private static bool ProcessCommandLineSwitches(
             ref string outputResultsCache,
             ref bool lowPriority,
             ref bool question,
+            ref string[] getProperty,
+            ref string[] getItem,
+            ref string[] getTargetResult,
             bool recursing,
             string commandLine)
         {
@@ -2285,9 +2412,15 @@ private static bool ProcessCommandLineSwitches(
             }
 #endif
 
+            bool shouldShowLogo = !commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoLogo] &&
+                                  !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Preprocess) &&
+                                  !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GetProperty) &&
+                                  !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GetItem) &&
+                                  !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GetTargetResult);
+
             // show copyright message if nologo switch is not set
             // NOTE: we heed the nologo switch even if there are switch errors
-            if (!recursing && !commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoLogo] && !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Preprocess))
+            if (!recursing && shouldShowLogo)
             {
                 DisplayVersionMessage();
             }
@@ -2377,6 +2510,9 @@ private static bool ProcessCommandLineSwitches(
                                                            ref outputResultsCache,
                                                            ref lowPriority,
                                                            ref question,
+                                                           ref getProperty,
+                                                           ref getItem,
+                                                           ref getTargetResult,
                                                            recursing: true,
                                                            commandLine);
                     }
@@ -2384,6 +2520,17 @@ private static bool ProcessCommandLineSwitches(
                     // figure out which targets we are building
                     targets = ProcessTargetSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Target]);
 
+                    // If we are looking for the value of a specific property or item post-evaluation or a target post-build, figure that out now
+                    getProperty = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetProperty] ?? Array.Empty<string>();
+                    getItem = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetItem] ?? Array.Empty<string>();
+                    getTargetResult = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetTargetResult] ?? Array.Empty<string>();
+                    if (getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0)
+                    {
+                        commandLineSwitches.SetParameterizedSwitch(CommandLineSwitches.ParameterizedSwitch.Verbosity, "q", "q", true, true, true);
+                    }
+
+                    targets = targets.Union(getTargetResult, MSBuildNameIgnoreCaseComparer.Default).ToArray();
+
                     // figure out which ToolsVersion has been set on the command line
                     toolsVersion = ProcessToolsVersionSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ToolsVersion]);
 
@@ -2446,7 +2593,7 @@ private static bool ProcessCommandLineSwitches(
 
                     outputResultsCache = ProcessOutputResultsCache(commandLineSwitches);
 
-                    bool liveLogger = ProcessLiveLoggerConfiguration(commandLineSwitches);
+                    bool useTerminalLogger = ProcessTerminalLoggerConfiguration(commandLineSwitches, out string aggregatedTerminalLoggerParameters);
 
                     // figure out which loggers are going to listen to build events
                     string[][] groupedFileLoggerParameters = commandLineSwitches.GetFileLoggerParameters();
@@ -2457,12 +2604,14 @@ private static bool ProcessCommandLineSwitches(
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],
-                        liveLogger,
+                        useTerminalLogger,
+                        aggregatedTerminalLoggerParameters,
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ProfileEvaluation],
                         groupedFileLoggerParameters,
+                        getProperty.Length + getItem.Length + getTargetResult.Length > 0,
                         out distributedLoggerRecords,
                         out verbosity,
                         out originalVerbosity,
@@ -2514,72 +2663,200 @@ private static bool ProcessCommandLineSwitches(
             return invokeBuild;
         }
 
-        private static bool ProcessLiveLoggerConfiguration(CommandLineSwitches commandLineSwitches)
+        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)
         {
-            string liveLoggerArg;
+            aggregatedParameters = AggregateParameters(commandLineSwitches);
+            string defaultValue = FindDefaultValue(aggregatedParameters);
 
-            // Command line wins, so check it first
-            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.LiveLogger))
+            string terminalLoggerArg = null;
+            if (!TryFromCommandLine(commandLineSwitches) && !TryFromEnvironmentVariables())
             {
-                // There's a switch set, but there might be more than one
-                string[] switches = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LiveLogger];
+                ApplyDefault();
+            }
 
-                liveLoggerArg = switches[switches.Length - 1];
+            terminalLoggerArg = NormalizeIntoBooleanValues();
 
-                // if the switch was set but not to an explicit value, the value is "auto"
-                if (string.IsNullOrEmpty(liveLoggerArg))
+            bool useTerminalLogger = false;
+            if (!TrueOrFalse())
+            {
+                ItMustBeAuto();
+            }
+
+            return KnownTelemetry.LoggingConfigurationTelemetry.TerminalLogger = useTerminalLogger;
+
+            static bool CheckIfTerminalIsSupportedAndTryEnableAnsiColorCodes()
+            {
+                (var acceptAnsiColorCodes, var outputIsScreen, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
+
+                if (!outputIsScreen)
                 {
-                    liveLoggerArg = "auto";
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString("TerminalLoggerNotUsedRedirected"), MessageImportance.Low));
+                    return false;
+                }
+
+                // TerminalLogger is not used if the terminal does not support ANSI/VT100 escape sequences.
+                if (!acceptAnsiColorCodes)
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString("TerminalLoggerNotUsedNotSupported"), MessageImportance.Low));
+                    return false;
                 }
+
+                if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString("TerminalLoggerNotUsedDisabled"), MessageImportance.Low));
+                    return false;
+                }
+
+                return true;
             }
-            else
+
+            string FindDefaultValue(string s)
             {
-                liveLoggerArg = Environment.GetEnvironmentVariable("MSBUILDLIVELOGGER");
+                // Find default configuration so it is part of telemetry even when default is not used.
+                // Default can be stored in /tlp:default=true|false|on|off|auto
+                string terminalLoggerDefault = null;
+                foreach (string parameter in s.Split(MSBuildConstants.SemicolonChar))
+                {
+                    if (string.IsNullOrWhiteSpace(parameter))
+                    {
+                        continue;
+                    }
 
-                if (string.IsNullOrWhiteSpace(liveLoggerArg))
+                    string[] parameterAndValue = parameter.Split(MSBuildConstants.EqualsChar);
+                    if (parameterAndValue[0].Equals("default", StringComparison.InvariantCultureIgnoreCase) && parameterAndValue.Length > 1)
+                    {
+                        terminalLoggerDefault = parameterAndValue[1];
+                    }
+                }
+
+                if (terminalLoggerDefault == null)
                 {
-                    return false;
+                    terminalLoggerDefault = bool.FalseString;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefault = bool.FalseString;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefaultSource = "msbuild";
                 }
                 else
+                {
+                    // Lets check DOTNET CLI env var
+                    string dotnetCliEnvVar = Environment.GetEnvironmentVariable("DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER");
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefault = terminalLoggerDefault;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefaultSource = string.IsNullOrWhiteSpace(dotnetCliEnvVar) ? "sdk" : "DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER";
+                }
+
+                return terminalLoggerDefault;
+            }
+
+            bool TryFromCommandLine(CommandLineSwitches commandLineSwitches1)
+            {
+                if (!commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.TerminalLogger))
+                {
+                    return false;
+                }
+
+                // There's a switch set, but there might be more than one
+                string[] switches = commandLineSwitches1[CommandLineSwitches.ParameterizedSwitch.TerminalLogger];
+
+                terminalLoggerArg = switches[switches.Length - 1];
+
+                // if the switch was set but not to an explicit value, the value is "auto"
+                if (string.IsNullOrEmpty(terminalLoggerArg))
+                {
+                    terminalLoggerArg = "auto";
+                }
+
+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalLoggerArg ?? string.Empty;
+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = "arg";
+
+                return true;
+            }
+
+            bool TryFromEnvironmentVariables()
+            {
+                // Keep MSBUILDLIVELOGGER supporitng existing use. But MSBUILDTERMINALLOGGER takes precedence.
+                string liveLoggerArg = Environment.GetEnvironmentVariable("MSBUILDLIVELOGGER");
+                terminalLoggerArg = Environment.GetEnvironmentVariable("MSBUILDTERMINALLOGGER");
+                if (!string.IsNullOrEmpty(terminalLoggerArg))
                 {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage($"The environment variable MSBUILDTERMINALLOGGER was set to {terminalLoggerArg}.", MessageImportance.Low));
+
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalLoggerArg;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = "MSBUILDTERMINALLOGGER";
+                }
+                else if (!string.IsNullOrEmpty(liveLoggerArg))
+                {
+                    terminalLoggerArg = liveLoggerArg;
                     s_globalMessagesToLogInBuildLoggers.Add(
                         new BuildManager.DeferredBuildMessage($"The environment variable MSBUILDLIVELOGGER was set to {liveLoggerArg}.", MessageImportance.Low));
+
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalLoggerArg;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = "MSBUILDLIVELOGGER";
                 }
+                else
+                {
+                    return false;
+                }
+
+                return true;
             }
 
-            // We now have a string. It can be "true" or "false" which means just that:
-            if (bool.TryParse(liveLoggerArg, out bool result))
+            string NormalizeIntoBooleanValues()
             {
-                return result;
+                // We now have a string`. It can be "true" or "false" which means just that:
+                if (terminalLoggerArg.Equals("on", StringComparison.InvariantCultureIgnoreCase))
+                {
+                    terminalLoggerArg = bool.TrueString;
+                }
+                else if (terminalLoggerArg.Equals("off", StringComparison.InvariantCultureIgnoreCase))
+                {
+                    terminalLoggerArg = bool.FalseString;
+                }
+
+                return terminalLoggerArg;
             }
 
-            // or it can be "auto", meaning "enable if we can"
-            if (!liveLoggerArg.Equals("auto", StringComparison.OrdinalIgnoreCase))
+            void ApplyDefault()
             {
-                CommandLineSwitchException.Throw("InvalidLiveLoggerValue", liveLoggerArg);
+                terminalLoggerArg = defaultValue;
             }
 
-            return DoesEnvironmentSupportLiveLogger();
-
-            static bool DoesEnvironmentSupportLiveLogger()
+            string AggregateParameters(CommandLineSwitches switches)
             {
-                (var acceptAnsiColorCodes, var outputIsScreen, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
+                string[] terminalLoggerParameters = switches[CommandLineSwitches.ParameterizedSwitch.TerminalLoggerParameters];
+                return terminalLoggerParameters?.Length > 0 ? MSBuildApp.AggregateParameters(string.Empty, terminalLoggerParameters) : string.Empty;
+            }
 
-                if (!outputIsScreen)
+            bool TrueOrFalse()
+            {
+                if (bool.TryParse(terminalLoggerArg, out bool result))
                 {
-                    s_globalMessagesToLogInBuildLoggers.Add(
-                        new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is being redirected to a file.", MessageImportance.Low));
-                    return false;
+                    useTerminalLogger = result;
+
+                    // Try Enable Ansi Color Codes when terminal logger is enabled/enforced.
+                    if (result)
+                    {
+                        // This needs to be called so Ansi Color Codes are enabled for the terminal logger.
+                        (_, _, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
+                    }
+
+                    return true;
                 }
 
-                // LiveLogger is not used if the terminal does not support ANSI/VT100 escape sequences.
-                if (!acceptAnsiColorCodes)
+                return false;
+            }
+
+            void ItMustBeAuto()
+            {
+                // or it can be "auto", meaning "enable if we can"
+                if (!terminalLoggerArg.Equals("auto", StringComparison.OrdinalIgnoreCase))
                 {
-                    s_globalMessagesToLogInBuildLoggers.Add(
-                        new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is not supported.", MessageImportance.Low));
-                    return false;
+                    CommandLineSwitchException.Throw("InvalidTerminalLoggerValue", terminalLoggerArg);
                 }
-                return true;
+
+                useTerminalLogger = CheckIfTerminalIsSupportedAndTryEnableAnsiColorCodes();
             }
         }
 
@@ -3259,6 +3536,14 @@ internal static int GetLengthOfSwitchIndicator(string unquotedSwitch)
         /// <returns>List of target names.</returns>
         private static string[] ProcessTargetSwitch(string[] parameters)
         {
+            foreach (string parameter in parameters)
+            {
+                int indexOfSpecialCharacter = parameter.IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
+                if (indexOfSpecialCharacter >= 0)
+                {
+                    CommandLineSwitchException.Throw("NameInvalid", nameof(XMakeElements.target), parameter, parameter[indexOfSpecialCharacter].ToString());
+                }
+            }
             return parameters;
         }
 
@@ -3330,12 +3615,14 @@ private static ILogger[] ProcessLoggingSwitches(
             string[] verbositySwitchParameters,
             bool noConsoleLogger,
             bool distributedFileLogger,
-            bool liveLoggerOptIn,
+            bool terminalloggerOptIn,
+            string aggregatedTerminalLoggerParameters,
             string[] fileLoggerParameters,
             string[] consoleLoggerParameters,
             string[] binaryLoggerParameters,
             string[] profileEvaluationParameters,
             string[][] groupedFileLoggerParameters,
+            bool useSimpleErrorLogger,
             out List<DistributedLoggerRecord> distributedLoggerRecords,
             out LoggerVerbosity verbosity,
             out LoggerVerbosity originalVerbosity,
@@ -3358,15 +3645,23 @@ private static ILogger[] ProcessLoggingSwitches(
             var outVerbosity = verbosity;
             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref outVerbosity);
 
-            ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);
+            // When returning the result of evaluation from the command line, do not use custom loggers.
+            if (!useSimpleErrorLogger)
+            {
+                ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);
+            }
 
             // Add any loggers which have been specified on the commandline
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
 
-            // Choose default console logger
-            if (liveLoggerOptIn)
+            // Otherwise choose default console logger: None, TerminalLogger, or the older ConsoleLogger
+            if (useSimpleErrorLogger)
+            {
+                loggers.Add(new SimpleErrorLogger());
+            }
+            else if (terminalloggerOptIn)
             {
-                ProcessLiveLogger(noConsoleLogger, distributedLoggerRecords, cpuCount, loggers);
+                ProcessTerminalLogger(noConsoleLogger, aggregatedTerminalLoggerParameters, distributedLoggerRecords, cpuCount, loggers);
             }
             else
             {
@@ -3542,8 +3837,8 @@ internal static void ProcessConsoleLoggerSwitch(
             }
         }
 
-        private static void ProcessLiveLogger(
-            bool noConsoleLogger,
+        private static void ProcessTerminalLogger(bool noConsoleLogger,
+            string aggregatedLoggerParameters,
             List<DistributedLoggerRecord> distributedLoggerRecords,
             int cpuCount,
             List<ILogger> loggers)
@@ -3551,7 +3846,10 @@ private static void ProcessLiveLogger(
             if (!noConsoleLogger)
             {
                 // A central logger will be created for both single proc and multiproc.
-                LiveLogger logger = new LiveLogger();
+                TerminalLogger logger = new TerminalLogger()
+                {
+                    Parameters = aggregatedLoggerParameters
+                };
 
                 // Check to see if there is a possibility we will be logging from an out-of-proc node.
                 // If so (we're multi-proc or the in-proc node is disabled), we register a distributed logger.
@@ -3562,7 +3860,7 @@ private static void ProcessLiveLogger(
                 else
                 {
                     // For performance, register this logger using the forwarding logger mechanism.
-                    DistributedLoggerRecord forwardingLoggerRecord = CreateForwardingLoggerRecord(logger, string.Join(";", LiveLogger.ConfigurableForwardingLoggerParameters), LoggerVerbosity.Quiet);
+                    DistributedLoggerRecord forwardingLoggerRecord = CreateForwardingLoggerRecord(logger, string.Join(";", TerminalLogger.ConfigurableForwardingLoggerParameters), LoggerVerbosity.Quiet);
                     distributedLoggerRecords.Add(forwardingLoggerRecord);
                 }
             }
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index c2e0bb5b8c1..463795025c0 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -61,6 +61,9 @@
     <Compile Include="..\Framework\ITaskItem2.cs">
       <Link>ITaskItem2.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\IExtendedBuildEventArgs.cs">
+      <Link>IExtendedBuildEventArgs.cs</Link>
+    </Compile>
     <Compile Include="..\Framework\AssemblyUtilities.cs" />
     <Compile Include="..\Framework\ResponseFileUsedEventArgs.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
diff --git a/src/Samples/PortableTask/PortableTask.csproj b/src/Samples/PortableTask/PortableTask.csproj
index 944a7d713ac..47a2ca8a65f 100644
--- a/src/Samples/PortableTask/PortableTask.csproj
+++ b/src/Samples/PortableTask/PortableTask.csproj
@@ -18,6 +18,6 @@
 
   <!-- This is only needed for a test in the MSBuild repo; it is unrelated to the PortableTask sample itself. -->
   <Target Name="CopyMSBuildUtilitiesToNewFolder" BeforeTargets="CopyFilesToOutputDirectory">
-    <Copy SourceFiles="$(PkgMicrosoft_Build_Utilities_Core)\lib\net46\Microsoft.Build.Utilities.Core.dll" DestinationFiles="$(OutDir)\OldMSBuild\Microsoft.Build.Utilities.Core.dll" />
+    <Copy SourceFiles="$(PkgMicrosoft_Build_Utilities_Core)\lib\net46\Microsoft.Build.Utilities.Core.dll" DestinationFiles="$(OutDir)\OldMSBuild\Microsoft.Build.Utilities.Core.dll" SkipUnchangedFiles="true"/>
   </Target>
 </Project>
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index 316a1180878..994c24341bd 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -99,5 +99,30 @@ public static unsafe Guid ReadGuid(this BinaryReader reader)
         {
             return new Guid(reader.ReadBytes(sizeof(Guid)));
         }
+
+        public static void ReadExtendedBuildEventData(this BinaryReader reader, IExtendedBuildEventArgs data)
+        {
+            data.ExtendedType = reader.ReadString();
+            data.ExtendedData = reader.ReadOptionalString();
+
+            bool haveMetadata = reader.ReadBoolean();
+            if (haveMetadata)
+            {
+                data.ExtendedMetadata = new();
+
+                int count = reader.Read7BitEncodedInt();
+                for (int i = 0; i < count; i++)
+                {
+                    string key = reader.ReadString();
+                    string? value = reader.ReadOptionalString();
+
+                    data.ExtendedMetadata.Add(key, value);
+                }
+            }
+            else
+            {
+                data.ExtendedMetadata = null;
+            }
+        }
     }
 }
diff --git a/src/Shared/BinaryWriterExtensions.cs b/src/Shared/BinaryWriterExtensions.cs
index 211e91f3edc..5f7a0046a6e 100644
--- a/src/Shared/BinaryWriterExtensions.cs
+++ b/src/Shared/BinaryWriterExtensions.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.IO;
 using System.Runtime.CompilerServices;
 using Microsoft.Build.Framework;
@@ -111,5 +112,22 @@ public static void WriteGuid(this BinaryWriter writer, Guid value)
                 }
             }
         }
+
+        public static void WriteExtendedBuildEventData(this BinaryWriter writer, IExtendedBuildEventArgs data)
+        {
+            writer.Write(data.ExtendedType);
+            writer.WriteOptionalString(data.ExtendedData);
+
+            writer.Write(data.ExtendedMetadata != null);
+            if (data.ExtendedMetadata != null)
+            {
+                writer.Write7BitEncodedInt(data.ExtendedMetadata.Count);
+                foreach (KeyValuePair<string, string?> kvp in data.ExtendedMetadata)
+                {
+                    writer.Write(kvp.Key);
+                    writer.WriteOptionalString(kvp.Value);
+                }
+            }
+        }
     }
 }
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index b885d081a74..4cfbf546ce0 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -145,6 +145,61 @@ internal enum LoggingEventType : int
         /// Event is an AssemblyLoadBuildEventArgs
         /// </summary>
         AssemblyLoadEvent = 21,
+
+        /// <summary>
+        /// Event is <see cref="ExternalProjectStartedEventArgs"/>
+        /// </summary>
+        ExternalProjectStartedEvent = 22,
+
+        /// <summary>
+        /// Event is <see cref="ExternalProjectFinishedEventArgs"/>
+        /// </summary>
+        ExternalProjectFinishedEvent = 23,
+
+        /// <summary>
+        /// Event is <see cref="ExtendedCustomBuildEventArgs"/>
+        /// </summary>
+        ExtendedCustomEvent = 24,
+
+        /// <summary>
+        /// Event is <see cref="ExtendedBuildErrorEventArgs"/>
+        /// </summary>
+        ExtendedBuildErrorEvent = 25,
+
+        /// <summary>
+        /// Event is <see cref="ExtendedBuildWarningEventArgs"/>
+        /// </summary>
+        ExtendedBuildWarningEvent = 26,
+
+        /// <summary>
+        /// Event is <see cref="ExtendedBuildMessageEventArgs"/>
+        /// </summary>
+        ExtendedBuildMessageEvent = 27,
+
+        /// <summary>
+        /// Event is <see cref="CriticalBuildMessageEventArgs"/>
+        /// </summary>
+        CriticalBuildMessage = 28,
+
+        /// <summary>
+        /// Event is <see cref="MetaprojectGeneratedEventArgs"/>
+        /// </summary>
+        MetaprojectGenerated = 29,
+
+        /// <summary>
+        /// Event is <see cref="PropertyInitialValueSetEventArgs"/>
+        /// </summary>
+        PropertyInitialValueSet = 30,
+
+        /// <summary>
+        /// Event is <see cref="PropertyReassignmentEventArgs"/>
+        /// </summary>
+        PropertyReassignment = 31,
+
+        /// <summary>
+        /// Event is <see cref="UninitializedPropertyReadEventArgs"/>
+        /// </summary>
+        UninitializedPropertyRead = 32
     }
     #endregion
 
@@ -230,8 +285,9 @@ internal LogMessagePacketBase(KeyValuePair<int, BuildEventArgs>? nodeBuildEvent,
         /// <summary>
         /// Constructor for deserialization
         /// </summary>
-        protected LogMessagePacketBase(ITranslator translator)
+        protected LogMessagePacketBase(ITranslator translator, TargetFinishedTranslator targetFinishedTranslator = null)
         {
+            _targetFinishedTranslator = targetFinishedTranslator;
             Translate(translator);
         }
 
@@ -339,7 +395,8 @@ internal void WriteToStream(ITranslator translator)
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
                 if (_buildEvent is ProjectEvaluationStartedEventArgs
                     or ProjectEvaluationFinishedEventArgs
-                    or EnvironmentVariableReadEventArgs)
+                    or EnvironmentVariableReadEventArgs
+                    or ResponseFileUsedEventArgs)
                 {
                     // switch to serialization methods that we provide in this file
                     // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
@@ -536,6 +593,17 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.ProjectImportedEvent => new ProjectImportedEventArgs(),
                 LoggingEventType.TargetSkipped => new TargetSkippedEventArgs(),
                 LoggingEventType.Telemetry => new TelemetryEventArgs(),
+                LoggingEventType.ExtendedCustomEvent => new ExtendedCustomBuildEventArgs(),
+                LoggingEventType.ExtendedBuildErrorEvent => new ExtendedBuildErrorEventArgs(),
+                LoggingEventType.ExtendedBuildWarningEvent => new ExtendedBuildWarningEventArgs(),
+                LoggingEventType.ExtendedBuildMessageEvent => new ExtendedBuildMessageEventArgs(),
+                LoggingEventType.ExternalProjectStartedEvent => new ExternalProjectStartedEventArgs(null, null, null, null, null),
+                LoggingEventType.ExternalProjectFinishedEvent => new ExternalProjectFinishedEventArgs(null, null, null, null, false),
+                LoggingEventType.CriticalBuildMessage => new CriticalBuildMessageEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),
+                LoggingEventType.MetaprojectGenerated => new MetaprojectGeneratedEventArgs(null, null, null),
+                LoggingEventType.PropertyInitialValueSet => new PropertyInitialValueSetEventArgs(),
+                LoggingEventType.PropertyReassignment => new PropertyReassignmentEventArgs(),
+                LoggingEventType.UninitializedPropertyRead => new UninitializedPropertyReadEventArgs(),
 #endif
                 _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
             };
@@ -573,6 +641,15 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.ProjectStartedEvent;
             }
+            else if (eventType == typeof(ExternalProjectStartedEventArgs))
+            {
+                return LoggingEventType.ExternalProjectStartedEvent;
+            }
+            else if (eventType == typeof(ExternalProjectFinishedEventArgs))
+            {
+                return LoggingEventType.ExternalProjectFinishedEvent;
+            }
+
 #if !TASKHOST
             else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))
             {
@@ -598,6 +675,42 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.AssemblyLoadEvent;
             }
+            else if (eventType == typeof(ExtendedCustomBuildEventArgs))
+            {
+                return LoggingEventType.ExtendedCustomEvent;
+            }
+            else if (eventType == typeof(ExtendedBuildErrorEventArgs))
+            {
+                return LoggingEventType.ExtendedBuildErrorEvent;
+            }
+            else if (eventType == typeof(ExtendedBuildWarningEventArgs))
+            {
+                return LoggingEventType.ExtendedBuildWarningEvent;
+            }
+            else if (eventType == typeof(ExtendedBuildMessageEventArgs))
+            {
+                return LoggingEventType.ExtendedBuildMessageEvent;
+            }
+            else if (eventType == typeof(CriticalBuildMessageEventArgs))
+            {
+                return LoggingEventType.CriticalBuildMessage;
+            }
+            else if (eventType == typeof(MetaprojectGeneratedEventArgs))
+            {
+                return LoggingEventType.MetaprojectGenerated;
+            }
+            else if (eventType == typeof(PropertyInitialValueSetEventArgs))
+            {
+                return LoggingEventType.PropertyInitialValueSet;
+            }
+            else if (eventType == typeof(PropertyReassignmentEventArgs))
+            {
+                return LoggingEventType.PropertyReassignment;
+            }
+            else if (eventType == typeof(UninitializedPropertyReadEventArgs))
+            {
+                return LoggingEventType.UninitializedPropertyRead;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
@@ -690,12 +803,6 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
                 case LoggingEventType.BuildWarningEvent:
                     WriteBuildWarningEventToStream((BuildWarningEventArgs)buildEvent, translator);
                     break;
-                case LoggingEventType.ProjectStartedEvent:
-                    WriteExternalProjectStartedEventToStream((ExternalProjectStartedEventArgs)buildEvent, translator);
-                    break;
-                case LoggingEventType.ProjectFinishedEvent:
-                    WriteExternalProjectFinishedEventToStream((ExternalProjectFinishedEventArgs)buildEvent, translator);
-                    break;
                 case LoggingEventType.EnvironmentVariableReadEvent:
                     WriteEnvironmentVariableReadEventArgs((EnvironmentVariableReadEventArgs)buildEvent, translator);
                     break;
@@ -712,37 +819,20 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
         private void WriteEnvironmentVariableReadEventArgs(EnvironmentVariableReadEventArgs environmentVariableReadEventArgs, ITranslator translator)
         {
             string name = environmentVariableReadEventArgs.EnvironmentVariableName;
+            MessageImportance importance = environmentVariableReadEventArgs.Importance;
+
             translator.Translate(ref name);
-            BuildEventContext context = environmentVariableReadEventArgs.BuildEventContext;
+            translator.TranslateEnum(ref importance, (int)importance);
+
 #if !CLR2COMPATIBILITY
+            DateTime timestamp = environmentVariableReadEventArgs.RawTimestamp;
+            BuildEventContext context = environmentVariableReadEventArgs.BuildEventContext;
+
+            translator.Translate(ref timestamp);
             translator.Translate(ref context);
 #endif
         }
 
-        /// <summary>
-        /// Serialize ExternalProjectFinished Event Argument to the stream
-        /// </summary>
-        private void WriteExternalProjectFinishedEventToStream(ExternalProjectFinishedEventArgs externalProjectFinishedEventArgs, ITranslator translator)
-        {
-            string projectFile = externalProjectFinishedEventArgs.ProjectFile;
-            translator.Translate(ref projectFile);
-
-            bool succeeded = externalProjectFinishedEventArgs.Succeeded;
-            translator.Translate(ref succeeded);
-        }
-
-        /// <summary>
-        /// ExternalProjectStartedEvent
-        /// </summary>
-        private void WriteExternalProjectStartedEventToStream(ExternalProjectStartedEventArgs externalProjectStartedEventArgs, ITranslator translator)
-        {
-            string projectFile = externalProjectStartedEventArgs.ProjectFile;
-            translator.Translate(ref projectFile);
-
-            string targetNames = externalProjectStartedEventArgs.TargetNames;
-            translator.Translate(ref targetNames);
-        }
-
         #region Writes to Stream
 
         /// <summary>
@@ -829,7 +919,13 @@ private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEv
         private void WriteResponseFileUsedEventToStream(ResponseFileUsedEventArgs responseFileUsedEventArgs, ITranslator translator)
         {
             string filePath = responseFileUsedEventArgs.ResponseFilePath;
+
             translator.Translate(ref filePath);
+
+#if !CLR2COMPATIBILITY
+            DateTime timestamp = responseFileUsedEventArgs.RawTimestamp;
+            translator.Translate(ref timestamp);
+#endif
         }
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
@@ -1066,8 +1162,6 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
             {
                 LoggingEventType.TaskCommandLineEvent => ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.BuildErrorEvent => ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.ResponseFileUsedEvent => ReadResponseFileUsedEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),
@@ -1082,60 +1176,24 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
         private EnvironmentVariableReadEventArgs ReadEnvironmentVariableReadEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
         {
             string environmentVariableName = null;
+            MessageImportance importance = default;
+
             translator.Translate(ref environmentVariableName);
-            BuildEventContext context = null;
+            translator.TranslateEnum(ref importance, (int)importance);
+
+            EnvironmentVariableReadEventArgs args = new(environmentVariableName, message, helpKeyword, senderName, importance);
+
 #if !CLR2COMPATIBILITY
+            DateTime timestamp = default;
+            BuildEventContext context = null;
+            translator.Translate(ref timestamp);
             translator.Translate(ref context);
-#endif
-            EnvironmentVariableReadEventArgs args = new(environmentVariableName, message);
+            args.RawTimestamp = timestamp;
             args.BuildEventContext = context;
+#endif
             return args;
         }
 
-        /// <summary>
-        /// Read and reconstruct a ProjectFinishedEventArgs from the stream
-        /// </summary>
-        private ExternalProjectFinishedEventArgs ReadExternalProjectFinishedEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
-        {
-            string projectFile = null;
-            translator.Translate(ref projectFile);
-
-            bool succeeded = true;
-            translator.Translate(ref succeeded);
-
-            ExternalProjectFinishedEventArgs buildEvent =
-                new ExternalProjectFinishedEventArgs(
-                    message,
-                    helpKeyword,
-                    senderName,
-                    projectFile,
-                    succeeded);
-
-            return buildEvent;
-        }
-
-        /// <summary>
-        /// Read and reconstruct a ProjectStartedEventArgs from the stream
-        /// </summary>
-        private ExternalProjectStartedEventArgs ReadExternalProjectStartedEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
-        {
-            string projectFile = null;
-            translator.Translate(ref projectFile);
-
-            string targetNames = null;
-            translator.Translate(ref targetNames);
-
-            ExternalProjectStartedEventArgs buildEvent =
-                new ExternalProjectStartedEventArgs(
-                    message,
-                    helpKeyword,
-                    senderName,
-                    projectFile,
-                    targetNames);
-
-            return buildEvent;
-        }
-
         /// <summary>
         /// Read and reconstruct a BuildWarningEventArgs from the stream
         /// </summary>
@@ -1256,6 +1314,14 @@ private ResponseFileUsedEventArgs ReadResponseFileUsedEventFromStream(ITranslato
             string responseFilePath = String.Empty;
             translator.Translate(ref responseFilePath);
             ResponseFileUsedEventArgs buildEvent = new ResponseFileUsedEventArgs(responseFilePath);
+
+#if !CLR2COMPATIBILITY
+            DateTime timestamp = default;
+            translator.Translate(ref timestamp);
+            buildEvent.RawTimestamp = timestamp;
+#endif
+
+
             return buildEvent;
         }
 
diff --git a/src/Shared/ReadOnlyEmptyDictionary.cs b/src/Shared/ReadOnlyEmptyDictionary.cs
index e4b1662bdeb..46b1b2738e9 100644
--- a/src/Shared/ReadOnlyEmptyDictionary.cs
+++ b/src/Shared/ReadOnlyEmptyDictionary.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Collections
     /// </summary>
     /// <typeparam name="K">Key</typeparam>
     /// <typeparam name="V">Value</typeparam>
-    internal class ReadOnlyEmptyDictionary<K, V> : IDictionary<K, V>, IDictionary
+    internal class ReadOnlyEmptyDictionary<K, V> : IDictionary<K, V>, IReadOnlyDictionary<K, V>, IDictionary
     {
         /// <summary>
         /// The single instance
@@ -127,6 +127,22 @@ ICollection IDictionary.Values
             get { return (ICollection)((IDictionary<K, V>)this).Values; }
         }
 
+        /// <summary>
+        /// Keys
+        /// </summary>
+        IEnumerable<K> IReadOnlyDictionary<K, V>.Keys
+        {
+            get { return Keys; }
+        }
+
+        /// <summary>
+        /// Values
+        /// </summary>
+        IEnumerable<V> IReadOnlyDictionary<K, V>.Values
+        {
+            get { return Values; }
+        }
+
         /// <summary>
         /// Indexer
         /// </summary>
@@ -292,3 +308,22 @@ public void CopyTo(System.Array array, int index)
         }
     }
 }
+
+#if NET35
+namespace System.Collections.Generic
+{
+    public interface IReadOnlyCollection<T> : IEnumerable<T>
+    {
+        int Count { get; }
+    }
+
+    public interface IReadOnlyDictionary<TKey, TValue> : IReadOnlyCollection<KeyValuePair<TKey, TValue>>
+    {
+        TValue this[TKey key] { get; }
+        IEnumerable<TKey> Keys { get; }
+        IEnumerable<TValue> Values { get; }
+        bool ContainsKey(TKey key);
+        bool TryGetValue(TKey key, out TValue value);
+    }
+}
+#endif
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index 69187a226e3..9fb94751e2f 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -66,6 +66,9 @@
   <data name="ExpectedEventToBeSerializable" Visibility="Public">
     <value>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</value>
   </data>
+  <data name="DeprecatedEventSerialization" Visibility="Public">
+    <value>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</value>
+  </data>
   <data name="FileLocation" Visibility="Public">
     <value>{0} ({1},{2})</value>
     <comment>A file location to be embedded in a string.</comment>
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 984f025f954..cdffb07fb6f 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: Bylo nalezeno konfliktní sestavení pro sestavení úlohy {0} v umístění {1}.</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Použití nezabezpečeného BinaryFormatteru během serializace vlastního typu události {0}. Tento způsob bude brzy zastaralý. Místo toho prosím použijte Extended*EventArgs. Další informace najdete zde: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Očekávalo se, že typ události {0} bude možné serializovat pomocí serializátoru .NET. Událost nebylo možné serializovat a byla ignorována.</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: Úloha se pokusila přihlásit před tím, než byla inicializována. Zpráva: {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index b47a86b0485..9faa13d7602 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: Eine mit der Aufgabenassembly "{0}" in Konflikt stehende Assembly wurde in "{1}" gefunden.</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Verwendung eines unsicheren BinaryFormatter während der Serialisierung des benutzerdefinierten Ereignistyps '{0}'. Dies wird in Kürze eingestellt. Verwenden Sie stattdessen Extended*EventArgs. Weitere Informationen: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Es wurde erwartet, dass der Ereignistyp "{0}" mithilfe des .NET-Serialisierers serialisierbar ist. Das Ereignis war nicht serialisierbar und wurde ignoriert.</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: Die Aufgabe hat versucht, eine Protokollierung durchzuführen, bevor sie initialisiert wurde. Meldung: {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index c456052efd7..dc91f2bd810 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: Se detectó un ensamblado conflictivo para el ensamblado de tarea "{0}" en "{1}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Uso de BinaryFormatter no seguro durante la serialización del tipo de evento personalizado "{0}". Esto estará en desuso pronto. En su lugar, use Extended*EventArgs. Más información: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Se esperaba que el tipo de evento "{0}" fuera serializable con el serializador .NET. El evento no era serializable y se ha omitido.</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: La tarea intentó registrarse antes de inicializarse. El mensaje era: {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 09764b47710..c812aa833db 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: un assembly en conflit avec l'assembly de tâche "{0}" a été trouvé sur "{1}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Utilisation de BinaryFormatter non sécurisé lors de la sérialisation d’un type d’événement personnalisé '{0}'. Cette opération sera bientôt déconseillée. Utilisez Extended*EventArgs à la place. Plus d’informations : https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Le type d'événement "{0}" devait être sérialisable à l'aide du sérialiseur .NET. L'événement n'était pas sérialisable et a été ignoré.</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: La tâche a tenté d'ouvrir une session avant d'être initialisée. Le message était le suivant : {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 09f8b2fc566..2ed5a530e64 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: rilevato un assembly in conflitto per l'assembly dell'attività "{0}" in "{1}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Utilizzo di BinaryFormatter non sicuro durante la serializzazione del tipo di evento personalizzato '{0}'. Questa operazione verrà presto deprecata. Usare invece Extended*EventArgs. Altre informazioni: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">È previsto un tipo di evento "{0}" serializzabile con il serializzatore .NET. L'evento non era serializzabile ed è stato ignorato.</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: tentativo di registrazione prima dell'inizializzazione dell'attività. Messaggio: {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index 49060c71b05..0d17c4c2a44 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: タスク アセンブリ "{0}" に対して競合しているアセンブリが "{1}" で見つかりました。</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">カスタム イベントの種類 '{0}' のシリアル化中のセキュリティで保護されていない BinaryFormatter の使用。これは間もなく非推奨になります。代わりに Extended*EventArgs を使用してください。詳細情報: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">イベントの種類 "{0}" は .NET シリアライザーを使用してシリアル化可能であることが想定されていましたが、シリアル化可能でなかったため無視されました。</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: タスクは、初期化される前にログを記録しようとしました。メッセージ: {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 3a16af966cc..e8bbabfd3e9 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: 작업 어셈블리 "{0}"과(와) 충돌하는 어셈블리가 "{1}"에 있습니다.</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">사용자 지정 이벤트 유형 '{0}'의 직렬화 중 보안되지 않은 BinaryFormatter 사용. 이 항목은 곧 지원 중단될 예정입니다. 대신 Extended*EventArgs를 사용하세요. 추가 정보: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">이벤트 유형 "{0}"은(는) .NET serializer를 사용하여 serialize할 수 있어야 합니다. 이 이벤트는 serialize할 수 없으므로 무시되었습니다.</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: 작업을 초기화하기 전에 로깅하려고 했습니다. 메시지: {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 18935fea285..272e8877783 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: Zestaw, który wywołuje konflikt z zestawem zadania „{0}”, został znaleziony w „{1}”.</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Użycie niezabezpieczonego formatu BinaryFormatter podczas serializacji niestandardowego typu zdarzenia „{0}”. Wkrótce ta funkcja będzie przestarzała. Zamiast tego należy użyć Extended*EventArgs. Więcej informacji: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Oczekiwano, że zdarzenie typu „{0}” będzie uszeregowane przy użyciu serializatora platformy .NET. Zdarzenie nie może podlegać szeregowaniu, dlatego zostało zignorowane.</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: Zadanie podjęło próbę zarejestrowania przed zainicjowaniem. Pojawił się komunikat: {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 38920bf6342..3b4308d3b6d 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: Foi encontrado um assembly conflitante no assembly da tarefa "{0}" em "{1}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Uso de BinaryFormatter não seguro durante a serialização do tipo de evento personalizado '{0}'. Isso será obsoleto em breve. Em vez disso, use Extended*EventArgs. Mais informações: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Era esperado que o tipo de evento "{0}" fosse serializável usando o serializador .NET. O evento não era serializável e foi ignorado.</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: A tarefa tentou fazer o registro antes de ser inicializada. A mensagem era: {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index 73e4cd4a500..eebaa4e6caa 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: в "{1}" обнаружена сборка, конфликтующая со сборкой задачи "{0}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Использование небезопасного BinaryFormatter во время сериализации настраиваемого типа события "{0}". Скоро этот параметр станет нерекомендуемым. Вместо этого используйте Extended*EventArgs. Дополнительные сведения: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">Необходимо, чтобы тип события "{0}" был сериализуемым с помощью сериализатора .NET. Событие не было сериализуемым и было пропущено.</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: задачей предпринята попытка вести журнал до своей инициализации. Сообщение: {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index b5ebcf35473..775a8cc8718 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: "{0}" görev derlemesi için "{1}" konumunda çakışan derleme bulundu.</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">'{0}' özel olay türünü serileştirme işlemi sırasında güvenli olmayan BinaryFormatter kullanımı. Bu özellik yakında kullanımdan kaldırılacak. Lütfen bunun yerine Extended*EventArgs özelliğini kullanın. Daha fazla bilgi: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">"{0}" olay türünün .NET serileştiricisi kullanılarak serileştirilebilir olması bekleniyordu. Olay serileştirilebilir değildi ve yoksayıldı.</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: Görev başlatılmadan önce günlüğe yazmaya çalıştı. İleti: {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index fe57cf48407..7e9f0b6897d 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: 在“{1}”处发现了与任务程序集“{0}”冲突的程序集。</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">在自定义事件类型“{0}”的序列化期间使用了不安全的 BinaryFormatter。这将很快被弃用。请改用 Extended*EventArgs。详细信息: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">事件类型“{0}”应可以使用 .NET 序列化程序进行序列化。此事件不可序列化，已忽略它。</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: 任务尚未初始化就尝试进行日志记录。消息为: {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index f8c2c977e3a..94fd6cd9fcc 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -22,6 +22,11 @@
         <target state="translated">MSB4008: 已在 "{1}" 中發現工作組件 "{0}" 的衝突組件。</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DeprecatedEventSerialization">
+        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">自訂事件類型 '{0}' 序列化期間使用不安全的 BinaryFormatter。即將取代此項目。請改用 Extended*EventArgs。更多資訊: https://aka.ms/msbuild/eventargs</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
         <target state="translated">事件類型 "{0}" 應該可以使用 .NET 序列化程式序列化。此事件不可序列化，已略過。</target>
@@ -34,7 +39,7 @@
       </trans-unit>
       <trans-unit id="LoggingBeforeTaskInitialization">
         <source>MSB6005: Task attempted to log before it was initialized. Message was: {0}</source>
-        <target state="new">MSB6005: Task attempted to log before it was initialized. Message was: {0}</target>
+        <target state="translated">MSB6005: 工作在初始化之前就嘗試記錄。訊息為: {0}</target>
         <note>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</note>
       </trans-unit>
       <trans-unit id="ModifyingTaskHostEnvironmentHeader">
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index cf4c7934afe..4595adaba62 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -24,47 +24,37 @@ namespace Microsoft.Build.BackEnd
     internal enum TaskParameterType
     {
         /// <summary>
-        /// Parameter is null
+        /// Parameter is null.
         /// </summary>
         Null,
 
         /// <summary>
-        /// Parameter is a string
+        /// Parameter is of a type described by a <see cref="TypeCode"/>.
         /// </summary>
-        String,
+        PrimitiveType,
 
         /// <summary>
-        /// Parameter is an array of strings
+        /// Parameter is an array of a type described by a <see cref="TypeCode"/>.
         /// </summary>
-        StringArray,
+        PrimitiveTypeArray,
 
         /// <summary>
-        /// Parameter is <c>true</c> or <c>false</c>.
-        /// </summary>
-        Bool,
-
-        /// <summary>
-        /// Parameter is an <see langword="int"/>.
-        /// </summary>
-        Int,
-
-        /// <summary>
-        /// Parameter is a value type.  Note:  Must be serializable
+        /// Parameter is a value type.  Note:  Must be <see cref="IConvertible"/>.
         /// </summary>
         ValueType,
 
         /// <summary>
-        /// Parameter is an array of value types.  Note:  Must be serializable.
+        /// Parameter is an array of value types.  Note:  Must be <see cref="IConvertible"/>.
         /// </summary>
         ValueTypeArray,
 
         /// <summary>
-        /// Parameter is an ITaskItem
+        /// Parameter is an ITaskItem.
         /// </summary>
         ITaskItem,
 
         /// <summary>
-        /// Parameter is an array of ITaskItems
+        /// Parameter is an array of ITaskItems.
         /// </summary>
         ITaskItemArray,
 
@@ -72,7 +62,7 @@ internal enum TaskParameterType
         /// An invalid parameter -- the value of this parameter contains the exception
         /// that is thrown when trying to access it.
         /// </summary>
-        Invalid
+        Invalid,
     }
 
     /// <summary>
@@ -86,10 +76,15 @@ internal class TaskParameter :
         ITranslatable
     {
         /// <summary>
-        /// The TaskParameterType of the wrapped parameter
+        /// The TaskParameterType of the wrapped parameter.
         /// </summary>
         private TaskParameterType _parameterType;
 
+        /// <summary>
+        /// The <see cref="TypeCode"/> of the wrapped parameter if it's a primitive type.
+        /// </summary>
+        private TypeCode _parameterTypeCode;
+
         /// <summary>
         /// The actual task parameter that we're wrapping
         /// </summary>
@@ -124,9 +119,11 @@ public TaskParameter(object wrappedParameter)
 
             if (wrappedParameterType.IsArray)
             {
-                if (wrappedParameterType == typeof(string[]))
+                TypeCode typeCode = Type.GetTypeCode(wrappedParameterType.GetElementType());
+                if (typeCode != TypeCode.Object && typeCode != TypeCode.DBNull)
                 {
-                    _parameterType = TaskParameterType.StringArray;
+                    _parameterType = TaskParameterType.PrimitiveTypeArray;
+                    _parameterTypeCode = typeCode;
                     _wrappedParameter = wrappedParameter;
                 }
                 else if (typeof(ITaskItem[]).GetTypeInfo().IsAssignableFrom(wrappedParameterType.GetTypeInfo()))
@@ -158,37 +155,27 @@ public TaskParameter(object wrappedParameter)
             else
             {
                 // scalar parameter
-                if (wrappedParameterType == typeof(string))
-                {
-                    _parameterType = TaskParameterType.String;
-                    _wrappedParameter = wrappedParameter;
-                }
-                else if (typeof(ITaskItem).IsAssignableFrom(wrappedParameterType))
-                {
-                    _parameterType = TaskParameterType.ITaskItem;
-                    _wrappedParameter = CreateNewTaskItemFrom((ITaskItem)wrappedParameter);
-                }
                 // Preserve enums as strings: the enum type itself may not
                 // be loaded on the other side of the serialization, but
                 // we would convert to string anyway after pulling the
                 // task output into a property or item.
-                else if (wrappedParameterType.IsEnum)
+                if (wrappedParameterType.IsEnum)
                 {
-                    _parameterType = TaskParameterType.String;
-                    _wrappedParameter = (string)Convert.ChangeType(wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+                    wrappedParameter = (string)Convert.ChangeType(wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+                    wrappedParameterType = typeof(string);
                 }
-                // Also stringify known common value types, to avoid calling
-                // TranslateDotNet when they'll just be stringified on the
-                // output side
-                else if (wrappedParameterType == typeof(bool))
+
+                TypeCode typeCode = Type.GetTypeCode(wrappedParameterType);
+                if (typeCode != TypeCode.Object && typeCode != TypeCode.DBNull)
                 {
-                    _parameterType = TaskParameterType.Bool;
+                    _parameterType = TaskParameterType.PrimitiveType;
+                    _parameterTypeCode = typeCode;
                     _wrappedParameter = wrappedParameter;
                 }
-                else if (wrappedParameterType == typeof(int))
+                else if (typeof(ITaskItem).IsAssignableFrom(wrappedParameterType))
                 {
-                    _parameterType = TaskParameterType.Int;
-                    _wrappedParameter = wrappedParameter;
+                    _parameterType = TaskParameterType.ITaskItem;
+                    _wrappedParameter = CreateNewTaskItemFrom((ITaskItem)wrappedParameter);
                 }
                 else if (wrappedParameterType.GetTypeInfo().IsValueType)
                 {
@@ -203,31 +190,26 @@ public TaskParameter(object wrappedParameter)
         }
 
         /// <summary>
-        /// Constructor for deserialization
+        /// Constructor for deserialization.
         /// </summary>
         private TaskParameter()
         {
         }
 
         /// <summary>
-        /// The TaskParameterType of the wrapped parameter
+        /// The TaskParameterType of the wrapped parameter.
         /// </summary>
-        public TaskParameterType ParameterType
-        {
-            [DebuggerStepThrough]
-            get
-            { return _parameterType; }
-        }
+        public TaskParameterType ParameterType => _parameterType;
 
         /// <summary>
-        /// The actual task parameter that we're wrapping
+        /// The <see cref="TypeCode"/> of the wrapper parameter if it's a primitive or array of primitives.
         /// </summary>
-        public object WrappedParameter
-        {
-            [DebuggerStepThrough]
-            get
-            { return _wrappedParameter; }
-        }
+        public TypeCode ParameterTypeCode => _parameterTypeCode;
+
+        /// <summary>
+        /// The actual task parameter that we're wrapping.
+        /// </summary>
+        public object WrappedParameter => _wrappedParameter;
 
         /// <summary>
         /// TaskParameter's ToString should just pass through to whatever it's wrapping.
@@ -242,44 +224,38 @@ public override string ToString()
         /// </summary>
         public void Translate(ITranslator translator)
         {
-            translator.TranslateEnum<TaskParameterType>(ref _parameterType, (int)_parameterType);
+            translator.TranslateEnum(ref _parameterType, (int)_parameterType);
 
             switch (_parameterType)
             {
                 case TaskParameterType.Null:
                     _wrappedParameter = null;
                     break;
-                case TaskParameterType.String:
-                    string stringParam = (string)_wrappedParameter;
-                    translator.Translate(ref stringParam);
-                    _wrappedParameter = stringParam;
+                case TaskParameterType.PrimitiveType:
+                    TranslatePrimitiveType(translator);
                     break;
-                case TaskParameterType.StringArray:
-                    string[] stringArrayParam = (string[])_wrappedParameter;
-                    translator.Translate(ref stringArrayParam);
-                    _wrappedParameter = stringArrayParam;
+                case TaskParameterType.PrimitiveTypeArray:
+                    TranslatePrimitiveTypeArray(translator);
                     break;
-                case TaskParameterType.Bool:
-                    bool boolParam = _wrappedParameter switch
+                case TaskParameterType.ValueType:
+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
                     {
-                        bool hadValue => hadValue,
-                        _ => default,
-                    };
-                    translator.Translate(ref boolParam);
-                    _wrappedParameter = boolParam;
-                    break;
-                case TaskParameterType.Int:
-                    int intParam = _wrappedParameter switch
+                        TranslateValueType(translator);
+                    }
+                    else
                     {
-                        int hadValue => hadValue,
-                        _ => default,
-                    };
-                    translator.Translate(ref intParam);
-                    _wrappedParameter = intParam;
+                        translator.TranslateDotNet(ref _wrappedParameter);
+                    }
                     break;
-                case TaskParameterType.ValueType:
                 case TaskParameterType.ValueTypeArray:
-                    translator.TranslateDotNet(ref _wrappedParameter);
+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+                    {
+                        TranslateValueTypeArray(translator);
+                    }
+                    else
+                    {
+                        translator.TranslateDotNet(ref _wrappedParameter);
+                    }
                     break;
                 case TaskParameterType.ITaskItem:
                     TranslateITaskItem(translator);
@@ -537,6 +513,223 @@ private bool TranslateNullable<T>(ITranslator translator, T value)
             return haveRef;
         }
 
+        /// <summary>
+        /// Serializes or deserializes a primitive type value wrapped by this <see cref="TaskParameter"/>.
+        /// </summary>
+        private void TranslatePrimitiveType(ITranslator translator)
+        {
+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);
+
+            switch (_parameterTypeCode)
+            {
+                case TypeCode.Boolean:
+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;
+                    translator.Translate(ref boolParam);
+                    _wrappedParameter = boolParam;
+                    break;
+
+                case TypeCode.Byte:
+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;
+                    translator.Translate(ref byteParam);
+                    _wrappedParameter = byteParam;
+                    break;
+
+                case TypeCode.Int16:
+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;
+                    translator.Translate(ref shortParam);
+                    _wrappedParameter = shortParam;
+                    break;
+
+                case TypeCode.UInt16:
+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;
+                    translator.Translate(ref ushortParam);
+                    _wrappedParameter = ushortParam;
+                    break;
+
+                case TypeCode.Int64:
+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;
+                    translator.Translate(ref longParam);
+                    _wrappedParameter = longParam;
+                    break;
+
+                case TypeCode.Double:
+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;
+                    translator.Translate(ref doubleParam);
+                    _wrappedParameter = doubleParam;
+                    break;
+
+                case TypeCode.String:
+                    string stringParam = (string)_wrappedParameter;
+                    translator.Translate(ref stringParam);
+                    _wrappedParameter = stringParam;
+                    break;
+
+                case TypeCode.DateTime:
+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;
+                    translator.Translate(ref dateTimeParam);
+                    _wrappedParameter = dateTimeParam;
+                    break;
+
+                default:
+                    // Fall back to converting to/from string for types that don't have ITranslator support.
+                    string stringValue = null;
+                    if (translator.Mode == TranslationDirection.WriteToStream)
+                    {
+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+                    }
+
+                    translator.Translate(ref stringValue);
+
+                    if (translator.Mode == TranslationDirection.ReadFromStream)
+                    {
+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);
+                    }
+                    break;
+            }
+        }
+
+        /// <summary>
+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref="TaskParameter"/>.
+        /// </summary>
+        private void TranslatePrimitiveTypeArray(ITranslator translator)
+        {
+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);
+
+            switch (_parameterTypeCode)
+            {
+                case TypeCode.Boolean:
+                    bool[] boolArrayParam = (bool[])_wrappedParameter;
+                    translator.Translate(ref boolArrayParam);
+                    _wrappedParameter = boolArrayParam;
+                    break;
+
+                case TypeCode.Int32:
+                    int[] intArrayParam = (int[])_wrappedParameter;
+                    translator.Translate(ref intArrayParam);
+                    _wrappedParameter = intArrayParam;
+                    break;
+
+                case TypeCode.String:
+                    string[] stringArrayParam = (string[])_wrappedParameter;
+                    translator.Translate(ref stringArrayParam);
+                    _wrappedParameter = stringArrayParam;
+                    break;
+
+                default:
+                    // Fall back to converting to/from string for types that don't have ITranslator support.
+                    if (translator.Mode == TranslationDirection.WriteToStream)
+                    {
+                        Array array = (Array)_wrappedParameter;
+                        int length = array.Length;
+
+                        translator.Translate(ref length);
+
+                        for (int i = 0; i < length; i++)
+                        {
+                            string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);
+                            translator.Translate(ref valueString);
+                        }
+                    }
+                    else
+                    {
+                        Type elementType = _parameterTypeCode switch
+                        {
+                            TypeCode.Char => typeof(char),
+                            TypeCode.SByte => typeof(sbyte),
+                            TypeCode.Byte => typeof(byte),
+                            TypeCode.Int16 => typeof(short),
+                            TypeCode.UInt16 => typeof(ushort),
+                            TypeCode.UInt32 => typeof(uint),
+                            TypeCode.Int64 => typeof(long),
+                            TypeCode.UInt64 => typeof(ulong),
+                            TypeCode.Single => typeof(float),
+                            TypeCode.Double => typeof(double),
+                            TypeCode.Decimal => typeof(decimal),
+                            TypeCode.DateTime => typeof(DateTime),
+                            _ => throw new NotImplementedException(),
+                        };
+
+                        int length = 0;
+                        translator.Translate(ref length);
+
+                        Array array = Array.CreateInstance(elementType, length);
+                        for (int i = 0; i < length; i++)
+                        {
+                            string valueString = null;
+                            translator.Translate(ref valueString);
+                            array.SetValue(Convert.ChangeType(valueString, _parameterTypeCode, CultureInfo.InvariantCulture), i);
+                        }
+                        _wrappedParameter = array;
+                    }
+                    break;
+            }
+        }
+
+        /// <summary>
+        /// Serializes or deserializes the value type instance wrapped by this <see cref="TaskParameter"/>.
+        /// </summary>
+        /// <remarks>
+        /// The value type is converted to/from string using the <see cref="Convert"/> class. Note that we require
+        /// task parameter types to be <see cref="IConvertible"/> so this conversion is guaranteed to work for parameters
+        /// that have made it this far.
+        /// </remarks>
+        private void TranslateValueType(ITranslator translator)
+        {
+            string valueString = null;
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                valueString = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+            }
+
+            translator.Translate(ref valueString);
+
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                // We don't know how to convert the string back to the original value type. This is fine because output
+                // task parameters are anyway converted to strings by the engine (see TaskExecutionHost.GetValueOutputs)
+                // and input task parameters of custom value types are not supported.
+                _wrappedParameter = valueString;
+            }
+        }
+
+        /// <summary>
+        /// Serializes or deserializes the value type array instance wrapped by this <see cref="TaskParameter"/>.
+        /// </summary>
+        /// <remarks>
+        /// The array is assumed to be non-null.
+        /// </remarks>
+        private void TranslateValueTypeArray(ITranslator translator)
+        {
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                Array array = (Array)_wrappedParameter;
+                int length = array.Length;
+
+                translator.Translate(ref length);
+
+                for (int i = 0; i < length; i++)
+                {
+                    string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);
+                    translator.Translate(ref valueString);
+                }
+            }
+            else
+            {
+                int length = 0;
+                translator.Translate(ref length);
+
+                string[] stringArray = new string[length];
+                for (int i = 0; i < length; i++)
+                {
+                    translator.Translate(ref stringArray[i]);
+                }
+
+                // We don't know how to convert the string array back to the original value type array.
+                // This is fine because the engine would eventually convert it to strings anyway.
+                _wrappedParameter = stringArray;
+            }
+        }
+
         /// <summary>
         /// Super simple ITaskItem derivative that we can use as a container for read items.
         /// </summary>
@@ -856,6 +1049,14 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataLazy()
                     yield return unescaped;
                 }
             }
+
+            public void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
+            {
+                foreach (KeyValuePair<string, string> kvp in metadata)
+                {
+                    SetMetadata(kvp.Key, kvp.Value);
+                }
+            }
         }
     }
 }
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index 8aa828b533c..5efa28ce676 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -679,68 +679,6 @@ public void VerifyReverseVersionComparer()
             Assert.True(assemblies[2].Equals(y));
         }
 
-        [Theory]
-        [InlineData("System.Xml")]
-        [InlineData("System.XML, Version=2.0.0.0")]
-        [InlineData("System.Xml, Culture=de-DE")]
-        [InlineData("System.Xml, Version=10.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a, Retargetable=Yes")]
-        [InlineData("System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
-        public void VerifyAssemblyNameExSerialization(string assemblyName)
-        {
-            AssemblyNameExtension assemblyNameOriginal = new AssemblyNameExtension(assemblyName);
-            AssemblyNameExtension assemblyNameDeserialized;
-
-            byte[] bytes;
-
-            using (MemoryStream ms = new MemoryStream())
-            {
-                BinaryFormatter formatter = new BinaryFormatter();
-                formatter.Serialize(ms, assemblyNameOriginal);
-
-                bytes = ms.ToArray();
-            }
-
-            using (MemoryStream ms = new MemoryStream(bytes))
-            {
-                BinaryFormatter formatter = new BinaryFormatter();
-                assemblyNameDeserialized = (AssemblyNameExtension)formatter.Deserialize(ms);
-            }
-
-            assemblyNameDeserialized.ShouldBe(assemblyNameOriginal);
-        }
-
-        [Fact]
-        public void VerifyAssemblyNameExSerializationWithRemappedFrom()
-        {
-            AssemblyNameExtension assemblyNameOriginal = new AssemblyNameExtension("System.Xml, Version=10.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
-            AssemblyNameExtension assemblyRemappedFrom = new AssemblyNameExtension("System.Xml, Version=9.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
-            assemblyRemappedFrom.MarkImmutable();
-            assemblyNameOriginal.AddRemappedAssemblyName(assemblyRemappedFrom);
-            assemblyNameOriginal.RemappedFromEnumerator.Count().ShouldBe(1);
-
-            AssemblyNameExtension assemblyNameDeserialized;
-
-            byte[] bytes;
-
-            using (MemoryStream ms = new MemoryStream())
-            {
-                BinaryFormatter formatter = new BinaryFormatter();
-                formatter.Serialize(ms, assemblyNameOriginal);
-
-                bytes = ms.ToArray();
-            }
-
-            using (MemoryStream ms = new MemoryStream(bytes))
-            {
-                BinaryFormatter formatter = new BinaryFormatter();
-                assemblyNameDeserialized = (AssemblyNameExtension)formatter.Deserialize(ms);
-            }
-
-            assemblyNameDeserialized.Equals(assemblyNameOriginal).ShouldBeTrue();
-            assemblyNameDeserialized.RemappedFromEnumerator.Count().ShouldBe(1);
-            assemblyNameDeserialized.RemappedFromEnumerator.First().ShouldBe(assemblyRemappedFrom);
-        }
-
         [Theory]
         [InlineData("System.Xml")]
         [InlineData("System.XML, Version=2.0.0.0")]
diff --git a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
index 9589762b100..8beef1b543f 100644
--- a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
+++ b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
@@ -192,53 +192,5 @@ public void CloneWritesNotVisibleToOriginal()
             Assert.Equal("1", dictionary["test"]);
             Assert.Equal("2", clone["test"]);
         }
-
-        /// <summary>
-        /// Serialize basic case
-        /// </summary>
-        [Fact]
-        public void SerializeDeserialize()
-        {
-            CopyOnWriteDictionary<string> dictionary = new CopyOnWriteDictionary<string>();
-            dictionary.Add("Key1", "1");
-
-            using (MemoryStream stream = new MemoryStream())
-            {
-                BinaryFormatter formatter = new BinaryFormatter();
-
-                formatter.Serialize(stream, dictionary);
-                stream.Position = 0;
-
-                var dictionary2 = (CopyOnWriteDictionary<string>)formatter.Deserialize(stream);
-
-                Assert.Equal(dictionary.Count, dictionary2.Count);
-                Assert.Equal(dictionary.Comparer, dictionary2.Comparer);
-                Assert.Equal("1", dictionary2["Key1"]);
-
-                dictionary2.Add("key2", "2");
-            }
-        }
-
-        /// <summary>
-        /// Serialize custom comparer
-        /// </summary>
-        [Fact]
-        public void SerializeDeserialize2()
-        {
-            CopyOnWriteDictionary<string> dictionary = new CopyOnWriteDictionary<string>(MSBuildNameIgnoreCaseComparer.Default);
-
-            using (MemoryStream stream = new MemoryStream())
-            {
-                BinaryFormatter formatter = new BinaryFormatter();
-
-                formatter.Serialize(stream, dictionary);
-                stream.Position = 0;
-
-                CopyOnWriteDictionary<string> deserialized = (CopyOnWriteDictionary<string>)formatter.Deserialize(stream);
-
-                deserialized.Count.ShouldBe(dictionary.Count);
-                deserialized.Comparer.ShouldBeOfType<MSBuildNameIgnoreCaseComparer>();
-            }
-        }
     }
 }
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index c52765ccd49..df21aa2f2e6 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -26,7 +26,7 @@ namespace Microsoft.Build.UnitTests
      * up a raw string (fullLog) that contains all messages, warnings, errors.
      * Thread-safe.
      */
-    internal sealed class MockLogger : ILogger
+    public sealed class MockLogger : ILogger
     {
         #region Properties
 
@@ -138,6 +138,11 @@ internal sealed class MockLogger : ILogger
         /// </summary>
         internal List<BuildFinishedEventArgs> BuildFinishedEvents { get; } = new List<BuildFinishedEventArgs>();
 
+        /// <summary>
+        /// List of Telemetry events
+        /// </summary>
+        internal List<TelemetryEventArgs> TelemetryEvents { get; } = new();
+
         internal List<BuildEventArgs> AllBuildEvents { get; } = new List<BuildEventArgs>();
 
         /*
@@ -175,11 +180,7 @@ internal string FullLog
          * The mock logger does not take parameters.
          * 
          */
-        public string Parameters
-        {
-            get => null;
-            set {/* do nothing */}
-        }
+        public string Parameters { get; set; }
 
         /*
          * Method:  Initialize
@@ -190,6 +191,10 @@ public string Parameters
         public void Initialize(IEventSource eventSource)
         {
             eventSource.AnyEventRaised += LoggerEventHandler;
+            if (eventSource is IEventSource2 eventSource2)
+            {
+                eventSource2.TelemetryLogged += TelemetryEventHandler;
+            }
 
             if (_profileEvaluation)
             {
@@ -197,6 +202,12 @@ public void Initialize(IEventSource eventSource)
                 eventSource3.ShouldNotBeNull();
                 eventSource3.IncludeEvaluationProfiles();
             }
+
+            // Apply parameters
+            if (Parameters?.IndexOf("reporttelemetry", StringComparison.OrdinalIgnoreCase) >= 0)
+            {
+                _reportTelemetry = true;
+            }
         }
 
         /// <summary>
@@ -222,6 +233,10 @@ public void Shutdown()
         }
         #endregion
 
+        public MockLogger() : this(null)
+        {
+        }
+
         public MockLogger(ITestOutputHelper testOutputHelper = null, bool profileEvaluation = false, bool printEventsToStdout = true, LoggerVerbosity verbosity = LoggerVerbosity.Normal)
         {
             _testOutputHelper = testOutputHelper;
@@ -383,6 +398,27 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
             }
         }
 
+        internal void TelemetryEventHandler(object sender, BuildEventArgs eventArgs)
+        {
+            lock (_lockObj)
+            {
+                if (eventArgs is TelemetryEventArgs telemetryEventArgs)
+                {
+                    TelemetryEvents.Add(telemetryEventArgs);
+
+                    if (_reportTelemetry)
+                    {
+                        // Log telemetry events to the full log so we can verify them in end-to-end tests by captured outputs.
+                        _fullLog.AppendLine($"Telemetry:{telemetryEventArgs.EventName}");
+                        foreach (KeyValuePair<string, string> pair in telemetryEventArgs.Properties)
+                        {
+                            _fullLog.AppendLine($"    {telemetryEventArgs.EventName}:{pair.Key}={pair.Value}");
+                        }
+                    }
+                }
+            }
+        }
+
         private void PrintFullLog()
         {
             if (_printEventsToStdout)
@@ -397,6 +433,7 @@ private void PrintFullLog()
             typeof(ProjectCollection).GetTypeInfo().Assembly));
 
         private static ResourceManager s_engineResourceManager;
+        private bool _reportTelemetry;
 
         // Gets the resource string given the resource ID
         public static string GetString(string stringId) => EngineResourceManager.GetString(stringId, CultureInfo.CurrentUICulture);
diff --git a/src/Shared/UnitTests/TaskParameter_Tests.cs b/src/Shared/UnitTests/TaskParameter_Tests.cs
index a33b226229a..6b23cbac9aa 100644
--- a/src/Shared/UnitTests/TaskParameter_Tests.cs
+++ b/src/Shared/UnitTests/TaskParameter_Tests.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
@@ -39,96 +40,124 @@ public void NullParameter()
             Assert.Equal(TaskParameterType.Null, t2.ParameterType);
         }
 
-        /// <summary>
-        /// Verifies that construction and serialization with a string parameter is OK.
-        /// </summary>
-        [Fact]
-        public void StringParameter()
+        [Theory]
+        [InlineData(typeof(bool), (int)TypeCode.Boolean, "True")]
+        [InlineData(typeof(byte), (int)TypeCode.Byte, "127")]
+        [InlineData(typeof(sbyte), (int)TypeCode.SByte, "-127")]
+        [InlineData(typeof(double), (int)TypeCode.Double, "3.14")]
+        [InlineData(typeof(float), (int)TypeCode.Single, "3.14")]
+        [InlineData(typeof(short), (int)TypeCode.Int16, "-20000")]
+        [InlineData(typeof(ushort), (int)TypeCode.UInt16, "30000")]
+        [InlineData(typeof(int), (int)TypeCode.Int32, "-1")]
+        [InlineData(typeof(uint), (int)TypeCode.UInt32, "1")]
+        [InlineData(typeof(long), (int)TypeCode.Int64, "-1000000000000")]
+        [InlineData(typeof(ulong), (int)TypeCode.UInt64, "1000000000000")]
+        [InlineData(typeof(decimal), (int)TypeCode.Decimal, "29.99")]
+        [InlineData(typeof(char), (int)TypeCode.Char, "q")]
+        [InlineData(typeof(string), (int)TypeCode.String, "foo")]
+        [InlineData(typeof(DateTime), (int)TypeCode.DateTime, "1/1/2000 12:12:12")]
+        public void PrimitiveParameter(Type type, int expectedTypeCodeAsInt, string testValueAsString)
         {
-            TaskParameter t = new TaskParameter("foo");
+            TypeCode expectedTypeCode = (TypeCode)expectedTypeCodeAsInt;
+
+            object value = Convert.ChangeType(testValueAsString, type, CultureInfo.InvariantCulture);
+            TaskParameter t = new TaskParameter(value);
 
-            Assert.Equal("foo", t.WrappedParameter);
-            Assert.Equal(TaskParameterType.String, t.ParameterType);
+            Assert.Equal(value, t.WrappedParameter);
+            Assert.Equal(TaskParameterType.PrimitiveType, t.ParameterType);
+            Assert.Equal(expectedTypeCode, t.ParameterTypeCode);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            Assert.Equal("foo", t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.String, t2.ParameterType);
+            Assert.Equal(value, t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.PrimitiveType, t2.ParameterType);
+            Assert.Equal(expectedTypeCode, t2.ParameterTypeCode);
         }
 
-        /// <summary>
-        /// Verifies that construction and serialization with a string array parameter is OK.
-        /// </summary>
-        [Fact]
-        public void StringArrayParameter()
+        [Theory]
+        [InlineData(typeof(bool), (int)TypeCode.Boolean, "True;False;True")]
+        [InlineData(typeof(byte), (int)TypeCode.Byte, "127;100;0")]
+        [InlineData(typeof(sbyte), (int)TypeCode.SByte, "-127;-126;12")]
+        [InlineData(typeof(double), (int)TypeCode.Double, "3.14;3.15")]
+        [InlineData(typeof(float), (int)TypeCode.Single, "3.14;3.15")]
+        [InlineData(typeof(short), (int)TypeCode.Int16, "-20000;0;-1")]
+        [InlineData(typeof(ushort), (int)TypeCode.UInt16, "30000;20000;10")]
+        [InlineData(typeof(int), (int)TypeCode.Int32, "-1;-2")]
+        [InlineData(typeof(uint), (int)TypeCode.UInt32, "1;5;6")]
+        [InlineData(typeof(long), (int)TypeCode.Int64, "-1000000000000;0")]
+        [InlineData(typeof(ulong), (int)TypeCode.UInt64, "1000000000000;0")]
+        [InlineData(typeof(decimal), (int)TypeCode.Decimal, "29.99;0.88")]
+        [InlineData(typeof(char), (int)TypeCode.Char, "q;r;c")]
+        [InlineData(typeof(string), (int)TypeCode.String, "foo;bar")]
+        [InlineData(typeof(DateTime), (int)TypeCode.DateTime, "1/1/2000 12:12:12;2/2/2000 13:13:13")]
+        public void PrimitiveArrayParameter(Type type, int expectedTypeCodeAsInt, string testValueAsString)
         {
-            TaskParameter t = new TaskParameter(new string[] { "foo", "bar" });
+            TypeCode expectedTypeCode = (TypeCode)expectedTypeCodeAsInt;
 
-            Assert.Equal(TaskParameterType.StringArray, t.ParameterType);
+            string[] values = testValueAsString.Split(';');
+            Array array = Array.CreateInstance(type, values.Length);
+            for (int i = 0; i < values.Length; i++)
+            {
+                object value = Convert.ChangeType(values[i], type, CultureInfo.InvariantCulture);
+                array.SetValue(value, i);
+            }
 
-            string[] wrappedParameter = t.WrappedParameter as string[];
-            Assert.NotNull(wrappedParameter);
-            Assert.Equal(2, wrappedParameter.Length);
-            Assert.Equal("foo", wrappedParameter[0]);
-            Assert.Equal("bar", wrappedParameter[1]);
+            TaskParameter t = new TaskParameter(array);
+
+            Assert.Equal(array, t.WrappedParameter);
+            Assert.Equal(TaskParameterType.PrimitiveTypeArray, t.ParameterType);
+            Assert.Equal(expectedTypeCode, t.ParameterTypeCode);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            Assert.Equal(TaskParameterType.StringArray, t2.ParameterType);
-
-            string[] wrappedParameter2 = t2.WrappedParameter as string[];
-            Assert.NotNull(wrappedParameter2);
-            Assert.Equal(2, wrappedParameter2.Length);
-            Assert.Equal("foo", wrappedParameter2[0]);
-            Assert.Equal("bar", wrappedParameter2[1]);
+            Assert.Equal(array, t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.PrimitiveTypeArray, t2.ParameterType);
+            Assert.Equal(expectedTypeCode, t2.ParameterTypeCode);
         }
 
-        /// <summary>
-        /// Verifies that construction and serialization with a value type (integer) parameter is OK.
-        /// </summary>
         [Fact]
-        public void IntParameter()
+        public void ValueTypeParameter()
         {
-            TaskParameter t = new TaskParameter(1);
+            TaskBuilderTestTask.CustomStruct value = new TaskBuilderTestTask.CustomStruct(3.14);
+            TaskParameter t = new TaskParameter(value);
 
-            Assert.Equal(1, t.WrappedParameter);
-            Assert.Equal(TaskParameterType.Int, t.ParameterType);
+            Assert.Equal(value, t.WrappedParameter);
+            Assert.Equal(TaskParameterType.ValueType, t.ParameterType);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            Assert.Equal(1, t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.Int, t2.ParameterType);
+            // Custom IConvertible structs are deserialized into strings.
+            Assert.Equal(value.ToString(CultureInfo.InvariantCulture), t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.ValueType, t2.ParameterType);
         }
 
-        /// <summary>
-        /// Verifies that construction and serialization with a parameter that is an array of value types (ints) is OK.
-        /// </summary>
         [Fact]
-        public void IntArrayParameter()
+        public void ValueTypeArrayParameter()
         {
-            TaskParameter t = new TaskParameter(new int[] { 2, 15 });
-
+            TaskBuilderTestTask.CustomStruct[] value = new TaskBuilderTestTask.CustomStruct[]
+            {
+                new TaskBuilderTestTask.CustomStruct(3.14),
+                new TaskBuilderTestTask.CustomStruct(2.72),
+            };
+            TaskParameter t = new TaskParameter(value);
+
+            Assert.Equal(value, t.WrappedParameter);
             Assert.Equal(TaskParameterType.ValueTypeArray, t.ParameterType);
 
-            int[] wrappedParameter = t.WrappedParameter as int[];
-            Assert.NotNull(wrappedParameter);
-            Assert.Equal(2, wrappedParameter.Length);
-            Assert.Equal(2, wrappedParameter[0]);
-            Assert.Equal(15, wrappedParameter[1]);
-
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
+            // Custom IConvertible structs are deserialized into strings.
+            Assert.True(t2.WrappedParameter is string[]);
             Assert.Equal(TaskParameterType.ValueTypeArray, t2.ParameterType);
 
-            int[] wrappedParameter2 = t2.WrappedParameter as int[];
-            Assert.NotNull(wrappedParameter2);
-            Assert.Equal(2, wrappedParameter2.Length);
-            Assert.Equal(2, wrappedParameter2[0]);
-            Assert.Equal(15, wrappedParameter2[1]);
+            string[] stringArray = (string[])t2.WrappedParameter;
+            Assert.Equal(2, stringArray.Length);
+            Assert.Equal(value[0].ToString(CultureInfo.InvariantCulture), stringArray[0]);
+            Assert.Equal(value[1].ToString(CultureInfo.InvariantCulture), stringArray[1]);
         }
 
         private enum TestEnumForParameter
@@ -143,55 +172,15 @@ public void EnumParameter()
             TaskParameter t = new TaskParameter(TestEnumForParameter.SomethingElse);
 
             Assert.Equal("SomethingElse", t.WrappedParameter);
-            Assert.Equal(TaskParameterType.String, t.ParameterType);
+            Assert.Equal(TaskParameterType.PrimitiveType, t.ParameterType);
+            Assert.Equal(TypeCode.String, t.ParameterTypeCode);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
             Assert.Equal("SomethingElse", t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.String, t2.ParameterType);
-        }
-
-        [Fact]
-        public void BoolParameter()
-        {
-            TaskParameter t = new TaskParameter(true);
-
-            Assert.Equal(true, t.WrappedParameter);
-            Assert.Equal(TaskParameterType.Bool, t.ParameterType);
-
-            ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
-            TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
-
-            Assert.Equal(true, t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.Bool, t2.ParameterType);
-        }
-
-        /// <summary>
-        /// Verifies that construction and serialization with a parameter that is an array of value types (ints) is OK.
-        /// </summary>
-        [Fact]
-        public void BoolArrayParameter()
-        {
-            TaskParameter t = new TaskParameter(new bool[] { false, true });
-
-            Assert.Equal(TaskParameterType.ValueTypeArray, t.ParameterType);
-
-            bool[] wrappedParameter = t.WrappedParameter as bool[];
-            Assert.NotNull(wrappedParameter);
-            Assert.Equal(2, wrappedParameter.Length);
-            Assert.False(wrappedParameter[0]);
-            Assert.True(wrappedParameter[1]);
-
-            ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
-            TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
-
-            Assert.Equal(TaskParameterType.ValueTypeArray, t2.ParameterType);
-
-            bool[] wrappedParameter2 = Assert.IsType<bool[]>(t2.WrappedParameter);
-            Assert.Equal(2, wrappedParameter2.Length);
-            Assert.False(wrappedParameter2[0]);
-            Assert.True(wrappedParameter2[1]);
+            Assert.Equal(TaskParameterType.PrimitiveType, t2.ParameterType);
+            Assert.Equal(TypeCode.String, t2.ParameterTypeCode);
         }
 
         /// <summary>
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
index 0c10b4d1f04..6b8d8eb14f0 100644
--- a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
@@ -18,8 +18,6 @@
 
   <ItemGroup>
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="xunit.core" />
-    <PackageReference Include="xunit.assert" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/StringTools/CompatibilitySuppressions.xml b/src/StringTools/CompatibilitySuppressions.xml
deleted file mode 100644
index f5eff188d66..00000000000
--- a/src/StringTools/CompatibilitySuppressions.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
-<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <Suppression>
-    <!-- Dropped net35 for 17.5; see https://github.com/dotnet/msbuild/pull/8198 -->
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>.NETFramework,Version=v3.5</Target>
-  </Suppression>
-</Suppressions>
diff --git a/src/Tasks.UnitTests/.editorconfig b/src/Tasks.UnitTests/.editorconfig
new file mode 100644
index 00000000000..a618acbc288
--- /dev/null
+++ b/src/Tasks.UnitTests/.editorconfig
@@ -0,0 +1,3 @@
+# Files that have inline expected results that include trailing whitespace
+[RoslynCodeTaskFactory_Tests.cs]
+trim_trailing_whitespace = false
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index 91692fb8aa7..5f9f39e9220 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -450,6 +450,9 @@ public void CodeLanguageFromTaskBody()
             TryLoadTaskBodyAndExpectSuccess("<Code Language=\"vb\">code</Code>", expectedCodeLanguage: "VB");
             TryLoadTaskBodyAndExpectSuccess("<Code Language=\"visualbasic\">code</Code>", expectedCodeLanguage: "VB");
             TryLoadTaskBodyAndExpectSuccess("<Code Language=\"ViSuAl BaSic\">code</Code>", expectedCodeLanguage: "VB");
+
+            // Default when the Language attribute is not present.
+            TryLoadTaskBodyAndExpectSuccess("<Code>code</Code>", expectedCodeLanguage: "CS");
         }
 
         [Fact]
@@ -474,6 +477,31 @@ public void CodeTypeFromTaskBody()
             }
         }
 
+        [Fact]
+        public void CSharpClass()
+        {
+            const string taskClassSourceCode = @"namespace InlineTask
+{
+    using Microsoft.Build.Utilities;
+
+    public class HelloWorld : Task
+    {
+        public override bool Execute()
+        {
+            Log.LogMessage(""Hello, world!"");
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
+";
+
+            TryLoadTaskBodyAndExpectSuccess(
+                $"<Code Type=\"Class\">{taskClassSourceCode}</Code>",
+                expectedSourceCode: taskClassSourceCode,
+                expectedCodeType: RoslynCodeTaskFactoryCodeType.Class,
+                expectedCodeLanguage: "CS");
+        }
+
         [Fact]
         public void CSharpFragment()
         {
@@ -690,6 +718,36 @@ public class MyInlineTask : Microsoft.Build.Utilities.Task {{
                 expectedCodeType: RoslynCodeTaskFactoryCodeType.Method);
         }
 
+        [Fact]
+        public void CSharpClassSourceCodeFromFile()
+        {
+            const string taskClassSourceCode = @"namespace InlineTask
+{
+    using Microsoft.Build.Utilities;
+
+    public class HelloWorld : Task
+    {
+        public override bool Execute()
+        {
+            Log.LogMessage(""Hello, world!"");
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
+";
+
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile file = env.CreateFile(fileName: "CSharpClassSourceCodeFromFile.tmp", contents: taskClassSourceCode);
+
+                TryLoadTaskBodyAndExpectSuccess(
+                    $"<Code Source=\"{file.Path}\" />",
+                    expectedSourceCode: taskClassSourceCode,
+                    expectedCodeType: RoslynCodeTaskFactoryCodeType.Class,
+                    expectedCodeLanguage: "CS");
+            }
+        }
+
         [Fact]
         public void CSharpFragmentSourceCodeFromFile()
         {
@@ -969,6 +1027,47 @@ public void SourceCodeFromFile()
             }
         }
 
+        [Fact]
+        public void MismatchedTaskNameAndTaskClassName()
+        {
+            const string taskName = "SayHello";
+            const string className = "HelloWorld";
+            taskName.ShouldNotBe(className, "The test is misconfigured.");
+            string errorMessage = string.Format(ResourceUtilities.GetResourceString("CodeTaskFactory.CouldNotFindTaskInAssembly"), taskName);
+
+            const string projectContent = @"<Project>
+  <UsingTask TaskName=""" + taskName + @""" TaskFactory=""RoslynCodeTaskFactory"" AssemblyFile=""$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"">
+    <Task>
+      <Code Type=""Class"">
+namespace InlineTask
+{
+    using Microsoft.Build.Utilities;
+
+    public class " + className + @" : Task
+    {
+        public override bool Execute()
+        {
+            Log.LogMessage(""Hello, world!"");
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
+      </Code>
+    </Task>
+  </UsingTask>
+  <Target Name=""Build"">
+    <" + taskName + @" />
+  </Target>
+</Project>";
+
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles(projectContent);
+                var logger = proj.BuildProjectExpectFailure();
+                logger.AssertLogContains(errorMessage);
+            }
+        }
+
         private void TryLoadTaskBodyAndExpectFailure(string taskBody, string expectedErrorMessage)
         {
             if (expectedErrorMessage == null)
diff --git a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
index 0b3d12f099e..d5495b9dfab 100644
--- a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
+++ b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
@@ -238,6 +238,57 @@ public void QuestionWriteLinesWriteOnlyWhenDifferentTest()
             }
         }
 
+        /// <summary>
+        /// Question WriteLines to return true when Lines are empty.
+        /// </summary>
+        [Fact]
+        public void QuestionWriteLinesWhenLinesAreEmpty()
+        {
+            // Test the combination of:
+            // 1) File exists
+            // 2) Overwrite
+            // 3) WriteOnlyWhenDifferent
+
+            var fileExists = FileUtilities.GetTemporaryFile();
+            var fileNotExists = FileUtilities.GetTemporaryFileName();
+            try
+            {
+                TestWriteLines(fileExists, fileNotExists, Overwrite: true, WriteOnlyWhenDifferent: true);
+                TestWriteLines(fileExists, fileNotExists, Overwrite: false, WriteOnlyWhenDifferent: true);
+                TestWriteLines(fileExists, fileNotExists, Overwrite: true, WriteOnlyWhenDifferent: false);
+                TestWriteLines(fileExists, fileNotExists, Overwrite: false, WriteOnlyWhenDifferent: false);
+            }
+            finally
+            {
+                File.Delete(fileExists);
+            }
+
+            void TestWriteLines(string fileExists, string fileNotExists, bool Overwrite, bool WriteOnlyWhenDifferent)
+            {
+                var test1 = new WriteLinesToFile
+                {
+                    Overwrite = Overwrite,
+                    BuildEngine = new MockEngine(_output),
+                    File = new TaskItem(fileExists),
+                    WriteOnlyWhenDifferent = WriteOnlyWhenDifferent,
+                    FailIfNotIncremental = true,
+                    // Tests Lines = null.
+                };
+                test1.Execute().ShouldBeTrue();
+
+                var test2 = new WriteLinesToFile
+                {
+                    Overwrite = Overwrite,
+                    BuildEngine = new MockEngine(_output),
+                    File = new TaskItem(fileNotExists),
+                    WriteOnlyWhenDifferent = WriteOnlyWhenDifferent,
+                    FailIfNotIncremental = true,
+                    Lines = Array.Empty<ITaskItem>(),  // Test empty.
+                };
+                test2.Execute().ShouldBeTrue();
+            }
+        }
+
         /// <summary>
         /// Should create directory structure when target <see cref="WriteLinesToFile.File"/> does not exist.
         /// </summary>
diff --git a/src/Tasks/AppConfig/AppConfigException.cs b/src/Tasks/AppConfig/AppConfigException.cs
index 82caefb8fc0..b059713b9da 100644
--- a/src/Tasks/AppConfig/AppConfigException.cs
+++ b/src/Tasks/AppConfig/AppConfigException.cs
@@ -66,6 +66,9 @@ public AppConfigException(string message, string fileName, int line, int column,
         /// <summary>
         /// Construct the exception.
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected AppConfigException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
         }
diff --git a/src/Tasks/AssemblyDependency/BadImageReferenceException.cs b/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
index 8a9cadcc29a..a6567717294 100644
--- a/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
+++ b/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
@@ -25,6 +25,9 @@ internal BadImageReferenceException(string message, Exception innerException)
         /// <summary>
         /// Construct
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private BadImageReferenceException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
diff --git a/src/Tasks/AssemblyDependency/DependencyResolutionException.cs b/src/Tasks/AssemblyDependency/DependencyResolutionException.cs
index 402e4999988..2e174dadc3b 100644
--- a/src/Tasks/AssemblyDependency/DependencyResolutionException.cs
+++ b/src/Tasks/AssemblyDependency/DependencyResolutionException.cs
@@ -25,6 +25,9 @@ internal DependencyResolutionException(string message, Exception innerException)
         /// <summary>
         /// Construct
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private DependencyResolutionException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
diff --git a/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs b/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
index 42838f8dc21..55287a96840 100644
--- a/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
+++ b/src/Tasks/AssemblyDependency/InvalidReferenceAssemblyNameException.cs
@@ -26,6 +26,9 @@ internal InvalidReferenceAssemblyNameException(string sourceItemSpec)
         /// <summary>
         /// Construct
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private InvalidReferenceAssemblyNameException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
         }
diff --git a/src/Tasks/AssemblyDependency/ReferenceResolutionException.cs b/src/Tasks/AssemblyDependency/ReferenceResolutionException.cs
index 621d8834891..c924e806f07 100644
--- a/src/Tasks/AssemblyDependency/ReferenceResolutionException.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceResolutionException.cs
@@ -25,6 +25,9 @@ internal ReferenceResolutionException(string message, Exception innerException)
         /// <summary>
         /// Implement required constructors for serialization
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private ReferenceResolutionException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
         }
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 41cdfe24dd6..d6636913a1f 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -852,8 +852,7 @@ private static AssemblyNameExtension GetAssemblyNameFromItemMetadata(ITaskItem i
                 name = item.GetMetadata(FileUtilities.ItemSpecModifiers.Filename);
             }
 
-            AssemblyName assemblyName = new AssemblyName($"{name}, Version={version}, Culture=neutral, PublicKeyToken={publicKeyToken}");
-            return new AssemblyNameExtension(assemblyName);
+            return new AssemblyNameExtension($"{name}, Version={version}, Culture=neutral, PublicKeyToken={publicKeyToken}");
         }
 
         /// <summary>
@@ -2677,36 +2676,9 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
             // Set up the main item.
             TaskItem referenceItem = new TaskItem();
             referenceItem.ItemSpec = reference.FullPath;
-            referenceItem.SetMetadata(ItemMetadataNames.resolvedFrom, reference.ResolvedSearchPath);
 
-            // Set the CopyLocal metadata.
-            referenceItem.SetMetadata(ItemMetadataNames.copyLocal, reference.IsCopyLocal ? "true" : "false");
-
-            // Set the Redist name metadata.
-            if (!String.IsNullOrEmpty(reference.RedistName))
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.redist, reference.RedistName);
-            }
-
-            if (Reference.IsFrameworkFile(reference.FullPath, _frameworkPaths) || (_installedAssemblies?.FrameworkAssemblyEntryInRedist(assemblyName) == true))
-            {
-                if (!IsAssemblyRemovedFromDotNetFramework(assemblyName, reference.FullPath, _frameworkPaths, _installedAssemblies))
-                {
-                    referenceItem.SetMetadata(ItemMetadataNames.frameworkFile, "true");
-                }
-            }
-
-            if (!String.IsNullOrEmpty(reference.ImageRuntime))
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.imageRuntime, reference.ImageRuntime);
-            }
-
-            // The redist root is "null" when there was no IsRedistRoot flag in the Redist XML
-            // (or there was no redist XML at all for this item).
-            if (reference.IsRedistRoot != null)
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, (bool)reference.IsRedistRoot ? "true" : "false");
-            }
+            IMetadataContainer referenceItemAsMetadataContainer = referenceItem;
+            referenceItemAsMetadataContainer.ImportMetadata(EnumerateCommonMetadata());
 
             // If there was a primary source item, then forward metadata from it.
             // It's important that the metadata from the primary source item
@@ -2880,13 +2852,45 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
             // nonForwardableMetadata should be null here if relatedFileExtensions, satellites, serializationAssemblyFiles, and scatterFiles were all empty.
             if (nonForwardableMetadata != null)
             {
-                foreach (KeyValuePair<string, string> kvp in nonForwardableMetadata)
-                {
-                    referenceItem.SetMetadata(kvp.Key, kvp.Value);
-                }
+                referenceItemAsMetadataContainer.ImportMetadata(nonForwardableMetadata);
             }
 
             return referenceItem;
+
+            // Enumerate common metadata with an iterator to allow using a more efficient bulk-set operation.
+            IEnumerable<KeyValuePair<string, string>> EnumerateCommonMetadata()
+            {
+                yield return new KeyValuePair<string, string>(ItemMetadataNames.resolvedFrom, reference.ResolvedSearchPath);
+
+                // Set the CopyLocal metadata.
+                yield return new KeyValuePair<string, string>(ItemMetadataNames.copyLocal, reference.IsCopyLocal ? "true" : "false");
+
+                // Set the Redist name metadata.
+                if (!string.IsNullOrEmpty(reference.RedistName))
+                {
+                    yield return new KeyValuePair<string, string>(ItemMetadataNames.redist, reference.RedistName);
+                }
+
+                if (Reference.IsFrameworkFile(reference.FullPath, _frameworkPaths) || (_installedAssemblies?.FrameworkAssemblyEntryInRedist(assemblyName) == true))
+                {
+                    if (!IsAssemblyRemovedFromDotNetFramework(assemblyName, reference.FullPath, _frameworkPaths, _installedAssemblies))
+                    {
+                        yield return new KeyValuePair<string, string>(ItemMetadataNames.frameworkFile, "true");
+                    }
+                }
+
+                if (!string.IsNullOrEmpty(reference.ImageRuntime))
+                {
+                    yield return new KeyValuePair<string, string>(ItemMetadataNames.imageRuntime, reference.ImageRuntime);
+                }
+
+                // The redist root is "null" when there was no IsRedistRoot flag in the Redist XML
+                // (or there was no redist XML at all for this item).
+                if (reference.IsRedistRoot != null)
+                {
+                    yield return new KeyValuePair<string, string>(ItemMetadataNames.isRedistRoot, (bool)reference.IsRedistRoot ? "true" : "false");
+                }
+            }
         }
 
         /// <summary>
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index 2480c599bce..2ff7b10261f 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -139,7 +139,7 @@ public override bool Execute()
                             dependentUpon,
                             // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
                             // https://github.com/dotnet/msbuild/issues/3064
-                            AssignedFiles[i].GetMetadata("WithCulture").Equals("false", StringComparison.OrdinalIgnoreCase));
+                            ConversionUtilities.ValidBooleanFalse(AssignedFiles[i].GetMetadata("WithCulture")));
 
                     if (!string.IsNullOrEmpty(info.culture))
                     {
diff --git a/src/Tasks/ComReferenceInfo.cs b/src/Tasks/ComReferenceInfo.cs
index f41dd573f48..7ba6eff1a9f 100644
--- a/src/Tasks/ComReferenceInfo.cs
+++ b/src/Tasks/ComReferenceInfo.cs
@@ -153,10 +153,10 @@ internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path
             {
                 case ProcessorArchitecture.AMD64:
                 case ProcessorArchitecture.IA64:
-                    this.typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_LOAD_TLB_AS_64BIT);
+                    this.typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_NONE | (int)NativeMethods.REGKIND.REGKIND_LOAD_TLB_AS_64BIT);
                     break;
                 case ProcessorArchitecture.X86:
-                    this.typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_LOAD_TLB_AS_32BIT);
+                    this.typeLibPointer = (ITypeLib)NativeMethods.LoadTypeLibEx(path, (int)NativeMethods.REGKIND.REGKIND_NONE | (int)NativeMethods.REGKIND.REGKIND_LOAD_TLB_AS_32BIT);
                     break;
                 case ProcessorArchitecture.ARM:
                 case ProcessorArchitecture.MSIL:
diff --git a/src/Tasks/CompatibilitySuppressions.xml b/src/Tasks/CompatibilitySuppressions.xml
index be7948e4890..498513b70bc 100644
--- a/src/Tasks/CompatibilitySuppressions.xml
+++ b/src/Tasks/CompatibilitySuppressions.xml
@@ -2,7 +2,7 @@
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <Suppression>
-    <!-- For ease of logging the "not supported on Core" message, this task is a
+<!-- For ease of logging the "not supported on Core" message, this task is a
          TaskExtension on netstandard/netcore. Since the type is sealed there,
          that shouldn't cause any implementation problems since no one can derive
          from it and try to call TaskExtension.Log. -->
@@ -12,6 +12,15 @@
     <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
   </Suppression>
 
+  <!-- We don't have the net7 reference assemblies handy to pass in to compare against the net8 ones -->
+  <Suppression>
+    <DiagnosticId>CP1002</DiagnosticId>
+    <Target>System.Security.Cryptography, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Target>
+    <Left>ref/net7.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
        This is intentional, because you can only use MSBuild in the context of a .NET SDK
        (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
@@ -65,7 +74,7 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-  <!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
+<!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
   <Suppression>
     <DiagnosticId>PKV006</DiagnosticId>
     <Target>net7.0</Target>
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 9ee72433bef..68d7f27ddba 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -361,7 +361,7 @@ private void LogDiagnostic(string message, params object[] messageArgs)
         private void TryCopyViaLink(string linkComment, MessageImportance messageImportance, FileState sourceFileState, FileState destinationFileState, out bool linkCreated, ref string errorMessage, Func<string, string, string, bool> createLink)
         {
             // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
-            Log.LogMessage(MessageImportance.Normal, linkComment, sourceFileState.Name, destinationFileState.Name);
+            Log.LogMessage(MessageImportance.Normal, linkComment, sourceFileState.FileNameFullPath, destinationFileState.FileNameFullPath);
 
             linkCreated = createLink(sourceFileState.Name, destinationFileState.Name, errorMessage);
         }
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index e2be751c69d..f45169c4d12 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -44,7 +44,7 @@ protected override string CreateManifestName(
                 culture = item.GetMetadata("Culture");
                 // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
                 // https://github.com/dotnet/msbuild/issues/3064
-                treatAsCultureNeutral = item.GetMetadata("WithCulture").Equals("false", StringComparison.OrdinalIgnoreCase);
+                treatAsCultureNeutral = ConversionUtilities.ValidBooleanFalse(item.GetMetadata("WithCulture"));
             }
 
             /*
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 11ccf11e3a6..9b02e0109bc 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -1,9 +1,10 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
 using System.IO;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
 #nullable disable
@@ -42,7 +43,7 @@ protected override string CreateManifestName(
                 culture = item.GetMetadata("Culture");
                 // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
                 // https://github.com/dotnet/msbuild/issues/3064
-                treatAsCultureNeutral = item.GetMetadata("WithCulture").Equals("false", StringComparison.OrdinalIgnoreCase);
+                treatAsCultureNeutral = ConversionUtilities.ValidBooleanFalse(item.GetMetadata("WithCulture"));
             }
 
             /*
diff --git a/src/Tasks/FileIO/WriteLinesToFile.cs b/src/Tasks/FileIO/WriteLinesToFile.cs
index 7ae0228c8e5..9b94858fc12 100644
--- a/src/Tasks/FileIO/WriteLinesToFile.cs
+++ b/src/Tasks/FileIO/WriteLinesToFile.cs
@@ -133,8 +133,11 @@ public override bool Execute()
 
                         if (FailIfNotIncremental)
                         {
-                            Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorReadingFile", File.ItemSpec);
-                            return false;
+                            if (Lines?.Length > 0)
+                            {
+                                Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorReadingFile", File.ItemSpec);
+                                return false;
+                            }
                         }
                         else
                         {
@@ -143,7 +146,7 @@ public override bool Execute()
                     }
                     else
                     {
-                        if (FailIfNotIncremental)
+                        if (FailIfNotIncremental && Lines?.Length > 0)
                         {
                             Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorOrWarning", File.ItemSpec, string.Empty);
                             return false;
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 6ff6c0a5dff..3c198c1d512 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -1745,9 +1745,10 @@ private bool NeedSeparateAppDomain()
 
                     try
                     {
-                        XmlReaderSettings readerSettings = new XmlReaderSettings();
-                        readerSettings.DtdProcessing = DtdProcessing.Ignore;
-                        reader = XmlReader.Create(source.ItemSpec, readerSettings);
+                        XmlReaderSettings readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+
+                        FileStream fs = File.OpenRead(source.ItemSpec);
+                        reader = XmlReader.Create(fs, readerSettings);
 
                         while (reader.Read())
                         {
@@ -3942,6 +3943,9 @@ internal sealed class TextFileException : Exception
             private int lineNumber;
             private int column;
 
+#if NET8_0_OR_GREATER
+            [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
             private TextFileException(SerializationInfo info, StreamingContext context)
                 : base(info, context)
             {
diff --git a/src/Tasks/InvalidParameterValueException.cs b/src/Tasks/InvalidParameterValueException.cs
index cfa9c9f52d6..ad9c727d1b8 100644
--- a/src/Tasks/InvalidParameterValueException.cs
+++ b/src/Tasks/InvalidParameterValueException.cs
@@ -38,6 +38,9 @@ internal InvalidParameterValueException(string paramName, string actualValue, st
         /// <summary>
         /// Constructor
         /// </summary>
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private InvalidParameterValueException(SerializationInfo info, StreamingContext context)
             : base(info, context)
         {
diff --git a/src/Tasks/ManifestUtil/XmlUtil.cs b/src/Tasks/ManifestUtil/XmlUtil.cs
index e2360d23b24..ca35d8090a0 100644
--- a/src/Tasks/ManifestUtil/XmlUtil.cs
+++ b/src/Tasks/ManifestUtil/XmlUtil.cs
@@ -97,36 +97,38 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
             Util.CopyStream(input, clonedInput);
 
             int t4 = Environment.TickCount;
-            XmlReader xml = XmlReader.Create(clonedInput);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "new XmlReader(2) t={0}", Environment.TickCount - t4));
-
-            XsltArgumentList args = null;
-            if (entries.Length > 0)
+            using (XmlReader reader = XmlReader.Create(clonedInput))
             {
-                args = new XsltArgumentList();
-                foreach (DictionaryEntry entry in entries)
+                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "new XmlReader(2) t={0}", Environment.TickCount - t4));
+
+                XsltArgumentList args = null;
+                if (entries.Length > 0)
                 {
-                    string key = entry.Key.ToString();
-                    object val = entry.Value.ToString();
-                    args.AddParam(key, "", val);
-                    Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "arg: key='{0}' value='{1}'", key, val.ToString()));
+                    args = new XsltArgumentList();
+                    foreach (DictionaryEntry entry in entries)
+                    {
+                        string key = entry.Key.ToString();
+                        object val = entry.Value.ToString();
+                        args.AddParam(key, "", val);
+                        Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "arg: key='{0}' value='{1}'", key, val.ToString()));
+                    }
                 }
-            }
 
-            var m = new MemoryStream();
-            var w = new XmlTextWriter(m, Encoding.UTF8);
-            w.WriteStartDocument();
+                var m = new MemoryStream();
+                var w = new XmlTextWriter(m, Encoding.UTF8);
+                w.WriteStartDocument();
 
-            int t5 = Environment.TickCount;
-            xslc.Transform(xml, args, w, s_resolver);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform.Transform t={0}", Environment.TickCount - t4));
+                int t5 = Environment.TickCount;
+                xslc.Transform(reader, args, w, s_resolver);
+                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform.Transform t={0}", Environment.TickCount - t4));
 
-            w.WriteEndDocument();
-            w.Flush();
-            m.Position = 0;
+                w.WriteEndDocument();
+                w.Flush();
+                m.Position = 0;
 
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform(\"{0}\") t={1}", resource, Environment.TickCount - t1));
-            return m;
+                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform(\"{0}\") t={1}", resource, Environment.TickCount - t1));
+                return m;
+            }
         }
 
         private class ResourceResolver : XmlUrlResolver
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index ef14371aa36..3b19aee2b1e 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -612,8 +612,10 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldF
                 {
                     XmlReaderSettings settings = new XmlReaderSettings();
                     settings.DtdProcessing = DtdProcessing.Parse;
-                    XmlReader reader = XmlReader.Create(stringReader, settings, manifestDom.BaseURI);
-                    normalizedDom.Load(reader);
+                    using (XmlReader reader = XmlReader.Create(stringReader, settings, manifestDom.BaseURI))
+                    {
+                        normalizedDom.Load(reader);
+                    }
                 }
 
                 XmlDsigExcC14NTransform exc = new XmlDsigExcC14NTransform();
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index f7b0c673aba..6b963c661b5 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -2476,9 +2476,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ====================================================================================================
   -->
   <Target Name="GenerateBindingRedirects"
-    Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath);$(ResolveAssemblyReferencesStateFile);$(SuggestedBindingRedirectsCacheFile)"
+    Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath);$(SuggestedBindingRedirectsCacheFile)"
     Outputs="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and '@(SuggestedBindingRedirects)' != ''"
+    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and '@(SuggestedBindingRedirects)' != '' and '$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'"
     DependsOnTargets="_GenerateSuggestedBindingRedirectsCache">
 
     <GenerateBindingRedirects
@@ -4422,7 +4422,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_ClickOnceRuntimeCopyLocalItems Include="@(NativeCopyLocalItems)"
                                       Condition="'%(NativeCopyLocalItems.CopyLocal)' == 'true'" />
       <_ClickOnceRuntimeCopyLocalItems Remove="@(_DeploymentReferencePaths)" />
-      <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems)"/>
+
+      <!-- Include items from None itemgroup for publishing -->
+      <_ClickOnceNoneItems Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
+
+      <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems);@(_ClickOnceNoneItems)"/>
     </ItemGroup>
 
     <!-- For single file publish, we need to include the SF bundle EXE, application icon file and files excluded from the bundle EXE in the clickonce manifest -->
diff --git a/src/Tasks/ResourceHandling/InputFormatNotSupportedException.cs b/src/Tasks/ResourceHandling/InputFormatNotSupportedException.cs
index a6b797a7d94..f82fb7c7758 100644
--- a/src/Tasks/ResourceHandling/InputFormatNotSupportedException.cs
+++ b/src/Tasks/ResourceHandling/InputFormatNotSupportedException.cs
@@ -23,6 +23,9 @@ public InputFormatNotSupportedException(string message, Exception innerException
         {
         }
 
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected InputFormatNotSupportedException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
         }
diff --git a/src/Tasks/ResourceHandling/MSBuildResXException.cs b/src/Tasks/ResourceHandling/MSBuildResXException.cs
index ce6d5b589c2..6ef3b33e88e 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXException.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXException.cs
@@ -23,6 +23,9 @@ public MSBuildResXException(string message, Exception innerException) : base(mes
         {
         }
 
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         protected MSBuildResXException(SerializationInfo info, StreamingContext context) : base(info, context)
         {
         }
diff --git a/src/Tasks/ResourceHandling/PreserializedResourceWriterRequiredException.cs b/src/Tasks/ResourceHandling/PreserializedResourceWriterRequiredException.cs
index d72a71f17b0..5cfea71ab5c 100644
--- a/src/Tasks/ResourceHandling/PreserializedResourceWriterRequiredException.cs
+++ b/src/Tasks/ResourceHandling/PreserializedResourceWriterRequiredException.cs
@@ -13,6 +13,9 @@ internal sealed class PreserializedResourceWriterRequiredException : Exception
     {
         public PreserializedResourceWriterRequiredException() { }
 
+#if NET8_0_OR_GREATER
+        [Obsolete(DiagnosticId = "SYSLIB0051")]
+#endif
         private PreserializedResourceWriterRequiredException(SerializationInfo info, StreamingContext context)
             : base(info, context) { }
     }
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 4321076d1c1..e911bfc64fe 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: Hodnota {0} není nastavena nebo je prázdná. Pokud {1} má hodnotu false, nezapomeňte pro hodnotu {0} nastavit neprázdnou hodnotu.</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: Hodnota {0} není nastaven. Pokud {1} má hodnotu true, nezapomeňte nastavit hodnotu pro {0}.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 63076c32279..1db9a0ed02b 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: „{0}“ ist nicht festgelegt oder leer. Wenn {1} falsch ist, legen Sie für „{0}“ auf keinen Fall einen leeren Wert fest.</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: „{0}“ ist nicht festgelegt. Wenn {1} wahr ist, legen Sie auf jeden Fall einen Wert für „{0}“ fest.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index b390aa1ac89..6bf3797e34f 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -118,17 +118,17 @@
       </trans-unit>
       <trans-unit id="AxTlbBaseTask.StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3654: Delay signing requires that at least a public key be specified.  Please either supply a public key using the KeyFile or KeyContainer properties, or disable delay signing.</source>
-        <target state="translated">MSB3654: La firma retrasada requiere que se especifique al menos una clave pública.  Proporcione una clave pública mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retrasada.</target>
+        <target state="translated">MSB3654: La firma retardada requiere que se especifique al menos una clave pública.  Proporcione una clave pública mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retardada.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: "{0}" no se ha establecido o está vacío. Cuando {1} sea false, asegúrese de establecer un valor que no esté vacío para "{0}".</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: "{0}" no se ha establecido. Cuando {1} sea true, asegúrese de establecer un valor para "{0}".</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
@@ -2287,7 +2287,7 @@
       </trans-unit>
       <trans-unit id="ResolveComReference.LoadingDelaySignedAssemblyWithStrongNameVerificationEnabled">
         <source>MSB3295: Failed to load an assembly. Please make sure you have disabled strong name verification for your public key if you want to generate delay signed wrappers. {0}</source>
-        <target state="translated">MSB3295: No se pudo cargar un ensamblado. Asegúrese de que deshabilitó la comprobación de nombres seguros para su clave pública si desea generar contenedores de firma con retraso. {0}</target>
+        <target state="translated">MSB3295: No se pudo cargar un ensamblado. Asegúrese de que deshabilitó la comprobación de nombres seguros para su clave pública si desea generar contenedores de firma retardada. {0}</target>
         <note>{StrBegin="MSB3295: "}</note>
       </trans-unit>
       <trans-unit id="ResolveComReference.MissingOrUnknownComReferenceAttribute">
@@ -2496,7 +2496,7 @@
       </trans-unit>
       <trans-unit id="StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3353: Public key necessary for delay signing was not specified.</source>
-        <target state="translated">MSB3353: No se especificó la clave pública necesaria para la firma con retraso.</target>
+        <target state="translated">MSB3353: No se especificó la clave pública necesaria para la firma retardada.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 2d6a4458ea5..1c092fd0a8c 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: « {0} » n’est pas défini ou vide. Quand la valeur de {1} est false, veillez à définir une valeur non vide pour « {0} ».</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: « {{0}0} » n’est pas défini. Lorsque {1} la valeur est true, veillez à définir une valeur pour «{0} ».</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 913b6a1a3e9..fc2c0670f0a 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: '{0}' non è impostato o è vuoto. Quando {1} è false, assicurarsi di impostare un valore non vuoto per '{0}'.</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: '{0}' non è impostato. Quando {1} è true, assicurarsi di impostare un valore per '{0}'.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index eda61cd91af..605cfdf73f4 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: '{0}' が設定されていないか、空です。{1} が false の場合は、'{0}' に空でない値を設定してください。</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: '{0}' が設定されていません。{1} が true の場合は、必ず '{0}' の値を設定してください。</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 46c9864f31b..39b15815f32 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: '{0}'이(가) 설정되지 않았거나 비어 있습니다. {1}이(가) false인 경우 '{0}'에 비어 있지 않은 값을 설정해야 합니다.</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: '{0}'이(가) 설정되지 않았습니다. {1}이(가) true인 경우 '{0}'에 값을 설정해야 합니다.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index e21cd345e3c..56153414787 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: „{0}” nie jest ustawiony ani pusty. Jeśli {1} ma wartość false, ustaw wartość, która nie jest pusta dla „{0}”.</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: nie ustawiono „{0}”. Jeśli {1} ma wartość true, upewnij się, że ustawiono wartość dla „{0}”.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index f82237f4707..db84fa88b8a 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: '{0}' não está definido ou está vazio. Quando {1} for falso, certifique-se de definir um valor não vazio para '{0}'.</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: '{0}' não está definido. Quando {1} for verdadeiro, certifique-se de definir um valor para '{0}'.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index a4e21bdf13d..d090d29ef62 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: "{0}" не настроено или пусто. Если для {1} присвоено значение false, настройте непустое значение для "{0}".</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: "{0}" не настроено. Если для {1} присвоено значение true, настройте значение для "{0}".</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 349a4228e56..c5979af8059 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: '{0}' ayarlanmamış veya boş. {1} yanlış olduğunda, '{0}' için boş olmayan bir değer ayarlandığından emin olun.</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: '{0}' ayarlanmamış. {1} doğru olduğunda, '{0}' için bir değer ayarlandığından emin olun.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 27de96d7dc7..8b146319e98 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: "{0}" 未设置或为空。如果 {1} 为 false，请确保为 "{0}" 设置非空值。</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: 未设置 "{0}"。如果 {1} 为 true，请确保为 "{0}" 设置值。</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index cdcc217b65f..c03fdbd6641 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="new">MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</target>
+        <target state="translated">MSB3991: 未設定 '{0}' 或空白。當 {1} 為 false 時，請務必將 '{0}' 設定非空白值。</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="new">MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</target>
+        <target state="translated">MSB3992: 未設定 '{0}'。當 {1} 為 true 時，請務必j將 '{0}' 設定一個值。</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 43dd3c3ed10..374fa50852d 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -181,6 +181,12 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> pa
                 TaskType = exportedTypes.FirstOrDefault(type => type.Name.Equals(taskName, StringComparison.OrdinalIgnoreCase))
                            ?? exportedTypes.Where(i => i.FullName != null).FirstOrDefault(type => type.FullName.Equals(taskName, StringComparison.OrdinalIgnoreCase) || type.FullName.EndsWith(taskName, StringComparison.OrdinalIgnoreCase));
 
+                if (TaskType == null)
+                {
+                    _log.LogErrorWithCodeFromResources("CodeTaskFactory.CouldNotFindTaskInAssembly", taskName);
+                    return false;
+                }
+
                 if (taskInfo.CodeType == RoslynCodeTaskFactoryCodeType.Class && parameterGroup.Count == 0)
                 {
                     // If the user specified a whole class but nothing in <ParameterGroup />, automatically derive
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index f9734a9720f..8ef3dee1bf3 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -6,6 +6,9 @@
 using System.IO;
 using System.Xml;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
+using Microsoft.IO;
+using File = System.IO.File;
 
 #nullable disable
 
@@ -174,17 +177,19 @@ internal class RelationsParser
         #endregion
 
         /// <summary>
-        /// The method that loads in an XML file
+        /// The method that loads in an XML file.
         /// </summary>
-        /// <param name="fileName">the xml file containing switches and properties</param>
-        private XmlDocument LoadFile(string fileName)
+        /// <param name="filePath">the xml file containing switches and properties.</param>
+        private XmlDocument LoadFile(string filePath)
         {
             try
             {
                 var xmlDocument = new XmlDocument();
-                XmlReaderSettings settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                XmlReader reader = XmlReader.Create(fileName, settings);
+                XmlReaderSettings settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
+                FileStream fs = File.OpenRead(filePath);
+                using XmlReader reader = XmlReader.Create(fs, settings);
                 xmlDocument.Load(reader);
+
                 return xmlDocument;
             }
             catch (FileNotFoundException e)
@@ -209,9 +214,12 @@ internal XmlDocument LoadXml(string xml)
             {
                 var xmlDocument = new XmlDocument();
                 XmlReaderSettings settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                XmlReader reader = XmlReader.Create(new StringReader(xml), settings);
-                xmlDocument.Load(reader);
-                return xmlDocument;
+                using (XmlReader reader = XmlReader.Create(new StringReader(xml), settings))
+                {
+                    xmlDocument.Load(reader);
+
+                    return xmlDocument;
+                }
             }
             catch (XmlException e)
             {
@@ -221,7 +229,7 @@ internal XmlDocument LoadXml(string xml)
         }
 
         /// <summary>
-        /// Parses the xml file
+        /// Parses the xml file.
         /// </summary>
         public bool ParseXmlDocument(string fileName)
         {
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index c2829bd8851..f5e09078922 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -201,7 +201,7 @@ public override bool Execute()
         /// Takes the raw XML and loads XsltArgumentList
         /// </summary>
         /// <param name="xsltParametersXml">The raw XML that holds each parameter as <Parameter Name="" Value="" Namespace="" /> </param>
-        /// <returns>XsltArgumentList</returns>
+        /// <returns>XsltArgumentList.</returns>
         private static XsltArgumentList ProcessXsltArguments(string xsltParametersXml)
         {
             XsltArgumentList arguments = new XsltArgumentList();
@@ -214,8 +214,10 @@ private static XsltArgumentList ProcessXsltArguments(string xsltParametersXml)
             try
             {
                 XmlReaderSettings settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                XmlReader reader = XmlReader.Create(new StringReader("<XsltParameters>" + xsltParametersXml + "</XsltParameters>"), settings);
-                doc.Load(reader);
+                using (XmlReader reader = XmlReader.Create(new StringReader("<XsltParameters>" + xsltParametersXml + "</XsltParameters>"), settings))
+                {
+                    doc.Load(reader);
+                }
             }
             catch (XmlException xe)
             {
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index 2c81395c138..ffd146c0d17 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -324,6 +324,25 @@ public void SetNullMetadataValue()
             item.GetMetadata("m").ShouldBe(string.Empty);
         }
 
+        [Fact]
+        public void ImplementsIMetadataContainer()
+        {
+            Dictionary<string, string> metadata = new()
+            {
+                { "a", "a1" },
+                { "b", "b1" },
+            };
+
+            TaskItem item = new TaskItem("foo");
+            IMetadataContainer metadataContainer = (IMetadataContainer)item;
+
+            metadataContainer.ImportMetadata(metadata);
+
+            var actualMetadata = metadataContainer.EnumerateMetadata().OrderBy(metadata => metadata.Key).ToList();
+            var expectedMetadata = metadata.OrderBy(metadata => metadata.Value).ToList();
+            Assert.True(actualMetadata.SequenceEqual(expectedMetadata));
+        }
+
 #if FEATURE_APPDOMAIN
         /// <summary>
         /// Test that task items can be successfully constructed based on a task item from another appdomain.  
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index b40b91cd8fa..308a4915321 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -827,6 +827,34 @@ protected override string GenerateCommandLineCommands()
         }
 
         /// <summary>
+        /// Verifies the validation of the <see cref="ToolTask.TaskProcessTerminationTimeout" />.
+        /// </summary>
+        /// <param name="timeout">New value for <see cref="ToolTask.TaskProcessTerminationTimeout" />.</param>
+        /// <param name="isInvalidValid">Is a task expected to be valid or not.</param>
+        [Theory]
+        [InlineData(int.MaxValue, false)]
+        [InlineData(97, false)]
+        [InlineData(0, false)]
+        [InlineData(-1, false)]
+        [InlineData(-2, true)]
+        [InlineData(-101, true)]
+        [InlineData(int.MinValue, true)]
+        public void SetsTerminationTimeoutCorrectly(int timeout, bool isInvalidValid)
+        {
+            using var env = TestEnvironment.Create(_output);
+
+            // Task under test:
+            var task = new ToolTaskSetsTerminationTimeout
+            {
+                BuildEngine = new MockEngine()
+            };
+
+            task.TerminationTimeout = timeout;
+            task.ValidateParameters().ShouldBe(!isInvalidValid);
+            task.TerminationTimeout.ShouldBe(timeout);
+        }
+		
+		/// <summary>
         /// Verifies that a ToolTask instance can return correct results when executed multiple times with timeout.
         /// </summary>
         /// <param name="repeats">Specifies the number of repeats for external command execution.</param>
@@ -960,5 +988,50 @@ public override bool Execute()
                 return base.Execute();
             }
         }
+
+        /// <summary>
+        /// A simple implementation of <see cref="ToolTask"/> to excercise <see cref="ToolTask.TaskProcessTerminationTimeout" />.
+        /// </summary>
+        private sealed class ToolTaskSetsTerminationTimeout : ToolTask
+        {
+            public ToolTaskSetsTerminationTimeout()
+                : base()
+            {
+                base.TaskResources = AssemblyResources.PrimaryResources;
+            }
+
+            /// <summary>
+            /// Gets or sets <see cref="ToolTask.TaskProcessTerminationTimeout" />.
+            /// </summary>
+            /// <remarks>
+            /// This is just a proxy property to access <see cref="ToolTask.TaskProcessTerminationTimeout" />.
+            /// </remarks>
+            public int TerminationTimeout
+            {
+                get => TaskProcessTerminationTimeout;
+                set => TaskProcessTerminationTimeout = value;
+            }
+
+            /// <summary>
+            /// Gets the tool name (dummy).
+            /// </summary>
+            protected override string ToolName => string.Empty;
+
+            /// <summary>
+            /// Gets the full path to tool (dummy).
+            /// </summary>
+            protected override string GenerateFullPathToTool() => string.Empty;
+
+            /// <summary>
+            /// Does nothing.
+            /// </summary>
+            /// <returns>
+            /// Always returns true.
+            /// </returns>
+            /// <remarks>
+            /// This dummy tool task is not meant to run anything.
+            /// </remarks>
+            public override bool Execute() => true;
+        }
     }
 }
diff --git a/src/Utilities/CompatibilitySuppressions.xml b/src/Utilities/CompatibilitySuppressions.xml
index 1c5e56d19a3..bb15e1e6c3e 100644
--- a/src/Utilities/CompatibilitySuppressions.xml
+++ b/src/Utilities/CompatibilitySuppressions.xml
@@ -1,6 +1,14 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <!-- We don't have the net7 reference assemblies handy to pass in to compare against the net8 ones -->
+  <Suppression>
+    <DiagnosticId>CP1002</DiagnosticId>
+    <Target>System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Target>
+    <Left>ref/net7.0/Microsoft.Build.Utilities.Core.dll</Left>
+    <Right>ref/netstandard2.0/Microsoft.Build.Utilities.Core.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
        This is intentional, because you can only use MSBuild in the context of a .NET SDK
        (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
@@ -54,7 +62,7 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-  <!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
+<!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
   <Suppression>
     <DiagnosticId>PKV006</DiagnosticId>
     <Target>net7.0</Target>
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 1b164ee1089..5b9a22eba36 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -34,11 +34,6 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="System.Text.Encoding.CodePages" />
   </ItemGroup>
-
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
-    <!-- Need Win32 API on .NET Standard to ping registry for some methods in ToolLocationHelper -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-  </ItemGroup>
   
   <ItemGroup Label="Shared Code">
     <Compile Include="..\Shared\AssemblyFolders\AssemblyFoldersEx.cs">
diff --git a/src/Utilities/Resources/Strings.resx b/src/Utilities/Resources/Strings.resx
index 639f489139e..1bbcf8ce260 100644
--- a/src/Utilities/Resources/Strings.resx
+++ b/src/Utilities/Resources/Strings.resx
@@ -290,6 +290,9 @@
     <value>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</value>
     <comment>{StrBegin="MSB6012: "}</comment>
   </data>
+  <data name="ToolTask.InvalidTerminationTimeout" xml:space="preserve">
+    <value>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</value>
+  </data>
   <!--
         The Utilities message bucket is: MSB6001 - MSB6200
 
diff --git a/src/Utilities/Resources/xlf/Strings.cs.xlf b/src/Utilities/Resources/xlf/Strings.cs.xlf
index f03d0670d1d..40ec557b1b3 100644
--- a/src/Utilities/Resources/xlf/Strings.cs.xlf
+++ b/src/Utilities/Resources/xlf/Strings.cs.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Nepodařilo se spustit spustitelný soubor zadané úlohy {0}. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Úlohu nelze přeskočit, protože není aktuální.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.de.xlf b/src/Utilities/Resources/xlf/Strings.de.xlf
index 7b1b9bbd81a..ae6c7f1d318 100644
--- a/src/Utilities/Resources/xlf/Strings.de.xlf
+++ b/src/Utilities/Resources/xlf/Strings.de.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Die angegebene ausführbare Datei der Aufgabe "{0}" konnte nicht ausgeführt werden. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Das angegebene Beendigungstimeout ({0}) ist ungültig. Es wird ein Wert größer oder gleich -1 erwartet.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Die Aufgabe kann nicht übersprungen werden, da sie nicht auf dem neuesten Stand ist.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.es.xlf b/src/Utilities/Resources/xlf/Strings.es.xlf
index 4e1d526942f..fb3fb6346d2 100644
--- a/src/Utilities/Resources/xlf/Strings.es.xlf
+++ b/src/Utilities/Resources/xlf/Strings.es.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: No se pudo ejecutar la tarea ejecutable especificada "{0}". {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">El tiempo de espera de finalización especificado ({0}) no es válido; se espera un valor mayor o igual que -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">No se puede omitir la tarea porque no está actualizada.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.fr.xlf b/src/Utilities/Resources/xlf/Strings.fr.xlf
index 16e18463161..eda5b70eadc 100644
--- a/src/Utilities/Resources/xlf/Strings.fr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.fr.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Impossible d'exécuter la tâche exécutable spécifiée "{0}". {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Nous n’avons pas pu ignorer la tâche, car elle n’est pas à jour.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.it.xlf b/src/Utilities/Resources/xlf/Strings.it.xlf
index 051435b8f45..a6f2388b69c 100644
--- a/src/Utilities/Resources/xlf/Strings.it.xlf
+++ b/src/Utilities/Resources/xlf/Strings.it.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: non è stato possibile eseguire il file eseguibile "{0}" dell'attività. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Il timeout di terminazione specificato ({0}) non è valido - è previsto un valore maggiore o uguale a -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Non è possibile ignorare l'attività perché non è aggiornata.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ja.xlf b/src/Utilities/Resources/xlf/Strings.ja.xlf
index f47ade5a30c..cbdd70df0f9 100644
--- a/src/Utilities/Resources/xlf/Strings.ja.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ja.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: 指定されたタスク実行可能ファイル "{0}" を実行できませんでした。{1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">タスクは最新ではないため、スキップできません。</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ko.xlf b/src/Utilities/Resources/xlf/Strings.ko.xlf
index 6e90f79aa10..dd22c108316 100644
--- a/src/Utilities/Resources/xlf/Strings.ko.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ko.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: 지정한 작업 실행 파일 "{0}"을(를) 실행할 수 없습니다. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">작업이 최신 상태가 아니므로 건너뛸 수 없습니다.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.pl.xlf b/src/Utilities/Resources/xlf/Strings.pl.xlf
index 0a40f6100e8..75c6c2b9bf9 100644
--- a/src/Utilities/Resources/xlf/Strings.pl.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pl.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Nie można uruchomić określonego pliku wykonywalnego zadania „{0}”. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Nie można pominąć zadania, ponieważ nie jest ono aktualne.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
index 4dac2b52e26..031011afb81 100644
--- a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Não foi possível executar a tarefa executável "{0}" especificada. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">O tempo limite de encerramento especificado ({0}) é inválido - esperando valor maior ou igual a -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Não foi possível ignorar a tarefa porque ela não está atualizada.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ru.xlf b/src/Utilities/Resources/xlf/Strings.ru.xlf
index ff9b0e8c2fa..af05a69213a 100644
--- a/src/Utilities/Resources/xlf/Strings.ru.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ru.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Не удалось запустить указанный исполняемый файл задачи "{0}". {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Указано недопустимое время ожидания завершения ({0}) — ожидается значение больше или равно –1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Невозможно пропустить задачу, поскольку она не обновлена.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.tr.xlf b/src/Utilities/Resources/xlf/Strings.tr.xlf
index badcc02495d..434da205f02 100644
--- a/src/Utilities/Resources/xlf/Strings.tr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.tr.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Belirtilen "{0}" görev yürütülebilir dosyası çalıştırılamadı. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Güncel olmadığı için görev atlanamıyor.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
index 3455e66d0d1..ae68e2fdab0 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: 指定的任务可执行文件“{0}”未能运行。{1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">指定的终止超时({0})无效 - 值应大于或等于 -1。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">无法跳过任务，因为它不是最新的。</target>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
index bf830c02ea3..d417911a7fa 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: 無法執行指定的工作可執行檔 "{0}"。{1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="new">Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">無法略過工作，因為它不是最新的。</target>
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 34d7b498183..858b35eb892 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -480,6 +480,12 @@ IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata()
             return EnumerateMetadataLazy();
         }
 
+        void IMetadataContainer.ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
+        {
+            _metadata ??= new CopyOnWriteDictionary<string>(MSBuildNameIgnoreCaseComparer.Default);
+            _metadata.SetItems(metadata.Select(kvp => new KeyValuePair<string, string>(kvp.Key, kvp.Value ?? string.Empty)));
+        }
+
         private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
         {
             if (_metadata == null)
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index daee4074552..3a8ff43f237 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -345,7 +345,16 @@ protected virtual void ProcessStarted() { }
         /// Implemented in the derived class
         /// </summary>
         /// <returns>true, if successful</returns>
-        protected internal virtual bool ValidateParameters() => true; // Default is no validation (ie. parameters are always valid, hence the true return value). This is useful for tools that don't need validation.
+        protected internal virtual bool ValidateParameters()
+        {
+            if (TaskProcessTerminationTimeout < -1 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+            {
+                Log.LogWarningWithCodeFromResources("ToolTask.InvalidTerminationTimeout", TaskProcessTerminationTimeout);
+                return false;
+            }
+
+            return true;
+        }
 
         /// <summary>
         /// Returns true if task execution is not necessary. Executed after ValidateParameters
@@ -945,7 +954,7 @@ private void KillToolProcessOnTimeout(Process proc, bool isBeingCancelled)
                     LogShared.LogWarningWithCodeFromResources("Shared.KillingProcessByCancellation", processName);
                 }
 
-                int timeout = 5000;
+                int timeout = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && TaskProcessTerminationTimeout >= -1 ? TaskProcessTerminationTimeout : 5000;
                 string timeoutFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDTOOLTASKCANCELPROCESSWAITTIMEOUT");
                 if (timeoutFromEnvironment != null)
                 {
diff --git a/src/Xunit.NetCore.Extensions/DotNetOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/DotNetOnlyFactAttribute.cs
deleted file mode 100644
index b1b0fb8baa4..00000000000
--- a/src/Xunit.NetCore.Extensions/DotNetOnlyFactAttribute.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    ///  This test should be run only on .NET (or .NET Core).
-    /// </summary>
-    public class DotNetOnlyFactAttribute : FactAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="DotNetOnlyFactAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public DotNetOnlyFactAttribute(string? additionalMessage = null)
-        {
-            if (!CustomXunitAttributesUtilities.IsBuiltAgainstDotNet)
-            {
-                this.Skip = "This test only runs on .NET.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/DotNetOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/DotNetOnlyTheoryAttribute.cs
deleted file mode 100644
index b6ee768534b..00000000000
--- a/src/Xunit.NetCore.Extensions/DotNetOnlyTheoryAttribute.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    ///  This test should be run only on .NET (or .NET Core).
-    /// </summary>
-    public class DotNetOnlyTheoryAttribute : TheoryAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="DotNetOnlyTheoryAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public DotNetOnlyTheoryAttribute(string? additionalMessage = null)
-        {
-            if (!CustomXunitAttributesUtilities.IsBuiltAgainstDotNet)
-            {
-                this.Skip = "This test only runs on .NET.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs
deleted file mode 100644
index f3878ef0de3..00000000000
--- a/src/Xunit.NetCore.Extensions/UnixOnlyFactAttribute.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Runtime.InteropServices;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    /// This test should be run only on Unix (Linux, OSX platforms).
-    /// </summary>
-    public class UnixOnlyFactAttribute : FactAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="UnixOnlyFactAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public UnixOnlyFactAttribute(string? additionalMessage = null)
-        {
-            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                this.Skip = "This test requires Unix to run.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs
deleted file mode 100644
index f0a1769882e..00000000000
--- a/src/Xunit.NetCore.Extensions/UnixOnlyTheoryAttribute.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Runtime.InteropServices;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    /// This test should be run only on Unix (Linux, OSX platforms).
-    /// </summary>
-    public class UnixOnlyTheoryAttribute : TheoryAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="UnixOnlyTheoryAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public UnixOnlyTheoryAttribute(string? additionalMessage = null)
-        {
-            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                this.Skip = "This test requires Unix to run.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyFactAttribute.cs
deleted file mode 100644
index 4caa40a3198..00000000000
--- a/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyFactAttribute.cs
+++ /dev/null
@@ -1,30 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Runtime.InteropServices;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    ///  This test should be run only on Windows on full .NET Framework.
-    /// </summary>
-    public class WindowsFullFrameworkOnlyFactAttribute : FactAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="WindowsFullFrameworkOnlyFactAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public WindowsFullFrameworkOnlyFactAttribute(string? additionalMessage = null)
-        {
-            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                this.Skip = "This test only runs on Windows on full framework.".AppendAdditionalMessage(additionalMessage);
-                return;
-            }
-            if (!CustomXunitAttributesUtilities.IsBuiltAgainstNetFramework)
-            {
-                this.Skip = "This test only runs on full framework.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyTheoryAttribute.cs
deleted file mode 100644
index 952bf0d7250..00000000000
--- a/src/Xunit.NetCore.Extensions/WindowsFullFrameworkOnlyTheoryAttribute.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Runtime.InteropServices;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    ///  This test should be run only on Windows on full .NET Framework.
-    /// </summary>
-    public class WindowsFullFrameworkOnlyTheoryAttribute : TheoryAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="WindowsFullFrameworkOnlyTheoryAttribute"/> class.
-        /// Creates the attribute.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public WindowsFullFrameworkOnlyTheoryAttribute(string? additionalMessage = null)
-        {
-            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                this.Skip = "This test only runs on Windows on full framework.".AppendAdditionalMessage(additionalMessage);
-                return;
-            }
-            if (!CustomXunitAttributesUtilities.IsBuiltAgainstNetFramework)
-            {
-                this.Skip = "This test only runs on full framework.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs
deleted file mode 100644
index 72f2378ad02..00000000000
--- a/src/Xunit.NetCore.Extensions/WindowsOnlyFactAttribute.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Runtime.InteropServices;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    /// This test should be run only on Windows.
-    /// </summary>
-    public class WindowsOnlyFactAttribute : FactAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="WindowsOnlyFactAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public WindowsOnlyFactAttribute(string? additionalMessage = null)
-        {
-            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                this.Skip = "This test requires Windows to run.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs
deleted file mode 100644
index dfc2be0b220..00000000000
--- a/src/Xunit.NetCore.Extensions/WindowsOnlyTheoryAttribute.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Runtime.InteropServices;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    /// This test should be run only on Windows.
-    /// </summary>
-    public class WindowsOnlyTheoryAttribute : TheoryAttribute
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="WindowsOnlyTheoryAttribute"/> class.
-        /// </summary>
-        /// <param name="additionalMessage">The additional message that is appended to skip reason, when test is skipped.</param>
-        public WindowsOnlyTheoryAttribute(string? additionalMessage = null)
-        {
-            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
-            {
-                this.Skip = "This test requires Windows to run.".AppendAdditionalMessage(additionalMessage);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Xunit.NetCore.Extensions.csproj b/src/Xunit.NetCore.Extensions/Xunit.NetCore.Extensions.csproj
index 6bc9b9cbc4d..01d47500a32 100644
--- a/src/Xunit.NetCore.Extensions/Xunit.NetCore.Extensions.csproj
+++ b/src/Xunit.NetCore.Extensions/Xunit.NetCore.Extensions.csproj
@@ -7,6 +7,8 @@
     <IsTestProject>false</IsTestProject><!-- while this project references xunit it isn't itself a test -->
   </PropertyGroup>
   <ItemGroup>
-    <PackageReference Include="xunit.core" />
+    <!-- Implicit references to xunit.core and xunit.assert in test projects by Arcade
+         cause restore failures if PackageVersion is in the normal .props file. -->
+    <PackageReference Include="xunit.core" VersionOverride="$(XUnitVersion)" />
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
