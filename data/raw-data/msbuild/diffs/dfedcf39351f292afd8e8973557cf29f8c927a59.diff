diff --git a/MSBuild.Dev.slnf b/MSBuild.Dev.slnf
index 1157c36a866..4ae636a74a6 100644
--- a/MSBuild.Dev.slnf
+++ b/MSBuild.Dev.slnf
@@ -13,7 +13,8 @@
       "src\\Tasks\\Microsoft.Build.Tasks.csproj",
       "src\\Utilities.UnitTests\\Microsoft.Build.Utilities.UnitTests.csproj",
       "src\\Utilities\\Microsoft.Build.Utilities.csproj",
-      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj"
+      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj",
+      "src\\StringTools\\StringTools.csproj"
     ]
   }
 }
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 79f2560c088..b070e47ccfb 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -22,11 +22,11 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 # Change Waves & Associated Features
 
 ## Current Rotation of Change Waves
-### 17.8
-- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
 
 ### 17.8
+- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
 - [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
+- [New serialization approach for transferring build exceptions between processes](https://github.com/dotnet/msbuild/pull/8779)
 
 ### 17.6
 - [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 78119f43696..548f4bd4db7 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -23,7 +23,7 @@
     <UsagePattern IdentityGlob="System.Reflection.Metadata/*7.0.0*" />
     <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*7.0.0*" />
     <UsagePattern IdentityGlob="System.Resources.Extensions/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*7.0.2*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*7.0.0*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*7.0.1*" />
     <UsagePattern IdentityGlob="System.Security.Permissions/*7.0.0*" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index b2b49d74af7..724c5623ad7 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -37,9 +37,9 @@
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>f3bb337e310ce44abda4ad73cdb0755ed940809d</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.7.0-3.23311.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.7.0-3.23318.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>4cbfec964e59687cd9cc8601df42b936c9c06f63</Sha>
+      <Sha>15da8d75200f3748547d3afef2987f1c2865ca9b</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23313.5">
diff --git a/eng/Versions.props b/eng/Versions.props
index ab0b8e95efe..30bbd35ae27 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -51,7 +51,7 @@
     <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23313.5</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.7.0-3.23311.1</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.7.0-3.23318.1</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.7.0-preview.2.51</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.0</SystemTextJsonVersion>
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 14986a790d2..c756257f7be 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -40,7 +40,7 @@
     <PackageVersion Include="System.Runtime" Version="4.3.1" />
     <PackageVersion Update="System.Runtime" Condition="'$(SystemRuntimeVersion)' != ''" Version="$(SystemRuntimeVersion)" />
 
-    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="7.0.0" />
+    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="7.0.2" />
     <PackageVersion Update="System.Security.Cryptography.Pkcs" Condition="'$(SystemSecurityCryptographyPkcsVersion)' != ''" Version="$(SystemSecurityCryptographyPkcsVersion)" />
 
     <PackageVersion Include="System.Security.Cryptography.Xml" Version="7.0.1" />
diff --git a/newc/Program.cs b/newc/Program.cs
deleted file mode 100644
index 3751555cbd3..00000000000
--- a/newc/Program.cs
+++ /dev/null
@@ -1,2 +0,0 @@
-﻿// See https://aka.ms/new-console-template for more information
-Console.WriteLine("Hello, World!");
diff --git a/newc/newc.csproj b/newc/newc.csproj
deleted file mode 100644
index 2150e3797ba..00000000000
--- a/newc/newc.csproj
+++ /dev/null
@@ -1,10 +0,0 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
-
-  <PropertyGroup>
-    <OutputType>Exe</OutputType>
-    <TargetFramework>net8.0</TargetFramework>
-    <ImplicitUsings>enable</ImplicitUsings>
-    <Nullable>enable</Nullable>
-  </PropertyGroup>
-
-</Project>
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 1dcc2fb9fc2..57cba86c10c 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -15,8 +15,9 @@
   </PropertyGroup>
 
   <PropertyGroup>
-    <NuGetCommandLinePackageVersion>4.1.0</NuGetCommandLinePackageVersion>
-</PropertyGroup>
+    <!-- Managed manually since PackageDownload is not supported by dependabot https://github.com/dependabot/dependabot-core/issues/2920 -->
+    <NuGetCommandLinePackageVersion>4.9.6</NuGetCommandLinePackageVersion>
+  </PropertyGroup>
 
   <ItemGroup>
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
@@ -28,7 +29,7 @@
 
   <ItemGroup>
     <!-- GeneratePathProperty currently isn't enabled for PackageDownload. -->
-    <Content Condition="'$(MSBuildRuntimeType)' != 'Core' and '$(Configuration)' == 'Release'" Include="$(NuGetPackageRoot)\nuget.commandline\$(NuGetCommandLinePackageVersion)\tools\NuGet.exe" CopyToOutputDirectory="PreserveNewest" Link="nuget\NuGet.exe" />
+    <Content Include="$(NuGetPackageRoot)\nuget.commandline\$(NuGetCommandLinePackageVersion)\tools\NuGet.exe" CopyToOutputDirectory="PreserveNewest" Link="nuget\NuGet.exe" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
index c0a00cf572e..ee35a83c93a 100644
--- a/src/Build.OM.UnitTests/NugetRestoreTests.cs
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -1,13 +1,11 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#if !DEBUG
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using System.IO;
 using Xunit;
-#endif
 using Xunit.Abstractions;
 using Xunit.NetCore.Extensions;
 
@@ -21,9 +19,7 @@ public NugetRestoreTests(ITestOutputHelper output)
             _output = output;
         }
 
-        // This NuGet version cannot locate other assemblies when parsing solutions at restore time. This includes localized strings required in debug mode.
-        // NuGet version 4.1.0 was somewhat arbitrarily chosen. 3.5 breaks with an unrelated error, and 4.8.2 does not fail when a new dependency is introduced. This is a safe middle point.
-#if !DEBUG
+        // Tests proper loading of msbuild assemblies by nuget.exe
         [WindowsFullFrameworkOnlyFact]
         public void TestOldNuget()
         {
@@ -54,6 +50,5 @@ public void TestOldNuget()
             RunnerUtilities.RunProcessAndGetOutput(Path.Combine(msbuildExePath, "nuget", "NuGet.exe"), "restore " + sln.Path + " -MSBuildPath \"" + msbuildExePath + "\"", out bool success, outputHelper: _output);
             success.ShouldBeTrue();
         }
-#endif
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index b1288952956..ba1e8c7b4eb 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -6,8 +6,13 @@
 using System.Configuration.Assemblies;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Reflection;
+using System.Runtime.CompilerServices;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
 using Shouldly;
 using Xunit;
 
@@ -20,6 +25,11 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     public class BinaryTranslator_Tests
     {
+        static BinaryTranslator_Tests()
+        {
+            SerializationContractInitializer.Initialize();
+        }
+
         /// <summary>
         /// Tests the SerializationMode property
         /// </summary>
@@ -27,7 +37,7 @@ public class BinaryTranslator_Tests
         public void TestSerializationMode()
         {
             MemoryStream stream = new MemoryStream();
-            using ITranslator readTranslator = BinaryTranslator.GetReadTranslator(stream, null);
+            using ITranslator readTranslator = BinaryTranslator.GetReadTranslator(stream, InterningBinaryReader.PoolingBuffer);
             Assert.Equal(TranslationDirection.ReadFromStream, readTranslator.Mode);
 
             using ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(stream);
@@ -183,7 +193,7 @@ public void TestSerializeDotNet()
             ArgumentNullException deserializedValue = null;
             TranslationHelpers.GetReadTranslator().TranslateDotNet(ref deserializedValue);
 
-            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
         }
 
         /// <summary>
@@ -198,7 +208,125 @@ public void TestSerializeDotNetNull()
             ArgumentNullException deserializedValue = null;
             TranslationHelpers.GetReadTranslator().TranslateDotNet(ref deserializedValue);
 
-            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
+        }
+
+        [Fact]
+        public void TestSerializeException()
+        {
+            Exception value = new ArgumentNullException("The argument was null");
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
+        }
+
+        [Fact]
+        public void TestSerializeException_NestedWithStack()
+        {
+            Exception value = null;
+            try
+            {
+                // Intentionally throw a nested exception with a stack trace.
+                value = value.InnerException;
+            }
+            catch (Exception e)
+            {
+                value = new ArgumentNullException("The argument was null", e);
+            }
+
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
+        }
+
+        [Fact]
+        public void TestSerializeBuildException_NestedWithStack()
+        {
+            Exception value = null;
+            try
+            {
+                throw new InvalidProjectFileException("sample message");
+            }
+            catch (Exception e)
+            {
+                try
+                {
+                    throw new ArgumentNullException("The argument was null", e);
+                }
+                catch (Exception exception)
+                {
+                    value = new InternalErrorException("Another message", exception);
+                }
+            }
+
+            Assert.NotNull(value);
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason), diffReason);
+        }
+
+        public static IEnumerable<object[]> GetBuildExceptionsAsTestData()
+            => AppDomain
+                .CurrentDomain
+                .GetAssemblies()
+                // TaskHost is copying code files - so has a copy of types with identical names.
+                .Where(a => !a.FullName!.StartsWith("MSBuildTaskHost", StringComparison.CurrentCultureIgnoreCase))
+                .SelectMany(s => s.GetTypes())
+                .Where(BuildExceptionSerializationHelper.IsSupportedExceptionType)
+                .Select(t => new object[] { t });
+
+        [Theory]
+        [MemberData(nameof(GetBuildExceptionsAsTestData))]
+        public void TestSerializationOfBuildExceptions(Type exceptionType)
+        {
+            Exception e = (Exception)Activator.CreateInstance(exceptionType, BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.CreateInstance | BindingFlags.Instance, null, new object[]{"msg", new GenericBuildTransferredException() }, System.Globalization.CultureInfo.CurrentCulture);
+            Exception remote;
+            try
+            {
+                throw e;
+            }
+            catch (Exception exception)
+            {
+                remote = exception;
+            }
+
+            Assert.NotNull(remote);
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref remote);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(remote, deserializedValue, out string diffReason, true), $"Exception type {exceptionType.FullName} not properly de/serialized: {diffReason}");
+        }
+
+        [Fact]
+        public void TestInvalidProjectFileException_NestedWithStack()
+        {
+            Exception value = null;
+            try
+            {
+                throw new InvalidProjectFileException("sample message", new InternalErrorException("Another message"));
+            }
+            catch (Exception e)
+            {
+                value = e;
+            }
+
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue, out string diffReason, true), diffReason);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
index 13269b5221a..02c1179e863 100644
--- a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
@@ -326,16 +326,16 @@ public void TestTranslation()
 
             Assert.Equal(result.ConfigurationId, deserializedResult.ConfigurationId);
             Assert.True(TranslationHelpers.CompareCollections(result.DefaultTargets, deserializedResult.DefaultTargets, StringComparer.Ordinal));
-            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception, out string diffReason), diffReason);
             Assert.Equal(result.Exception.Message, deserializedResult.Exception.Message);
             Assert.Equal(result.GlobalRequestId, deserializedResult.GlobalRequestId);
             Assert.True(TranslationHelpers.CompareCollections(result.InitialTargets, deserializedResult.InitialTargets, StringComparer.Ordinal));
             Assert.Equal(result.NodeRequestId, deserializedResult.NodeRequestId);
             Assert.Equal(result["alpha"].ResultCode, deserializedResult["alpha"].ResultCode);
-            Assert.True(TranslationHelpers.CompareExceptions(result["alpha"].Exception, deserializedResult["alpha"].Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result["alpha"].Exception, deserializedResult["alpha"].Exception, out diffReason), diffReason);
             Assert.True(TranslationHelpers.CompareCollections(result["alpha"].Items, deserializedResult["alpha"].Items, TaskItemComparer.Instance));
             Assert.Equal(result["omega"].ResultCode, deserializedResult["omega"].ResultCode);
-            Assert.True(TranslationHelpers.CompareExceptions(result["omega"].Exception, deserializedResult["omega"].Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result["omega"].Exception, deserializedResult["omega"].Exception, out diffReason), diffReason);
             Assert.True(TranslationHelpers.CompareCollections(result["omega"].Items, deserializedResult["omega"].Items, TaskItemComparer.Instance));
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
index 5c653497011..d9fb204fb78 100644
--- a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
@@ -102,7 +102,7 @@ public void TestTranslationNoException()
 
             Assert.Equal(result.ResultCode, deserializedResult.ResultCode);
             Assert.True(TranslationHelpers.CompareCollections(result.Items, deserializedResult.Items, TaskItemComparer.Instance));
-            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception, out string diffReason), diffReason);
             Assert.Equal(result.OriginalBuildEventContext, deserializedResult.OriginalBuildEventContext);
         }
 
@@ -122,7 +122,7 @@ public void TestTranslationWithException()
 
             Assert.Equal(result.ResultCode, deserializedResult.ResultCode);
             Assert.True(TranslationHelpers.CompareCollections(result.Items, deserializedResult.Items, TaskItemComparer.Instance));
-            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception));
+            Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception, out string diffReason), diffReason);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
index 60f073a0cf2..7d4736837ce 100644
--- a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
+++ b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
@@ -9,6 +9,7 @@
 using System.Text;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
+using Xunit;
 
 #nullable disable
 
@@ -40,7 +41,7 @@ internal static ITranslator GetWriteTranslator()
         internal static ITranslator GetReadTranslator()
         {
             s_serializationStream.Seek(0, SeekOrigin.Begin);
-            return BinaryTranslator.GetReadTranslator(s_serializationStream, null);
+            return BinaryTranslator.GetReadTranslator(s_serializationStream, InterningBinaryReader.PoolingBuffer);
         }
 
         /// <summary>
@@ -85,8 +86,9 @@ internal static bool CompareCollections<T>(ICollection<T> left, ICollection<T> r
         /// <summary>
         /// Compares two exceptions.
         /// </summary>
-        internal static bool CompareExceptions(Exception left, Exception right)
+        internal static bool CompareExceptions(Exception left, Exception right, out string diffReason, bool detailed = false)
         {
+            diffReason = null;
             if (ReferenceEquals(left, right))
             {
                 return true;
@@ -94,20 +96,74 @@ internal static bool CompareExceptions(Exception left, Exception right)
 
             if ((left == null) ^ (right == null))
             {
+                diffReason = "One exception is null and the other is not.";
                 return false;
             }
 
             if (left.Message != right.Message)
             {
+                diffReason = $"Exception messages are different ({left.Message} vs {right.Message}).";
                 return false;
             }
 
             if (left.StackTrace != right.StackTrace)
             {
+                diffReason = $"Exception stack traces are different ({left.StackTrace} vs {right.StackTrace}).";
                 return false;
             }
 
-            return CompareExceptions(left.InnerException, right.InnerException);
+            if (!CompareExceptions(left.InnerException, right.InnerException, out diffReason, detailed))
+            {
+                diffReason = "Inner exceptions are different: " + diffReason;
+                return false;
+            }
+
+            if (detailed)
+            {
+                if (left.GetType() != right.GetType())
+                {
+                    diffReason = $"Exception types are different ({left.GetType().FullName} vs {right.GetType().FullName}).";
+                    return false;
+                }
+
+                foreach (var prop in left.GetType().GetProperties())
+                {
+                    if (!IsSimpleType(prop.PropertyType))
+                    {
+                        continue;
+                    }
+
+                    object leftProp = prop.GetValue(left, null);
+                    object rightProp = prop.GetValue(right, null);
+
+                    if (leftProp == null && rightProp != null)
+                    {
+                        diffReason = $"Property {prop.Name} is null on left but not on right.";
+                        return false;
+                    }
+
+                    if (leftProp != null && !prop.GetValue(left, null).Equals(prop.GetValue(right, null)))
+                    {
+                        diffReason = $"Property {prop.Name} is different ({prop.GetValue(left, null)} vs {prop.GetValue(rightProp, null)}).";
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        }
+
+        internal static bool IsSimpleType(Type type)
+        {
+            // Nullables
+            if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))
+            {
+                return IsSimpleType(type.GetGenericArguments()[0]);
+            }
+            return type.IsPrimitive
+                   || type.IsEnum
+                   || type == typeof(string)
+                   || type == typeof(decimal);
         }
 
         internal static string GetPropertiesString(IEnumerable properties)
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index e16f3578b22..57e2bc3fa82 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -228,12 +228,24 @@ public void AssemblyLoadsDuringTaskRunLogged()
                 BinaryLogger logger = new();
                 logger.Parameters = _logFile;
                 env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
-                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -nr:False -bl:{logger.Parameters}", out bool success);
-                success.ShouldBeTrue();
-                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -nr:False -bl:{logger.Parameters} -flp1:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile2.log")};verbosity=normal", out bool success);
                 success.ShouldBeTrue();
+
+                string assemblyLoadedEventText =
+                    "Assembly loaded during TaskRun (InlineCode.HelloWorld): System.Diagnostics.Debug";
                 string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
-                text.ShouldContain("Assembly loaded during TaskRun (InlineCode.HelloWorld): System.Diagnostics.Debug");
+                text.ShouldContain(assemblyLoadedEventText);
+                // events should not be in logger with verbosity normal
+                string text2 = File.ReadAllText(Path.Combine(logFolder.Path, "logFile2.log"));
+                text2.ShouldNotContain(assemblyLoadedEventText);
+
+                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp1:logfile={Path.Combine(logFolder.Path, "logFile3.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile4.log")};verbosity=normal", out success);
+                success.ShouldBeTrue();
+                text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile3.log"));
+                text.ShouldContain(assemblyLoadedEventText);
+                // events should not be in logger with verbosity normal
+                text2 = File.ReadAllText(Path.Combine(logFolder.Path, "logFile4.log"));
+                text2.ShouldNotContain(assemblyLoadedEventText);
             }
         }
 
diff --git a/src/Build.UnitTests/InternalEngineHelpers.cs b/src/Build.UnitTests/InternalEngineHelpers.cs
index 4751aef9ddd..8590a479da9 100644
--- a/src/Build.UnitTests/InternalEngineHelpers.cs
+++ b/src/Build.UnitTests/InternalEngineHelpers.cs
@@ -175,7 +175,7 @@ internal static void AssertBuildResultsEqual(BuildResult actualBuildResult, Buil
 
             internal static void AssertTargetResultsEqual(TargetResult a, TargetResult b)
             {
-                TranslationHelpers.CompareExceptions(a.Exception, b.Exception).ShouldBeTrue();
+                TranslationHelpers.CompareExceptions(a.Exception, b.Exception, out string diffReason).ShouldBeTrue(diffReason);
                 TranslationHelpers.CompareCollections(a.Items, b.Items, TaskItemComparer.Instance).ShouldBeTrue();
 
                 a.ResultCode.ShouldBe(b.ResultCode);
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 9787ffe4a5c..74a8ad6e500 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -306,6 +306,7 @@ public BuildManager(string hostName)
             _nextUnnamedProjectId = 1;
             _componentFactories = new BuildComponentFactoryCollection(this);
             _componentFactories.RegisterDefaultFactories();
+            SerializationContractInitializer.Initialize();
             _projectStartedEvents = new Dictionary<int, BuildEventArgs>();
 
             _projectStartedEventHandler = OnProjectStarted;
diff --git a/src/Build/BackEnd/BuildManager/CacheSerialization.cs b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
index 3fa59bfe28b..7003cce1c32 100644
--- a/src/Build/BackEnd/BuildManager/CacheSerialization.cs
+++ b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
@@ -121,7 +121,7 @@ public static (IConfigCache ConfigCache, IResultsCache ResultsCache, Exception e
 
                 using (var fileStream = File.OpenRead(inputCacheFile))
                 {
-                    using var translator = BinaryTranslator.GetReadTranslator(fileStream, null);
+                    using var translator = BinaryTranslator.GetReadTranslator(fileStream, InterningBinaryReader.PoolingBuffer);
 
                     translator.Translate(ref configCache);
                     translator.Translate(ref resultsCache);
diff --git a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
index 657bfc4b4fb..aa7efb8cd72 100644
--- a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -19,7 +20,7 @@ namespace Microsoft.Build.BackEnd
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    internal class NodeFailedToLaunchException : Exception
+    internal class NodeFailedToLaunchException : BuildExceptionBase
     {
         /// <summary>
         /// Constructs a standard NodeFailedToLaunchException.
@@ -33,6 +34,10 @@ internal NodeFailedToLaunchException(Exception innerException)
             : base(innerException.Message, innerException)
         { }
 
+        public NodeFailedToLaunchException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Constructs a standard NodeFailedToLaunchException.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 7346954557d..58105527c16 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -598,7 +598,7 @@ private enum ExitPacketState
             /// <summary>
             /// Per node read buffers
             /// </summary>
-            private SharedReadBuffer _sharedReadBuffer;
+            private BinaryReaderFactory _binaryReaderFactory;
 
             /// <summary>
             /// Constructor.
@@ -616,7 +616,7 @@ public NodeContext(int nodeId, Process process,
                 _readBufferMemoryStream = new MemoryStream();
                 _writeBufferMemoryStream = new MemoryStream();
                 _terminateDelegate = terminateDelegate;
-                _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
+                _binaryReaderFactory = InterningBinaryReader.CreateSharedBuffer();
             }
 
             /// <summary>
@@ -982,7 +982,7 @@ private bool ReadAndRoutePacket(NodePacketType packetType, byte[] packetData, in
                     // Since the buffer is publicly visible dispose right away to discourage outsiders from holding a reference to it.
                     using (var packetStream = new MemoryStream(packetData, 0, packetLength, /*writeable*/ false, /*bufferIsPubliclyVisible*/ true))
                     {
-                        ITranslator readTranslator = BinaryTranslator.GetReadTranslator(packetStream, _sharedReadBuffer);
+                        ITranslator readTranslator = BinaryTranslator.GetReadTranslator(packetStream, _binaryReaderFactory);
                         _packetFactory.DeserializeAndRoutePacket(_nodeId, packetType, readTranslator);
                     }
                 }
diff --git a/src/Build/BackEnd/Components/Communications/SerializationContractInitializer.cs b/src/Build/BackEnd/Components/Communications/SerializationContractInitializer.cs
new file mode 100644
index 00000000000..a0dc533bbd1
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/SerializationContractInitializer.cs
@@ -0,0 +1,43 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal static class SerializationContractInitializer
+    {
+        public static void Initialize()
+        {
+            RegisterExceptions();
+            // reserved for future usage - BuildEventArgs, etc.
+        }
+
+        private static void RegisterExceptions()
+        {
+            // Any exception not contained int this list will be transferred as a GenericBuildTransferredException
+            BuildExceptionSerializationHelper.InitializeSerializationContract(
+                new(typeof(GenericBuildTransferredException), (msg, inner) => new GenericBuildTransferredException(msg, inner)),
+                new(typeof(SdkResolverException), (msg, inner) => new SdkResolverException(msg, inner)),
+                new(typeof(BuildAbortedException), BuildAbortedException.CreateFromRemote),
+                new(typeof(CircularDependencyException), (msg, inner) => new CircularDependencyException(msg, inner)),
+                new(typeof(InternalLoggerException), (msg, inner) => new InternalLoggerException(msg, inner)),
+                new(typeof(InvalidProjectFileException), (msg, inner) => new InvalidProjectFileException(msg, inner)),
+                new(typeof(InvalidToolsetDefinitionException), (msg, inner) => new InvalidToolsetDefinitionException(msg, inner)),
+                new(typeof(ProjectCacheException), (msg, inner) => new ProjectCacheException(msg, inner)),
+                new(typeof(InternalErrorException), InternalErrorException.CreateFromRemote),
+                new(typeof(LoggerException), (msg, inner) => new LoggerException(msg, inner)),
+                new(typeof(NodeFailedToLaunchException), (msg, inner) => new NodeFailedToLaunchException(msg, inner)),
+                new(typeof(SchedulerCircularDependencyException), (msg, inner) => new SchedulerCircularDependencyException(msg, inner)),
+                new(typeof(RegistryException), (msg, inner) => new RegistryException(msg, inner)),
+                new(typeof(HostObjectException), (msg, inner) => new HostObjectException(msg, inner)),
+                new(typeof(UnbuildableProjectTypeException), (msg, inner) => new UnbuildableProjectTypeException(msg, inner)));
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
index 3b1a9bb3dca..d2f76b4c577 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -12,7 +13,7 @@ namespace Microsoft.Build.Experimental.ProjectCache
     /// This exception is used to wrap an unhandled exception from a project cache plugin. This exception aborts the build, and it can only be
     /// thrown by the MSBuild engine.
     /// </summary>
-    public sealed class ProjectCacheException : Exception
+    public sealed class ProjectCacheException : BuildExceptionBase
     {
         private ProjectCacheException()
         {
@@ -33,6 +34,10 @@ private ProjectCacheException(
             ErrorCode = errorCode;
         }
 
+        internal ProjectCacheException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// The project cache has already logged this as an error.
         /// Should not get logged again.
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs b/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
index 405d0290483..61ba3fabbaf 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -14,7 +15,7 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     [SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors", Justification = "No point in adding the serialization constructors since BuildRequest is not serializable")]
     [SuppressMessage("Microsoft.Usage", "CA2237:MarkISerializableTypesWithSerializable", Justification = "No point in marking as ISerializable since BuildRequest is not. ")]
-    internal class SchedulerCircularDependencyException : Exception
+    internal class SchedulerCircularDependencyException : BuildExceptionBase
     {
         /// <summary>
         /// The ancestors which led to this circular dependency.
@@ -35,6 +36,11 @@ public SchedulerCircularDependencyException(BuildRequest request, IList<Schedula
             _ancestors = ancestors;
         }
 
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal SchedulerCircularDependencyException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Gets an enumeration of the ancestors which led to this circular dependency.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs
index bd8af074fb0..656cc7f4aab 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -12,7 +13,7 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// <summary>
     /// Represents an exception that occurs when an SdkResolver throws an unhandled exception.
     /// </summary>
-    public class SdkResolverException : Exception
+    public class SdkResolverException : BuildExceptionBase
     {
         public SdkResolver Resolver { get; private set; }
 
@@ -24,5 +25,10 @@ public SdkResolverException(string resourceName, SdkResolver resolver, SdkRefere
             Resolver = resolver;
             Sdk = sdk;
         }
+
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal SdkResolverException(string message, Exception inner)
+            : base(message, inner)
+        { }
     }
 }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index c0c3531ff34..83a74bee7d6 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -144,6 +144,7 @@ public OutOfProcNode()
 
             _componentFactories = new BuildComponentFactoryCollection(this);
             _componentFactories.RegisterDefaultFactories();
+            SerializationContractInitializer.Initialize();
             _packetFactory = new NodePacketFactory();
 
             _buildRequestEngine = (this as IBuildComponentHost).GetComponent(BuildComponentType.RequestEngine) as IBuildRequestEngine;
diff --git a/src/Build/BackEnd/Shared/BuildAbortedException.cs b/src/Build/BackEnd/Shared/BuildAbortedException.cs
index ab5d34af0e4..09f107a93f8 100644
--- a/src/Build/BackEnd/Shared/BuildAbortedException.cs
+++ b/src/Build/BackEnd/Shared/BuildAbortedException.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -21,7 +23,7 @@ namespace Microsoft.Build.Exceptions
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    public class BuildAbortedException : Exception
+    public class BuildAbortedException : BuildExceptionBase
     {
         /// <summary>
         /// Constructs a standard BuildAbortedException.
@@ -49,11 +51,40 @@ public BuildAbortedException(string message)
         /// Constructs a BuildAbortedException with an additional message attached and an inner exception.
         /// </summary>
         public BuildAbortedException(string message, Exception innerException)
-            : base(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildAbortedWithMessage", message), innerException)
+            : this(message, innerException, false)
+        { }
+
+        internal static BuildAbortedException CreateFromRemote(string message, Exception innerException)
         {
-            ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "BuildAbortedWithMessage", message);
+            return new BuildAbortedException(message, innerException, true /* calledFromDeserialization */);
+        }
 
-            ErrorCode = errorCode;
+        private BuildAbortedException(string message, Exception innerException, bool calledFromDeserialization)
+            : base(
+                calledFromDeserialization
+                    ? message
+                    : ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildAbortedWithMessage", message),
+                innerException)
+        {
+            if (!calledFromDeserialization)
+            {
+                ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "BuildAbortedWithMessage", message);
+
+                ErrorCode = errorCode;
+            }
+        }
+
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(ErrorCode), ErrorCode }
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            ErrorCode = state[nameof(ErrorCode)];
         }
 
         /// <summary>
@@ -70,7 +101,7 @@ protected BuildAbortedException(SerializationInfo info, StreamingContext context
         /// Gets the error code (if any) associated with the exception message.
         /// </summary>
         /// <value>Error code string, or null.</value>
-        public string ErrorCode { get; }
+        public string ErrorCode { get; private set; }
 
         /// <summary>
         /// ISerializable method which we must override since Exception implements this interface
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 7fb5d26c006..838210573f6 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -1037,7 +1037,7 @@ private ITranslator GetConfigurationTranslator(TranslationDirection direction)
                 else
                 {
                     // Not using sharedReadBuffer because this is not a memory stream and so the buffer won't be used anyway.
-                    return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), null);
+                    return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), InterningBinaryReader.PoolingBuffer);
                 }
             }
             catch (Exception e) when (e is DirectoryNotFoundException || e is UnauthorizedAccessException)
diff --git a/src/Build/BackEnd/Shared/CircularDependencyException.cs b/src/Build/BackEnd/Shared/CircularDependencyException.cs
index 08cfb2a4783..11ea521d9ed 100644
--- a/src/Build/BackEnd/Shared/CircularDependencyException.cs
+++ b/src/Build/BackEnd/Shared/CircularDependencyException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -16,7 +17,7 @@ namespace Microsoft.Build.Exceptions
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    public class CircularDependencyException : Exception
+    public class CircularDependencyException : BuildExceptionBase
     {
         /// <summary>
         /// Constructs a standard BuildAbortedException.
@@ -30,6 +31,11 @@ internal CircularDependencyException(string message)
         {
         }
 
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal CircularDependencyException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Constructor for deserialization.
         /// </summary>
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 3136450178d..2840148876c 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -327,7 +327,7 @@ private void TranslateItems(ITranslator translator)
                 ErrorUtilities.VerifyThrow(buffer != null, "Unexpected null items buffer during translation.");
 
                 using MemoryStream itemsStream = new MemoryStream(buffer, 0, buffer.Length, writable: false, publiclyVisible: true);
-                using var itemTranslator = BinaryTranslator.GetReadTranslator(itemsStream, null);
+                using var itemTranslator = BinaryTranslator.GetReadTranslator(itemsStream, InterningBinaryReader.PoolingBuffer);
                 _items = new TaskItem[itemsCount];
                 for (int i = 0; i < _items.Length; i++)
                 {
@@ -355,7 +355,7 @@ private static ITranslator GetResultsCacheTranslator(int configId, string target
             }
             else
             {
-                return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), null);
+                return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), InterningBinaryReader.PoolingBuffer);
             }
         }
 
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..eebde973639
--- /dev/null
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -0,0 +1,39 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <!-- Need to suppress due to AppCompat limitation https://github.com/dotnet/sdk/issues/32922	 -->
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.BackEnd.SdkResolution.SdkResolverException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Exceptions.BuildAbortedException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Exceptions.CircularDependencyException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Exceptions.InternalLoggerException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Exceptions.InvalidToolsetDefinitionException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Exceptions.InvalidProjectFileException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.ProjectCache.ProjectCacheException</Target>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+</Suppressions>
\ No newline at end of file
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index 06daa610cd9..74fbd3dfb6f 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -9,6 +9,8 @@
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
+using System.Collections.Generic;
 
 #nullable disable
 
@@ -22,7 +24,7 @@ namespace Microsoft.Build.Exceptions
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
-    public sealed class InternalLoggerException : Exception
+    public sealed class InternalLoggerException : BuildExceptionBase
     {
         #region Unusable constructors
 
@@ -63,9 +65,7 @@ public InternalLoggerException(string message)
         /// <exception cref="InvalidOperationException"></exception>
         public InternalLoggerException(string message, Exception innerException)
             : base(message, innerException)
-        {
-            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
-        }
+        { }
 
         #endregion
 
@@ -136,6 +136,23 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("initializationException", initializationException);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(errorCode), errorCode },
+                { nameof(helpKeyword), helpKeyword },
+                { nameof(initializationException), initializationException.ToString() },
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            errorCode = state[nameof(errorCode)];
+            helpKeyword = state[nameof(helpKeyword)];
+            initializationException = bool.Parse(state[nameof(initializationException)]);
+        }
+
         /// <summary>
         /// Provide default values for optional members
         /// </summary>
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index 71c7d93d2cc..8a15be32d42 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -3,10 +3,11 @@
 
 using System;
 using System.Runtime.Serialization;
+using System.Collections.Generic;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
-
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -21,7 +22,7 @@ namespace Microsoft.Build.Exceptions
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
-    public sealed class InvalidProjectFileException : Exception
+    public sealed class InvalidProjectFileException : BuildExceptionBase
     {
         #region Basic constructors
 
@@ -122,6 +123,35 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("hasBeenLogged", hasBeenLogged);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(file), file },
+                { nameof(lineNumber), lineNumber.ToString() },
+                { nameof(columnNumber), columnNumber.ToString() },
+                { nameof(endLineNumber), endLineNumber.ToString() },
+                { nameof(endColumnNumber), endColumnNumber.ToString() },
+                { nameof(errorSubcategory), errorSubcategory },
+                { nameof(errorCode), errorCode },
+                { nameof(helpKeyword), helpKeyword },
+                { nameof(hasBeenLogged), hasBeenLogged.ToString() },
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            file = state[nameof(file)];
+            lineNumber = int.Parse(state[nameof(lineNumber)]);
+            columnNumber = int.Parse(state[nameof(columnNumber)]);
+            endLineNumber = int.Parse(state[nameof(endLineNumber)]);
+            endColumnNumber = int.Parse(state[nameof(endColumnNumber)]);
+            errorSubcategory = state[nameof(errorSubcategory)];
+            errorCode = state[nameof(errorCode)];
+            helpKeyword = state[nameof(helpKeyword)];
+            hasBeenLogged = bool.Parse(state[nameof(hasBeenLogged)]);
+        }
+
         #endregion
 
         #region Rich constructors
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index 9f7c51e0b61..be588b6e061 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -1,10 +1,11 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
+using System;
 using System.Runtime.Serialization;
+using System.Collections.Generic;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -17,7 +18,7 @@ namespace Microsoft.Build.Exceptions
     /// Exception subclass that ToolsetReaders should throw.
     /// </summary>
     [Serializable]
-    public class InvalidToolsetDefinitionException : Exception
+    public class InvalidToolsetDefinitionException : BuildExceptionBase
     {
         /// <summary>
         /// The MSBuild error code corresponding with this exception.
@@ -103,6 +104,19 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("errorCode", errorCode);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(errorCode), errorCode }
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            errorCode = state[nameof(errorCode)];
+        }
+
         /// <summary>
         /// The MSBuild error code corresponding with this exception, or
         /// null if none was specified.
diff --git a/src/Build/Errors/RegistryException.cs b/src/Build/Errors/RegistryException.cs
index 13d4335634d..e3aee195277 100644
--- a/src/Build/Errors/RegistryException.cs
+++ b/src/Build/Errors/RegistryException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -12,7 +13,7 @@ namespace Microsoft.Build.Exceptions
     /// Generic exception used to wrap exceptions thrown during Registry access.
     /// </summary>
     [Serializable]
-    internal class RegistryException : Exception
+    internal class RegistryException : BuildExceptionBase
     {
         /// <summary>
         /// Basic constructor.
diff --git a/src/Build/Instance/HostObjectException.cs b/src/Build/Instance/HostObjectException.cs
index a38d07726c0..ee4613d1b14 100644
--- a/src/Build/Instance/HostObjectException.cs
+++ b/src/Build/Instance/HostObjectException.cs
@@ -2,13 +2,14 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
 namespace Microsoft.Build.Execution
 {
     [Serializable]
-    internal sealed class HostObjectException : Exception
+    internal sealed class HostObjectException : BuildExceptionBase
     {
         private const string ErrorMessagePrefix = "Error for HostObject:";
         private const string ErrorMessageProjectTargetTask = "In Project '{0}', Target '{1}', Task '{2}'.";
@@ -56,5 +57,11 @@ internal HostObjectException(
                 + string.Format(ErrorMessageProjectTargetTask, projectFile, targetName, taskName) + message)
         {
         }
+
+        internal HostObjectException(string message, Exception innerException)
+            : base(
+                message,
+                innerException)
+        { }
     }
 }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 53d46b1290d..7619850d4a7 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -609,7 +609,7 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                     _properties.Set(property.DeepClone(_isImmutable));
                 }
 
-                _items = new ItemDictionary<ProjectItemInstance>(that._items.ItemTypes.Count);
+                _items = new ItemDictionary<ProjectItemInstance>(that._items.Count);
 
                 foreach (ProjectItemInstance item in that.Items)
                 {
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 6e6725c439d..1bc5e67a847 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -110,9 +110,6 @@
     <Compile Include="..\Shared\INodePacket.cs" />
     <Compile Include="..\Shared\INodePacketFactory.cs" />
     <Compile Include="..\Shared\INodePacketHandler.cs" />
-    <Compile Include="..\Shared\ITranslatable.cs" />
-    <Compile Include="..\Shared\ITranslator.cs" />
-    <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\LogMessagePacketBase.cs" />
     <Compile Include="..\Shared\NodePacketFactory.cs" />
     <Compile Include="..\Shared\NodeBuildComplete.cs" />
@@ -155,6 +152,7 @@
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\ProjectCache\*.cs" />
     <Compile Include="BackEnd\Components\Communications\CurrentHost.cs" />
+    <Compile Include="BackEnd\Components\Communications\SerializationContractInitializer.cs" />
     <Compile Include="BackEnd\Components\Communications\ServerNodeEndpointOutOfProc.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\AssemblyLoadsTracker.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
diff --git a/src/Build/Xml/ProjectXmlUtilities.cs b/src/Build/Xml/ProjectXmlUtilities.cs
index 25667c21f6c..c5ef688824e 100644
--- a/src/Build/Xml/ProjectXmlUtilities.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -16,12 +17,17 @@ namespace Microsoft.Build.Internal
     /// <summary>
     /// Exception indicating that we tried to build a type of project MSBuild did not recognize.
     /// </summary>
-    internal sealed class UnbuildableProjectTypeException : Exception
+    internal sealed class UnbuildableProjectTypeException : BuildExceptionBase
     {
         internal UnbuildableProjectTypeException(string file)
             : base(file)
         {
         }
+
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal UnbuildableProjectTypeException(string message, Exception inner)
+            : base(message, inner)
+        { }
     }
 
     /// <summary>
diff --git a/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs b/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
index 8e2bf7db11b..f0cdf2232cd 100644
--- a/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/AssemblyLoadBuildEventArgs_Tests.cs
@@ -29,7 +29,8 @@ public void SerializationDeserializationTest()
             stream.Position = 0;
             using BinaryReader br = new BinaryReader(stream);
             AssemblyLoadBuildEventArgs argDeserialized = new();
-            argDeserialized.CreateFromStream(br, 0);
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+            argDeserialized.CreateFromStream(br, packetVersion);
 
             argDeserialized.LoadingInitiator.ShouldBe(loadingInitiator);
             argDeserialized.AssemblyName.ShouldBe(assemblyName);
@@ -37,6 +38,7 @@ public void SerializationDeserializationTest()
             argDeserialized.MVID.ShouldBe(mvid);
             argDeserialized.AppDomainDescriptor.ShouldBe(appDomainName);
             argDeserialized.LoadingContext.ShouldBe(context);
+            argDeserialized.Importance.ShouldBe(arg.Importance);
         }
     }
 }
diff --git a/src/Framework/AssemblyLoadBuildEventArgs.cs b/src/Framework/AssemblyLoadBuildEventArgs.cs
index bb9d8e58e6f..4c6c8292cbc 100644
--- a/src/Framework/AssemblyLoadBuildEventArgs.cs
+++ b/src/Framework/AssemblyLoadBuildEventArgs.cs
@@ -24,7 +24,7 @@ public AssemblyLoadBuildEventArgs(
             Guid mvid,
             string? customAppDomainDescriptor,
             MessageImportance importance = MessageImportance.Low)
-            : base(null, null, null, importance, DateTime.UtcNow, assemblyName, assemblyPath, mvid)
+            : base(null, null, null, importance, DateTime.UtcNow, null)
         {
             LoadingContext = loadingContext;
             LoadingInitiator = loadingInitiator;
@@ -44,6 +44,8 @@ public AssemblyLoadBuildEventArgs(
 
         internal override void WriteToStream(BinaryWriter writer)
         {
+            base.WriteToStream(writer);
+
             writer.Write7BitEncodedInt((int)LoadingContext);
             writer.WriteTimestamp(RawTimestamp);
             writer.WriteOptionalBuildEventContext(BuildEventContext);
@@ -56,6 +58,8 @@ internal override void WriteToStream(BinaryWriter writer)
 
         internal override void CreateFromStream(BinaryReader reader, int version)
         {
+            base.CreateFromStream(reader, version);
+
             LoadingContext = (AssemblyLoadingContext)reader.Read7BitEncodedInt();
             RawTimestamp = reader.ReadTimestamp();
             BuildEventContext = reader.ReadOptionalBuildEventContext();
diff --git a/src/Framework/BinaryReaderFactory.cs b/src/Framework/BinaryReaderFactory.cs
new file mode 100644
index 00000000000..5cc76fe84ea
--- /dev/null
+++ b/src/Framework/BinaryReaderFactory.cs
@@ -0,0 +1,14 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.IO;
+
+namespace Microsoft.Build;
+
+/// <summary>
+/// Opaque holder of shared buffer.
+/// </summary>
+internal abstract class BinaryReaderFactory
+{
+    public abstract BinaryReader Create(Stream stream);
+}
diff --git a/src/Shared/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
similarity index 97%
rename from src/Shared/BinaryTranslator.cs
rename to src/Framework/BinaryTranslator.cs
index 055d34bb141..a2eab07d302 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -8,7 +8,7 @@
 using System.IO;
 using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -22,14 +22,16 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal static class BinaryTranslator
     {
+#nullable enable
         /// <summary>
         /// Returns a read-only serializer.
         /// </summary>
         /// <returns>The serializer.</returns>
-        internal static ITranslator GetReadTranslator(Stream stream, SharedReadBuffer buffer)
+        internal static ITranslator GetReadTranslator(Stream stream, BinaryReaderFactory buffer)
         {
             return new BinaryReadTranslator(stream, buffer);
         }
+#nullable disable
 
         /// <summary>
         /// Returns a write-only serializer.
@@ -56,14 +58,16 @@ private class BinaryReadTranslator : ITranslator
             /// </summary>
             private BinaryReader _reader;
 
+#nullable enable
             /// <summary>
             /// Constructs a serializer from the specified stream, operating in the designated mode.
             /// </summary>
-            public BinaryReadTranslator(Stream packetStream, SharedReadBuffer buffer)
+            public BinaryReadTranslator(Stream packetStream, BinaryReaderFactory buffer)
             {
                 _packetStream = packetStream;
-                _reader = InterningBinaryReader.Create(packetStream, buffer);
+                _reader = buffer.Create(packetStream);
             }
+#nullable disable
 
             /// <summary>
             /// Delegates the Dispose call the to the underlying BinaryReader.
@@ -88,7 +92,7 @@ public BinaryWriter Writer
             {
                 get
                 {
-                    ErrorUtilities.ThrowInternalError("Cannot get writer from reader.");
+                    EscapeHatches.ThrowInternalError("Cannot get writer from reader.");
                     return null;
                 }
             }
@@ -477,7 +481,18 @@ public void TranslateDotNet<T>(ref T value)
 
             public void TranslateException(ref Exception value)
             {
-                TranslateDotNet<Exception>(ref value);
+                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+                {
+                    TranslateDotNet<Exception>(ref value);
+                    return;
+                }
+
+                if (!TranslateNullable(value))
+                {
+                    return;
+                }
+
+                value = BuildExceptionBase.ReadExceptionFromTranslator(this);
             }
 
 
@@ -761,7 +776,7 @@ public BinaryReader Reader
             {
                 get
                 {
-                    ErrorUtilities.ThrowInternalError("Cannot get reader from writer.");
+                    EscapeHatches.ThrowInternalError("Cannot get reader from writer.");
                     return null;
                 }
             }
@@ -1100,7 +1115,18 @@ public void TranslateDotNet<T>(ref T value)
 
             public void TranslateException(ref Exception value)
             {
-                TranslateDotNet<Exception>(ref value);
+                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+                {
+                    TranslateDotNet<Exception>(ref value);
+                    return;
+                }
+
+                if (!TranslateNullable(value))
+                {
+                    return;
+                }
+
+                BuildExceptionBase.WriteExceptionToTranslator(this, value);
             }
 
             /// <summary>
diff --git a/src/Framework/BuildException/BuildExceptionBase.cs b/src/Framework/BuildException/BuildExceptionBase.cs
new file mode 100644
index 00000000000..acb93434e0e
--- /dev/null
+++ b/src/Framework/BuildException/BuildExceptionBase.cs
@@ -0,0 +1,154 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework.BuildException;
+
+public abstract class BuildExceptionBase : Exception
+{
+    private string? _remoteTypeName;
+    private string? _remoteStackTrace;
+
+    private protected BuildExceptionBase()
+        : base()
+    { }
+
+    private protected BuildExceptionBase(string message)
+        : base(message)
+    { }
+
+    private protected BuildExceptionBase(
+        string message,
+        Exception? inner)
+        : base(message, inner)
+    { }
+
+    // This is needed to allow opting back in to BinaryFormatter serialization
+    private protected BuildExceptionBase(SerializationInfo info, StreamingContext context)
+        : base(info, context)
+    { }
+
+    public override string? StackTrace => string.IsNullOrEmpty(_remoteStackTrace) ? base.StackTrace : _remoteStackTrace;
+
+    public override string ToString() => string.IsNullOrEmpty(_remoteTypeName) ? base.ToString() : $"{_remoteTypeName}->{base.ToString()}";
+
+    /// <summary>
+    /// Override this method to recover subtype-specific state from the remote exception.
+    /// </summary>
+    protected virtual void InitializeCustomState(IDictionary<string, string?>? customKeyedSerializedData)
+    { }
+
+    /// <summary>
+    /// Override this method to provide subtype-specific state to be serialized.
+    /// </summary>
+    /// <returns></returns>
+    protected virtual IDictionary<string, string?>? FlushCustomState()
+    {
+        return null;
+    }
+
+    private void InitializeFromRemoteState(BuildExceptionRemoteState remoteState)
+    {
+        _remoteTypeName = remoteState.RemoteTypeName;
+        _remoteStackTrace = remoteState.RemoteStackTrace;
+        base.Source = remoteState.Source;
+        base.HelpLink = remoteState.HelpLink;
+        base.HResult = remoteState.HResult;
+        if (remoteState.Source != null)
+        {
+            InitializeCustomState(remoteState.CustomKeyedSerializedData);
+        }
+    }
+
+    internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)
+    {
+        BinaryWriter writer = translator.Writer;
+        writer.Write(exception.InnerException != null);
+        if (exception.InnerException != null)
+        {
+            WriteExceptionToTranslator(translator, exception.InnerException);
+        }
+
+        string serializationType = BuildExceptionSerializationHelper.GetExceptionSerializationKey(exception.GetType());
+        writer.Write(serializationType);
+        writer.Write(exception.Message);
+        writer.WriteOptionalString(exception.StackTrace);
+        writer.WriteOptionalString(exception.Source);
+        writer.WriteOptionalString(exception.HelpLink);
+        // HResult is completely protected up till net4.5
+#if NET || NET45_OR_GREATER
+        int? hresult = exception.HResult;
+#else
+            int? hresult = null;
+#endif
+        writer.WriteOptionalInt32(hresult);
+
+        IDictionary<string, string?>? customKeyedSerializedData = (exception as BuildExceptionBase)?.FlushCustomState();
+        if (customKeyedSerializedData == null)
+        {
+            writer.Write((byte)0);
+        }
+        else
+        {
+            writer.Write((byte)1);
+            writer.Write(customKeyedSerializedData.Count);
+            foreach (var pair in customKeyedSerializedData)
+            {
+                writer.Write(pair.Key);
+                writer.WriteOptionalString(pair.Value);
+            }
+        }
+
+        Debug.Assert((exception.Data?.Count ?? 0) == 0,
+            "Exception Data is not supported in BuildTransferredException");
+    }
+
+    internal static Exception ReadExceptionFromTranslator(ITranslator translator)
+    {
+        BinaryReader reader = translator.Reader;
+        Exception? innerException = null;
+        if (reader.ReadBoolean())
+        {
+            innerException = ReadExceptionFromTranslator(translator);
+        }
+
+        string serializationType = reader.ReadString();
+        string message = reader.ReadString();
+        string? deserializedStackTrace = reader.ReadOptionalString();
+        string? source = reader.ReadOptionalString();
+        string? helpLink = reader.ReadOptionalString();
+        int hResult = reader.ReadOptionalInt32();
+
+        IDictionary<string, string?>? customKeyedSerializedData = null;
+        if (reader.ReadByte() == 1)
+        {
+            int count = reader.ReadInt32();
+            customKeyedSerializedData = new Dictionary<string, string?>(count, StringComparer.CurrentCulture);
+
+            for (int i = 0; i < count; i++)
+            {
+                customKeyedSerializedData[reader.ReadString()] = reader.ReadOptionalString();
+            }
+        }
+
+        BuildExceptionBase exception = BuildExceptionSerializationHelper.CreateExceptionFactory(serializationType)(message, innerException);
+
+        exception.InitializeFromRemoteState(
+            new BuildExceptionRemoteState(
+                serializationType,
+                deserializedStackTrace,
+                source,
+                helpLink,
+                hResult,
+                customKeyedSerializedData));
+
+        return exception;
+    }
+}
diff --git a/src/Framework/BuildException/BuildExceptionRemoteState.cs b/src/Framework/BuildException/BuildExceptionRemoteState.cs
new file mode 100644
index 00000000000..b4d8786f43d
--- /dev/null
+++ b/src/Framework/BuildException/BuildExceptionRemoteState.cs
@@ -0,0 +1,35 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework.BuildException;
+
+/// <summary>
+/// Remote exception internal data serving as the source for the exception deserialization.
+/// </summary>
+internal class BuildExceptionRemoteState
+{
+    public BuildExceptionRemoteState(
+        string remoteTypeName,
+        string? remoteStackTrace,
+        string? source,
+        string? helpLink,
+        int hResult,
+        IDictionary<string, string?>? customKeyedSerializedData)
+    {
+        RemoteTypeName = remoteTypeName;
+        RemoteStackTrace = remoteStackTrace;
+        Source = source;
+        HelpLink = helpLink;
+        HResult = hResult;
+        CustomKeyedSerializedData = customKeyedSerializedData;
+    }
+
+    public string RemoteTypeName { get; init; }
+    public string? RemoteStackTrace { get; init; }
+    public string? Source { get; init; }
+    public string? HelpLink { get; init; }
+    public int HResult { get; init; }
+    public IDictionary<string, string?>? CustomKeyedSerializedData { get; init; }
+}
diff --git a/src/Framework/BuildException/BuildExceptionSerializationHelper.cs b/src/Framework/BuildException/BuildExceptionSerializationHelper.cs
new file mode 100644
index 00000000000..030fd532e00
--- /dev/null
+++ b/src/Framework/BuildException/BuildExceptionSerializationHelper.cs
@@ -0,0 +1,91 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Threading;
+
+namespace Microsoft.Build.Framework.BuildException
+{
+    internal static class BuildExceptionSerializationHelper
+    {
+        public class TypeConstructionTuple
+        {
+            public TypeConstructionTuple(Type type, Func<string, Exception?, BuildExceptionBase> factory)
+            {
+                Type = type;
+                Factory = factory;
+            }
+
+            public Type Type { get; }
+            public Func<string, Exception?, BuildExceptionBase> Factory { get; }
+        }
+
+        private static Dictionary<string, Func<string, Exception?, BuildExceptionBase>>? s_exceptionFactories;
+
+        private static readonly Func<string, Exception?, BuildExceptionBase> s_defaultFactory =
+            (message, innerException) => new GenericBuildTransferredException(message, innerException);
+
+        internal static bool IsSupportedExceptionType(Type type)
+        {
+            return type.IsClass &&
+                   !type.IsAbstract &&
+                   type.IsSubclassOf(typeof(Exception)) &&
+                   type.IsSubclassOf(typeof(BuildExceptionBase));
+        }
+
+        internal static void InitializeSerializationContract(params TypeConstructionTuple[] exceptionsAllowlist)
+        {
+            InitializeSerializationContract((IEnumerable<TypeConstructionTuple>)exceptionsAllowlist);
+        }
+
+        internal static void InitializeSerializationContract(IEnumerable<TypeConstructionTuple> exceptionsAllowlist)
+        {
+            if (s_exceptionFactories != null)
+            {
+                return;
+            }
+
+            var exceptionFactories = new Dictionary<string, Func<string, Exception?, BuildExceptionBase>>();
+
+            foreach (TypeConstructionTuple typeConstructionTuple in exceptionsAllowlist)
+            {
+                Type exceptionType = typeConstructionTuple.Type;
+                Func<string, Exception?, BuildExceptionBase> exceptionFactory = typeConstructionTuple.Factory;
+
+                if (!IsSupportedExceptionType(exceptionType))
+                {
+                    EscapeHatches.ThrowInternalError($"Type {exceptionType.FullName} is not recognized as a build exception type.");
+                }
+
+                string key = GetExceptionSerializationKey(exceptionType);
+                exceptionFactories[key] = exceptionFactory;
+            }
+
+            if (Interlocked.Exchange(ref s_exceptionFactories, exceptionFactories) != null)
+            {
+                EscapeHatches.ThrowInternalError("Serialization contract was already initialized.");
+            }
+        }
+
+        internal static string GetExceptionSerializationKey(Type exceptionType)
+        {
+            return exceptionType.FullName ?? exceptionType.ToString();
+        }
+
+        internal static Func<string, Exception?, BuildExceptionBase> CreateExceptionFactory(string serializationType)
+        {
+            Func<string, Exception?, BuildExceptionBase>? factory = null;
+            if (s_exceptionFactories == null)
+            {
+                EscapeHatches.ThrowInternalError("Serialization contract was not initialized.");
+            }
+            else
+            {
+                s_exceptionFactories.TryGetValue(serializationType, out factory);
+            }
+
+            return factory ?? s_defaultFactory;
+        }
+    }
+}
diff --git a/src/Framework/BuildException/GenericBuildTransferredException.cs b/src/Framework/BuildException/GenericBuildTransferredException.cs
new file mode 100644
index 00000000000..0c0261c80d5
--- /dev/null
+++ b/src/Framework/BuildException/GenericBuildTransferredException.cs
@@ -0,0 +1,22 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Framework.BuildException;
+
+/// <summary>
+/// A catch-all type for remote exceptions that we don't know how to deserialize.
+/// </summary>
+internal sealed class GenericBuildTransferredException : BuildExceptionBase
+{
+    public GenericBuildTransferredException()
+        : base()
+    { }
+
+    internal GenericBuildTransferredException(
+        string message,
+        Exception? inner)
+        : base(message, inner)
+    { }
+}
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index a2a62100d7d..00507237987 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -125,7 +125,7 @@ internal static void ApplyChangeWave()
                 ConversionState = ChangeWaveConversionState.Valid;
                 _cachedWave = ChangeWaves.EnableAllFeatures;
             }
-            else if (!Version.TryParse(msbuildDisableFeaturesFromVersion, out _cachedWave))
+            else if (!TryParseVersion(msbuildDisableFeaturesFromVersion, out _cachedWave))
             {
                 ConversionState = ChangeWaveConversionState.InvalidFormat;
                 _cachedWave = ChangeWaves.EnableAllFeatures;
@@ -173,5 +173,23 @@ internal static void ResetStateForTests()
             _cachedWave = null;
             _state = ChangeWaveConversionState.NotConvertedYet;
         }
+
+        private static bool TryParseVersion(string stringVersion, out Version version)
+        {
+#if FEATURE_NET35_TASKHOST
+            try
+            {
+                version = new Version(stringVersion);
+                return true;
+            }
+            catch (Exception)
+            {
+                version = null;
+                return false;
+            }
+#else
+            return Version.TryParse(stringVersion, out version);
+#endif
+        }
     }
 }
diff --git a/src/Shared/ITranslatable.cs b/src/Framework/ITranslatable.cs
similarity index 100%
rename from src/Shared/ITranslatable.cs
rename to src/Framework/ITranslatable.cs
diff --git a/src/Shared/ITranslator.cs b/src/Framework/ITranslator.cs
similarity index 100%
rename from src/Shared/ITranslator.cs
rename to src/Framework/ITranslator.cs
diff --git a/src/Framework/InternalErrorException.cs b/src/Framework/InternalErrorException.cs
index 86383e09bbb..4aef7c049ea 100644
--- a/src/Framework/InternalErrorException.cs
+++ b/src/Framework/InternalErrorException.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Diagnostics;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 
 #nullable disable
 
@@ -15,7 +16,7 @@ namespace Microsoft.Build.Framework
     /// did wrong.
     /// </summary>
     [Serializable]
-    internal sealed class InternalErrorException : Exception
+    internal sealed class InternalErrorException : BuildExceptionBase
     {
         /// <summary>
         /// Default constructor.
@@ -45,9 +46,27 @@ internal InternalErrorException(
         internal InternalErrorException(
             String message,
             Exception innerException) :
-            base("MSB0001: Internal MSBuild Error: " + message + (innerException == null ? String.Empty : ("\n=============\n" + innerException.ToString() + "\n\n")), innerException)
+            this(message, innerException, false)
+        { }
+
+        internal static InternalErrorException CreateFromRemote(string message, Exception innerException)
+        {
+            return new InternalErrorException(message, innerException, true /* calledFromDeserialization */);
+        }
+
+        private InternalErrorException(string message, Exception innerException, bool calledFromDeserialization)
+            : base(
+                calledFromDeserialization
+                    ? message
+                    : "MSB0001: Internal MSBuild Error: " + message + (innerException == null
+                        ? String.Empty
+                        : ("\n=============\n" + innerException.ToString() + "\n\n")),
+                innerException)
         {
-            ConsiderDebuggerLaunch(message, innerException);
+            if (!calledFromDeserialization)
+            {
+                ConsiderDebuggerLaunch(message, innerException);
+            }
         }
 
         #region Serialization (update when adding new class members)
diff --git a/src/Framework/LoggerException.cs b/src/Framework/LoggerException.cs
index ba423ceba87..a671142368a 100644
--- a/src/Framework/LoggerException.cs
+++ b/src/Framework/LoggerException.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions; // for SecurityPermissionAttribute
 #endif
@@ -20,7 +22,7 @@ namespace Microsoft.Build.Framework
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
-    public class LoggerException : Exception
+    public class LoggerException : BuildExceptionBase
     {
         /// <summary>
         /// Default constructor.
@@ -104,6 +106,21 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("helpKeyword", helpKeyword);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(errorCode), errorCode },
+                { nameof(helpKeyword), helpKeyword },
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            errorCode = state[nameof(errorCode)];
+            helpKeyword = state[nameof(helpKeyword)];
+        }
+
         #endregion
 
         #region Properties
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 7a4db37105c..871d648e4ea 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Globalization;
 
 #nullable disable
 
@@ -474,7 +475,7 @@ public enum SdkReferencePropertyExpansionMode
         /// then we can give them this undocumented environment variable as an immediate workaround.
         /// </summary>
         /// <remarks>
-        /// Clone from ErrorUtilities which isn't (yet?) available in Framework.
+        /// Clone from ErrorUtilities which isn't available in Framework.
         /// </remarks>
         private static readonly bool s_throwExceptions = String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDONOTTHROWINTERNAL"));
 
@@ -482,7 +483,7 @@ public enum SdkReferencePropertyExpansionMode
         /// Throws InternalErrorException.
         /// </summary>
         /// <remarks>
-        /// Clone of ErrorUtilities.ThrowInternalError which isn't (yet?) available in Framework.
+        /// Clone of ErrorUtilities.ThrowInternalError which isn't available in Framework.
         /// </remarks>
         internal static void ThrowInternalError(string message)
         {
@@ -491,5 +492,66 @@ internal static void ThrowInternalError(string message)
                 throw new InternalErrorException(message);
             }
         }
+
+        /// <summary>
+        /// Throws InternalErrorException.
+        /// This is only for situations that would mean that there is a bug in MSBuild itself.
+        /// </summary>
+        /// <remarks>
+        /// Clone from ErrorUtilities which isn't available in Framework.
+        /// </remarks>
+        internal static void ThrowInternalError(string message, params object[] args)
+        {
+            if (s_throwExceptions)
+            {
+                throw new InternalErrorException(FormatString(message, args));
+            }
+        }
+
+        /// <summary>
+        /// Formats the given string using the variable arguments passed in.
+        /// 
+        /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
+        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
+        /// 
+        /// Thread safe.
+        /// </summary>
+        /// <param name="unformatted">The string to format.</param>
+        /// <param name="args">Optional arguments for formatting the given string.</param>
+        /// <returns>The formatted string.</returns>
+        /// <remarks>
+        /// Clone from ResourceUtilities which isn't available in Framework.
+        /// </remarks>
+        internal static string FormatString(string unformatted, params object[] args)
+        {
+            string formatted = unformatted;
+
+            // NOTE: String.Format() does not allow a null arguments array
+            if ((args?.Length > 0))
+            {
+#if DEBUG
+                // If you accidentally pass some random type in that can't be converted to a string, 
+                // FormatResourceString calls ToString() which returns the full name of the type!
+                foreach (object param in args)
+                {
+                    // Check it has a real implementation of ToString() and the type is not actually System.String
+                    if (param != null)
+                    {
+                        if (string.Equals(param.GetType().ToString(), param.ToString(), StringComparison.Ordinal) &&
+                            param.GetType() != typeof(string))
+                        {
+                            ThrowInternalError("Invalid resource parameter type, was {0}",
+                                param.GetType().FullName);
+                        }
+                    }
+                }
+#endif
+                // Format the string, using the variable arguments passed in.
+                // NOTE: all String methods are thread-safe
+                formatted = String.Format(CultureInfo.CurrentCulture, unformatted, args);
+            }
+
+            return formatted;
+        }
     }
 }
diff --git a/src/MSBuild.UnitTests/LiveLogger_Tests.cs b/src/MSBuild.UnitTests/LiveLogger_Tests.cs
index fc1463ff095..1a359d69aad 100644
--- a/src/MSBuild.UnitTests/LiveLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/LiveLogger_Tests.cs
@@ -38,7 +38,7 @@ public class LiveLogger_Tests : IEventSource, IDisposable
 
         private VerifySettings _settings = new();
 
-        private static Regex s_elapsedTime = new($@"\(\d+{Regex.Escape(CultureInfo.CurrentUICulture.NumberFormat.NumberDecimalSeparator)}\ds\)", RegexOptions.Compiled);
+        private static Regex s_elapsedTime = new($@"\d+{Regex.Escape(CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator)}\ds", RegexOptions.Compiled);
 
         public LiveLogger_Tests()
         {
@@ -56,7 +56,7 @@ public LiveLogger_Tests()
             {
                 string line = lineBuilder.ToString();
                 lineBuilder.Clear();
-                lineBuilder.Append(s_elapsedTime.Replace(line, "(0.0s)"));
+                lineBuilder.Append(s_elapsedTime.Replace(line, "0.0s"));
             });
         }
 
@@ -245,5 +245,45 @@ public Task PrintBuildSummary_FailedWithErrors()
         }
 
         #endregion
+
+        [Fact]
+        public void DisplayNodesShowsCurrent()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, async () =>
+            {
+                _liveLogger.DisplayNodes();
+
+                await Verify(_outputWriter.ToString(), _settings);
+            });
+        }
+
+        [Fact]
+        public async Task DisplayNodesOverwritesWithNewTargetFramework()
+        {
+            BuildStarted?.Invoke(_eventSender, MakeBuildStartedEventArgs());
+
+            ProjectStartedEventArgs pse = MakeProjectStartedEventArgs(_projectFile, "Build");
+            pse.GlobalProperties = new Dictionary<string, string>() { ["TargetFramework"] = "tfName" };
+
+            ProjectStarted?.Invoke(_eventSender, pse);
+
+            TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
+            TaskStarted?.Invoke(_eventSender, MakeTaskStartedEventArgs(_projectFile, "Task"));
+
+            _liveLogger.DisplayNodes();
+
+            // This is a bit fast and loose with the events that would be fired
+            // in a real "stop building that TF for the project and start building
+            // a new TF of the same project" situation, but it's enough now.
+            ProjectStartedEventArgs pse2 = MakeProjectStartedEventArgs(_projectFile, "Build");
+            pse2.GlobalProperties = new Dictionary<string, string>() { ["TargetFramework"] = "tf2" };
+
+            ProjectStarted?.Invoke(_eventSender, pse2);
+            TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
+
+            _liveLogger.DisplayNodes();
+
+            await Verify(_outputWriter.ToString(), _settings);
+        }
     }
 }
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.verified.txt b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.verified.txt
new file mode 100644
index 00000000000..5420c4eab35
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.verified.txt
@@ -0,0 +1,5 @@
+﻿]9;4;3;\[?25l[1F
+  project [36;1mtfName[m Build (0.0s)
+[?25h[?25l[2F
+  project [36;1mtf2[m Build (0.0s)[K
+[?25h
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesShowsCurrent.verified.txt b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesShowsCurrent.verified.txt
new file mode 100644
index 00000000000..0fb8b744327
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.DisplayNodesShowsCurrent.verified.txt
@@ -0,0 +1,3 @@
+﻿]9;4;3;\[?25l[1F
+  project Build (0.0s)
+[?25h
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_Failed.verified.txt b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_Failed.verified.txt
index c36142ab71a..a761905358e 100644
--- a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_Failed.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_Failed.verified.txt
@@ -1,3 +1,4 @@
-﻿[?25l[1F
+﻿]9;4;3;\[?25l[1F
 [?25h
-Build [31;1mfailed[m in 5.0s
+Build [31;1mfailed[m in 0.0s
+]9;4;0;\
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_FailedWithErrors.verified.txt b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_FailedWithErrors.verified.txt
index dd05d6b61ec..3657a549d75 100644
--- a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_FailedWithErrors.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_FailedWithErrors.verified.txt
@@ -1,5 +1,6 @@
-﻿  project [31;1mfailed with errors[m (0.0s)
+﻿]9;4;3;\  project [31;1mfailed with errors[m (0.0s)
 [31;1m    ❌︎[7D[6C MSBUILD : error : Error![m
 [?25l[1F
 [?25h
-Build [31;1mfailed with errors[m in 5.0s
+Build [31;1mfailed with errors[m in 0.0s
+]9;4;0;\
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_SucceededWithWarnings.verified.txt b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_SucceededWithWarnings.verified.txt
index 6049dc616db..405fa3a221f 100644
--- a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_SucceededWithWarnings.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintBuildSummary_SucceededWithWarnings.verified.txt
@@ -1,5 +1,6 @@
-﻿  project [33;1msucceeded with warnings[m (0.0s)
+﻿]9;4;3;\  project [33;1msucceeded with warnings[m (0.0s)
 [33;1m    ⚠︎[7D[6C MSBUILD : warning : Warning![m
 [?25l[1F
 [?25h
-Build [33;1msucceeded with warnings[m in 5.0s
+Build [33;1msucceeded with warnings[m in 0.0s
+]9;4;0;\
diff --git a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintsBuildSummary_Succeeded.verified.txt b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintsBuildSummary_Succeeded.verified.txt
index 4d414bf90bf..f62b3f5ddba 100644
--- a/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintsBuildSummary_Succeeded.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/LiveLogger_Tests.PrintsBuildSummary_Succeeded.verified.txt
@@ -1,3 +1,4 @@
-﻿[?25l[1F
+﻿]9;4;3;\[?25l[1F
 [?25h
-Build [32;1msucceeded[m in 5.0s
+Build [32;1msucceeded[m in 0.0s
+]9;4;0;\
diff --git a/src/MSBuild/LiveLogger/AnsiCodes.cs b/src/MSBuild/LiveLogger/AnsiCodes.cs
index 7cdb5eb8454..2984f957dc4 100644
--- a/src/MSBuild/LiveLogger/AnsiCodes.cs
+++ b/src/MSBuild/LiveLogger/AnsiCodes.cs
@@ -94,6 +94,16 @@ internal static class AnsiCodes
     /// </summary>
     public const string ShowCursor = "\x1b[?25h";
 
+    /// <summary>
+    /// Set progress state to a busy spinner.
+    /// </summary>
+    public const string SetProgressIndeterminate = "\x1b]9;4;3;\x1b\\";
+
+    /// <summary>
+    /// Remove progress state, restoring taskbar status to normal.
+    /// </summary>
+    public const string RemoveProgress = "\x1b]9;4;0;\x1b\\";
+
     public static string Colorize(string? s, TerminalColor color)
     {
         if (string.IsNullOrWhiteSpace(s))
diff --git a/src/MSBuild/LiveLogger/LiveLogger.cs b/src/MSBuild/LiveLogger/LiveLogger.cs
index fff21dacc5f..ccfc71e3825 100644
--- a/src/MSBuild/LiveLogger/LiveLogger.cs
+++ b/src/MSBuild/LiveLogger/LiveLogger.cs
@@ -234,6 +234,8 @@ private void BuildStarted(object sender, BuildStartedEventArgs e)
         }
 
         _buildStartTime = e.Timestamp;
+
+        Terminal.Write(AnsiCodes.SetProgressIndeterminate);
     }
 
     /// <summary>
@@ -268,6 +270,7 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)
         }
         finally
         {
+            Terminal.Write(AnsiCodes.RemoveProgress);
             Terminal.EndUpdate();
         }
 
@@ -611,7 +614,7 @@ private void ThreadProc()
     /// Render Nodes section.
     /// It shows what all build nodes do.
     /// </summary>
-    private void DisplayNodes()
+    internal void DisplayNodes()
     {
         NodesFrame newFrame = new NodesFrame(_nodes, width: Terminal.Width, height: Terminal.Height);
 
@@ -740,21 +743,22 @@ public string Render(NodesFrame previousFrame)
                     if (!previous.SequenceEqual(needed))
                     {
                         int commonPrefixLen = previous.CommonPrefixLength(needed);
-                        if (commonPrefixLen == 0)
+
+                        if (commonPrefixLen != 0 && needed.Slice(0, commonPrefixLen).IndexOf('\x1b') == -1)
                         {
-                            // whole string
-                            sb.Append(needed);
+                            // no escape codes, so can trivially skip substrings
+                            sb.Append($"{AnsiCodes.CSI}{commonPrefixLen}{AnsiCodes.MoveForward}");
+                            sb.Append(needed.Slice(commonPrefixLen));
                         }
                         else
                         {
-                            // set cursor to different char
-                            sb.Append($"{AnsiCodes.CSI}{commonPrefixLen}{AnsiCodes.MoveForward}");
-                            sb.Append(needed.Slice(commonPrefixLen));
-                            // Shall we clear rest of line
-                            if (needed.Length < previous.Length)
-                            {
-                                sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInLine}");
-                            }
+                            sb.Append(needed);
+                        }
+
+                        // Shall we clear rest of line
+                        if (needed.Length < previous.Length)
+                        {
+                            sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInLine}");
                         }
                     }
                 }
diff --git a/src/MSBuild/LiveLogger/Terminal.cs b/src/MSBuild/LiveLogger/Terminal.cs
index f8cdb60bf10..1d78fcce6d6 100644
--- a/src/MSBuild/LiveLogger/Terminal.cs
+++ b/src/MSBuild/LiveLogger/Terminal.cs
@@ -107,7 +107,7 @@ public void Write(string text)
         }
         else
         {
-            Console.Write(text);
+            Output.Write(text);
         }
     }
 
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index dfff888c132..219437cdacf 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -127,10 +127,7 @@
     <Compile Include="..\Shared\INodePacketFactory.cs" />
     <Compile Include="..\Shared\NodePacketFactory.cs" />
     <Compile Include="..\Shared\INodePacketHandler.cs" />
-    <Compile Include="..\Shared\ITranslatable.cs" />
-    <Compile Include="..\Shared\ITranslator.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
-    <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\CommunicationsUtilities.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
     <Compile Include="..\Shared\TaskHostConfiguration.cs" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 0628e295bd9..c2e0bb5b8c1 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -70,9 +70,12 @@
     </Compile>
     <Compile Include="..\Shared\Constants.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
-    <Compile Include="..\Shared\ErrorUtilities.cs">
+    <Compile Include="..\Framework\ErrorUtilities.cs">
       <Link>ErrorUtilities.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\ErrorUtilities.cs">
+      <Link>SharedErrorUtilities.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\EscapingUtilities.cs">
       <Link>EscapingUtilities.cs</Link>
     </Compile>
@@ -97,10 +100,10 @@
     <Compile Include="..\Shared\INodePacketHandler.cs">
       <Link>INodePacketHandler.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\ITranslatable.cs">
+    <Compile Include="..\Framework\ITranslatable.cs">
       <Link>ITranslatable.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\ITranslator.cs">
+    <Compile Include="..\Framework\ITranslator.cs">
       <Link>ITranslator.cs</Link>
     </Compile>
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
@@ -110,6 +113,15 @@
     <Compile Include="..\Shared\InterningBinaryReader.cs">
       <Link>InterningBinaryReader.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\BinaryReaderFactory.cs">
+      <Link>BinaryReaderFactory.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\BinaryReaderExtensions.cs">
+      <Link>BinaryReaderExtensions.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\BinaryWriterExtensions.cs">
+      <Link>BinaryWriterExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\LogMessagePacketBase.cs">
       <Link>LogMessagePacketBase.cs</Link>
     </Compile>
@@ -132,9 +144,21 @@
     <Compile Include="..\Shared\NodePacketFactory.cs">
       <Link>NodePacketFactory.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\BinaryTranslator.cs">
+    <Compile Include="..\Framework\BinaryTranslator.cs">
       <Link>BinaryTranslator.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\BuildException\BuildExceptionBase.cs">
+      <Link>BuildExceptionBase.cs</Link>
+    </Compile>
+    <Compile Include="..\Framework\BuildException\BuildExceptionRemoteState.cs">
+      <Link>BuildExceptionRemoteState.cs</Link>
+    </Compile>
+    <Compile Include="..\Framework\BuildException\BuildExceptionSerializationHelper.cs">
+      <Link>BuildExceptionSerializationHelper.cs</Link>
+    </Compile>
+    <Compile Include="..\Framework\BuildException\GenericBuildTransferredException.cs">
+      <Link>GenericBuildTransferredException.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\NodeShutdown.cs">
       <Link>NodeShutdown.cs</Link>
     </Compile>
@@ -167,6 +191,9 @@
     </Compile>
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="AssemblyResources.cs" />
+    <Compile Include="..\Framework\ChangeWaves.cs">
+      <Link>ChangeWaves.cs</Link>
+    </Compile>
     <Compile Include="Concurrent\ConcurrentDictionary.cs" />
     <Compile Include="Concurrent\ConcurrentQueue.cs" />
     <Compile Include="Immutable\ImmutableDictionary.cs" />
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index cb3857ff100..316a1180878 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -10,13 +10,25 @@ namespace Microsoft.Build.Shared
 {
     internal static class BinaryReaderExtensions
     {
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static string? ReadOptionalString(this BinaryReader reader)
         {
             return reader.ReadByte() == 0 ? null : reader.ReadString();
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
+        public static int ReadOptionalInt32(this BinaryReader reader)
+        {
+            return reader.ReadByte() == 0 ? 0 : reader.ReadInt32();
+        }
+
+#if !TASKHOST
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static int Read7BitEncodedInt(this BinaryReader reader)
         {
             // Read out an Int32 7 bits at a time.  The high bit
@@ -41,7 +53,9 @@ public static int Read7BitEncodedInt(this BinaryReader reader)
             return count;
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static DateTime ReadTimestamp(this BinaryReader reader)
         {
             long timestampTicks = reader.ReadInt64();
@@ -50,6 +64,7 @@ public static DateTime ReadTimestamp(this BinaryReader reader)
             return timestamp;
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
         public static BuildEventContext? ReadOptionalBuildEventContext(this BinaryReader reader)
         {
@@ -75,8 +90,11 @@ public static BuildEventContext ReadBuildEventContext(this BinaryReader reader)
             var buildEventContext = new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, targetId, taskId);
             return buildEventContext;
         }
+#endif
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static unsafe Guid ReadGuid(this BinaryReader reader)
         {
             return new Guid(reader.ReadBytes(sizeof(Guid)));
diff --git a/src/Shared/BinaryWriterExtensions.cs b/src/Shared/BinaryWriterExtensions.cs
index 2a221d573a5..211e91f3edc 100644
--- a/src/Shared/BinaryWriterExtensions.cs
+++ b/src/Shared/BinaryWriterExtensions.cs
@@ -10,7 +10,9 @@ namespace Microsoft.Build.Shared
 {
     internal static class BinaryWriterExtensions
     {
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static void WriteOptionalString(this BinaryWriter writer, string? value)
         {
             if (value == null)
@@ -24,14 +26,34 @@ public static void WriteOptionalString(this BinaryWriter writer, string? value)
             }
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
+        public static void WriteOptionalInt32(this BinaryWriter writer, int? value)
+        {
+            if (value == null)
+            {
+                writer.Write((byte)0);
+            }
+            else
+            {
+                writer.Write((byte)1);
+                writer.Write(value.Value);
+            }
+        }
+
+#if !TASKHOST
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static void WriteTimestamp(this BinaryWriter writer, DateTime timestamp)
         {
             writer.Write(timestamp.Ticks);
             writer.Write((Int32)timestamp.Kind);
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static void Write7BitEncodedInt(this BinaryWriter writer, int value)
         {
             // Write out an int 7 bits at a time.  The high bit of the byte,
@@ -46,6 +68,7 @@ public static void Write7BitEncodedInt(this BinaryWriter writer, int value)
             writer.Write((byte)v);
         }
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
         public static void WriteOptionalBuildEventContext(this BinaryWriter writer, BuildEventContext? context)
         {
@@ -71,8 +94,11 @@ public static void WriteBuildEventContext(this BinaryWriter writer, BuildEventCo
             writer.Write(context.ProjectInstanceId);
             writer.Write(context.EvaluationId);
         }
+#endif
 
+#if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
+#endif
         public static void WriteGuid(this BinaryWriter writer, Guid value)
         {
             Guid val = value;
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 1fc332a0639..8513d60cee5 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -191,11 +191,19 @@ public override String ReadString()
         /// <remarks>
         /// The caller is responsible for managing the lifetime of the returned buffer and for passing it to <see cref="Create"/>.
         /// </remarks>
-        internal static SharedReadBuffer CreateSharedBuffer()
+        internal static BinaryReaderFactory CreateSharedBuffer()
         {
             return new Buffer();
         }
 
+        /// <summary>
+        /// A placeholder instructing InterningBinaryReader to use pooled buffer (to avoid extra allocations).
+        /// </summary>
+        /// <remarks>
+        /// Lifetime of the pooled buffer is managed by InterningBinaryReader (tied to BinaryReader lifetime wrapping the buffer)
+        /// </remarks> 
+        internal static BinaryReaderFactory PoolingBuffer => NullBuffer.Instance;
+
         /// <summary>
         /// Gets a buffer from the pool or creates a new one.
         /// </summary>
@@ -232,7 +240,7 @@ protected override void Dispose(bool disposing)
         /// Create a BinaryReader. It will either be an interning reader or standard binary reader
         /// depending on whether the interning reader is possible given the buffer and stream.
         /// </summary>
-        internal static BinaryReader Create(Stream stream, SharedReadBuffer sharedBuffer)
+        private static BinaryReader Create(Stream stream, BinaryReaderFactory sharedBuffer)
         {
             Buffer buffer = (Buffer)sharedBuffer;
             if (buffer != null)
@@ -245,7 +253,7 @@ internal static BinaryReader Create(Stream stream, SharedReadBuffer sharedBuffer
         /// <summary>
         /// Holds thepreallocated buffer. 
         /// </summary>
-        private class Buffer : SharedReadBuffer
+        private class Buffer : BinaryReaderFactory
         {
             private char[] _charBuffer;
             private byte[] _byteBuffer;
@@ -280,13 +288,24 @@ internal byte[] ByteBuffer
                     return _byteBuffer;
                 }
             }
+
+            public override BinaryReader Create(Stream stream)
+            {
+                return InterningBinaryReader.Create(stream, this);
+            }
         }
-    }
 
-    /// <summary>
-    /// Opaque holder of shared buffer.
-    /// </summary>
-    internal abstract class SharedReadBuffer
-    {
+        private class NullBuffer : BinaryReaderFactory
+        {
+            private NullBuffer()
+            { }
+
+            public static readonly BinaryReaderFactory Instance = new NullBuffer();
+
+            public override BinaryReader Create(Stream stream)
+            {
+                return InterningBinaryReader.Create(stream, null);
+            }
+        }
     }
 }
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index ac7f5509236..f9abb54236e 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -101,7 +101,7 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// <summary>
         /// Per-node shared read buffer.
         /// </summary>
-        private SharedReadBuffer _sharedReadBuffer;
+        private BinaryReaderFactory _sharedReadBuffer;
 
         /// <summary>
         /// A way to cache a byte array when writing out packets
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index 12ef8396ae8..8aa828b533c 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -758,7 +758,7 @@ public void VerifyAssemblyNameExSerializationByTranslator(string assemblyName)
             writeTranslator.Translate(ref assemblyNameOriginal, (ITranslator t) => new AssemblyNameExtension(t));
 
             serializationStream.Seek(0, SeekOrigin.Begin);
-            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, null);
+            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, InterningBinaryReader.PoolingBuffer);
 
             readTranslator.Translate(ref assemblyNameDeserialized, (ITranslator t) => new AssemblyNameExtension(t));
 
@@ -782,7 +782,7 @@ public void VerifyAssemblyNameExSerializationWithRemappedFromByTranslator()
             writeTranslator.Translate(ref assemblyNameOriginal, (ITranslator t) => new AssemblyNameExtension(t));
 
             serializationStream.Seek(0, SeekOrigin.Begin);
-            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, null);
+            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, InterningBinaryReader.PoolingBuffer);
 
             readTranslator.Translate(ref assemblyNameDeserialized, (ITranslator t) => new AssemblyNameExtension(t));
 
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 5d7d3d22d65..ad715d6c44b 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -9,6 +9,7 @@
 using System.IO.Compression;
 using System.Linq;
 using System.Text.RegularExpressions;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
@@ -95,6 +96,7 @@ private void Cleanup()
                 }
 
                 SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", "");
+                ChangeWaves.ResetStateForTests();
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
             }
         }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
index 08e201918af..5607a413d21 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
@@ -20,6 +20,8 @@ public class ResolveAssemblyReferenceCacheSerialization : IDisposable
         private readonly string _rarCacheFile;
         private readonly TaskLoggingHelper _taskLoggingHelper;
 
+        private static readonly DateTime s_now = DateTime.Now;
+
         public ResolveAssemblyReferenceCacheSerialization()
         {
             var tempPath = Path.GetTempPath();
@@ -38,12 +40,20 @@ public void Dispose()
             }
         }
 
+        private static DateTime GetLastWriteTime(string path) => path switch
+        {
+            "path1" => s_now,
+            "path2" => s_now,
+            "dllName" => s_now.AddSeconds(-10),
+            _ => throw new ArgumentException(),
+        };
+
         [Fact]
         public void RoundTripEmptyState()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper, serializeEmptyState: true);
 
             var deserialized = StateFileBase.DeserializeCache<SystemState>(_rarCacheFile, _taskLoggingHelper);
 
@@ -55,7 +65,7 @@ public void CorrectFileVersion()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper, serializeEmptyState: true);
             using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
             {
                 cacheStream.Seek(0, SeekOrigin.Begin);
@@ -73,7 +83,7 @@ public void WrongFileVersion()
         {
             SystemState systemState = new();
 
-            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper);
+            systemState.SerializeCache(_rarCacheFile, _taskLoggingHelper, serializeEmptyState: true);
             using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
             {
                 cacheStream.Seek(0, SeekOrigin.Begin);
@@ -90,15 +100,24 @@ public void WrongFileVersion()
         public void ValidateSerializationAndDeserialization()
         {
             Dictionary<string, SystemState.FileState> cache = new() {
-                    { "path1", new SystemState.FileState(DateTime.Now) },
-                    { "path2", new SystemState.FileState(DateTime.Now) { Assembly = new AssemblyNameExtension("hi") } },
-                    { "dllName", new SystemState.FileState(DateTime.Now.AddSeconds(-10)) {
+                    { "path1", new SystemState.FileState(GetLastWriteTime("path1")) },
+                    { "path2", new SystemState.FileState(GetLastWriteTime("path2")) { Assembly = new AssemblyNameExtension("hi") } },
+                    { "dllName", new SystemState.FileState(GetLastWriteTime("dllName")) {
                         Assembly = null,
                         RuntimeVersion = "v4.0.30319",
                         FrameworkNameAttribute = new FrameworkName(".NETFramework", Version.Parse("4.7.2"), "Profile"),
                         scatterFiles = new string[] { "first", "second" } } } };
             SystemState sysState = new();
+            sysState.SetGetLastWriteTime(GetLastWriteTime);
             sysState.instanceLocalFileStateCache = cache;
+
+            // Get all FileState entries to make sure they are marked as having been used.
+            _ = sysState.GetFileState("path1");
+            _ = sysState.GetFileState("path2");
+            _ = sysState.GetFileState("dllName");
+
+            sysState.HasStateToSave.ShouldBe(true);
+
             SystemState sysState2 = null;
             using (TestEnvironment env = TestEnvironment.Create())
             {
@@ -119,5 +138,58 @@ public void ValidateSerializationAndDeserialization()
             dll2.scatterFiles.Length.ShouldBe(dll.scatterFiles.Length);
             dll2.scatterFiles[1].ShouldBe(dll.scatterFiles[1]);
         }
+
+        [Fact]
+        public void OutgoingCacheIsSmallerThanIncomingCache()
+        {
+            Dictionary<string, SystemState.FileState> cache = new() {
+                    { "path1", new SystemState.FileState(GetLastWriteTime("path1")) },
+                    { "path2", new SystemState.FileState(GetLastWriteTime("path2")) } };
+            SystemState sysState = new();
+            sysState.SetGetLastWriteTime(GetLastWriteTime);
+            sysState.instanceLocalFileStateCache = cache;
+
+            // Get only the first FileState entry.
+            _ = sysState.GetFileState("path1");
+
+            sysState.HasStateToSave.ShouldBe(true);
+
+            SystemState sysState2 = null;
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile file = env.CreateFile();
+                sysState.SerializeCache(file.Path, null);
+                sysState2 = StateFileBase.DeserializeCache<SystemState>(file.Path, null);
+            }
+
+            // The new cache has only the entry that was actually used.
+            Dictionary<string, SystemState.FileState> cache2 = sysState2.instanceLocalFileStateCache;
+            cache2.Count.ShouldBe(1);
+            cache2.ShouldContainKey("path1");
+        }
+
+        [Fact]
+        public void OutgoingCacheIsEmpty()
+        {
+            Dictionary<string, SystemState.FileState> cache = new() {
+                    { "path1", new SystemState.FileState(GetLastWriteTime("path1")) },
+                    { "path2", new SystemState.FileState(GetLastWriteTime("path2")) } };
+            SystemState sysState = new();
+            sysState.SetGetLastWriteTime(GetLastWriteTime);
+            sysState.instanceLocalFileStateCache = cache;
+
+            sysState.HasStateToSave.ShouldBe(false);
+
+            SystemState sysState2 = null;
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile file = env.CreateFile();
+                sysState.SerializeCache(file.Path, null);
+                sysState2 = StateFileBase.DeserializeCache<SystemState>(file.Path, null);
+            }
+
+            // The new cache was not written to disk at all because none of the entries were actually used.
+            sysState2.ShouldBeNull();
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 748cce32307..6b025c4256d 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -2911,7 +2911,7 @@ private static DateTime GetLastWriteTime(string path)
         /// </summary>
         /// <param name="appConfigFile"></param>
         /// <param name="redirects"></param>
-        protected static string WriteAppConfig(string redirects)
+        protected static string WriteAppConfig(string redirects, string appConfigNameSuffix = null)
         {
             string appConfigContents =
             "<configuration>\n" +
@@ -2920,7 +2920,7 @@ protected static string WriteAppConfig(string redirects)
             "    </runtime>\n" +
             "</configuration>";
 
-            string appConfigFile = FileUtilities.GetTemporaryFileName();
+            string appConfigFile = FileUtilities.GetTemporaryFileName() + appConfigNameSuffix;
             File.WriteAllText(appConfigFile, appConfigContents);
             return appConfigFile;
         }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
index e33de91b860..c4f0bd34510 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
@@ -38,13 +38,16 @@ public StronglyNamedDependencyAppConfig(ITestOutputHelper output) : base(output)
         /// - An app.config was passed in that promotes UnifyMe version from 1.0.0.0 to 2.0.0.0
         /// - Version 1.0.0.0 of UnifyMe exists.
         /// - Version 2.0.0.0 of UnifyMe exists.
+        /// - The case is attempted on special unicode characters in path as well.
         /// Expected:
         /// - The resulting UnifyMe returned should be 2.0.0.0.
         /// Rationale:
         /// Strongly named dependencies should unify according to the bindingRedirects in the app.config.
         /// </summary>
-        [Fact]
-        public void Exists()
+        [Theory]
+        [InlineData(null)]
+        [InlineData("\uE025\uE026")]
+        public void Exists(string appConfigNameSuffix)
         {
             // Create the engine.
             MockEngine engine = new MockEngine(_output);
@@ -59,7 +62,8 @@ public void Exists()
                     "        <dependentAssembly>\n" +
                     "            <assemblyIdentity name='UnifyMe' PublicKeyToken='b77a5c561934e089' culture='neutral' />\n" +
                     "            <bindingRedirect oldVersion='1.0.0.0' newVersion='2.0.0.0' />\n" +
-                    "        </dependentAssembly>\n");
+                    "        </dependentAssembly>\n",
+                    appConfigNameSuffix);
 
             // Now, pass feed resolved primary references into ResolveAssemblyReference.
             ResolveAssemblyReference t = new ResolveAssemblyReference();
diff --git a/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs b/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
index bf6e3c2a05c..af533432c22 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
@@ -59,7 +59,7 @@ private ITranslator GetReadTranslator()
             }
 
             _serializationStream.Seek(0, SeekOrigin.Begin);
-            return BinaryTranslator.GetReadTranslator(_serializationStream, null);
+            return BinaryTranslator.GetReadTranslator(_serializationStream, InterningBinaryReader.PoolingBuffer);
         }
 
         private ITranslator GetWriteTranslator()
diff --git a/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
index 062eab76b12..d3c94688e18 100644
--- a/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
+++ b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
@@ -21,14 +21,18 @@ public void TestPrecomputedCacheOutput()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
+                DateTime now = DateTime.Now;
                 TransientTestFile standardCache = env.CreateFile(".cache");
                 ResolveAssemblyReference t = new ResolveAssemblyReference()
                 {
                     _cache = new SystemState()
                 };
                 t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {
-                    { Path.Combine(standardCache.Path, "assembly1"), new SystemState.FileState(DateTime.Now) },
-                    { Path.Combine(standardCache.Path, "assembly2"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension("hi") } } };
+                    { Path.Combine(standardCache.Path, "assembly1"), new SystemState.FileState(now) },
+                    { Path.Combine(standardCache.Path, "assembly2"), new SystemState.FileState(now) { Assembly = new Shared.AssemblyNameExtension("hi") } } };
+                t._cache.SetGetLastWriteTime(_ => now);
+                _ = t._cache.GetFileState("assembly1");
+                _ = t._cache.GetFileState("assembly2");
                 t._cache.IsDirty = true;
                 t.StateFile = standardCache.Path;
                 t.WriteStateFile();
@@ -52,13 +56,18 @@ public void StandardCacheTakesPrecedence()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
+                DateTime now = DateTime.Now;
                 TransientTestFile standardCache = env.CreateFile(".cache");
                 ResolveAssemblyReference rarWriterTask = new ResolveAssemblyReference()
                 {
                     _cache = new SystemState()
                 };
-                rarWriterTask._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>();
+                rarWriterTask._cache.instanceLocalFileStateCache = new() {
+                    { "path1", new SystemState.FileState(now) },
+                };
+                rarWriterTask._cache.SetGetLastWriteTime(_ => now);
                 rarWriterTask.StateFile = standardCache.Path;
+                _ = rarWriterTask._cache.GetFileState("path1");
                 rarWriterTask._cache.IsDirty = true;
                 // Write standard cache
                 rarWriterTask.WriteStateFile();
diff --git a/src/Tasks/AppConfig/AppConfig.cs b/src/Tasks/AppConfig/AppConfig.cs
index 018a2ee5932..bc250b945f3 100644
--- a/src/Tasks/AppConfig/AppConfig.cs
+++ b/src/Tasks/AppConfig/AppConfig.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
 using System.Xml;
 
 using Microsoft.Build.Shared;
@@ -24,13 +25,16 @@ internal void Load(string appConfigFile)
             XmlReader reader = null;
             try
             {
-                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+                var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true};
 
                 // it's important to normalize the path as it may contain two slashes
                 // see https://github.com/dotnet/msbuild/issues/4335 for details.
                 appConfigFile = FileUtilities.NormalizePath(appConfigFile);
 
-                reader = XmlReader.Create(appConfigFile, readerSettings);
+                // Need a filestream as the XmlReader doesn't support nonstandard unicode characters in path.
+                // No need to dispose - as 'CloseInput' was passed to XmlReaderSettings
+                FileStream fs = File.OpenRead(appConfigFile);
+                reader = XmlReader.Create(fs, readerSettings);
                 Read(reader);
             }
             catch (XmlException e)
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 56e7d8ad826..45d87afb04c 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -2055,12 +2055,14 @@ internal void ReadStateFile(FileExists fileExists)
         /// </summary>
         internal void WriteStateFile()
         {
-            if (!String.IsNullOrEmpty(AssemblyInformationCacheOutputPath))
+            if (!string.IsNullOrEmpty(AssemblyInformationCacheOutputPath))
             {
                 _cache.SerializePrecomputedCache(AssemblyInformationCacheOutputPath, Log);
             }
-            else if (!String.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
+            else if (!string.IsNullOrEmpty(_stateFile) && (_cache.IsDirty || _cache.instanceLocalOutgoingFileStateCache.Count < _cache.instanceLocalFileStateCache.Count))
             {
+                // Either the cache is dirty (we added or updated an item) or the number of items actually used is less than what
+                // we got by reading the state file prior to execution. Serialize the cache into the state file.
                 if (FailIfNotIncremental)
                 {
                     Log.LogErrorFromResources("ResolveAssemblyReference.WritingCacheFile", _stateFile);
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 16985d1bb3d..c5bc3724e33 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -931,7 +931,7 @@ internal SDKInfo LoadAssemblyListFromCacheFile(string sdkIdentity, string sdkRoo
                     if (!string.IsNullOrEmpty(cacheFile))
                     {
                         using FileStream fs = new FileStream(cacheFile, FileMode.Open);
-                        using var translator = BinaryTranslator.GetReadTranslator(fs, buffer: null);
+                        using var translator = BinaryTranslator.GetReadTranslator(fs, InterningBinaryReader.PoolingBuffer);
                         SDKInfo sdkInfo = new SDKInfo();
                         sdkInfo.Translate(translator);
                         return sdkInfo;
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 330072c56cc..72ea1091d20 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -30,9 +30,6 @@
   </ItemGroup>
   <ItemGroup>
     <!-- Binary serialization by ITranslatable -->
-    <Compile Include="..\Shared\ITranslatable.cs" />
-    <Compile Include="..\Shared\ITranslator.cs" />
-    <Compile Include="..\Shared\BinaryTranslator.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
   </ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index af1a6b18164..44bed1b25ba 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -76,6 +76,34 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
+  <!--
+    Target that allows targets consuming source control confirmation to establish a dependency on targets producing this information.
+
+    Any target that reads SourceRevisionId, PrivateRepositoryUrl, SourceRoot, and other source control properties and items
+    should depend on this target and be conditioned on '$(SourceControlInformationFeatureSupported)' == 'true'.
+
+    SourceRevisionId property uniquely identifies the source control revision of the repository the project belongs to.
+    For Git repositories this id is a commit hash, for TFVC repositories it's the changeset number, etc.
+
+    PrivateRepositoryUrl property stores the URL of the repository supplied by the CI server or retrieved from source control manager.
+    Targets consuming this property shall not publish its value implicitly as it might inadvertently reveal an internal URL.
+    Instead, they shall only do so if the project sets PublishRepositoryUrl property to true. For example, the NuGet Pack target
+    may include the repository URL in the nuspec file generated for NuGet package produced by the project if PublishRepositoryUrl is true.
+
+    SourceRoot item group lists all source roots that the project source files reside under and their mapping to source control server URLs,
+    if available. This includes both source files under source control as well as source files in source packages. SourceRoot items are
+    used by compilers to determine path map in deterministic build and by SourceLink provider, which maps local paths to URLs of source files
+    stored on the source control server.
+
+    Source control information provider that sets these properties and items shall execute before this target (by including
+    InitializeSourceControlInformation in its BeforeTargets) and set source control properties and items that haven't been initialized yet.
+  -->
+  <Target Name="InitializeSourceControlInformation" />
+
+  <PropertyGroup>
+    <SourceControlInformationFeatureSupported>true</SourceControlInformationFeatureSupported>
+  </PropertyGroup>
+
   <!--
   ============================================================
                                        DispatchToInnerBuilds
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index f441cedcfdc..706899188d7 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -185,9 +185,9 @@ internal void UpdatePortableLibrary(PortableLibraryFile library)
         /// <summary>
         /// Writes the contents of this object out to the specified file.
         /// </summary>
-        internal override void SerializeCache(string stateFile, TaskLoggingHelper log)
+        internal override void SerializeCache(string stateFile, TaskLoggingHelper log, bool serializeEmptyState = false)
         {
-            base.SerializeCache(stateFile, log);
+            base.SerializeCache(stateFile, log, serializeEmptyState);
             _isDirty = false;
         }
 
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 061baf82ad9..96a4e7d7ce8 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -28,10 +28,15 @@ internal abstract class StateFileBase
         // Version this instance is serialized with.
         private byte _serializedVersion = CurrentSerializationVersion;
 
+        /// <summary>
+        /// True if <see cref="SerializeCache"/> should create the state file and serialize ourselves, false otherwise.
+        /// </summary>
+        internal virtual bool HasStateToSave => true;
+
         /// <summary>
         /// Writes the contents of this object out to the specified file.
         /// </summary>
-        internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
+        internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log, bool serializeEmptyState = false)
         {
             try
             {
@@ -42,11 +47,14 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
                         File.Delete(stateFile);
                     }
 
-                    using (var s = new FileStream(stateFile, FileMode.CreateNew))
+                    if (serializeEmptyState || HasStateToSave)
                     {
-                        var translator = BinaryTranslator.GetWriteTranslator(s);
-                        translator.Translate(ref _serializedVersion);
-                        Translate(translator);
+                        using (var s = new FileStream(stateFile, FileMode.CreateNew))
+                        {
+                            var translator = BinaryTranslator.GetWriteTranslator(s);
+                            translator.Translate(ref _serializedVersion);
+                            Translate(translator);
+                        }
                     }
                 }
             }
@@ -76,7 +84,7 @@ internal static T DeserializeCache<T>(string stateFile, TaskLoggingHelper log) w
                 {
                     using (FileStream s = File.OpenRead(stateFile))
                     {
-                        using var translator = BinaryTranslator.GetReadTranslator(s, buffer: null);
+                        using var translator = BinaryTranslator.GetReadTranslator(s, InterningBinaryReader.PoolingBuffer);
 
                         byte version = 0;
                         translator.Translate(ref version);
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 8290c6611d9..8774ba6773b 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -31,10 +31,21 @@ internal sealed class SystemState : StateFileBase, ITranslatable
         private Dictionary<string, FileState> upToDateLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
-        /// Cache at the SystemState instance level. It is serialized and reused between instances.
-        /// </summary>
+        /// Cache at the SystemState instance level.
+        /// </summary>
+        /// <remarks>
+        /// Before starting execution, RAR attempts to populate this field by deserializing a per-project cache file. During execution,
+        /// <see cref="FileState"/> objects that get actually used are inserted into <see cref="instanceLocalOutgoingFileStateCache"/>.
+        /// After execution, <see cref="instanceLocalOutgoingFileStateCache"/> is serialized and written to disk if it's different from
+        /// what we originally deserialized into this field.
+        /// </remarks>
         internal Dictionary<string, FileState> instanceLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
 
+        /// <summary>
+        /// Cache at the SystemState instance level. It is serialized to disk and reused between instances via <see cref="instanceLocalFileStateCache"/>.
+        /// </summary>
+        internal Dictionary<string, FileState> instanceLocalOutgoingFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
+
         /// <summary>
         /// LastModified information is purely instance-local. It doesn't make sense to
         /// cache this for long periods of time since there's no way (without actually 
@@ -104,7 +115,6 @@ internal sealed class SystemState : StateFileBase, ITranslatable
         /// <summary>
         /// Class that holds the current file state.
         /// </summary>
-        [Serializable]
         internal sealed class FileState : ITranslatable
         {
             /// <summary>
@@ -256,7 +266,7 @@ public override void Translate(ITranslator translator)
             }
 
             translator.TranslateDictionary(
-                ref instanceLocalFileStateCache,
+                ref (translator.Mode == TranslationDirection.WriteToStream) ? ref instanceLocalOutgoingFileStateCache : ref instanceLocalFileStateCache,
                 StringComparer.OrdinalIgnoreCase,
                 (ITranslator t) => new FileState(t));
 
@@ -265,6 +275,9 @@ public override void Translate(ITranslator translator)
             IsDirty = false;
         }
 
+        /// <inheritdoc />
+        internal override bool HasStateToSave => instanceLocalOutgoingFileStateCache.Count > 0;
+
         /// <summary>
         /// Flag that indicates that <see cref="instanceLocalFileStateCache"/> has been modified.
         /// </summary>
@@ -343,7 +356,7 @@ internal GetAssemblyRuntimeVersion CacheDelegate(GetAssemblyRuntimeVersion getAs
             return GetRuntimeVersion;
         }
 
-        private FileState GetFileState(string path)
+        internal FileState GetFileState(string path)
         {
             // Looking up an assembly to get its metadata can be expensive for projects that reference large amounts
             // of assemblies. To avoid that expense, we remember and serialize this information betweeen runs in
@@ -373,19 +386,30 @@ private FileState ComputeFileStateFromCachesAndDisk(string path)
             bool isInstanceFileStateUpToDate = isCachedInInstance && lastModified == cachedInstanceFileState.LastModified;
             bool isProcessFileStateUpToDate = isCachedInProcess && lastModified == cachedProcessFileState.LastModified;
 
-            // If the process-wide cache contains an up-to-date FileState, always use it
+            // If the process-wide cache contains an up-to-date FileState, always use it.
             if (isProcessFileStateUpToDate)
             {
                 // For the next build, we may be using a different process. Update the file cache if the entry is worth persisting.
-                if (!isInstanceFileStateUpToDate && cachedProcessFileState.IsWorthPersisting)
+                if (cachedProcessFileState.IsWorthPersisting)
                 {
-                    instanceLocalFileStateCache[path] = cachedProcessFileState;
-                    isDirty = true;
+                    if (!isInstanceFileStateUpToDate)
+                    {
+                        instanceLocalFileStateCache[path] = cachedProcessFileState;
+                        isDirty = true;
+                    }
+
+                    // Remember that this FileState was actually used by adding it to the outgoing dictionary.
+                    instanceLocalOutgoingFileStateCache[path] = cachedProcessFileState;
                 }
                 return cachedProcessFileState;
             }
             if (isInstanceFileStateUpToDate)
             {
+                if (cachedInstanceFileState.IsWorthPersisting)
+                {
+                    // Remember that this FileState was actually used by adding it to the outgoing dictionary.
+                    instanceLocalOutgoingFileStateCache[path] = cachedInstanceFileState;
+                }
                 return s_processWideFileStateCache[path] = cachedInstanceFileState;
             }
 
@@ -412,6 +436,7 @@ private FileState InitializeFileState(string path, DateTime lastModified)
             if (fileState.IsWorthPersisting)
             {
                 instanceLocalFileStateCache[path] = fileState;
+                instanceLocalOutgoingFileStateCache[path] = fileState;
                 isDirty = true;
             }
 
@@ -582,10 +607,10 @@ internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles,
         /// <param name="log">How to log</param>
         internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)
         {
-            // Save a copy of instanceLocalFileStateCache so we can restore it later. SerializeCacheByTranslator serializes
-            // instanceLocalFileStateCache by default, so change that to the relativized form, then change it back.
-            Dictionary<string, FileState> oldFileStateCache = instanceLocalFileStateCache;
-            instanceLocalFileStateCache = instanceLocalFileStateCache.ToDictionary(kvp => FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key), kvp => kvp.Value);
+            // Save a copy of instanceLocalOutgoingFileStateCache so we can restore it later. SerializeCacheByTranslator serializes
+            // instanceLocalOutgoingFileStateCache by default, so change that to the relativized form, then change it back.
+            Dictionary<string, FileState> oldFileStateCache = instanceLocalOutgoingFileStateCache;
+            instanceLocalOutgoingFileStateCache = instanceLocalFileStateCache.ToDictionary(kvp => FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key), kvp => kvp.Value);
 
             try
             {
@@ -597,7 +622,7 @@ internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)
             }
             finally
             {
-                instanceLocalFileStateCache = oldFileStateCache;
+                instanceLocalOutgoingFileStateCache = oldFileStateCache;
             }
         }
 
