diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 752230391f8..05631f3f090 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -12,7 +12,7 @@
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
 
     <DefineConstants>$(DefineConstants);MICROSOFT_BUILD_ENGINE_OM_UNITTESTS;NO_FRAMEWORK_IVT</DefineConstants>
-	  <NoWarn>$(NoWarn);CA2000</NoWarn>
+    <NoWarn>$(NoWarn);CA2000</NoWarn>
   </PropertyGroup>
 
   <PropertyGroup>
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index 39d1f99297b..4f9e62b9343 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -4,6 +4,8 @@
 using System;
 using System.Collections.Concurrent;
 using System.IO;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
 using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
@@ -467,20 +469,75 @@ public override void Flush()
                 _internalWriter.Flush();
             }
 
-            public override void Write(char value)
-            {
-                _syncWriter.Write(value);
-            }
+            public override void Write(char value) => _syncWriter.Write(value);
 
-            public override void Write(char[] buffer, int index, int count)
-            {
-                _syncWriter.Write(buffer, index, count);
-            }
+            public override void Write(char[]? buffer) => _syncWriter.Write(buffer);
 
-            public override void Write(string? value)
-            {
-                _syncWriter.Write(value);
-            }
+            public override void Write(char[] buffer, int index, int count) => _syncWriter.Write(buffer, index, count);
+
+            public override void Write(bool value) => _syncWriter.Write(value);
+
+            public override void Write(int value) => _syncWriter.Write(value);
+
+            public override void Write(uint value) => _syncWriter.Write(value);
+
+            public override void Write(long value) => _syncWriter.Write(value);
+
+            public override void Write(ulong value) => _syncWriter.Write(value);
+ 
+            public override void Write(float value) => _syncWriter.Write(value);
+
+            public override void Write(double value) => _syncWriter.Write(value);
+
+            public override void Write(decimal value) => _syncWriter.Write(value);
+
+            public override void Write(string? value) => _syncWriter.Write(value);
+
+            public override void Write(object? value) => _syncWriter.Write(value);
+
+            public override void Write(string format, object? arg0) => _syncWriter.Write(format, arg0);
+
+            public override void Write(string format, object? arg0, object? arg1) => _syncWriter.Write(format, arg0, arg1);
+
+            public override void Write(string format, object? arg0, object? arg1, object? arg2) => _syncWriter.Write(format, arg0, arg1, arg2);
+
+            public override void Write(string format, params object?[] arg) => _syncWriter.WriteLine(format, arg);
+
+            public override void WriteLine() => _syncWriter.WriteLine();
+
+            public override void WriteLine(char value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(decimal value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(char[]? buffer) => _syncWriter.WriteLine(buffer);
+
+            public override void WriteLine(char[] buffer, int index, int count) => _syncWriter.WriteLine(buffer, index, count);
+
+            public override void WriteLine(bool value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(int value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(uint value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(long value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(ulong value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(float value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(double value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(string? value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(object? value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(string format, object? arg0) => _syncWriter.WriteLine(format, arg0);
+
+            public override void WriteLine(string format, object? arg0, object? arg1) => _syncWriter.WriteLine(format, arg0, arg1);
+
+            public override void WriteLine(string format, object? arg0, object? arg1, object? arg2) => _syncWriter.WriteLine(format, arg0, arg1, arg2);
+
+            public override void WriteLine(string format, params object?[] arg) => _syncWriter.WriteLine(format, arg);
 
             private void TimerCallback(object? state)
             {
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index f34b0443210..094d4ad31cf 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -700,11 +700,19 @@ public void CacheIfPossible()
                     {
                         string cacheFile = GetCacheFile();
                         Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));
+                        try
+                        {
+                            using Stream stream = File.Create(cacheFile);
+                            using ITranslator translator = GetConfigurationTranslator(TranslationDirection.WriteToStream, stream);
+
+                            _project.Cache(translator);
+                        }
+                        catch (Exception e) when (e is DirectoryNotFoundException or UnauthorizedAccessException)
+                        {
+                            ErrorUtilities.ThrowInvalidOperation("CacheFileInaccessible", cacheFile, e);
+                            throw;
+                        }
 
-                        using Stream stream = File.Create(cacheFile);
-                        using ITranslator translator = GetConfigurationTranslator(TranslationDirection.WriteToStream, stream, cacheFile);
-
-                        _project.Cache(translator);
                         _baseLookup = null;
 
                         IsCached = true;
@@ -731,10 +739,18 @@ public void RetrieveFromCache()
                 }
 
                 string cacheFile = GetCacheFile();
-                using Stream stream = File.OpenRead(cacheFile);
-                using ITranslator translator = GetConfigurationTranslator(TranslationDirection.ReadFromStream, stream, cacheFile);
+                try
+                {
+                    using Stream stream = File.OpenRead(cacheFile);
+                    using ITranslator translator = GetConfigurationTranslator(TranslationDirection.ReadFromStream, stream);
 
-                _project.RetrieveFromCache(translator);
+                    _project.RetrieveFromCache(translator);
+                }
+                catch (Exception e) when (e is DirectoryNotFoundException or UnauthorizedAccessException)
+                {
+                    ErrorUtilities.ThrowInvalidOperation("CacheFileInaccessible", cacheFile, e);
+                    throw;
+                }
 
                 IsCached = false;
             }
@@ -945,6 +961,7 @@ internal void ApplyTransferredState(ProjectInstance instance)
         internal string GetCacheFile()
         {
             string filename = Path.Combine(FileUtilities.GetCacheDirectory(), String.Format(CultureInfo.InvariantCulture, "Configuration{0}.cache", _configId));
+
             return filename;
         }
 
@@ -1030,21 +1047,10 @@ private static string ResolveToolsVersion(BuildRequestData data, string defaultT
         /// <summary>
         /// Gets the translator for this configuration.
         /// </summary>
-        private ITranslator GetConfigurationTranslator(TranslationDirection direction, Stream stream, string cacheFile)
-        {
-            try
-            {
-                return direction == TranslationDirection.WriteToStream
+        private ITranslator GetConfigurationTranslator(TranslationDirection direction, Stream stream) =>
+            direction == TranslationDirection.WriteToStream
                     ? BinaryTranslator.GetWriteTranslator(stream)
-
                     // Not using sharedReadBuffer because this is not a memory stream and so the buffer won't be used anyway.
                     : BinaryTranslator.GetReadTranslator(stream, InterningBinaryReader.PoolingBuffer);
-            }
-            catch (Exception e) when (e is DirectoryNotFoundException or UnauthorizedAccessException)
-            {
-                ErrorUtilities.ThrowInvalidOperation("CacheFileInaccessible", cacheFile, e);
-                throw;
-            }
-        }
     }
 }
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 02f8d92045d..9d0428b265e 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -248,16 +248,20 @@ internal void CacheItems(int configId, string targetName)
                 string cacheFile = GetCacheFile(configId, targetName);
                 Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));
 
-                using Stream stream = File.Create(cacheFile);
-                using ITranslator translator = GetResultsCacheTranslator(TranslationDirection.WriteToStream, stream, cacheFile);
-
-                // If the translator is null, it means these results were cached once before.  Since target results are immutable once they
-                // have been created, there is no point in writing them again.
-                if (translator != null)
+                // If the file doesn't already exists, then we haven't cached this once before. We need to cache it again since it could have changed.
+                if (!FileSystems.Default.FileExists(cacheFile))
                 {
-                    TranslateItems(translator);
-                    _items = null;
-                    _cacheInfo = new CacheInfo(configId, targetName);
+                    using Stream stream = File.Create(cacheFile);
+                    using ITranslator translator = GetResultsCacheTranslator(TranslationDirection.WriteToStream, stream, cacheFile);
+
+                    // If the translator is null, it means these results were cached once before.  Since target results are immutable once they
+                    // have been created, there is no point in writing them again.
+                    if (translator != null)
+                    {
+                        TranslateItems(translator);
+                        _items = null;
+                        _cacheInfo = new CacheInfo(configId, targetName);
+                    }
                 }
             }
         }
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 84aefed175a..92c09ec6c01 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -291,34 +291,28 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
                         return string.Empty;
                     }
 
-                    RegistryKey key = null;
-                    try
+#pragma warning disable CA2000 // Dispose objects before losing scope is false positive here.
+                    using (RegistryKey key = GetBaseKeyFromKeyName(keyName, view, out string subKeyName))
                     {
-                        using (key = GetBaseKeyFromKeyName(keyName, view, out string subKeyName))
+                        if (key != null)
                         {
-                            if (key != null)
+                            using (RegistryKey subKey = key.OpenSubKey(subKeyName, false))
                             {
-                                using (RegistryKey subKey = key.OpenSubKey(subKeyName, false))
+                                // If we managed to retrieve the subkey, then move onto locating the value
+                                if (subKey != null)
                                 {
-                                    // If we managed to retrieve the subkey, then move onto locating the value
-                                    if (subKey != null)
-                                    {
-                                        result = subKey.GetValue(valueName);
-                                    }
-
-                                    // We've found a value, so stop looking
-                                    if (result != null)
-                                    {
-                                        break;
-                                    }
+                                    result = subKey.GetValue(valueName);
+                                }
+
+                                // We've found a value, so stop looking
+                                if (result != null)
+                                {
+                                    break;
                                 }
                             }
                         }
                     }
-                    finally
-                    {
-                        key?.Dispose();
-                    }
+#pragma warning restore CA2000 // Dispose objects before losing scope
                 }
             }
 
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
index 68c15b3288a..d8eca6c3848 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
@@ -5,6 +5,7 @@
 using System.Buffers;
 using System.Diagnostics;
 using System.IO;
+using System.Text;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
@@ -60,7 +61,7 @@ public static byte[] ReadToEnd(this Stream stream)
         {
             if (stream.TryGetLength(out long length))
             {
-                using BinaryReader reader = new(stream);
+                using BinaryReader reader = new(stream, Encoding.UTF8, leaveOpen: true);
 
                 return reader.ReadBytes((int)length);
             }
diff --git a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
index 340e769371f..53bb173c271 100644
--- a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
+++ b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
@@ -197,34 +197,28 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
                     // of that error.
                     RegistryView view = (RegistryView)Enum.Parse(typeof(RegistryView), viewAsString, true);
 
-                    RegistryKey key = null;
-                    try
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed as a false positive.
+                    using (RegistryKey key = GetBaseKeyFromKeyName(keyName, view, out subKeyName))
                     {
-                        using (key = GetBaseKeyFromKeyName(keyName, view, out subKeyName))
+                        if (key != null)
                         {
-                            if (key != null)
+                            using (RegistryKey subKey = key.OpenSubKey(subKeyName, false))
                             {
-                                using (RegistryKey subKey = key.OpenSubKey(subKeyName, false))
+                                // If we managed to retrieve the subkey, then move onto locating the value
+                                if (subKey != null)
                                 {
-                                    // If we managed to retrieve the subkey, then move onto locating the value
-                                    if (subKey != null)
-                                    {
-                                        result = subKey.GetValue(valueName);
-                                    }
-
-                                    // We've found a value, so stop looking
-                                    if (result != null)
-                                    {
-                                        break;
-                                    }
+                                    result = subKey.GetValue(valueName);
+                                }
+
+                                // We've found a value, so stop looking
+                                if (result != null)
+                                {
+                                    break;
                                 }
                             }
                         }
                     }
-                    finally
-                    {
-                        key?.Dispose();
-                    }
+#pragma warning restore CA2000 // Dispose objects before losing scope
                 }
             }
 
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 9cff18f438d..25cb0c8b95e 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -1302,21 +1302,14 @@ internal static int GetParentProcessId(int processId)
             {
                 if (!hProcess.IsInvalid)
                 {
-                    try
-                    {
-                        // UNDONE: NtQueryInformationProcess will fail if we are not elevated and other process is. Advice is to change to use ToolHelp32 API's
-                        // For now just return zero and worst case we will not kill some children.
-                        PROCESS_BASIC_INFORMATION pbi = new PROCESS_BASIC_INFORMATION();
-                        int pSize = 0;
+                    // UNDONE: NtQueryInformationProcess will fail if we are not elevated and other process is. Advice is to change to use ToolHelp32 API's
+                    // For now just return zero and worst case we will not kill some children.
+                    PROCESS_BASIC_INFORMATION pbi = new PROCESS_BASIC_INFORMATION();
+                    int pSize = 0;
 
-                        if (0 == NtQueryInformationProcess(hProcess, PROCESSINFOCLASS.ProcessBasicInformation, ref pbi, pbi.Size, ref pSize))
-                        {
-                            ParentID = (int)pbi.InheritedFromUniqueProcessId;
-                        }
-                    }
-                    finally
+                    if (0 == NtQueryInformationProcess(hProcess, PROCESSINFOCLASS.ProcessBasicInformation, ref pbi, pbi.Size, ref pSize))
                     {
-                        hProcess.Dispose();
+                        ParentID = (int)pbi.InheritedFromUniqueProcessId;
                     }
                 }
             }
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index 787d5ea4979..2ea2106d417 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -4,7 +4,7 @@
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
     <IsPackable>false</IsPackable>
-  	<NoWarn>$(NoWarn);CA2000</NoWarn>
+    <NoWarn>$(NoWarn);CA2000</NoWarn>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 8aa95e9ab23..887e61a299c 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -826,9 +826,11 @@ public static ExitType Execute(
                             using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))
                             {
                                 Project project = collection.LoadProject(projectFile, globalProperties, toolsVersion);
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because the StreamWriter is disposed in the finally block
                                 output = getResultOutputFile.Length > 0
                                     ? new StreamWriter(getResultOutputFile)
                                     : Console.Out;
+#pragma warning restore CA2000 // Dispose objects before losing scope
                                 exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project, output);
                                 collection.LogBuildFinishedEvent(exitType == ExitType.Success);
                             }
@@ -839,7 +841,11 @@ public static ExitType Execute(
                         }
                         finally
                         {
-                            output?.Dispose();
+                            if (output is StreamWriter)
+                            {
+                                // dispose only if StreamWriter to avoid closing Console.Out
+                                output?.Dispose();
+                            }
                         }
                     }
                     else // regular build
@@ -898,13 +904,19 @@ public static ExitType Execute(
                     {
                         if (outputPropertiesItemsOrTargetResults && targets?.Length > 0 && result is not null)
                         {
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because the StreamWriter is disposed in the finally block
                             outputStream = getResultOutputFile.Length > 0 ? new StreamWriter(getResultOutputFile) : Console.Out;
+#pragma warning restore CA2000 // Dispose objects before losing scope
                             exitType = OutputBuildInformationInJson(result, getProperty, getItem, getTargetResult, loggers, exitType, outputStream);
                         }
                     }
                     finally
                     {
-                        outputStream?.Dispose();
+                        if (outputStream is StreamWriter)
+                        {
+                            // dispose only if StreamWriter to avoid closing Console.Out
+                            outputStream?.Dispose();
+                        }
                     }
 
                     if (!string.IsNullOrEmpty(timerOutputFilename))
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.csproj
index c9ab3135d37..5c5e35465f3 100644
--- a/src/StringTools.UnitTests/StringTools.UnitTests.csproj
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.csproj
@@ -8,7 +8,7 @@
     <AssemblyName>Microsoft.NET.StringTools.UnitTests</AssemblyName>
     <IsTestProject>true</IsTestProject>
     <IsLibraryTestProject>true</IsLibraryTestProject>
-	<NoWarn>$(NoWarn);CA2000</NoWarn>
+    <NoWarn>$(NoWarn);CA2000</NoWarn>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
index 31a5634c2f4..b63fa1e4e9e 100644
--- a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -14,7 +14,7 @@
     <IsTestProject>true</IsTestProject>
     <IsLibraryTestProject>true</IsLibraryTestProject>
     <DefineConstants>$(DefineConstants);NET35_UNITTEST</DefineConstants>
-	<NoWarn>$(NoWarn);CA2000</NoWarn>
+    <NoWarn>$(NoWarn);CA2000</NoWarn>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/Tasks/AppConfig/AppConfig.cs b/src/Tasks/AppConfig/AppConfig.cs
index 40932d287a5..0e746a573e7 100644
--- a/src/Tasks/AppConfig/AppConfig.cs
+++ b/src/Tasks/AppConfig/AppConfig.cs
@@ -34,10 +34,10 @@ internal void Load(string appConfigFilePath)
                 // Need a filestream as the XmlReader doesn't support nonstandard unicode characters in path.
                 // No need to dispose - as 'CloseInput' was passed to XmlReaderSettings
                 FileStream fs = File.OpenRead(appConfigFilePath);
-                using (reader = XmlReader.Create(fs, readerSettings))
-                {
-                    Read(reader);
-                }
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because the reader is disposed in the finally block
+                reader = XmlReader.Create(fs, readerSettings);
+#pragma warning restore CA2000 // Dispose objects before losing scope
+                Read(reader);
             }
             catch (XmlException e)
             {
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index eaf9a7bca99..af988ec51d3 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -974,7 +974,7 @@ private bool IsDangerous(String filename)
                 // XML files are only dangerous if there are unrecognized objects in them
                 dangerous = false;
 
-                FileStream stream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);
+                using FileStream stream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);
                 using XmlTextReader reader = new XmlTextReader(stream);
                 reader.DtdProcessing = DtdProcessing.Ignore;
                 reader.XmlResolver = null;
@@ -2163,8 +2163,6 @@ private void RecordFilesWritten()
                         {
                             StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(
                                 provider, OutputResources[0].ItemSpec);
-
-                            provider.Dispose();
                         }
                     }
                     finally
@@ -3432,60 +3430,61 @@ private void CreateStronglyTypedResources(ReaderInfo reader, String outFile, Str
                     sourceFile = null;
                     return;
                 }
-            }
-            finally
-            {
-                provider?.Dispose();
-            }
 
-            // Default the class name if we need to
-            if (_stronglyTypedClassName == null)
-            {
-                _stronglyTypedClassName = Path.GetFileNameWithoutExtension(outFile);
-            }
 
-            // Default the filename if we need to
-            if (_stronglyTypedFilename == null)
-            {
-                _stronglyTypedFilename = GenerateDefaultStronglyTypedFilename(provider, outFile);
-            }
-            sourceFile = this.StronglyTypedFilename;
-
-            _logger.LogMessageFromResources("GenerateResource.CreatingSTR", _stronglyTypedFilename);
-
-            // Generate the STR class
-            String[] errors;
-            bool generateInternalClass = !_stronglyTypedClassIsPublic;
-            // StronglyTypedResourcesNamespace can be null and this is ok.
-            // If it is null then the default namespace (=stronglyTypedNamespace) is used.
-            CodeCompileUnit ccu = StronglyTypedResourceBuilder.Create(
-                    reader.resourcesHashTable,
-                    _stronglyTypedClassName,
-                    _stronglyTypedNamespace,
-                    _stronglyTypedResourcesNamespace,
-                    provider,
-                    generateInternalClass,
-                    out errors);
+                // Default the class name if we need to
+                if (_stronglyTypedClassName == null)
+                {
+                    _stronglyTypedClassName = Path.GetFileNameWithoutExtension(outFile);
+                }
 
-            CodeGeneratorOptions codeGenOptions = new CodeGeneratorOptions();
-            using (TextWriter output = new StreamWriter(_stronglyTypedFilename))
-            {
-                provider.GenerateCodeFromCompileUnit(ccu, output, codeGenOptions);
-            }
+                // Default the filename if we need to
+                if (_stronglyTypedFilename == null)
+                {
+                    _stronglyTypedFilename = GenerateDefaultStronglyTypedFilename(provider, outFile);
+                }
+                sourceFile = this.StronglyTypedFilename;
+
+                _logger.LogMessageFromResources("GenerateResource.CreatingSTR", _stronglyTypedFilename);
+
+                // Generate the STR class
+                String[] errors;
+                bool generateInternalClass = !_stronglyTypedClassIsPublic;
+                // StronglyTypedResourcesNamespace can be null and this is ok.
+                // If it is null then the default namespace (=stronglyTypedNamespace) is used.
+                CodeCompileUnit ccu = StronglyTypedResourceBuilder.Create(
+                        reader.resourcesHashTable,
+                        _stronglyTypedClassName,
+                        _stronglyTypedNamespace,
+                        _stronglyTypedResourcesNamespace,
+                        provider,
+                        generateInternalClass,
+                        out errors);
+
+                CodeGeneratorOptions codeGenOptions = new CodeGeneratorOptions();
+                using (TextWriter output = new StreamWriter(_stronglyTypedFilename))
+                {
+                    provider.GenerateCodeFromCompileUnit(ccu, output, codeGenOptions);
+                }
 
-            if (errors.Length > 0)
-            {
-                _logger.LogErrorWithCodeFromResources("GenerateResource.ErrorFromCodeDom", inputFileName);
-                foreach (String error in errors)
+                if (errors.Length > 0)
                 {
-                    _logger.LogErrorWithCodeFromResources("GenerateResource.CodeDomError", error);
+                    _logger.LogErrorWithCodeFromResources("GenerateResource.ErrorFromCodeDom", inputFileName);
+                    foreach (String error in errors)
+                    {
+                        _logger.LogErrorWithCodeFromResources("GenerateResource.CodeDomError", error);
+                    }
+                }
+                else
+                {
+                    // No errors, and no exceptions - we presumably did create the STR class file
+                    // and it should get added to FilesWritten. So set a flag to indicate this.
+                    _stronglyTypedResourceSuccessfullyCreated = true;
                 }
             }
-            else
+            finally
             {
-                // No errors, and no exceptions - we presumably did create the STR class file
-                // and it should get added to FilesWritten. So set a flag to indicate this.
-                _stronglyTypedResourceSuccessfullyCreated = true;
+                provider?.Dispose();
             }
         }
 
diff --git a/src/Tasks/GetInstalledSDKLocations.cs b/src/Tasks/GetInstalledSDKLocations.cs
index 8f4bb052bd9..e1d4bb966e7 100644
--- a/src/Tasks/GetInstalledSDKLocations.cs
+++ b/src/Tasks/GetInstalledSDKLocations.cs
@@ -194,7 +194,9 @@ public override bool Execute()
                 object staticCacheDisposer = buildEngine4.GetRegisteredTaskObject(StaticSDKCacheKey, RegisteredTaskObjectLifetime.Build);
                 if (staticCacheDisposer == null)
                 {
-                    using BuildCacheDisposeWrapper staticDisposer = new BuildCacheDisposeWrapper(ToolLocationHelper.ClearSDKStaticCache);
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because the object is registered with the engine and disposed of at the end of the build.
+                    BuildCacheDisposeWrapper staticDisposer = new BuildCacheDisposeWrapper(ToolLocationHelper.ClearSDKStaticCache);
+#pragma warning restore CA2000 // Dispose objects before losing scope
                     buildEngine4.RegisterTaskObject(StaticSDKCacheKey, staticDisposer, RegisteredTaskObjectLifetime.Build, allowEarlyCollection: false);
                 }
             }
diff --git a/src/Tasks/ManifestUtil/ManifestWriter.cs b/src/Tasks/ManifestUtil/ManifestWriter.cs
index 45d6c4ddd18..465fe49bbf6 100644
--- a/src/Tasks/ManifestUtil/ManifestWriter.cs
+++ b/src/Tasks/ManifestUtil/ManifestWriter.cs
@@ -24,7 +24,9 @@ private static Stream Serialize(Manifest manifest)
             manifest.OnBeforeSave();
             var m = new MemoryStream();
             var s = new XmlSerializer(manifest.GetType());
-            using var w = new StreamWriter(m);
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because the stream is returned to the caller and will be handled there.
+            var w = new StreamWriter(m);
+#pragma warning restore CA2000 // Dispose objects before losing scope
 
             int t1 = Environment.TickCount;
             s.Serialize(w, manifest);
@@ -32,6 +34,7 @@ private static Stream Serialize(Manifest manifest)
 
             w.Flush();
             m.Position = 0;
+
             return m;
         }
 
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 6d5f37aba14..457265e0333 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -205,7 +205,9 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkName fn)
                         {
                             try
                             {
-                                using var sr = new StreamReader(fs);
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because it is managed by FileStream above.
+                                var sr = new StreamReader(fs);
+#pragma warning restore CA2000 // Dispose objects before losing scope
                                 string data = sr.ReadToEnd();
                                 if (!string.IsNullOrEmpty(data))
                                 {
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index e0852911d90..40f8c1bc221 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -521,7 +521,9 @@ public static void WriteLogFile(string filename, Stream s)
             }
 
             string path = Path.Combine(logPath, filename);
-            using StreamReader r = new StreamReader(s);
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because the stream is returned to the caller and will be handled there.
+            StreamReader r = new StreamReader(s);
+#pragma warning restore CA2000 // Dispose objects before losing scope
             string text = r.ReadToEnd();
             try
             {
@@ -539,6 +541,7 @@ public static void WriteLogFile(string filename, Stream s)
             catch (SecurityException)
             {
             }
+
             s.Position = 0;
         }
 
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 20f9579a604..6590a161c43 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -5,7 +5,6 @@
 using System.IO;
 using System.IO.Compression;
 using System.Linq;
-using System.Runtime.InteropServices.ComTypes;
 using System.Threading;
 
 using Microsoft.Build.Framework;
@@ -99,8 +98,6 @@ public override bool Execute()
 
             BuildEngine3.Yield();
 
-            FileStream stream = null;
-            ZipArchive zipArchive = null;
             try
             {
                 ParseIncludeExclude();
@@ -117,9 +114,10 @@ public override bool Execute()
 
                         try
                         {
-                            using (stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))
+                            using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))
                             {
-                                using (zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))
+#pragma warning disable CA2000 // Dispose objects before losing scope because ZipArchive will dispose the stream when it is disposed.
+                                using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))
                                 {
                                     try
                                     {
@@ -132,6 +130,7 @@ public override bool Execute()
                                         return false;
                                     }
                                 }
+#pragma warning restore CA2000 // Dispose objects before losing scope
                             }
                         }
                         catch (OperationCanceledException)
@@ -149,8 +148,6 @@ public override bool Execute()
             finally
             {
                 BuildEngine3.Reacquire();
-                stream?.Dispose();
-                zipArchive?.Dispose();
             }
 
             return !_cancellationToken.IsCancellationRequested && !Log.HasLoggedErrors;
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index d59a89f4510..2576fa2b2b7 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -140,12 +140,24 @@ private string GenerateCode(out string extension)
             extension = null;
             bool haveGeneratedContent = false;
 
-            string code = string.Empty;
             CodeDomProvider provider = null;
-
             try
             {
-                provider = CodeDomProvider.CreateProvider(Language);
+                try
+                {
+                    provider = CodeDomProvider.CreateProvider(Language);
+                }
+                catch (SystemException e) when
+#if FEATURE_SYSTEM_CONFIGURATION
+                (e is ConfigurationException || e is SecurityException)
+#else
+            (e.GetType().Name == "ConfigurationErrorsException") // TODO: catch specific exception type once it is public https://github.com/dotnet/corefx/issues/40456
+#endif
+                {
+                    Log.LogErrorWithCodeFromResources("WriteCodeFragment.CouldNotCreateProvider", Language, e.Message);
+                    return null;
+                }
+
                 extension = provider.FileExtension;
 
                 var unit = new CodeCompileUnit();
@@ -263,26 +275,19 @@ private string GenerateCode(out string extension)
                     provider.GenerateCodeFromCompileUnit(unit, writer, new CodeGeneratorOptions());
                 }
 
-                code = generatedCode.ToString();
-            }
-            catch (SystemException e) when
-#if FEATURE_SYSTEM_CONFIGURATION
-            (e is ConfigurationException || e is SecurityException)
-#else
-            (e.GetType().Name == "ConfigurationErrorsException") // TODO: catch specific exception type once it is public https://github.com/dotnet/corefx/issues/40456
-#endif
-            {
-                Log.LogErrorWithCodeFromResources("WriteCodeFragment.CouldNotCreateProvider", Language, e.Message);
-                return null;
+                string code = generatedCode.ToString();
+
+                // If we just generated infrastructure, don't bother returning anything
+                // as there's no point writing the file
+                return haveGeneratedContent ? code : String.Empty;
             }
             finally
             {
-                provider?.Dispose();
+                if (provider != null)
+                {
+                    provider.Dispose();
+                }
             }
-
-            // If we just generated infrastructure, don't bother returning anything
-            // as there's no point writing the file
-            return haveGeneratedContent ? code : String.Empty;
         }
 
         /// <summary>
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 2533a8bd9d0..304b318e2b8 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -6,7 +6,7 @@
     <IsShipping>false</IsShipping>
     <IsTestProject>false</IsTestProject>
     <IsTestLibrary>true</IsTestLibrary>
-	  <NoWarn>$(NoWarn);CA2000</NoWarn>
+    <NoWarn>$(NoWarn);CA2000</NoWarn>
   </PropertyGroup>
   <ItemGroup>
     <!-- Implicit references to xunit.core and xunit.assert in test projects by Arcade
