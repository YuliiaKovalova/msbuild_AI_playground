diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 4d5ef743d0d..d6c4a58df99 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -6,6 +6,7 @@
 using System.Collections.Immutable;
 using System.IO;
 using System.Linq;
+using System.Text.RegularExpressions;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
@@ -13,11 +14,30 @@
 using Microsoft.Build.UnitTests;
 using Shouldly;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.Experimental.Graph.UnitTests
 {
-    public class ProjectGraphTests
+    public class ProjectGraphTests : IDisposable
     {
+        private TestEnvironment _env;
+
+        private static readonly ImmutableDictionary<string, string> EmptyGlobalProperties = new Dictionary<string, string> {{PropertyNames.IsGraphBuild, "true"}}.ToImmutableDictionary();
+
+        private static readonly string InnerBuildProperty = "InnerBuild";
+        private static readonly string OuterBuildSpecification = $@"<PropertyGroup>
+                                                                        <InnerBuildProperty>{InnerBuildProperty}</InnerBuildProperty>
+                                                                        <InnerBuildPropertyValues>InnerBuildProperties</InnerBuildPropertyValues>
+                                                                        <InnerBuildProperties>a;b</InnerBuildProperties>
+                                                                     </PropertyGroup>
+
+";
+
+        public ProjectGraphTests(ITestOutputHelper outputHelper)
+        {
+            _env = TestEnvironment.Create(outputHelper);
+        }
+
         [Fact]
         public void ConstructWithNoNodes()
         {
@@ -97,9 +117,9 @@ public void ConstructWithThreeNodes()
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
 
                 graph.ProjectNodes.Count.ShouldBe(3);
-                GetNodeForProject(graph, 1).ProjectReferences.Count.ShouldBe(2);
-                GetNodeForProject(graph, 2).ProjectReferences.Count.ShouldBe(0);
-                GetNodeForProject(graph, 3).ProjectReferences.Count.ShouldBe(0);
+                GetFirstNodeWithProjectNumber(graph, 1).ProjectReferences.Count.ShouldBe(2);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.Count.ShouldBe(0);
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.Count.ShouldBe(0);
             }
         }
 
@@ -126,13 +146,13 @@ public void ConstructWithMultipleNodes()
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
 
                 graph.ProjectNodes.Count.ShouldBe(7);
-                ProjectGraphNode node1 = GetNodeForProject(graph, 1);
-                ProjectGraphNode node2 = GetNodeForProject(graph, 2);
-                ProjectGraphNode node3 = GetNodeForProject(graph, 3);
-                ProjectGraphNode node4 = GetNodeForProject(graph, 4);
-                ProjectGraphNode node5 = GetNodeForProject(graph, 5);
-                ProjectGraphNode node6 = GetNodeForProject(graph, 6);
-                ProjectGraphNode node7 = GetNodeForProject(graph, 7);
+                ProjectGraphNode node1 = GetFirstNodeWithProjectNumber(graph, 1);
+                ProjectGraphNode node2 = GetFirstNodeWithProjectNumber(graph, 2);
+                ProjectGraphNode node3 = GetFirstNodeWithProjectNumber(graph, 3);
+                ProjectGraphNode node4 = GetFirstNodeWithProjectNumber(graph, 4);
+                ProjectGraphNode node5 = GetFirstNodeWithProjectNumber(graph, 5);
+                ProjectGraphNode node6 = GetFirstNodeWithProjectNumber(graph, 6);
+                ProjectGraphNode node7 = GetFirstNodeWithProjectNumber(graph, 7);
 
                 node1.ProjectReferences.Count.ShouldBe(2);
                 node2.ProjectReferences.Count.ShouldBe(3);
@@ -237,12 +257,11 @@ public void ConstructWithDifferentGlobalProperties()
                 graph.ProjectNodes.Count.ShouldBe(5);
 
                 // Projects 2 and 3 both reference project 4, but with different properties, so they should not point to the same node.
-                GetNodeForProject(graph, 2).ProjectReferences.First().ShouldNotBe(GetNodeForProject(graph, 3).ProjectReferences.First());
-                GetNodeForProject(graph, 2).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("4.proj");
-                GetNodeForProject(graph, 2).ProjectReferences.First().ProjectInstance.GlobalProperties.ShouldHaveSingleItem();
-                GetNodeForProject(graph, 2).ProjectReferences.First().ProjectInstance.GlobalProperties.Keys.First().ShouldBe(PropertyNames.IsGraphBuild);
-                GetNodeForProject(graph, 3).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("4.proj");
-                GetNodeForProject(graph, 3).ProjectReferences.First().ProjectInstance.GlobalProperties.ShouldNotBeEmpty();
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ShouldNotBe(GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First());
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("4.proj");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties);
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("4.proj");
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First().ProjectInstance.GlobalProperties.Count.ShouldBeGreaterThan(1);
             }
         }
 
@@ -261,7 +280,7 @@ public void TestGlobalPropertiesInProjectReferences()
                 CreateProjectFile(env, 3);
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
                 graph.ProjectNodes.Count.ShouldBe(3);
-                GetNodeForProject(graph, 3).ProjectInstance.GlobalProperties["A"].ShouldBe("B");
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstance.GlobalProperties["A"].ShouldBe("B");
             }
         }
 
@@ -295,8 +314,8 @@ public void ConstructWithConvergingProperties()
                 // Project 4 requires 2 nodes, but project 5 does not
                 graph.ProjectNodes.Count.ShouldBe(6);
 
-                var node4A = GetNodeForProject(graph, 2).ProjectReferences.First();
-                var node4B = GetNodeForProject(graph, 3).ProjectReferences.First();
+                var node4A = GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First();
+                var node4B = GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First();
                 node4A.ShouldNotBe(node4B);
 
                 node4A.ProjectReferences.Count.ShouldBe(1);
@@ -332,7 +351,7 @@ public void ConstructWithSameEffectiveProperties()
                 graph.ProjectNodes.Count.ShouldBe(4);
 
                 // The project references end up using the same effective properties
-                GetNodeForProject(graph, 2).ProjectReferences.First().ShouldBe(GetNodeForProject(graph, 3).ProjectReferences.First());
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ShouldBe(GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First());
             }
         }
 
@@ -367,14 +386,14 @@ public void ConstructWithCaseDifferences()
                 graph.ProjectNodes.Count.ShouldBe(6);
 
                 // Property names are case-insensitive, so projects 2 and 3 point to the same project 5 node.
-                GetNodeForProject(graph, 2).ProjectReferences.First().ShouldBe(GetNodeForProject(graph, 3).ProjectReferences.First());
-                GetNodeForProject(graph, 2).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("5.proj");
-                GetNodeForProject(graph, 2).ProjectReferences.First().ProjectInstance.GlobalProperties["FoO"].ShouldBe("bar");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ShouldBe(GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First());
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("5.proj");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.GlobalProperties["FoO"].ShouldBe("bar");
 
                 // Property values are case-sensitive, so project 4 points to a different project 5 node than proejcts 2 and 3
-                GetNodeForProject(graph, 4).ProjectReferences.First().ShouldNotBe(GetNodeForProject(graph, 2).ProjectReferences.First());
-                GetNodeForProject(graph, 4).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("5.proj");
-                GetNodeForProject(graph, 4).ProjectReferences.First().ProjectInstance.GlobalProperties["FoO"].ShouldBe("BAR");
+                GetFirstNodeWithProjectNumber(graph, 4).ProjectReferences.First().ShouldNotBe(GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First());
+                GetFirstNodeWithProjectNumber(graph, 4).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("5.proj");
+                GetFirstNodeWithProjectNumber(graph, 4).ProjectReferences.First().ProjectInstance.GlobalProperties["FoO"].ShouldBe("BAR");
             }
         }
 
@@ -407,9 +426,9 @@ public void ConstructWithMultipleEntryPoints()
                 var projectGraph = new ProjectGraph(new [] { entryProject1.Path, entryProject2.Path });
                 projectGraph.ProjectNodes.Count.ShouldBe(3);
 
-                var node1 = GetNodeForProject(projectGraph, 1);
-                var node2 = GetNodeForProject(projectGraph, 2);
-                var node3 = GetNodeForProject(projectGraph, 3);
+                var node1 = GetFirstNodeWithProjectNumber(projectGraph, 1);
+                var node2 = GetFirstNodeWithProjectNumber(projectGraph, 2);
+                var node3 = GetFirstNodeWithProjectNumber(projectGraph, 3);
                 node1.ProjectReferences.Count.ShouldBe(1);
                 node1.ProjectReferences.First().ShouldBe(node3);
                 node2.ProjectReferences.Count.ShouldBe(1);
@@ -502,7 +521,7 @@ public void ConstructGraphWithDifferentEntryPointsAndGraphRoots()
                 var projectGraph = new ProjectGraph(new[] { entryProject1.Path, entryProject2.Path, entryProject3.Path });
                 projectGraph.EntryPointNodes.Count.ShouldBe(3);
                 projectGraph.GraphRoots.Count.ShouldBe(2);
-                projectGraph.GraphRoots.ShouldNotContain(GetNodeForProject(projectGraph, 2));
+                projectGraph.GraphRoots.ShouldNotContain(GetFirstNodeWithProjectNumber(projectGraph, 2));
             }
         }
 
@@ -521,10 +540,10 @@ public void GetTargetListsAggregatesFromMultipleEdges()
 
                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new[] { "A" });
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { "A" });
-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { "B" });
-                targetLists[GetNodeForProject(projectGraph, 3)].ShouldBe(new[] { "B" });
-                targetLists[GetNodeForProject(projectGraph, 4)].ShouldBe(new[] { "C", "D" }); // From B => C and B => D
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "A" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { "B" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { "B" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 4)].ShouldBe(new[] { "C", "D" }); // From B => C and B => D
             }
         }
 
@@ -549,9 +568,9 @@ public void GetTargetListsDedupesTargets()
 
                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new[] { "A" });
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { "A" });
-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { "B", "X", "C" });
-                targetLists[GetNodeForProject(projectGraph, 3)].ShouldBe(new[] { "X", "Y", "Z" }); // Simplified from X, Y, X, Z
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "A" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { "B", "X", "C" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { "X", "Y", "Z" }); // Simplified from X, Y, X, Z
             }
         }
 
@@ -580,12 +599,12 @@ public void GetTargetListsForComplexGraph()
 
                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(new[] { "A" });
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { "A" });
-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { "B" });
-                targetLists[GetNodeForProject(projectGraph, 3)].ShouldBe(new[] { "B" });
-                targetLists[GetNodeForProject(projectGraph, 4)].ShouldBe(new[] { "C" });
-                targetLists[GetNodeForProject(projectGraph, 5)].ShouldBe(new[] { "B", "C", "D" });
-                targetLists[GetNodeForProject(projectGraph, 6)].ShouldBe(new[] { "C", "D", "E" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "A" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { "B" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { "B" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 4)].ShouldBe(new[] { "C" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 5)].ShouldBe(new[] { "B", "C", "D" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 6)].ShouldBe(new[] { "C", "D", "E" });
             }
         }
 
@@ -602,8 +621,8 @@ public void GetTargetListsNullEntryTargets()
 
                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { "A" });
-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { "B" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "A" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { "B" });
             }
         }
 
@@ -642,8 +661,8 @@ public void GetTargetListsDefaultTargetsAreExpanded()
 
                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { "A" });
-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { "B" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "A" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { "B" });
             }
         }
 
@@ -660,8 +679,8 @@ public void GetTargetListsUnspecifiedTargetsDefaultToBuild()
 
                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { "Build" });
-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { "A", "Build" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "Build" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { "A", "Build" });
             }
         }
 
@@ -677,12 +696,12 @@ public void GetTargetListsDefaultComplexPropagation()
 
             using (var env = TestEnvironment.Create())
             {
-                TransientTestFile entryProject = CreateProjectFile(env, 1, new[] { 2, 3, 4 }, projectReferenceTargets, defaultTargets: null);
-                CreateProjectFile(env, 2, new[] { 5 }, projectReferenceTargets, defaultTargets: null);
+                TransientTestFile entryProject = CreateProjectFile(env, 1, new[] { 2, 3, 4 }, projectReferenceTargets);
+                CreateProjectFile(env, 2, new[] { 5 }, projectReferenceTargets);
                 CreateProjectFile(env, 3, new[] { 6 }, projectReferenceTargets, defaultTargets: "X");
                 CreateProjectFile(env, 4, new[] { 7 }, projectReferenceTargets, defaultTargets: "Y");
-                CreateProjectFile(env, 5, defaultTargets: null);
-                CreateProjectFile(env, 6, defaultTargets: null);
+                CreateProjectFile(env, 5);
+                CreateProjectFile(env, 6);
                 CreateProjectFile(env, 7, defaultTargets: "Z;W");
 
                 var projectGraph = new ProjectGraph(entryProject.Path);
@@ -690,17 +709,17 @@ public void GetTargetListsDefaultComplexPropagation()
 
                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
-                targetLists[GetNodeForProject(projectGraph, 1)].ShouldBe(new[] { "Build" });
-                targetLists[GetNodeForProject(projectGraph, 2)].ShouldBe(new[] { "A", "Build" });
-                targetLists[GetNodeForProject(projectGraph, 3)].ShouldBe(new[] { "A", "X" });
-                targetLists[GetNodeForProject(projectGraph, 4)].ShouldBe(new[] { "A", "Y" });
-                targetLists[GetNodeForProject(projectGraph, 5)].ShouldBe(new[] { "A", "Build" });
-                targetLists[GetNodeForProject(projectGraph, 6)].ShouldBe(new[] { "B", "Build" });
-                targetLists[GetNodeForProject(projectGraph, 7)].ShouldBe(new[] { "C", "Z", "W" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "Build" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { "A", "Build" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { "A", "X" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 4)].ShouldBe(new[] { "A", "Y" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 5)].ShouldBe(new[] { "A", "Build" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 6)].ShouldBe(new[] { "B", "Build" });
+                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 7)].ShouldBe(new[] { "C", "Z", "W" });
             }
         }
 
-        public static IEnumerable<object[]> TopologicalSortShouldTopologicallySortData
+        public static IEnumerable<object[]> Graphs
         {
             get
             {
@@ -844,7 +863,7 @@ public static IEnumerable<object[]> TopologicalSortShouldTopologicallySortData
         }
 
         [Theory]
-        [MemberData(nameof(TopologicalSortShouldTopologicallySortData))]
+        [MemberData(nameof(Graphs))]
         public void TopologicalSortShouldTopologicallySort(Dictionary<int, int[]> edges)
         {
             using (var env = TestEnvironment.Create())
@@ -866,6 +885,353 @@ public void TopologicalSortShouldTopologicallySort(Dictionary<int, int[]> edges)
             }
         }
 
+        [Theory]
+        [MemberData(nameof(Graphs))]
+        public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
+        {
+            var graph = Helpers.CreateProjectGraph(
+                _env,
+                edges,
+                new Dictionary<string, string> {{"a", "b"}});
+
+
+            Func<ProjectGraphNode, string> nodeIdProvider = GetProjectFileName;
+
+            var dot = graph.ToDot(nodeIdProvider);
+
+            var edgeCount = 0;
+
+            foreach (var node in graph.ProjectNodes)
+            {
+                var nodeId = nodeIdProvider(node);
+
+                foreach (var globalProperty in node.ProjectInstance.GlobalProperties)
+                {
+                    dot.ShouldMatch($@"{nodeId}\s*\[.*{globalProperty.Key}.*{globalProperty.Value}.*\]");
+                }
+
+                foreach (var reference in node.ProjectReferences)
+                {
+                    edgeCount++;
+                    dot.ShouldMatch($@"{nodeId}\s*->\s*{nodeIdProvider(reference)}");
+                }
+            }
+
+            // edge count
+            Regex.Matches(dot,"->").Count.ShouldBe(edgeCount);
+
+            // node count
+            Regex.Matches(dot,"label").Count.ShouldBe(graph.ProjectNodes.Count);
+        }
+
+        private static void AssertOuterBuildAsRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)
+        {
+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+
+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
+
+            outerBuild.ReferencingProjects.ShouldBeEmpty();
+            outerBuild.ProjectReferences.Count.ShouldBe(2);
+
+            foreach (var innerBuild in outerBuild.ProjectReferences)
+            {
+                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
+            }
+        }
+
+        private static void AssertOuterBuildAsNonRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null)
+        {
+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+
+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
+
+            outerBuild.ProjectReferences.ShouldBeEmpty();
+            outerBuild.ReferencingProjects.ShouldNotBeEmpty();
+
+            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)
+            {
+                var innerBuilds =
+                    outerBuildReferencer.ProjectReferences.Where(
+                        p =>
+                            IsInnerBuild(p)
+                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();
+
+                innerBuilds.Length.ShouldBe(2);
+
+                foreach (var innerBuild in innerBuilds)
+                {
+                    AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
+                }
+            }
+        }
+
+        private static bool IsOuterBuild(ProjectGraphNode project)
+        {
+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.OuterBuild;
+        }
+
+        private static bool IsInnerBuild(ProjectGraphNode project)
+        {
+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.InnerBuild;
+        }
+
+        private static bool IsNotCrossTargeting(ProjectGraphNode project)
+        {
+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.NonCrossTargeting;
+        }
+
+        private static void AssertNonCrossTargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)
+        {
+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+
+            IsNotCrossTargeting(node).ShouldBeTrue();
+            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
+            node.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();
+        }
+
+        private static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties)
+        {
+            additionalGlobalProperties.ShouldNotBeNull();
+
+            IsOuterBuild(outerBuild).ShouldBeTrue();
+            IsInnerBuild(outerBuild).ShouldBeFalse();
+
+            outerBuild.ProjectInstance.GetProperty(InnerBuildProperty).ShouldBeNull();
+            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
+        }
+
+        private static void AssertInnerBuildEvaluation(
+            ProjectGraphNode innerBuild,
+            bool InnerBuildPropertyIsSetViaGlobalProperty,
+            Dictionary<string, string> additionalGlobalProperties)
+        {
+            additionalGlobalProperties.ShouldNotBeNull();
+
+            IsOuterBuild(innerBuild).ShouldBeFalse();
+            IsInnerBuild(innerBuild).ShouldBeTrue();
+
+            var innerBuildPropertyValue = innerBuild.ProjectInstance.GetPropertyValue(InnerBuildProperty);
+
+            innerBuildPropertyValue.ShouldNotBeNullOrEmpty();
+
+            if (InnerBuildPropertyIsSetViaGlobalProperty)
+            {
+                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(
+                    EmptyGlobalProperties
+                        .Add(InnerBuildProperty, innerBuildPropertyValue)
+                        .AddRange(additionalGlobalProperties));
+            }
+        }
+
+        [Fact]
+        public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
+        {
+            var projectFile = _env.CreateTestProjectWithFiles($@"<Project>{OuterBuildSpecification}</Project>").ProjectFile;
+
+            var graph = new ProjectGraph(projectFile);
+
+            var dot = graph.ToDot();
+
+            graph.ProjectNodes.Count.ShouldBe(3);
+            
+            var outerBuild = graph.GraphRoots.First();
+
+            AssertOuterBuildAsRoot(outerBuild);
+        }
+
+        [Fact]
+        public void ReferenceOfCrosstargetingProjectShouldNotInheritInnerBuildSpecificGlobalProperties()
+        {
+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;
+            CreateProjectFile(_env, 2);
+
+            var graph = new ProjectGraph(root);
+
+            var dot = graph.ToDot();
+
+            graph.ProjectNodes.Count.ShouldBe(4);
+
+            AssertOuterBuildAsRoot(graph.GraphRoots.First());
+
+            var nonCrosstargetingNode = GetFirstNodeWithProjectNumber(graph, 2);
+
+            AssertNonCrossTargetingNode(nonCrosstargetingNode);
+        }
+
+        [Fact]
+        public void InnerBuildAsRootViaLocalPropertyShouldNotPropagateInnerBuildPropertyToReference()
+        {
+            var innerBuildViaLocalProperty = OuterBuildSpecification + $"<PropertyGroup><{InnerBuildProperty}>foo</{InnerBuildProperty}></PropertyGroup>";
+
+            var root = CreateProjectFile(
+                _env,
+                1,
+                new[] {2},
+                null,
+                null,
+                innerBuildViaLocalProperty).Path;
+
+            CreateProjectFile(_env, 2);
+
+            var graph = new ProjectGraph(root);
+
+            var dot = graph.ToDot();
+
+            graph.ProjectNodes.Count.ShouldBe(2);
+
+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), false, new Dictionary<string, string>());
+
+            var nonCrosstargetingNode = GetFirstNodeWithProjectNumber(graph, 2);
+
+            AssertNonCrossTargetingNode(nonCrosstargetingNode);
+        }
+
+        [Fact]
+        public void InnerBuildAsRootViaGlobalPropertyShouldNotPropagateInnerBuildPropertyToReference()
+        {
+            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, OuterBuildSpecification).Path;
+            CreateProjectFile(_env, 2);
+
+            var graph = new ProjectGraph(root, new Dictionary<string, string>{{InnerBuildProperty, "foo"}});
+
+            var dot = graph.ToDot();
+
+            graph.ProjectNodes.Count.ShouldBe(2);
+
+            AssertInnerBuildEvaluation(graph.GraphRoots.First(), true, new Dictionary<string, string>());
+
+            var nonCrosstargetingNode = GetFirstNodeWithProjectNumber(graph, 2);
+
+            AssertNonCrossTargetingNode(nonCrosstargetingNode);
+        }
+
+        [Fact]
+        public void NonOuterBuildProjectsInTheMiddle()
+        {
+            var root = CreateProjectFile(_env, 1, new[] {2, 3}, null, null, OuterBuildSpecification).Path;
+            CreateProjectFile(_env, 2, new[] {4});
+            CreateProjectFile(_env, 3, new[] {4});
+            CreateProjectFile(_env, 4, null, null, null, OuterBuildSpecification);
+
+            var graph = new ProjectGraph(root);
+
+            var dot = graph.ToDot();
+
+            graph.ProjectNodes.Count.ShouldBe(8);
+
+            AssertOuterBuildAsRoot(graph.GraphRoots.First());
+            AssertOuterBuildAsNonRoot(GetNodesWithProjectNumber(graph, 4).First(IsOuterBuild));
+
+            AssertNonCrossTargetingNode(GetFirstNodeWithProjectNumber(graph, 2));
+            AssertNonCrossTargetingNode(GetFirstNodeWithProjectNumber(graph, 3));
+        }
+
+        [Fact]
+        public void InnerBuildsCanHaveSeparateReferences()
+        {
+            var extraInnerBuildReferenceSpec = OuterBuildSpecification +
+                                          $@"<ItemGroup>
+                                                <ProjectReference Condition=`'$({InnerBuildProperty})'=='b'` Include=`4.proj;5.proj`/>
+                                            </ItemGroup>".Cleanup();
+
+            var root = CreateProjectFile(_env, 1, new[] {2, 3}, null, null, extraInnerBuildReferenceSpec).Path;
+            CreateProjectFile(_env, 2, null, null, null, OuterBuildSpecification);
+            CreateProjectFile(_env, 3);
+            CreateProjectFile(_env, 4, null, null, null, OuterBuildSpecification);
+            CreateProjectFile(_env, 5);
+
+            var graph = new ProjectGraph(root);
+
+            var dot = graph.ToDot();
+
+            graph.ProjectNodes.Count.ShouldBe(11);
+
+            AssertOuterBuildAsRoot(graph.GraphRoots.First());
+            AssertOuterBuildAsNonRoot(GetNodesWithProjectNumber(graph, 2).First(IsOuterBuild));
+            AssertOuterBuildAsNonRoot(GetNodesWithProjectNumber(graph, 4).First(IsOuterBuild));
+
+            AssertNonCrossTargetingNode(GetFirstNodeWithProjectNumber(graph, 3));
+            AssertNonCrossTargetingNode(GetFirstNodeWithProjectNumber(graph, 5));
+
+            var innerBuildWithCommonReferences = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GlobalProperties[InnerBuildProperty] == "a");
+
+            innerBuildWithCommonReferences.ProjectReferences.Count.ShouldBe(4);
+            var referenceNumbersSet = innerBuildWithCommonReferences.ProjectReferences.Select(r => Path.GetFileNameWithoutExtension(r.ProjectInstance.FullPath)).ToHashSet();
+            referenceNumbersSet.ShouldBeEquivalentTo(new HashSet<string>{"2", "3"});
+
+            var innerBuildWithAdditionalReferences = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GlobalProperties[InnerBuildProperty] == "b");
+
+            innerBuildWithAdditionalReferences.ProjectReferences.Count.ShouldBe(8);
+            referenceNumbersSet = innerBuildWithAdditionalReferences.ProjectReferences.Select(r => Path.GetFileNameWithoutExtension(r.ProjectInstance.FullPath)).ToHashSet();
+            referenceNumbersSet.ShouldBeEquivalentTo(new HashSet<string>{"2", "3", "4", "5"});
+        }
+
+        [Fact]
+        public void InnerBuildProducedByOuterBuildCanBeReferencedByAnotherNode()
+        {
+            var referenceToInnerBuild = $@"<ItemGroup>
+                                               <ProjectReference Include='1.proj' Properties='{InnerBuildProperty}=a'/>
+                                           </ItemGroup>";
+
+            var additionalGlobalProperties = new Dictionary<string, string>{{"x", "y"}};
+
+            var graph = new ProjectGraph(new []
+            {
+                CreateProjectFile(_env, 1, null, null, null, OuterBuildSpecification).Path,
+                CreateProjectFile(_env, 2, null, null, null, referenceToInnerBuild).Path
+            },
+            additionalGlobalProperties);
+
+            var dot = graph.ToDot();
+
+            graph.ProjectNodes.Count.ShouldBe(4);
+
+            var outerBuild = graph.GraphRoots.First(IsOuterBuild);
+
+            AssertOuterBuildAsRoot(outerBuild, additionalGlobalProperties);
+            AssertNonCrossTargetingNode(GetFirstNodeWithProjectNumber(graph, 2), additionalGlobalProperties);
+
+            var referencedInnerBuild = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GetPropertyValue(InnerBuildProperty) == "a");
+
+            var two = GetFirstNodeWithProjectNumber(graph, 2);
+
+            two.ProjectReferences.ShouldHaveSingleItem();
+            two.ProjectReferences.First().ShouldBe(referencedInnerBuild);
+
+            referencedInnerBuild.ReferencingProjects.ShouldBeEquivalentTo(new []{two, outerBuild});
+        }
+
+        [Fact]
+        public void InnerBuildCanBeReferencedWithoutItsOuterBuild()
+        {
+            var referenceToInnerBuild = $@"<ItemGroup>
+                                               <ProjectReference Include='2.proj' Properties='{InnerBuildProperty}=a'/>
+                                           </ItemGroup>";
+
+            var root = CreateProjectFile(_env, 1, null, null, null, referenceToInnerBuild).Path;
+            CreateProjectFile(_env, 2, new []{3}, null, null, OuterBuildSpecification + $"<PropertyGroup><{InnerBuildProperty}>a</{InnerBuildProperty}></PropertyGroup>");
+            CreateProjectFile(_env, 3);
+
+            var additionalGlobalProperties = new Dictionary<string, string>{{"x", "y"}};
+
+            var graph = new ProjectGraph(root, additionalGlobalProperties);
+
+            var dot = graph.ToDot();
+
+            graph.ProjectNodes.Count.ShouldBe(3);
+
+            var rootNode = graph.GraphRoots.First();
+            AssertNonCrossTargetingNode(rootNode, additionalGlobalProperties);
+
+            rootNode.ProjectReferences.ShouldHaveSingleItem();
+            var innerBuildNode = rootNode.ProjectReferences.First();
+
+            AssertInnerBuildEvaluation(innerBuildNode, false, additionalGlobalProperties);
+
+            innerBuildNode.ProjectReferences.ShouldHaveSingleItem();
+            AssertNonCrossTargetingNode(innerBuildNode.ProjectReferences.First(), additionalGlobalProperties);
+        }
+
         public static IEnumerable<object[]> AllNodesShouldHaveGraphBuildGlobalPropertyData
         {
             get
@@ -955,13 +1321,16 @@ public void AllNodesShouldHaveGraphBuildGlobalProperty(Dictionary<int, int[]> ed
         {
             using (var env = TestEnvironment.Create())
             {
-                var projectGraph = Helpers.CreateProjectGraph(env, edges, null, roots, globalProperties);
+                var projectGraph = Helpers.CreateProjectGraph(env, edges, globalProperties, null, roots);
+
+                var dot = projectGraph.ToDot();
 
-                var expectedGlobalProperties = new Dictionary<string, string>(globalProperties) {[PropertyNames.IsGraphBuild] = "true"};
+                var expectedGlobalProperties = new Dictionary<string, string>(globalProperties);
+                expectedGlobalProperties[PropertyNames.IsGraphBuild] = "true";
 
                 foreach (var node in projectGraph.ProjectNodes)
                 {
-                    Helpers.AssertDictionariesEqual(expectedGlobalProperties, node.ProjectInstance.GlobalProperties.ToDictionary(kvp => kvp.Key, kvp => kvp.Value));
+                    node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(expectedGlobalProperties);
                 }
             }
         }
@@ -974,22 +1343,28 @@ public void UserValuesForIsGraphBuildGlobalPropertyShouldBePreserved()
                 var projectGraph = Helpers.CreateProjectGraph(
                     env,
                     new Dictionary<int, int[]> {{1, null}},
-                    null,
-                    null,
                     new Dictionary<string, string> {{PropertyNames.IsGraphBuild, "xyz"}});
 
                 projectGraph.ProjectNodes.First().ProjectInstance.GlobalProperties[PropertyNames.IsGraphBuild].ShouldBe("xyz");
             }
         }
 
-        private static ProjectGraphNode GetNodeForProject(ProjectGraph graph, int projectNum) => graph.ProjectNodes.First(node => node.ProjectInstance.FullPath.EndsWith(projectNum + ".proj"));
+        private static ProjectGraphNode GetFirstNodeWithProjectNumber(ProjectGraph graph, int projectNum) => GetNodesWithProjectNumber(graph, projectNum).First();
+
+        private static IEnumerable<ProjectGraphNode> GetNodesWithProjectNumber(ProjectGraph graph, int projectNum)
+        {
+            return graph.ProjectNodes.Where(node => node.ProjectInstance.FullPath.EndsWith(projectNum + ".proj"));
+        }
+
+        private static string GetProjectFileName(ProjectGraphNode node) => Path.GetFileNameWithoutExtension(node.ProjectInstance.FullPath);
 
         internal static TransientTestFile CreateProjectFile(
             TestEnvironment env,
             int projectNumber,
             int[] projectReferences = null,
             Dictionary<string, string[]> projectReferenceTargets = null,
-            string defaultTargets = null
+            string defaultTargets = null,
+            string extraContent = null
             )
         {
             return Helpers.CreateProjectFile(
@@ -999,8 +1374,12 @@ internal static TransientTestFile CreateProjectFile(
                 projectReferenceTargets,
                 // Use "Build" when the default target is unspecified since in practice that is usually the default target.
                 defaultTargets ?? "Build",
-                null);
+                extraContent);
         }
-    }
 
+        public void Dispose()
+        {
+            _env.Dispose();
+        }
+    }
 }
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index e914e2c67a6..aa7e986c366 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -287,6 +287,7 @@ public void BuildProjectGraphUsingCaches(Dictionary<int, int[]> edges)
                 CreateProjectGraph(
                     _env,
                     edges,
+                    null,
                     CreateProjectFileWrapper)
                     .ProjectNodesTopologicallySorted.ToArray();
 
@@ -369,6 +370,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
                 CreateProjectGraph(
                     _env,
                     new Dictionary<int, int[]> { { 1, new[] { 2, 3 } } },
+                    null,
                     CreateProjectFileWrapper)
                     .ProjectNodesTopologicallySorted.ToArray();
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index d586f4fb5c8..d9639592e03 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -542,12 +542,16 @@ internal static async Task<bool> ExecuteTargets(
 
                     // If the user specified a different set of global properties for this project, then
                     // parse the string containing the properties
-                    if (!String.IsNullOrEmpty(projects[i].GetMetadata("Properties")))
+                    if (!String.IsNullOrEmpty(projects[i].GetMetadata(ItemMetadataNames.PropertiesMetadataName)))
                     {
                         if (!PropertyParser.GetTableWithEscaping
-                             (log, ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("General.OverridingProperties", projectNames[i]), "Properties", projects[i].GetMetadata("Properties").Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries),
-                              out Dictionary<string, string> preProjectPropertiesTable)
-                           )
+                            (
+                                log,
+                                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("General.OverridingProperties", projectNames[i]),
+                                ItemMetadataNames.PropertiesMetadataName,
+                                projects[i].GetMetadata(ItemMetadataNames.PropertiesMetadataName).Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries),
+                                out Dictionary<string, string> preProjectPropertiesTable)
+                            )
                         {
                             return false;
                         }
@@ -562,7 +566,7 @@ internal static async Task<bool> ExecuteTargets(
 
                     // If the user wanted to undefine specific global properties for this project, parse
                     // that string and remove them now.
-                    string projectUndefineProperties = projects[i].GetMetadata("UndefineProperties");
+                    string projectUndefineProperties = projects[i].GetMetadata(ItemMetadataNames.UndefinePropertiesMetadataName);
                     if (!String.IsNullOrEmpty(projectUndefineProperties))
                     {
                         string[] propertiesToUndefine = projectUndefineProperties.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
@@ -584,11 +588,15 @@ internal static async Task<bool> ExecuteTargets(
 
                     // If the user specified a different set of global properties for this project, then
                     // parse the string containing the properties
-                    if (!String.IsNullOrEmpty(projects[i].GetMetadata("AdditionalProperties")))
+                    if (!String.IsNullOrEmpty(projects[i].GetMetadata(ItemMetadataNames.AdditionalPropertiesMetadataName)))
                     {
                         if (!PropertyParser.GetTableWithEscaping
-                             (log, ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("General.AdditionalProperties", projectNames[i]), "AdditionalProperties", projects[i].GetMetadata("AdditionalProperties").Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries),
-                              out Dictionary<string, string> additionalProjectPropertiesTable)
+                            (
+                                log,
+                                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("General.AdditionalProperties", projectNames[i]),
+                                ItemMetadataNames.AdditionalPropertiesMetadataName,
+                                projects[i].GetMetadata(ItemMetadataNames.AdditionalPropertiesMetadataName).Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries),
+                                out Dictionary<string, string> additionalProjectPropertiesTable)
                            )
                         {
                             return false;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index d831555ce1e..a723a42f166 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -995,7 +995,7 @@ private List<string> GetUndeclaredProjects(MSBuild msbuildTask)
                 return null;
             }
 
-            var projectReferenceItems = _taskExecutionHost.ProjectInstance.GetItems(ItemTypeNames.ProjectReferenceItemName);
+            var projectReferenceItems = _taskExecutionHost.ProjectInstance.GetItems(ItemTypeNames.ProjectReference);
 
             var declaredProjects = new HashSet<string>(projectReferenceItems.Count);
 
diff --git a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
index d2cfed04af7..2b127aba893 100644
--- a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
+++ b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
@@ -36,7 +36,7 @@ public ConfigurationMetadata(Project project)
             _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(project.GlobalProperties.Count);
             foreach (KeyValuePair<string, string> entry in project.GlobalProperties)
             {
-                GlobalProperties[entry.Key] = ProjectPropertyInstance.Create(entry.Key, entry.Value);
+                _globalProperties[entry.Key] = ProjectPropertyInstance.Create(entry.Key, entry.Value);
             }
 
             _toolsVersion = project.ToolsVersion;
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index 4d43f3977a2..007abda8be4 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -2,10 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Collections.Concurrent;
 using System.Globalization;
+using System.IO;
 using System.Linq;
 using System.Text;
 using System.Threading;
@@ -24,21 +26,6 @@ namespace Microsoft.Build.Experimental.Graph
     /// </summary>
     public sealed class ProjectGraph
     {
-        private const string FullPathMetadataName = "FullPath";
-        private const string ToolsVersionMetadataName = "ToolsVersion";
-        private const string PropertiesMetadataName = "Properties";
-        private const string UndefinePropertiesMetadataName = "UndefineProperties";
-        private const string AdditionalPropertiesMetadataName = "AdditionalProperties";
-        private const string SetConfigurationMetadataName = "SetConfiguration";
-        private const string SetPlatformMetadataName = "SetPlatform";
-        private const string SetTargetFrameworkMetadataName = "SetTargetFramework";
-        private const string GlobalPropertiesToRemoveMetadataName = "GlobalPropertiesToRemove";
-
-        private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
-
-        private readonly ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> _allParsedProjects =
-            new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();
-
         /// <summary>
         /// Constructs a graph starting from the given project file, evaluating with the global project collection and no global properties.
         /// </summary>
@@ -200,10 +187,10 @@ public ProjectGraph(
 
             projectInstanceFactory = projectInstanceFactory ?? DefaultProjectInstanceFactory;
 
-            var nodeStates = new Dictionary<ProjectGraphNode, NodeState>();
-            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();
-            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();
+            var sdkInfo = ProjectInterpretation.Instance;
+
             var entryPointConfigurationMetadata = new List<ConfigurationMetadata>();
+
             foreach (var entryPoint in entryPoints)
             {
                 var globalPropertyDictionary = CreatePropertyDictionary(entryPoint.GlobalProperties);
@@ -211,36 +198,68 @@ public ProjectGraph(
                 AddGraphBuildGlobalVariable(globalPropertyDictionary);
 
                 var configurationMetadata = new ConfigurationMetadata(FileUtilities.NormalizePath(entryPoint.ProjectFile), globalPropertyDictionary);
-                projectsToEvaluate.Enqueue(configurationMetadata);
                 entryPointConfigurationMetadata.Add(configurationMetadata);
             }
 
+            var (entryPointNodes, rootNodes, allNodes) = LoadGraph(entryPointConfigurationMetadata, projectCollection, projectInstanceFactory, sdkInfo);
+
+            EntryPointNodes = entryPointNodes;
+            GraphRoots = rootNodes;
+            ProjectNodes = allNodes;
+
+            _projectNodesTopologicallySorted = new Lazy<IReadOnlyCollection<ProjectGraphNode>>(() => TopologicalSort(GraphRoots, ProjectNodes));
+            
+            void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> globalPropertyDictionary)
+            {
+                if (globalPropertyDictionary.GetProperty(PropertyNames.IsGraphBuild) == null)
+                {
+                    globalPropertyDictionary[PropertyNames.IsGraphBuild] = ProjectPropertyInstance.Create(PropertyNames.IsGraphBuild, "true");
+                }
+            }
+        }
+
+        private
+            (IReadOnlyCollection<ProjectGraphNode> EntryPointNodes, IReadOnlyCollection<ProjectGraphNode> RootNodes, IReadOnlyCollection<ProjectGraphNode> AllNodes) LoadGraph(
+            List<ConfigurationMetadata> entryPointConfigurationMetadata,
+            ProjectCollection projectCollection,
+            ProjectInstanceFactoryFunc projectInstanceFactory,
+            ProjectInterpretation sdkInfo)
+        {
+            var allParsedProjects = new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();
+            var tasksInProgress = new ConcurrentDictionary<ConfigurationMetadata, object>();
+            var projectsToEvaluate = new ConcurrentQueue<ConfigurationMetadata>();
+
+            foreach (var entryPoint in entryPointConfigurationMetadata)
+            {
+                projectsToEvaluate.Enqueue(entryPoint);
+            }
+
             if (FindGraphNodes(
                 projectsToEvaluate,
                 projectCollection,
                 tasksInProgress,
                 projectInstanceFactory,
+                sdkInfo,
+                allParsedProjects,
                 out var exceptions))
             {
-                var entryPointNodes = new List<ProjectGraphNode>(entryPointConfigurationMetadata.Count);
+                var entryPointNodes = entryPointConfigurationMetadata.Select(e => allParsedProjects[e]).ToList();
 
-                foreach (var entrypointConfig in entryPointConfigurationMetadata)
-                {
-                    var entryPointNode = _allParsedProjects[entrypointConfig];
-                    entryPointNodes.Add(entryPointNode);
+                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, sdkInfo, allParsedProjects);
 
-                    if (!nodeStates.ContainsKey(entryPointNode))
-                    {
-                        CreateEdgesAndDetectCycles(entryPointNode, nodeStates);
-                    }
-                    else
-                    {
-                        ErrorUtilities.VerifyThrow(
-                            nodeStates[entryPointNode] == NodeState.Processed,
-                            "entrypoints should get processed after a call to detect cycles");
-                    }
-                }
+                var graphRoots = GetGraphRoots(entryPointNodes);
+
+                ProjectInterpretation.PostProcess(allParsedProjects);
+
+                return (entryPointNodes.AsReadOnly(), graphRoots.AsReadOnly(), allParsedProjects.Values.ToList());
+            }
+            else
+            {
+                throw new AggregateException(exceptions);
+            }
 
+            List<ProjectGraphNode> GetGraphRoots(List<ProjectGraphNode> entryPointNodes)
+            {
                 var graphRoots = new List<ProjectGraphNode>(entryPointNodes.Count);
                 foreach (var entryPointNode in entryPointNodes)
                 {
@@ -249,24 +268,104 @@ public ProjectGraph(
                         graphRoots.Add(entryPointNode);
                     }
                 }
+                return graphRoots;
+            }
+        }
 
-                EntryPointNodes = entryPointNodes.AsReadOnly();
-                ProjectNodes = _allParsedProjects.Values.ToList();
-                GraphRoots = graphRoots.AsReadOnly();
+        /// <remarks>
+        ///     Traverse the found nodes and add edges.
+        ///     Maintain the state of each node (InProcess and Processed) to detect cycles.
+        ///     Returns false if cycles were detected.
+        /// </remarks>
+        private void CreateEdgesAndDetectCycles(
+            List<ConfigurationMetadata> entryPointConfigurationMetadata,
+            ProjectInterpretation sdkInfo,
+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects)
+        {
+            var nodeStates = new Dictionary<ProjectGraphNode, NodeVisitationState>();
 
-                _projectNodesTopologicallySorted = new Lazy<IReadOnlyCollection<ProjectGraphNode>>(() => TopologicalSort(GraphRoots, ProjectNodes));
-            }
-            else
+            foreach (var entrypointConfig in entryPointConfigurationMetadata)
             {
-                throw new AggregateException(exceptions);
+                var entryPointNode = allParsedProjects[entrypointConfig];
+
+                if (!nodeStates.ContainsKey(entryPointNode))
+                {
+                    CreateEdgesAndDetectCyclesForRoot(entryPointNode, entrypointConfig, nodeStates);
+                }
+                else
+                {
+                    ErrorUtilities.VerifyThrow(
+                        nodeStates[entryPointNode] == NodeVisitationState.Processed,
+                        "entrypoints should get processed after a call to detect cycles");
+                }
             }
-            
-            void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> globalPropertyDictionary)
+
+            return;
+
+            (bool success, List<string> projectsInCycle) CreateEdgesAndDetectCyclesForRoot(
+                ProjectGraphNode node,
+                ConfigurationMetadata nodeConfig,
+                IDictionary<ProjectGraphNode, NodeVisitationState> nodeState)
             {
-                if (globalPropertyDictionary.GetProperty(PropertyNames.IsGraphBuild) == null)
+                nodeState[node] = NodeVisitationState.InProcess;
+
+                foreach (var referenceConfig in sdkInfo.GetReferences(node.ProjectInstance))
                 {
-                    globalPropertyDictionary[PropertyNames.IsGraphBuild] = ProjectPropertyInstance.Create(PropertyNames.IsGraphBuild, "true");
+                    var referenceNode = allParsedProjects[referenceConfig];
+
+                    if (nodeState.TryGetValue(referenceNode, out var projectReferenceNodeState))
+                    {
+                        // Because this is a depth-first search, we should only encounter new nodes or nodes whose subgraph has been completely processed.
+                        // If we encounter a node that is currently being processed(InProcess state), it must be one of the ancestors in a circular dependency.
+                        if (projectReferenceNodeState == NodeVisitationState.InProcess)
+                        {
+                            if (node.Equals(referenceNode))
+                            {
+                                // the project being evaluated has a reference to itself
+                                var selfReferencingProjectString =
+                                    FormatCircularDependencyError(new List<string> {node.ProjectInstance.FullPath, node.ProjectInstance.FullPath});
+                                throw new CircularDependencyException(
+                                    string.Format(
+                                        ResourceUtilities.GetResourceString("CircularDependencyInProjectGraph"),
+                                        selfReferencingProjectString));
+                            }
+                            // the project being evaluated has a circular dependency involving multiple projects
+                            // add this project to the list of projects involved in cycle 
+                            var projectsInCycle = new List<string> {referenceConfig.ProjectFullPath};
+                            return (false, projectsInCycle);
+                        }
+                    }
+                    else
+                    {
+                        // recursively process newly discovered references
+                        var loadReference = CreateEdgesAndDetectCyclesForRoot(referenceNode, referenceConfig, nodeState);
+                        if (!loadReference.success)
+                        {
+                            if (loadReference.projectsInCycle[0].Equals(node.ProjectInstance.FullPath))
+                            {
+                                // we have reached the nth project in the cycle, form error message and throw
+                                loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);
+                                loadReference.projectsInCycle.Add(node.ProjectInstance.FullPath);
+                                var errorMessage = FormatCircularDependencyError(loadReference.projectsInCycle);
+                                throw new CircularDependencyException(
+                                    string.Format(
+                                        ResourceUtilities.GetResourceString("CircularDependencyInProjectGraph"),
+                                        errorMessage));
+                            }
+                            // this is one of the projects in the circular dependency
+                            // update the list of projects in cycle and return the list to the caller
+                            loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);
+                            return (false, loadReference.projectsInCycle);
+                        }
+                    }
+
+                    var parsedProjectReference = allParsedProjects[referenceConfig];
+                    node.AddProjectReference(parsedProjectReference);
+                    parsedProjectReference.AddReferencingProject(node);
                 }
+
+                nodeState[node] = NodeVisitationState.Processed;
+                return (true, null);
             }
         }
 
@@ -280,6 +379,44 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo
         /// </summary>
         public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; }
 
+        internal string ToDot()
+        {
+            var nodeCount = 0;
+            return ToDot(node => nodeCount++.ToString());
+        }
+
+        internal string ToDot(Func<ProjectGraphNode, string> nodeIdProvider)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(nodeIdProvider, nameof(nodeIdProvider));
+
+            var nodeIds = new ConcurrentDictionary<ProjectGraphNode, string>();
+
+            var sb = new StringBuilder();
+
+            sb.Append("digraph g\n{\n\tnode [shape=box]\n");
+
+            foreach (var node in ProjectNodes)
+            {
+                var nodeId = nodeIds.GetOrAdd(node, (n, idProvider) => idProvider(n), nodeIdProvider);
+
+                var nodeName = Path.GetFileNameWithoutExtension(node.ProjectInstance.FullPath);
+                var globalPropertiesString = string.Join("<br/>", node.ProjectInstance.GlobalProperties.OrderBy(kvp => kvp.Key).Select(kvp => $"{kvp.Key}={kvp.Value}"));
+
+                sb.AppendLine($"\t{nodeId} [label=<{nodeName}<br/>{globalPropertiesString}>]");
+
+                foreach (var reference in node.ProjectReferences)
+                {
+                    var referenceId = nodeIds.GetOrAdd(reference, (n, idProvider) => idProvider(n), nodeIdProvider);
+
+                    sb.AppendLine($"\t{nodeId} -> {referenceId}");
+                }
+            }
+
+            sb.Append("}");
+
+            return sb.ToString();
+        }
+
         private readonly Lazy<IReadOnlyCollection<ProjectGraphNode>> _projectNodesTopologicallySorted;
 
         private static IReadOnlyCollection<ProjectGraphNode> TopologicalSort(IReadOnlyCollection<ProjectGraphNode> graphRoots, IReadOnlyCollection<ProjectGraphNode> graphNodes)
@@ -486,7 +623,8 @@ internal static ProjectInstance DefaultProjectInstanceFactory(
         private ProjectGraphNode CreateNewNode(
             ConfigurationMetadata configurationMetadata,
             ProjectCollection projectCollection,
-            ProjectInstanceFactoryFunc projectInstanceFactory)
+            ProjectInstanceFactoryFunc projectInstanceFactory,
+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects)
         {
             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.
             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();
@@ -502,7 +640,7 @@ private ProjectGraphNode CreateNewNode(
 
             var graphNode = new ProjectGraphNode(
                 projectInstance);
-            _allParsedProjects[configurationMetadata] = graphNode;
+            allParsedProjects[configurationMetadata] = graphNode;
             return graphNode;
         }
 
@@ -516,6 +654,8 @@ private bool FindGraphNodes(
             ProjectCollection projectCollection,
             ConcurrentDictionary<ConfigurationMetadata, object> tasksInProgress,
             ProjectInstanceFactoryFunc projectInstanceFactory,
+            ProjectInterpretation sdkInfo,
+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects,
             out List<Exception> exceptions)
         {
             var exceptionsInTasks = new ConcurrentBag<Exception>();
@@ -529,9 +669,9 @@ private bool FindGraphNodes(
                     projectToEvaluate = projectsToEvaluate.Dequeue();
                     var task = new Task(() =>
                     {
-                        var parsedProject = CreateNewNode(projectToEvaluate, projectCollection, projectInstanceFactory);
+                        var parsedProject = CreateNewNode(projectToEvaluate, projectCollection, projectInstanceFactory, allParsedProjects);
 
-                        foreach (var referenceConfig in GetReferenceConfigs(parsedProject.ProjectInstance))
+                        foreach (var referenceConfig in sdkInfo.GetReferences(parsedProject.ProjectInstance))
                         {
                              /*todo: fix the following double check-then-act concurrency bug: one thread can pass the two checks, loose context,
                              meanwhile another thread passes the same checks with the same data and inserts its reference. The initial thread regains context
@@ -539,7 +679,7 @@ meanwhile another thread passes the same checks with the same data and inserts i
                              */
                             if (!tasksInProgress.ContainsKey(referenceConfig))
                             {
-                                if (!_allParsedProjects.ContainsKey(referenceConfig))
+                                if (!allParsedProjects.ContainsKey(referenceConfig))
                                 {
                                     projectsToEvaluate.Enqueue(referenceConfig);
                                     evaluationWaitHandle.Set();
@@ -582,32 +722,7 @@ meanwhile another thread passes the same checks with the same data and inserts i
             return true;
         }
 
-        private static IEnumerable<ConfigurationMetadata> GetReferenceConfigs(ProjectInstance requesterInstance)
-        {
-            IEnumerable<ProjectItemInstance> projectReferenceItems = requesterInstance.GetItems(ItemTypeNames.ProjectReferenceItemName);
-            foreach (var projectReferenceToParse in projectReferenceItems)
-            {
-                if (!string.IsNullOrEmpty(projectReferenceToParse.GetMetadataValue(ToolsVersionMetadataName)))
-                {
-                    throw new InvalidOperationException(
-                        string.Format(
-                            CultureInfo.InvariantCulture,
-                            ResourceUtilities.GetResourceString(
-                                "ProjectGraphDoesNotSupportProjectReferenceWithToolset"),
-                            projectReferenceToParse.EvaluatedInclude,
-                            requesterInstance.FullPath));
-                }
-
-                var projectReferenceFullPath = projectReferenceToParse.GetMetadataValue(FullPathMetadataName);
-
-                var projectReferenceGlobalProperties =
-                    GetProjectReferenceGlobalProperties(projectReferenceToParse, requesterInstance.GlobalPropertiesDictionary);
-
-                yield return new ConfigurationMetadata(projectReferenceFullPath, projectReferenceGlobalProperties);
-            }
-        }
-
-        private enum NodeState
+        private enum NodeVisitationState
         {
             // the project has been evaluated and its project references are being processed
             InProcess,
@@ -615,79 +730,6 @@ private enum NodeState
             Processed
         }
 
-        /// <remarks>
-        /// Traverse the found nodes and add edges.
-        /// Maintain the state of each node (InProcess and Processed) to detect cycles.
-        /// Returns false if cycles were detected.
-        /// </remarks>
-        private (bool success, List<string> projectsInCycle) CreateEdgesAndDetectCycles(
-            ProjectGraphNode node,
-            Dictionary<ProjectGraphNode, NodeState> nodeState)
-        {
-            nodeState[node] = NodeState.InProcess;
-
-            foreach (var referenceConfig in GetReferenceConfigs(node.ProjectInstance))
-            {
-                var referenceNode = _allParsedProjects[referenceConfig];
-
-                if (nodeState.TryGetValue(referenceNode, out var projectReferenceNodeState))
-                {
-                    // Because this is a depth-first search, we should only encounter new nodes or nodes whose subgraph has been completely processed.
-                    // If we encounter a node that is currently being processed(InProcess state), it must be one of the ancestors in a circular dependency.
-                    if (projectReferenceNodeState == NodeState.InProcess)
-                    {
-                        if (node.Equals(referenceNode))
-                        {
-                            // the project being evaluated has a reference to itself
-                            var selfReferencingProjectString = FormatCircularDependencyError(new List<string> { node.ProjectInstance.FullPath, node.ProjectInstance.FullPath });
-                            throw new CircularDependencyException(string.Format(
-                                ResourceUtilities.GetResourceString("CircularDependencyInProjectGraph"),
-                                selfReferencingProjectString));
-                        }
-                        else
-                        {
-                            // the project being evaluated has a circular dependency involving multiple projects
-                            // add this project to the list of projects involved in cycle 
-                            var projectsInCycle = new List<string> { referenceConfig.ProjectFullPath };
-                            return (false, projectsInCycle);
-                        }
-                    }
-                }
-                else
-                {
-                    // recursively process newly discovered references
-                    var loadReference = CreateEdgesAndDetectCycles(referenceNode, nodeState);
-                    if (!loadReference.success)
-                    {
-                        if (loadReference.projectsInCycle[0].Equals(node.ProjectInstance.FullPath))
-                        {
-                            // we have reached the nth project in the cycle, form error message and throw
-                            loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);
-                            loadReference.projectsInCycle.Add(node.ProjectInstance.FullPath);
-                            var errorMessage = FormatCircularDependencyError(loadReference.projectsInCycle);
-                            throw new CircularDependencyException(string.Format(
-                                ResourceUtilities.GetResourceString("CircularDependencyInProjectGraph"),
-                                errorMessage));
-                        }
-                        else
-                        {
-                            // this is one of the projects in the circular dependency
-                            // update the list of projects in cycle and return the list to the caller
-                            loadReference.projectsInCycle.Add(referenceConfig.ProjectFullPath);
-                            return (false, loadReference.projectsInCycle);
-                        }
-                    }
-                }
-
-                var parsedProjectReference = _allParsedProjects[referenceConfig];
-                node.AddProjectReference(parsedProjectReference);
-                parsedProjectReference.AddReferencingProject(node);
-            }
-
-            nodeState[node] = NodeState.Processed;
-            return (true, null);
-        }
-
         internal static string FormatCircularDependencyError(List<string> projectsInCycle)
         {
             const int MAX_PATH = 260;
@@ -711,7 +753,7 @@ internal static string FormatCircularDependencyError(List<string> projectsInCycl
         private static ImmutableList<string> DetermineTargetsToPropagate(ProjectGraphNode node, ImmutableList<string> entryTargets)
         {
             var targetsToPropagate = ImmutableList<string>.Empty;
-            var projectReferenceTargets = node.ProjectInstance.GetItems(ItemTypeNames.ProjectReferenceTargetsItemType);
+            var projectReferenceTargets = node.ProjectInstance.GetItems(ItemTypeNames.ProjectReferenceTargets);
             foreach (var entryTarget in entryTargets)
             {
                 foreach (var projectReferenceTarget in projectReferenceTargets)
@@ -727,54 +769,6 @@ private static ImmutableList<string> DetermineTargetsToPropagate(ProjectGraphNod
             return targetsToPropagate;
         }
 
-        /// <summary>
-        /// Gets the effective global properties for a project reference.
-        /// </summary>
-        /// <remarks>
-        /// The behavior of this method should match the logic in Microsoft.Common.CurrentVersion.targets and the MSBuild task.
-        /// </remarks>
-        private static PropertyDictionary<ProjectPropertyInstance> GetProjectReferenceGlobalProperties(ProjectItemInstance projectReference, PropertyDictionary<ProjectPropertyInstance> requesterGlobalProperties)
-        {
-            var propertiesString = projectReference.GetMetadataValue(PropertiesMetadataName);
-            var additionalPropertiesString = projectReference.GetMetadataValue(AdditionalPropertiesMetadataName);
-            var undefinePropertiesString = projectReference.GetMetadataValue(UndefinePropertiesMetadataName);
-            var globalPropertiesToRemoveString = projectReference.GetMetadataValue(GlobalPropertiesToRemoveMetadataName);
-
-            // The properties on the project reference supersede the ones from the MSBuild task instad of appending.
-            if (string.IsNullOrEmpty(propertiesString))
-            {
-                // TODO: Mimic AssignProjectConfiguration's behavior for determining the values for these.
-                var setConfigurationString = projectReference.GetMetadataValue(SetConfigurationMetadataName);
-                var setPlatformString = projectReference.GetMetadataValue(SetPlatformMetadataName);
-                var setTargetFrameworkString = projectReference.GetMetadataValue(SetTargetFrameworkMetadataName);
-
-                if (!string.IsNullOrEmpty(setConfigurationString) || !string.IsNullOrEmpty(setPlatformString) || !string.IsNullOrEmpty(setTargetFrameworkString))
-                {
-                    propertiesString = $"{setConfigurationString};{setPlatformString};{setTargetFrameworkString}";
-                }
-            }
-
-            // If none of these are set, we can just reuse the requestor's global properties directly.
-            if (string.IsNullOrEmpty(propertiesString)
-                && string.IsNullOrEmpty(additionalPropertiesString)
-                && string.IsNullOrEmpty(undefinePropertiesString)
-                && string.IsNullOrEmpty(globalPropertiesToRemoveString))
-            {
-                return requesterGlobalProperties;
-            }
-
-            // Make a copy to avoid mutating the requester
-            var globalProperties = new PropertyDictionary<ProjectPropertyInstance>(requesterGlobalProperties);
-
-            // Append and remove properties as specified by the various metadata
-            MergeIntoPropertyDictionary(globalProperties, propertiesString, PropertiesMetadataName);
-            MergeIntoPropertyDictionary(globalProperties, additionalPropertiesString, AdditionalPropertiesMetadataName);
-            RemoveFromPropertyDictionary(globalProperties, globalPropertiesToRemoveString);
-            RemoveFromPropertyDictionary(globalProperties, undefinePropertiesString);
-
-            return globalProperties;
-        }
-
         private static PropertyDictionary<ProjectPropertyInstance> CreatePropertyDictionary(IDictionary<string, string> properties)
         {
             PropertyDictionary<ProjectPropertyInstance> propertyDictionary;
@@ -794,50 +788,6 @@ private static PropertyDictionary<ProjectPropertyInstance> CreatePropertyDiction
             return propertyDictionary;
         }
 
-        private static void MergeIntoPropertyDictionary(
-            PropertyDictionary<ProjectPropertyInstance> properties,
-            string propertyNameAndValuesString,
-            string syntaxName)
-        {
-            if (!string.IsNullOrEmpty(propertyNameAndValuesString))
-            {
-                if (PropertyParser.GetTableWithEscaping(
-                    null,
-                    null,
-                    null,
-                    propertyNameAndValuesString.Split(PropertySeparator, StringSplitOptions.RemoveEmptyEntries),
-                    out var propertiesTable))
-                {
-                    foreach (var pair in propertiesTable)
-                    {
-                        properties[pair.Key] = ProjectPropertyInstance.Create(pair.Key, pair.Value);
-                    }
-                }
-                else
-                {
-                    throw new InvalidProjectFileException(string.Format(
-                        CultureInfo.InvariantCulture,
-                        ResourceUtilities.GetResourceString("General.InvalidPropertyError"),
-                        syntaxName,
-                        propertyNameAndValuesString));
-                }
-            }
-        }
-
-        private static void RemoveFromPropertyDictionary(
-            PropertyDictionary<ProjectPropertyInstance> properties,
-            string propertyNamesString)
-        {
-            if (!string.IsNullOrEmpty(propertyNamesString))
-            {
-                var propertiesToRemove = propertyNamesString.Split(PropertySeparator, StringSplitOptions.RemoveEmptyEntries);
-                foreach (var propertyName in propertiesToRemove)
-                {
-                    properties.Remove(propertyName);
-                }
-            }
-        }
-
         private struct ProjectGraphBuildRequest : IEquatable<ProjectGraphBuildRequest>
         {
             public ProjectGraphBuildRequest(ProjectGraphNode node, ImmutableList<string> targets)
diff --git a/src/Build/Graph/ProjectGraphNode.cs b/src/Build/Graph/ProjectGraphNode.cs
index b283aa8e39e..eeab5860a50 100644
--- a/src/Build/Graph/ProjectGraphNode.cs
+++ b/src/Build/Graph/ProjectGraphNode.cs
@@ -37,6 +37,10 @@ internal ProjectGraphNode(ProjectInstance projectInstance)
 
         internal void AddProjectReference(ProjectGraphNode projectGraphNode) => _projectReferences.Add(projectGraphNode);
 
+        internal void RemoveReferences() => _projectReferences.Clear();
+
+        internal void RemoveProjectReference(ProjectGraphNode projectGraphNode) => _projectReferences.Remove(projectGraphNode);
+
         internal void AddReferencingProject(ProjectGraphNode projectGraphNode) => _referencingProjects.Add(projectGraphNode);
     }
 }
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
new file mode 100644
index 00000000000..4737f98718a
--- /dev/null
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -0,0 +1,327 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Globalization;
+using System.Linq;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.Graph
+{
+    internal sealed class ProjectInterpretation
+    {
+        private const string FullPathMetadataName = "FullPath";
+        private const string ToolsVersionMetadataName = "ToolsVersion";
+        private const string SetConfigurationMetadataName = "SetConfiguration";
+        private const string SetPlatformMetadataName = "SetPlatform";
+        private const string SetTargetFrameworkMetadataName = "SetTargetFramework";
+        private const string GlobalPropertiesToRemoveMetadataName = "GlobalPropertiesToRemove";
+        private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
+
+        public static ProjectInterpretation Instance = new ProjectInterpretation();
+
+        private ProjectInterpretation()
+        {
+        }
+
+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonCrosstargetingNodes = new[] {(GlobalPropertiesModifier) ProjectReferenceGlobalPropertiesModifier}.ToImmutableList();
+
+        internal enum ProjectType
+        {
+            OuterBuild, InnerBuild, NonCrossTargeting
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="requesterConfig"></param>
+        /// <param name="requesterInstance"></param>
+        /// <returns></returns>
+        public IEnumerable<ConfigurationMetadata> GetReferences(ProjectInstance requesterInstance)
+        {
+            IEnumerable<ProjectItemInstance> references;
+            IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;
+
+            switch (GetProjectType(requesterInstance))
+            {
+                case ProjectType.OuterBuild:
+                    references = GetInnerBuildReferences(requesterInstance);
+                    break;
+                case ProjectType.InnerBuild:
+                    globalPropertiesModifiers = ModifierForNonCrosstargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));
+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);
+                    break;
+                case ProjectType.NonCrossTargeting:
+                    globalPropertiesModifiers = ModifierForNonCrosstargetingNodes;
+                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);
+                    break;
+                default:
+                    throw new ArgumentOutOfRangeException();
+            }
+
+            foreach (var projectReference in references)
+            {
+                if (!string.IsNullOrEmpty(projectReference.GetMetadataValue(ToolsVersionMetadataName)))
+                {
+                    throw new InvalidOperationException(
+                        string.Format(
+                            CultureInfo.InvariantCulture,
+                            ResourceUtilities.GetResourceString(
+                                "ProjectGraphDoesNotSupportProjectReferenceWithToolset"),
+                            projectReference.EvaluatedInclude,
+                            requesterInstance.FullPath));
+                }
+
+                var projectReferenceFullPath = projectReference.GetMetadataValue(FullPathMetadataName);
+
+                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReference, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);
+
+                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);
+
+                yield return referenceConfig;
+            }
+        }
+
+        private static string GetInnerBuildPropertyValue(ProjectInstance project)
+        {
+            return project.GetPropertyValue(GetInnerBuildPropertyName(project));
+        }
+
+        private static string GetInnerBuildPropertyName(ProjectInstance project)
+        {
+            return project.GetPropertyValue(PropertyNames.InnerBuildProperty);
+        }
+
+        private static string GetInnerBuildPropertyValues(ProjectInstance project)
+        {
+            return project.GetPropertyValue(project.GetPropertyValue(PropertyNames.InnerBuildPropertyValues));
+        }
+
+        internal static ProjectType GetProjectType(ProjectInstance project)
+        {
+            var isOuterBuild = string.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project)) && !string.IsNullOrWhiteSpace(GetInnerBuildPropertyValues(project));
+            var isInnerBuild = !string.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project));
+
+            ErrorUtilities.VerifyThrow(!(isOuterBuild && isInnerBuild), $"A project cannot be an outer and inner build at the same time: ${project.FullPath}");
+
+            return isOuterBuild
+                ? ProjectType.OuterBuild
+                : isInnerBuild
+                    ? ProjectType.InnerBuild
+                    : ProjectType.NonCrossTargeting;
+        }
+
+        public static void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)
+        {
+            foreach (var nodeKvp in allNodes)
+            {
+                var outerBuild = nodeKvp.Value;
+
+                if (GetProjectType(outerBuild.ProjectInstance) == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)
+                {
+                    foreach (var innerBuild in outerBuild.ProjectReferences)
+                    {
+                        foreach (var referencingProject in outerBuild.ReferencingProjects)
+                        {
+                            referencingProject.AddProjectReference(innerBuild);
+                        }
+                    }
+
+                    outerBuild.RemoveReferences();
+                }
+            }
+        }
+
+        private static IEnumerable<ProjectItemInstance> GetInnerBuildReferences(ProjectInstance outerBuild)
+        {
+            var globalPropertyName = GetInnerBuildPropertyName(outerBuild);
+            var globalPropertyValues = GetInnerBuildPropertyValues(outerBuild);
+
+            ErrorUtilities.VerifyThrow(!string.IsNullOrWhiteSpace(globalPropertyName), "Must have an inner build property");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrWhiteSpace(globalPropertyValues), "Must have values for the inner build property");
+
+            foreach (var globalPropertyValue in ExpressionShredder.SplitSemiColonSeparatedList(globalPropertyValues))
+            {
+                yield return new ProjectItemInstance(
+                    outerBuild,
+                    "_ProjectSelfReference",
+                    outerBuild.FullPath,
+                    new[] {new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}")},
+                    outerBuild.FullPath);
+            }
+        }
+
+        /// <summary>
+        ///     Gets the effective global properties for a project reference item.
+        /// </summary>
+        /// <remarks>
+        ///     The behavior of this method should match the logic in the SDK
+        /// </remarks>
+        private static GlobalPropertyPartsForMSBuildTask ProjectReferenceGlobalPropertiesModifier(
+            GlobalPropertyPartsForMSBuildTask defaultParts,
+            ProjectItemInstance projectReference
+        )
+        {
+            // ProjectReference defines yet another metadata name containing properties to undefine. Merge it in if non empty.
+            var globalPropertiesToRemove = SplitPropertyNames(projectReference.GetMetadataValue(GlobalPropertiesToRemoveMetadataName));
+
+            var newUndefineProperties = defaultParts.UndefineProperties;
+
+            newUndefineProperties = newUndefineProperties.AddRange(defaultParts.UndefineProperties);
+            newUndefineProperties = newUndefineProperties.AddRange(globalPropertiesToRemove);
+
+            newUndefineProperties.Add("InnerBuildProperty");
+
+            var newProperties = defaultParts.Properties;
+
+            // The properties on the project reference supersede the ones from the MSBuild task instead of appending.
+            if (newProperties.Count == 0)
+            {
+                // TODO: Mimic AssignProjectConfiguration's behavior for determining the values for these.
+                var setConfigurationString = projectReference.GetMetadataValue(SetConfigurationMetadataName);
+                var setPlatformString = projectReference.GetMetadataValue(SetPlatformMetadataName);
+                var setTargetFrameworkString = projectReference.GetMetadataValue(SetTargetFrameworkMetadataName);
+
+                if (!string.IsNullOrEmpty(setConfigurationString) || !string.IsNullOrEmpty(setPlatformString) || !string.IsNullOrEmpty(setTargetFrameworkString))
+                {
+                    newProperties = SplitPropertyNameValuePairs(
+                        ItemMetadataNames.PropertiesMetadataName,
+                        $"{setConfigurationString};{setPlatformString};{setTargetFrameworkString}").ToImmutableDictionary();
+                }
+            }
+
+            return new GlobalPropertyPartsForMSBuildTask(newProperties, defaultParts.AdditionalProperties, newUndefineProperties);
+        }
+
+        private readonly struct GlobalPropertyPartsForMSBuildTask
+        {
+            public ImmutableDictionary<string, string> Properties { get; }
+            public ImmutableDictionary<string, string> AdditionalProperties { get; }
+            public ImmutableList<string> UndefineProperties { get; }
+
+            public GlobalPropertyPartsForMSBuildTask(
+                ImmutableDictionary<string, string> properties,
+                ImmutableDictionary<string, string> additionalProperties,
+                ImmutableList<string> undefineProperties)
+            {
+                Properties = properties;
+                AdditionalProperties = additionalProperties;
+                UndefineProperties = undefineProperties;
+            }
+
+            public bool AllEmpty()
+            {
+                return Properties.Count == 0 && AdditionalProperties.Count == 0 && UndefineProperties.Count == 0;
+            }
+
+            public GlobalPropertyPartsForMSBuildTask AddPropertyToUndefine(string propertyToUndefine)
+            {
+                return new GlobalPropertyPartsForMSBuildTask(Properties, AdditionalProperties, UndefineProperties.Add(propertyToUndefine));
+            }
+        }
+
+        delegate GlobalPropertyPartsForMSBuildTask GlobalPropertiesModifier(GlobalPropertyPartsForMSBuildTask defaultParts, ProjectItemInstance projectReference);
+
+        /// <summary>
+        ///     Gets the effective global properties for an item that will get passed to <see cref="MSBuild.Projects"/>.
+        /// </summary>
+        /// <remarks>
+        ///     The behavior of this method matches the hardcoded behaviour of the msbuild task
+        ///     and the <paramref name="globalPropertyModifier"/> parameter can contain other mutations done at build time in targets / tasks
+        /// </remarks>
+        private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesForItem(
+            ProjectItemInstance projectReference,
+            PropertyDictionary<ProjectPropertyInstance> requesterGlobalProperties,
+            IEnumerable<GlobalPropertiesModifier> globalPropertyModifier = null)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(projectReference, nameof(projectReference));
+            ErrorUtilities.VerifyThrowArgumentNull(requesterGlobalProperties, nameof(requesterGlobalProperties));
+
+            var properties = SplitPropertyNameValuePairs(ItemMetadataNames.PropertiesMetadataName, projectReference.GetMetadataValue(ItemMetadataNames.PropertiesMetadataName));
+            var additionalProperties = SplitPropertyNameValuePairs(ItemMetadataNames.AdditionalPropertiesMetadataName, projectReference.GetMetadataValue(ItemMetadataNames.AdditionalPropertiesMetadataName));
+            var undefineProperties = SplitPropertyNames(projectReference.GetMetadataValue(ItemMetadataNames.UndefinePropertiesMetadataName));
+
+            var defaultParts = new GlobalPropertyPartsForMSBuildTask(properties.ToImmutableDictionary(), additionalProperties.ToImmutableDictionary(), undefineProperties.ToImmutableList());
+
+            var globalPropertyParts = globalPropertyModifier?.Aggregate(defaultParts, (currentProperties, modifier) => modifier(currentProperties, projectReference)) ?? defaultParts;
+
+            if (globalPropertyParts.AllEmpty())
+            {
+                return requesterGlobalProperties;
+            }
+
+            // Make a copy to avoid mutating the requester
+            var globalProperties = new PropertyDictionary<ProjectPropertyInstance>(requesterGlobalProperties);
+
+            // Append and remove properties as specified by the various metadata
+            MergeIntoPropertyDictionary(globalProperties, globalPropertyParts.Properties);
+            MergeIntoPropertyDictionary(globalProperties, globalPropertyParts.AdditionalProperties);
+            RemoveFromPropertyDictionary(globalProperties, globalPropertyParts.UndefineProperties);
+
+            return globalProperties;
+        }
+
+        private static void MergeIntoPropertyDictionary(
+            PropertyDictionary<ProjectPropertyInstance> destination,
+            IReadOnlyDictionary<string, string> source)
+        {
+            foreach (var pair in source)
+            {
+                destination[pair.Key] = ProjectPropertyInstance.Create(pair.Key, pair.Value);
+            }
+        }
+
+        private static IReadOnlyDictionary<string, string> SplitPropertyNameValuePairs(string syntaxName, string propertyNameAndValuesString)
+        {
+            if (string.IsNullOrEmpty(propertyNameAndValuesString))
+            {
+                return ImmutableDictionary<string, string>.Empty;
+            }
+
+            if (PropertyParser.GetTableWithEscaping(
+                null,
+                null,
+                null,
+                propertyNameAndValuesString.Split(PropertySeparator, StringSplitOptions.RemoveEmptyEntries),
+                out var propertiesTable))
+            {
+                return propertiesTable;
+            }
+
+            throw new InvalidProjectFileException(
+                string.Format(
+                    CultureInfo.InvariantCulture,
+                    ResourceUtilities.GetResourceString("General.InvalidPropertyError"),
+                    syntaxName,
+                    propertyNameAndValuesString));
+        }
+
+        private static IReadOnlyCollection<string> SplitPropertyNames(string propertyNamesString)
+        {
+            if (string.IsNullOrEmpty(propertyNamesString))
+            {
+                return ImmutableArray<string>.Empty;
+            }
+
+            return propertyNamesString.Split(PropertySeparator, StringSplitOptions.RemoveEmptyEntries);
+        }
+
+        private static void RemoveFromPropertyDictionary(
+            PropertyDictionary<ProjectPropertyInstance> properties,
+            IReadOnlyCollection<string> propertyNamesToRemove)
+        {
+            foreach (var propertyName in propertyNamesToRemove)
+            {
+                properties.Remove(propertyName);
+            }
+        }
+    }
+}
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 3b416131269..419148469cd 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -160,6 +160,7 @@
     <Compile Include="BackEnd\BuildManager\CacheAggregator.cs" />
     <Compile Include="BackEnd\Components\Caching\ConfigCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
+    <Compile Include="Graph\ProjectInterpretation.cs" />
     <Compile Include="Graph\GraphBuildResult.cs" />
     <Compile Include="Graph\GraphBuildSubmission.cs" />
     <Compile Include="Graph\GraphBuildRequestData.cs" />
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 1469ef250f1..5cb0c94cec1 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -111,19 +111,22 @@ internal static class PropertyNames
         /// Specifies whether the current evaluation / build is happening during a graph build
         /// </summary>
         internal const string IsGraphBuild = "IsGraphBuild";
+
+        internal const string InnerBuildProperty = "InnerBuildProperty";
+        internal const string InnerBuildPropertyValues = "InnerBuildPropertyValues";
     }
 
     internal static class ItemTypeNames
     {
         /// <summary>
-        /// The name of the item used to specify references to other msbuild projects
+        /// References to other msbuild projects
         /// </summary>
-        internal const string ProjectReferenceItemName = "ProjectReference";
+        internal const string ProjectReference = "ProjectReference";
 
         /// <summary>
-        /// The name of the item used to statically specify what targets a project calls on its references
+        /// Statically specifies what targets a project calls on its references
         /// </summary>
-        internal const string ProjectReferenceTargetsItemType = "ProjectReferenceTargets";
+        internal const string ProjectReferenceTargets = "ProjectReferenceTargets";
     }
 
     /// <summary>
@@ -168,5 +171,8 @@ internal static class ItemMetadataNames
         internal const string IgnoreVersionForFrameworkReference = "IgnoreVersionForFrameworkReference";
         internal const string frameworkFile = "FrameworkFile";
         internal const string ProjectReferenceTargetsMetadataName = "Targets";
+        internal const string PropertiesMetadataName = "Properties";
+        internal const string UndefinePropertiesMetadataName = "UndefineProperties";
+        internal const string AdditionalPropertiesMetadataName = "AdditionalProperties";
     }
 }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 554fced43c1..ea00789ec36 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1269,6 +1269,24 @@ internal static void AssertDictionariesEqual(IDictionary<string, string> x, IDic
                 });
         }
 
+        internal static void ShouldBeEquivalentTo<K, V>(this IReadOnlyDictionary<K, V> a, IReadOnlyDictionary<K, V> b)
+        {
+            a.ShouldBeSubsetOf(b);
+            b.ShouldBeSubsetOf(a);
+        }
+
+        internal static void ShouldBeEquivalentTo<K, V>(this IDictionary<K, V> a, IReadOnlyDictionary<K, V> b)
+        {
+            a.ShouldBeSubsetOf(b);
+            b.ShouldBeSubsetOf(a);
+        }
+
+        internal static void ShouldBeEquivalentTo<K>(this IReadOnlyCollection<K> a, IReadOnlyCollection<K> b)
+        {
+            a.ShouldBeSubsetOf(b);
+            b.ShouldBeSubsetOf(a);
+        }
+
         /// <summary>
         /// Verify that the two enumerables are value identical
         /// </summary>
@@ -1572,9 +1590,9 @@ internal static ProjectGraph CreateProjectGraph(
             TestEnvironment env,
             // direct dependencies that the kvp.key node has on the nodes represented by kvp.value
             IDictionary<int, int[]> dependencyEdges,
+            IDictionary<string, string> globalProperties = null,
             CreateProjectFileDelegate createProjectFile = null,
-            IEnumerable<int> roots = null,
-            IDictionary<string, string> globalProperties = null)
+            IEnumerable<int> roots = null)
         {
             createProjectFile = createProjectFile ?? CreateProjectFile;
 
diff --git a/src/Tasks/Microsoft.ManagedLanguages.targets b/src/Tasks/Microsoft.ManagedLanguages.targets
index dde76678c0e..337c402e480 100644
--- a/src/Tasks/Microsoft.ManagedLanguages.targets
+++ b/src/Tasks/Microsoft.ManagedLanguages.targets
@@ -12,21 +12,25 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
 <Project>
    <!-- 
-        We are doing a cross-targeting build if there is no list of target frameworks specified
-        nor is there a current target framework being built individually. In that case, a crosstargeting
+        We are doing a cross-targeting build if there is a non-empty list of target frameworks specified
+        and there is no current target framework being built individually. In that case, a crosstargeting
         project file like Microsoft.<language>.CrossTargeting.targets gets imported.
    -->
    <PropertyGroup Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''">
       <IsCrossTargetingBuild>true</IsCrossTargetingBuild>
-      <IsOuterBuild>true</IsOuterBuild>
+   </PropertyGroup>
+
+   <PropertyGroup>
+      <InnerBuildProperty>TargetFramework</InnerBuildProperty>
+      <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>
    </PropertyGroup>
 
    <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
-      <!-- Microsoft.Net.Sdk adds all transitive project references to @ProjectReference. It does this at build time
+      <!-- Microsoft.Net.Sdk adds all transitive project references to ProjectReference. It does this at build time
            via a target. This fails the undeclared msbuild reference /isolate constraint, so disable transitive
            references.
            Do not disable transitive references if BuildProjectReferences is false. If building references is false,
-           then msbuild won't try to build the transitive references, which won't trigger undeclared reference constraints.
+           then MSBuild won't try to build the transitive references, which won't trigger undeclared reference constraints.
           -->
       <DisableTransitiveProjectReferences Condition="'$(BuildProjectReferences)' != 'false'">true</DisableTransitiveProjectReferences>
    </PropertyGroup>
