diff --git a/.github/policies/resourceManagement.yml b/.github/policies/resourceManagement.yml
index effb189ad06..c65e138b268 100644
--- a/.github/policies/resourceManagement.yml
+++ b/.github/policies/resourceManagement.yml
@@ -168,5 +168,36 @@ configuration:
       - addReply:
           reply: Hello @${issueAuthor}, I noticed that you’re changing an *.swr file or any file under src/Package/MSBuild.VSSetup.*. Please make sure to validate this change by an experimental VS insertion. This is accomplished by pushing to an exp/* branch, which requires write permissions to this repo.
       description: Remind to run VS Perf DDRITs when deployed assemblies change
+    - if:
+      - payloadType: Issues
+      - labelAdded:
+          label: breaking-change
+      then:
+      - addReply:
+          reply: >-
+            Refer to the [.NET SDK breaking change guidelines](https://github.com/dotnet/sdk/blob/main/documentation/project-docs/breaking-change-guidelines.md#required-process-for-all-net-sdk-breaking-changes)
+      description: Add breaking change doc instructions to issue
+    - if:
+      - payloadType: Pull_Request
+      - labelAdded:
+          label: breaking-change
+      then:
+      - addLabel:
+          label: needs-breaking-change-doc-created
+      - addReply:
+          reply: >-
+            Added `needs-breaking-change-doc-created` label because this PR has the `breaking-change` label. 
+
+
+            When you commit this breaking change:
+
+
+            1. [ ] Create and link to this PR and the issue a matching issue in the dotnet/docs repo using the [breaking change documentation template](https://aka.ms/dotnet/docs/new-breaking-change-issue), then remove this `needs-breaking-change-doc-created` label.
+
+            2. [ ] Ask a committer to mail the `.NET SDK Breaking Change Notification` email list.
+
+
+            You can refer to the [.NET SDK breaking change guidelines](https://github.com/dotnet/sdk/blob/main/documentation/project-docs/breaking-change-guidelines.md)
+      description: Add breaking change instructions to PR.      
 onFailure: 
 onSuccess: 
diff --git a/.github/workflows/labeler-cache-retention.yml b/.github/workflows/labeler-cache-retention.yml
new file mode 100644
index 00000000000..235b0e42cf2
--- /dev/null
+++ b/.github/workflows/labeler-cache-retention.yml
@@ -0,0 +1,40 @@
+# Workflow template imported and updated from:
+# https://github.com/dotnet/issue-labeler/wiki/Onboarding
+#
+# See labeler.md for more information
+#
+# Regularly restore the prediction models from cache to prevent cache eviction
+name: "Labeler: Cache Retention"
+
+# For more information about GitHub's action cache limits and eviction policy, see:
+# https://docs.github.com/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows#usage-limits-and-eviction-policy
+
+on:
+  schedule:
+    - cron: "10 3 * * *" # 3:10 every day (arbitrary time daily, modified to different values in each repository)
+
+  workflow_dispatch:
+    inputs:
+      cache_key:
+        description: "The cache key suffix to use for restoring the model from cache. Defaults to 'ACTIVE'."
+        required: true
+        default: "ACTIVE"
+
+env:
+  CACHE_KEY: ${{ inputs.cache_key || 'ACTIVE' }}
+
+jobs:
+  restore-cache:
+    # Do not automatically run the workflow on forks outside the 'dotnet' org
+    if: ${{ github.event_name == 'workflow_dispatch' || github.repository_owner == 'dotnet' }}
+    runs-on: ubuntu-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        type: ["issues"] # Pulls are disabled in this repository, so "pulls" is removed from the matrix
+    steps:
+      - uses: dotnet/issue-labeler/restore@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: ${{ matrix.type }}
+          cache_key: ${{ env.CACHE_KEY }}
+          fail-on-cache-miss: true
diff --git a/.github/workflows/labeler-predict-issues.yml b/.github/workflows/labeler-predict-issues.yml
new file mode 100644
index 00000000000..8db06b94696
--- /dev/null
+++ b/.github/workflows/labeler-predict-issues.yml
@@ -0,0 +1,58 @@
+# Workflow template imported and updated from:
+# https://github.com/dotnet/issue-labeler/wiki/Onboarding
+#
+# See labeler.md for more information
+#
+# Predict labels for Issues using a trained model
+name: "Labeler: Predict (Issues)"
+
+on:
+  # Only automatically predict area labels when issues are first opened
+  issues:
+    types: opened
+
+  # Allow dispatching the workflow via the Actions UI, specifying ranges of numbers
+  workflow_dispatch:
+    inputs:
+      issues:
+        description: "Issue Numbers (comma-separated list of ranges)."
+        required: true
+      cache_key:
+        description: "The cache key suffix to use for restoring the model. Defaults to 'ACTIVE'."
+        required: true
+        default: "ACTIVE"
+
+env:
+  # Do not allow failure for jobs triggered automatically (as this causes red noise on the workflows list)
+  ALLOW_FAILURE: ${{ github.event_name == 'workflow_dispatch' }}
+
+  LABEL_PREFIX: "Area: "
+  THRESHOLD: 0.40
+
+jobs:
+  predict-issue-label:
+    # Do not automatically run the workflow on forks outside the 'dotnet' org
+    if: ${{ github.event_name == 'workflow_dispatch' || github.repository_owner == 'dotnet' }}
+    runs-on: ubuntu-latest
+    permissions:
+      issues: write
+    steps:
+      - name: "Restore issues model from cache"
+        id: restore-model
+        uses: dotnet/issue-labeler/restore@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: issues
+          fail-on-cache-miss: ${{ env.ALLOW_FAILURE }}
+          quiet: true
+
+      - name: "Predict issue labels"
+        id: prediction
+        if: ${{ steps.restore-model.outputs.cache-hit == 'true' }}
+        uses: dotnet/issue-labeler/predict@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          issues: ${{ inputs.issues || github.event.issue.number }}
+          label_prefix: ${{ env.LABEL_PREFIX }}
+          threshold: ${{ env.THRESHOLD }}
+        env:
+          GITHUB_TOKEN: ${{ github.token }}
+        continue-on-error: ${{ !env.ALLOW_FAILURE }}
diff --git a/.github/workflows/labeler-predict-pulls.yml b/.github/workflows/labeler-predict-pulls.yml
new file mode 100644
index 00000000000..ff0c2c61f1c
--- /dev/null
+++ b/.github/workflows/labeler-predict-pulls.yml
@@ -0,0 +1,72 @@
+# Workflow template imported and updated from:
+# https://github.com/dotnet/issue-labeler/wiki/Onboarding
+#
+# See labeler.md for more information
+#
+# Predict labels for Pull Requests using a trained model
+name: "Labeler: Predict (Pulls)"
+
+on:
+  # Per to the following documentation:
+  # https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#pull_request_target
+  #
+  # The `pull_request_target` event runs in the context of the base of the pull request, rather
+  # than in the context of the merge commit, as the `pull_request` event does. This prevents
+  # execution of unsafe code from the head of the pull request that could alter the repository
+  # or steal any secrets you use in your workflow. This event allows your workflow to do things
+  # like label or comment on pull requests from forks.
+  #
+  # Only automatically predict area labels when pull requests are first opened
+  pull_request_target:
+    types: opened
+
+    # Configure the branches that need to have PRs labeled
+    branches:
+      - 'main'
+      - 'vs*'
+
+  # Allow dispatching the workflow via the Actions UI, specifying ranges of numbers
+  workflow_dispatch:
+    inputs:
+      pulls:
+        description: "Pull Request Numbers (comma-separated list of ranges)."
+        required: true
+      cache_key:
+        description: "The cache key suffix to use for restoring the model. Defaults to 'ACTIVE'."
+        required: true
+        default: "ACTIVE"
+
+env:
+  # Do not allow failure for jobs triggered automatically (this can block PR merge)
+  ALLOW_FAILURE: ${{ github.event_name == 'workflow_dispatch' }}
+
+  LABEL_PREFIX: "Area: "
+  THRESHOLD: 0.40
+
+jobs:
+  predict-pull-label:
+    # Do not automatically run the workflow on forks outside the 'dotnet' org
+    if: ${{ github.event_name == 'workflow_dispatch' || github.repository_owner == 'dotnet' }}
+    runs-on: ubuntu-latest
+    permissions:
+      pull-requests: write
+    steps:
+      - name: "Restore pulls model from cache"
+        id: restore-model
+        uses: dotnet/issue-labeler/restore@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: pulls
+          fail-on-cache-miss: ${{ env.ALLOW_FAILURE }}
+          quiet: true
+
+      - name: "Predict pull labels"
+        id: prediction
+        if: ${{ steps.restore-model.outputs.cache-hit == 'true' }}
+        uses: dotnet/issue-labeler/predict@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          pulls: ${{ inputs.pulls || github.event.number }}
+          label_prefix: ${{ env.LABEL_PREFIX }}
+          threshold: ${{ env.THRESHOLD }}
+        env:
+          GITHUB_TOKEN: ${{ github.token }}
+        continue-on-error: ${{ !env.ALLOW_FAILURE }}
diff --git a/.github/workflows/labeler-promote.yml b/.github/workflows/labeler-promote.yml
new file mode 100644
index 00000000000..c01086c5177
--- /dev/null
+++ b/.github/workflows/labeler-promote.yml
@@ -0,0 +1,54 @@
+# Workflow template imported and updated from:
+# https://github.com/dotnet/issue-labeler/wiki/Onboarding
+#
+# See labeler.md for more information
+#
+# Promote a model from staging to 'ACTIVE', backing up the currently 'ACTIVE' model
+name: "Labeler: Promotion"
+
+on:
+  # Dispatched via the Actions UI, promotes the staged models from
+  # a staged slot into the prediction environment
+  workflow_dispatch:
+    inputs:
+      issues:
+        description: "Issues: Promote Model"
+        type: boolean
+        required: true
+      pulls:
+        description: "Pulls: Promote Model"
+        type: boolean
+        required: true
+      staged_key:
+        description: "The cache key suffix to use for promoting a staged model to 'ACTIVE'. Defaults to 'staged'."
+        required: true
+        default: "staged"
+      backup_key:
+        description: "The cache key suffix to use for backing up the currently active model. Defaults to 'backup'."
+        default: "backup"
+
+permissions:
+  actions: write
+
+jobs:
+  promote-issues:
+    if: ${{ inputs.issues }}
+    runs-on: ubuntu-latest
+    steps:
+      - name: "Promote Model for Issues"
+        uses: dotnet/issue-labeler/promote@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "issues"
+          staged_key: ${{ inputs.staged_key }}
+          backup_key: ${{ inputs.backup_key }}
+
+  promote-pulls:
+    if: ${{ inputs.pulls }}
+    runs-on: ubuntu-latest
+    steps:
+      - name: "Promote Model for Pull Requests"
+        uses: dotnet/issue-labeler/promote@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "pulls"
+          staged_key: ${{ inputs.staged_key }}
+          backup_key: ${{ inputs.backup_key }}
diff --git a/.github/workflows/labeler-train.yml b/.github/workflows/labeler-train.yml
new file mode 100644
index 00000000000..85a816fb064
--- /dev/null
+++ b/.github/workflows/labeler-train.yml
@@ -0,0 +1,165 @@
+# Workflow template imported and updated from:
+# https://github.com/dotnet/issue-labeler/wiki/Onboarding
+#
+# See labeler.md for more information
+#
+# Train the Issues and Pull Requests models for label prediction
+name: "Labeler: Training"
+
+on:
+  workflow_dispatch:
+    inputs:
+      type:
+        description: "Issues or Pull Requests"
+        type: choice
+        required: true
+        default: "Issues" # Pulls are disabled in this repository, so default to "Issues" only
+        options:
+          - "Both"
+          - "Issues"
+          - "Pull Requests"
+
+      steps:
+        description: "Training Steps"
+        type: choice
+        required: true
+        default: "All"
+        options:
+          - "All"
+          - "Download Data"
+          - "Train Model"
+          - "Test Model"
+
+      limit:
+        description: "Max number of items to download for training/testing the model (newest items are used). Defaults to the max number of pages times the page size."
+        type: number
+      page_size:
+        description: "Number of items per page in GitHub API requests. Defaults to 100 for issues, 25 for pull requests."
+        type: number
+      page_limit:
+        description: "Maximum number of pages to download for training/testing the model. Defaults to 1000 for issues, 4000 for pull requests."
+        type: number
+      cache_key_suffix:
+        description: "The cache key suffix to use for staged data/models (use 'ACTIVE' to bypass staging). Defaults to 'staged'."
+        required: true
+        default: "staged"
+
+env:
+  CACHE_KEY: ${{ inputs.cache_key_suffix }}
+  REPOSITORY: ${{ github.repository }}
+  LABEL_PREFIX: "Area: "
+  THRESHOLD: "0.40"
+  LIMIT: ${{ inputs.limit }}
+  PAGE_SIZE: ${{ inputs.page_size }}
+  PAGE_LIMIT: ${{ inputs.page_limit }}
+
+jobs:
+  download-issues:
+    if: ${{ contains(fromJSON('["Both", "Issues"]'), inputs.type) && contains(fromJSON('["All", "Download Data"]'), inputs.steps) }}
+    runs-on: ubuntu-latest
+    permissions:
+      issues: read
+    steps:
+      - name: "Download Issues"
+        uses: dotnet/issue-labeler/download@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "issues"
+          cache_key: ${{ env.CACHE_KEY }}
+          repository: ${{ env.REPOSITORY }}
+          label_prefix: ${{ env.LABEL_PREFIX }}
+          limit: ${{ env.LIMIT }}
+          page_size: ${{ env.PAGE_SIZE }}
+          page_limit: ${{ env.PAGE_LIMIT }}
+          excluded_authors: ${{ env.EXCLUDED_AUTHORS }}
+        env:
+          GITHUB_TOKEN: ${{ github.token }}
+
+  download-pulls:
+    if: ${{ contains(fromJSON('["Both", "Pull Requests"]'), inputs.type) && contains(fromJSON('["All", "Download Data"]'), inputs.steps) }}
+    runs-on: ubuntu-latest
+    permissions:
+      pull-requests: read
+    steps:
+      - name: "Download Pull Requests"
+        uses: dotnet/issue-labeler/download@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "pulls"
+          cache_key: ${{ env.CACHE_KEY }}
+          repository: ${{ env.REPOSITORY }}
+          label_prefix: ${{ env.LABEL_PREFIX }}
+          limit: ${{ env.LIMIT }}
+          page_size: ${{ env.PAGE_SIZE }}
+          page_limit: ${{ env.PAGE_LIMIT }}
+          excluded_authors: ${{ env.EXCLUDED_AUTHORS }}
+        env:
+          GITHUB_TOKEN: ${{ github.token }}
+
+  train-issues:
+    if: ${{ always() && contains(fromJSON('["Both", "Issues"]'), inputs.type) && contains(fromJSON('["All", "Train Model"]'), inputs.steps) && contains(fromJSON('["success", "skipped"]'), needs.download-issues.result) }}
+    runs-on: ubuntu-latest
+    permissions: {}
+    needs: download-issues
+    steps:
+      - name: "Train Model for Issues"
+        uses: dotnet/issue-labeler/train@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "issues"
+          data_cache_key: ${{ env.CACHE_KEY }}
+          model_cache_key: ${{ env.CACHE_KEY }}
+
+  train-pulls:
+    if: ${{ always() && contains(fromJSON('["Both", "Pull Requests"]'), inputs.type) && contains(fromJSON('["All", "Train Model"]'), inputs.steps) && contains(fromJSON('["success", "skipped"]'), needs.download-pulls.result) }}
+    runs-on: ubuntu-latest
+    permissions: {}
+    needs: download-pulls
+    steps:
+      - name: "Train Model for Pull Requests"
+        uses: dotnet/issue-labeler/train@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "pulls"
+          data_cache_key: ${{ env.CACHE_KEY }}
+          model_cache_key: ${{ env.CACHE_KEY }}
+
+  test-issues:
+    if: ${{ always() && contains(fromJSON('["Both", "Issues"]'), inputs.type) && contains(fromJSON('["All", "Test Model"]'), inputs.steps) && contains(fromJSON('["success", "skipped"]'), needs.train-issues.result) }}
+    runs-on: ubuntu-latest
+    permissions:
+      issues: read
+    needs: train-issues
+    steps:
+      - name: "Test Model for Issues"
+        uses: dotnet/issue-labeler/test@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "issues"
+          cache_key: ${{ env.CACHE_KEY }}
+          repository: ${{ env.REPOSITORY }}
+          label_prefix: ${{ env.LABEL_PREFIX }}
+          threshold: ${{ env.THRESHOLD }}
+          limit: ${{ env.LIMIT }}
+          page_size: ${{ env.PAGE_SIZE }}
+          page_limit: ${{ env.PAGE_LIMIT }}
+          excluded_authors: ${{ env.EXCLUDED_AUTHORS }}
+        env:
+          GITHUB_TOKEN: ${{ github.token }}
+
+  test-pulls:
+    if: ${{ always() && contains(fromJSON('["Both", "Pull Requests"]'), inputs.type) && contains(fromJSON('["All", "Test Model"]'), inputs.steps) && contains(fromJSON('["success", "skipped"]'), needs.train-pulls.result) }}
+    runs-on: ubuntu-latest
+    permissions:
+      pull-requests: read
+    needs: train-pulls
+    steps:
+      - name: "Test Model for Pull Requests"
+        uses: dotnet/issue-labeler/test@46125e85e6a568dc712f358c39f35317366f5eed # v2.0.0
+        with:
+          type: "pulls"
+          cache_key: ${{ env.CACHE_KEY }}
+          repository: ${{ env.REPOSITORY }}
+          label_prefix: ${{ env.LABEL_PREFIX }}
+          threshold: ${{ env.THRESHOLD }}
+          limit: ${{ env.LIMIT }}
+          page_size: ${{ env.PAGE_SIZE }}
+          page_limit: ${{ env.PAGE_LIMIT }}
+          excluded_authors: ${{ env.EXCLUDED_AUTHORS }}
+        env:
+          GITHUB_TOKEN: ${{ github.token }}
diff --git a/.github/workflows/labeler.md b/.github/workflows/labeler.md
new file mode 100644
index 00000000000..84d004aeed5
--- /dev/null
+++ b/.github/workflows/labeler.md
@@ -0,0 +1,36 @@
+# Issue-Labeler Workflows
+
+This repository uses actions from [dotnet/issue-labeler](https://github.com/dotnet/issue-labeler) to predict area labels for issues and pull requests.
+
+The following workflow templates were imported and updated from [dotnet/issue-labeler/wiki/Onboarding](https://github.com/dotnet/issue-labeler/wiki/Onboarding):
+
+1. `labeler-cache-retention.yml`
+2. `labeler-predict-issues.yml`
+3. `labeler-predict-pulls.yml`
+4. `labeler-promote.yml`
+5. `labeler-train.yml`
+
+## Repository Configuration
+
+Across these workflows, the following changes were made to configure the issue labeler for this repository:
+
+1. Set `LABEL_PREFIX` to `"Area: "`:
+    - `labeler-predict-issues.yml`
+    - `labeler-predict-pulls.yml`
+    - `labeler-train.yml`
+2. Remove the `DEFAULT_LABEL` setting since no default label is applied when prediction is not made:
+    - `labeler-predict-issues.yml`
+    - `labeler-predict-pulls.yml`
+3. Remove the `EXCLUDED_AUTHORS` value as we do not bypass labeling for any authors' issues/pulls in this repository:
+    - `labeler-predict-issues.yml`
+    - `labeler-predict-pulls.yml`
+4. Update the pull request labeling branches to include `main` and `vs*`:
+    - `labeler-predict-pulls.yml`
+5. Remove the `repository` input for training the models against another repository:
+    - `labeler-train.yml`
+6. Update the cache retention cron schedule to an arbitrary time of day:
+    - `labeler-cache-retention.yml`
+7. Disable pull request training, cache retention, and predition
+    - `labeler-train.yml` - Change the default from "Both" to "Issues"
+    - `labeler-cache-retention.yml` - Remove "pulls" from the job matrix (leaving a comment)
+    - `labeler-predict-pulls.yml` - Workflow marked as Disabled via GitHub UI
diff --git a/.github/workflows/perfstar-branch.yml b/.github/workflows/perfstar-branch.yml
new file mode 100644
index 00000000000..f7f52492417
--- /dev/null
+++ b/.github/workflows/perfstar-branch.yml
@@ -0,0 +1,55 @@
+name: Create Perf Branch on /perfstar comment
+
+on:
+  issue_comment:
+    types: [created]
+
+permissions:
+  contents: write
+  pull-requests: read
+
+jobs:
+  create_perf_branch:
+    if: |
+      github.event.issue.pull_request &&
+      github.event.comment.body == '/perfstar' &&
+      contains(fromJSON('["COLLABORATOR", "MEMBER", "OWNER"]'), github.event.comment.author_association)
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout repository
+        uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+
+      - name: Get PR information
+        id: pr_info
+        run: |
+          PR_DATA=$(gh pr view ${{ github.event.issue.number }} --json headRefName,headRefOid,headRepository)
+          HEAD_REF=$(echo $PR_DATA | jq -r '.headRefName')
+          HEAD_SHA=$(echo $PR_DATA | jq -r '.headRefOid')
+          HEAD_REPO=$(echo $PR_DATA | jq -r '.headRepository.nameWithOwner')
+          
+          echo "pr_head_branch=${HEAD_REF}" >> $GITHUB_OUTPUT
+          echo "pr_head_sha=${HEAD_SHA}" >> $GITHUB_OUTPUT
+          echo "pr_head_repo=${HEAD_REPO}" >> $GITHUB_OUTPUT
+          echo "new_branch_name=perf/${HEAD_REF}" >> $GITHUB_OUTPUT
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+
+      - name: Create and push perf branch
+        run: |
+          git config user.name "github-actions[bot]"
+          git config user.email "github-actions[bot]@users.noreply.github.com"
+          
+          # Ensure we can access the PR's commits (especially important for forks)
+          git fetch origin pull/${{ github.event.issue.number }}/head:pr-${{ github.event.issue.number }}-head
+          
+          # Create branch from PR head
+          git checkout -b ${{ steps.pr_info.outputs.new_branch_name }} ${{ steps.pr_info.outputs.pr_head_sha }}
+          
+          # Merge main branch
+          git fetch origin main
+          git merge origin/main --no-ff --no-edit -m "Merge main into ${{ steps.pr_info.outputs.new_branch_name }} for perf testing"
+          
+          # Push branch
+          git push origin ${{ steps.pr_info.outputs.new_branch_name }}
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 3ea490a61af..f8f6e6e69a0 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -14,40 +14,40 @@ variables:
   value: none
 
 jobs:
-# - job: CheckVersionBumpOnReleaseBranches
-#   displayName: "Check Version Bump On Release Branches"
-#   steps:
-#   - powershell: |
-#       $versionsFile = "eng/Versions.props"
-#       $changedFiles = git diff --name-only HEAD HEAD~1
-#       $changedVersionsFile = $changedFiles | Where-Object { $_ -eq $versionsFile }
-#       $isInitialCommit = $false
-#       $isVersionBumped = $false
-#       if ($changedVersionsFile -ne $null) {
-#         $difference = git diff HEAD~1 $versionsFile
-#         $changedContent = $difference -join "%"
-#         # 'DotNetFinalVersionKind' is expected to be added only during the initial setup of the release branch
-#         $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>%.*\+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix><DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
-#         $isInitialCommit = $changedContent -match $initialCommitPattern
-#         $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.*%\+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
-#         if (!($isInitialCommit) -and ($changedContent -match $pattern)) {
-#           try {
-#             $previousPatch = [Convert]::ToInt32($Matches.previous)
-#             $currentPatch = [Convert]::ToInt32($Matches.current)
-#             if ($currentPatch -gt $previousPatch) {
-#               $isVersionBumped = $true
-#             }
-#           } catch {
-#             Write-Host "An error occurred during conversion: $_"
-#           }
-#         }
-#       }
+- job: CheckVersionBumpOnReleaseBranches
+  displayName: "Check Version Bump On Release Branches"
+  steps:
+  - powershell: |
+      $versionsFile = "eng/Versions.props"
+      $changedFiles = git diff --name-only HEAD HEAD~1
+      $changedVersionsFile = $changedFiles | Where-Object { $_ -eq $versionsFile }
+      $isInitialCommit = $false
+      $isVersionBumped = $false
+      if ($changedVersionsFile -ne $null) {
+        $difference = git diff HEAD~1 $versionsFile
+        $changedContent = $difference -join "%"
+        # 'DotNetFinalVersionKind' is expected to be added only during the initial setup of the release branch
+        $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>%.*\+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix><DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
+        $isInitialCommit = $changedContent -match $initialCommitPattern
+        $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.*%\+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
+        if (!($isInitialCommit) -and ($changedContent -match $pattern)) {
+          try {
+            $previousPatch = [Convert]::ToInt32($Matches.previous)
+            $currentPatch = [Convert]::ToInt32($Matches.current)
+            if ($currentPatch -gt $previousPatch) {
+              $isVersionBumped = $true
+            }
+          } catch {
+            Write-Host "An error occurred during conversion: $_"
+          }
+        }
+      }
 
-#       if (!($isInitialCommit -or $isVersionBumped)) {
-#         throw "Hello! I noticed that you're targeting one of our servicing branches. You need to increase the revision version number (the last part) of 'VersionPrefix' in eng/Versions.props."
-#       }
-#     condition: startsWith(variables['System.PullRequest.TargetBranch'], 'vs')
-#     displayName: "Check if patch version is bumped up"
+      if (!($isInitialCommit -or $isVersionBumped)) {
+        throw "Hello! I noticed that you're targeting one of our servicing branches. You need to increase the revision version number (the last part) of 'VersionPrefix' in eng/Versions.props."
+      }
+    condition: startsWith(variables['System.PullRequest.TargetBranch'], 'vs')
+    displayName: "Check if patch version is bumped up"
 
 - job: IfOnlyDocumentionChanged
   displayName: "Check whether Test Results need to be executed"
@@ -294,7 +294,7 @@ jobs:
         Token: $(dn-bot-dnceng-artifact-feeds-rw)
   - bash: . 'eng/cibuild_bootstrapped_msbuild.sh' --onlyDocChanged $(onlyDocChanged)
     displayName: CI Build
-    env: 
+    env:
         MSBUILDUSESERVER: "1"
   - task: PublishTestResults@2
     displayName: Publish .NET Test Results
@@ -361,7 +361,7 @@ jobs:
         Token: $(dn-bot-dnceng-artifact-feeds-rw)
   - bash: . 'eng/cibuild_bootstrapped_msbuild.sh' --onlyDocChanged $(onlyDocChanged)
     displayName: CI Build
-    env: 
+    env:
         MSBUILDUSESERVER: "1"
   - task: PublishTestResults@2
     displayName: Publish .NET Test Results
diff --git a/Directory.Build.targets b/Directory.Build.targets
index f2c71b74a0e..3538e50a581 100644
--- a/Directory.Build.targets
+++ b/Directory.Build.targets
@@ -7,6 +7,11 @@
     <Description Condition="'$(Description)' == ''">$(TargetFileName)</Description>
   </PropertyGroup>
 
+  <!-- Disable package validation as source build filters out target frameworks. -->
+  <PropertyGroup Condition="'$(DotNetBuildSourceOnly)' == 'true'">
+    <EnablePackageValidation>false</EnablePackageValidation>
+  </PropertyGroup>
+
   <ItemGroup Condition=" '$(IsPackable)' == 'true' ">
     <None Include="$(ThirdPartyNotice)" Pack="true" PackagePath="notices" Visible="false" />
     <None Include="README.md" Pack="true" PackagePath="\" />
diff --git a/azure-pipelines/vs-insertion-experimental.yml b/azure-pipelines/vs-insertion-experimental.yml
index 965ceb7d478..ab2ce364131 100644
--- a/azure-pipelines/vs-insertion-experimental.yml
+++ b/azure-pipelines/vs-insertion-experimental.yml
@@ -2,16 +2,6 @@
 trigger: none
 name: $(Date:yyyyMMdd).$(Rev:r)
 
-# Since our release branch is the one flowing into main
-# we will keep our main experimental insertions to make sure everything is alright
-schedules:
-  - cron: '0 3 * * 1,3,5' # Runs every Monday, Wednesday and Friday at 3AM UTC
-    displayName: Experimental VS insertion main
-    branches:
-      include:
-        - main
-    always: false # Don't run if there are no code changes
-    
 resources:
   pipelines:
   - pipeline: 'MSBuild'
diff --git a/azure-pipelines/vs-insertion.yml b/azure-pipelines/vs-insertion.yml
index 2f2046c4687..2f8d8732f04 100644
--- a/azure-pipelines/vs-insertion.yml
+++ b/azure-pipelines/vs-insertion.yml
@@ -12,13 +12,13 @@ trigger: none
 pr: none
 name: $(Date:yyyyMMdd).$(Rev:r)
 
-# schedules:
-#   - cron: '0 3 * * 1-5' # Runs every weekday at 3AM UTC
-#     displayName: Daily VS insertion main
-#     branches:
-#       include:
-#         - main
-#     always: false # Don't run if there are no code changes
+schedules:
+  - cron: '0 3 * * 1-5' # Runs every weekday at 3AM UTC
+    displayName: Daily VS insertion main
+    branches:
+      include:
+        - main
+    always: false # Don't run if there are no code changes
 
 resources:
   pipelines:
@@ -66,7 +66,7 @@ variables:
   # `auto` should work every time and selecting a branch in parameters is likely to fail due to incompatible versions in MSBuild and VS
   - name: AutoInsertTargetBranch
     ${{ if eq(variables['Build.SourceBranchName'], 'vs17.14') }}:
-      value: 'main'
+      value: 'rel/d17.14'
     ${{ elseif eq(variables['Build.SourceBranchName'], 'vs17.13') }}:
       value: 'rel/d17.13'
     ${{ elseif eq(variables['Build.SourceBranchName'], 'vs17.12') }}:
diff --git a/documentation/specs/BuildCheck/Codes.md b/documentation/specs/BuildCheck/Codes.md
index e9a4c04a20f..2f0d197c2b1 100644
--- a/documentation/specs/BuildCheck/Codes.md
+++ b/documentation/specs/BuildCheck/Codes.md
@@ -16,7 +16,7 @@ Report codes are chosen to conform to suggested guidelines. Those guidelines are
 | [BC0202](#bc0202---property-first-declared-after-it-was-used) | Warning | Project | 9.0.100 | Property first declared after it was used. |
 | [BC0203](#bc0203----property-declared-but-never-used) | None | Project | 9.0.100 | Property declared but never used. |
 | [BC0301](#bc0301---building-from-downloads-folder) | None | Project | 9.0.300 | Building from Downloads folder. |
-
+| [BC0302](#bc0302---building-using-the-exec-task) | Warning | N/A | 9.0.300 | Building using the Exec task. |
 
 Notes: 
  * What does the 'N/A' scope mean? The scope of checks are only applicable and configurable in cases where evaluation-time data are being used and the source of the data is determinable and available. Otherwise the scope of whole build is always checked.
@@ -137,7 +137,6 @@ dotnet build my-multi-target.csproj /p:TargetFramework=net9.0
 
 Make sure the Target Framework is specified appropriately for your project.
 
-
 <a name="BC0201"></a>
 ## BC0201 - Usage of undefined property.
 
@@ -197,6 +196,13 @@ Placing project files into Downloads folder (or any other folder that cannot be
 
 Place your projects into trusted locations - including cases when you intend to only open the project in IDE.
 
+<a name="BC0302"></a>
+## BC0302 - Building using the Exec task.
+
+"The 'Exec' task should not be used to build projects."
+
+Building projects using the dotnet/msbuild/nuget CLI in the `Exec` task is not recommended, as it spawns a separate build process that the MSBuild engine cannot track. Please use the [MSBuild task](https://learn.microsoft.com/visualstudio/msbuild/msbuild-task) instead.
+
 <BR/>
 <BR/>
 <BR/>
diff --git a/documentation/specs/VS-OpenTelemetry.md b/documentation/specs/VS-OpenTelemetry.md
new file mode 100644
index 00000000000..59d1f6e5d17
--- /dev/null
+++ b/documentation/specs/VS-OpenTelemetry.md
@@ -0,0 +1,198 @@
+# Telemetry via OpenTelemetry design
+
+VS OTel provide packages compatible with ingesting data to their backend if we instrument it via OpenTelemetry traces (System.Diagnostics.Activity).
+VS OTel packages are not open source so we need to conditionally include them in our build only for VS and MSBuild.exe
+
+> this formatting is a comment describing how the implementation turned out in 17.14 when our original goals were different
+
+[Onepager](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/telemetry-onepager.md)
+
+## Concepts
+
+It's a bit confusing how things are named in OpenTelemetry and .NET and VS Telemetry and what they do.
+
+| OTel concept | .NET/VS | Description |
+| --- | --- | --- |
+| Span/Trace | System.Diagnostics.Activity |  Trace is a tree of Spans. Activities can be nested.|
+| Tracer | System.Diagnostics.ActivitySource | Creates activites.  |
+| Processor/Exporter | VS OTel provided default config | filters and saves telemetry as files in a desired format |
+| TracerProvider | OTel SDK TracerProvider | Singleton that is aware of processors, exporters and Tracers and listens (in .NET a bit looser relationship because it does not create Tracers just hooks to them) |
+| Collector | VS OTel Collector | Sends to VS backend |
+
+## Requirements
+
+### Performance
+
+- If not sampled, no infra initialization overhead.
+- Avoid allocations when not sampled.
+- Has to have no impact on Core without opting into tracing, small impact on Framework
+- No regression in VS perf ddrit scenarios.
+
+> there is an allocation regression when sampled, one of the reasons why it's not enabled by default
+
+### Privacy
+
+- Hashing data points that could identify customers (e.g. names of targets)
+- Opt out capability
+
+### Security
+
+- Providing or/and documenting a method for creating a hook in Framework MSBuild
+- If custom hooking solution will be used - document the security implications of hooking custom telemetry Exporters/Collectors in Framework
+- other security requirements (transportation, rate limiting, sanitization, data access) are implemented by VS Telemetry library or the backend
+
+> hooking in Framework not implemented
+
+### Data handling
+
+- Implement head [Sampling](https://opentelemetry.io/docs/concepts/sampling/) with the granularity of a MSBuild.exe invocation/VS instance.
+- VS Data handle tail sampling in their infrastructure not to overwhelm storage with a lot of build events.
+
+#### Data points
+
+The data sent via VS OpenTelemetry is neither a subset neither a superset of what is sent to SDK telemetry and it is not a purpose of this design to unify them.
+
+##### Basic info
+
+- Build duration
+- Host
+- Build success/failure
+- Version
+- Target (hashed)
+
+##### Evnironment
+
+- SAC (Smart app control) enabled
+
+##### Features
+
+- BuildCheck enabled
+- Tasks runtimes and memory usage
+- Tasks summary - whether they come from Nuget or are custom
+- Targets summary - how many loaded and executed, how many come from nuget, how many come from metaproject
+
+The design should allow for easy instrumentation of additional data points.
+> current implementation has only one datapoint and that is the whole build `vs/msbuild/build`, the instrumentaiton of additional datapoints is gated by first checking that telemetry is running and using `Activity` classes only in helper methods gated by `[MethodImpl(MethodImplOptions.NoInlining)]` to avoid System.Diagnostics.DiagnosticSource dll load.
+
+## Core `dotnet build` scenario
+
+- Telemetry should not be collected via VS OpenTelemetry mechanism because it's already collected in sdk.
+- opt in to initialize the ActivitySource to avoid degrading performance.
+- [baronfel/otel-startup-hook: A .NET CLR Startup Hook that exports OpenTelemetry metrics via the OTLP Exporter to an OpenTelemetry Collector](https://github.com/baronfel/otel-startup-hook/) and similar enable collecting telemetry data locally by listening to the ActivitySource prefix defined in MSBuild.
+
+> this hook can be used when the customer specifies that they want to listen to the prefix `Microsoft.VisualStudio.OpenTelemetry.MSBuild`, opt in by setting environment variables `MSBUILD_TELEMETRY_OPTIN=1`,`MSBUILD_TELEMETRY_SAMPLE_RATE=1.0`
+
+## Standalone MSBuild.exe scenario
+
+- Initialize and finalize in Xmake.cs
+ ActivitySource, TracerProvider, VS Collector
+- overhead of starting VS collector is nonzero
+- head sampling should avoid initializing if not sampled
+
+## VS in proc (devenv) scenario
+
+- VS can call `BuildManager` in a thread unsafe way the telemetry implementation has to be mindful of [BuildManager instances acquire its own BuildTelemetry instance by rokonec · Pull Request #8444 · dotnet/msbuild](https://github.com/dotnet/msbuild/pull/8444)
+  - ensure no race conditions in initialization
+  - only 1 TracerProvider with VS defined processing should exist
+- Visual Studio should be responsible for having a running collector, we don't want this overhead in MSBuild and eventually many will use it
+
+> this was not achieved in 17.14 so we start collector every time
+
+## Implementation and MSBuild developer experience
+
+### ActivitySource names
+
+- Microsoft.VisualStudio.OpenTelemetry.MSBuild.Default
+
+### Sampling
+
+Our estimation from VS and SDK data is that there are 10M-100M build events per day.
+For proportion estimation (of fairly common occurence in the builds), with not very strict confidnece (95%) and margin for error (5%) sampling 1:25000 would be enough.
+
+- this would apply for the DefaultActivitySource
+- other ActivitySources could be sampled more frequently to get enough data
+- Collecting has a cost, especially in standalone scenario where we have to start the collector. We might decide to undersample in standalone to avoid performance frequent impact.
+- We want to avoid that cost when not sampled, therefore we prefer head sampling.
+- Enables opt-in and opt-out for guaranteed sample or not sampled.
+- nullable ActivitySource, using `?` when working with them, we can be initialized but not sampled -> it will not reinitialize but not collect telemetry.
+
+- for 17.14 we can't use the new OTel assemblies and their dependencies, so everything has to be opt in.
+- eventually OpenTelemetry will be available and usable by default
+- We can use experiments in VS to pass the environment variable to initialize
+
+> Targeted notification can be set that samples 100% of customers to which it is sent
+
+### Initialization at entrypoints
+
+- There are 2 entrypoints:
+  - for VS in BuildManager.BeginBuild
+  - for standalone in Xmake.cs Main
+
+### Exiting
+
+Force flush TracerProvider's exporter in BuildManager.EndBuild.
+Dispose collector in Xmake.cs at the end of Main.
+
+### Configuration
+
+- Class that's responsible for configuring and initializing telemetry and handles optouts, holding tracer and collector.
+- Wrapping source so that it has correct prefixes for VS backend to ingest.
+
+### Instrumenting
+
+2 ways of instrumenting:
+
+#### Instrument areas in code running in the main process
+
+```csharp
+using (Activity? myActivity = OpenTelemetryManager.DefaultActivitySource?.StartActivity(TelemetryConstants.NameFromAConstantToAvoidAllocation))
+{
+// something happens here
+
+// add data to the trace
+myActivity?.WithTag("SpecialEvent","fail")
+}
+```
+
+Interface for classes holding telemetry data
+
+```csharp
+IActivityTelemetryDataHolder data = new SomeData();
+...
+myActivity?.WithTags(data);
+```
+
+> currently this should be gated in a separate method to avoid System.DiagnosticDiagnosticsource dll load.
+
+#### Default Build activity in EndBuild
+
+- this activity would always be created at the same point when sdk telemetry is sent in Core
+- we can add data to it that we want in general builds
+- the desired count of data from this should control the sample rate of DefaultActivitySource
+
+#### Multiple Activity Sources
+
+We want to create ActivitySources with different sample rates, this requires either implementation server side or a custom Processor.
+
+We potentially want apart from the Default ActivitySource:
+
+1. Other activity sources with different sample rates (in order to get significant data for rarer events such as custom tasks).
+2. a way to override sampling decision - ad hoc starting telemetry infrastructure to catch rare events
+
+- Create a way of using a "HighPrioActivitySource" which would override sampling and initialize Collector in MSBuild.exe scenario/tracerprovider in VS.
+- this would enable us to catch rare events
+
+> not implemented
+
+### Implementation details
+
+- `OpenTelemetryManager` - singleton that manages lifetime of OpenTelemetry objects listening to `Activity`ies, start by initializing in `Xmake` or `BuildManager`.
+- Task and Target data is forwarded from worker nodes via `TelemetryForwarder` and `InternalTelemetryForwardingLogger` and then aggregated to stats and serialized in `TelemetryDataUtils` and attached to the default `vs/msbuild/build` event.
+
+## Future work when/if we decide to invest in telemetry again
+
+- avoid initializing/finalizing collector in VS when there is one running
+- multiple levels of sampling for different types of events
+- running by default with head sampling (simplifies instrumentation with `Activity`ies)
+- implement anonymization consistently in an OTel processor and not ad hoc in each usage
+- add datapoints helping perf optimization decisions/ reliability investigations
diff --git a/documentation/specs/custom-cultures.md b/documentation/specs/custom-cultures.md
new file mode 100644
index 00000000000..a3e683c25e4
--- /dev/null
+++ b/documentation/specs/custom-cultures.md
@@ -0,0 +1,42 @@
+# MSBuild Custom Cultures Support
+
+## Overview
+
+The `EnableCustomCulture` property provides an opt-in mechanism for handling custom culture-specific resources in MSBuild projects. This feature allows for greater control over which directories are treated as culture-specific resources during the build process.
+
+## Purpose
+
+In some projects, directory names that match culture name patterns might not actually be culture resources. This can cause issues with resource compilation and deployment. This feature flag enables:
+
+1. Control over whether custom culture detection is enabled
+2. Fine-grained configuration of which directories should be excluded from culture-specific resource processing
+
+## Usage
+
+### Enabling the Feature
+
+To enable the custom cultures feature, set the `EnableCustomCulture` property `true`.
+
+```xml
+<PropertyGroup>
+  <EnableCustomCulture>true</EnableCustomCulture>
+</PropertyGroup>
+```
+
+### Excluding Specific Directories
+
+When the feature is enabled, you can specify directories that should not be treated as culture-specific resources using the `NonCultureResourceDirectories` property:
+
+```xml
+<PropertyGroup>
+  <NonCultureResourceDirectories>long;hash;temp</NonCultureResourceDirectories>
+</PropertyGroup>
+```
+
+In this example, directories named "long", "hash", or "temp" will not be processed as culture-specific resources and the assemblied inside of them will be skipped, even if their names match culture naming patterns. Globbing is not supported.
+
+## Additional Notes
+
+- This feature does not affect the standard resource handling for well-known cultures.
+- The feature is designed to be backward compatible - existing projects without the feature flag will behave the same as before.
+- Performance impact is minimal, as the exclusion check happens only during the resource discovery phase of the build.
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 6b88ed66097..833299ed296 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -26,7 +26,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 
 ### 17.14
 - ~[.SLNX support - use the new parser for .sln and .slnx](https://github.com/dotnet/msbuild/pull/10836)~ reverted after compat problems discovered
-- [Support custom culture in RAR](https://github.com/dotnet/msbuild/pull/11000)
+- ~~[Support custom culture in RAR](https://github.com/dotnet/msbuild/pull/11000)~~ - see [11607](https://github.com/dotnet/msbuild/pull/11607) for details
 - [VS Telemetry](https://github.com/dotnet/msbuild/pull/11255)
 
 ### 17.12
diff --git a/eng/BootStrapMsBuild.targets b/eng/BootStrapMsBuild.targets
index d4330ba658d..4789ffcec85 100644
--- a/eng/BootStrapMsBuild.targets
+++ b/eng/BootStrapMsBuild.targets
@@ -63,14 +63,27 @@
     </ItemGroup>
   </Target>
 
+  <!-- The task allows to find VS bits on machine. These files will be used as a source for patching on the top of them. -->
+  <UsingTask TaskName="LocateVisualStudioTask"
+             AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"
+             TaskFactory="RoslynCodeTaskFactory">
+    <Task>
+      <Code Source="$(MSBuildThisFileDirectory)..\src\MSBuild.Bootstrap.Utils\Tasks\LocateVisualStudioTask.cs" Language="cs" />
+    </Task>
+  </UsingTask>
   <Target Name="BootstrapFull" DependsOnTargets="CleanBootstrapFolder;SetBinPaths;GatherNuGetDependencies">
+
+      <LocateVisualStudioTask>
+        <Output TaskParameter="VsInstallPath" PropertyName="AvailableVsInstallPath" />
+      </LocateVisualStudioTask>
+
     <ItemGroup>
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\*.targets" />
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\*.props" />
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\Tracker*.dll" />
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\Tracker*.exe" />
       <InstalledVersionedExtensions Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\**\FileTracker*.dll" />
-      <SdkResolverFiles Include="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\**\*.*" />
+      <SdkResolverFiles Include="$(AvailableVsInstallPath)\MSBuild\Current\Bin\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\**\*.*" />
       <NuGetSdkResolverManifest Include="$(RepoRoot)src\MSBuild\SdkResolvers\VS\Microsoft.Build.NuGetSdkResolver.xml" />
       <InstalledSdks Include="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\Sdks\**\*.*" />
 
diff --git a/eng/Build.props b/eng/Build.props
index 591a4d41340..fec5d08db7d 100644
--- a/eng/Build.props
+++ b/eng/Build.props
@@ -6,11 +6,12 @@
   </PropertyGroup>
 
   <ItemGroup>
-	<!-- Remove all sln files globbed by arcade so far and add only MSBuild.sln to the build.
-	Without this, arcade tries to build all three MSBuild solution at once, which leads to
-	locked file errors. -->
+    <!-- Remove all sln files globbed by arcade so far and add only MSBuild.sln to the build.
+         Without this, arcade tries to build all three MSBuild solution at once, which leads to
+         locked file errors. -->
     <ProjectToBuild Remove="@(ProjectToBuild)" />
-    <ProjectToBuild Include="$(RepoRoot)MSBuild.sln" />
+    <ProjectToBuild Include="$(RepoRoot)MSBuild.sln" Condition="'$(DotNetBuildSourceOnly)' != 'true'" />
+    <ProjectToBuild Include="$(RepoRoot)MSBuild.SourceBuild.slnf" Condition="'$(DotNetBuildSourceOnly)' == 'true'" />
   </ItemGroup>
 
 </Project>
diff --git a/eng/DotNetBuild.props b/eng/DotNetBuild.props
index 778419d070a..87db021212d 100644
--- a/eng/DotNetBuild.props
+++ b/eng/DotNetBuild.props
@@ -1,21 +1,13 @@
 <!-- When altering this file, include @dotnet/product-construction as a reviewer. -->
-
 <Project>
 
+  <!-- TODO: Remove this file when msbuild upgrades to Arcade 10 -->
   <PropertyGroup>
     <GitHubRepositoryName>msbuild</GitHubRepositoryName>
     <SourceBuildManagedOnly>true</SourceBuildManagedOnly>
+    <ReportPrebuiltUsage Condition="'$(DotNetBuildSourceOnly)' == 'true'">$(DotNetBuildOrchestrator)</ReportPrebuiltUsage>
+    <SetUpSourceBuildIntermediateNupkgCache>false</SetUpSourceBuildIntermediateNupkgCache>
+    <CreateIntermediatePackage>false</CreateIntermediatePackage>
   </PropertyGroup>
 
-  <Target Name="ConfigureInnerBuildArgs" BeforeTargets="GetSourceBuildCommandConfiguration"
-          Condition="'$(DotNetBuildSourceOnly)' == 'true'">
-    <PropertyGroup>
-      <!-- Filter down projects aggressively in source-only modes. -->
-      <InnerBuildArgs>$(InnerBuildArgs) /p:Projects="$(InnerSourceBuildRepoRoot)MSBuild.SourceBuild.slnf"</InnerBuildArgs>
-
-      <!-- Disable package validation as source build filters out target frameworks. -->
-      <InnerBuildArgs>$(InnerBuildArgs) /p:EnablePackageValidation=false</InnerBuildArgs>
-    </PropertyGroup>
-  </Target>
-
 </Project>
diff --git a/eng/Packages.props b/eng/Packages.props
index 6afcad00799..456f037819e 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -34,6 +34,7 @@
     <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
     <PackageVersion Include="System.Threading.Channels" Version="$(SystemThreadingChannelsVersion)" />
     <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
+    <PackageVersion Include="System.Threading.Tasks.Extensions" Version="$(SystemThreadingTasksExtensionsVersion)" />
     <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
     <PackageVersion Include="Microsoft.VisualStudio.OpenTelemetry.Collector" Version="$(MicrosoftVisualStudioOpenTelemetryVersion)" />
     <PackageVersion Include="Microsoft.VisualStudio.OpenTelemetry.ClientExtensions" Version="$(MicrosoftVisualStudioOpenTelemetryVersion)" />
diff --git a/eng/Publishing.props b/eng/Publishing.props
index 6db69f7afa9..5f9650d32dc 100644
--- a/eng/Publishing.props
+++ b/eng/Publishing.props
@@ -1,6 +1,9 @@
-<?xml version="1.0" encoding="utf-8"?>
 <Project>
-    <PropertyGroup>
-        <PublishingVersion>3</PublishingVersion>
-    </PropertyGroup>
-</Project>
\ No newline at end of file
+
+  <!-- Update Artifacts with Kind=Package to have additional metadata item Category="ToolingPackage".
+       Depending on channel configuration, this means that these assets could be pushed to a different feed. -->
+  <ItemGroup>
+    <Artifact Update="@(Artifact->WithMetadataValue('Kind', 'Package'))" Category="ToolingPackage" />
+  </ItemGroup>
+
+</Project>
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
deleted file mode 100644
index 6bf7dfcbf3a..00000000000
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ /dev/null
@@ -1,32 +0,0 @@
-<!-- When altering this file or making other Source Build related changes, include @dotnet/source-build as a reviewer. -->
-<!-- See aka.ms/dotnet/prebuilts for guidance on what pre-builts are and how to eliminate them. -->
-
-<UsageData>
-  <IgnorePatterns>
-    <!-- 9.0 packages are not allowed in the 9.0 build, because they're not "current", so baseline them. -->
-    <UsagePattern IdentityGlob="System.CodeDom/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Collections.Immutable/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Diagnostics.DiagnosticSource/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Formats.Asn1/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Reflection.Metadata/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Resources.Extensions/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Encoding.CodePages/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Json/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Threading.Channels/*9.0.0*" />
-    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*9.0.0*" />
-
-    <!-- dependency of System.Configuration.ConfigurationManager -->
-    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*9.0.0*" />
-    <!-- dependency of System.Resources.Extensions -->
-    <UsagePattern IdentityGlob="System.Formats.Nrbf/*9.0.0*" />
-    <!-- dependency of System.Security.Cryptography.Pkcs -->
-    <UsagePattern IdentityGlob="Microsoft.Bcl.Cryptography/*9.0.0*" />
-  </IgnorePatterns>
-  <Usages>
-  </Usages>
-</UsageData>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index d9ade9bf3bb..53c6c9b6ce2 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,18 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
+  <Source Uri="https://github.com/dotnet/dotnet" Mapping="msbuild" Sha="721dc7a2a59416b21fc49447d264009d708d6000" BarId="265489" />
   <ProductDependencies>
-    <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="9.0.0-alpha.1.25170.3">
-      <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>6968f7059f4418e985febe704a3b1320f9e5887d</Sha>
-      <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
-    </Dependency>
-    <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-externals" Version="9.0.0-alpha.1.25160.2">
-      <Uri>https://github.com/dotnet/source-build-externals</Uri>
-      <Sha>e2c3c1329ea432b36e4570d977271454e8abb0a0</Sha>
-      <SourceBuild RepoName="source-build-externals" ManagedOnly="true" />
-    </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
     <Dependency Name="Microsoft.Bcl.Cryptography" Version="9.0.0">
       <Uri>https://github.com/dotnet/runtime</Uri>
@@ -123,36 +112,21 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25164.2">
-      <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
-    </Dependency>
-    <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.25164.2">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25255.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
-      <SourceBuild RepoName="arcade" ManagedOnly="true" />
+      <Sha>1cfa39f82d00b3659a3d367bc344241946e10681</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.25164.2">
-      <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
-    </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.14.0-preview.1.89">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.15.0-preview.1.50">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>13550619f90e73a1f8b4b5159c6d7f268c9756d0</Sha>
-    </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-3.25179.1">
-      <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>304768b76e90f5d224b745e3a03cfc5e9509baf6</Sha>
+      <Sha>e4e3b79701686199bc804a06533d2df054924d7e</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.14.0-3.25179.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-3.25229.6">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>304768b76e90f5d224b745e3a03cfc5e9509baf6</Sha>
-      <SourceBuild RepoName="roslyn" ManagedOnly="true" />
+      <Sha>871ef6369443071681de3351d30f41ea78ab48e6</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25164.2">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25255.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
+      <Sha>1cfa39f82d00b3659a3d367bc344241946e10681</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index b2510945229..da16859c07e 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -20,7 +20,6 @@
   <PropertyGroup>
     <UsingToolIbcOptimization>true</UsingToolIbcOptimization>
     <UsingToolVisualStudioIbcTraining>true</UsingToolVisualStudioIbcTraining>
-    <UsingToolMicrosoftNetCompilers>true</UsingToolMicrosoftNetCompilers>
     <UsingToolSymbolUploader>true</UsingToolSymbolUploader>
     <UsingToolVSSDK>true</UsingToolVSSDK>
   </PropertyGroup>
@@ -29,26 +28,22 @@
        This is to prevent "package downgrade" errors coming from other packages that are
        already consuming the newest version of these same dependencies. -->
   <PropertyGroup Condition="'$(DotNetBuildSourceOnly)' == 'true'">
-    <!-- Use newest package versions. -->
-    <SystemMemoryVersion>4.6.2</SystemMemoryVersion>
-    <SystemRuntimeCompilerServicesUnsafeVersion>6.1.1</SystemRuntimeCompilerServicesUnsafeVersion>
-    <MicrosoftIORedistVersion>6.1.2</MicrosoftIORedistVersion>
+    <MicrosoftIORedistVersion>6.1.3</MicrosoftIORedistVersion>
+    <SystemMemoryVersion>4.6.3</SystemMemoryVersion>
+    <SystemRuntimeCompilerServicesUnsafeVersion>6.1.2</SystemRuntimeCompilerServicesUnsafeVersion>
+    <SystemThreadingTasksExtensionsVersion>4.6.3</SystemThreadingTasksExtensionsVersion>
   </PropertyGroup>
   <PropertyGroup Condition="'$(DotNetBuildSourceOnly)' != 'true'">
-    <!-- Keep using older versions. Upgrade carefully. -->
+    <MicrosoftIORedistVersion>6.1.0</MicrosoftIORedistVersion>
     <!--
         Modifying the version of System.Memory is very high impact and causes downstream breaks in third-party tooling that uses the MSBuild API.
-        When updating the version of System.Memory file a breaking change here: https://github.com/dotnet/docs/issues/new?assignees=gewarren&labels=breaking-change%2CPri1%2Cdoc-idea&template=breaking-change.yml&title=%5BBreaking+change%5D%3A+
-        and follow the guidelines written here (internal-link): https://dev.azure.com/devdiv/DevDiv/_wiki/wikis/DevDiv.wiki/1796/How-to-add-a-Known-Issue
+        As a result, we CONTINUE TO REFERENCE the old versions at build time, so those are the versions that get embedded into MSBuild assemblies.
+        However, we can update, binding-redirect to, and distribute the newest version (that matches the VS-referenced versions) in order to get the benefits of updating.
+        See uses of $(UseFrozenMaintenancePackageVersions) for details.
     -->
-    <SystemMemoryVersion>4.5.5</SystemMemoryVersion>
-    <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
-    <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
-  </PropertyGroup>
-  <PropertyGroup>
-    <!-- manually maintained versions -->
-    <MicrosoftVisualStudioOpenTelemetryVersion>0.2.104-beta</MicrosoftVisualStudioOpenTelemetryVersion>
-    <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
+    <SystemMemoryVersion>4.6.0</SystemMemoryVersion>
+    <SystemRuntimeCompilerServicesUnsafeVersion>6.1.0</SystemRuntimeCompilerServicesUnsafeVersion>
+    <SystemThreadingTasksExtensionsVersion>4.6.0</SystemThreadingTasksExtensionsVersion>
   </PropertyGroup>
   <PropertyGroup>
     <!-- dotnet/runtime packages -->
@@ -62,12 +57,14 @@
     <SystemReflectionMetadataLoadContextVersion>9.0.0</SystemReflectionMetadataLoadContextVersion>
     <SystemResourcesExtensionsVersion>9.0.0</SystemResourcesExtensionsVersion>
     <SystemSecurityCryptographyProtectedDataVersion>9.0.0</SystemSecurityCryptographyProtectedDataVersion>
+    <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
     <SystemTextEncodingCodePagesVersion>9.0.0</SystemTextEncodingCodePagesVersion>
     <SystemTextJsonVersion>9.0.0</SystemTextJsonVersion>
     <SystemThreadingChannelsVersion>9.0.0</SystemThreadingChannelsVersion>
     <SystemThreadingTasksDataflowVersion>9.0.0</SystemThreadingTasksDataflowVersion>
   </PropertyGroup>
   <PropertyGroup>
+    <MicrosoftVisualStudioOpenTelemetryVersion>0.2.104-beta</MicrosoftVisualStudioOpenTelemetryVersion>
     <!-- maintained in eng/dependabot/Packages.props -->
     <!--
     <SystemCodeDomVersion></SystemCodeDomVersion>
@@ -83,12 +80,12 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25164.2</MicrosoftDotNetXUnitExtensionsVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.14.0-3.25179.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.14.0-preview.1.89</NuGetBuildTasksVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25255.5</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.14.0-3.25229.6</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.15.0-preview.1.50</NuGetBuildTasksVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
-    <BootstrapSdkVersion>9.0.200-preview.0.24603.3</BootstrapSdkVersion>
+    <BootstrapSdkVersion>9.0.203</BootstrapSdkVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/common/core-templates/job/source-build.yml b/eng/common/core-templates/job/source-build.yml
index c4713c8b6ed..d47f09d58fd 100644
--- a/eng/common/core-templates/job/source-build.yml
+++ b/eng/common/core-templates/job/source-build.yml
@@ -26,6 +26,8 @@ parameters:
   #   Specifies the build script to invoke to perform the build in the repo. The default
   #   './build.sh' should work for typical Arcade repositories, but this is customizable for
   #   difficult situations.
+  # buildArguments: ''
+  #   Specifies additional build arguments to pass to the build script.
   # jobProperties: {}
   #   A list of job properties to inject at the top level, for potential extensibility beyond
   #   container and pool.
diff --git a/eng/common/core-templates/job/source-index-stage1.yml b/eng/common/core-templates/job/source-index-stage1.yml
index 205fb5b3a39..8b833332b3e 100644
--- a/eng/common/core-templates/job/source-index-stage1.yml
+++ b/eng/common/core-templates/job/source-index-stage1.yml
@@ -1,7 +1,7 @@
 parameters:
   runAsPublic: false
-  sourceIndexUploadPackageVersion: 2.0.0-20240522.1
-  sourceIndexProcessBinlogPackageVersion: 1.0.1-20240522.1
+  sourceIndexUploadPackageVersion: 2.0.0-20250425.2
+  sourceIndexProcessBinlogPackageVersion: 1.0.1-20250425.2
   sourceIndexPackageSource: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json
   sourceIndexBuildCommand: powershell -NoLogo -NoProfile -ExecutionPolicy Bypass -Command "eng/common/build.ps1 -restore -build -binarylog -ci"
   preSteps: []
diff --git a/eng/common/core-templates/steps/source-build.yml b/eng/common/core-templates/steps/source-build.yml
index 2915d29bb7f..37133b55b75 100644
--- a/eng/common/core-templates/steps/source-build.yml
+++ b/eng/common/core-templates/steps/source-build.yml
@@ -79,6 +79,7 @@ steps:
     ${{ coalesce(parameters.platform.buildScript, './build.sh') }} --ci \
       --configuration $buildConfig \
       --restore --build --pack $publishArgs -bl \
+      ${{ parameters.platform.buildArguments }} \
       $officialBuildArgs \
       $internalRuntimeDownloadArgs \
       $internalRestoreArgs \
diff --git a/global.json b/global.json
index e2e3c22ae34..ebc227f25dd 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "9.0.104",
+    "dotnet": "9.0.105",
     "vs": {
       "version": "17.12.0"
     },
     "xcopy-msbuild": "17.12.0"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25164.2"
+    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25255.5"
   }
 }
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
index bd2346f8b43..1db628811a0 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
@@ -207,8 +207,7 @@ public ElementLinkPair<CT> QuerySingleChildrenWithValidation<CT>(Func<T, IEnumer
 
     internal sealed class ProjectXmlPair : ElementLinkPair<ProjectRootElement>
     {
-        private ProjectPair Project { get; }
-        public ProjectXmlPair(ProjectPair pair) : base(null, pair.View.Xml, pair.Real.Xml) { this.Project = pair; this.PRE = this; }
+        public ProjectXmlPair(ProjectPair pair) : base(null, pair.View.Xml, pair.Real.Xml) { this.PRE = this; }
         public ProjectXmlPair(ProjectRootElement viewXml, ProjectRootElement realXml) : base(null, viewXml, realXml) { this.PRE = this; }
 
         public ElementLinkPair<CT> CreateWithVerify<CT>(Func<ProjectRootElement, CT> creator)
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs
index f8d3cb321d5..a723c355ad9 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs
@@ -40,12 +40,5 @@ public RemotedResolvedImport(ResolvedImport resolvedImport, ProjectCollectionLin
         public SdkResult SdkResult { get; }
 
         public bool IsImported { get; }
-
-        private ResolvedImport Import(ProjectCollectionLinker importer)
-        {
-            var importElement = (ProjectImportElement)importer.Import<ProjectElement, MockProjectImportElementLinkRemoter>(this.ImportingElement);
-            var projectElement = (ProjectRootElement)importer.Import<ProjectElement, MockProjectRootElementLinkRemoter>(this.ImportedProject);
-            return importer.LinkFactory.Create(importElement, projectElement, 0, this.SdkResult, this.IsImported);
-        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index 9a0bb05138a..fcf4e5a1e54 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -424,6 +424,417 @@ public void TestSerializeArrayWithFactoryNull()
             Assert.True(TranslationHelpers.CompareCollections(value, deserializedValue, BaseClass.Comparer));
         }
 
+        /// <summary>
+        /// Tests interning strings within an intern scope.
+        /// </summary>
+        /// <remarks>
+        /// Most of the string intern tests use casing differences to assert whether interning was successful, rather
+        /// than asserting the underlying buffer contents. Although the intended use is to deduplicate many strings of the
+        /// same casing, this is harder to validate this high level, so we focus on testing behavior here.
+        /// </remarks>
+        [Theory]
+        [InlineData("foo", true)]
+        [InlineData("", true)]
+        [InlineData(null, true)]
+        [InlineData("foo", false)]
+        [InlineData("", false)]
+        public void TestInternWithInterning(string value, bool nullable)
+        {
+            // Create a case mismatch to test if the string is deduplicated.
+            string valueUpperCase = value?.ToUpperInvariant();
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref value, nullable);
+                translator.Intern(ref valueUpperCase, nullable);
+            });
+
+            string deserializedValue = null;
+            string deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref deserializedValue, nullable);
+                translator.Intern(ref deserializedValueUpperCase, nullable);
+            });
+
+            // All occurrences should deserialize to the first encountered value.
+            Assert.Equal(value, deserializedValue);
+            Assert.Equal(value, deserializedValueUpperCase);
+        }
+
+        /// <summary>
+        /// Tests interning strings outside of an intern scope.
+        /// All calls should be forwarded to the regular translate method.
+        /// </summary>
+        [Theory]
+        [InlineData("foo", true)]
+        [InlineData("", true)]
+        [InlineData(null, true)]
+        [InlineData("foo", false)]
+        [InlineData("", false)]
+        [InlineData(null, false)]
+        public void TestInternNoInterning(string value, bool nullable)
+        {
+            TranslationHelpers.GetWriteTranslator().Intern(ref value, nullable);
+
+            string deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().Intern(ref deserializedValue, nullable);
+
+            // If we haven't blown up so far, assume we've skipped interning.
+            Assert.Equal(value, deserializedValue);
+        }
+
+        /// <summary>
+        /// Tests interning path-like strings within an intern scope.
+        /// </summary>
+        [Theory]
+        [InlineData(@"C:/src/msbuild/artifacts/bin/SomeProject.Namespace/Debug/net472/SomeProject.NameSpace.dll", true)]
+        [InlineData("foo", true)]
+        [InlineData("", true)]
+        [InlineData(null, true)]
+        [InlineData(@"C:/src/msbuild/artifacts/bin/SomeProject.Namespace/Debug/net472/SomeProject.NameSpace.dll", false)]
+        [InlineData("foo", false)]
+        [InlineData("", false)]
+        public void TestInternPathWithInterning(string value, bool nullable)
+        {
+            // Create a case mismatch to test if the path parts are deduplicated.
+            string valueUpperCase = value?.ToUpperInvariant();
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.InternPath(ref value, nullable);
+                translator.InternPath(ref valueUpperCase, nullable);
+            });
+
+            string deserializedValue = null;
+            string deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.InternPath(ref deserializedValue, nullable);
+                translator.InternPath(ref deserializedValueUpperCase, nullable);
+            });
+
+            // All occurrences should deserialize to the first encountered value.
+            Assert.Equal(value, deserializedValue);
+            Assert.Equal(value, deserializedValueUpperCase);
+        }
+
+        /// <summary>
+        /// Tests interning components in path-like strings.
+        /// </summary>
+        [Fact]
+        public void TestInternPathWithComponentsFirst()
+        {
+            // Create a case mismatch to test if the path parts are deduplicated.
+            string directory = @"C:/SRC/MSBUILD/ARTIFACTS/BIN/SOMEPROJECT.NAMESPACE/DEBUG/NET472/";
+            string fileName = @"SOMEPROJECT.NAMESPACE.DLL";
+            string fullPath = @"C:/src/msbuild/artifacts/bin/SomeProject.Namespace/Debug/net472/SomeProject.NameSpace.dll";
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternPath(ref directory);
+                translator.InternPath(ref fileName);
+                translator.InternPath(ref fullPath);
+            });
+
+            string deserializedDirectory = null;
+            string deserializedFileName = null;
+            string deserializedFullPath = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternPath(ref deserializedDirectory);
+                translator.InternPath(ref deserializedFileName);
+                translator.InternPath(ref deserializedFullPath);
+            });
+
+            // The path components should be reconstructed using the first encountered value.
+            Assert.Equal(directory, deserializedDirectory);
+            Assert.Equal(fileName, deserializedFileName);
+            Assert.Equal(Path.Combine(directory, fileName), deserializedFullPath);
+        }
+
+        /// <summary>
+        /// Tests interning components in path-like strings.
+        /// </summary>
+        [Fact]
+        public void TestInternPathWithFullPathFirst()
+        {
+            // Create a case mismatch to test if the path parts are deduplicated.
+            string fullPath = @"c:/src/msbuild/artifacts/bin/someproject.namespace/debug/net472/someproject.namespace.dll";
+            string directory = @"C:/SRC/MSBUILD/ARTIFACTS/BIN/SOMEPROJECT.NAMESPACE/DEBUG/NET472/";
+            string fileName = @"SOMEPROJECT.NAMESPACE.DLL";
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternPath(ref fullPath);
+                translator.InternPath(ref directory);
+                translator.InternPath(ref fileName);
+            });
+
+            string deserializedFullPath = null;
+            string deserializedDirectory = null;
+            string deserializedFileName = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternPath(ref deserializedFullPath);
+                translator.InternPath(ref deserializedDirectory);
+                translator.InternPath(ref deserializedFileName);
+            });
+
+            // The path components should be reconstructed using the first encountered value.
+            Assert.Equal(fullPath, deserializedFullPath);
+            Assert.Equal(fullPath, Path.Combine(deserializedDirectory, deserializedFileName));
+        }
+
+        /// <summary>
+        /// Tests serializing string arrays within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternStringArrayWithInterning()
+        {
+            // Create a case mismatch to test if the string is deduplicated.
+            string[] value1 = ["foo", "FOO"];
+            string[] value2 = ["Foo", "fOO"];
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref value1);
+                translator.Intern(ref value2);
+            });
+
+            string[] deserializedValue1 = null;
+            string[] deserializedValue2 = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref deserializedValue1);
+                translator.Intern(ref deserializedValue2);
+            });
+
+            // All occurrences should deserialize to the first encountered value.
+            string[] expectedValue = ["foo", "foo"];
+            Assert.True(TranslationHelpers.CompareCollections(expectedValue, deserializedValue1, StringComparer.Ordinal));
+            Assert.True(TranslationHelpers.CompareCollections(expectedValue, deserializedValue2, StringComparer.Ordinal));
+        }
+
+        /// <summary>
+        /// Tests serializing string arrays outside of an intern scope.
+        /// All calls should be forwarded to the regular translate method.
+        /// </summary>
+        [Fact]
+        public void TestInternStringArrayNoInterning()
+        {
+            string[] value1 = ["foo", "FOO"];
+            string[] value2 = ["Foo", "fOO"];
+
+            ITranslator translator = TranslationHelpers.GetWriteTranslator();
+            translator.Intern(ref value1);
+            translator.Intern(ref value2);
+
+            string[] deserializedValue1 = null;
+            string[] deserializedValue2 = null;
+            translator = TranslationHelpers.GetReadTranslator();
+            translator.Intern(ref deserializedValue1);
+            translator.Intern(ref deserializedValue2);
+
+            Assert.True(TranslationHelpers.CompareCollections(value1, deserializedValue1, StringComparer.Ordinal));
+            Assert.True(TranslationHelpers.CompareCollections(value2, deserializedValue2, StringComparer.Ordinal));
+        }
+
+        /// <summary>
+        /// End-to-end test using a mixture of interned and non-interned operations to ensure that we don't hit
+        /// invalid states, as this will be the most common use case.
+        /// </summary>
+        [Fact]
+        public void TestWithInterningMixedUsage()
+        {
+            string value1 = "Foobar";
+            string value2 = "foobar";
+            string valueToIntern = "FooBar";
+            int value3 = 10;
+            string value4 = "fooBar";
+
+            // Create a case mismatch to test if the string is deduplicated.
+            string valueToInternUpperCase = valueToIntern?.ToUpperInvariant();
+            string value5 = "Foo_Bar";
+
+            ITranslator translator = TranslationHelpers.GetWriteTranslator();
+
+            // Interleave interned and non-interned operations.
+            translator.Translate(ref value1);
+            translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Translate(ref value2);
+                translator.Intern(ref valueToIntern);
+                translator.Translate(ref value3);
+                translator.Intern(ref valueToInternUpperCase);
+                translator.Translate(ref value4);
+            });
+            translator.Translate(ref value5);
+
+            string deserializedValue1 = null;
+            string deserializedValue2 = null;
+            string deserializedInternedValue = null;
+            int deserializedValue3 = -1;
+            string deserializedValue4 = null;
+            string deserializedInternedValueUpperCase = null;
+            string deserializedValue5 = null;
+
+            translator = TranslationHelpers.GetReadTranslator();
+
+            // This will only succeed if both translators are correctly sequenced:
+            // packet body -> intern header -> intern body -> packet body.
+            translator.Translate(ref deserializedValue1);
+            translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Translate(ref deserializedValue2);
+                translator.Intern(ref deserializedInternedValue);
+                translator.Translate(ref deserializedValue3);
+                translator.Intern(ref deserializedInternedValueUpperCase);
+                translator.Translate(ref deserializedValue4);
+            });
+            translator.Translate(ref deserializedValue5);
+
+            // All non-interned values should maintain their original casing.
+            Assert.Equal(value1, deserializedValue1);
+            Assert.Equal(value2, deserializedValue2);
+            Assert.Equal(value3, deserializedValue3);
+            Assert.Equal(value4, deserializedValue4);
+            Assert.Equal(value5, deserializedValue5);
+
+            // All interned values should deserialize to the first encountered value.
+            Assert.Equal(valueToIntern, deserializedInternedValue);
+            Assert.Equal(valueToIntern, deserializedInternedValueUpperCase);
+        }
+
+        /// <summary>
+        /// Tests interning path-like strings outside of an intern scope.
+        /// All calls should be forwarded to the regular translate method.
+        /// </summary>
+        [Theory]
+        [InlineData(@"C:/src/msbuild/artifacts/bin/SomeProject.Namespace/Debug/net472/SomeProject.NameSpace.dll", true)]
+        [InlineData("foo", true)]
+        [InlineData("", true)]
+        [InlineData(null, true)]
+        [InlineData("foo", false)]
+        [InlineData(@"C:/src/msbuild/artifacts/bin/SomeProject.Namespace/Debug/net472/SomeProject.NameSpace.dll", false)]
+        [InlineData("", false)]
+        [InlineData(null, false)]
+        public void TestInternPathNoInterning(string value, bool nullable)
+        {
+            TranslationHelpers.GetWriteTranslator().InternPath(ref value, nullable);
+
+            string deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().InternPath(ref deserializedValue, nullable);
+
+            // If we haven't blown up so far, assume we've skipped interning.
+            Assert.Equal(value, deserializedValue);
+        }
+
+        /// <summary>
+        /// Tests no-op when nothing is written to the interner. E.g. a packet opens an intern scope, but none of its
+        /// translatable child objects write anything.
+        /// </summary>
+        [Fact]
+        public void TestWithInterningNoWritesDoesNotThrow()
+        {
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 128, translator =>
+            {
+            });
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 128, translator =>
+            {
+            });
+        }
+
+        /// <summary>
+        /// Tests reusing a translator with different interning comparers.
+        /// This is important if the translator is reused for multiple packet types with different case sensitivity.
+        /// </summary>
+        [Fact]
+        public void TestWithInterningResetsComparerBetweenScopes()
+        {
+            string mixedCaseValue = "StringWithSomeCasing";
+            string lowerCaseValue = "stringwithsomecasing";
+
+            MemoryStream serializationStream = new();
+            ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(serializationStream);
+            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, InterningBinaryReader.PoolingBuffer);
+
+            writeTranslator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref mixedCaseValue);
+                translator.Intern(ref lowerCaseValue);
+            });
+
+            serializationStream.Position = 0;
+
+            string deserializedMixedCaseValue = null;
+            string deserializedLowerCaseValue = null;
+
+            readTranslator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                translator.Intern(ref deserializedMixedCaseValue);
+                translator.Intern(ref deserializedLowerCaseValue);
+            });
+
+            // Only the first casing should be interned.
+            Assert.Equal(mixedCaseValue, deserializedMixedCaseValue);
+            Assert.Equal(mixedCaseValue, deserializedLowerCaseValue);
+
+            // Simulate translator reuse by resetting the underlying stream.
+            serializationStream.Position = 0;
+            serializationStream.SetLength(0);
+
+            writeTranslator.WithInterning(StringComparer.Ordinal, initialCapacity: 2, translator =>
+            {
+                translator.Intern(ref mixedCaseValue);
+                translator.Intern(ref lowerCaseValue);
+            });
+
+            serializationStream.Position = 0;
+
+            readTranslator.WithInterning(StringComparer.Ordinal, initialCapacity: 2, translator =>
+            {
+                translator.Intern(ref deserializedMixedCaseValue);
+                translator.Intern(ref deserializedLowerCaseValue);
+            });
+
+            // Both casings should be interned if the comparer was correctly reset.
+            Assert.Equal(mixedCaseValue, deserializedMixedCaseValue);
+            Assert.Equal(lowerCaseValue, deserializedLowerCaseValue);
+        }
+
+        /// <summary>
+        /// Tests throwing an exception on nested intern scopes, which is unsupported.
+        /// </summary>
+        [Fact]
+        public void TestWithInterningThrowsOnNestedScopes()
+        {
+            _ = Assert.Throws<InvalidOperationException>(() =>
+            {
+                ITranslator translator = TranslationHelpers.GetWriteTranslator();
+                translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+                {
+                    translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+                    {
+                    });
+                });
+            });
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+            {
+                // Reset the stream, since the broken write will result in an IO exception when read.
+            });
+
+            _ = Assert.Throws<InvalidOperationException>(() =>
+            {
+                ITranslator translator = TranslationHelpers.GetReadTranslator();
+                translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+                {
+                    translator.WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 1, translator =>
+                    {
+                    });
+                });
+            });
+        }
+
         /// <summary>
         /// Tests serializing a dictionary of { string, string }
         /// </summary>
@@ -539,6 +950,178 @@ public void TestSerializeDictionaryStringTNoComparerNull()
             Assert.Equal(value, deserializedValue);
         }
 
+        /// <summary>
+        /// Tests interning dictionaries of { string, string } within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternDictionaryStringString()
+        {
+            Dictionary<string, string> value = new(StringComparer.OrdinalIgnoreCase)
+            {
+                ["foo"] = "bar",
+                ["alpha"] = "omega",
+            };
+            Dictionary<string, string> valueUpperCase = new(StringComparer.OrdinalIgnoreCase)
+            {
+                ["FOO"] = "BAR",
+                ["ALPHA"] = "OMEGA",
+            };
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 4, translator =>
+            {
+                translator.InternDictionary(ref value, StringComparer.OrdinalIgnoreCase);
+                translator.InternDictionary(ref valueUpperCase, StringComparer.OrdinalIgnoreCase);
+            });
+
+            Dictionary<string, string> deserializedValue = null;
+            Dictionary<string, string> deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 4, translator =>
+            {
+                translator.InternDictionary(ref deserializedValue, StringComparer.OrdinalIgnoreCase);
+                translator.InternDictionary(ref deserializedValueUpperCase, StringComparer.OrdinalIgnoreCase);
+            });
+
+            Assert.Equal(value.Count, deserializedValue.Count);
+            Assert.Equal(value["foo"], deserializedValue["foo"]);
+            Assert.Equal(value["alpha"], deserializedValue["alpha"]);
+
+            // All occurrences should deserialize to the first encountered value.
+            // We don't test the keys since the dictionary already uses an ignore case comparer, and
+            // we also want to test that the dictionary comparer matches on both sides.
+            Assert.Equal(valueUpperCase.Count, deserializedValueUpperCase.Count);
+            Assert.Equal(value["foo"], deserializedValueUpperCase["foo"]);
+            Assert.Equal(value["alpha"], deserializedValueUpperCase["alpha"]);
+        }
+
+        /// <summary>
+        /// Tests interning a dictionary of { string, T } within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternDictionaryStringT()
+        {
+            // Since we don't have string values, mismatch the key comparer to verify that interning works.
+            Dictionary<string, BaseClass> value = new(StringComparer.Ordinal)
+            {
+                ["foo"] = new BaseClass(1),
+                ["alpha"] = new BaseClass(2),
+            };
+            Dictionary<string, BaseClass> valueUpperCase = new(StringComparer.Ordinal)
+            {
+                ["FOO"] = new BaseClass(1),
+                ["ALPHA"] = new BaseClass(2),
+            };
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternDictionary(ref value, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+                translator.InternDictionary(ref valueUpperCase, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+            });
+
+            Dictionary<string, BaseClass> deserializedValue = null;
+            Dictionary<string, BaseClass> deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternDictionary(ref deserializedValue, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+                translator.InternDictionary(ref deserializedValueUpperCase, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+            });
+
+            Assert.Equal(value.Count, deserializedValue.Count);
+            Assert.Equal(0, BaseClass.Comparer.Compare(value["foo"], deserializedValue["foo"]));
+            Assert.Equal(0, BaseClass.Comparer.Compare(value["alpha"], deserializedValue["alpha"]));
+
+            // All occurrences should deserialize to the first encountered key.
+            Assert.Equal(0, BaseClass.Comparer.Compare(valueUpperCase["FOO"], deserializedValueUpperCase["foo"]));
+            Assert.Equal(0, BaseClass.Comparer.Compare(valueUpperCase["ALPHA"], deserializedValueUpperCase["alpha"]));
+        }
+
+        /// <summary>
+        /// Tests interning dictionaries of { string, string } with path-like values within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternPathDictionaryStringString()
+        {
+            Dictionary<string, string> value = new(StringComparer.OrdinalIgnoreCase)
+            {
+                ["foo"] = @"C:/src/msbuild/artifacts/bin/ProjectA.Namespace/Debug/net472/ProjectA.NameSpace.dll",
+                ["alpha"] = @"C:/src/msbuild/artifacts/bin/ProjectB.Namespace/Debug/net472/ProjectB.NameSpace.dll",
+            };
+            Dictionary<string, string> valueUpperCase = new(StringComparer.OrdinalIgnoreCase)
+            {
+                ["FOO"] = @"C:/SRC/MSBUILD/ARTIFACTS/BIN/PROJECTA.NAMESPACE/DEBUG/NET472/PROJECTA.NAMESPACE.DLL",
+                ["ALPHA"] = @"C:/SRC/MSBUILD/ARTIFACTS/BIN/PROJECTB.NAMESPACE/DEBUG/NET472/PROJECTB.NAMESPACE.DLL",
+            };
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 4, translator =>
+            {
+                translator.InternDictionary(ref value, StringComparer.OrdinalIgnoreCase);
+                translator.InternDictionary(ref valueUpperCase, StringComparer.OrdinalIgnoreCase);
+            });
+
+            Dictionary<string, string> deserializedValue = null;
+            Dictionary<string, string> deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 4, translator =>
+            {
+                translator.InternDictionary(ref deserializedValue, StringComparer.OrdinalIgnoreCase);
+                translator.InternDictionary(ref deserializedValueUpperCase, StringComparer.OrdinalIgnoreCase);
+            });
+
+            Assert.Equal(value.Count, deserializedValue.Count);
+            Assert.Equal(value["foo"], deserializedValue["foo"]);
+            Assert.Equal(value["alpha"], deserializedValue["alpha"]);
+
+            // All occurrences should deserialize to the first encountered value.
+            // We don't test the keys since the dictionary already uses an ignore case comparer, and
+            // we also want to test that the dictionary comparer matches on both sides.
+            Assert.Equal(valueUpperCase.Count, deserializedValueUpperCase.Count);
+            Assert.Equal(value["foo"], deserializedValueUpperCase["foo"]);
+            Assert.Equal(value["alpha"], deserializedValueUpperCase["alpha"]);
+        }
+
+        /// <summary>
+        /// Tests interning a dictionary of { string, T } with path-like keys within an intern scope.
+        /// </summary>
+        [Fact]
+        public void TestInternPathDictionaryStringT()
+        {
+            const string PathA = @"C:/src/msbuild/artifacts/bin/ProjectA.Namespace/Debug/net472/ProjectA.NameSpace.dll";
+            const string PathB = @"C:/src/msbuild/artifacts/bin/ProjectB.Namespace/Debug/net472/ProjectB.NameSpace.dll";
+
+            // Since we don't have string values, mismatch the key comparer to verify that interning works.
+            Dictionary<string, BaseClass> value = new(StringComparer.Ordinal)
+            {
+                [PathA] = new BaseClass(1),
+                [PathB] = new BaseClass(2),
+            };
+            Dictionary<string, BaseClass> valueUpperCase = new(StringComparer.Ordinal)
+            {
+                [PathA.ToUpperInvariant()] = new BaseClass(1),
+                [PathB.ToUpperInvariant()] = new BaseClass(2),
+            };
+
+            TranslationHelpers.GetWriteTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternDictionary(ref value, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+                translator.InternDictionary(ref valueUpperCase, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+            });
+
+            Dictionary<string, BaseClass> deserializedValue = null;
+            Dictionary<string, BaseClass> deserializedValueUpperCase = null;
+            TranslationHelpers.GetReadTranslator().WithInterning(StringComparer.OrdinalIgnoreCase, initialCapacity: 2, translator =>
+            {
+                translator.InternDictionary(ref deserializedValue, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+                translator.InternDictionary(ref deserializedValueUpperCase, StringComparer.OrdinalIgnoreCase, BaseClass.FactoryForDeserialization);
+            });
+
+            Assert.Equal(value.Count, deserializedValue.Count);
+            Assert.Equal(0, BaseClass.Comparer.Compare(value[PathA], deserializedValue[PathA]));
+            Assert.Equal(0, BaseClass.Comparer.Compare(value[PathB], deserializedValue[PathB]));
+
+            // All occurrences should deserialize to the first encountered key.
+            Assert.Equal(0, BaseClass.Comparer.Compare(valueUpperCase[PathA.ToUpperInvariant()], deserializedValueUpperCase[PathA]));
+            Assert.Equal(0, BaseClass.Comparer.Compare(valueUpperCase[PathB.ToUpperInvariant()], deserializedValueUpperCase[PathB]));
+        }
+
+
         [Theory]
         [InlineData("en")]
         [InlineData("en-US")]
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
index d588c980ab4..b1db9f4d040 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
@@ -59,14 +59,12 @@ public class BuildManager_Logging_Tests : IDisposable
         private readonly ProjectCollection _projectCollection;
 
         private readonly TestEnvironment _env;
-        private readonly ITestOutputHelper _output;
 
         /// <summary>
         /// SetUp
         /// </summary>
         public BuildManager_Logging_Tests(ITestOutputHelper output)
         {
-            _output = output;
             // Ensure that any previous tests which may have been using the default BuildManager do not conflict with us.
             BuildManager.DefaultBuildManager.Dispose();
 
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
index b7ea019500a..3d9c91ca2c4 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
@@ -52,7 +52,6 @@ public List<FullyQualifiedBuildRequest[]> NewRequests
             }
 
 
-            private IBuildComponentHost _host;
             private Thread _builderThread;
             private BuildRequestEntry _entry;
             private AutoResetEvent _continueEvent;
@@ -224,12 +223,10 @@ public void WaitForCancelCompletion()
 
             public void InitializeComponent(IBuildComponentHost host)
             {
-                _host = host;
             }
 
             public void ShutdownComponent()
             {
-                _host = null;
             }
 
             #endregion
@@ -255,13 +252,11 @@ private ProjectInstance CreateStandinProject()
         private BuildResult _requestComplete_Result;
 
         private AutoResetEvent _requestResumedEvent;
-        private BuildRequest _requestResumed_Request;
 
         private AutoResetEvent _newRequestEvent;
         private BuildRequestBlocker _newRequest_Request;
 
         private AutoResetEvent _engineStatusChangedEvent;
-        private BuildRequestEngineStatus _engineStatusChanged_Status;
 
         private AutoResetEvent _newConfigurationEvent;
         private BuildRequestConfiguration _newConfiguration_Config;
@@ -270,7 +265,6 @@ private ProjectInstance CreateStandinProject()
         private Exception _engineException_Exception;
 
         private AutoResetEvent _engineResourceRequestEvent;
-        private ResourceRequest _engineResourceRequest_Request;
 
         private IBuildRequestEngine _engine;
         private IConfigCache _cache;
@@ -560,7 +554,6 @@ private void Engine_RequestComplete(BuildRequest request, BuildResult result)
         /// <param name="request">The request being resumed</param>
         private void Engine_RequestResumed(BuildRequest request)
         {
-            _requestResumed_Request = request;
             _requestResumedEvent.Set();
         }
 
@@ -580,7 +573,6 @@ private void Engine_NewRequest(BuildRequestBlocker blocker)
         /// <param name="newStatus">The new status for the engine</param>
         private void Engine_EngineStatusChanged(BuildRequestEngineStatus newStatus)
         {
-            _engineStatusChanged_Status = newStatus;
             _engineStatusChangedEvent.Set();
         }
 
@@ -610,7 +602,6 @@ private void Engine_Exception(Exception e)
         /// <param name="request">The resource request</param>
         private void Engine_ResourceRequest(ResourceRequest request)
         {
-            _engineResourceRequest_Request = request;
             _engineResourceRequestEvent.Set();
         }
     }
diff --git a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
index d2241b404ae..cdd280d3b72 100644
--- a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
+++ b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
@@ -19,11 +19,6 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     internal sealed class MockTaskBuilder : ITaskBuilder, IBuildComponent
     {
-        /// <summary>
-        /// The component host.
-        /// </summary>
-        private IBuildComponentHost _host;
-
         /// <summary>
         /// The current task number.
         /// </summary>
@@ -137,7 +132,6 @@ public Task<WorkUnitResult> ExecuteTask(TargetLoggingContext targetLoggingContex
         /// <param name="host">The component host</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            _host = host;
         }
 
         /// <summary>
@@ -145,7 +139,6 @@ public void InitializeComponent(IBuildComponentHost host)
         /// </summary>
         public void ShutdownComponent()
         {
-            _host = null;
         }
 
         #endregion
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 5d0ae210a56..0c22214c0ee 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -105,6 +105,11 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
                 throw new NotImplementedException();
             }
 
+            public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+            {
+                throw new NotImplementedException();
+            }
+
             public void RoutePacket(int nodeId, INodePacket packet)
             {
                 _dataReceivedContext = new DataReceivedContext(Thread.CurrentThread, packet);
diff --git a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
index 61ac9f125d4..797e83393f1 100644
--- a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
@@ -339,7 +339,6 @@ private NodeLoggingContext GetNodeLoggingContext()
 
     internal sealed class TestTargetBuilder : ITargetBuilder, IBuildComponent
     {
-        private IBuildComponentHost _host;
         private IResultsCache _cache;
         private FullyQualifiedBuildRequest[] _newRequests;
         private IRequestBuilderCallback _requestBuilderCallback;
@@ -405,13 +404,11 @@ public Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, Buil
 
         public void InitializeComponent(IBuildComponentHost host)
         {
-            _host = host;
             _cache = new ResultsCache();
         }
 
         public void ShutdownComponent()
         {
-            _host = null;
             _cache = null;
         }
         #endregion
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index 10a1c5dcd6c..8200c364d2a 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -75,6 +75,33 @@ public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
             _logger.Warnings.Select(i => i.Message).ShouldBe(new[] { "WARNING4", "WARNING2" });
         }
 
+        [Fact]
+        public void AssertSingleResolverErrorLoggedWhenSdkNotResolved()
+        {
+            var service = new SdkResolverService();
+
+            // Use mock loader that only provides a single resolver
+            service.InitializeForTests(new MockLoaderStrategy(includeSingleResolverOnly: true));
+
+            var sdk = new SdkReference("notfound", "referencedVersion", "minimumVersion");
+
+            var result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
+
+            result.Success.ShouldBeFalse();
+            result.ShouldNotBeNull();
+            result.SdkReference.ShouldNotBeNull();
+            result.SdkReference.Name.ShouldBe("notfound");
+
+            // Check that only the simplified error (no MSBuild wrapper) is logged
+            _logger.Errors.Count.ShouldBe(1);
+            _logger.Errors[0].Message.ShouldBe(
+                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                    "SingleResolverFailedToResolveSDK",
+                    "notfound",
+                    "MockSdkResolver1",
+                    "ERROR1"));
+        }
+
         [Fact]
         public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersion()
         {
@@ -743,8 +770,14 @@ private sealed class MockLoaderStrategy : SdkResolverLoader
             public bool ResolversHaveBeenLoaded { get; private set; } = false;
             public bool ManifestsHaveBeenLoaded { get; private set; } = false;
 
-            public MockLoaderStrategy(bool includeErrorResolver = false, bool includeResolversWithPatterns = false, bool includeDefaultResolver = false) : this()
+            public MockLoaderStrategy(bool includeErrorResolver = false, bool includeResolversWithPatterns = false, bool includeDefaultResolver = false , bool includeSingleResolverOnly = false) : this()
             {
+                if (includeSingleResolverOnly)
+                {
+                    _resolvers = new List<SdkResolver> { new MockSdkResolver1() };
+                    return; // Exit early so other ones aren't added
+                }
+
                 if (includeErrorResolver)
                 {
                     _resolvers.Add(new MockSdkResolverThrows());
diff --git a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
index 83d4ae0cf0a..0baca3b2dad 100644
--- a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
@@ -35,32 +35,19 @@ public class SdkResultOutOfProc_Tests : IDisposable
         /// </summary>
         private readonly BuildManager _buildManager;
 
-        /// <summary>
-        /// The build parameters.
-        /// </summary>
-        private readonly BuildParameters _parameters;
-
         /// <summary>
         /// The project collection used.
         /// </summary>
         private readonly ProjectCollection _projectCollection;
 
         private readonly TestEnvironment _env;
-        private readonly ITestOutputHelper _output;
 
         public SdkResultOutOfProc_Tests(ITestOutputHelper output)
         {
-            _output = output;
             // Ensure that any previous tests which may have been using the default BuildManager do not conflict with us.
             BuildManager.DefaultBuildManager.Dispose();
 
             _logger = new MockLogger(output);
-            _parameters = new BuildParameters
-            {
-                ShutdownInProcNodeOnBuildFinish = true,
-                Loggers = new ILogger[] { _logger },
-                EnableNodeReuse = false
-            };
             _buildManager = new BuildManager();
             _projectCollection = new ProjectCollection();
 
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index f0155787682..9bec89727fe 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -32,26 +32,14 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     public class TaskBuilder_Tests : ITargetBuilderCallback
     {
-        /// <summary>
-        /// The mock component host and logger
-        /// </summary>
-        private MockHost _host;
-
         private readonly ITestOutputHelper _testOutput;
 
-        /// <summary>
-        /// The temporary project we use to run the test
-        /// </summary>
-        private ProjectInstance _testProject;
-
         /// <summary>
         /// Prepares the environment for the test.
         /// </summary>
         public TaskBuilder_Tests(ITestOutputHelper output)
         {
-            _host = new MockHost();
             _testOutput = output;
-            _testProject = CreateTestProject();
         }
 
         /*********************************************************************************
@@ -1098,7 +1086,6 @@ private Project CreateSTATestProject(bool requireSTA, bool failTask, bool throwE
 
             return project;
         }
-#endif
 
         /// <summary>
         /// Helper to create the STA test task.
@@ -1172,80 +1159,7 @@ public ITaskHost HostObject
 }";
             return CustomTaskHelper.GetAssemblyForTask(taskContents);
         }
-
-        /// <summary>
-        /// Creates a test project.
-        /// </summary>
-        /// <returns>The project.</returns>
-        private ProjectInstance CreateTestProject()
-        {
-            string projectFileContents = ObjectModelHelpers.CleanupFileContents(@"
-                <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
-
-                    <ItemGroup>
-                        <Compile Include='b.cs' />
-                        <Compile Include='c.cs' />
-                    </ItemGroup>
-
-                    <ItemGroup>
-                        <Reference Include='System' />
-                    </ItemGroup>
-
-                    <Target Name='Empty' />
-
-                    <Target Name='Skip' Inputs='testProject.proj' Outputs='testProject.proj' />
-
-                    <Target Name='Error' >
-                        <ErrorTask1 ContinueOnError='True'/>
-                        <ErrorTask2 ContinueOnError='False'/>
-                        <ErrorTask3 />
-                        <OnError ExecuteTargets='Foo'/>
-                        <OnError ExecuteTargets='Bar'/>
-                    </Target>
-
-                    <Target Name='Foo' Inputs='foo.cpp' Outputs='foo.o'>
-                        <FooTask1/>
-                    </Target>
-
-                    <Target Name='Bar'>
-                        <BarTask1/>
-                    </Target>
-
-                    <Target Name='Baz' DependsOnTargets='Bar'>
-                        <BazTask1/>
-                        <BazTask2/>
-                    </Target>
-
-                    <Target Name='Baz2' DependsOnTargets='Bar;Foo'>
-                        <Baz2Task1/>
-                        <Baz2Task2/>
-                        <Baz2Task3/>
-                    </Target>
-
-                    <Target Name='DepSkip' DependsOnTargets='Skip'>
-                        <DepSkipTask1/>
-                        <DepSkipTask2/>
-                        <DepSkipTask3/>
-                    </Target>
-
-                    <Target Name='DepError' DependsOnTargets='Foo;Skip;Error'>
-                        <DepSkipTask1/>
-                        <DepSkipTask2/>
-                        <DepSkipTask3/>
-                    </Target>
-
-                </Project>
-                ");
-
-            IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("testfile", new Dictionary<string, string>(), "3.5", Array.Empty<string>(), null), "2.0");
-            using ProjectFromString projectFromString = new(projectFileContents);
-            Project project = projectFromString.Project;
-            config.Project = project.CreateProjectInstance();
-            cache.AddConfiguration(config);
-
-            return config.Project;
-        }
+#endif
 
         /// <summary>
         /// The mock component host object.
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index b1a2a334e8d..54cb31e6598 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1302,18 +1302,6 @@ private void ValidateOutputItem(string outputName, string value)
             Assert.Equal(value, _bucket.Lookup.GetItems("output").First().EvaluatedInclude);
         }
 
-        /// <summary>
-        /// Helper method for tests
-        /// </summary>
-        private void ValidateOutputItem(string outputName, ITaskItem value)
-        {
-            Assert.True(_host.GatherTaskOutputs(outputName, ElementLocation.Create(".", 1, 1), true, "output"));
-            Assert.True(_outputsReadFromTask.ContainsKey(outputName));
-
-            Assert.Single(_bucket.Lookup.GetItems("output"));
-            Assert.Equal(0, TaskItemComparer.Instance.Compare(value, new TaskItem(_bucket.Lookup.GetItems("output").First())));
-        }
-
         /// <summary>
         /// Helper method for tests
         /// </summary>
diff --git a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
index 7e54dd49c91..b462245e17d 100644
--- a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
@@ -26,8 +26,6 @@ namespace Microsoft.Build.UnitTests.Definition
     /// </summary>
     public class ToolsetRegistryReader_Tests : IDisposable
     {
-        // The registry key that is passed as the baseKey parameter to the ToolsetRegistryReader class
-        private RegistryKey _testRegistryKey = null;
         // Subkey "3.5"
         private RegistryKey _currentVersionRegistryKey = null;
         // Subkey "ToolsVersions"
@@ -49,7 +47,6 @@ public class ToolsetRegistryReader_Tests : IDisposable
         public ToolsetRegistryReader_Tests()
         {
             DeleteTestRegistryKey();
-            _testRegistryKey = Registry.CurrentUser.CreateSubKey(testRegistryPath);
             _currentVersionRegistryKey = Registry.CurrentUser.CreateSubKey(testRegistryPath + "\\" + Constants.AssemblyVersion);
             _toolsVersionsRegistryKey = Registry.CurrentUser.CreateSubKey(testRegistryPath + "\\ToolsVersions");
 
diff --git a/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs b/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
index fe0acc1db0d..4b69b86fe02 100644
--- a/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
@@ -14,10 +14,6 @@ namespace Microsoft.Build.Engine.UnitTests.Evaluation
 {
     public class ExpanderFunction_Tests
     {
-        private readonly ITestOutputHelper _output;
-
-        public ExpanderFunction_Tests(ITestOutputHelper output) => _output = output;
-
         /* Tests for TryConvertToInt */
 
         [Fact]
diff --git a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
index a5041d55fd6..e596bc05e8a 100644
--- a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
@@ -137,6 +138,40 @@ public void SdkResolverCanReturnNoPaths(bool includePropertiesAndItems)
             _logger.WarningCount.ShouldBe(0);
         }
 
+        [Fact]
+        public void SuccessfullyEvaluatesSdkResultWithPropertiesForNullProjectRootElement()
+        {
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                        Enumerable.Empty<string>(),
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null)));
+
+            string projectContent = @"
+                    <Project>
+                        <Import Project=""Sdk.props"" Sdk=""TestPropsAndItemsFromResolverSdk""/>
+                    </Project>";
+
+            string projectPath = Path.Combine(_testFolder, "project.proj");
+            File.WriteAllText(projectPath, projectContent);
+
+            using XmlReader xmlReader = XmlReader.Create(projectPath);
+
+            projectOptions.ProjectCollection = _projectCollection;
+
+            // Creating project from XmlReader results in null ProjectRootElement on Evaluation phase.
+            // In that case project created for SdkResult properties and items is given a unique file name {Guid}.SdkResolver.{propertiesAndItemsHash}.proj in the current directory
+            Project.FromXmlReader(xmlReader, projectOptions);
+        }
+
         [Theory]
         [InlineData(true, true)]
         [InlineData(true, false)]
diff --git a/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs b/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs
index 323326401c6..b10cf9465d4 100644
--- a/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs
+++ b/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs
@@ -2,7 +2,10 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
+using System.Linq;
 using System.Reflection;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.UnitTests;
 using Shouldly;
@@ -98,6 +101,23 @@ public void Initialize_ShouldNoOp_WhenCalledMultipleTimes()
             state2.ShouldBe(false);
         }
 
+        [Fact]
+        public void TelemetryLoadFailureIsLoggedOnce()
+        {
+            OpenTelemetryManager.Instance.LoadFailureExceptionMessage = new System.IO.FileNotFoundException().ToString();
+            using BuildManager bm = new BuildManager();
+            var deferredMessages = new List<BuildManager.DeferredBuildMessage>();
+            bm.BeginBuild(new BuildParameters(), deferredMessages);
+            deferredMessages.ShouldContain(x => x.Text.Contains("FileNotFound"));
+            bm.EndBuild();
+            bm.BeginBuild(new BuildParameters());
+            bm.EndBuild();
+
+            // should not add message twice
+            int count = deferredMessages.Count(x => x.Text.Contains("FileNotFound"));
+            count.ShouldBe(1);
+        }
+
         /* Helper methods */
 
         /// <summary>
diff --git a/src/Build.UnitTests/Telemetry/Telemetry_Tests.cs b/src/Build.UnitTests/Telemetry/Telemetry_Tests.cs
index 6154403ab83..8eae309431d 100644
--- a/src/Build.UnitTests/Telemetry/Telemetry_Tests.cs
+++ b/src/Build.UnitTests/Telemetry/Telemetry_Tests.cs
@@ -5,9 +5,7 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Linq;
-#if NET
 using System.Text.Json;
-#endif
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
@@ -282,7 +280,7 @@ public void NodeTelemetryE2E()
                 tasksData.TryGetProperty("Microsoft.Build.Tasks.Message", out var messageTask).ShouldBe(true);
                 messageTask.GetProperty("ExecutionsCount").GetInt32().ShouldBe(3);
                 messageTask.GetProperty("TotalMilliseconds").GetDouble().ShouldBeGreaterThan(0);
-                messageTask.GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThan(0);
+                messageTask.GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThanOrEqualTo(0);
                 messageTask.GetProperty(nameof(TaskOrTargetTelemetryKey.IsCustom)).GetBoolean().ShouldBe(false);
                 messageTask.GetProperty(nameof(TaskOrTargetTelemetryKey.IsCustom)).GetBoolean().ShouldBe(false);
 
@@ -290,7 +288,7 @@ public void NodeTelemetryE2E()
                 tasksData.TryGetProperty("Microsoft.Build.Tasks.CreateItem", out var createItemTask).ShouldBe(true);
                 createItemTask.GetProperty("ExecutionsCount").GetInt32().ShouldBe(1);
                 createItemTask.GetProperty("TotalMilliseconds").GetDouble().ShouldBeGreaterThan(0);
-                createItemTask.GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThan(0);
+                createItemTask.GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThanOrEqualTo(0);
 
                 // Verify Targets summary information
                 tags.ShouldContainKey("VS.MSBuild.TargetsSummary");
@@ -311,7 +309,8 @@ public void NodeTelemetryE2E()
                 // Verify task execution summary metrics based on TasksSummaryConverter.Write structure
                 tasksSummary.GetProperty("Microsoft").GetProperty("Total").GetProperty("ExecutionsCount").GetInt32().ShouldBe(4);
                 tasksSummary.GetProperty("Microsoft").GetProperty("Total").GetProperty("TotalMilliseconds").GetDouble().ShouldBeGreaterThan(0);
-                tasksSummary.GetProperty("Microsoft").GetProperty("Total").GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThan(0);
+                // Allowing 0 for TotalMemoryBytes as it is possible for tasks to allocate no memory in certain scenarios.
+                tasksSummary.GetProperty("Microsoft").GetProperty("Total").GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThanOrEqualTo(0);
             }
         }
 
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index 60ed5d2bd01..a29466e852c 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -21,12 +21,9 @@ namespace Microsoft.Build.UnitTests
 {
     public class UtilitiesTestStandard : UtilitiesTest
     {
-        private readonly ITestOutputHelper _output;
-
-        public UtilitiesTestStandard(ITestOutputHelper output)
+        public UtilitiesTestStandard()
         {
             this.loadAsReadOnly = false;
-            _output = output;
         }
 
         [Fact]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index a60bd4ed0d8..fa6ae4bbbfd 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -459,7 +459,8 @@ private void UpdatePriority(Process p, ProcessPriorityClass priority)
         /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
         public void BeginBuild(BuildParameters parameters)
         {
-            OpenTelemetryManager.Instance.Initialize(isStandalone: false);
+            InitializeTelemetry();
+
             if (_previousLowPriority != null)
             {
                 if (parameters.LowPriority != _previousLowPriority)
@@ -677,7 +678,7 @@ IEnumerable<ILogger> AppendDebuggingLoggers(IEnumerable<ILogger> loggers)
 
                 var logger = new BinaryLogger { Parameters = binlogPath };
 
-                return (loggers ?? [logger]);
+                return (loggers ?? []).Concat([logger]);
             }
 
             void InitializeCaches()
@@ -723,6 +724,26 @@ void InitializeCaches()
             }
         }
 
+        private void InitializeTelemetry()
+        {
+            OpenTelemetryManager.Instance.Initialize(isStandalone: false);
+            string? failureMessage = OpenTelemetryManager.Instance.LoadFailureExceptionMessage;
+            if (_deferredBuildMessages != null &&
+                failureMessage != null &&
+                _deferredBuildMessages is ICollection<DeferredBuildMessage> deferredBuildMessagesCollection)
+            {
+                deferredBuildMessagesCollection.Add(
+                    new DeferredBuildMessage(
+                        ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                            "OpenTelemetryLoadFailed",
+                            failureMessage),
+                    MessageImportance.Low));
+
+                // clean up the message from OpenTelemetryManager to avoid double logging it
+                OpenTelemetryManager.Instance.LoadFailureExceptionMessage = null;
+            }
+        }
+
 #if FEATURE_REPORTFILEACCESSES
         /// <summary>
         /// Configure the build to use I/O tracking for nodes.
@@ -779,6 +800,7 @@ private static void AttachDebugger()
         /// </summary>
         public void CancelAllSubmissions()
         {
+            MSBuildEventSource.Log.CancelSubmissionsStart();
             CancelAllSubmissions(true);
         }
 
@@ -2405,7 +2427,7 @@ private void HandleResourceRequest(int node, ResourceRequest request)
             {
                 // Resource request requires a response and may be blocking. Our continuation is effectively a callback
                 // to be called once at least one core becomes available.
-                _scheduler!.RequestCores(request.GlobalRequestId, request.NumCores, request.IsBlocking).ContinueWith((Task<int> task) =>
+                _scheduler!.RequestCores(request.GlobalRequestId, request.NumCores, request.IsBlocking).ContinueWith((task) =>
                 {
                     var response = new ResourceResponse(request.GlobalRequestId, task.Result);
                     _nodeManager!.SendData(node, response);
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index 0219982e43e..b78001c5f3d 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -125,6 +125,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
         }
 
+        /// <summary>
+        /// Deserializes a packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator to use as a source for packet data.</param>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _packetFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes a packet to the appropriate handler.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index d892518e9ea..bd8e221c3dd 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -15,6 +15,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.TelemetryInfra;
+using Microsoft.NET.StringTools;
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 
 #nullable disable
@@ -314,6 +315,8 @@ public void CleanupForBuild()
                 _requestsByGlobalRequestId.Clear();
                 _unsubmittedRequests.Clear();
                 _unresolvedConfigurations.ClearConfigurations();
+                Strings.ClearCachedStrings();
+
                 ChangeStatus(BuildRequestEngineStatus.Uninitialized);
             }
         }
@@ -1131,8 +1134,8 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
             // to the entry rather than a series of them.
             lock (issuingEntry.GlobalLock)
             {
-                var existingResultsToReport = new List<BuildResult>();
-                var unresolvedConfigurationsAdded = new HashSet<int>();
+                List<BuildResult> existingResultsToReport = null;
+                HashSet<int> unresolvedConfigurationsAdded = null;
 
                 foreach (FullyQualifiedBuildRequest request in newRequests)
                 {
@@ -1157,6 +1160,7 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
                             // Not waiting for it
                             request.Config.ConfigurationId = GetNextUnresolvedConfigurationId();
                             _unresolvedConfigurations.AddConfiguration(request.Config);
+                            unresolvedConfigurationsAdded ??= new HashSet<int>();
                             unresolvedConfigurationsAdded.Add(request.Config.ConfigurationId);
                         }
                         else
@@ -1235,6 +1239,7 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
 
                             // Can't report the result directly here, because that could cause the request to go from
                             // Waiting to Ready.
+                            existingResultsToReport ??= new List<BuildResult>();
                             existingResultsToReport.Add(response.Results);
                         }
                         else
@@ -1246,9 +1251,12 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
                 }
 
                 // If we have any results we had to report, do so now.
-                foreach (BuildResult existingResult in existingResultsToReport)
+                if (existingResultsToReport is not null)
                 {
-                    issuingEntry.ReportResult(existingResult);
+                    foreach (BuildResult existingResult in existingResultsToReport)
+                    {
+                        issuingEntry.ReportResult(existingResult);
+                    }
                 }
 
                 // Issue any configuration requests we may still need.
@@ -1257,16 +1265,23 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
                 {
                     foreach (BuildRequestConfiguration unresolvedConfigurationToIssue in unresolvedConfigurationsToIssue)
                     {
-                        unresolvedConfigurationsAdded.Remove(unresolvedConfigurationToIssue.ConfigurationId);
+                        if (unresolvedConfigurationsAdded is not null)
+                        {
+                            unresolvedConfigurationsAdded.Remove(unresolvedConfigurationToIssue.ConfigurationId);
+                        }
+
                         IssueConfigurationRequest(unresolvedConfigurationToIssue);
                     }
                 }
 
                 // Remove any configurations we ended up not waiting for, otherwise future requests will think we are still waiting for them
                 // and will never get submitted.
-                foreach (int unresolvedConfigurationId in unresolvedConfigurationsAdded)
+                if (unresolvedConfigurationsAdded is not null)
                 {
-                    _unresolvedConfigurations.RemoveConfiguration(unresolvedConfigurationId);
+                    foreach (int unresolvedConfigurationId in unresolvedConfigurationsAdded)
+                    {
+                        _unresolvedConfigurations.RemoveConfiguration(unresolvedConfigurationId);
+                    }
                 }
 
                 // Finally, if we can issue build requests, do so.
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index b0031746031..31ebde5a1d6 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -255,6 +255,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
         }
 
+        /// <summary>
+        /// Takes a serializer and deserializes the packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _packetFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes the specified packet. This is called by the Inproc node directly since it does not have to do any deserialization
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 45334ce6752..54f5205c3f3 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -292,6 +292,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             ErrorUtilities.ThrowInternalErrorUnreachable();
         }
 
+        /// <summary>
+        /// Deserializes and routes a packet.  Not used in the in-proc node.
+        /// </summary>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            // Not used
+            ErrorUtilities.ThrowInternalErrorUnreachable();
+            return null;
+        }
+
         /// <summary>
         /// Routes a packet.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 4e6a7b77970..1064b2c709a 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -881,23 +881,6 @@ public async Task WaitForExitAsync(ILoggingService loggingService)
                 _process.KillTree(timeoutMilliseconds: 5000);
             }
 
-#if FEATURE_APM
-            /// <summary>
-            /// Completes the asynchronous packet write to the node.
-            /// </summary>
-            private void PacketWriteComplete(IAsyncResult result)
-            {
-                try
-                {
-                    _serverToClientStream.EndWrite(result);
-                }
-                catch (IOException)
-                {
-                    // Do nothing here because any exception will be caught by the async read handler
-                }
-            }
-#endif
-
             private bool ProcessHeaderBytesRead(int bytesRead)
             {
                 if (bytesRead != _headerByte.Length)
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 1d0f0f525d3..95df655f7c9 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -287,6 +287,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             }
         }
 
+        /// <summary>
+        /// Takes a serializer and deserializes the packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _localPacketFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes the specified packet
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index e7e66d6b886..66c881052b8 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -149,6 +149,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             throw new NotSupportedException("not used");
         }
 
+        /// <summary>
+        /// Takes a serializer, deserializes the packet and routes it to the appropriate handler.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            throw new NotSupportedException("not used");
+        }
+
         /// <summary>
         /// Routes the specified packet. This is called by the Inproc node directly since it does not have to do any deserialization
         /// </summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index 596555819ca..93c744c5870 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -480,8 +480,15 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     ICollection<ProjectItemInstance> adds = scope.Adds[itemType];
                     if (adds.Count != 0)
                     {
-                        allAdds ??= new List<ProjectItemInstance>(adds.Count);
-                        allAdds.AddRange(adds);
+                        if (allAdds == null)
+                        {
+                            // Use the List<T>(IEnumerable<T>) constructor to avoid an intermediate array allocation.
+                            allAdds = new List<ProjectItemInstance>(adds);
+                        }
+                        else
+                        {
+                            allAdds.AddRange(adds);
+                        }
                     }
                 }
 
@@ -491,8 +498,14 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     ICollection<ProjectItemInstance> removes = scope.Removes[itemType];
                     if (removes.Count != 0)
                     {
-                        allRemoves ??= new List<ProjectItemInstance>(removes.Count);
-                        allRemoves.AddRange(removes);
+                        if (allRemoves == null)
+                        {
+                            allRemoves = new List<ProjectItemInstance>(removes);
+                        }
+                        else
+                        {
+                            allRemoves.AddRange(removes);
+                        }
                     }
                 }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 4be12ea2854..3f08179f500 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -497,7 +497,7 @@ public int RequestCores(object monitorLockObject, int requestedCores, bool waitF
             // a queue of pending requests.
             ResourceResponse responseObject = null;
             using AutoResetEvent responseEvent = new AutoResetEvent(false);
-            _pendingResourceRequests.Enqueue((ResourceResponse response) =>
+            _pendingResourceRequests.Enqueue((response) =>
             {
                 responseObject = response;
                 responseEvent.Set();
@@ -1106,8 +1106,6 @@ private async Task<BuildResult> BuildProject()
             // logged with the node logging context
             _projectLoggingContext = null;
 
-            MSBuildEventSource.Log.BuildProjectStart(_requestEntry.RequestConfiguration.ProjectFullPath);
-
             try
             {
                 // Load the project
@@ -1145,6 +1143,13 @@ private async Task<BuildResult> BuildProject()
 
             try
             {
+                // Determine the set of targets we need to build
+                (string name, TargetBuiltReason reason)[] allTargets = _requestEntry.RequestConfiguration
+   .GetTargetsUsedToBuildRequest(_requestEntry.Request).ToArray();
+                if (MSBuildEventSource.Log.IsEnabled())
+                {
+                    MSBuildEventSource.Log.BuildProjectStart(_requestEntry.RequestConfiguration.ProjectFullPath, string.Join(", ", allTargets));
+                }
                 HandleProjectStarted(buildCheckManager);
 
                 // Make sure to extract known immutable folders from properties and register them for fast up-to-date check
@@ -1162,9 +1167,6 @@ private async Task<BuildResult> BuildProject()
 
                 _requestEntry.Request.BuildEventContext = _projectLoggingContext.BuildEventContext;
 
-                // Determine the set of targets we need to build
-                (string name, TargetBuiltReason reason)[] allTargets = _requestEntry.RequestConfiguration
-                    .GetTargetsUsedToBuildRequest(_requestEntry.Request).ToArray();
 
                 ProjectErrorUtilities.VerifyThrowInvalidProject(allTargets.Length > 0,
                     _requestEntry.RequestConfiguration.Project.ProjectFileLocation, "NoTargetSpecified");
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 30179f2e7a9..ee1dca8557e 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -148,11 +148,6 @@ internal class TargetEntry : IEquatable<TargetEntry>
         /// </summary>
         private bool _isExecuting;
 
-        /// <summary>
-        /// The current task builder.
-        /// </summary>
-        private ITaskBuilder _currentTaskBuilder;
-
         /// <summary>
         /// The constructor.
         /// </summary>
@@ -816,46 +811,36 @@ private async ValueTask<WorkUnitResult> ProcessBucket(ITaskBuilder taskBuilder,
             WorkUnitActionCode finalActionCode = WorkUnitActionCode.Continue;
             WorkUnitResult lastResult = new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null);
 
-            try
+            int currentTask = 0;
+
+            // Walk through all of the tasks and execute them in order.
+            for (; (currentTask < _target.Children.Count) && !_cancellationToken.IsCancellationRequested; ++currentTask)
             {
-                // Grab the task builder so if cancel is called it will have something to operate on.
-                _currentTaskBuilder = taskBuilder;
+                ProjectTargetInstanceChild targetChildInstance = _target.Children[currentTask];
 
-                int currentTask = 0;
+                // Execute the task.
+                lastResult = await taskBuilder.ExecuteTask(targetLoggingContext, _requestEntry, _targetBuilderCallback, targetChildInstance, mode, lookupForInference, lookupForExecution, _cancellationToken);
 
-                // Walk through all of the tasks and execute them in order.
-                for (; (currentTask < _target.Children.Count) && !_cancellationToken.IsCancellationRequested; ++currentTask)
+                if (lastResult.ResultCode == WorkUnitResultCode.Failed)
                 {
-                    ProjectTargetInstanceChild targetChildInstance = _target.Children[currentTask];
-
-                    // Execute the task.
-                    lastResult = await taskBuilder.ExecuteTask(targetLoggingContext, _requestEntry, _targetBuilderCallback, targetChildInstance, mode, lookupForInference, lookupForExecution, _cancellationToken);
-
-                    if (lastResult.ResultCode == WorkUnitResultCode.Failed)
-                    {
-                        aggregatedTaskResult = WorkUnitResultCode.Failed;
-                    }
-                    else if (lastResult.ResultCode == WorkUnitResultCode.Success && aggregatedTaskResult != WorkUnitResultCode.Failed)
-                    {
-                        aggregatedTaskResult = WorkUnitResultCode.Success;
-                    }
-
-                    if (lastResult.ActionCode == WorkUnitActionCode.Stop)
-                    {
-                        finalActionCode = WorkUnitActionCode.Stop;
-                        break;
-                    }
+                    aggregatedTaskResult = WorkUnitResultCode.Failed;
+                }
+                else if (lastResult.ResultCode == WorkUnitResultCode.Success && aggregatedTaskResult != WorkUnitResultCode.Failed)
+                {
+                    aggregatedTaskResult = WorkUnitResultCode.Success;
                 }
 
-                if (_cancellationToken.IsCancellationRequested)
+                if (lastResult.ActionCode == WorkUnitActionCode.Stop)
                 {
-                    aggregatedTaskResult = WorkUnitResultCode.Canceled;
                     finalActionCode = WorkUnitActionCode.Stop;
+                    break;
                 }
             }
-            finally
+
+            if (_cancellationToken.IsCancellationRequested)
             {
-                _currentTaskBuilder = null;
+                aggregatedTaskResult = WorkUnitResultCode.Canceled;
+                finalActionCode = WorkUnitActionCode.Stop;
             }
 
             return new WorkUnitResult(aggregatedTaskResult, finalActionCode, lastResult.Exception);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 36b4af7301f..29b8eff6009 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -428,8 +428,10 @@ private async ValueTask<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBuc
                     {
                         TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance, taskAssemblyLocation);
                         MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
-                        // Can be condition with _componentHost.BuildParameters.IsTelemetryEnabled) - but it's a cheap call
-                        taskFactoryWrapper?.Statistics?.ExecutionStarted();
+                        if (_componentHost.BuildParameters.IsTelemetryEnabled)
+                        {
+                            taskFactoryWrapper?.Statistics?.ExecutionStarted();
+                        }
 
                         _buildRequestEntry.Request.CurrentTaskContext = taskLoggingContext.BuildEventContext;
 
@@ -479,7 +481,10 @@ private async ValueTask<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBuc
 
                             // Flag the completion of the task.
                             taskLoggingContext.LogTaskBatchFinished(_projectFullPath, taskResult.ResultCode == WorkUnitResultCode.Success || taskResult.ResultCode == WorkUnitResultCode.Skipped);
-                            taskFactoryWrapper?.Statistics?.ExecutionStopped();
+                            if (_componentHost.BuildParameters.IsTelemetryEnabled)
+                            {
+                                taskFactoryWrapper?.Statistics?.ExecutionStopped();
+                            }
 
                             if (taskResult.ResultCode == WorkUnitResultCode.Failed && _continueOnError == ContinueOnError.WarnAndContinue)
                             {
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index e0390e978f0..6bcb954c1f3 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -579,7 +579,7 @@ public Task<int> RequestCores(int requestId, int requestedCores, bool waitForCor
                 return Task.FromResult(0);
             }
 
-            Func<int, int> grantCores = (int availableCores) =>
+            Func<int, int> grantCores = (availableCores) =>
             {
                 int grantedCores = Math.Min(requestedCores, availableCores);
                 if (grantedCores > 0)
@@ -599,7 +599,7 @@ public Task<int> RequestCores(int requestId, int requestedCores, bool waitForCor
                 // We have no cores to grant at the moment, queue up the request.
                 TaskCompletionSource<int> completionSource = new TaskCompletionSource<int>();
                 _pendingRequestCoresCallbacks.Enqueue(completionSource);
-                return completionSource.Task.ContinueWith((Task<int> task) => grantCores(task.Result), TaskContinuationOptions.ExecuteSynchronously);
+                return completionSource.Task.ContinueWith((task) => grantCores(task.Result), TaskContinuationOptions.ExecuteSynchronously);
             }
         }
 
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 19a63a6eb5f..c6a7fb224d1 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -111,7 +111,7 @@ public void WritePlan(int submissionId, ILoggingService loggingService, BuildEve
                     RecursiveAccumulateConfigurationTimes(rootRequest, accumulatedTimeByConfiguration);
 
                     List<KeyValuePair<int, double>> configurationsInOrder = new(accumulatedTimeByConfiguration);
-                    configurationsInOrder.Sort((KeyValuePair<int, double> l, KeyValuePair<int, double> r) => Comparer<int>.Default.Compare(l.Key, r.Key));
+                    configurationsInOrder.Sort((l, r) => Comparer<int>.Default.Compare(l.Key, r.Key));
                     foreach (KeyValuePair<int, double> configuration in configurationsInOrder)
                     {
                         file.WriteLine(String.Format(CultureInfo.InvariantCulture, "{0} {1} {2}", configuration.Key, configuration.Value, _configCache[configuration.Key].ProjectFullPath));
@@ -400,7 +400,7 @@ private void ReadTimes(StreamReader file)
                     return;
                 }
 
-                string[] values = line.Split(MSBuildConstants.SemicolonChar);
+                string[] values = line.Split(MSBuildConstants.SpaceChar);
                 if (values.Length < 3)
                 {
                     throw new InvalidDataException("Too few values in build plan.");
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 1d6ec92f64c..7318e57e900 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -250,7 +250,16 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
 
             if (failOnUnresolvedSdk)
             {
-                loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "FailedToResolveSDK", sdk.Name, string.Join($"{Environment.NewLine}  ", errors));
+                if (resolvers.Count == 1) // Check if only one resolver was used
+                {
+                    // Log the single resolver's error message directly
+                    loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "SingleResolverFailedToResolveSDK", sdk.Name, resolvers[0].Name, string.Join(Environment.NewLine, errors));
+                }
+                else
+                {
+                    // Log the error with the MSBuild wrapper
+                    loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "FailedToResolveSDK", sdk.Name, string.Join($"{Environment.NewLine}  ", errors));
+                }
             }
 
             LogWarnings(loggingContext, sdkReferenceLocation, warnings);
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index 7b4049f8905..33d5fb6359d 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -222,6 +222,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             ErrorUtilities.ThrowInternalError("Unexpected call to DeserializeAndRoutePacket on the in-proc node.");
         }
 
+        /// <summary>
+        /// Not necessary for in-proc node - we don't serialize.
+        /// </summary>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            // The in-proc endpoint shouldn't be serializing, just routing.
+            ErrorUtilities.ThrowInternalError("Unexpected call to DeserializePacket on the in-proc node.");
+            return null;
+        }
+
         /// <summary>
         /// Routes the packet to the appropriate handler.
         /// </summary>
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index df4dea0c279..f28b906077a 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -342,6 +342,16 @@ void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType pac
             _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
         }
 
+        /// <summary>
+        /// Deserializes a packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator to use as a source for packet data.</param>
+        INodePacket INodePacketFactory.DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _packetFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes a packet to the appropriate handler.
         /// </summary>
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index aefae5aceab..89591cd0f4c 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -210,6 +210,16 @@ void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType pac
             _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
         }
 
+        /// <summary>
+        /// Deserializes a packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator to use as a source for packet data.</param>
+        INodePacket INodePacketFactory.DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _packetFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes a packet to the appropriate handler.
         /// </summary>
diff --git a/src/Build/BuildCheck/Checks/ExecCliBuildCheck.cs b/src/Build/BuildCheck/Checks/ExecCliBuildCheck.cs
new file mode 100644
index 00000000000..252159162b2
--- /dev/null
+++ b/src/Build/BuildCheck/Checks/ExecCliBuildCheck.cs
@@ -0,0 +1,150 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+#if !FEATURE_MSIOREDIST
+using System.IO;
+#endif
+using Microsoft.Build.Shared;
+
+#if FEATURE_MSIOREDIST
+using Path = Microsoft.IO.Path;
+#endif
+
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
+
+internal sealed class ExecCliBuildCheck : Check
+{
+    public static CheckRule SupportedRule = new CheckRule(
+        "BC0302",
+        "ExecCliBuild",
+        ResourceUtilities.GetResourceString("BuildCheck_BC0302_Title")!,
+        ResourceUtilities.GetResourceString("BuildCheck_BC0302_MessageFmt")!,
+        new CheckConfiguration() { Severity = CheckResultSeverity.Warning });
+
+    private const string ExecTaskName = "Exec";
+    private const string CommandParameterName = "Command";
+
+    private static readonly char[] s_knownCommandSeparators = ['&', ';', '|'];
+
+    private static readonly string[] s_knownBuildCommands =
+    [
+        "dotnet build",
+        "dotnet clean",
+        "dotnet msbuild",
+        "dotnet restore",
+        "dotnet publish",
+        "dotnet pack",
+        "dotnet vstest",
+        "nuget restore",
+        "msbuild",
+        "dotnet test",
+        "dotnet run",
+    ];
+
+    public override string FriendlyName => "MSBuild.ExecCliBuildCheck";
+
+    internal override bool IsBuiltIn => true;
+
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
+
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        /* This is it - no custom configuration */
+    }
+
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+    {
+        registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);
+    }
+
+    private static void TaskInvocationAction(BuildCheckDataContext<TaskInvocationCheckData> context)
+    {
+        if (context.Data.TaskName == ExecTaskName
+            && context.Data.Parameters.TryGetValue(CommandParameterName, out TaskInvocationCheckData.TaskParameter? commandArgument))
+        {
+            var execCommandValue = commandArgument.Value?.ToString() ?? string.Empty;
+
+            var commandSpan = execCommandValue.AsSpan();
+            int start = 0;
+
+            while (start < commandSpan.Length)
+            {
+                var nextSeparatorIndex = commandSpan.Slice(start, commandSpan.Length - start).IndexOfAny(s_knownCommandSeparators);
+
+                if (nextSeparatorIndex == -1)
+                {
+                    if (TryGetMatchingKnownBuildCommand(commandSpan.Slice(start), out var knownBuildCommand))
+                    {
+                        context.ReportResult(BuildCheckResult.CreateBuiltIn(
+                            SupportedRule,
+                            context.Data.TaskInvocationLocation,
+                            context.Data.TaskName,
+                            Path.GetFileName(context.Data.ProjectFilePath),
+                            GetToolName(knownBuildCommand)));
+                    }
+
+                    break;
+                }
+                else
+                {
+                    var command = commandSpan.Slice(start, nextSeparatorIndex);
+
+                    if (TryGetMatchingKnownBuildCommand(command, out var knownBuildCommand))
+                    {
+                        context.ReportResult(BuildCheckResult.CreateBuiltIn(
+                            SupportedRule,
+                            context.Data.TaskInvocationLocation,
+                            context.Data.TaskName,
+                            Path.GetFileName(context.Data.ProjectFilePath),
+                            GetToolName(knownBuildCommand)));
+
+                        break;
+                    }
+
+                    start += nextSeparatorIndex + 1;
+                }
+            }
+        }
+    }
+
+    private static bool TryGetMatchingKnownBuildCommand(ReadOnlySpan<char> command, out string knownBuildCommand)
+    {
+        const int maxStackLimit = 1024;
+
+        Span<char> normalizedBuildCommand = command.Length <= maxStackLimit ? stackalloc char[command.Length] : new char[command.Length];
+        int normalizedCommandIndex = 0;
+
+        foreach (var c in command)
+        {
+            if (char.IsWhiteSpace(c) && (normalizedCommandIndex == 0 || char.IsWhiteSpace(normalizedBuildCommand[normalizedCommandIndex - 1])))
+            {
+                continue;
+            }
+
+            normalizedBuildCommand[normalizedCommandIndex++] = c;
+        }
+
+        foreach (var buildCommand in s_knownBuildCommands)
+        {
+            if (normalizedBuildCommand.StartsWith(buildCommand.AsSpan()))
+            {
+                knownBuildCommand = buildCommand;
+                return true;
+            }
+        }
+
+        knownBuildCommand = string.Empty;
+        return false;
+    }
+
+    private static string GetToolName(string knownBuildCommand)
+    {
+        int nextSpaceIndex = knownBuildCommand.IndexOf(' ');
+
+        return nextSpaceIndex == -1
+            ? knownBuildCommand
+            : knownBuildCommand.AsSpan().Slice(0, nextSpaceIndex).ToString();
+    }
+}
diff --git a/src/Build/BuildCheck/Checks/TargetFrameworkConfusionCheck.cs b/src/Build/BuildCheck/Checks/TargetFrameworkConfusionCheck.cs
index 2c3db3512ad..7d117fe456f 100644
--- a/src/Build/BuildCheck/Checks/TargetFrameworkConfusionCheck.cs
+++ b/src/Build/BuildCheck/Checks/TargetFrameworkConfusionCheck.cs
@@ -46,7 +46,9 @@ private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedProperties
         string? frameworks;
         string? framework;
         if (context.Data.EvaluatedProperties.TryGetValue(PropertyNames.TargetFrameworks, out frameworks) &&
+            !string.IsNullOrEmpty(frameworks) &&
             context.Data.EvaluatedProperties.TryGetValue(PropertyNames.TargetFramework, out framework) &&
+            !string.IsNullOrEmpty(framework) &&
             !context.Data.GlobalProperties.ContainsKey(PropertyNames.TargetFramework))
         {
             // {0} specifies 'TargetFrameworks' property '{1}' and 'TargetFramework' property '{2}'
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
index b2e0055006e..0c9dcb341d1 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
@@ -28,25 +28,25 @@ internal BuildCheckBuildEventHandler(
 
         _eventHandlersFull = new()
         {
-            { typeof(BuildSubmissionStartedEventArgs), (BuildEventArgs e) => HandleBuildSubmissionStartedEvent((BuildSubmissionStartedEventArgs)e) },
-            { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs)e) },
-            { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs)e) },
-            { typeof(EnvironmentVariableReadEventArgs), (BuildEventArgs e) => HandleEnvironmentVariableReadEvent((EnvironmentVariableReadEventArgs)e) },
-            { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => HandleProjectStartedRequest((ProjectStartedEventArgs)e) },
-            { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => HandleProjectFinishedRequest((ProjectFinishedEventArgs)e) },
-            { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => HandleBuildCheckTracingEvent((BuildCheckTracingEventArgs)e) },
-            { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => HandleBuildCheckAcquisitionEvent((BuildCheckAcquisitionEventArgs)e) },
-            { typeof(TaskStartedEventArgs), (BuildEventArgs e) => HandleTaskStartedEvent((TaskStartedEventArgs)e) },
-            { typeof(TaskFinishedEventArgs), (BuildEventArgs e) => HandleTaskFinishedEvent((TaskFinishedEventArgs)e) },
-            { typeof(TaskParameterEventArgs), (BuildEventArgs e) => HandleTaskParameterEvent((TaskParameterEventArgs)e) },
-            { typeof(BuildFinishedEventArgs), (BuildEventArgs e) => HandleBuildFinishedEvent((BuildFinishedEventArgs)e) },
-            { typeof(ProjectImportedEventArgs), (BuildEventArgs e) => HandleProjectImportedEvent((ProjectImportedEventArgs)e) },
+            { typeof(BuildSubmissionStartedEventArgs), (e) => HandleBuildSubmissionStartedEvent((BuildSubmissionStartedEventArgs)e) },
+            { typeof(ProjectEvaluationFinishedEventArgs), (e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs)e) },
+            { typeof(ProjectEvaluationStartedEventArgs), (e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs)e) },
+            { typeof(EnvironmentVariableReadEventArgs), (e) => HandleEnvironmentVariableReadEvent((EnvironmentVariableReadEventArgs)e) },
+            { typeof(ProjectStartedEventArgs), (e) => HandleProjectStartedRequest((ProjectStartedEventArgs)e) },
+            { typeof(ProjectFinishedEventArgs), (e) => HandleProjectFinishedRequest((ProjectFinishedEventArgs)e) },
+            { typeof(BuildCheckTracingEventArgs), (e) => HandleBuildCheckTracingEvent((BuildCheckTracingEventArgs)e) },
+            { typeof(BuildCheckAcquisitionEventArgs), (e) => HandleBuildCheckAcquisitionEvent((BuildCheckAcquisitionEventArgs)e) },
+            { typeof(TaskStartedEventArgs), (e) => HandleTaskStartedEvent((TaskStartedEventArgs)e) },
+            { typeof(TaskFinishedEventArgs), (e) => HandleTaskFinishedEvent((TaskFinishedEventArgs)e) },
+            { typeof(TaskParameterEventArgs), (e) => HandleTaskParameterEvent((TaskParameterEventArgs)e) },
+            { typeof(BuildFinishedEventArgs), (e) => HandleBuildFinishedEvent((BuildFinishedEventArgs)e) },
+            { typeof(ProjectImportedEventArgs), (e) => HandleProjectImportedEvent((ProjectImportedEventArgs)e) },
         };
 
         // During restore we'll wait only for restore to be done.
         _eventHandlersRestore = new()
         {
-            { typeof(BuildSubmissionStartedEventArgs), (BuildEventArgs e) => HandleBuildSubmissionStartedEvent((BuildSubmissionStartedEventArgs)e) },
+            { typeof(BuildSubmissionStartedEventArgs), (e) => HandleBuildSubmissionStartedEvent((BuildSubmissionStartedEventArgs)e) },
         };
 
         _eventHandlers = _eventHandlersFull;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 9e8782ae9ee..08c7ea339c4 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -16,15 +16,11 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 internal sealed class BuildCheckConnectorLogger : ILogger
 {
     private readonly BuildCheckBuildEventHandler _eventHandler;
-    private readonly IBuildCheckManager _buildCheckManager;
-    private readonly ICheckContextFactory _checkContextFactory;
 
     internal BuildCheckConnectorLogger(
         ICheckContextFactory checkContextFactory,
         IBuildCheckManager buildCheckManager)
     {
-        _buildCheckManager = buildCheckManager;
-        _checkContextFactory = checkContextFactory;
         _eventHandler = new BuildCheckBuildEventHandler(checkContextFactory, buildCheckManager);
     }
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 7100095f1b4..89998bad255 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -149,6 +149,7 @@ internal readonly record struct BuiltInCheckFactory(
                 new BuiltInCheckFactory([PreferProjectReferenceCheck.SupportedRule.Id], PreferProjectReferenceCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<PreferProjectReferenceCheck>),
                 new BuiltInCheckFactory([CopyAlwaysCheck.SupportedRule.Id], CopyAlwaysCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<CopyAlwaysCheck>),
                 new BuiltInCheckFactory([DoubleWritesCheck.SupportedRule.Id], DoubleWritesCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<DoubleWritesCheck>),
+                new BuiltInCheckFactory([ExecCliBuildCheck.SupportedRule.Id], ExecCliBuildCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<ExecCliBuildCheck>),
                 new BuiltInCheckFactory([NoEnvironmentVariablePropertyCheck.SupportedRule.Id], NoEnvironmentVariablePropertyCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<NoEnvironmentVariablePropertyCheck>),
                 new BuiltInCheckFactory([EmbeddedResourceCheck.SupportedRule.Id], EmbeddedResourceCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<EmbeddedResourceCheck>),
                 new BuiltInCheckFactory([TargetFrameworkConfusionCheck.SupportedRule.Id], TargetFrameworkConfusionCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<TargetFrameworkConfusionCheck>),
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
index 393a9f7612c..9b72644bdb8 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
@@ -12,6 +12,10 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
 
 internal sealed class EditorConfigParser
 {
+    // static property for embedding resolved `.editorconfig`s in binlog
+    private static ConcurrentBag<string> editorConfigFilePaths = new ConcurrentBag<string>();
+    public static IEnumerable<string> EditorConfigFilePaths => editorConfigFilePaths;
+
     private const string EditorconfigFile = ".editorconfig";
 
     /// <summary>
@@ -25,6 +29,13 @@ internal Dictionary<string, string> Parse(string filePath)
         return MergeEditorConfigFiles(editorConfigs, filePath);
     }
 
+    /// <summary>
+    /// Clears the editorConfigFilePaths collection after embedding in the binlog.
+    /// </summary>
+    public static void ClearEditorConfigFilePaths()
+    {
+        editorConfigFilePaths = new ConcurrentBag<string>();
+    }
     /// <summary>
     /// Fetches the list of EditorconfigFile ordered from the nearest to the filePath.
     /// </summary>
@@ -34,16 +45,15 @@ internal List<EditorConfigFile> DiscoverEditorConfigFiles(string filePath)
         var editorConfigDataFromFilesList = new List<EditorConfigFile>();
 
         var directoryOfTheProject = Path.GetDirectoryName(filePath);
-        // The method will look for the file in parent directory if not found in current until found or the directory is root. 
+        // The method will look for the file in parent directory if not found in current until found or the directory is root.
         var editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, directoryOfTheProject);
-
         while (editorConfigFilePath != string.Empty)
         {
             var editorConfig = _editorConfigFileCache.GetOrAdd(editorConfigFilePath, (key) =>
             {
                 return EditorConfigFile.Parse(File.ReadAllText(editorConfigFilePath));
             });
-
+            editorConfigFilePaths.Add(editorConfigFilePath);
             editorConfigDataFromFilesList.Add(editorConfig);
 
             if (editorConfig.IsRoot)
@@ -61,7 +71,7 @@ internal List<EditorConfigFile> DiscoverEditorConfigFiles(string filePath)
     }
 
     /// <summary>
-    /// Retrieves the config dictionary from the sections that matched the filePath. 
+    /// Retrieves the config dictionary from the sections that matched the filePath.
     /// </summary>
     /// <param name="editorConfigFiles"></param>
     /// <param name="filePath"></param>
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index 6f77454eaaf..561e2f59fec 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -16,9 +16,9 @@ public abstract class CheckData(string projectFilePath, int? projectConfiguratio
 {
     private string? _projectFileDirectory;
     // The id is going to be used in future revision
-#pragma warning disable CA1823
+#pragma warning disable CA1823, IDE0052
     private int? _projectConfigurationId = projectConfigurationId;
-#pragma warning restore CA1823
+#pragma warning restore CA1823, IDE0052
 
     /// <summary>
     /// Full path to the project file being built.
diff --git a/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
index dc8d96f9f7c..5db99b8ab70 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
@@ -82,7 +82,7 @@ namespace Microsoft.Build.Collections
 #if FEATURE_SECURITY_PERMISSIONS
     [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
 #endif
-    internal class RetrievableEntryHashSet<T> : IRetrievableEntryHashSet<T>
+    internal class RetrievableEntryHashSet<T> : IRetrievableEntryHashSet<T> // CodeQL [SM02227] The dangerous method is called only in debug build. It's safe for release build.
         where T : class, IKeyed
     {
         // store lower 31 bits of hash code
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 23b235e5ad0..1ac8dde6d77 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -3815,7 +3815,7 @@ internal void Initialize(IDictionary<string, string> globalProperties, string to
 
                 // Cause the project to be actually loaded into the collection, and register for
                 // rename notifications so we can subsequently update the collection.
-                _renameHandler = (string oldFullPath) => ProjectCollection.OnAfterRenameLoadedProject(oldFullPath, Owner);
+                _renameHandler = (oldFullPath) => ProjectCollection.OnAfterRenameLoadedProject(oldFullPath, Owner);
 
                 Xml.OnAfterProjectRename += _renameHandler;
                 Xml.OnProjectXmlChanged += ProjectRootElement_ProjectXmlChangedHandler;
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 2f3ca882084..85692818736 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -27,11 +27,6 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class ToolsetReader
     {
-        /// <summary>
-        /// The global properties used to read the toolset.
-        /// </summary>
-        private PropertyDictionary<ProjectPropertyInstance> _globalProperties;
-
         /// <summary>
         /// The environment properties used to read the toolset.
         /// </summary>
@@ -45,7 +40,6 @@ protected ToolsetReader(
             PropertyDictionary<ProjectPropertyInstance> globalProperties)
         {
             _environmentProperties = environmentProperties;
-            _globalProperties = globalProperties;
         }
 
         /// <summary>
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index b5c1d724240..3176644c32d 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.Exceptions
     /// Exception subclass that ToolsetReaders should throw.
     /// </summary>
     [Serializable]
-    public class InvalidToolsetDefinitionException : BuildExceptionBase
+    public class InvalidToolsetDefinitionException : BuildExceptionBase // CodeQL [SM02227] The dangerous method is called only in debug build. It's safe for release build.
     {
         /// <summary>
         /// The MSBuild error code corresponding with this exception.
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 598c949ec54..0cf78b1d071 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -345,6 +345,11 @@ internal static void Evaluate(
             {
                 evaluator.Evaluate();
             }
+            catch (PathTooLongException ex)
+            {
+                evaluator._evaluationLoggingContext.LogErrorFromText(null, null, null, new BuildEventFileInfo(root.ProjectFileLocation.File),
+                    ex.Message);
+            }
             finally
             {
                 IEnumerable globalProperties = null;
@@ -1924,8 +1929,13 @@ private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
             int propertiesAndItemsHash = hash.ToHashCode();
 #endif
 
-            // Generate a unique filename for the generated project for each unique set of properties and items.
-            string projectPath = $"{_projectRootElement.FullPath}.SdkResolver.{propertiesAndItemsHash}.proj";
+            // Generate a unique filename for the generated project for each unique set of properties and items that ends like ".SdkResolver.{propertiesAndItemsHash}.proj".
+            // _projectRootElement.FullPath can be null. This can be in the case when Project is created from XmlReader. For that case we generate filename like "{Guid}.SdkResolver.{propertiesAndItemsHash}.proj in the current directory.
+            // Otherwise the project is in the same directory as _projectRootElement and has a name of the same project and ends like ".SdkResolver.{propertiesAndItemsHash}.proj".
+            string projectNameEnding = $".SdkResolver.{propertiesAndItemsHash}.proj";
+            string projectPath = _projectRootElement.FullPath != null ?
+             _projectRootElement.FullPath + projectNameEnding :
+             FileUtilities.NormalizePath(Guid.NewGuid() + projectNameEnding);
 
             ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
             {
diff --git a/src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs b/src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs
index ff6e6d700ee..3e9a03753da 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.OrderedItemDataCollection.cs
@@ -41,7 +41,6 @@ internal Builder(ImmutableList<ItemData>.Builder listBuilder)
 
                 #region IEnumerable implementation
 
-                private ImmutableList<ItemData>.Enumerator GetEnumerator() => _listBuilder.GetEnumerator();
                 IEnumerator<ItemData> IEnumerable<ItemData>.GetEnumerator() => _listBuilder.GetEnumerator();
 
                 System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => _listBuilder.GetEnumerator();
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 09c7709e062..3a30af61030 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -662,8 +662,10 @@ public void AddOrUpdateEdge((ProjectGraphNode node, ProjectGraphNode reference)
             {
                 ReferenceItems.AddOrUpdate(
                     key,
+#pragma warning disable IDE0350
                     addValueFactory: static ((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstance referenceItem) => referenceItem,
                     updateValueFactory: static ((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstance existingItem, ProjectItemInstance newItem) =>
+#pragma warning restore IDE0350
                     {
                         string existingTargetsMetadata = existingItem.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
                         string newTargetsMetadata = newItem.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
index b92e762eba9..00d34f295f2 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
@@ -175,13 +175,11 @@ public ICollection<T> GetItems(string itemType)
 
         private sealed class ListConverter : ICollection<T>
         {
-            private readonly string _itemType;
             private readonly ICollection<TCached> _list;
             private readonly Func<TCached, T?> _getInstance;
 
             public ListConverter(string itemType, ICollection<TCached> list, Func<TCached, T?> getInstance)
             {
-                _itemType = itemType;
                 _list = list;
                 _getInstance = getInstance;
             }
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 36f280f88bb..bce683abb37 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1085,6 +1085,7 @@ public void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
                 _directMetadata.ImportProperties(metadata.Select(kvp => new ProjectMetadataInstance(kvp.Key, kvp.Value, allowItemSpecModifiers: true)));
             }
 
+#if FEATURE_APPDOMAIN
             /// <summary>
             /// Used to return metadata from another AppDomain. Can't use yield return because the
             /// generated state machine is not marked as [Serializable], so we need to allocate.
@@ -1106,6 +1107,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(ICopyOn
                 // Probably better to send the raw array across the wire even if it's another allocation.
                 return result.ToArray();
             }
+#endif
 
             private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
             {
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index fd169167a9c..fdb9dc2373a 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -374,6 +374,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
         }
 
+        /// <summary>
+        /// Takes a serializer and deserializes the packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _packetFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes the specified packet
         /// </summary>
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 508cb7483b6..c4023835131 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -1188,7 +1188,7 @@ internal class Stats()
 
                 public void ExecutionStarted()
                 {
-                    _memoryConsumptionOnStart = GC.GetTotalMemory(false);
+                    _memoryConsumptionOnStart = GetMemoryAllocated();
                     _executedSw.Start();
                     ExecutedCount++;
                 }
@@ -1196,7 +1196,16 @@ public void ExecutionStarted()
                 public void ExecutionStopped()
                 {
                     _executedSw.Stop();
-                    TotalMemoryConsumption += GC.GetTotalMemory(false) - _memoryConsumptionOnStart;
+                    TotalMemoryConsumption += GetMemoryAllocated() - _memoryConsumptionOnStart;
+                }
+
+                private static long GetMemoryAllocated()
+                {
+#if NET
+                    return GC.GetTotalAllocatedBytes(false);
+#else
+                    return GC.GetTotalMemory(false);
+#endif
                 }
 
                 public void Reset()
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 10286b512eb..e5947b6bf33 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -4,6 +4,7 @@
 using System;
 using System.IO;
 using System.IO.Compression;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
@@ -321,6 +322,12 @@ public void Shutdown()
 
             if (projectImportsCollector != null)
             {
+                // Write the build check editorconfig file paths to the log
+                foreach (var filePath in EditorConfigParser.EditorConfigFilePaths)
+                {
+                    projectImportsCollector.AddFile(filePath);
+                }
+                EditorConfigParser.ClearEditorConfigFilePaths();
                 projectImportsCollector.Close();
 
                 if (CollectProjectImports == ProjectImportsCollectionMode.Embed)
@@ -336,6 +343,7 @@ public void Shutdown()
                 projectImportsCollector = null;
             }
 
+
             if (stream != null)
             {
                 // It's hard to determine whether we're at the end of decoding GZipStream
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 9e2368df650..fb60ed2c23c 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1401,22 +1401,6 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
             }
         }
 
-        /// <summary>
-        /// Write message taking into account whether or not the prefix (timestamp and key) have already been written on the line
-        /// </summary>
-        private void WriteBasedOnPrefix(string nonNullMessage, bool prefixAlreadyWritten, int adjustedPrefixWidth)
-        {
-            if (prefixAlreadyWritten)
-            {
-                WriteHandler(nonNullMessage + Environment.NewLine);
-            }
-            else
-            {
-                // No prefix info has been written, indent the line to the proper location
-                WriteHandler(IndentString(nonNullMessage, adjustedPrefixWidth));
-            }
-        }
-
         /// <summary>
         /// Will display the target started event which was deferred until the first visible message for the target is ready to be displayed
         /// </summary>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 128cf7283c0..71a53635fdd 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1340,6 +1340,9 @@
   <data name="SDKResolverFailed" xml:space="preserve">
     <value>The SDK resolver "{0}" failed while attempting to resolve the SDK "{1}". Exception: "{2}"</value>
   </data>
+  <data name="SingleResolverFailedToResolveSDK" xml:space="preserve">
+    <value>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</value>
+  </data>
   <data name="FailedToResolveSDK" xml:space="preserve">
     <value>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</value>
@@ -2206,6 +2209,12 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</value>
     <comment>Terms in quotes are not to be translated.</comment>
   </data>
+  <data name="BuildCheck_BC0302_Title" xml:space="preserve">
+    <value>The 'Exec' task should not be used to build a project.</value>
+  </data>
+  <data name="BuildCheck_BC0302_MessageFmt" xml:space="preserve">
+    <value>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</value>
+  </data>
   <data name="BuildCheck_BC0201_Title" xml:space="preserve">
     <value>A property that is accessed should be declared first.</value>
   </data>
@@ -2386,6 +2395,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>succeeded: {0}</value>
     <comment>{0} whole number</comment>
   </data>
+  <data name="OpenTelemetryLoadFailed" xml:space="preserve">
+    <value>Loading telemetry libraries failed with exception: {0}.</value>
+  </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 5d95d9b15e5..03650f88f89 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Vlastnosti TargetFramework a TargetFrameworks se nedodržují a neměly by se zadává v projektech, které nepoužívají sadu .NET SDK.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">Úloha {0} z projektu {1} sestaví projekt pomocí rozhraní příkazového řádku {2}. Místo toho by se měla použít úloha MSBuild.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">Úloha Exec by se neměla používat k sestavení projektu.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">K vlastnosti: {0} bylo přistupováno, ale nebyla nikdy inicializována.</target>
@@ -620,6 +630,11 @@
         <target state="translated">Metoda {0} se nedá zavolat s kolekcí, která obsahuje prázdné cílové názvy nebo názvy null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Načítání knihoven telemetrie se nezdařilo s výjimkou: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Výstupní vlastnost: </target>
@@ -845,6 +860,11 @@ Chyby: {3}</target>
         <target state="translated">Překladač sady SDK „{0}“ vrátil hodnotu null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">Sadu SDK {0} se nepodařilo vyřešit pomocí překladače sady SDK {1}. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Projekt {0} přeskočil omezení izolace grafu v odkazovaném projektu {1}.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 2cc67095e98..2ad593ea66a 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Die Eigenschaften "TargetFramework" und "TargetFrameworks" werden nicht berücksichtigt und sollten nicht in Projekten angegeben werden, die nicht das .NET SDK verwenden.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">Die {0}-Aufgabe aus dem Projekt {1} erstellt ein Projekt mithilfe der {2} CLI. Stattdessen sollte die MSBuild-Aufgabe verwendet werden.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">Die "Ausführen"-Aufgabe sollte nicht zum Erstellen eines Projekts verwendet werden.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Auf die Eigenschaft „{0}“ wurde zugegriffen, sie wurde jedoch nie initialisiert.</target>
@@ -620,6 +630,11 @@
         <target state="translated">Die Methode "{0}" kann nicht mit einer Sammlung aufgerufen werden, die NULL oder leere Zielnamen enthält.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Fehler beim Laden von Telemetriebibliotheken. Ausnahme:{0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Ausgabeeigenschaft: </target>
@@ -845,6 +860,11 @@ Fehler: {3}</target>
         <target state="translated">Der SDK-Resolver "{0}" hat NULL zurückgegeben.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">SDK „{0}“ konnte vom SDK-Resolver „{1}“ nicht aufgelöst werden. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Das Projekt "{0}" hat Graphisolationseinschränkungen für das referenzierte Projekt "{1}" übersprungen.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 7a8f4854d66..b4584d786bf 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Las propiedades "TargetFramework" y "TargetFrameworks" no se respetan y no deben especificarse en proyectos que no usen el SDK de .NET.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">La tarea {0} del proyecto {1} compila un proyecto mediante la CLI {2}. En su lugar, se debe usar la tarea MSBuild.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">La tarea "Exec" no debe usarse para compilar un proyecto.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Propiedad: se obtuvo acceso a "{0}", pero nunca se inicializó.</target>
@@ -620,6 +630,11 @@
         <target state="translated">No se puede llamar al método {0} con una colección que contiene nombres de destino nulos o vacíos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Error al cargar las bibliotecas de telemetría con la excepción: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Propiedad de salida: </target>
@@ -845,6 +860,11 @@ Errores: {3}</target>
         <target state="translated">La resolución del SDK "{0}" devolvió null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">El SDK '{0}' no se pudo resolver mediante la resolución de SDK '{1}'. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: El proyecto "{0}" ha omitido las restricciones de aislamiento de gráficos en el proyecto "{1}" al que se hace referencia.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index aafdf22e15f..909a507f566 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Les propriétés 'TargetFramework' et 'TargetFrameworks' ne sont pas respectées et ne doivent pas être spécifiées dans les projets qui n’utilisent pas le SDK .NET.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">La tâche {0} du projet {1} crée un projet en utilisant l’interface CLI {2}. Vous devez utiliser la tâche MSBuild à la place.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">Vous ne devez pas utiliser la tâche « Exec¯ pour construire un projet.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Propriété : « {0} » a été consultée, mais elle n'a jamais été initialisée.</target>
@@ -620,6 +630,11 @@
         <target state="translated">Impossible d'appeler la méthode {0} avec une collection contenant des noms de cibles qui ont une valeur null ou qui sont vides.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Nous n’avons pas pu charger les bibliothèques de télémétrie avec l’exception : {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Propriété de sortie : </target>
@@ -845,6 +860,11 @@ Erreurs : {3}</target>
         <target state="translated">Le programme de résolution du Kit de développement logiciel (SDK) «{0}» a retourné null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">Le Kit de développement logiciel (SDK) « {0} » n’a pas pu être résolu par le résolveur de SDK « {1} ». {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: le projet "{0}" a ignoré les contraintes d'isolement de graphe dans le projet référencé "{1}"</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 5e38412a12f..44e0f02b051 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Le proprietà 'TargetFramework' e 'TargetFrameworks' non vengono rispettate e non devono essere specificate nei progetti che non usano .NET SDK.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">L'attività {0} del progetto{1} compila un progetto utilizzando la CLI {2}. È necessario utilizzare invece l'attività MSBuild.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">L'attività 'Esecuzione' non deve essere utilizzata per compilare un progetto.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">È stato eseguito l'accesso alla proprietà '{0}', ma non è mai stata inizializzata.</target>
@@ -620,6 +630,11 @@
         <target state="translated">Non è possibile chiamare il metodo {0} con una raccolta contenente nomi di destinazione Null o vuoti.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Caricamento delle librerie di telemetria non riuscito con eccezione: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Proprietà di output: </target>
@@ -845,6 +860,11 @@ Errori: {3}</target>
         <target state="translated">Il resolver SDK "{0}" ha restituito null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">Il resolver SDK '{0}' non è riuscito a risolvere l'SDK '{1}'. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: il progetto "{0}" ha ignorato i vincoli di isolamento del grafico nel progetto di riferimento "{1}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index dda0d13a014..fa181c689ea 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -221,6 +221,16 @@
         <target state="translated">'TargetFramework' プロパティと 'TargetFrameworks' プロパティは優先されないため、.NET SDK を使用しないプロジェクトでは指定しないでください。</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">プロジェクト {1} のタスク {0} は、{2} CLI を使用してプロジェクトをビルドします。代わりに MSBuild タスクを使用する必要があります。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">'Exec' タスクはプロジェクトのビルドには使用しないでください。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">プロパティ: '{0}' にアクセスしましたが、初期化されませんでした。</target>
@@ -620,6 +630,11 @@
         <target state="translated">Null または空のターゲット名を含むコレクションを指定してメソッド {0} を呼び出すことはできません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">テレメトリ ライブラリの読み込みが次の例外で失敗しました: {0}。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">プロパティの出力: </target>
@@ -845,6 +860,11 @@ Errors: {3}</source>
         <target state="translated">SDK リゾルバー "{0}" が null を返しました。</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">SDK '{0}' を SDK リゾルバー '{1}' で解決できませんでした。{2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: プロジェクト "{0}" は、参照先のプロジェクト "{1}" で、グラフの分離制約をスキップしました</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 03f95d108ff..f5766935dde 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -221,6 +221,16 @@
         <target state="translated">'TargetFramework' 및 'TargetFrameworks' 속성은 사용되지 않으며 .NET SDK를 사용하지 않는 프로젝트에서 지정해서는 안 됩니다.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">프로젝트 {1}의 작업 {0}(은)는 {2} CLI를 사용하여 프로젝트를 빌드합니다. 대신 MSBuild 작업을 사용해야 합니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">'Exec' 작업은 프로젝트를 빌드하는 데 사용하면 안 됩니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">속성: '{0}'에 액세스했지만 초기화되지 않았습니다.</target>
@@ -620,6 +630,11 @@
         <target state="translated">null 또는 빈 대상 이름을 포함하는 컬렉션을 사용하여 {0} 메서드를 호출할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">예외 {0}(으)로 인해 원격 분석 라이브러리를 로드하지 못했습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">출력 속성: </target>
@@ -845,6 +860,11 @@ Errors: {3}</source>
         <target state="translated">SDK 확인자 "{0}"이(가) null을 반환했습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">SDK 확인자 '{1}'에서 SDK '{0}'을(를) 확인할 수 없습니다. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 프로젝트 "{0}"에서 참조된 프로젝트 "{1}"의 그래프 격리 제약 조건을 건너뛰었습니다.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b41218bfd21..a218f56d244 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Właściwości "TargetFramework" i "TargetFrameworks" nie są respektowane i nie należy ich określać w projektach, w których nie jest używany zestaw .NET SDK.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">Zadanie {0} z projektu {1} tworzy projekt przy użyciu interfejsu wiersza polecenia {2}. Zamiast tego należy użyć zadania MSBuild.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">Zadanie „Exec” nie powinno być używane do kompilowania projektu.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Właściwość: uzyskano dostęp do „{0}”, ale nigdy nie dokonano inicjacji.</target>
@@ -620,6 +630,11 @@
         <target state="translated">Metody {0} nie można wywołać przy użyciu kolekcji zawierającej nazwy docelowe o wartości null lub puste.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Ładowanie bibliotek telemetrii nie powiodło się. Wyjątek: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Właściwość danych wyjściowych: </target>
@@ -845,6 +860,11 @@ Błędy: {3}</target>
         <target state="translated">Narzędzie Resolver zestawu SDK „{0}” zwróciło wartość null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">Nie można rozpoznać zestawu SDK „{0}” przez program rozpoznawania nazw zestawu SDK „{1}”. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: W przypadku projektu „{0}” pominięto ograniczenia izolacji grafu dla przywoływanego projektu „{1}”</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index dd2bf9c6cf7..bde8513a69a 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -221,6 +221,16 @@
         <target state="translated">As propriedades 'TargetFramework' e 'TargetFrameworks' não são respeitadas e não devem ser especificadas em projetos que não usam o SDK do .NET.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">A tarefa {0} do projeto {1} cria um projeto usando a CLI {2}. Em vez disso, a tarefa do MSBuild deve ser usada.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">A tarefa "Exec" não deve ser usada para criar um projeto.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Propriedade: "{0}" foi acessada, mas nunca foi inicializada.</target>
@@ -620,6 +630,11 @@
         <target state="translated">O método {0} não pode ser chamado com uma coleção que contém nomes de destino nulos ou vazios.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Falha ao carregar as bibliotecas de telemetria com a exceção: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Propriedade de Saída: </target>
@@ -845,6 +860,11 @@ Erros: {3}</target>
         <target state="translated">O resolvedor do SDK "{0}" retornou nulo.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">O SDK '{0}' não pôde ser resolvido pelo resolvedor de SDK '{1}'. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: o projeto "{0}" ignorou as restrições de isolamento do gráfico no projeto referenciado "{1}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 7d7883cf5c6..34b7d9d8b23 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Свойства TargetFramework и TargetFrameworks не учитываются и не должны указываться в проектах, не использующих пакет SDK для .NET.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">Задача {0} из проекта {1} создает проект с помощью CLI {2}. Вместо этого следует использовать задачу MSBuild.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">Задачу "Exec" не следует использовать для создания проекта.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Свойство: к "{0}" получен доступ, но он не инициализирован.</target>
@@ -620,6 +630,11 @@
         <target state="translated">Метод {0} не может быть вызван с коллекцией, содержащей целевые имена, которые пусты или равны NULL.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Не удалось загрузить библиотеки телеметрии с исключением: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Выходное свойство: </target>
@@ -845,6 +860,11 @@ Errors: {3}</source>
         <target state="translated">Сопоставитель пакетов SDK "{0}" вернул значение null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">Не удалось разрешить SDK "{0}" с помощью сопоставителя SDK "{1}". {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: проект "{0}" пропустил ограничения изоляции графа в проекте "{1}", на который указывает ссылка.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 8bc03e8a1bc..004fafbaa16 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -221,6 +221,16 @@
         <target state="translated">'TargetFramework' ve 'TargetFrameworks' özellikleri dikkate alınmaz ve .NET SDK kullanmayan projelerde belirtilmeli.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">{1} projesindeki {0} görevi {2} CLI kullanılan bir proje oluşturur. Bunun yerine MSBuild görevi kullanılmalıdır.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">'Exec' görevi, bir projeyi oluşturmak için kullanılmamalıdır.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">'{0}' özelliğine erişildi, ancak hiç başlatılmadı.</target>
@@ -620,6 +630,11 @@
         <target state="translated">{0} metosu null veya boş hedef adları içeren bir koleksiyonla çağrılamaz.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">Telemetri kitaplıklarının yüklenmesi şu hayatla başarısız oldu: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">Çıkış Özelliği: </target>
@@ -845,6 +860,11 @@ Hatalar: {3}</target>
         <target state="translated">SDK çözümleyici "{0}" null döndürdü.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">SDK '{0}', SDK çözümleyici '{1}' tarafından çözümlenemedi. {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: "{0}" projesi, başvurulan "{1}" projesindeki graf yalıtımı kısıtlamalarını atladı</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index dcc11e8f51b..13047d4ac40 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -221,6 +221,16 @@
         <target state="translated">不考虑 “TargetFramework” 和 “TargetFrameworks” 属性，不应在不使用 .NET SDK 的项目中指定这些属性。</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">项目 {1} 中的任务 {0} 使用 {2} CLI 生成项目。应改用 MSBuild 任务。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">不应使用 "Exec" 任务来生成项目。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">已访问属性“{0}”，但从未将其初始化过。</target>
@@ -620,6 +630,11 @@
         <target state="translated">无法使用包含 null 或空目标名称的集合调用方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">加载遥测库失败，出现异常: {0}。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">输出属性: </target>
@@ -845,6 +860,11 @@ Errors: {3}</source>
         <target state="translated">SDK 解析程序“{0}”返回 null。</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">SDK 解析程序“{1}”无法解析 SDK“{0}”。{2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 项目“{0}”已跳过所引用的项目“{1}”上的图形隔离约束</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index beb75eae504..c4be1e9169a 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -221,6 +221,16 @@
         <target state="translated">未遵守 『TargetFramework』 和 『TargetFrameworks』 屬性，且不應在未使用 .NET SDK 的專案中指定。</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="translated">來自專案 {1} 的工作 {0} 使用 {2} CLI 建置專案。建議改用 MSBuild 工作。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0302_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="translated">不應該使用 'Exec' 工作來建置專案。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">已存取屬性: '{0}'，但從未初始化。</target>
@@ -620,6 +630,11 @@
         <target state="translated">無法使用內含 null 或空白目標名稱的集合呼叫方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OpenTelemetryLoadFailed">
+        <source>Loading telemetry libraries failed with exception: {0}.</source>
+        <target state="translated">載入遙測程式庫時發生例外狀況: {0}。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="OutputPropertyLogMessagePrefix">
         <source>Output Property: </source>
         <target state="translated">輸出屬性: </target>
@@ -845,6 +860,11 @@ Errors: {3}</source>
         <target state="translated">SDK 解析程式 "{0}" 傳回 Null。</target>
         <note />
       </trans-unit>
+      <trans-unit id="SingleResolverFailedToResolveSDK">
+        <source>SDK '{0}' could not be resolved by the SDK resolver '{1}'. {2}</source>
+        <target state="translated">SDK 解析程式 '{1}' 無法解析 SDK '{0}'。{2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 專案 "{0}" 已跳過參考專案 "{1}" 上的圖形隔離條件約束</target>
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 08e3fccb43f..489db4af2c1 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -362,6 +362,10 @@ public void WarningsCountExceedsLimitTest(bool buildInOutOfProcessNode, bool lim
     [InlineData("""<TargetFramework>net9.0</TargetFramework>""", "", false)]
     [InlineData("""<TargetFrameworks>net9.0;net472</TargetFrameworks>""", "", false)]
     [InlineData("""<TargetFrameworks>net9.0;net472</TargetFrameworks>""", " /p:TargetFramework=net9.0", false)]
+    [InlineData("""<TargetFramework></TargetFramework><TargetFrameworks>net9.0;net472</TargetFrameworks>""", "", false)]
+    [InlineData("""<TargetFramework /><TargetFrameworks>net9.0;net472</TargetFrameworks>""", "", false)]
+    [InlineData("""<TargetFramework>net9.0</TargetFramework><TargetFrameworks></TargetFrameworks>""", "", false)]
+    [InlineData("""<TargetFramework>net9.0</TargetFramework><TargetFrameworks />""", "", false)]
     [InlineData("""<TargetFramework>net9.0</TargetFramework><TargetFrameworks>net9.0;net472</TargetFrameworks>""", "", true)]
     public void TFMConfusionCheckTest(string tfmString, string cliSuffix, bool shouldTriggerCheck)
     {
diff --git a/src/BuildCheck.UnitTests/ExecCliBuildCheck_Tests.cs b/src/BuildCheck.UnitTests/ExecCliBuildCheck_Tests.cs
new file mode 100644
index 00000000000..105ba97f9e1
--- /dev/null
+++ b/src/BuildCheck.UnitTests/ExecCliBuildCheck_Tests.cs
@@ -0,0 +1,104 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.Runtime.InteropServices;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests
+{
+    public sealed class ExecCliBuildCheck_Tests
+    {
+        private const int MaxStackSizeWindows = 1024 * 1024; // 1 MB
+        private const int MaxStackSizeLinux = 1024 * 1024 * 8; // 8 MB
+
+        private readonly ExecCliBuildCheck _check;
+
+        private readonly MockBuildCheckRegistrationContext _registrationContext;
+
+        public static TheoryData<string?> BuildCommandTestData => new TheoryData<string?>(
+            "dotnet build",
+            "dotnet build&dotnet build",
+            "dotnet     build",
+            "dotnet clean",
+            "dotnet msbuild",
+            "dotnet restore",
+            "dotnet publish",
+            "dotnet pack",
+            "dotnet test",
+            "dotnet vstest",
+            "dotnet build -p:Configuration=Release",
+            "dotnet build /t:Restore;Clean",
+            "dotnet build&some command",
+            "some command&dotnet build&some other command",
+            "some command&dotnet build",
+            "some command&amp;dotnet build&amp;some other command",
+            "msbuild",
+            "msbuild /t:Build",
+            "msbuild --t:Restore;Clean",
+            "nuget restore",
+            "dotnet run --project project.SLN",
+            "dotnet run project.csproj",
+            "dotnet run project.proj",
+            "dotnet run",
+            string.Join(";", new string('a', 1025), "dotnet build", new string('a', 1025)),
+            string.Join(";", new string('a', RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? MaxStackSizeWindows * 2 : MaxStackSizeLinux * 2), "dotnet build"));
+
+        public static TheoryData<string?> NonBuildCommandTestData => new TheoryData<string?>(
+            "dotnet help",
+            "where dotnet",
+            "where msbuild",
+            "where nuget",
+            "dotnet bin/net472/project.dll",
+            string.Empty,
+            null,
+            new string('a', RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? MaxStackSizeWindows * 2 : MaxStackSizeLinux * 2));
+
+        public ExecCliBuildCheck_Tests()
+        {
+            _check = new ExecCliBuildCheck();
+            _registrationContext = new MockBuildCheckRegistrationContext();
+            _check.RegisterActions(_registrationContext);
+        }
+
+        [Theory]
+        [MemberData(nameof(BuildCommandTestData))]
+        public void ExecTask_WithCommandExecutingBuild_ShouldShowWarning(string? command)
+        {
+            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Exec", new Dictionary<string, TaskInvocationCheckData.TaskParameter>
+            {
+                { "Command", new TaskInvocationCheckData.TaskParameter(command, IsOutput: false) },
+            }));
+
+            _registrationContext.Results.Count.ShouldBe(1);
+            _registrationContext.Results[0].CheckRule.Id.ShouldBe("BC0302");
+        }
+
+        [Theory]
+        [MemberData(nameof(NonBuildCommandTestData))]
+        public void ExecTask_WithCommandNotExecutingBuild_ShouldNotShowWarning(string? command)
+        {
+            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Exec", new Dictionary<string, TaskInvocationCheckData.TaskParameter>
+            {
+                { "Command", new TaskInvocationCheckData.TaskParameter(command, IsOutput: false) },
+            }));
+
+            _registrationContext.Results.Count.ShouldBe(0);
+        }
+
+        private TaskInvocationCheckData MakeTaskInvocationData(string taskName, Dictionary<string, TaskInvocationCheckData.TaskParameter> parameters)
+        {
+            string projectFile = Framework.NativeMethods.IsWindows ? @"C:\fake\project.proj" : "/fake/project.proj";
+            return new TaskInvocationCheckData(
+                projectFile,
+                null,
+                Construction.ElementLocation.EmptyLocation,
+                taskName,
+                projectFile,
+                parameters);
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 440a60cc86e..76031c5b599 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -24,10 +24,13 @@
   </ItemGroup>
 
   <ItemGroup>
-    <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="Shouldly" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
+    <PackageReference Include="System.Collections.Immutable" />
 
-    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+    <Reference Include="System.Net.Http" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/EntryProject/EntryProject.csproj b/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/EntryProject/EntryProject.csproj
index 1ac36d043de..228409c378c 100644
--- a/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/EntryProject/EntryProject.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/EntryProject/EntryProject.csproj
@@ -4,6 +4,7 @@
     <TargetFramework>net9.0</TargetFramework>
     <ImplicitUsings>enable</ImplicitUsings>
     <Nullable>enable</Nullable>
+	<EnableCustomCulture>true</EnableCustomCulture>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/ReferencedProject/ReferencedProject.csproj b/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/ReferencedProject/ReferencedProject.csproj
index 4208181be80..c03ac65c696 100644
--- a/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/ReferencedProject/ReferencedProject.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/EmbeddedResourceTest/ReferencedProject/ReferencedProject.csproj
@@ -5,6 +5,7 @@
     <TargetFramework>net8.0</TargetFramework>
     <ImplicitUsings>enable</ImplicitUsings>
     <Nullable>enable</Nullable>
+	<EnableCustomCulture>true</EnableCustomCulture>
   </PropertyGroup>
 
   <PropertyGroup>
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 91e186d7fe3..deba5dbaf7a 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -138,6 +138,52 @@
 
   <Import Project="$(BUILD_STAGINGDIRECTORY)\MicroBuild\Plugins\MicroBuild.Plugins.IBCMerge.*\**\build\MicroBuild.Plugins.*.targets" Condition="'$(BUILD_STAGINGDIRECTORY)' != '' and $(TargetFramework.StartsWith('net4')) and '$(MicroBuild_EnablePGO)' != 'false'" />
 
+  <PropertyGroup>
+    <UseFrozenMaintenancePackageVersions Condition="'$(UseFrozenMaintenancePackageVersions)' == '' AND '$(IsUnitTestProject)' != 'true' AND $([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'net472')) AND '$(OutputType)' != 'exe'">true</UseFrozenMaintenancePackageVersions>
+
+    <FrozenMicrosoftIORedistVersion>6.0.1</FrozenMicrosoftIORedistVersion>
+    <FrozenSystemMemoryVersion>4.5.5</FrozenSystemMemoryVersion>
+    <FrozenSystemRuntimeCompilerServicesUnsafeVersion>6.0.0</FrozenSystemRuntimeCompilerServicesUnsafeVersion>
+    <FrozenSystemThreadingTasksExtensionsVersion>4.5.4</FrozenSystemThreadingTasksExtensionsVersion>
+    <FrozenSystemBuffersVersion>4.5.1</FrozenSystemBuffersVersion>
+    <FrozenSystemNumericsVectorsVersion>4.5.0</FrozenSystemNumericsVectorsVersion>
+  </PropertyGroup>
+
+  <ItemGroup Condition="'$(UseFrozenMaintenancePackageVersions)' == 'true'">
+    <PackageDownload Include="Microsoft.IO.Redist" Version="[$(FrozenMicrosoftIORedistVersion)]" />
+    <PackageDownload Include="System.Memory" Version="[$(FrozenSystemMemoryVersion)]" />
+    <PackageDownload Include="System.Runtime.CompilerServices.Unsafe" Version="[$(FrozenSystemRuntimeCompilerServicesUnsafeVersion)]" />
+    <PackageDownload Include="System.Threading.Tasks.Extensions" Version="[$(FrozenSystemThreadingTasksExtensionsVersion)]" />
+    <PackageDownload Include="System.Buffers" Version="[$(FrozenSystemBuffersVersion)]" />
+    <PackageDownload Include="System.Numerics.Vectors" Version="[$(FrozenSystemNumericsVectorsVersion)]" />
+  </ItemGroup>
+
+  <!-- Work around maintenance-packages updates breaking stuff -->
+  <Target Name="ReplaceCompileReferencesWithOlderMaintenancePackagesVersions"
+          BeforeTargets="ResolveAssemblyReferences"
+          Condition="$(UseFrozenMaintenancePackageVersions) == 'true'">
+
+    <ItemGroup>
+      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' == 'Microsoft.IO.Redist' and $([MSBuild]::VersionGreaterThan(%(Reference.NuGetPackageVersion), '$(FrozenMicrosoftIORedistVersion)'))" />
+      <Reference Include="$(NuGetPackageRoot)microsoft.io.redist\$(FrozenMicrosoftIORedistVersion)\lib\net472\Microsoft.IO.Redist.dll" />
+
+      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' == 'System.Buffers' and $([MSBuild]::VersionGreaterThan(%(Reference.NuGetPackageVersion), '$(FrozenSystemBuffersVersion)'))" />
+      <Reference Include="$(NuGetPackageRoot)system.buffers\$(FrozenSystemBuffersVersion)\lib\net461\System.Buffers.dll" />
+
+      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' == 'System.Memory' and $([MSBuild]::VersionGreaterThan(%(Reference.NuGetPackageVersion), '$(FrozenSystemMemoryVersion)'))" />
+      <Reference Include="$(NuGetPackageRoot)system.memory\$(FrozenSystemMemoryVersion)\lib\net461\System.Memory.dll" />
+
+      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' == 'System.Numerics.Vectors' and $([MSBuild]::VersionGreaterThan(%(Reference.NuGetPackageVersion), '$(FrozenSystemNumericsVectorsVersion)'))" />
+      <Reference Include="$(NuGetPackageRoot)system.numerics.vectors\$(FrozenSystemNumericsVectorsVersion)\lib\net46\System.Numerics.Vectors.dll" />
+
+      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' == 'System.Runtime.CompilerServices.Unsafe' and $([MSBuild]::VersionGreaterThan(%(Reference.NuGetPackageVersion), '$(FrozenSystemRuntimeCompilerServicesUnsafeVersion)'))" />
+      <Reference Include="$(NuGetPackageRoot)system.runtime.compilerservices.unsafe\$(FrozenSystemRuntimeCompilerServicesUnsafeVersion)\lib\net461\System.Runtime.CompilerServices.Unsafe.dll" />
+
+      <Reference Remove="@(Reference)" Condition="'%(Reference.NuGetPackageId)' == 'System.Threading.Tasks.Extensions' and $([MSBuild]::VersionGreaterThan(%(Reference.NuGetPackageVersion), '$(FrozenSystemThreadingTasksExtensionsVersion)'))" />
+      <Reference Include="$(NuGetPackageRoot)system.threading.tasks.extensions\$(FrozenSystemThreadingTasksExtensionsVersion)\lib\net461\System.Threading.Tasks.Extensions.dll" />
+    </ItemGroup>
+  </Target>
+
   <!-- Import parent targets -->
   <Import Project="..\Directory.Build.targets"/>
 
diff --git a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
index 4968243235a..a8ba7a3286a 100644
--- a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
@@ -16,18 +16,12 @@ namespace Microsoft.Build.UnitTests
     /// </summary>
     public class ProjectStartedEventArgs_Tests
     {
-        /// <summary>
-        /// Default event to use in tests.
-        /// </summary>
-        private static ProjectStartedEventArgs s_baseProjectStartedEvent;
-
         /// <summary>
         /// Setup for text fixture, this is run ONCE for the entire test fixture
         /// </summary>
         public ProjectStartedEventArgs_Tests()
         {
             BuildEventContext parentBuildEventContext = new BuildEventContext(2, 3, 4, 5);
-            s_baseProjectStartedEvent = new ProjectStartedEventArgs(1, "Message", "HelpKeyword", "ProjecFile", "TargetNames", null, null, parentBuildEventContext);
         }
 
         /// <summary>
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index ecf16907307..f7d7931853f 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -56,23 +56,28 @@ internal static ITranslator GetWriteTranslator(Stream stream)
         private class BinaryReadTranslator : ITranslator
         {
             /// <summary>
-            /// The stream used as a source or destination for data.
+            /// The intern reader used in an intern scope.
             /// </summary>
-            private Stream _packetStream;
+            private readonly InterningReadTranslator _interner;
 
             /// <summary>
             /// The binary reader used in read mode.
             /// </summary>
             private BinaryReader _reader;
 
+            /// <summary>
+            /// Whether the caller has entered an intern scope.
+            /// </summary>
+            private bool _isInterning;
+
 #nullable enable
             /// <summary>
             /// Constructs a serializer from the specified stream, operating in the designated mode.
             /// </summary>
             public BinaryReadTranslator(Stream packetStream, BinaryReaderFactory buffer)
             {
-                _packetStream = packetStream;
                 _reader = buffer.Create(packetStream);
+                _interner = new InterningReadTranslator(this);
             }
 #nullable disable
 
@@ -788,6 +793,80 @@ public bool TranslateNullable<T>(T value)
                 bool haveRef = _reader.ReadBoolean();
                 return haveRef;
             }
+
+            public void WithInterning(IEqualityComparer<string> comparer, int initialCapacity, Action<ITranslator> internBlock)
+            {
+                if (_isInterning)
+                {
+                    throw new InvalidOperationException("Cannot enter recursive intern block.");
+                }
+
+                _isInterning = true;
+
+                // Deserialize the intern header before entering the intern scope.
+                _interner.Translate(this);
+
+                // No other setup is needed since we can parse the packet directly from the stream.
+                internBlock(this);
+
+                _isInterning = false;
+            }
+
+            public void Intern(ref string str, bool nullable = true)
+            {
+                if (!_isInterning)
+                {
+                    Translate(ref str);
+                    return;
+                }
+
+                if (nullable && !TranslateNullable(string.Empty))
+                {
+                    str = null;
+                    return;
+                }
+
+                str = _interner.Read();
+            }
+
+            public void Intern(ref string[] array)
+            {
+                if (!_isInterning)
+                {
+                    Translate(ref array);
+                    return;
+                }
+
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                array = new string[count];
+
+                for (int i = 0; i < count; i++)
+                {
+                    array[i] = _interner.Read();
+                }
+            }
+
+            public void InternPath(ref string str, bool nullable = true)
+            {
+                if (!_isInterning)
+                {
+                    Translate(ref str);
+                    return;
+                }
+
+                if (nullable && !TranslateNullable(string.Empty))
+                {
+                    str = null;
+                    return;
+                }
+
+                str = _interner.ReadPath();
+            }
         }
 
         /// <summary>
@@ -796,14 +875,21 @@ public bool TranslateNullable<T>(T value)
         private class BinaryWriteTranslator : ITranslator
         {
             /// <summary>
-            /// The stream used as a source or destination for data.
+            /// The binary writer used in write mode.
             /// </summary>
-            private Stream _packetStream;
+            private BinaryWriter _writer;
 
             /// <summary>
-            /// The binary writer used in write mode.
+            /// The intern writer used in an intern scope.
+            /// This must be lazily instantiated since the interner has its own internal write translator, and
+            /// would otherwise go into a recursive loop on initalization.
             /// </summary>
-            private BinaryWriter _writer;
+            private InterningWriteTranslator _interner;
+
+            /// <summary>
+            /// Whether the caller has entered an intern scope.
+            /// </summary>
+            private bool _isInterning;
 
             /// <summary>
             /// Constructs a serializer from the specified stream, operating in the designated mode.
@@ -811,7 +897,6 @@ private class BinaryWriteTranslator : ITranslator
             /// <param name="packetStream">The stream serving as the source or destination of data.</param>
             public BinaryWriteTranslator(Stream packetStream)
             {
-                _packetStream = packetStream;
                 _writer = new BinaryWriter(packetStream);
             }
 
@@ -1510,6 +1595,92 @@ public bool TranslateNullable<T>(T value)
                 _writer.Write(haveRef);
                 return haveRef;
             }
+
+            public void WithInterning(IEqualityComparer<string> comparer, int initialCapacity, Action<ITranslator> internBlock)
+            {
+                if (_isInterning)
+                {
+                    throw new InvalidOperationException("Cannot enter recursive intern block.");
+                }
+
+                // Every new scope requires the interner's state to be reset.
+                _interner ??= new InterningWriteTranslator();
+                _interner.Setup(comparer, initialCapacity);
+
+                // Temporaily swap our writer with the interner.
+                // This forwards all writes to this translator into the interning buffer, so that any non-interned
+                // writes which are interleaved will be in the correct order.
+                BinaryWriter streamWriter = _writer;
+                _writer = _interner.Writer;
+                _isInterning = true;
+
+                try
+                {
+                    internBlock(this);
+                }
+                finally
+                {
+                    _writer = streamWriter;
+                    _isInterning = false;
+                }
+
+                // Write the interned buffer into the real output stream.
+                _interner.Translate(this);
+            }
+
+            public void Intern(ref string str, bool nullable = true)
+            {
+                if (!_isInterning)
+                {
+                    Translate(ref str);
+                    return;
+                }
+
+                if (nullable && !TranslateNullable(str))
+                {
+                    return;
+                }
+
+                _interner.Intern(str);
+            }
+
+            public void Intern(ref string[] array)
+            {
+                if (!_isInterning)
+                {
+                    Translate(ref array);
+                    return;
+                }
+
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = array.Length;
+                Translate(ref count);
+
+                for (int i = 0; i < count; i++)
+                {
+                    _interner.Intern(array[i]);
+                }
+            }
+
+            public void InternPath(ref string str, bool nullable = true)
+            {
+                if (!_isInterning)
+                {
+                    Translate(ref str);
+                    return;
+                }
+
+                if (nullable && !TranslateNullable(str))
+                {
+                    return;
+                }
+
+                _interner.InternPath(str);
+            }
         }
     }
 }
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index 1e1264246ec..a26e7b26948 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -284,7 +284,7 @@ private void SetBuildEventContextDefaultAfterSerialization(StreamingContext sc)
         /// This is used by the Message property overrides to reconstruct the
         /// message lazily on demand.
         /// </summary>
-        internal static Func<string, string?[], string> ResourceStringFormatter = (string resourceName, string?[] arguments) =>
+        internal static Func<string, string?[], string> ResourceStringFormatter = (resourceName, arguments) =>
         {
             var sb = new StringBuilder();
             sb.Append(resourceName);
diff --git a/src/Framework/IBuildEngine7.cs b/src/Framework/IBuildEngine7.cs
index c5fcd4c18a4..040e6ac338e 100644
--- a/src/Framework/IBuildEngine7.cs
+++ b/src/Framework/IBuildEngine7.cs
@@ -11,6 +11,6 @@ namespace Microsoft.Build.Framework
     /// </summary>
     public interface IBuildEngine7 : IBuildEngine6
     {
-        public bool AllowFailureWithoutError { get; set; }
+        bool AllowFailureWithoutError { get; set; }
     }
 }
diff --git a/src/Framework/IBuildEngine8.cs b/src/Framework/IBuildEngine8.cs
index 7d08daa0c4d..d31e09ed246 100644
--- a/src/Framework/IBuildEngine8.cs
+++ b/src/Framework/IBuildEngine8.cs
@@ -17,6 +17,6 @@ public interface IBuildEngine8 : IBuildEngine7
         /// </summary>
         /// <param name="warningCode">The warning code to check.</param>
         /// <returns>A boolean to determine whether the warning should be treated as an error.</returns>
-        public bool ShouldTreatWarningAsError(string warningCode);
+        bool ShouldTreatWarningAsError(string warningCode);
     }
 }
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index 5f6655cef36..c33ba195c03 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -366,5 +366,59 @@ void TranslateDictionary<D, T>(ref D dictionary, ObjectTranslator<T> objectTrans
         /// <typeparam name="T">The type of object to test.</typeparam>
         /// <returns>True if the object should be written, false otherwise.</returns>
         bool TranslateNullable<T>(T value);
+
+        /// <summary>
+        /// Creates a scope which activates string interning / deduplication for any Intern_xx method.
+        /// This should generally be called from the root level packet.
+        /// </summary>
+        /// <param name="comparer">The string comparer to use when populating the intern cache.</param>
+        /// <param name="initialCapacity">The initial capacity of the intern cache.</param>
+        /// <param name="internBlock">A delegate providing a translator, in which all Intern_xx calls will go through the intern cache.</param>
+        /// <remarks>
+        /// Packet interning is implemented via a header with an array of all interned strings, followed by the body in
+        /// which any interned / duplicated strings are replaced by their ID.
+        /// <see cref="TranslationDirection"/> modes have different ordering requirements, so it would not be
+        /// possible to implement direction-agnostic serialization via the Intern_xx methods alone:
+        /// - Write: Because we don't know the full list of strings ahead of time, we need to create a temporary buffer
+        ///   for the packet body, which we can later offset when flushing to the real stream.
+        /// - Read: The intern header needs to be deserialized before the packet body, otherwise we won't know what
+        ///   string each ID maps to.
+        /// This method abstracts these requirements to the caller, such that the underlying translator will
+        /// automatically handle the appropriate IO ordering when entering / exiting the delegate scope.
+        /// </remarks>
+        void WithInterning(IEqualityComparer<string> comparer, int initialCapacity, Action<ITranslator> internBlock);
+
+        /// <summary>
+        /// Interns the string if the translator is currently within an intern block.
+        /// Otherwise, this forwards to the regular Translate method.
+        /// </summary>
+        /// <param name="str">The value to be translated.</param>
+        /// <param name="nullable">
+        /// Whether to null check and translate the nullable marker.
+        /// Setting this to false can reduce packet sizes when interning large numbers of strings
+        /// which are validated to always be non-null, such as dictionary keys.
+        /// </param>
+        void Intern(ref string str, bool nullable = true);
+
+        /// <summary>
+        /// Interns each string in the array if the translator is currently within an intern block.
+        /// Otherwise, this forwards to the regular Translate method. To match behavior, all strings
+        /// assumed to be non-null.
+        /// </summary>
+        /// <param name="array">The array to be translated.</param>
+        void Intern(ref string[] array);
+
+        /// <summary>
+        /// Interns the string if the translator is currently within an intern block.
+        /// Otherwise, this forwards to the regular Translate method.
+        /// If the string is determined to be path-like, the path components will be interned separately.
+        /// </summary>
+        /// <param name="str">The value to be translated.</param>
+        /// <param name="nullable">
+        /// Whether to null check and translate the nullable marker.
+        /// Setting this to false can reduce packet sizes when interning large numbers of strings
+        /// which are validated to always be non-null, such as dictionary keys.
+        /// </param>
+        void InternPath(ref string str, bool nullable = true);
     }
 }
diff --git a/src/Framework/InternPathIds.cs b/src/Framework/InternPathIds.cs
new file mode 100644
index 00000000000..029f31f95ed
--- /dev/null
+++ b/src/Framework/InternPathIds.cs
@@ -0,0 +1,7 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.BackEnd
+{
+    internal readonly record struct InternPathIds(int DirectoryId, int FileNameId);
+}
diff --git a/src/Framework/InternalErrorException.cs b/src/Framework/InternalErrorException.cs
index 73180f14fb8..8b1096c5eef 100644
--- a/src/Framework/InternalErrorException.cs
+++ b/src/Framework/InternalErrorException.cs
@@ -148,6 +148,8 @@ private static void LaunchDebugger(string message, string innerMessage)
         }
         #endregion
 
+#if DEBUG
         private static bool RunningTests() => BuildEnvironmentState.s_runningTests;
+#endif
     }
 }
diff --git a/src/Framework/InterningReadTranslator.cs b/src/Framework/InterningReadTranslator.cs
new file mode 100644
index 00000000000..76a3d35b8f0
--- /dev/null
+++ b/src/Framework/InterningReadTranslator.cs
@@ -0,0 +1,84 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// Reads strings form a translator which contains interned packets.
+    /// </summary>
+    /// <remarks>
+    /// This maintains a reusable lookup table to deserialize packets interned by <see cref="InterningWriteTranslator"/>.
+    /// On Translate, the intern header (aka the array of strings indexed by ID) is deserialized.
+    /// The caller can then forward reads to deserialize any interned values in the packet body.
+    /// </remarks>
+    internal sealed class InterningReadTranslator : ITranslatable
+    {
+        private readonly ITranslator _translator;
+
+        private List<string> _strings = [];
+
+        private Dictionary<InternPathIds, string> _pathIdsToString = [];
+
+        internal InterningReadTranslator(ITranslator translator)
+        {
+            if (translator.Mode != TranslationDirection.ReadFromStream)
+            {
+                throw new InvalidOperationException(
+                    $"{nameof(InterningReadTranslator)} can only be used with {nameof(TranslationDirection.ReadFromStream)}.");
+            }
+
+            _translator = translator;
+        }
+
+        internal string? Read()
+        {
+            int key = -1;
+            _translator.Translate(ref key);
+            return _strings[key];
+        }
+
+        internal string? ReadPath()
+        {
+            // If the writer set a null marker, read this as a single string.
+            if (!_translator.TranslateNullable(string.Empty))
+            {
+                return Read();
+            }
+
+            int directoryKey = -1;
+            int fileNameKey = -1;
+            _translator.Translate(ref directoryKey);
+            _translator.Translate(ref fileNameKey);
+
+            InternPathIds pathIds = new(directoryKey, fileNameKey);
+
+            // Only concatenate paths the first time we encounter a pair.
+            if (_pathIdsToString.TryGetValue(pathIds, out string? path))
+            {
+                return path;
+            }
+
+            string directory = _strings[pathIds.DirectoryId];
+            string fileName = _strings[pathIds.FileNameId];
+            string str = string.Concat(directory, fileName);
+            _pathIdsToString.Add(pathIds, str);
+
+            return str;
+        }
+
+        public void Translate(ITranslator translator)
+        {
+            // Only deserialize the intern header since the caller will be reading directly from the stream.
+            _translator.Translate(ref _strings);
+#if NET
+            _pathIdsToString.Clear();
+            _pathIdsToString.EnsureCapacity(_strings.Count);
+#else
+            _pathIdsToString = new(_strings.Count);
+#endif
+        }
+    }
+}
diff --git a/src/Framework/InterningWriteTranslator.cs b/src/Framework/InterningWriteTranslator.cs
new file mode 100644
index 00000000000..ec31eb92eb4
--- /dev/null
+++ b/src/Framework/InterningWriteTranslator.cs
@@ -0,0 +1,173 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// Writes strings into a translator with interning / deduplication.
+    /// </summary>
+    /// <remarks>
+    /// This maintains a reusable temporary buffer and lookup table for deduplicating strings within a translatable packet.
+    /// All unique strings (as determined by the comparer) will be assigned an incrementing ID and stored into a dictionary.
+    /// This ID will be written to a private buffer in place of the string and any repeat occurrences.
+    /// When serialized into another translator, the interner will:
+    /// 1. Serialize the list of unique strings to an array, where the ID is the index.
+    /// 2. Serialize the temporary buffer (aka the packet body) with all interned strings replaced by their ID.
+    /// This ordering is important since the reader will need the string lookup table before parsing the body.
+    /// As such, two rules need to be followed when using this class:
+    /// 1. Any interleaved non-interned writes should be written using the exposed BinaryWriter to keep the overall
+    /// packet in sync.
+    /// 2. Translate should *only* be called after all internable writes have been processed.
+    /// </remarks>
+    internal sealed class InterningWriteTranslator : ITranslatable
+    {
+        private static readonly char[] DirectorySeparatorChars = [Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar];
+
+        private static readonly string IsPathMarker = string.Empty;
+
+        private static readonly string? NotPathMarker = null;
+
+        private readonly ITranslator _translator;
+
+        private readonly MemoryStream _packetStream;
+
+        private List<string> _strings = [];
+
+        private Dictionary<string, int> _stringToIds = [];
+
+        private Dictionary<string, InternPathIds> _stringToPathIds = [];
+
+        internal InterningWriteTranslator()
+        {
+            _packetStream = new MemoryStream();
+            _translator = BinaryTranslator.GetWriteTranslator(_packetStream);
+
+            // Avoid directly exposing the buffered translator - any accidental Intern_xx method calls could go into a
+            // recursive loop.
+            Writer = _translator.Writer;
+        }
+
+        /// <summary>
+        /// The writer for the underlying buffer.
+        /// Use to forward any non-interning writes into this translator.
+        /// </summary>
+        internal BinaryWriter Writer { get; }
+
+        /// <summary>
+        /// Setup the intern cache and underlying buffer. This allows the interner to be reused.
+        /// </summary>
+        /// <param name="comparer">The string comparer to use for string deduplication.</param>
+        /// <param name="initialCapacity">An estimate of the number of unique strings to be interned.</param>
+        internal void Setup(IEqualityComparer<string> comparer, int initialCapacity)
+        {
+#if NET
+            if (_stringToIds.Comparer == comparer)
+            {
+                // Clear before setting capacity, since dictionaries will rehash every entry.
+                _strings.Clear();
+                _stringToIds.Clear();
+                _stringToPathIds.Clear();
+                _strings.EnsureCapacity(initialCapacity);
+                _stringToIds.EnsureCapacity(initialCapacity);
+                _stringToPathIds.EnsureCapacity(initialCapacity);
+            }
+            else
+            {
+#endif
+                // If the interner is in a reused translator, the comparer might not match between packets.
+                // Just throw away the old collections in this case.
+                _strings.Clear();
+                _strings.Capacity = initialCapacity;
+                _stringToIds = new Dictionary<string, int>(initialCapacity, comparer);
+                _stringToPathIds = new Dictionary<string, InternPathIds>(initialCapacity, comparer);
+#if NET
+            }
+#endif
+            _packetStream.Position = 0;
+            _packetStream.SetLength(0);
+
+            // This is a rough estimate since the final size will depend on the length of each string and the total number
+            // of intern cache hits. Assume a mixture of short strings (e.g. item metadata pairs, RAR assembly metadata)
+            // and file paths (e.g. item include paths, RAR statefile entries).
+            const int CharactersPerString = 32;
+            const int BytesPerCharacter = 2;
+            const int BytesPerInternedString = 5;
+            int internHeaderSize = initialCapacity * CharactersPerString * BytesPerCharacter;
+            int packetPayloadSize = initialCapacity * BytesPerInternedString;
+            _packetStream.Capacity = internHeaderSize + packetPayloadSize;
+        }
+
+        internal void Intern(string str) => _ = InternString(str);
+
+        private int InternString(string str)
+        {
+            if (!_stringToIds.TryGetValue(str, out int index))
+            {
+                index = _strings.Count;
+                _stringToIds.Add(str, index);
+                _strings.Add(str);
+            }
+
+            _translator.Translate(ref index);
+            return index;
+        }
+
+        internal void InternPath(string str)
+        {
+            // If we've seen a string already and know it's path-like, we just need the index pair.
+            if (_stringToPathIds.TryGetValue(str, out InternPathIds pathIds))
+            {
+                _ = _translator.TranslateNullable(IsPathMarker);
+                int directoryId = pathIds.DirectoryId;
+                int fileNameId = pathIds.FileNameId;
+                _translator.Translate(ref directoryId);
+                _translator.Translate(ref fileNameId);
+                return;
+            }
+
+            // Quick and basic heuristic to check if we have a path-like string.
+            int splitId = str.LastIndexOfAny(DirectorySeparatorChars);
+            bool hasDirectorySeparator = splitId > -1
+                && splitId < str.Length - 1
+                && str.IndexOf('%') == -1;
+
+            if (!hasDirectorySeparator)
+            {
+                // Set a marker to signal the reader to parse this as a single string.
+                _ = _translator.TranslateNullable(NotPathMarker);
+                _ = InternString(str);
+                return;
+            }
+
+            string directory = str.Substring(0, splitId + 1);
+            string fileName = str.Substring(splitId + 1);
+
+            _ = _translator.TranslateNullable(IsPathMarker);
+            int directoryIndex = InternString(directory);
+            int fileNameIndex = InternString(fileName);
+
+            _stringToPathIds.Add(str, new InternPathIds(directoryIndex, fileNameIndex));
+        }
+
+        public void Translate(ITranslator translator)
+        {
+            if (translator.Mode != TranslationDirection.WriteToStream)
+            {
+                throw new InvalidOperationException(
+                    $"{nameof(InterningWriteTranslator)} can only be used with {nameof(TranslationDirection.WriteToStream)}.");
+            }
+
+            // Write the set of unique strings as the packet header.
+            translator.Translate(ref _strings);
+
+            // Write the temporary buffer as the packet body.
+            byte[] buffer = _packetStream.GetBuffer();
+            int bufferSize = (int)_packetStream.Length;
+            translator.Writer.Write(buffer, 0, bufferSize);
+        }
+    }
+}
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 4b403ebdf1d..5ed8c01507d 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -79,11 +79,12 @@ public void BuildStop()
         /// <summary>
         /// Call this method to notify listeners of information of how a project file built.
         /// <param name="projectPath">Filename of the project being built.</param>
+        /// <param name="targets">Names of the targets that built.</param>
         /// </summary>
-        [Event(5, Keywords = Keywords.All | Keywords.PerformanceLog)]
-        public void BuildProjectStart(string projectPath)
+        [Event(5, Keywords = Keywords.All | Keywords.PerformanceLog, Version = 1)]
+        public void BuildProjectStart(string projectPath, string targets)
         {
-            WriteEvent(5, projectPath);
+            WriteEvent(5, projectPath, targets);
         }
 
         /// <param name="projectPath">Filename of the project being built.</param>
@@ -672,6 +673,12 @@ public void ProjectCacheHandleBuildResultStop(string pluginTypeName, string proj
         {
             WriteEvent(92, pluginTypeName, projectPath, targets);
         }
+
+        [Event(93, Keywords = Keywords.All)]
+        public void CancelSubmissionsStart()
+        {
+            WriteEvent(93);
+        }
         #endregion
     }
 }
diff --git a/src/Framework/Telemetry/OpenTelemetryManager.cs b/src/Framework/Telemetry/OpenTelemetryManager.cs
index a659cb9a932..785c90edb42 100644
--- a/src/Framework/Telemetry/OpenTelemetryManager.cs
+++ b/src/Framework/Telemetry/OpenTelemetryManager.cs
@@ -39,6 +39,8 @@ internal class OpenTelemetryManager
         private IOpenTelemetryCollector? _collector;
 #endif
 
+        public string? LoadFailureExceptionMessage { get; set; }
+
         /// <summary>
         /// Optional activity source for MSBuild or other telemetry usage.
         /// </summary>
@@ -104,6 +106,7 @@ public void Initialize(bool isStandalone)
             {
                 // catch exceptions from loading the OTel SDK or Collector to maintain usability of Microsoft.Build.Framework package in our and downstream tests in VS.
                 _telemetryState = TelemetryState.Unsampled;
+                LoadFailureExceptionMessage = ex.ToString();
                 return;
             }
 #endif
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index f2447e47031..e355761d9fd 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -7,11 +7,12 @@
 namespace Microsoft.Build.Framework
 {
     /// <summary>
-    ///     Represents toggleable features of the MSBuild engine
+    ///     Represents toggleable features of the MSBuild engine.
     /// </summary>
     internal class Traits
     {
         private static Traits _instance = new Traits();
+
         public static Traits Instance
         {
             get
@@ -132,7 +133,6 @@ public Traits()
 
         public readonly bool InProcNodeDisabled = Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") == "1";
 
-
         /// <summary>
         /// Variables controlling opt out at the level of not initializing telemetry infrastructure. Set to "1" or "true" to opt out.
         /// mirroring
diff --git a/src/MSBuild.Bootstrap.Utils/Tasks/LocateVisualStudioTask.cs b/src/MSBuild.Bootstrap.Utils/Tasks/LocateVisualStudioTask.cs
new file mode 100644
index 00000000000..91cf7608e36
--- /dev/null
+++ b/src/MSBuild.Bootstrap.Utils/Tasks/LocateVisualStudioTask.cs
@@ -0,0 +1,62 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.Runtime.InteropServices;
+using System.Text;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+namespace MSBuild.Bootstrap.Utils.Tasks
+{
+    public class LocateVisualStudioTask : ToolTask
+    {
+        private readonly StringBuilder _standardOutput = new();
+
+        [Output]
+        public string VsInstallPath { get; set; }
+
+        protected override string ToolName => "vswhere.exe";
+
+        protected override string GenerateFullPathToTool()
+        {
+            string programFilesX86 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86);
+            string vsWherePath = Path.Combine(programFilesX86, "Microsoft Visual Studio", "Installer", ToolName);
+
+
+            return vsWherePath;
+        }
+
+        protected override string GenerateCommandLineCommands() => "-latest -prerelease -property installationPath";
+
+        public override bool Execute()
+        {
+            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                Log.LogMessage(MessageImportance.High, "Not running on Windows. Skipping Visual Studio detection.");
+                return true;
+            }
+
+            _ = ExecuteTool(GenerateFullPathToTool(), string.Empty, GenerateCommandLineCommands());
+
+            if (!Log.HasLoggedErrors)
+            {
+                VsInstallPath = _standardOutput.ToString().Trim();
+            }
+
+            return true;
+        }
+
+        // Override to capture standard output
+        protected override void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance)
+        {
+            if (!string.IsNullOrWhiteSpace(singleLine))
+            {
+                _ = _standardOutput.AppendLine(singleLine);
+            }
+
+            base.LogEventsFromTextOutput(singleLine, messageImportance);
+        }
+    }
+}
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 0876e2b8eec..4839c0dcbfa 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -9,6 +9,9 @@
     <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>None</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
 
     <DeterministicSourcePaths>false</DeterministicSourcePaths>
+
+    <!-- The output of this project is sort of an "executable" so it can get the latest versions of everything. -->
+    <UseFrozenMaintenancePackageVersions>false</UseFrozenMaintenancePackageVersions>
   </PropertyGroup>
 
   <ItemGroup>
@@ -53,4 +56,4 @@
 
   <Import Project="$(RepoRoot)eng\BootStrapMsBuild.targets" />
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index bc93f3ea4aa..b18eb45c346 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -10,6 +10,7 @@
 using System.Linq;
 using System.Reflection;
 using System.Runtime.InteropServices;
+using System.Text.RegularExpressions;
 using System.Threading;
 using System.Xml.Linq;
 using Microsoft.Build.CommandLine;
@@ -2711,6 +2712,16 @@ public void EndToEndMinimumMessageImportance(string arguments, MessageImportance
 
             TransientTestProjectWithFiles testProject = testEnvironment.CreateTestProjectWithFiles(projectContents);
 
+            // If /bl is specified, set a path for the binlog that is defined by the test environment
+            string pattern = @"/v:(\w+)\s/b"; ;
+            Regex.Match(arguments, pattern);
+            Match match = Regex.Match(arguments, pattern);
+            if (match.Success)
+            {
+                string binlogPath = Path.Combine(testProject.TestRoot, match.Groups[1] + ".binlog");
+                arguments = arguments.Replace("/bl", $"/bl:{binlogPath}");
+            }
+
             // Build in-proc.
             RunnerUtilities.ExecMSBuild($"{arguments} \"{testProject.ProjectFile}\"", out bool success, _output);
             success.ShouldBeTrue();
diff --git a/src/MSBuild/CommandLineSwitchException.cs b/src/MSBuild/CommandLineSwitchException.cs
index fdfd2b36762..e8ce5dd036d 100644
--- a/src/MSBuild/CommandLineSwitchException.cs
+++ b/src/MSBuild/CommandLineSwitchException.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.CommandLine
     /// This exception is used to flag (syntax) errors in command line switches passed to the application.
     /// </summary>
     [Serializable]
-    internal sealed class CommandLineSwitchException : Exception
+    internal sealed class CommandLineSwitchException : Exception // CodeQL [SM02227] The dangerous method is called only in debug build. It's safe for release build.
     {
         /// <summary>
         /// This constructor initializes the exception message.
diff --git a/src/MSBuild/InitializationException.cs b/src/MSBuild/InitializationException.cs
index 4607ec549af..2d1153029b7 100644
--- a/src/MSBuild/InitializationException.cs
+++ b/src/MSBuild/InitializationException.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.CommandLine
     /// Unlike the CommandLineSwitchException, this exception is NOT thrown for syntax errors in switches.
     /// </remarks>
     [Serializable]
-    internal sealed class InitializationException : Exception
+    internal sealed class InitializationException : Exception // CodeQL [SM02227] The dangerous method is called only in debug build. It's safe for release build.
     {
         /// <summary>
         /// This constructor initializes the exception message.
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 2edca8c339b..686e78276ab 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -179,7 +179,6 @@
 
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
-    <PackageReference Include="System.Diagnostics.DiagnosticSource" /><!-- for consistency with Framework via transitives -->
   </ItemGroup>
   <!-- Manually download this library for RoslynCodeTaskFactory.
            See target AddRefAssemblies below. -->
@@ -194,6 +193,7 @@
     <Reference Include="System.Core" />
     <Reference Include="System.Xml" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
+    <PackageReference Include="System.Diagnostics.DiagnosticSource" /><!-- for consistency with Framework via transitives -->
   </ItemGroup>
 
   <ItemGroup>
@@ -274,9 +274,6 @@
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.VisualBasic.CrossTargeting.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.VisualBasic.CurrentVersion.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.VisualBasic.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
-      <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.VisualStudioVersion.v11.Common.props" TargetFramework="%(_TargetFrameworks.Identity)" />
-      <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.VisualStudioVersion.v12.Common.props" TargetFramework="%(_TargetFrameworks.Identity)" />
-      <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.VisualStudioVersion.v14.Common.props" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\ref\**" TargetFramework="%(_TargetFrameworks.Identity)" Subdirectory="ref\" />
     </ItemGroup>
 
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 05365f4f62a..56c53a3af4d 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1893,6 +1893,7 @@ elementFormDefault="qualified">
     <xs:element name="LinkIncremental" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestCertificateThumbprint" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestKeyFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="EnableCustomCulture" type="msb:boolean" substitutionGroup="msb:EnableCustomCulture"/>
     <xs:element name="MapFileExtensions" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="MapFileExtensions" _locComment="" -->boolean</xs:documentation>
diff --git a/src/MSBuild/MSBuildClientApp.cs b/src/MSBuild/MSBuildClientApp.cs
index be768b58b8d..3eeb975bc40 100644
--- a/src/MSBuild/MSBuildClientApp.cs
+++ b/src/MSBuild/MSBuildClientApp.cs
@@ -97,28 +97,5 @@ public static MSBuildApp.ExitType Execute(
 
             return MSBuildApp.ExitType.MSBuildClientFailure;
         }
-
-        // Copied from NodeProviderOutOfProcBase.cs
-#if RUNTIME_TYPE_NETCORE
-        private static string? CurrentHost;
-        private static string GetCurrentHost()
-        {
-            if (CurrentHost == null)
-            {
-                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, 2),
-                    NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet");
-                if (File.Exists(dotnetExe))
-                {
-                    CurrentHost = dotnetExe;
-                }
-                else
-                {
-                    CurrentHost = EnvironmentUtilities.ProcessPath ?? throw new InvalidOperationException("Failed to retrieve process executable.");
-                }
-            }
-
-            return CurrentHost;
-        }
-#endif
     }
 }
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index fbd97f6e083..9b670a086d4 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -591,6 +591,16 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
             _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
         }
 
+        /// <summary>
+        /// Takes a serializer and deserializes the packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            return _packetFactory.DeserializePacket(packetType, translator);
+        }
+
         /// <summary>
         /// Routes the specified packet
         /// </summary>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 357cb767e84..77637578738 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1045,6 +1045,13 @@ public static ExitType Execute(
 
                 exitType = ExitType.Unexpected;
             }
+            catch (PathTooLongException e)
+            {
+                Console.WriteLine(
+                    $"{e.Message}{(e.InnerException != null ? $" {e.InnerException.Message}" : string.Empty)}");
+
+                exitType = ExitType.Unexpected;
+            }
             // handle fatal errors
             catch (Exception e)
             {
@@ -4526,6 +4533,7 @@ private static void ReplayBinaryLog(
             }
         }
 
+#if FEATURE_XML_SCHEMA_VALIDATION
         /// <summary>
         /// Figures out if the project needs to be validated against a schema.
         /// </summary>
@@ -4546,6 +4554,7 @@ private static string ProcessValidateSwitch(string[] parameters)
 
             return schemaFile;
         }
+#endif
 
         /// <summary>
         /// Given an invalid ToolsVersion string and the collection of valid toolsets,
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index ca919c51e3f..528707c3e22 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -39,8 +39,8 @@
 
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.IO.Redist" culture="neutral" publicKeyToken="cc7b13ffcd2ddd51" />
-          <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="6.0.0.1" />
-          <codeBase version="6.0.0.1" href="..\Microsoft.IO.Redist.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-6.1.0.0" newVersion="6.1.0.0" />
+          <codeBase version="6.1.0.0" href="..\Microsoft.IO.Redist.dll"/>
         </dependentAssembly>
 
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
@@ -94,8 +94,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
-          <codeBase version="4.0.3.0" href="..\System.Buffers.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.0.4.0" newVersion="4.0.4.0" />
+          <codeBase version="4.0.4.0" href="..\System.Buffers.dll"/>
         </dependentAssembly>
 
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
@@ -190,13 +190,13 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.1.2" newVersion="4.0.1.2" />
-          <codeBase version="4.0.1.2" href="..\System.Memory.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.0.2.0" newVersion="4.0.2.0" />
+          <codeBase version="4.0.2.0" href="..\System.Memory.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
-          <codeBase version="4.1.4.0" href="..\System.Numerics.Vectors.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.1.5.0" newVersion="4.1.5.0" />
+          <codeBase version="4.1.5.0" href="..\System.Numerics.Vectors.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -215,8 +215,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
-          <codeBase version="6.0.0.0" href="..\System.Runtime.CompilerServices.Unsafe.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-6.0.1.0" newVersion="6.0.1.0" />
+          <codeBase version="6.0.1.0" href="..\System.Runtime.CompilerServices.Unsafe.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -240,8 +240,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
-          <codeBase version="4.2.0.1" href="..\System.Threading.Tasks.Extensions.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.2.1.0" newVersion="4.2.1.0" />
+          <codeBase version="4.2.1.0" href="..\System.Threading.Tasks.Extensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index f1bb2ea9f69..cd0059bd3db 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -45,7 +45,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.IO.Redist" culture="neutral" publicKeyToken="cc7b13ffcd2ddd51" />
-          <bindingRedirect oldVersion="0.0.0.0-6.0.0.1" newVersion="6.0.0.1" />
+          <bindingRedirect oldVersion="0.0.0.0-6.1.0.0" newVersion="6.1.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -57,7 +57,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.4.0" newVersion="4.0.4.0" />
         </dependentAssembly>
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
@@ -78,11 +78,11 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.1.2" newVersion="4.0.1.2" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.2.0" newVersion="4.0.2.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
+          <bindingRedirect oldVersion="0.0.0.0-4.1.5.0" newVersion="4.1.5.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -98,7 +98,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.1.0" newVersion="6.0.1.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -114,7 +114,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
+          <bindingRedirect oldVersion="0.0.0.0-4.2.1.0" newVersion="4.2.1.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index a189f58567a..8512aae44f0 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -221,6 +221,10 @@
     <Compile Include="..\Shared\TaskParameter.cs" />
     <Compile Include="..\Shared\AssemblyNameExtension.cs" />
 
+    <Compile Include="..\Framework\InterningReadTranslator.cs" />
+    <Compile Include="..\Framework\InterningWriteTranslator.cs" />
+    <Compile Include="..\Framework\InternPathIds.cs" />
+
     <Compile Include="..\Shared\FileSystem\IFileSystem.cs" />
     <Compile Include="..\Shared\FileSystem\FileSystems.cs" />
     <Compile Include="FileSystem\MSBuildTaskHostFileSystem.cs" />
diff --git a/src/Package/DevDivPackage/DevDivPackage.csproj b/src/Package/DevDivPackage/DevDivPackage.csproj
index 5fd8407217e..9ed627a7938 100644
--- a/src/Package/DevDivPackage/DevDivPackage.csproj
+++ b/src/Package/DevDivPackage/DevDivPackage.csproj
@@ -2,6 +2,7 @@
   <Import Project="Sdk.props" Sdk="Microsoft.NET.Sdk" />
   <PropertyGroup>
     <TargetFramework>$(FullFrameworkTFM)</TargetFramework>
+    <UseFrozenMaintenancePackageVersions>false</UseFrozenMaintenancePackageVersions>
     <NuspecFile>VS.ExternalAPIs.MSBuild.nuspec</NuspecFile>
     <IsShipping>false</IsShipping>
     <PlatformTarget>x86</PlatformTarget>
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index e5f3ce39f93..a9e28eea646 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -22,7 +22,6 @@ vs.relatedProcessFiles
 
 folder InstallDir:\MSBuild\Current
   file source=$(X86BinPath)Microsoft.Common.props
-  file source=$(X86BinPath)Microsoft.VisualStudioVersion.v17.Common.props
   file source=$(ThirdPartyNotice)
 
 folder InstallDir:\MSBuild\Current\Bin
@@ -39,15 +38,15 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)BuildXL.Native.dll
   file source=$(X86BinPath)BuildXL.Processes.dll
   file source=$(X86BinPath)BuildXL.Utilities.Core.dll
-  file source=$(X86BinPath)Microsoft.VisualStudio.SolutionPersistence.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.VisualStudio.SolutionPersistence.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
   file source=$(X86BinPath)RuntimeContracts.dll
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)System.Diagnostics.DiagnosticSource.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Diagnostics.DiagnosticSource.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
   file source=$(X86BinPath)System.Formats.Nrbf.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Threading.Channels.dll
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -55,7 +54,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.ValueTuple.dll
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -90,24 +89,24 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.ServiceModel.targets
   file source=$(X86BinPath)Microsoft.WinFx.targets
   file source=$(X86BinPath)Microsoft.WorkflowBuildExtensions.targets
-  file source=$(X86BinPath)Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.VisualStudio.OpenTelemetry.Collector.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.VisualStudio.Utilities.Internal.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)OpenTelemetry.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)OpenTelemetry.Api.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)OpenTelemetry.Api.ProviderBuilderExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Configuration.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Configuration.Binder.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Configuration.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.DependencyInjection.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.DependencyInjection.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Logging.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Logging.Configuration.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Logging.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Options.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Options.ConfigurationExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Primitives.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Diagnostics.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.VisualStudio.OpenTelemetry.Collector.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.VisualStudio.Utilities.Internal.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)OpenTelemetry.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)OpenTelemetry.Api.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)OpenTelemetry.Api.ProviderBuilderExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Configuration.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Configuration.Binder.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Configuration.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.DependencyInjection.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.DependencyInjection.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Logging.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Logging.Configuration.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Logging.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Options.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Options.ConfigurationExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Primitives.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Diagnostics.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
   file source=$(X86BinPath)Newtonsoft.Json.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
 
 folder InstallDir:\MSBuild\Current\Bin\MSBuild
diff --git a/src/Samples/Directory.Build.props b/src/Samples/Directory.Build.props
index be310dc5e89..4e968bdb712 100644
--- a/src/Samples/Directory.Build.props
+++ b/src/Samples/Directory.Build.props
@@ -16,6 +16,8 @@
 
     <IsShipping>false</IsShipping>
     <ExcludeFromSourceOnlyBuild>true</ExcludeFromSourceOnlyBuild>
+
+    <UseFrozenMaintenancePackageVersions>false</UseFrozenMaintenancePackageVersions>
   </PropertyGroup>
 
 </Project>
diff --git a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
index f1c67c65ad0..ec425f3f969 100644
--- a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
+++ b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
@@ -1,4 +1,5 @@
 <Project Sdk="Microsoft.NET.Sdk">
+
   <PropertyGroup>
     <UseProductOutputPath>true</UseProductOutputPath>
     <CopyNuGetImplementations>false</CopyNuGetImplementations>
@@ -7,12 +8,20 @@
     <TargetFrameworks>$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
     <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(FullFrameworkTFM);$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
   </PropertyGroup>
+
   <ItemGroup>
-    <ProjectReference Include="..\..\Build\Microsoft.Build.csproj" />
-    <ProjectReference Include="..\..\Framework\Microsoft.Build.Framework.csproj" />
-  </ItemGroup>
-  <ItemGroup>
+    <PackageReference Include="Microsoft.Build" Version="16.11.0" PrivateAssets="all" />
     <PackageReference Include="Shouldly" Version="4.2.1" />
-    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+
+    <!-- Bump versions of transitive dependencies to vulnerable packages,
+         but don't reference them so the plugin doesn't carry higher references
+         than its targeted MSBuild. NOT NECESSARY for public plugins; use higher MSBuild. -->
+    <PackageReference Include="System.Drawing.Common" Version="4.7.2" ExcludeAssets="all" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
+    <PackageReference Include="System.Text.Encodings.Web" Version="4.7.2" ExcludeAssets="all" />
+    <Reference Include="System.Net.Http" />
   </ItemGroup>
+
 </Project>
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 12017934f1f..9f4b12b918e 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -989,8 +989,8 @@ public void Translate(ITranslator translator)
 
             // TODO: consider some kind of protection against infinite loop during serialization, hint: pre serialize check for cycle in graph
             translator.TranslateHashSet(ref remappedFrom,
-                (ITranslator t) => new AssemblyNameExtension(t),
-                (int capacity) => CreateRemappedFrom());
+                (t) => new AssemblyNameExtension(t),
+                (capacity) => CreateRemappedFrom());
         }
     }
 }
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index 0702770278a..11618bc3cc6 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -3,7 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+#if DEBUG
 using System.IO;
+#endif
 using System.Reflection;
 using System.Runtime.CompilerServices;
 using Microsoft.Build.Framework;
@@ -38,13 +40,17 @@ internal sealed class PrintLineDebugger : IDisposable
         public static Lazy<PrintLineDebugger> DefaultWithProcessInfo =
             new Lazy<PrintLineDebugger>(() => Create(null, null, true));
 
+#if DEBUG
         private readonly string _id;
+#endif
 
         private readonly CommonWriterType _writerSetByThisInstance;
 
         public PrintLineDebugger(string id, CommonWriterType writer)
         {
+#if DEBUG
             _id = id ?? string.Empty;
+#endif
 
             if (writer != null)
             {
@@ -145,10 +151,12 @@ public void Log(
 #endif
         }
 
+#if DEBUG
         private static string CallsiteString(string sourceFilePath, string memberName, int sourceLineNumber)
         {
             return $"@{Path.GetFileNameWithoutExtension(sourceFilePath)}.{memberName}({sourceLineNumber})";
         }
+#endif
 
         private void ReleaseUnmanagedResources()
         {
diff --git a/src/Shared/FileSystem/IFileSystem.cs b/src/Shared/FileSystem/IFileSystem.cs
index 191e348ee2d..8bfcb130067 100644
--- a/src/Shared/FileSystem/IFileSystem.cs
+++ b/src/Shared/FileSystem/IFileSystem.cs
@@ -38,7 +38,7 @@ internal interface IFileSystem
 
         FileAttributes GetAttributes(string path);
 
-        public DateTime GetLastWriteTimeUtc(string path);
+        DateTime GetLastWriteTimeUtc(string path);
 
         bool DirectoryExists(string path);
 
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index f2223635f80..53f3c7c4bc7 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -18,6 +18,7 @@ internal class ManagedFileSystem : IFileSystem
 
         public static ManagedFileSystem Singleton() => ManagedFileSystem.Instance;
 
+#if FEATURE_MSIOREDIST
         private static bool ShouldUseMicrosoftIO
         {
             get
@@ -31,6 +32,7 @@ private static bool ShouldUseMicrosoftIO
 #endif
             }
         }
+#endif
 
         protected ManagedFileSystem() { }
 
diff --git a/src/Shared/FileSystem/WindowsFileSystem.cs b/src/Shared/FileSystem/WindowsFileSystem.cs
index 1493d0f29a8..a83d932c00d 100644
--- a/src/Shared/FileSystem/WindowsFileSystem.cs
+++ b/src/Shared/FileSystem/WindowsFileSystem.cs
@@ -55,6 +55,12 @@ public override IEnumerable<string> EnumerateFileSystemEntries(string path, stri
 
         public override bool DirectoryExists(string path)
         {
+            if (!string.IsNullOrEmpty(path) && FileUtilities.IsPathTooLong(path))
+            {
+                // If the path is too long, we can't check if it exists on windows
+                string message = ResourceUtilities.FormatString(AssemblyResources.GetString("Shared.PathTooLong"), path, NativeMethodsShared.MaxPath);
+                throw new PathTooLongException(message);
+            }
             return NativeMethodsShared.DirectoryExistsWindows(path);
         }
 
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 911439a8bb0..71259e9d412 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -1239,7 +1239,7 @@ internal static string AttemptToShortenPath(string path)
             return FixFilePath(path);
         }
 
-        private static bool IsPathTooLong(string path)
+        public static bool IsPathTooLong(string path)
         {
             // >= not > because MAX_PATH assumes a trailing null
             return path.Length >= NativeMethodsShared.MaxPath;
@@ -1565,21 +1565,42 @@ internal static void ClearFileExistenceCache()
 
         internal static void ReadFromStream(this Stream stream, byte[] content, int startIndex, int length)
         {
-#if NET
             stream.ReadExactly(content, startIndex, length);
-#else
-            int bytesRead = 0;
-            while (bytesRead < length)
+        }
+    }
+}
+
+#if !NET
+namespace System.IO
+{
+    internal static class StreamExtensions
+    {
+        internal static void ReadExactly(this Stream stream, byte[] buffer, int offset, int count)
+        {
+            if (buffer == null)
             {
-                int read = stream.Read(content, startIndex + bytesRead, length - bytesRead);
-                if (read == 0)
+                throw new ArgumentNullException(nameof(buffer));
+            }
+            if (offset < 0)
+            {
+                throw new ArgumentOutOfRangeException(nameof(offset));
+            }
+            if ((uint)count > buffer.Length - offset)
+            {
+                throw new ArgumentOutOfRangeException(nameof(count));
+            }
+
+            while (count > 0)
+            {
+                int read = stream.Read(buffer, offset, count);
+                if (read <= 0)
                 {
                     throw new EndOfStreamException();
                 }
-
-                bytesRead += read;
+                offset +=read;
+                count -= read;
             }
-#endif
         }
     }
 }
+#endif
\ No newline at end of file
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 458272bcc30..506ba750ab3 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -1261,26 +1261,11 @@ private class DotNetFrameworkSpec
             private const string HKLM = "HKEY_LOCAL_MACHINE";
             private const string MicrosoftSDKsRegistryKey = @"SOFTWARE\Microsoft\Microsoft SDKs";
 
-            /// <summary>
-            /// The registry key of this .net framework, i.e. "SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full" for .net v4.5.
-            /// </summary>
-            private readonly string _dotNetFrameworkRegistryKey;
-
-            /// <summary>
-            /// The name in registry to indicate that this .net framework is installed, i.e. "Install" for .net v4.5.
-            /// </summary>
-            private readonly string _dotNetFrameworkSetupRegistryInstalledName;
-
             /// <summary>
             /// The key in registry to indicate the sdk tools folder, i.e. "WinSDK-NetFx40Tools-x86" for .net v4.5.
             /// </summary>
             private readonly string _dotNetFrameworkSdkRegistryToolsKey;
 
-            /// <summary>
-            /// The version of visual studio that shipped with this .net framework.
-            /// </summary>
-            private readonly Version _visualStudioVersion;
-
             /// <summary>
             /// Does this .net framework include MSBuild?
             /// </summary>
@@ -1298,9 +1283,24 @@ private class DotNetFrameworkSpec
 
 #if FEATURE_WIN32_REGISTRY
             /// <summary>
-            /// Cached path of the corresponding windows sdk.
+            /// The registry key of this .net framework, i.e. "SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full" for .net v4.5.
+            /// </summary>
+            private readonly string _dotNetFrameworkRegistryKey;
+
+            /// <summary>
+            /// The name in registry to indicate that this .net framework is installed, i.e. "Install" for .net v4.5.
+            /// </summary>
+            private readonly string _dotNetFrameworkSetupRegistryInstalledName;
+
+            /// <summary>
+            /// /// Cached path of the corresponding windows sdk.
             /// </summary>
             private string _pathToWindowsSdk;
+
+            /// <summary>
+            /// The version of visual studio that shipped with this .net framework.
+            /// </summary>
+            private readonly Version _visualStudioVersion;
 #endif
 
             /// <summary>
@@ -1319,15 +1319,18 @@ public DotNetFrameworkSpec(
                 Version visualStudioVersion = null)
             {
                 this.Version = version;
-                this._visualStudioVersion = visualStudioVersion;
-                this._dotNetFrameworkRegistryKey = dotNetFrameworkRegistryKey;
-                this._dotNetFrameworkSetupRegistryInstalledName = dotNetFrameworkSetupRegistryInstalledName;
                 this.DotNetFrameworkFolderPrefix = dotNetFrameworkVersionFolderPrefix;
                 this._dotNetFrameworkSdkRegistryToolsKey = dotNetFrameworkSdkRegistryToolsKey;
                 this.DotNetFrameworkSdkRegistryInstallationFolderName = dotNetFrameworkSdkRegistryInstallationFolderName;
                 this._hasMsBuild = hasMSBuild;
                 this._pathsToDotNetFramework = new ConcurrentDictionary<DotNetFrameworkArchitecture, string>();
                 this._pathsToDotNetFrameworkSdkTools = new ConcurrentDictionary<Version, string>();
+
+#if FEATURE_WIN32_REGISTRY
+                this._dotNetFrameworkRegistryKey = dotNetFrameworkRegistryKey;
+                this._dotNetFrameworkSetupRegistryInstalledName = dotNetFrameworkSetupRegistryInstalledName;
+                this._visualStudioVersion = visualStudioVersion;
+#endif
             }
 
             /// <summary>
diff --git a/src/Shared/INodePacketFactory.cs b/src/Shared/INodePacketFactory.cs
index c972e0408b5..63d469eb021 100644
--- a/src/Shared/INodePacketFactory.cs
+++ b/src/Shared/INodePacketFactory.cs
@@ -43,7 +43,14 @@ internal interface INodePacketFactory
         void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
 
         /// <summary>
-        /// Routes the specified packet
+        /// Takes a serializer and deserializes the packet.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator);
+
+        /// <summary>
+        /// Routes the specified packet.
         /// </summary>
         /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packet">The packet to route.</param>
diff --git a/src/Shared/LoadedType.cs b/src/Shared/LoadedType.cs
index 6b2f8aed5c8..6be0b228a75 100644
--- a/src/Shared/LoadedType.cs
+++ b/src/Shared/LoadedType.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 
-#nullable disable
 
 namespace Microsoft.Build.Shared
 {
@@ -47,7 +46,7 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade
             // properties and reflect over them without needing them to be fully loaded, so it also isn't need for TaskHosts.
 
             // MetadataLoadContext-loaded Type objects don't support testing for inherited attributes, so we manually walk the BaseType chain.
-            Type t = type;
+            Type? t = type;
             while (t is not null)
             {
                 if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(nameof(LoadInSeparateAppDomainAttribute))))
@@ -92,7 +91,7 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade
                 }
 
                 // Check whether it's assignable to ITaskItem or ITaskItem[]. Simplify to just checking for ITaskItem.
-                Type pt = props[i].PropertyType;
+                Type? pt = props[i].PropertyType;
                 if (pt.IsArray)
                 {
                     pt = pt.GetElementType();
@@ -101,9 +100,9 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade
                 bool isAssignableToITask = iTaskItemType.IsAssignableFrom(pt);
 
                 Properties[i] = new ReflectableTaskPropertyInfo(props[i], outputAttribute, requiredAttribute, isAssignableToITask);
-                if (loadedViaMetadataLoadContext)
+                if (loadedViaMetadataLoadContext && PropertyAssemblyQualifiedNames != null)
                 {
-                    PropertyAssemblyQualifiedNames[i] = Properties[i].PropertyType.AssemblyQualifiedName;
+                    PropertyAssemblyQualifiedNames[i] = Properties[i]?.PropertyType?.AssemblyQualifiedName?? string.Empty;
                 }
             }
 #else
@@ -143,7 +142,7 @@ private bool CheckForHardcodedSTARequirement()
             {
                 AssemblyName assemblyName = Type.GetTypeInfo().Assembly.GetName();
                 Version lastVersionToForce = new Version(3, 5);
-                if (assemblyName.Version.CompareTo(lastVersionToForce) > 0)
+                if (assemblyName.Version?.CompareTo(lastVersionToForce) > 0)
                 {
                     if (String.Equals(assemblyName.Name, "PresentationBuildTasks", StringComparison.OrdinalIgnoreCase))
                     {
@@ -180,7 +179,7 @@ private bool CheckForHardcodedSTARequirement()
         /// <summary>
         /// Assembly-qualified names for properties. Only has a value if this type was loaded using MetadataLoadContext.
         /// </summary>
-        internal string[] PropertyAssemblyQualifiedNames { get; private set; }
+        internal string[]? PropertyAssemblyQualifiedNames { get; private set; }
 
         /// <summary>
         /// Gets the assembly the type was loaded from.
diff --git a/src/Shared/NodePacketFactory.cs b/src/Shared/NodePacketFactory.cs
index 214ddfa20f9..478c88310eb 100644
--- a/src/Shared/NodePacketFactory.cs
+++ b/src/Shared/NodePacketFactory.cs
@@ -55,7 +55,22 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
                 ErrorUtilities.ThrowInternalError("No packet handler for type {0}", packetType);
             }
 
-            record.DeserializeAndRoutePacket(nodeId, translator);
+            INodePacket packet = record.DeserializePacket(translator);
+            record.RoutePacket(nodeId, packet);
+        }
+
+        /// <summary>
+        /// Creates a packet with data from a binary stream.
+        /// </summary>
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
+        {
+            // PERF: Not using VerifyThrow to avoid boxing of packetType in the non-error case
+            if (!_packetFactories.TryGetValue(packetType, out PacketFactoryRecord record))
+            {
+                ErrorUtilities.ThrowInternalError("No packet handler for type {0}", packetType);
+            }
+
+            return record.DeserializePacket(translator);
         }
 
         /// <summary>
@@ -63,7 +78,12 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
         /// </summary>
         public void RoutePacket(int nodeId, INodePacket packet)
         {
-            PacketFactoryRecord record = _packetFactories[packet.Type];
+            // PERF: Not using VerifyThrow to avoid boxing of packetType in the non-error case
+            if (!_packetFactories.TryGetValue(packet.Type, out PacketFactoryRecord record))
+            {
+                ErrorUtilities.ThrowInternalError("No packet handler for type {0}", packet.Type);
+            }
+
             record.RoutePacket(nodeId, packet);
         }
 
@@ -77,12 +97,12 @@ private class PacketFactoryRecord
             /// <summary>
             /// The handler to invoke when the packet is deserialized.
             /// </summary>
-            private INodePacketHandler _handler;
+            private readonly INodePacketHandler _handler;
 
             /// <summary>
             /// The method used to construct a packet from a translator stream.
             /// </summary>
-            private NodePacketFactoryMethod _factoryMethod;
+            private readonly NodePacketFactoryMethod _factoryMethod;
 
             /// <summary>
             /// Constructor.
@@ -94,21 +114,14 @@ public PacketFactoryRecord(INodePacketHandler handler, NodePacketFactoryMethod f
             }
 
             /// <summary>
-            /// Creates a packet from a binary stream and sends it to the registered handler.
+            /// Creates a packet from a binary stream.
             /// </summary>
-            public void DeserializeAndRoutePacket(int nodeId, ITranslator translator)
-            {
-                INodePacket packet = _factoryMethod(translator);
-                RoutePacket(nodeId, packet);
-            }
+            public INodePacket DeserializePacket(ITranslator translator) => _factoryMethod(translator);
 
             /// <summary>
             /// Routes the packet to the correct destination.
             /// </summary>
-            public void RoutePacket(int nodeId, INodePacket packet)
-            {
-                _handler.PacketReceived(nodeId, packet);
-            }
+            public void RoutePacket(int nodeId, INodePacket packet) => _handler.PacketReceived(nodeId, packet);
         }
     }
 }
diff --git a/src/Shared/NodePipeClient.cs b/src/Shared/NodePipeClient.cs
index 6585a2558e7..a521f4f34d2 100644
--- a/src/Shared/NodePipeClient.cs
+++ b/src/Shared/NodePipeClient.cs
@@ -84,7 +84,11 @@ private void PerformHandshake(int timeout)
             _pipeClient.WriteEndOfHandshakeSignal();
 
             CommunicationsUtilities.Trace("Reading handshake from pipe {0}", PipeName);
+#if NET
             _pipeClient.ReadEndOfHandshakeSignal(true, timeout);
+#else
+            _pipeClient.ReadEndOfHandshakeSignal(true);
+#endif
         }
     }
 }
diff --git a/src/Shared/NodePipeServer.cs b/src/Shared/NodePipeServer.cs
index dde8e2ee371..eb932d973aa 100644
--- a/src/Shared/NodePipeServer.cs
+++ b/src/Shared/NodePipeServer.cs
@@ -25,11 +25,13 @@ internal sealed class NodePipeServer : NodePipeBase
         /// </summary>
         private const int PipeBufferSize = 131_072;
 
+#if NET
         /// <summary>
         /// A timeout for the handshake. This is only used on Unix-like socket implementations, because the
         /// timeout on the PipeStream connection is ignore.
         /// </summary>
         private static readonly int s_handshakeTimeout = NativeMethodsShared.IsWindows ? 0 : 60_000;
+#endif
 
         private readonly NamedPipeServerStream _pipeServer;
 
@@ -179,7 +181,11 @@ private bool ValidateHandshake()
             for (int i = 0; i < HandshakeComponents.Length; i++)
             {
                 // This will disconnect a < 16.8 host; it expects leading 00 or F5 or 06. 0x00 is a wildcard.
+#if NET
                 int handshakePart = _pipeServer.ReadIntForHandshake(byteToAccept: i == 0 ? CommunicationsUtilities.handshakeVersion : null, s_handshakeTimeout);
+#else
+                int handshakePart = _pipeServer.ReadIntForHandshake(byteToAccept: i == 0 ? CommunicationsUtilities.handshakeVersion : null);
+#endif
 
                 if (handshakePart != HandshakeComponents[i])
                 {
@@ -190,7 +196,11 @@ private bool ValidateHandshake()
             }
 
             // To ensure that our handshake and theirs have the same number of bytes, receive and send a magic number indicating EOS.
+#if NET
             _pipeServer.ReadEndOfHandshakeSignal(false, s_handshakeTimeout);
+#else
+            _pipeServer.ReadEndOfHandshakeSignal(false);
+#endif
 
             CommunicationsUtilities.Trace("Successfully connected to parent.");
             _pipeServer.WriteEndOfHandshakeSignal();
diff --git a/src/Shared/TaskLoader.cs b/src/Shared/TaskLoader.cs
index ea170a16a08..602a36871ed 100644
--- a/src/Shared/TaskLoader.cs
+++ b/src/Shared/TaskLoader.cs
@@ -5,8 +5,6 @@
 using System.Reflection;
 using Microsoft.Build.Framework;
 
-#nullable disable
-
 namespace Microsoft.Build.Shared
 {
     /// <summary>
@@ -19,7 +17,7 @@ internal static class TaskLoader
         /// For saving the assembly that was loaded by the TypeLoader
         /// We only use this when the assembly failed to load properly into the appdomain
         /// </summary>
-        private static LoadedType s_resolverLoadedType;
+        private static LoadedType? s_resolverLoadedType;
 #endif
 
         /// <summary>
@@ -42,7 +40,7 @@ internal static bool IsTaskClass(Type type, object unused)
         /// Creates an ITask instance and returns it.
         /// </summary>
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-        internal static ITask CreateTask(
+        internal static ITask? CreateTask(
             LoadedType loadedType,
             string taskName,
             string taskLocation,
@@ -55,7 +53,7 @@ internal static ITask CreateTask(
 #endif
             bool isOutOfProc
 #if FEATURE_APPDOMAIN
-            , out AppDomain taskAppDomain
+            , out AppDomain? taskAppDomain
 #endif
             )
 #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
@@ -64,7 +62,7 @@ bool isOutOfProc
             bool separateAppDomain = loadedType.HasLoadInSeparateAppDomainAttribute;
             s_resolverLoadedType = null;
             taskAppDomain = null;
-            ITask taskInstanceInOtherAppDomain = null;
+            ITask? taskInstanceInOtherAppDomain = null;
 #endif
 
             try
@@ -126,7 +124,7 @@ bool isOutOfProc
                 {
                     // perf improvement for the same appdomain case - we already have the type object
                     // and don't want to go through reflection to recreate it from the name.
-                    return (ITask)Activator.CreateInstance(loadedType.Type);
+                    return (ITask?)Activator.CreateInstance(loadedType.Type);
                 }
 
 #if FEATURE_APPDOMAIN
@@ -158,7 +156,7 @@ bool isOutOfProc
                     taskInstanceInOtherAppDomain = (ITask)taskAppDomain.CreateInstanceAndUnwrap(loadedType.Type.GetTypeInfo().Assembly.FullName, loadedType.Type.FullName);
                 }
 
-                return taskInstanceInOtherAppDomain;
+                return  taskInstanceInOtherAppDomain;
 #endif
             }
             finally
@@ -179,10 +177,14 @@ bool isOutOfProc
         /// This is a resolver to help created AppDomains when they are unable to load an assembly into their domain we will help
         /// them succeed by providing the already loaded one in the currentdomain so that they can derive AssemblyName info from it
         /// </summary>
-        internal static Assembly AssemblyResolver(object sender, ResolveEventArgs args)
+        internal static Assembly? AssemblyResolver(object sender, ResolveEventArgs args)
         {
-            if (args.Name.Equals(s_resolverLoadedType.LoadedAssemblyName.FullName, StringComparison.OrdinalIgnoreCase))
+            if (args.Name.Equals(s_resolverLoadedType?.LoadedAssemblyName?.FullName, StringComparison.OrdinalIgnoreCase))
             {
+                if (s_resolverLoadedType == null || s_resolverLoadedType.Path == null)
+                {
+                    return null;
+                }
                 return s_resolverLoadedType.LoadedAssembly ?? Assembly.Load(s_resolverLoadedType.Path);
             }
 
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 3b6265ca4d9..2e397ebab7b 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -997,6 +997,7 @@ public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
                 return EnumerateMetadataLazy();
             }
 
+#if FEATURE_APPDOMAIN
             private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
             {
                 if (_customEscapedMetadata == null || _customEscapedMetadata.Count == 0)
@@ -1014,6 +1015,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
 
                 return result;
             }
+#endif
 
             private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataLazy()
             {
diff --git a/src/Shared/TranslatorHelpers.cs b/src/Shared/TranslatorHelpers.cs
index 2835756fa6c..b3c6a5573bd 100644
--- a/src/Shared/TranslatorHelpers.cs
+++ b/src/Shared/TranslatorHelpers.cs
@@ -89,6 +89,68 @@ public static void TranslateDictionary<T>(
             translator.TranslateDictionary(ref dictionary, comparer, AdaptFactory(valueFactory));
         }
 
+        public static void InternDictionary(
+            this ITranslator translator,
+            ref Dictionary<string, string> dictionary,
+            IEqualityComparer<string> comparer)
+        {
+            IDictionary<string, string> localDict = dictionary;
+            translator.TranslateDictionary(
+                ref localDict,
+                (ITranslator translator, ref string key) => translator.Intern(ref key),
+                (ITranslator translator, ref string val) => translator.Intern(ref val),
+                capacity => new Dictionary<string, string>(capacity, comparer));
+            dictionary = (Dictionary<string, string>)localDict;
+        }
+
+        public static void InternDictionary<T>(
+            this ITranslator translator,
+            ref Dictionary<string, T> dictionary,
+            IEqualityComparer<string> stringComparer,
+            NodePacketValueFactory<T> valueFactory)
+            where T : ITranslatable
+        {
+            IDictionary<string, T> localDict = dictionary;
+            translator.TranslateDictionary(
+                ref localDict,
+                (ITranslator translator, ref string key) => translator.Intern(ref key),
+                AdaptFactory(valueFactory),
+                capacity => new Dictionary<string, T>(capacity, stringComparer));
+            dictionary = (Dictionary<string, T>)localDict;
+        }
+
+        public static void InternPathDictionary(
+            this ITranslator translator,
+            ref Dictionary<string, string> dictionary,
+            IEqualityComparer<string> comparer)
+        {
+            IDictionary<string, string> localDict = dictionary;
+
+            // For now, assume only the value contains path-like strings (e.g. TaskItem metadata).
+            translator.TranslateDictionary(
+                ref localDict,
+                (ITranslator translator, ref string key) => translator.Intern(ref key),
+                (ITranslator translator, ref string val) => translator.InternPath(ref val),
+                capacity => new Dictionary<string, string>(capacity, comparer));
+            dictionary = (Dictionary<string, string>)localDict;
+        }
+
+        public static void InternPathDictionary<T>(
+            this ITranslator translator,
+            ref Dictionary<string, T> dictionary,
+            IEqualityComparer<string> stringComparer,
+            NodePacketValueFactory<T> valueFactory)
+            where T : ITranslatable
+        {
+            IDictionary<string, T> localDict = dictionary;
+            translator.TranslateDictionary(
+                ref localDict,
+                (ITranslator translator, ref string key) => translator.InternPath(ref key),
+                AdaptFactory(valueFactory),
+                capacity => new Dictionary<string, T>(capacity, stringComparer));
+            dictionary = (Dictionary<string, T>)localDict;
+        }
+
         public static void TranslateDictionary<D, T>(
             this ITranslator translator,
             ref D dictionary,
diff --git a/src/StringTools.UnitTests/WeakStringCache_Tests.cs b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
index 95c769a5fa7..29e51267c1c 100644
--- a/src/StringTools.UnitTests/WeakStringCache_Tests.cs
+++ b/src/StringTools.UnitTests/WeakStringCache_Tests.cs
@@ -86,7 +86,7 @@ private void AddStringsWithSameHashCode(int numberOfStrings)
 
             for (int i = 0; i < numberOfStrings; i++)
             {
-                string strPart2 = string.Concat(Enumerable.Repeat("100570862200", i + 2));
+                string strPart2 = string.Concat(Enumerable.Repeat("100570862200", i + 100));
                 hashCodes[i] = AddString(string.Empty, strPart2, (string cachedString) =>
                 {
                     _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
@@ -124,7 +124,7 @@ private void AddStringsWithSameHashCode(int numberOfStrings)
         public void RetainsStringUntilCollected()
         {
             // Add a string to the cache using a non-inlinable method to make sure it's not reachable from a GC root.
-            AddString("Random string ", "test", (string cachedString) =>
+            AddString(new string('r', 500), "test", (string cachedString) =>
             {
                 _cache.GetDebugInfo().ShouldBe(new WeakStringCache.DebugInfo()
                 {
diff --git a/src/StringTools/StringTools.cs b/src/StringTools/StringTools.cs
index 93b06619b5d..0ee22092369 100644
--- a/src/StringTools/StringTools.cs
+++ b/src/StringTools/StringTools.cs
@@ -92,6 +92,11 @@ public static string CreateDiagnosticReport()
             return WeakStringCacheInterner.Instance.FormatStatistics();
         }
 
+        public static void ClearCachedStrings()
+        {
+            WeakStringCacheInterner.Instance.Dispose();
+        }
+
         #endregion
 
         /// <summary>
diff --git a/src/StringTools/WeakStringCache.cs b/src/StringTools/WeakStringCache.cs
index 5e3434fd4ef..5517e1478cc 100644
--- a/src/StringTools/WeakStringCache.cs
+++ b/src/StringTools/WeakStringCache.cs
@@ -35,10 +35,15 @@ private class StringWeakHandle
             /// </summary>
             public GCHandle WeakHandle;
 
+            /// <summary>
+            /// Reference used for smaller strings retained by the cache.
+            /// </summary>
+            private string? referencedString;
+
             /// <summary>
             /// Returns true if the string referenced by the handle is still alive.
             /// </summary>
-            public bool IsUsed => WeakHandle.Target != null;
+            public bool IsUsed => referencedString is not null || WeakHandle.Target != null;
 
             /// <summary>
             /// Returns the string referenced by this handle if it is equal to the given internable.
@@ -47,13 +52,26 @@ private class StringWeakHandle
             /// <returns>The string matching the internable or null if the handle is referencing a collected string or the string is different.</returns>
             public string? GetString(ref InternableString internable)
             {
-                if (WeakHandle.IsAllocated && WeakHandle.Target is string str)
+                if (referencedString is not null && internable.Equals(referencedString))
                 {
-                    if (internable.Equals(str))
-                    {
-                        return str;
-                    }
+                    return referencedString;
+                }
+
+                if (!WeakHandle.IsAllocated)
+                {
+                    return null;
+                }
+
+                if (WeakHandle.Target is not string str)
+                {
+                    return null;
                 }
+
+                if (internable.Equals(str))
+                {
+                    return str;
+                }
+
                 return null;
             }
 
@@ -63,14 +81,28 @@ private class StringWeakHandle
             /// <param name="str">The string to set.</param>
             public void SetString(string str)
             {
-                if (!WeakHandle.IsAllocated)
+                const int stringLengthLimit = 500;
+                if (str.Length > stringLengthLimit)
                 {
-                    // The handle is not allocated - allocate it.
-                    WeakHandle = GCHandle.Alloc(str, GCHandleType.Weak);
+                    if (WeakHandle.IsAllocated)
+                    {
+                        WeakHandle.Target = str;
+                    }
+                    else
+                    {
+                        WeakHandle = GCHandle.Alloc(str, GCHandleType.Weak);
+                    }
+
+                    referencedString = null;
                 }
                 else
                 {
-                    WeakHandle.Target = str;
+                    if (WeakHandle.IsAllocated)
+                    {
+                        WeakHandle.Target = null;
+                    }
+
+                    referencedString = str;
                 }
             }
 
@@ -79,7 +111,10 @@ public void SetString(string str)
             /// </summary>
             public void Free()
             {
-                WeakHandle.Free();
+                if (WeakHandle.IsAllocated)
+                {
+                    WeakHandle.Free();
+                }
             }
         }
 
@@ -106,12 +141,6 @@ private void DisposeImpl()
         }
 
         public void Dispose()
-        {
-            DisposeImpl();
-            GC.SuppressFinalize(this);
-        }
-
-        ~WeakStringCache()
         {
             DisposeImpl();
         }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
index 85700054f33..f320ee47e70 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
@@ -940,13 +940,10 @@ private static IEnumerable<AssemblyNameExtension> MockAssemblyCacheEnumerator(st
         internal sealed class MockEnumerator : IEnumerable<AssemblyNameExtension>
         {
             private List<string> _assembliesToEnumerate = null;
-            private List<string>.Enumerator _enumerator;
 
             public MockEnumerator(List<string> assembliesToEnumerate)
             {
                 _assembliesToEnumerate = assembliesToEnumerate;
-
-                _enumerator = assembliesToEnumerate.GetEnumerator();
             }
 
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 576145d5cd5..eacd689668d 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3268,41 +3268,6 @@ public void ParentAssemblyResolvedFromAForGac()
             Assert.Equal(reference2.ResolvedSearchPath, parentReferenceFolders[0].Directory);
         }
 
-        /// <summary>
-        /// Generate a fake reference which has been resolved from the gac. We will use it to verify the creation of the exclusion list.
-        /// </summary>
-        /// <returns></returns>
-        private ReferenceTable GenerateTableWithAssemblyFromTheGlobalLocation(string location)
-        {
-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, Array.Empty<string>(), null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,
-#if FEATURE_WIN32_REGISTRY
-                null, null, null,
-#endif
-                null, null, new Version("4.0"), null, null, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null);
-
-            AssemblyNameExtension assemblyNameExtension = new AssemblyNameExtension(new AssemblyName("Microsoft.VisualStudio.Interopt, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"));
-            TaskItem taskItem = new TaskItem("Microsoft.VisualStudio.Interopt, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
-
-            Reference reference = new Reference(isWinMDFile, fileExists, getRuntimeVersion);
-            reference.MakePrimaryAssemblyReference(taskItem, false, ".dll");
-            // "Resolve the assembly from the gac"
-            reference.FullPath = "c:\\Microsoft.VisualStudio.Interopt.dll";
-            reference.ResolvedSearchPath = location;
-            referenceTable.AddReference(assemblyNameExtension, reference);
-
-            assemblyNameExtension = new AssemblyNameExtension(new AssemblyName("Team.System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"));
-            taskItem = new TaskItem("Team, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
-
-            reference = new Reference(isWinMDFile, fileExists, getRuntimeVersion);
-            reference.MakePrimaryAssemblyReference(taskItem, false, ".dll");
-
-            // "Resolve the assembly from the gac"
-            reference.FullPath = "c:\\Team.System.dll";
-            reference.ResolvedSearchPath = location;
-            referenceTable.AddReference(assemblyNameExtension, reference);
-            return referenceTable;
-        }
-
         /// <summary>
         /// Given a reference that resolves to a bad image, we should get a warning and
         /// no reference. We don't want an exception.
@@ -6734,11 +6699,11 @@ public void ReferenceTableDependentItemsInDenyList3()
         [Fact]
         public void ReferenceTableDependentItemsInDenyList4()
         {
-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, Array.Empty<string>(), null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null,
+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, false, Array.Empty<string>(), null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null,
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
-                null, null, null, new Version("4.0"), null, null, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null);
+                null, null, null, new Version("4.0"), null, null, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null, Array.Empty<string>());
             MockEngine mockEngine;
             ResolveAssemblyReference rar;
             Dictionary<string, string> denyList;
@@ -6912,11 +6877,11 @@ public void ReferenceTableDependentItemsInDenyListPrimaryWithSpecificVersion()
 
         private static ReferenceTable MakeEmptyReferenceTable(TaskLoggingHelper log)
         {
-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, Array.Empty<string>(), null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,
+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, false, Array.Empty<string>(), null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
-                null, null, new Version("4.0"), null, log, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null);
+                null, null, new Version("4.0"), null, log, null, true, false, null, null, false, null, WarnOrErrorOnTargetArchitectureMismatchBehavior.None, false, false, null, Array.Empty<string>());
             return referenceTable;
         }
 
@@ -7434,77 +7399,6 @@ public void ResolveAssemblyReferenceVerifyFullClientNameNoTablesPassedIn()
             }
         }
 
-        /// <summary>
-        /// Verify the correct references are still in the references table and that references which are in the deny list are not in the references table
-        /// Also verify any expected warning messages are seen in the log.
-        /// </summary>
-        private static void VerifyReferenceTable(ReferenceTable referenceTable, MockEngine mockEngine, AssemblyNameExtension engineAssemblyName, AssemblyNameExtension dataAssemblyName, AssemblyNameExtension sqlclientAssemblyName, AssemblyNameExtension xmlAssemblyName, string warningMessage, string warningMessage2)
-        {
-            IDictionary<AssemblyNameExtension, Reference> table = referenceTable.References;
-            Assert.Equal(3, table.Count); // "Expected there to be three elements in the dictionary"
-            Assert.False(table.ContainsKey(sqlclientAssemblyName)); // "Expected to not find the sqlclientAssemblyName in the referenceList"
-            Assert.True(table.ContainsKey(xmlAssemblyName)); // "Expected to find the xmlssemblyName in the referenceList"
-            Assert.True(table.ContainsKey(dataAssemblyName)); // "Expected to find the dataAssemblyName in the referenceList"
-            Assert.True(table.ContainsKey(engineAssemblyName)); // "Expected to find the engineAssemblyName in the referenceList"
-            if (warningMessage != null)
-            {
-                mockEngine.AssertLogContains(warningMessage);
-            }
-            if (warningMessage2 != null)
-            {
-                mockEngine.AssertLogContains(warningMessage2);
-            }
-            table.Clear();
-        }
-
-        /// <summary>
-        /// Generate helper delegates for returning the file existence and the assembly name.
-        /// Also run the rest and return the result.
-        /// </summary>
-        private bool GenerateHelperDelegatesAndExecuteTask(ResolveAssemblyReference t)
-        {
-            FileExists cachedFileExists = fileExists;
-            GetAssemblyName cachedGetAssemblyName = getAssemblyName;
-            string microsoftBuildEnginePath = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\Microsoft.Build.Engine.dll");
-            string systemXmlPath = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\System.Xml.dll");
-            fileExists = new FileExists(delegate (string path)
-{
-    if (String.Equals(path, microsoftBuildEnginePath, StringComparison.OrdinalIgnoreCase) ||
-                    String.Equals(path, systemXmlPath, StringComparison.OrdinalIgnoreCase) ||
-                    path.EndsWith("RarCache", StringComparison.OrdinalIgnoreCase))
-    {
-        return true;
-    }
-    return false;
-});
-
-            getAssemblyName = new GetAssemblyName(delegate (string path)
-            {
-                if (String.Equals(path, microsoftBuildEnginePath, StringComparison.OrdinalIgnoreCase))
-                {
-                    return new AssemblyNameExtension("Microsoft.Build.Engine, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
-                }
-                else if (String.Equals(path, systemXmlPath, StringComparison.OrdinalIgnoreCase))
-                {
-                    return new AssemblyNameExtension("System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
-                }
-
-                return null;
-            });
-
-            bool success;
-            try
-            {
-                success = Execute(t);
-            }
-            finally
-            {
-                fileExists = cachedFileExists;
-                getAssemblyName = cachedGetAssemblyName;
-            }
-            return success;
-        }
-
         [Fact]
         public void DoNotAssumeFilesDescribedByRedistListExistOnDisk()
         {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index ddfb1bd9c4f..e6b39fd0e94 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -2506,6 +2506,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             };
         }
 
+#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Registry access delegate. Given a hive and a view, return the registry base key.
         /// </summary>
@@ -2910,6 +2911,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
             Assert.Fail($"New GetRegistrySubKeyDefaultValue parameters encountered, need to add unittesting support for subKey={subKey}");
             return null;
         }
+#endif
 
         /// <summary>
         /// Delegate for System.IO.File.GetLastWriteTime
diff --git a/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs b/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
index 23adb6a34b1..e86f7cd868a 100644
--- a/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
+++ b/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
@@ -281,22 +281,6 @@ private static void AssertTokenize(
             AssertTokenize(source, source, expectedTokenKey, expectedLastLineNumber);
         }
 
-        /*
-        * Method:  AssertTokenizeUnicode
-        *
-        * Tokenize a string ('source') and compare it to the expected set of tokens.
-        * Also, the source must be regenerated exactly when the tokens are concatenated
-        * back together,
-        */
-        private static void AssertTokenizeUnicode(
-           string source,
-           string expectedTokenKey,
-           int expectedLastLineNumber)
-        {
-            // Most of the time, we expect the rebuilt source to be the same as the input source.
-            AssertTokenizeUnicode(source, source, expectedTokenKey, expectedLastLineNumber);
-        }
-
         /*
         * Method:  AssertTokenize
         *
diff --git a/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs b/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
index 8630c8025fb..ec790f6ec35 100644
--- a/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
+++ b/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
@@ -262,64 +262,6 @@ public void FaultInjectionMainLib()
             }
         }
 
-        private static void CreateFaultInjectionTypeLibs(MockTypeLibrariesFailurePoints failurePoint, out MockTypeLib mainTypeLib,
-            out MockTypeLib dependencyTypeLibGood1, out MockTypeLib dependencyTypeLibBad1,
-            out MockTypeLib dependencyTypeLibGood2, out MockTypeLib dependencyTypeLibBad2)
-        {
-            mainTypeLib = new MockTypeLib();
-            mainTypeLib.AddTypeInfo(new MockTypeInfo());
-            mainTypeLib.AddTypeInfo(new MockTypeInfo());
-
-            dependencyTypeLibGood1 = new MockTypeLib();
-            dependencyTypeLibGood1.AddTypeInfo(new MockTypeInfo());
-
-            // Make it the StdOle lib to exercise the ITypeInfo.GetDocumentation failure point
-            dependencyTypeLibBad1 = new MockTypeLib(NativeMethods.IID_StdOle);
-            dependencyTypeLibBad1.AddTypeInfo(new MockTypeInfo());
-
-            dependencyTypeLibGood2 = new MockTypeLib();
-            dependencyTypeLibGood2.AddTypeInfo(new MockTypeInfo());
-
-            // Make it the StdOle lib to exercise the ITypeInfo.GetDocumentation failure point
-            dependencyTypeLibBad2 = new MockTypeLib(NativeMethods.IID_StdOle);
-            dependencyTypeLibBad2.AddTypeInfo(new MockTypeInfo());
-
-            COMException failureException = new COMException("unhandled exception in " + failurePoint.ToString());
-
-            dependencyTypeLibBad1.InjectFailure(failurePoint, failureException);
-            dependencyTypeLibBad2.InjectFailure(failurePoint, failureException);
-        }
-
-        private void RunDependencyWalkerFaultInjection(MockTypeLibrariesFailurePoints failurePoint, MockTypeLib mainTypeLib, MockTypeLib dependencyTypeLibGood1, MockTypeLib dependencyTypeLibBad1, MockTypeLib dependencyTypeLibGood2, MockTypeLib dependencyTypeLibBad2)
-        {
-            ComDependencyWalker walker = new ComDependencyWalker(new MarshalReleaseComObject(MockReleaseComObject));
-            walker.AnalyzeTypeLibrary(mainTypeLib);
-
-            // Did the current failure point get hit for this test? If not then no point in checking anything
-            // The previous test (FaultInjectionMainLib) ensures that all defined failure points actually
-            // cause some sort of trouble
-            if (walker.EncounteredProblems.Count > 0)
-            {
-                TYPELIBATTR[] dependencies = walker.GetDependencies();
-                AssertDependenciesContainTypeLib("Test failed for failure point " + failurePoint.ToString(),
-                    dependencies, mainTypeLib, true);
-                AssertDependenciesContainTypeLib("Test failed for failure point " + failurePoint.ToString(),
-                    dependencies, dependencyTypeLibGood1, true);
-                AssertDependenciesContainTypeLib("Test failed for failure point " + failurePoint.ToString(),
-                    dependencies, dependencyTypeLibGood2, true);
-                AssertDependenciesContainTypeLib("Test failed for failure point " + failurePoint.ToString(),
-                    dependencies, dependencyTypeLibBad1, false);
-                AssertDependenciesContainTypeLib("Test failed for failure point " + failurePoint.ToString(),
-                    dependencies, dependencyTypeLibBad2, false);
-            }
-
-            mainTypeLib.AssertAllHandlesReleased();
-            dependencyTypeLibGood1.AssertAllHandlesReleased();
-            dependencyTypeLibGood2.AssertAllHandlesReleased();
-            dependencyTypeLibBad1.AssertAllHandlesReleased();
-            dependencyTypeLibBad2.AssertAllHandlesReleased();
-        }
-
         [Fact]
         public void FullDependenciesWithIncrementalAnalysis()
         {
diff --git a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
index 70ec1fb1452..567eea82ab6 100644
--- a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
@@ -665,21 +665,5 @@ public void ResourcesFileWithRootNamespace()
 
             Assert.Equal(@"RootNamespace.MyResource.resources", result);
         }
-
-        private void AssertSimpleCase(string code, string expected)
-        {
-            string result =
-            CreateVisualBasicManifestResourceName.CreateManifestNameImpl(
-                    fileName: "MyForm.resx",
-                    linkFileName: null,    // Link file name
-                    prependCultureAsDirectory: true,
-                    rootNamespace: "RootNamespace",    // Root namespace
-                    dependentUponFileName: "MyForm.vb",
-                    culture: null,
-                    binaryStream: StreamHelpers.StringToStream(code),
-                    log: null);
-
-            Assert.Equal(expected, result);
-        }
     }
 }
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 81b5048f0f7..2ff059b2833 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -64,6 +64,9 @@
     <None Include="..\Shared\UnitTests\xunit.runner.json">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
+    <None Include="TestResources\CustomCulture\**">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
     <None Include="TestResources\Projects\Custom_COM\Custom_COM\Class1.cs">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
@@ -155,6 +158,9 @@
     <None Update="TestResources\Manifests\*">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
+    <EmbeddedResource Update="TestResources\CustomCulture\*.resx">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </EmbeddedResource>
     <None Update="TestResources\mycert.pfx">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
diff --git a/src/Tasks.UnitTests/ResolveAssemblyReference_CustomCultureTests.cs b/src/Tasks.UnitTests/ResolveAssemblyReference_CustomCultureTests.cs
new file mode 100644
index 00000000000..1a7d7ed0562
--- /dev/null
+++ b/src/Tasks.UnitTests/ResolveAssemblyReference_CustomCultureTests.cs
@@ -0,0 +1,89 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    /// <summary>
+    /// Unit tests for the ResolveAssemblyReference task.
+    /// </summary>
+    public class ResolveAssemblyReference_CustomCultureTests
+    {
+        private static string TestAssetsRootPath { get; } = Path.Combine(
+            Path.GetDirectoryName(typeof(AddToWin32Manifest_Tests).Assembly.Location) ?? AppContext.BaseDirectory,
+            "TestResources",
+            "CustomCulture");
+
+        [WindowsOnlyTheory]
+        [InlineData(true, "", true, true)]
+        [InlineData(false)]
+        [InlineData(true, "yue", false, true)]
+        [InlineData(false, "yue", false, true)]
+        [InlineData(true, "euy", true)]
+        [InlineData(true, "yue;euy")]
+        [InlineData(true, "euy;yue")]
+        public void E2EScenarioTests(bool enableCustomCulture, string customCultureExclusions = "", bool isYueCultureExpected = false, bool isEuyCultureExpected = false)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                // Set up project paths
+                var testAssetsPath = TestAssetsRootPath;
+                var solutionFolder = env.CreateFolder();
+                var solutionPath = solutionFolder.Path;
+
+                // Create and configure ProjectB
+                var projectBName = "ProjectB.csproj";
+                var projBOutputPath = env.CreateFolder().Path;
+                var projectBFolder = Path.Combine(solutionPath, projectBName);
+                Directory.CreateDirectory(projectBFolder);
+                var projBContent = File.ReadAllText(Path.Combine(testAssetsPath, projectBName))
+                    .Replace("OutputPathPlaceholder", projBOutputPath)
+                    .Replace("NonCultureResourceDirectoriesPlaceholder", customCultureExclusions)
+                    .Replace("EnableCustomCulturePlaceholder", enableCustomCulture.ToString());
+                env.CreateFile(Path.Combine(projectBFolder, projectBName), projBContent);
+
+                // Copy ProjectA files to test solution folder
+                CopyTestAsset(testAssetsPath, "ProjectA.csproj", solutionPath);
+                CopyTestAsset(testAssetsPath, "Test.resx", solutionPath);
+                CopyTestAsset(testAssetsPath, "Test.yue.resx", solutionPath);
+                CopyTestAsset(testAssetsPath, "Test.euy.resx", solutionPath);
+
+                env.SetCurrentDirectory(projectBFolder);
+                var output = RunnerUtilities.ExecBootstrapedMSBuild("-restore", out bool buildSucceeded);
+
+                buildSucceeded.ShouldBeTrue($"MSBuild should complete successfully. Build output: {output}");
+
+                var yueCultureResourceDll = Path.Combine(projBOutputPath, "yue", "ProjectA.resources.dll");
+                AssertCustomCulture(isYueCultureExpected, "yue", yueCultureResourceDll);
+
+                var euyCultureResourceDll = Path.Combine(projBOutputPath, "euy", "ProjectA.resources.dll");
+                AssertCustomCulture(isEuyCultureExpected, "euy", euyCultureResourceDll);
+            }
+
+            void AssertCustomCulture(bool isCultureExpectedToExist, string customCultureName, string cultureResourcePath)
+            {
+                if (enableCustomCulture && isCultureExpectedToExist)
+                {
+                    File.Exists(cultureResourcePath).ShouldBeTrue($"Expected '{customCultureName}' resource DLL not found at: {cultureResourcePath}");
+                }
+                else
+                {
+                    File.Exists(cultureResourcePath).ShouldBeFalse($"Unexpected '{customCultureName}' culture DLL was found at: {cultureResourcePath}");
+                }
+            }
+        }
+
+        private void CopyTestAsset(string sourceFolder, string fileName, string destinationFolder)
+        {
+            var sourcePath = Path.Combine(sourceFolder, fileName);
+
+            File.Copy(sourcePath, Path.Combine(destinationFolder, fileName));
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/TestResources/CustomCulture/ProjectA.csproj b/src/Tasks.UnitTests/TestResources/CustomCulture/ProjectA.csproj
new file mode 100644
index 00000000000..aa6d648f1b1
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/CustomCulture/ProjectA.csproj
@@ -0,0 +1,25 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <OutputType>Library</OutputType>
+    <TargetFramework>net472</TargetFramework>
+  </PropertyGroup>
+
+	<PropertyGroup>
+		<RespectAlreadyAssignedItemCulture>True</RespectAlreadyAssignedItemCulture>
+	</PropertyGroup>
+	<ItemGroup>
+		<EmbeddedResource Update="Test.resx">
+			<Generator>ResXFileCodeGenerator</Generator>
+		</EmbeddedResource>
+		<EmbeddedResource Update="Test.yue.resx">
+			<Culture>yue</Culture>
+			<LogicalName>Test.yue.resources</LogicalName>
+		</EmbeddedResource>
+    <EmbeddedResource Update="Test.euy.resx">
+      <Culture>euy</Culture>
+      <LogicalName>Test.euy.resources</LogicalName>
+    </EmbeddedResource>
+	</ItemGroup>
+
+</Project>
diff --git a/src/Tasks.UnitTests/TestResources/CustomCulture/ProjectB.csproj b/src/Tasks.UnitTests/TestResources/CustomCulture/ProjectB.csproj
new file mode 100644
index 00000000000..1daa05a8bc7
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/CustomCulture/ProjectB.csproj
@@ -0,0 +1,19 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <TargetFramework>net472</TargetFramework>
+    <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
+    <OutputType>Library</OutputType>
+    <OutputPath>OutputPathPlaceholder</OutputPath>
+	<EnableCustomCulture>EnableCustomCulturePlaceholder</EnableCustomCulture>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <NonCultureResourceDirectories>NonCultureResourceDirectoriesPlaceholder</NonCultureResourceDirectories>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\ProjectA.csproj" />
+  </ItemGroup>
+
+</Project>
diff --git a/src/Tasks.UnitTests/TestResources/CustomCulture/Test.euy.resx b/src/Tasks.UnitTests/TestResources/CustomCulture/Test.euy.resx
new file mode 100644
index 00000000000..e6136e281c2
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/CustomCulture/Test.euy.resx
@@ -0,0 +1,58 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<root>
+  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
+    <xsd:element name="root" msdata:IsDataSet="true">
+      <xsd:complexType>
+        <xsd:choice maxOccurs="unbounded">
+          <xsd:element name="metadata">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" />
+              <xsd:attribute name="type" type="xsd:string" />
+              <xsd:attribute name="mimetype" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="assembly">
+            <xsd:complexType>
+              <xsd:attribute name="alias" type="xsd:string" />
+              <xsd:attribute name="name" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="data">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
+              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
+              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="resheader">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" use="required" />
+            </xsd:complexType>
+          </xsd:element>
+        </xsd:choice>
+      </xsd:complexType>
+    </xsd:element>
+  </xsd:schema>
+  <resheader name="resmimetype">
+    <value>text/microsoft-resx</value>
+  </resheader>
+  <resheader name="version">
+    <value>2.0</value>
+  </resheader>
+  <resheader name="reader">
+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+  <resheader name="writer">
+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+</root>
diff --git a/src/Tasks.UnitTests/TestResources/CustomCulture/Test.resx b/src/Tasks.UnitTests/TestResources/CustomCulture/Test.resx
new file mode 100644
index 00000000000..e6136e281c2
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/CustomCulture/Test.resx
@@ -0,0 +1,58 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<root>
+  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
+    <xsd:element name="root" msdata:IsDataSet="true">
+      <xsd:complexType>
+        <xsd:choice maxOccurs="unbounded">
+          <xsd:element name="metadata">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" />
+              <xsd:attribute name="type" type="xsd:string" />
+              <xsd:attribute name="mimetype" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="assembly">
+            <xsd:complexType>
+              <xsd:attribute name="alias" type="xsd:string" />
+              <xsd:attribute name="name" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="data">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
+              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
+              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="resheader">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" use="required" />
+            </xsd:complexType>
+          </xsd:element>
+        </xsd:choice>
+      </xsd:complexType>
+    </xsd:element>
+  </xsd:schema>
+  <resheader name="resmimetype">
+    <value>text/microsoft-resx</value>
+  </resheader>
+  <resheader name="version">
+    <value>2.0</value>
+  </resheader>
+  <resheader name="reader">
+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+  <resheader name="writer">
+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+</root>
diff --git a/src/Tasks.UnitTests/TestResources/CustomCulture/Test.yue.resx b/src/Tasks.UnitTests/TestResources/CustomCulture/Test.yue.resx
new file mode 100644
index 00000000000..e6136e281c2
--- /dev/null
+++ b/src/Tasks.UnitTests/TestResources/CustomCulture/Test.yue.resx
@@ -0,0 +1,58 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<root>
+  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
+    <xsd:element name="root" msdata:IsDataSet="true">
+      <xsd:complexType>
+        <xsd:choice maxOccurs="unbounded">
+          <xsd:element name="metadata">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" />
+              <xsd:attribute name="type" type="xsd:string" />
+              <xsd:attribute name="mimetype" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="assembly">
+            <xsd:complexType>
+              <xsd:attribute name="alias" type="xsd:string" />
+              <xsd:attribute name="name" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="data">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
+              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
+              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="resheader">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
+              </xsd:sequence>
+              <xsd:attribute name="name" type="xsd:string" use="required" />
+            </xsd:complexType>
+          </xsd:element>
+        </xsd:choice>
+      </xsd:complexType>
+    </xsd:element>
+  </xsd:schema>
+  <resheader name="resmimetype">
+    <value>text/microsoft-resx</value>
+  </resheader>
+  <resheader name="version">
+    <value>2.0</value>
+  </resheader>
+  <resheader name="reader">
+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+  <resheader name="writer">
+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+  </resheader>
+</root>
diff --git a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
index 633d6ef0435..acabaad7dec 100644
--- a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
+++ b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
@@ -319,7 +319,7 @@ public void WriteLinesToFileDoesCreateDirectory()
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        private void WritingNothingErasesExistingFile(bool useNullLines)
+        public void WritingNothingErasesExistingFile(bool useNullLines)
         {
             ITaskItem[] lines = useNullLines ? null : Array.Empty<ITaskItem>();
 
@@ -346,7 +346,7 @@ private void WritingNothingErasesExistingFile(bool useNullLines)
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        private void WritingNothingCreatesNewFile(bool useNullLines)
+        public void WritingNothingCreatesNewFile(bool useNullLines)
         {
             ITaskItem[] lines = useNullLines ? null : Array.Empty<ITaskItem>();
 
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 9e3b0c07d36..2b57c7287f8 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -92,10 +92,6 @@ internal sealed class ReferenceTable
         private readonly GetAssemblyMetadata _getAssemblyMetadata;
         /// <summary>Delegate used to get the image runtime version of a file</summary>
         private readonly GetAssemblyRuntimeVersion _getRuntimeVersion;
-#if FEATURE_WIN32_REGISTRY
-        /// <summary> Delegate to get the base registry key for AssemblyFoldersEx</summary>
-        private OpenBaseKey _openBaseKey;
-#endif
         /// <summary>Version of the runtime we are targeting</summary>
         private readonly Version _targetedRuntimeVersion;
 
@@ -135,7 +131,7 @@ internal sealed class ReferenceTable
         private readonly bool _doNotCopyLocalIfInGac;
 
         /// <summary>
-        ///  Shoould the framework attribute version mismatch be ignored.
+        ///  Should the framework attribute version mismatch be ignored.
         /// </summary>
         private readonly bool _ignoreFrameworkAttributeVersionMismatch;
 
@@ -145,7 +141,17 @@ internal sealed class ReferenceTable
         private readonly GetAssemblyPathInGac _getAssemblyPathInGac;
 
         /// <summary>
-        /// Should a warning or error be emitted on architecture mismatch
+        /// Contains the list of directories that should NOT be considered as custom culture directories.
+        /// </summary>
+        private readonly string[] _nonCultureResourceDirectories = [];
+
+        /// <summary>
+        /// Is true, custom culture processing is enabled.
+        /// </summary>
+        private readonly bool _enableCustomCulture = false;
+
+        /// <summary>
+        /// Should a warning or error be emitted on architecture mismatch.
         /// </summary>
         private readonly WarnOrErrorOnTargetArchitectureMismatchBehavior _warnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatchBehavior.Warning;
 
@@ -174,6 +180,7 @@ internal sealed class ReferenceTable
         /// <param name="findSatellites">If true, then search for satellite files.</param>
         /// <param name="findSerializationAssemblies">If true, then search for serialization assembly files.</param>
         /// <param name="findRelatedFiles">If true, then search for related files.</param>
+        /// <param name="enableCustomCulture">If true, custom culture processing is enabled.</param>
         /// <param name="searchPaths">Paths to search for dependent assemblies on.</param>
         /// <param name="relatedFileExtensions"></param>
         /// <param name="candidateAssemblyFiles">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>
@@ -206,6 +213,7 @@ internal sealed class ReferenceTable
         /// <param name="readMachineTypeFromPEHeader"></param>
         /// <param name="warnOrErrorOnTargetArchitectureMismatch"></param>
         /// <param name="ignoreFrameworkAttributeVersionMismatch"></param>
+        /// <param name="nonCultureResourceDirectories"></param>
 #else
         /// <summary>
         /// Construct.
@@ -215,13 +223,14 @@ internal sealed class ReferenceTable
         /// <param name="findSatellites">If true, then search for satellite files.</param>
         /// <param name="findSerializationAssemblies">If true, then search for serialization assembly files.</param>
         /// <param name="findRelatedFiles">If true, then search for related files.</param>
+        /// <param name="enableCustomCulture">If true, custom culture processing is enabled.</param>
         /// <param name="searchPaths">Paths to search for dependent assemblies on.</param>
         /// <param name="relatedFileExtensions"></param>
         /// <param name="candidateAssemblyFiles">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>
         /// <param name="resolvedSDKItems">Resolved sdk items</param>
         /// <param name="frameworkPaths">Path to the FX.</param>
         /// <param name="installedAssemblies">Installed assembly XML tables.</param>
-        /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
+        /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targeted.</param>
         /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
         /// <param name="directoryExists">Delegate used for files.</param>
         /// <param name="getDirectories">Delegate used for getting directories.</param>
@@ -234,7 +243,7 @@ internal sealed class ReferenceTable
         /// <param name="targetedRuntimeVersion">Version of the runtime to target.</param>
         /// <param name="projectTargetFramework">Version of the framework targeted by the project.</param>
         /// <param name="targetFrameworkMoniker">Target framework moniker we are targeting.</param>
-        /// <param name="log">Logging helper to allow the logging of meessages from the Reference Table.</param>
+        /// <param name="log">Logging helper to allow the logging of messages from the Reference Table.</param>
         /// <param name="latestTargetFrameworkDirectories"></param>
         /// <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
         /// <param name="doNotCopyLocalIfInGac"></param>
@@ -244,6 +253,7 @@ internal sealed class ReferenceTable
         /// <param name="readMachineTypeFromPEHeader"></param>
         /// <param name="warnOrErrorOnTargetArchitectureMismatch"></param>
         /// <param name="ignoreFrameworkAttributeVersionMismatch"></param>
+        /// <param name="nonCultureResourceDirectories"></param>
 #endif
         internal ReferenceTable(
             IBuildEngine buildEngine,
@@ -251,6 +261,7 @@ internal ReferenceTable(
             bool findSatellites,
             bool findSerializationAssemblies,
             bool findRelatedFiles,
+            bool enableCustomCulture,
             string[] searchPaths,
             string[] allowedAssemblyExtensions,
             string[] relatedFileExtensions,
@@ -284,7 +295,8 @@ internal ReferenceTable(
             WarnOrErrorOnTargetArchitectureMismatchBehavior warnOrErrorOnTargetArchitectureMismatch,
             bool ignoreFrameworkAttributeVersionMismatch,
             bool unresolveFrameworkAssembliesFromHigherFrameworks,
-            ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache)
+            ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache,
+            string[] nonCultureResourceDirectories)
         {
             _log = log;
             _findDependencies = findDependencies;
@@ -304,9 +316,6 @@ internal ReferenceTable(
             _getRuntimeVersion = getRuntimeVersion;
             _projectTargetFramework = projectTargetFramework;
             _targetedRuntimeVersion = targetedRuntimeVersion;
-#if FEATURE_WIN32_REGISTRY
-            _openBaseKey = openBaseKey;
-#endif
             _targetFrameworkMoniker = targetFrameworkMoniker;
             _latestTargetFrameworkDirectories = latestTargetFrameworkDirectories;
             _copyLocalDependenciesWhenParentReferenceInGac = copyLocalDependenciesWhenParentReferenceInGac;
@@ -317,6 +326,8 @@ internal ReferenceTable(
             _warnOrErrorOnTargetArchitectureMismatch = warnOrErrorOnTargetArchitectureMismatch;
             _ignoreFrameworkAttributeVersionMismatch = ignoreFrameworkAttributeVersionMismatch;
             _assemblyMetadataCache = assemblyMetadataCache;
+            _nonCultureResourceDirectories = nonCultureResourceDirectories;
+            _enableCustomCulture = enableCustomCulture;
 
             // Set condition for when to check assembly version against the target framework version
             _checkAssemblyVersionAgainstTargetFrameworkVersion = unresolveFrameworkAssembliesFromHigherFrameworks || ((_projectTargetFramework ?? ReferenceTable.s_targetFrameworkVersion_40) <= ReferenceTable.s_targetFrameworkVersion_40);
@@ -970,8 +981,9 @@ private void FindSatellites(
                     // Is there a candidate satellite in that folder?
                     string cultureName = Path.GetFileName(subDirectory);
 
-                    // Custom or unknown cultures can be met as well
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14) || CultureInfoCache.IsValidCultureString(cultureName))
+                    // Custom or unknown cultures can be met only if the feature is enabled and the directory was not added to the exclusion list.
+                    if ((_enableCustomCulture && !_nonCultureResourceDirectories.Contains(cultureName))
+                        || CultureInfoCache.IsValidCultureString(cultureName))
                     {
                         string satelliteAssembly = Path.Combine(subDirectory, satelliteFilename);
                         if (_fileExists(satelliteAssembly))
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index a5a3ae00813..8a42269ce14 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -177,8 +177,10 @@ internal static void Initialize(TaskLoggingHelper log)
         private ITaskItem[] _resolvedSDKReferences = Array.Empty<TaskItem>();
         private bool _ignoreDefaultInstalledAssemblyTables = false;
         private bool _ignoreDefaultInstalledAssemblySubsetTables = false;
+        private bool _enableCustomCulture = false;
         private string[] _candidateAssemblyFiles = [];
         private string[] _targetFrameworkDirectories = [];
+        private string[] _nonCultureResourceDirectories = [];
         private string[] _searchPaths = [];
         private string[] _allowedAssemblyExtensions = [".winmd", ".dll", ".exe"];
         private string[] _relatedFileExtensions = [".pdb", ".xml", ".pri"];
@@ -422,6 +424,24 @@ public string[] TargetFrameworkDirectories
             set { _targetFrameworkDirectories = value; }
         }
 
+        /// <summary>
+        /// Contains list of directories that point to custom culture resources that has to be ignored by MSBuild.
+        /// </summary>
+        public string[] NonCultureResourceDirectories
+        {
+            get { return _nonCultureResourceDirectories; }
+            set { _nonCultureResourceDirectories = value; }
+        }
+
+        /// <summary>
+        /// Contains the information if custom culture is enabled.
+        /// </summary>
+        public bool EnableCustomCulture
+        {
+            get { return _enableCustomCulture; }
+            set { _enableCustomCulture = value; }     
+        }
+
         /// <summary>
         /// A list of XML files that contain assemblies that are expected to be installed on the target machine.
         ///
@@ -1511,7 +1531,10 @@ private void LogInputs()
             }
 
             Log.LogMessage(importance, property, "TargetFrameworkDirectories");
-            Log.LogMessage(importance, indent + String.Join(",", TargetFrameworkDirectories));
+            Log.LogMessage(importance, indent + string.Join(",", TargetFrameworkDirectories));
+
+            Log.LogMessage(importance, property, "NonCultureResourceDirectories");
+            Log.LogMessage(importance, indent + string.Join(",", NonCultureResourceDirectories));
 
             Log.LogMessage(importance, property, "InstalledAssemblyTables");
             foreach (ITaskItem installedAssemblyTable in InstalledAssemblyTables)
@@ -1547,6 +1570,12 @@ private void LogInputs()
             Log.LogMessage(importance, property, "AutoUnify");
             Log.LogMessage(importance, $"{indent}{AutoUnify}");
 
+            Log.LogMessage(importance, property, "EnableCustomCulture");
+            Log.LogMessage(importance, $"{indent}{EnableCustomCulture}");
+
+            Log.LogMessage(importance, property, "EnableCustomCulture");
+            Log.LogMessage(importance, $"{indent}{EnableCustomCulture}");
+
             Log.LogMessage(importance, property, "CopyLocalDependenciesWhenParentReferenceInGac");
             Log.LogMessage(importance, $"{indent}{_copyLocalDependenciesWhenParentReferenceInGac}");
 
@@ -2386,6 +2415,7 @@ internal bool Execute(
                         _findSatellites,
                         _findSerializationAssemblies,
                         _findRelatedFiles,
+                        _enableCustomCulture,
                         _searchPaths,
                         _allowedAssemblyExtensions,
                         _relatedFileExtensions,
@@ -2419,7 +2449,8 @@ internal bool Execute(
                         _warnOrErrorOnTargetArchitectureMismatch,
                         _ignoreTargetFrameworkAttributeVersionMismatch,
                         _unresolveFrameworkAssembliesFromHigherFrameworks,
-                        assemblyMetadataCache);
+                        assemblyMetadataCache,
+                        _nonCultureResourceDirectories);
 
                     dependencyTable.FindDependenciesOfExternallyResolvedReferences = FindDependenciesOfExternallyResolvedReferences;
 
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index 6f3b6b5a06d..c7f838b16ef 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -51,7 +51,7 @@ protected override string CreateManifestName(
                 Actual implementation is in a static method called CreateManifestNameImpl.
                 The reason is that CreateManifestName can't be static because it is an
                 override of a method declared in the base class, but its convenient
-                to expose a static version anyway for unittesting purposes.
+                to expose a static version anyway for unit testing purposes.
             */
             return CreateManifestNameImpl(
                 fileName,
@@ -62,7 +62,8 @@ The reason is that CreateManifestName can't be static because it is an
                 culture,
                 binaryStream,
                 Log,
-                treatAsCultureNeutral);
+                treatAsCultureNeutral,
+                EnableCustomCulture);
         }
 
         /// <summary>
@@ -81,6 +82,7 @@ The reason is that CreateManifestName can't be static because it is an
         /// <param name="binaryStream">File contents binary stream, may be null</param>
         /// <param name="log">Task's TaskLoggingHelper, for logging warnings or errors</param>
         /// <param name="treatAsCultureNeutral">Whether to treat the current file as 'culture-neutral' and retain the culture in the name.</param>
+        /// <param name="enableCustomCulture">Whether custom culture handling is expected.</param>
         /// <returns>Returns the manifest name</returns>
         internal static string CreateManifestNameImpl(
             string fileName,
@@ -91,7 +93,8 @@ internal static string CreateManifestNameImpl(
             string culture, // may be null
             Stream binaryStream, // File contents binary stream, may be null
             TaskLoggingHelper log,
-            bool treatAsCultureNeutral = false)
+            bool treatAsCultureNeutral = false,
+            bool enableCustomCulture = false)
         {
             // Use the link file name if there is one, otherwise, fall back to file name.
             string embeddedFileName = FileUtilities.FixFilePath(linkFileName);
@@ -103,13 +106,12 @@ internal static string CreateManifestNameImpl(
             dependentUponFileName = FileUtilities.FixFilePath(dependentUponFileName);
             Culture.ItemCultureInfo info;
 
-            if (!string.IsNullOrEmpty(culture) && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14))
+            if (!string.IsNullOrEmpty(culture) && enableCustomCulture)
             {
                 info = new Culture.ItemCultureInfo()
                 {
                     culture = culture,
-                    cultureNeutralFilename =
-                        embeddedFileName.RemoveLastInstanceOf("." + culture, StringComparison.OrdinalIgnoreCase),
+                    cultureNeutralFilename = embeddedFileName.RemoveLastInstanceOf("." + culture, StringComparison.OrdinalIgnoreCase),
                 };
             }
             else
diff --git a/src/Tasks/CreateManifestResourceName.cs b/src/Tasks/CreateManifestResourceName.cs
index 934d67c6a68..d974b1a8d1c 100644
--- a/src/Tasks/CreateManifestResourceName.cs
+++ b/src/Tasks/CreateManifestResourceName.cs
@@ -28,6 +28,8 @@ public abstract class CreateManifestResourceName : TaskExtension
 
         private ITaskItem[] _resourceFiles;
 
+        private bool _enableCustomCulture;
+
         [SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Justification = "Shipped this way in Dev11 Beta (go-live)")]
         [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Taskitem", Justification = "Shipped this way in Dev11 Beta (go-live)")]
         protected Dictionary<string, ITaskItem> itemSpecToTaskitem = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
@@ -56,6 +58,15 @@ public ITaskItem[] ResourceFiles
             set => _resourceFiles = value;
         }
 
+        /// <summary>
+        /// Contains the information if custom culture is enabled.
+        /// </summary>
+        public bool EnableCustomCulture
+        {
+            get { return _enableCustomCulture; }
+            set { _enableCustomCulture = value; }
+        }
+
         /// <summary>
         /// Rootnamespace to use for naming.
         /// </summary>
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 0115685336f..d2cf7f405ef 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -50,7 +50,7 @@ protected override string CreateManifestName(
                 Actual implementation is in a static method called CreateManifestNameImpl.
                 The reason is that CreateManifestName can't be static because it is an
                 override of a method declared in the base class, but its convenient
-                to expose a static version anyway for unittesting purposes.
+                to expose a static version anyway for unit testing purposes.
             */
             return CreateManifestNameImpl(
                 fileName,
@@ -61,7 +61,8 @@ The reason is that CreateManifestName can't be static because it is an
                 culture,
                 binaryStream,
                 Log,
-                treatAsCultureNeutral);
+                treatAsCultureNeutral,
+                EnableCustomCulture);
         }
 
         /// <summary>
@@ -80,6 +81,7 @@ The reason is that CreateManifestName can't be static because it is an
         /// <param name="binaryStream">File contents binary stream, may be null</param>
         /// <param name="log">Task's TaskLoggingHelper, for logging warnings or errors</param>
         /// <param name="treatAsCultureNeutral">Whether to treat the current file as 'culture-neutral' and retain the culture in the name.</param>
+        /// <param name="enableCustomCulture">Whether custom culture handling is expected.</param>
         /// <returns>Returns the manifest name</returns>
         internal static string CreateManifestNameImpl(
             string fileName,
@@ -90,7 +92,8 @@ internal static string CreateManifestNameImpl(
             string culture,
             Stream binaryStream, // File contents binary stream, may be null
             TaskLoggingHelper log,
-            bool treatAsCultureNeutral = false)
+            bool treatAsCultureNeutral = false,
+            bool enableCustomCulture = false)
         {
             // Use the link file name if there is one, otherwise, fall back to file name.
             string embeddedFileName = linkFileName;
@@ -102,13 +105,12 @@ internal static string CreateManifestNameImpl(
             dependentUponFileName = FileUtilities.FixFilePath(dependentUponFileName);
             Culture.ItemCultureInfo info;
 
-            if (!string.IsNullOrEmpty(culture) && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14))
+            if (!string.IsNullOrEmpty(culture) && enableCustomCulture)
             {
                 info = new Culture.ItemCultureInfo()
                 {
                     culture = culture,
-                    cultureNeutralFilename =
-                        embeddedFileName.RemoveLastInstanceOf("." + culture, StringComparison.OrdinalIgnoreCase)
+                    cultureNeutralFilename = embeddedFileName.RemoveLastInstanceOf("." + culture, StringComparison.OrdinalIgnoreCase),
                 };
             }
             else
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index baca3658583..66baa32d31f 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -2,12 +2,13 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.Globalization;
 #if NET
 using System.Linq;
-#endif
+#else
+using System.Collections.Generic;
 using Microsoft.Build.Shared;
+#endif
 
 #nullable disable
 
@@ -32,6 +33,7 @@ internal static class CultureInfoCache
         // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.
         private static readonly string[] pseudoLocales = ["qps-ploc", "qps-ploca", "qps-plocm", "qps-Latn-x-sh"];
 
+#if !NET
         private static HashSet<string> InitializeValidCultureNames()
         {
 #if !FEATURE_CULTUREINFO_GETCULTURES
@@ -54,6 +56,7 @@ private static HashSet<string> InitializeValidCultureNames()
 
             return validCultureNames;
         }
+#endif
 
         /// <summary>
         /// Determine if a culture string represents a valid <see cref="CultureInfo"/> instance.
@@ -79,7 +82,7 @@ internal static bool IsValidCultureString(string name)
 #endif
         }
 
-#if !FEATURE_CULTUREINFO_GETCULTURES
+#if !NET && !FEATURE_CULTUREINFO_GETCULTURES
         // Copied from https://github.com/aspnet/Localization/blob/5e1fb16071affd15f15b9c732833f3ae2ac46e10/src/Microsoft.Framework.Globalization.CultureInfoCache/CultureInfoList.cs
         // Regenerated using the tool (removed by https://github.com/aspnet/Localization/pull/130)
         //   * Removed the empty string from the list
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index d761f90b332..7c41f6fcbf3 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -16,6 +16,7 @@
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Resources;
 using System.Resources.Extensions;
 using System.Reflection;
@@ -41,7 +42,6 @@
 using Microsoft.Build.Utilities;
 #if FEATURE_RESXREADER_LIVEDESERIALIZATION
 using Microsoft.Win32;
-using System.Linq;
 #endif
 
 #nullable disable
@@ -1705,7 +1705,7 @@ private void UpdateNewestUncorrelatedInputWriteTime()
 
             // Check the timestamp of each of the passed-in references to find the newest;
             // and then the additional inputs
-            ITaskItem[] inputs = this.References ?? [.. (this.AdditionalInputs ?? [])];
+            var inputs = (this.References ?? []).Concat(this.AdditionalInputs ?? []);
 
             foreach (ITaskItem input in inputs)
             {
@@ -2015,7 +2015,6 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
                 return result != null;
             }
         }
-#endif
 
         /// <summary>
         /// Turns the nicely justified block of base64 found in a resx into a byte array.
@@ -2046,6 +2045,7 @@ private static byte[] ByteArrayFromBase64WrappedString(string text)
                 return Convert.FromBase64String(text);
             }
         }
+#endif
 
         /// <summary>
         /// Make sure that OutputResources has 1 file name for each name in Sources.
@@ -2295,10 +2295,12 @@ internal string StronglyTypedClassName
         /// </summary>
         private List<ITaskItem> _inFiles;
 
+#if !FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// List of satellite input files to process.
         /// </summary>
         private List<ITaskItem> _satelliteInFiles;
+#endif
 
         /// <summary>
         /// List of output files to process.
@@ -2310,11 +2312,6 @@ internal string StronglyTypedClassName
         /// </summary>
         private bool _extractResWFiles;
 
-        /// <summary>
-        /// Where to write extracted ResW files.
-        /// </summary>
-        private string _resWOutputDirectory;
-
         private bool _usePreserializedResources;
 
         internal List<ITaskItem> ExtractedResWFiles
@@ -2402,7 +2399,9 @@ internal void Run(
             _logger = log;
             _assemblyFiles = assemblyFilesList;
             _inFiles = inputs;
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             _satelliteInFiles = satelliteInputs;
+#endif
             _outFiles = outputs;
             _useSourcePath = sourcePath;
             _stronglyTypedLanguage = language;
@@ -2413,7 +2412,6 @@ internal void Run(
             _stronglyTypedClassIsPublic = publicClass;
             _readers = new List<ReaderInfo>();
             _extractResWFiles = extractingResWFiles;
-            _resWOutputDirectory = resWOutputDirectory;
             _portableLibraryCacheInfo = new List<ResGenDependencies.PortableLibraryFile>();
             _usePreserializedResources = usePreserializedResources;
             _logWarningForBinaryFormatter = logWarningForBinaryFormatter;
diff --git a/src/Tasks/ManifestUtil/ManifestReader.cs b/src/Tasks/ManifestUtil/ManifestReader.cs
index 1bd48abe2db..87e7e3d452d 100644
--- a/src/Tasks/ManifestUtil/ManifestReader.cs
+++ b/src/Tasks/ManifestUtil/ManifestReader.cs
@@ -54,9 +54,7 @@ private static XmlDocument GetXmlDocument(string path)
             using (Stream s = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read))
             {
                 byte[] buffer = new byte[2];
-#pragma warning disable CA2022 // Avoid inexact read with 'Stream.Read' The check of bytes happens later in the code. In case of invalid documents the code will throw an exception during xml loading.
-                s.Read(buffer, 0, 2);
-#pragma warning restore CA2022 // Avoid inexact read with 'Stream.Read'
+                s.ReadExactly(buffer, 0, 2);
                 s.Position = 0;
                 var document = new XmlDocument();
                 var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
@@ -140,9 +138,7 @@ public static Manifest ReadManifest(string manifestType, string path, bool prese
             using (Stream s = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read))
             {
                 byte[] buffer = new byte[2];
-#pragma warning disable CA2022 // Avoid inexact read with 'Stream.Read' The check of bytes happens later in the code. In case of invalid document the exception is expected later
-                s.Read(buffer, 0, 2);
-#pragma warning restore CA2022 // Avoid inexact read with 'Stream.Read'
+                s.ReadExactly(buffer, 0, 2);
                 s.Position = 0;
                 // if first two bytes are "MZ" then we're looking at an .exe or a .dll not a .manifest
                 if ((buffer[0] == 0x4D) && (buffer[1] == 0x5A))
diff --git a/src/Tasks/ManifestUtil/PathUtil.cs b/src/Tasks/ManifestUtil/PathUtil.cs
index 93ec71a20a8..83184f8f618 100644
--- a/src/Tasks/ManifestUtil/PathUtil.cs
+++ b/src/Tasks/ManifestUtil/PathUtil.cs
@@ -166,9 +166,7 @@ public static bool IsPEFile(string path)
             byte[] buffer = new byte[2];
             using (Stream s = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.Read))
             {
-#pragma warning disable CA2022 // Avoid inexact read with 'Stream.Read'
-                s.Read(buffer, 0, 2);
-#pragma warning restore CA2022 // Avoid inexact read with 'Stream.Read'
+                s.ReadExactly(buffer, 0, 2);
             }
 
             // if first two bytes are "MZ" then we're looking at an .exe or a .dll not a .manifest
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index a737ed59012..0013fbde3e2 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -502,7 +502,7 @@ public static PermissionSet XmlToPermissionSet(XmlElement element)
         [SupportedOSPlatform("windows")]
         public static void SignFile(string certThumbprint, Uri timestampUrl, string path)
         {
-            SignFile(certThumbprint, timestampUrl, path, null, null);
+            SignFile(certThumbprint, timestampUrl, path, targetFrameworkVersion: null, targetFrameworkIdentifier: null);
         }
 
         /// <summary>
@@ -518,7 +518,7 @@ public static void SignFile(string certThumbprint,
                                     string path,
                                     string targetFrameworkVersion)
         {
-            SignFile(certThumbprint, timestampUrl, path, targetFrameworkVersion, null);
+            SignFile(certThumbprint, timestampUrl, path, targetFrameworkVersion, targetFrameworkIdentifier: null);
         }
 
         /// <summary>
@@ -536,7 +536,7 @@ public static void SignFile(string certThumbprint,
                                     string targetFrameworkVersion,
                                     string targetFrameworkIdentifier)
         {
-            SignFile(certThumbprint, timestampUrl, path, targetFrameworkVersion, targetFrameworkIdentifier, false);
+            SignFile(certThumbprint, timestampUrl, path, targetFrameworkVersion, targetFrameworkIdentifier, disallowMansignTimestampFallback: false);
         }
 
         /// <summary>
@@ -637,7 +637,7 @@ public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path
         {
             // setup resources
             System.Resources.ResourceManager resources = new System.Resources.ResourceManager("Microsoft.Build.Tasks.Core.Strings.ManifestUtilities", typeof(SecurityUtilities).Module.Assembly);
-            SignFileInternal(cert, timestampUrl, path, true, resources);
+            SignFileInternal(cert, timestampUrl, path, targetFrameworkSupportsSha256: true, resources);
         }
 
         [SupportedOSPlatform("windows")]
@@ -701,6 +701,7 @@ private static void SignFileInternal(X509Certificate2 cert,
                         {
                             doc.Load(xr);
                         }
+
                         var manifest = new SignedCmiManifest2(doc, useSha256);
                         CmiManifestSigner2 signer;
                         if (useSha256 && rsa is RSACryptoServiceProvider rsacsp)
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index d23e63c0870..522a2173045 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -550,126 +550,68 @@ private static void ReplacePublicKeyToken(XmlDocument manifestDom, AsymmetricAlg
             }
         }
 
+        [SuppressMessage("Security", "CA5350:Do Not Use Weak Cryptographic Algorithms", Justification = "SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2.")]
         private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool useSha256)
         {
-#if (true) // BUGBUG: Remove before RTM when old format support is no longer needed.
-            return ComputeHashFromManifest(manifestDom, false, useSha256);
-        }
+            // Since the DOM given to us is not guaranteed to be normalized,
+            // we need to normalize it ourselves. Also, we always preserve
+            // white space as Fusion XML engine always preserve white space.
+            XmlDocument normalizedDom = new XmlDocument();
+            normalizedDom.PreserveWhitespace = true;
+
+            // Normalize the document
+            using (TextReader stringReader = new StringReader(manifestDom.OuterXml))
+            {
+                XmlReaderSettings settings = new XmlReaderSettings();
+                settings.DtdProcessing = DtdProcessing.Parse;
+                using (XmlReader reader = XmlReader.Create(stringReader, settings, manifestDom.BaseURI))
+                {
+                    normalizedDom.Load(reader);
+                }
+            }
 
-        [System.Diagnostics.CodeAnalysis.SuppressMessage("Security", "CA5350:Do Not Use Weak Cryptographic Algorithms", Justification = "SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2.")]
-        private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldFormat, bool useSha256)
-        {
-            if (oldFormat)
-            {
-                XmlDsigExcC14NTransform exc = new XmlDsigExcC14NTransform();
-                exc.LoadInput(manifestDom);
+            XmlDsigExcC14NTransform exc = new XmlDsigExcC14NTransform();
+            exc.LoadInput(normalizedDom);
 
-                if (useSha256)
-                {
+            if (useSha256)
+            {
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                    using (SHA256 sha2 = SHA256.Create(
+                using (SHA256 sha2 = SHA256.Create(
 #if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
-                        "System.Security.Cryptography.SHA256CryptoServiceProvider"
+                    "System.Security.Cryptography.SHA256CryptoServiceProvider"
 #endif
-                ))
+                    ))
 #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                    {
-                        byte[] hash = sha2.ComputeHash(exc.GetOutput() as MemoryStream);
-                        if (hash == null)
-                        {
-                            throw new CryptographicException(Win32.TRUST_E_BAD_DIGEST);
-                        }
-
-                        return hash;
-                    }
-                }
-                else
                 {
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                    // codeql[cs/weak-crypto] SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2. https://devdiv.visualstudio.com/DevDiv/_workitems/edit/139025
-                    using (SHA1 sha1 = SHA1.Create(
-#if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
-                        "System.Security.Cryptography.SHA1CryptoServiceProvider"
-#endif
-                        ))
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+                    byte[] hash = sha2.ComputeHash(exc.GetOutput() as MemoryStream);
+                    if (hash == null)
                     {
-                        byte[] hash = sha1.ComputeHash(exc.GetOutput() as MemoryStream);
-                        if (hash == null)
-                        {
-                            throw new CryptographicException(Win32.TRUST_E_BAD_DIGEST);
-                        }
-
-                        return hash;
+                        throw new CryptographicException(Win32.TRUST_E_BAD_DIGEST);
                     }
+
+                    return hash;
                 }
             }
             else
             {
-#endif
-                // Since the DOM given to us is not guaranteed to be normalized,
-                // we need to normalize it ourselves. Also, we always preserve
-                // white space as Fusion XML engine always preserve white space.
-                XmlDocument normalizedDom = new XmlDocument();
-                normalizedDom.PreserveWhitespace = true;
-
-                // Normalize the document
-                using (TextReader stringReader = new StringReader(manifestDom.OuterXml))
-                {
-                    XmlReaderSettings settings = new XmlReaderSettings();
-                    settings.DtdProcessing = DtdProcessing.Parse;
-                    using (XmlReader reader = XmlReader.Create(stringReader, settings, manifestDom.BaseURI))
-                    {
-                        normalizedDom.Load(reader);
-                    }
-                }
-
-                XmlDsigExcC14NTransform exc = new XmlDsigExcC14NTransform();
-                exc.LoadInput(normalizedDom);
-
-                if (useSha256)
-                {
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                    using (SHA256 sha2 = SHA256.Create(
+                // codeql[cs/weak-crypto] SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2. https://devdiv.visualstudio.com/DevDiv/_workitems/edit/139025
+                using (SHA1 sha1 = SHA1.Create(
 #if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
-                        "System.Security.Cryptography.SHA256CryptoServiceProvider"
+                    "System.Security.Cryptography.SHA1CryptoServiceProvider"
 #endif
-                        ))
+                     ))
 #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                    {
-                        byte[] hash = sha2.ComputeHash(exc.GetOutput() as MemoryStream);
-                        if (hash == null)
-                        {
-                            throw new CryptographicException(Win32.TRUST_E_BAD_DIGEST);
-                        }
-
-                        return hash;
-                    }
-                }
-                else
                 {
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                    // codeql[cs/weak-crypto] SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2. https://devdiv.visualstudio.com/DevDiv/_workitems/edit/139025
-                    using (SHA1 sha1 = SHA1.Create(
-#if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
-                        "System.Security.Cryptography.SHA1CryptoServiceProvider"
-#endif
-                         ))
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+                    byte[] hash = sha1.ComputeHash(exc.GetOutput() as MemoryStream);
+                    if (hash == null)
                     {
-                        byte[] hash = sha1.ComputeHash(exc.GetOutput() as MemoryStream);
-                        if (hash == null)
-                        {
-                            throw new CryptographicException(Win32.TRUST_E_BAD_DIGEST);
-                        }
-
-                        return hash;
+                        throw new CryptographicException(Win32.TRUST_E_BAD_DIGEST);
                     }
-                }
 
-#if (true) // BUGBUG: Remove before RTM when old format support is no longer needed.
+                    return hash;
+                }
             }
-#endif
         }
 
         private const string AssemblyNamespaceUri = "urn:schemas-microsoft-com:asm.v1";
@@ -739,8 +681,8 @@ private static void AuthenticodeSignLicenseDom(XmlDocument licenseDom, CmiManife
             signedXml.SignedInfo.CanonicalizationMethod = SignedXml.XmlDsigExcC14NTransformUrl;
             if (signer.UseSha256)
             {
-                signedXml.SignedInfo.SignatureMethod = Sha256SignatureMethodUri;
-            }
+                    signedXml.SignedInfo.SignatureMethod = Sha256SignatureMethodUri;
+                }
             else
             {
                 signedXml.SignedInfo.SignatureMethod = Sha1SignatureMethodUri;
@@ -1108,12 +1050,12 @@ internal class CmiManifestSigner2
         private X509Certificate2Collection _certificates;
         private X509IncludeOption _includeOption;
         private CmiManifestSignerFlag _signerFlag;
-        private bool _useSha256;
+        private readonly bool _useSha256;
 
         private CmiManifestSigner2() { }
 
         internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey) :
-            this(strongNameKey, null, false)
+            this(strongNameKey, certificate: null, useSha256: false)
         { }
 
         internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey, X509Certificate2 certificate, bool useSha256)
@@ -1311,7 +1253,7 @@ internal CmiAuthenticodeSignerInfo(int errorCode)
         }
 
         internal CmiAuthenticodeSignerInfo(Win32.AXL_SIGNER_INFO signerInfo,
-                                            Win32.AXL_TIMESTAMPER_INFO timestamperInfo)
+                                           Win32.AXL_TIMESTAMPER_INFO timestamperInfo)
         {
             _error = (int)signerInfo.dwError;
             if (signerInfo.pChainContext != IntPtr.Zero)
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 37d7cece260..a518f22fe8b 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -447,24 +447,6 @@
     <Content Include="Microsoft.NETFramework.props">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
-    <Content Include="Microsoft.VisualStudioVersion.v11.Common.props">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
-    <Content Include="Microsoft.VisualStudioVersion.v12.Common.props">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
-    <Content Include="Microsoft.VisualStudioVersion.v14.Common.props">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
-    <Content Include="Microsoft.VisualStudioVersion.v15.Common.props">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
-    <Content Include="Microsoft.VisualStudioVersion.v16.Common.props">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
-    <Content Include="Microsoft.VisualStudioVersion.v17.Common.props">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-    </Content>
     <!-- Resource Files -->
     <EmbeddedResource Include="Resources\Strings.resx">
       <LogicalName>$(AssemblyName).Strings.resources</LogicalName>
@@ -663,7 +645,6 @@
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
-    <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Resources.Extensions" />
   </ItemGroup>
 
@@ -682,6 +663,7 @@
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'">
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
+    <PackageReference Include="System.Collections.Immutable" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildSourceOnly)' != 'true'">
diff --git a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
index 60045885791..6e30cf7fba4 100644
--- a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
@@ -100,6 +100,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <CreateCSharpManifestResourceName
               ResourceFiles="@(EmbeddedResource)"
               RootNamespace="$(RootNamespace)"
+              EnableCustomCulture="$(EnableCustomCulture)"
               UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)"
               Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and ('%(EmbeddedResource.WithCulture)' == 'false' or '%(EmbeddedResource.Type)' == 'Resx')">
             <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
@@ -247,6 +248,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          ChecksumAlgorithm="$(ChecksumAlgorithm)"
          CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)"
          CodePage="$(CodePage)"
+         CompilerType="$(RoslynCompilerType)"
          DebugType="none"
          DefineConstants="$(DefineConstants)"
          DelaySign="$(DelaySign)"
@@ -261,6 +263,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          ErrorLog="$(ErrorLog)"
          ErrorReport="$(ErrorReport)"
          Features="$(Features)"
+         InterceptorsNamespaces="$(InterceptorsNamespaces)"
          InterceptorsPreviewNamespaces="$(InterceptorsPreviewNamespaces)"
          FileAlignment="$(FileAlignment)"
          GeneratedFilesOutputPath="$(CompilerGeneratedFilesOutputPath)"
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 48b9de51827..0c4ce55ad13 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -2412,6 +2412,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </Reference>
     </ItemGroup>
 
+    <!--Converts string property NonCultureResourceDirectories to array if present. NonCultureResourceDirectories defines exclusions for the custom cultures.  -->
+    <ItemGroup Condition="'$(NonCultureResourceDirectories)' != ''">
+      <NonCultureResourceDirectory Include="$(NonCultureResourceDirectories)" />
+    </ItemGroup>
+
+    <PropertyGroup Condition="'$(EnableCustomCulture)' == ''">
+      <EnableCustomCulture>false</EnableCustomCulture>
+    </PropertyGroup>
+
     <!--
       Normally, as an optimization, finding dependencies of references marked with ExternallyResolved=true metadata is skipped.
       However, skipping that step breaks binding redirect generation when there are conflicting versions within the externally
@@ -2465,6 +2474,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         FindDependenciesOfExternallyResolvedReferences="$(FindDependenciesOfExternallyResolvedReferences)"
         ContinueOnError="$(ContinueOnError)"
         OutputUnresolvedAssemblyConflicts="$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)"
+        NonCultureResourceDirectories="@(NonCultureResourceDirectory)"
+        EnableCustomCulture="$(EnableCustomCulture)"
         Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!='' or '@(_ExplicitReference)' != ''"
         >
 
@@ -5411,11 +5422,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <!--
         Not using SkipUnchangedFiles="true" by default for backwards compatibility.
         -->
-        
+
     <PropertyGroup>
       <SkipUnchangedFilesOnCopyAlways Condition="'$(SkipUnchangedFilesOnCopyAlways)' == ''">false</SkipUnchangedFilesOnCopyAlways>
     </PropertyGroup>
-        
+
     <Copy
         SourceFiles = "@(_SourceItemsToCopyToOutputDirectoryAlways)"
         DestinationFiles = "@(_SourceItemsToCopyToOutputDirectoryAlways->'$(OutDir)%(TargetPath)')"
@@ -5463,7 +5474,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </Copy>
 
   </Target>
-  
+
   <!--
     ============================================================
                                         _CopyAppConfigFile
diff --git a/src/Tasks/Microsoft.Common.props b/src/Tasks/Microsoft.Common.props
index e322c4a2f1e..be186f628bd 100644
--- a/src/Tasks/Microsoft.Common.props
+++ b/src/Tasks/Microsoft.Common.props
@@ -108,7 +108,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <WMSJSProjectDirectory Condition="'$(WMSJSProjectDirectory)' == ''">JavaScript</WMSJSProjectDirectory>
   </PropertyGroup>
 
-  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualStudioVersion.v*.Common.props" Condition="'$(VisualStudioVersion)' == ''" />
+  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualStudioVersion.v*.Common.props" />
 
   <Import Project="$(CustomAfterMicrosoftCommonProps)" Condition="'$(CustomAfterMicrosoftCommonProps)' != '' and Exists('$(CustomAfterMicrosoftCommonProps)')" />
 
diff --git a/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets b/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
index 1e64f51125c..fe304b229f5 100644
--- a/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
@@ -110,6 +110,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               ResourceFiles="@(EmbeddedResource)"
               RootNamespace="$(RootNamespace)"
               PrependCultureAsDirectory="false"
+              EnableCustomCulture="$(EnableCustomCulture)"
               UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)"
               Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and '%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
             <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
@@ -237,6 +238,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          ChecksumAlgorithm="$(ChecksumAlgorithm)"
          CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)"
          CodePage="$(CodePage)"
+         CompilerType="$(RoslynCompilerType)"
          DebugType="none"
          DefineConstants="$(FinalDefineConstants)"
          DelaySign="$(DelaySign)"
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v11.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v11.Common.props
deleted file mode 100644
index 9ef50e92c14..00000000000
--- a/src/Tasks/Microsoft.VisualStudioVersion.v11.Common.props
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-***********************************************************************************************
-Microsoft.VisualStudio.v11.Common.props
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-Copyright (C) Microsoft Corporation. All rights reserved.
-***********************************************************************************************
--->
-<Project ToolsVersion="4.0">
-
-  <PropertyGroup>
-    <VisualStudioVersion>11.0</VisualStudioVersion>
-    <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
-  </PropertyGroup>
-
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v12.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v12.Common.props
deleted file mode 100644
index 428a5c1d571..00000000000
--- a/src/Tasks/Microsoft.VisualStudioVersion.v12.Common.props
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-***********************************************************************************************
-Microsoft.VisualStudio.v11.Common.props
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-Copyright (C) Microsoft Corporation. All rights reserved.
-***********************************************************************************************
--->
-<Project ToolsVersion="4.0">
-
-  <PropertyGroup>
-    <VisualStudioVersion>12.0</VisualStudioVersion>
-    <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
-  </PropertyGroup>
-
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v14.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v14.Common.props
deleted file mode 100644
index c2e2af3ad8e..00000000000
--- a/src/Tasks/Microsoft.VisualStudioVersion.v14.Common.props
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-***********************************************************************************************
-Microsoft.VisualStudio.v14.Common.props
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-Copyright (C) Microsoft Corporation. All rights reserved.
-***********************************************************************************************
--->
-<Project ToolsVersion="4.0">
-
-  <PropertyGroup>
-    <VisualStudioVersion>14.0</VisualStudioVersion>
-    <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
-  </PropertyGroup>
-
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v15.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v15.Common.props
deleted file mode 100644
index 9d9e0f62d71..00000000000
--- a/src/Tasks/Microsoft.VisualStudioVersion.v15.Common.props
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-***********************************************************************************************
-Microsoft.VisualStudio.v15.Common.props
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-Copyright (C) Microsoft Corporation. All rights reserved.
-***********************************************************************************************
--->
-<Project>
-
-  <PropertyGroup>
-    <VisualStudioVersion>15.0</VisualStudioVersion>
-    <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
-  </PropertyGroup>
-
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v16.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v16.Common.props
deleted file mode 100644
index 1843227e760..00000000000
--- a/src/Tasks/Microsoft.VisualStudioVersion.v16.Common.props
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-***********************************************************************************************
-Microsoft.VisualStudio.v16.Common.props
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-Copyright (C) Microsoft Corporation. All rights reserved.
-***********************************************************************************************
--->
-<Project>
-
-  <PropertyGroup>
-    <VisualStudioVersion>16.0</VisualStudioVersion>
-    <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
-  </PropertyGroup>
-
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/Microsoft.VisualStudioVersion.v17.Common.props b/src/Tasks/Microsoft.VisualStudioVersion.v17.Common.props
deleted file mode 100644
index 94031c33888..00000000000
--- a/src/Tasks/Microsoft.VisualStudioVersion.v17.Common.props
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-***********************************************************************************************
-Microsoft.VisualStudio.v17.Common.props
-
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-Copyright (C) Microsoft Corporation. All rights reserved.
-***********************************************************************************************
--->
-<Project>
-
-  <PropertyGroup>
-    <VisualStudioVersion>17.0</VisualStudioVersion>
-    <VSToolsPath>$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)</VSToolsPath>
-  </PropertyGroup>
-
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index 6a7ae609617..366f0badba0 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -62,6 +62,7 @@ public override bool Execute()
             return ResolveAssemblyKey() && ResolveManifestKey();
         }
 
+#if FEATURE_PFX_SIGNING
         // We we use hash the contens of .pfx file so we can establish relationship file <-> container name, whithout
         // need to prompt for password. Note this is not used for any security reasons. With the departure from standard MD5 algoritm
         // we need as simple hash function for replacement. The data blobs we use (.pfx files)  are
@@ -87,6 +88,7 @@ private static UInt64 HashFromBlob(byte[] data)
             result |= dw2;
             return result;
         }
+#endif
 
         private bool ResolveAssemblyKey()
         {
diff --git a/src/Tasks/StrongNameUtils.cs b/src/Tasks/StrongNameUtils.cs
index 26fce852479..f1aef67e8c0 100644
--- a/src/Tasks/StrongNameUtils.cs
+++ b/src/Tasks/StrongNameUtils.cs
@@ -49,10 +49,8 @@ internal static void ReadKeyFile(TaskLoggingHelper log, string keyFile, out Stro
                     int fileLength = (int)fs.Length;
                     keyFileContents = new byte[fileLength];
 
-#pragma warning disable CA2022 // Avoid inexact read with 'Stream.Read'
                     // TODO: Read the count of read bytes and check if it matches the expected length, if not raise an exception
-                    fs.Read(keyFileContents, 0, fileLength);
-#pragma warning restore CA2022 // Avoid inexact read with 'Stream.Read'
+                    fs.ReadExactly(keyFileContents, 0, fileLength);
                 }
             }
             catch (ArgumentException e)
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index cbb66f13907..0d1dac8f86c 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -171,10 +171,8 @@ public void Translate(ITranslator translator)
                 ErrorUtilities.VerifyThrowArgumentNull(translator);
 
                 translator.Translate(ref lastModified);
-                translator.Translate(ref assemblyName,
-                    (ITranslator t) => new AssemblyNameExtension(t));
-                translator.TranslateArray(ref dependencies,
-                    (ITranslator t) => new AssemblyNameExtension(t));
+                translator.Translate(ref assemblyName, (t) => new AssemblyNameExtension(t));
+                translator.TranslateArray(ref dependencies, (t) => new AssemblyNameExtension(t));
                 translator.Translate(ref scatterFiles);
                 translator.Translate(ref runtimeVersion);
                 translator.Translate(ref frameworkName);
@@ -268,7 +266,7 @@ public override void Translate(ITranslator translator)
             translator.TranslateDictionary(
                 ref (translator.Mode == TranslationDirection.WriteToStream) ? ref instanceLocalOutgoingFileStateCache : ref instanceLocalFileStateCache,
                 StringComparer.OrdinalIgnoreCase,
-                (ITranslator t) => new FileState(t));
+                (t) => new FileState(t));
 
             // IsDirty should be false for either direction. Either this cache was brought
             // up-to-date with the on-disk cache or vice versa. Either way, they agree.
diff --git a/src/Tasks/TaskRequiresFramework.cs b/src/Tasks/TaskRequiresFramework.cs
index cbc3caf0b2f..f29331729e6 100644
--- a/src/Tasks/TaskRequiresFramework.cs
+++ b/src/Tasks/TaskRequiresFramework.cs
@@ -1,6 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#pragma warning disable IDE0052
+
 #if NETFRAMEWORK
 using System;
 #endif
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 90b49a9780b..6130771ccd4 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -2,9 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
 using System.Xml;
 using System.Xml.XPath;
 using System.Xml.Xsl;
@@ -12,6 +10,11 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
+#if FEATURE_COMPILED_XSL
+using System.Collections.Generic;
+using System.Reflection;
+#endif
+
 #nullable disable
 
 namespace Microsoft.Build.Tasks
@@ -495,6 +498,7 @@ public XslCompiledTransform LoadXslt(bool useTrustedSettings)
                 return xslct;
             }
 
+#if FEATURE_COMPILED_XSL
             /// <summary>
             /// Find the type from an assembly and loads it.
             /// </summary>
@@ -528,6 +532,7 @@ private static Type FindType(string assemblyPath, string typeName)
                     throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("XslTransform.MustSpecifyType", assemblyPath));
                 }
             }
+#endif
         }
         #endregion
     }
diff --git a/src/UnitTests.Shared/EngineTestEnvironment.cs b/src/UnitTests.Shared/EngineTestEnvironment.cs
index 9f543926223..6464653bcf9 100644
--- a/src/UnitTests.Shared/EngineTestEnvironment.cs
+++ b/src/UnitTests.Shared/EngineTestEnvironment.cs
@@ -25,9 +25,9 @@ namespace Microsoft.Build.UnitTests
     public partial class TestEnvironment
     {
         // reset the default build manager and the state it might have accumulated from other tests
-#pragma warning disable CA1823 // Avoid unused private fields
+#pragma warning disable CA1823, IDE0052 // Avoid unused private fields
         private object _resetBuildManager = new ResetDefaultBuildManager();
-#pragma warning restore CA1823 // Avoid unused private fields
+#pragma warning restore CA1823, IDE0052 // Avoid unused private fields
 
         private sealed class ResetDefaultBuildManager
         {
diff --git a/src/UnitTests.Shared/TestEnvironment.cs b/src/UnitTests.Shared/TestEnvironment.cs
index 1df70aad6af..39374abd308 100644
--- a/src/UnitTests.Shared/TestEnvironment.cs
+++ b/src/UnitTests.Shared/TestEnvironment.cs
@@ -677,19 +677,16 @@ public override void Revert()
 
     public class TransientTestFile : TransientTestState
     {
-        private readonly bool _createFile;
         private readonly bool _expectedAsOutput;
 
         public TransientTestFile(string extension, bool createFile, bool expectedAsOutput)
         {
-            _createFile = createFile;
             _expectedAsOutput = expectedAsOutput;
             Path = FileUtilities.GetTemporaryFile(null, null, extension, createFile);
         }
 
         public TransientTestFile(string rootPath, string extension, bool createFile, bool expectedAsOutput)
         {
-            _createFile = createFile;
             _expectedAsOutput = expectedAsOutput;
             Path = FileUtilities.GetTemporaryFile(rootPath, null, extension, createFile);
         }
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index a06401e8191..a14605728ea 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -30,7 +30,9 @@ namespace Microsoft.Build.UnitTests
 {
     public sealed class ToolLocationHelper_Tests
     {
+#if FEATURE_CODETASKFACTORY
         private readonly ITestOutputHelper _output;
+#endif
 
 #if USE_MSBUILD_DLL_EXTN
         private const string MSBuildExeName = "MSBuild.dll";
@@ -40,7 +42,9 @@ public sealed class ToolLocationHelper_Tests
 
         public ToolLocationHelper_Tests(ITestOutputHelper output)
         {
+#if FEATURE_CODETASKFACTORY
             _output = output;
+#endif
             ToolLocationHelper.ClearStaticCaches();
         }
 
@@ -2922,7 +2926,6 @@ public class GetPlatformExtensionSDKLocationsTestFixture : IDisposable
         // Path to the fake SDk directory structure created under the temp directory.
         private readonly string _fakeStructureRoot;
         private readonly string _fakeStructureRoot2;
-        private readonly ITestOutputHelper _output;
 
         public GetPlatformExtensionSDKLocationsTestFixture(ITestOutputHelper output)
         {
@@ -2930,8 +2933,6 @@ public GetPlatformExtensionSDKLocationsTestFixture(ITestOutputHelper output)
             getRegistrySubKeyDefaultValue = GetRegistrySubKeyDefaultValue;
 #endif
 
-            _output = output;
-
             _fakeStructureRoot = MakeFakeSDKStructure();
             _fakeStructureRoot2 = MakeFakeSDKStructure2();
         }
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index 1bcad909332..f99b7af9a60 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -1735,9 +1735,7 @@ public void CreateFileDoesntRecordWriteIfNotWrittenTo()
                 var buffer = new byte[10];
                 using (FileStream fs = File.Open(readFile, FileMode.Open, FileAccess.ReadWrite, FileShare.None))
                 {
-#pragma warning disable CA2022
-                    fs.Read(buffer, 0, 10);
-#pragma warning restore CA2022
+                    fs.ReadExactly(buffer, 0, 10);
                 }
 
                 FileTracker.WriteContextTLogs(testDir, tlogRootName);
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index e5a0a89b595..86e032a484b 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -23,7 +23,7 @@
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
 
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
-    <PackageReference Include="System.Collections.Immutable" />
+    <PackageReference Include="System.Collections.Immutable" Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
 
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index d43175b77aa..c1820c060aa 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -508,6 +508,7 @@ void IMetadataContainer.ImportMetadata(IEnumerable<KeyValuePair<string, string>>
             _metadata.SetItems(metadata.Select(kvp => new KeyValuePair<string, string>(kvp.Key, kvp.Value ?? string.Empty)));
         }
 
+#if FEATURE_APPDOMAIN
         private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
         {
             if (_metadata == null)
@@ -526,6 +527,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
 
             return result;
         }
+#endif
 
         private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataLazy()
         {
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index ef175ad916b..c3ac96f1f15 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -9,7 +9,6 @@
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.IO;
-using System.Linq;
 using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -80,7 +79,7 @@ public static class FileTracker
         /// This must be the base system-wide temp path because we use it to filter out I/O of tools outside of our control.
         /// Tools running under the tracker may put temp files in the temp base or in a sub-directory of their choosing.
         /// </remarks>
-        private static readonly string s_tempPath = Path.GetTempPath();
+        private static readonly string s_tempPath = FileUtilities.EnsureTrailingSlash(Path.GetTempPath());
 
         // The short path to temp
         private static readonly string s_tempShortPath = FileUtilities.EnsureTrailingSlash(NativeMethodsShared.GetShortFilePath(s_tempPath).ToUpperInvariant());
@@ -247,12 +246,25 @@ public static bool FileIsExcludedFromDependencies(string fileName)
             // 5. Files under the common ("All Users") Application Data location -- C:\Documents and Settings\All Users\Application Data
             //    on XP and either C:\Users\All Users\Application Data or C:\ProgramData on Vista+
 
-            return FileIsUnderPath(fileName, s_applicationDataPath) ||
-                   FileIsUnderPath(fileName, s_localApplicationDataPath) ||
-                   FileIsUnderPath(fileName, s_localLowApplicationDataPath) ||
-                   FileIsUnderPath(fileName, s_tempShortPath) ||
-                   FileIsUnderPath(fileName, s_tempLongPath) ||
-                   s_commonApplicationDataPaths.Any(p => FileIsUnderPath(fileName, p));
+            if (FileIsUnderNormalizedPath(fileName, s_applicationDataPath) ||
+                FileIsUnderNormalizedPath(fileName, s_localApplicationDataPath) ||
+                FileIsUnderNormalizedPath(fileName, s_localLowApplicationDataPath) ||
+                FileIsUnderNormalizedPath(fileName, s_tempShortPath) ||
+                FileIsUnderNormalizedPath(fileName, s_tempLongPath))
+            {
+                return true;
+            }
+
+            // PERF: Avoid LINQ in this path.
+            foreach (string p in s_commonApplicationDataPaths)
+            {
+                if (FileIsUnderNormalizedPath(fileName, p))
+                {
+                    return true;
+                }
+            }
+
+            return false;
         }
 
         /// <summary>
@@ -266,15 +278,31 @@ public static bool FileIsExcludedFromDependencies(string fileName)
         /// </param>
         public static bool FileIsUnderPath(string fileName, string path)
         {
+            // Ensure that the path has a trailing slash that we are checking under
+            // By default the paths that we check for most often will have, so this will
+            // return fast and not allocate memory in the process
+            return FileIsUnderNormalizedPath(fileName, FileUtilities.EnsureTrailingSlash(path));
+        }
+
+        internal static bool FileIsUnderNormalizedPath(string fileName, string path)
+        {
+            int pathLength = path.Length;
+
+            Debug.Assert(path[pathLength - 1] == Path.DirectorySeparatorChar);
+
             // UNDONE: Get the long file path for the entry
             // This is an incredibly expensive operation. The tracking log
             // as written by CL etc. does not contain short paths
             // fileDirectory = NativeMethods.GetFullLongFilePath(fileDirectory);
 
-            // Ensure that the path has a trailing slash that we are checking under
-            // By default the paths that we check for most often will have, so this will
-            // return fast and not allocate memory in the process
-            path = FileUtilities.EnsureTrailingSlash(path);
+            // quick checks to return early. If our given filename is less than the length of the path, it can't be under it.
+            // Similarly, if the file name doesn't have a path separator
+            // at the index of the last separator in the path, it doesn't match.
+            // Because we have a normalized path below we can check against normal-slash directly.
+            if (fileName.Length < pathLength || fileName[pathLength - 1] != Path.DirectorySeparatorChar)
+            {
+                return false;
+            }
 
             // Is the fileName under the filePath?
             return string.Compare(fileName, 0, path, 0, path.Length, StringComparison.OrdinalIgnoreCase) == 0;
