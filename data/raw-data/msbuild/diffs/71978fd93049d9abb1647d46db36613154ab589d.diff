diff --git a/Directory.Build.props b/Directory.Build.props
index 3da3ed640c0..2cc17a1372f 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -20,7 +20,7 @@
     <DOTNET_INSTALL_DIR Condition="'$(DOTNET_INSTALL_DIR)' == ''">$(RepoRoot).dotnet\</DOTNET_INSTALL_DIR>
 
     <!-- Repository and project URLs (used in nuget packages) -->
-    <RepositoryUrl>https://github.com/microsoft/msbuild</RepositoryUrl>
+    <RepositoryUrl>https://github.com/dotnet/msbuild</RepositoryUrl>
     <PackageProjectUrl>http://go.microsoft.com/fwlink/?LinkId=624683</PackageProjectUrl>
     <PackageIcon>MSBuild-NuGet-Icon.png</PackageIcon>
     <PackageTags>MSBuild</PackageTags>
diff --git a/README.md b/README.md
index 0ca7629c10a..9589de5beba 100644
--- a/README.md
+++ b/README.md
@@ -10,19 +10,19 @@ The current development branch is `main`. Changes in `main` will go into a futur
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=main)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=main)
 
-We have forked for MSBuild 16.9 in the branch [`vs16.9`](https://github.com/Microsoft/msbuild/tree/vs16.9). Changes to that branch need special approval.
+We have forked for MSBuild 16.9 in the branch [`vs16.9`](https://github.com/dotnet/msbuild/tree/vs16.9). Changes to that branch need special approval.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.9)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.9)
 
-MSBuild 16.7 builds from the branch [`vs16.7`](https://github.com/Microsoft/msbuild/tree/vs16.7). Only high-priority bugfixes will be considered for servicing 16.7.
+MSBuild 16.7 builds from the branch [`vs16.7`](https://github.com/dotnet/msbuild/tree/vs16.7). Only high-priority bugfixes will be considered for servicing 16.7.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.7)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.7)
 
-MSBuild 16.4 builds from the branch [`vs16.4`](https://github.com/Microsoft/msbuild/tree/vs16.4). Only high-priority bugfixes will be considered for servicing 16.4.
+MSBuild 16.4 builds from the branch [`vs16.4`](https://github.com/dotnet/msbuild/tree/vs16.4). Only high-priority bugfixes will be considered for servicing 16.4.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.4)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.4)
 
-MSBuild 15.9 builds from the branch [`vs15.9`](https://github.com/Microsoft/msbuild/tree/vs15.9). Only very-high-priority bugfixes will be considered for servicing 15.9.
+MSBuild 15.9 builds from the branch [`vs15.9`](https://github.com/dotnet/msbuild/tree/vs15.9). Only very-high-priority bugfixes will be considered for servicing 15.9.
 
 ## Building
 
@@ -36,12 +36,13 @@ To get started on **Visual Studio 2019**:
   - .NET desktop development
   - .NET Core cross-platform development
 2. Open a `Developer Command Prompt for VS 2019` prompt.
-3. Clone the source code: `git clone https://github.com/Microsoft/msbuild.git`
+3. Clone the source code: `git clone https://github.com/dotnet/msbuild`
   - You may have to [download Git](https://git-scm.com/downloads) first.
 4. Run `.\build.cmd` from the root of the repo to build the code. This also restores packages needed to open the projects in Visual Studio.
 5. Open `MSBuild.sln` or `MSBuild.Dev.slnf` in Visual Studio 2019.
 
 Note: To create a usable MSBuild with your changes, run `.\build.cmd /p:CreateBootstrap=true`.
+To build release, add `-c Release`: `.\build.cmd -c Release /p:CreateBootstrap=true`.
 
 This newly-built MSBuild will be located at `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe`. It may not work for all scenarios, including C++ builds.
 
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index 8f6a76fd036..f5363b9f43f 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -5,8 +5,8 @@ The MSBuild engine doesn't have a notion of a “project reference”—it only
 That's a powerful tool, but no one would want to have to specify how to build every single reference in every single project. The common targets introduce an item, `ProjectReference`, and a default process for building references declared via that item.
 
 Default protocol implementation:
-- https://github.com/Microsoft/msbuild/blob/master/src/Tasks/Microsoft.Common.CurrentVersion.targets
-- https://github.com/Microsoft/msbuild/blob/master/src/Tasks/Microsoft.Common.CrossTargeting.targets
+- https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.CurrentVersion.targets
+- https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.CrossTargeting.targets
 
 ## Projects that have references
 
@@ -73,7 +73,7 @@ If implementing a project with an “outer” (determine what properties to pass
 * `GetTargetPath` should return the path of the project's output, but _not_ build that output.
   * **Conditions**: this is used for builds inside Visual Studio, but not on the command line.
   * It's also used when the property `BuildProjectReferences` is `false`, manually indicating that all `ProjectReferences` are up to date and shouldn't be (re)built.
-  * This should return a single item that is the primary output of the project, with metadata describing that output. See [`TargetPathWithTargetPlatformMoniker`](https://github.com/Microsoft/msbuild/blob/080ef976a428f6ff7bf53ca5dd4ee637b3fe949c/src/Tasks/Microsoft.Common.CurrentVersion.targets#L1834-L1842) for the default metadata.
+  * This should return a single item that is the primary output of the project, with metadata describing that output. See [`TargetPathWithTargetPlatformMoniker`](https://github.com/dotnet/msbuild/blob/080ef976a428f6ff7bf53ca5dd4ee637b3fe949c/src/Tasks/Microsoft.Common.CurrentVersion.targets#L1834-L1842) for the default metadata.
 * **Default** targets should do the full build and return an assembly to be referenced.
   * **Conditions**: this is _not_ called when building inside Visual Studio. Instead, Visual Studio builds each project in isolation but in order, so the path returned from `GetTargetPath` can be assumed to exist at consumption time.
   * If the `ProjectReference` defines the `Targets` metadata, it is used. If not, no target is passed, and the default target of the reference (usually `Build`) is built.
diff --git a/documentation/WhenGlobbingReturnsOriginalFilespec.md b/documentation/WhenGlobbingReturnsOriginalFilespec.md
index 6196c579a95..ac9a74c887f 100644
--- a/documentation/WhenGlobbingReturnsOriginalFilespec.md
+++ b/documentation/WhenGlobbingReturnsOriginalFilespec.md
@@ -6,5 +6,5 @@ Original itemspec is returned when:
 	- a `:` anywhere but the second character
 	- a `..` after a wildcard
 	- a path fragment which contains `**` and other characters (e.g. `/**f/`)
-- Any IO related exception is thrown during file walking: https://github.com/Microsoft/msbuild/blob/c1d949558b4808ca9381d09af384b66b31cde2b2/src/Shared/ExceptionHandling.cs#L125-L140
+- Any IO related exception is thrown during file walking: https://github.com/dotnet/msbuild/blob/c1d949558b4808ca9381d09af384b66b31cde2b2/src/Shared/ExceptionHandling.cs#L125-L140
   - System.UnauthorizedAccessException and System.Security.SecurityException from directory enumeration (Directory.EnumerateFileSystemEntries) are ignored, and the files / directories which cause it are excluded from the results.
diff --git a/documentation/assigning-msb-error-code.md b/documentation/assigning-msb-error-code.md
index f9350a8e627..2801df217ed 100644
--- a/documentation/assigning-msb-error-code.md
+++ b/documentation/assigning-msb-error-code.md
@@ -4,7 +4,7 @@ User-facing errors encountered in MSBuild should have an error code in the form
 
 Errors that should not be user-facing (because they're a result of a problem internal to MSBuild like an `InternalErrorException`) do not need an error code.
 
-This code is defined in the `.resx` file that includes the string representation of the error. For example, [MSB3021 is defined as](https://github.com/Microsoft/msbuild/blob/ea30bf10ad0d7ab37ea54ab9d98fe39a5d97bfb0/src/Tasks/Resources/Strings.resx#L234-L237):
+This code is defined in the `.resx` file that includes the string representation of the error. For example, [MSB3021 is defined as](https://github.com/dotnet/msbuild/blob/ea30bf10ad0d7ab37ea54ab9d98fe39a5d97bfb0/src/Tasks/Resources/Strings.resx#L234-L237):
 
 ```xml
   <data name="Copy.Error">
diff --git a/documentation/specs/static-graph-implementation-details.md b/documentation/specs/static-graph-implementation-details.md
index 4845fff794d..028fb333359 100644
--- a/documentation/specs/static-graph-implementation-details.md
+++ b/documentation/specs/static-graph-implementation-details.md
@@ -17,16 +17,16 @@ The presence of either input or output caches turns on [isolated build constrain
 
 ## Input / Output cache implementation
 <!-- cache structure -->
-The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). 
+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/dotnet/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). 
 
 One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.
 
 <!-- cache lifetime -->
-The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
+The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
 
 <!-- constraints -->
 
-When MSBuild is loading input cache files, it has to merge multiple incoming instances of `ConfigCache` and `ResultsCache` into one instance of each. The [CacheAggregator](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L13) is responsible for stitching together the pairs of deserialized `ConfigCache`/`ResultsCache` entries from each input cache file.
+When MSBuild is loading input cache files, it has to merge multiple incoming instances of `ConfigCache` and `ResultsCache` into one instance of each. The [CacheAggregator](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L13) is responsible for stitching together the pairs of deserialized `ConfigCache`/`ResultsCache` entries from each input cache file.
 The following constraints are enforced during cache aggregation:
 - For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
 - For each input cache, there is exactly one mapping from ConfigCache to ResultsCache (on `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`)
@@ -35,17 +35,17 @@ The following constraints are enforced during cache aggregation:
 The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.
 
 <!-- How input / output cache entries are separated with the override caches -->
-Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache. The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.
+Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache. The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.
 
 ## Isolation implementation
 
-[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the Scheduler and the TaskBuilder. [TaskBuilder.ExecuteInstantiatedTask](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in `ProjectReference`. [Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
+[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the Scheduler and the TaskBuilder. [TaskBuilder.ExecuteInstantiatedTask](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in `ProjectReference`. [Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
 
 ### How isolation exemption complicates everything
 <!-- Potential cache scenarios caused by exemption -->
 Project references [can be exempt](static-graph.md#exempting-references-from-isolation-constraints) from isolation constraints via the `GraphIsolationExemptReference` item.
 
-The `Scheduler` knows to skip isolation constraints on an exempt `BuildRequest` because the [ProjectBuilder compares](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L349) each new `BuildRequest` against the `GraphIsolationExemptReference` items defined in the calling project, and if exempt, sets `BuildRequest.SkipStaticGraphIsolationConstraints`. When a `BuildRequest` is marked as exempt, the `Scheduler` also marks its corresponding `BuildRequestConfiguration` as exempt as well, which aids in further identification of exempt projects outside the `Scheduler`.
+The `Scheduler` knows to skip isolation constraints on an exempt `BuildRequest` because the [ProjectBuilder compares](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L349) each new `BuildRequest` against the `GraphIsolationExemptReference` items defined in the calling project, and if exempt, sets `BuildRequest.SkipStaticGraphIsolationConstraints`. When a `BuildRequest` is marked as exempt, the `Scheduler` also marks its corresponding `BuildRequestConfiguration` as exempt as well, which aids in further identification of exempt projects outside the `Scheduler`.
 
 The build results for the exempt project are also included in the current cache (according to the above mentioned rule that newly built results are serialized in the output cache file). This complicates the way caches interact in several scenarios:
 1. the same project can be exempt via multiple references, thus potentially colliding when multiple output cache files containing the same exempt project get aggregated. For example, given the graph `{A->B, A->C}`, where both `B` and `C` build the exempt project `D`, `D` will appear in the output caches of both `B` and `C`. When `A` aggregates these two caches, it will encounter duplicate entries for `D`, and will need to merge the results.
diff --git a/documentation/wiki/Binary-Log.md b/documentation/wiki/Binary-Log.md
index e1895c63eba..7d3be80a19b 100644
--- a/documentation/wiki/Binary-Log.md
+++ b/documentation/wiki/Binary-Log.md
@@ -74,7 +74,7 @@ After installing that, enable logging and run your build ([more details](https:/
 
 The implementation of the binary logger is here:
 https://source.dot.net/#Microsoft.Build/Logging/BinaryLogger/BinaryLogger.cs
-https://github.com/Microsoft/msbuild/blob/master/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+https://github.com/dotnet/msbuild/blob/main/src/Build/Logging/BinaryLogger/BinaryLogger.cs
 
 It is a `GZipStream`-compressed binary stream of serialized `BuildEventArgs` objects. The event args objects are serialized and deserialized using:
  * https://source.dot.net/#Microsoft.Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -85,7 +85,7 @@ It is a `GZipStream`-compressed binary stream of serialized `BuildEventArgs` obj
 Every .binlog file has the first three bytes that indicate the file version. The current file format version is 9 (`00 00 09`).
 
 When incrementing the file format, keep this in mind:
- * Increment the version and add a summary of the changes: https://github.com/Microsoft/msbuild/blob/master/src/Build/Logging/BinaryLogger/BinaryLogger.cs#L22
+ * Increment the version and add a summary of the changes: https://github.com/dotnet/msbuild/blob/main/src/Build/Logging/BinaryLogger/BinaryLogger.cs#L22
  * In BuildEventArgsWriter.cs, just add fields, etc. without worrying. 
  * In BuildEventArgsReader.cs, add exactly the same changes, but wrapped in an `if`-statement like this: `if (fileFormatVersion > version where the field was introduced)
  * Open an issue over at https://github.com/KirillOsenkov/MSBuildStructuredLog/issues/new so I can adapt the Structured Log Viewer to these changes.
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
index d7d81600bef..114bc177306 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
@@ -10,7 +10,7 @@ All command lines should be executed from a Visual Studio developer command prom
 
 ## Getting the code
 
-1. Clone the repo: `git clone https://github.com/Microsoft/msbuild.git`
+1. Clone the repo: `git clone https://github.com/dotnet/msbuild`
 2. Build on the command line: `.\build.cmd`
    1. If you encounter errors, see [Something's wrong in my build](Something's-wrong-in-my-build.md).
 3. Open the solution file in Visual Studio (`MSBuild.Dev.slnf`).
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 46d1d61b4e5..1e25829f60b 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -25,6 +25,8 @@ The opt-out comes in the form of setting the environment variable `MSBuildDisabl
 - [Don't expand full drive globs with false condition](https://github.com/dotnet/msbuild/pull/5669)
 ### 16.10
 - [Error when a property expansion in a condition has whitespace](https://github.com/dotnet/msbuild/pull/5672)
+- [Allow Custom CopyToOutputDirectory Location With TargetPath](https://github.com/dotnet/msbuild/pull/6237)
+- [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
 ### 17.0
 
 ## Change Waves No Longer In Rotation
diff --git a/documentation/wiki/Interactions-with-the-internal-repository.md b/documentation/wiki/Interactions-with-the-internal-repository.md
index 10b6d96bbb3..a6b0b414114 100644
--- a/documentation/wiki/Interactions-with-the-internal-repository.md
+++ b/documentation/wiki/Interactions-with-the-internal-repository.md
@@ -1,8 +1,8 @@
 MSbuild got forked from an internal Microsoft repository. Although the Github repository is the official one, where development takes place, there are still some left-over connections to the internal one. This page attempts to document these.
 
 Changes to these files need to be migrated back into the internal repo because that's where they are localized:
-- [src/XMakeCommandLine/Microsoft.Build.Core.xsd](https://github.com/Microsoft/msbuild/blob/xplat/src/XMakeCommandLine/Microsoft.Build.Core.xsd)
-- [src/XMakeCommandLine/Microsoft.Build.CommonTypes.xsd](https://github.com/Microsoft/msbuild/blob/xplat/src/XMakeCommandLine/Microsoft.Build.CommonTypes.xsd)
+- [src/XMakeCommandLine/Microsoft.Build.Core.xsd](https://github.com/dotnet/msbuild/blob/main/src/XMakeCommandLine/Microsoft.Build.Core.xsd)
+- [src/XMakeCommandLine/Microsoft.Build.CommonTypes.xsd](https://github.com/dotnet/msbuild/blob/main/src/XMakeCommandLine/Microsoft.Build.CommonTypes.xsd)
 
 There should be no changes to the following files. They are shipped from the internal repo. The github ones are stale.
-- [all XamlRules](https://github.com/Microsoft/msbuild/tree/xplat/src/XMakeTasks/XamlRules)
\ No newline at end of file
+- [all XamlRules](https://github.com/dotnet/msbuild/tree/main/src/XMakeTasks/XamlRules)
\ No newline at end of file
diff --git a/documentation/wiki/ResolveAssemblyReference.md b/documentation/wiki/ResolveAssemblyReference.md
index cd0e51172b3..16a7bd65ad2 100644
--- a/documentation/wiki/ResolveAssemblyReference.md
+++ b/documentation/wiki/ResolveAssemblyReference.md
@@ -107,7 +107,7 @@ References can also have the `CopyLocal` metadata or not. If the reference has `
 If the CopyLocal metadata is missing entirely, it is assumed to be true by default. So RAR by default tries to copy dependencies to output unless it finds a reason not to. RAR is quite detailed about the reasons why it chose a particular reference to be CopyLocal or not.
 
 All possible reasons for CopyLocal decision are enumerated here:
-https://github.com/Microsoft/msbuild/blob/master/src/Tasks/AssemblyDependency/CopyLocalState.cs
+https://github.com/dotnet/msbuild/blob/main/src/Tasks/AssemblyDependency/CopyLocalState.cs
 It is useful to know these strings to be able to search for them in build logs.
 
 ## Private item metadata
@@ -118,7 +118,7 @@ An important part of determining CopyLocal is the Private metadata on all primar
  3. If none of the source assemblies specify `Private=true` and at least one specifies `Private=false`, `CopyLocal` is set to `False`
 
 Here's the source code:
-https://github.com/Microsoft/msbuild/blob/master/src/Tasks/AssemblyDependency/Reference.cs#L1243
+https://github.com/dotnet/msbuild/blob/main/src/Tasks/AssemblyDependency/Reference.cs#L1243
 
 ## Which reference set Private to false?
 
diff --git a/documentation/wiki/Something's-wrong-in-my-build.md b/documentation/wiki/Something's-wrong-in-my-build.md
index 9b5603d5af4..c9073d37e9c 100644
--- a/documentation/wiki/Something's-wrong-in-my-build.md
+++ b/documentation/wiki/Something's-wrong-in-my-build.md
@@ -27,8 +27,8 @@ First, verify the `global.json` file in your repository is using a preview versi
 ![](https://user-images.githubusercontent.com/3347530/59614580-a795c900-90e6-11e9-8981-0fdbd08d42bd.png)
 
 ## Tools
-Many debugging tools listed [here](https://github.com/Microsoft/msbuild/blob/master/documentation/wiki/MSBuild-Resources.md#tools).
+Many debugging tools listed [here](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/MSBuild-Resources.md#tools).
 
 [MSBuildStructuredLog](https://github.com/KirillOsenkov/MSBuildStructuredLog) can be used to get a clearer idea of what's going on in your build. MSBuildStructuredLog is graphical interface over MSBuild binary logs that visualizes a structured representation of executed targets, tasks, properties, and item values. It can be easier to look though than the diagnostic log.
 
-![](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/Screenshot1.png)
+![](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/Screenshot1.png)
diff --git a/documentation/wiki/UnGAC.md b/documentation/wiki/UnGAC.md
index 79f7a3ddc77..e0d45d729ee 100644
--- a/documentation/wiki/UnGAC.md
+++ b/documentation/wiki/UnGAC.md
@@ -7,7 +7,7 @@ See the [public documentation](https://docs.microsoft.com/dotnet/framework/app-d
 The only MSBuild assemblies you may see in the GAC are version 4.8. There is no reason any modern (15.1+) MSBuild assembly should be in the GAC today.
 
 ## What MSBuild Assemblies are installed on my Machine?
-Run the [EnumerateMSBuild powershell script](https://github.com/Microsoft/msbuild/blob/master/scripts/EnumerateMSBuild.ps1) from our repo. It will output a `msbuild_versions.txt` file that lists MSBuild assemblies in their common folders along with their versions.
+Run the [EnumerateMSBuild powershell script](https://github.com/dotnet/msbuild/blob/main/scripts/EnumerateMSBuild.ps1) from our repo. It will output a `msbuild_versions.txt` file that lists MSBuild assemblies in their common folders along with their versions.
 
 ## How to Remove MSBuild Assemblies from the GAC
 1. If on Visual Studio 16.8 or higher, repair your installation.
diff --git a/eng/Packages.props b/eng/Packages.props
index 97f340790f5..91058315eaa 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -2,7 +2,7 @@
   <ItemGroup>
     <PackageReference Update="BenchmarkDotNet" Version="0.12.1" />
     <PackageReference Update="jnm2.ReferenceAssemblies.net35" Version="1.0.1" />
-    <PackageReference Update="LargeAddressAware" Version="1.0.3" />
+    <PackageReference Update="LargeAddressAware" Version="1.0.5" />
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.DotNet.GenAPI" Version="2.1.0-prerelease-02404-02" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index b1cd6f1c918..13d8260275b 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -5,9 +5,9 @@
       <Uri>https://github.com/dotnet/arcade</Uri>
       <Sha>670382be6a978ba401c21c57ba44311199d2682a</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="5.9.0-rc.7122">
-      <Uri>https://dev.azure.com/devdiv/DevDiv/_git/NuGet-NuGet.Client-Trusted</Uri>
-      <Sha>abf0ba0638070af16427cea69bd47a9945fd5d7a</Sha>
+    <Dependency Name="NuGet.Build.Tasks" Version="5.9.1-rc.8">
+      <Uri>https://github.com/nuget/nuget.client</Uri>
+      <Sha>d525b0e670f3b6cbd5c73a35f04730a9f658c852</Sha>
     </Dependency>
     <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="3.9.0-2.20574.26">
       <Uri>https://github.com/dotnet/roslyn</Uri>
diff --git a/eng/Versions.props b/eng/Versions.props
index 91c428912ff..2a1789bd837 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -27,7 +27,7 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>5.0.102</DotNetCliVersion>
     <MicrosoftNetCompilersToolsetVersion>3.9.0-2.20574.26</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>5.9.0-rc.7122</NuGetBuildTasksVersion>
+    <NuGetBuildTasksVersion>5.9.1-rc.8</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index 8fb7f590527..6e22aacb0d3 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -53,6 +53,7 @@ $RepoRoot = [System.IO.Path]::GetFullPath($RepoRoot).TrimEnd($([System.IO.Path]:
 $ArtifactsDir = Join-Path $RepoRoot "artifacts"
 $Stage1Dir = Join-Path $RepoRoot "stage1"
 $Stage1BinDir = Join-Path $Stage1Dir "bin"
+$PerfLogDir = Join-Path $ArtifactsDir "log\$Configuration\PerformanceLogs"
 
 if ($msbuildEngine -eq '')
 {
@@ -123,6 +124,9 @@ try {
   # Ensure that debug bits fail fast, rather than hanging waiting for a debugger attach.
   $env:MSBUILDDONOTLAUNCHDEBUGGER="true"
 
+  # Opt into performance logging. https://github.com/dotnet/msbuild/issues/5900
+  $env:DOTNET_PERFLOG_DIR=$PerfLogDir
+
   # When using bootstrapped MSBuild:
   # - Turn off node reuse (so that bootstrapped MSBuild processes don't stay running and lock files)
   # - Do run tests
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index 23987f994d9..26fe13a7c82 100755
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -39,6 +39,7 @@ done
 RepoRoot="$ScriptRoot/.."
 ArtifactsDir="$RepoRoot/artifacts"
 Stage1Dir="$RepoRoot/stage1"
+PerfLogDir="$ArtifactsDir/log/$configuration/PerformanceLogs"
 
 . "$ScriptRoot/common/tools.sh"
 InitializeDotNetCli true
@@ -86,6 +87,9 @@ mv $ArtifactsDir $Stage1Dir
 # Ensure that debug bits fail fast, rather than hanging waiting for a debugger attach.
 export MSBUILDDONOTLAUNCHDEBUGGER=true
 
+# Opt into performance logging.
+export DOTNET_PERFLOG_DIR=$PerfLogDir
+
 # Prior to 3.0, the Csc task uses this environment variable to decide whether to run
 # a CLI host or directly execute the compiler.
 export DOTNET_HOST_PATH="$_InitializeDotNetCli/dotnet"
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index 1318a437f92..00db63a067d 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -38,7 +38,7 @@ protected BuildEventArgs(string message, string helpKeyword, string senderName,
         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } }
         public virtual string Message { get { throw null; } protected set { } }
-        protected System.DateTime RawTimestamp { get { throw null; } set { } }
+        protected internal System.DateTime RawTimestamp { get { throw null; } set { } }
         public string SenderName { get { throw null; } }
         public int ThreadId { get { throw null; } }
         public System.DateTime Timestamp { get { throw null; } }
@@ -258,6 +258,10 @@ public partial interface IEventSource3 : Microsoft.Build.Framework.IEventSource,
         void IncludeEvaluationProfiles();
         void IncludeTaskInputs();
     }
+    public partial interface IEventSource4 : Microsoft.Build.Framework.IEventSource, Microsoft.Build.Framework.IEventSource2, Microsoft.Build.Framework.IEventSource3
+    {
+        void IncludeEvaluationPropertiesAndItems();
+    }
     public partial interface IForwardingLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
     {
         Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get; set; }
@@ -387,8 +391,11 @@ public sealed partial class ProjectEvaluationFinishedEventArgs : Microsoft.Build
     {
         public ProjectEvaluationFinishedEventArgs() { }
         public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) { }
+        public System.Collections.IEnumerable GlobalProperties { get { throw null; } set { } }
+        public System.Collections.IEnumerable Items { get { throw null; } set { } }
         public Microsoft.Build.Framework.Profiler.ProfilerResult? ProfilerResult { get { throw null; } set { } }
         public string ProjectFile { get { throw null; } set { } }
+        public System.Collections.IEnumerable Properties { get { throw null; } set { } }
     }
     public partial class ProjectEvaluationStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index 9d3b8a4e277..7b0fbb39d15 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -38,7 +38,7 @@ protected BuildEventArgs(string message, string helpKeyword, string senderName,
         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } }
         public virtual string Message { get { throw null; } protected set { } }
-        protected System.DateTime RawTimestamp { get { throw null; } set { } }
+        protected internal System.DateTime RawTimestamp { get { throw null; } set { } }
         public string SenderName { get { throw null; } }
         public int ThreadId { get { throw null; } }
         public System.DateTime Timestamp { get { throw null; } }
@@ -258,6 +258,10 @@ public partial interface IEventSource3 : Microsoft.Build.Framework.IEventSource,
         void IncludeEvaluationProfiles();
         void IncludeTaskInputs();
     }
+    public partial interface IEventSource4 : Microsoft.Build.Framework.IEventSource, Microsoft.Build.Framework.IEventSource2, Microsoft.Build.Framework.IEventSource3
+    {
+        void IncludeEvaluationPropertiesAndItems();
+    }
     public partial interface IForwardingLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
     {
         Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get; set; }
@@ -386,8 +390,11 @@ public sealed partial class ProjectEvaluationFinishedEventArgs : Microsoft.Build
     {
         public ProjectEvaluationFinishedEventArgs() { }
         public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) { }
+        public System.Collections.IEnumerable GlobalProperties { get { throw null; } set { } }
+        public System.Collections.IEnumerable Items { get { throw null; } set { } }
         public Microsoft.Build.Framework.Profiler.ProfilerResult? ProfilerResult { get { throw null; } set { } }
         public string ProjectFile { get { throw null; } set { } }
+        public System.Collections.IEnumerable Properties { get { throw null; } set { } }
     }
     public partial class ProjectEvaluationStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
diff --git a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
index 4491f300e5c..e435979d2b2 100644
--- a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
@@ -227,6 +227,7 @@ public partial class MuxLogger : Microsoft.Build.Framework.ILogger, Microsoft.Bu
         public MuxLogger() { }
         public bool IncludeEvaluationMetaprojects { get { throw null; } set { } }
         public bool IncludeEvaluationProfiles { get { throw null; } set { } }
+        public bool IncludeEvaluationPropertiesAndItems { get { throw null; } set { } }
         public bool IncludeTaskInputs { get { throw null; } set { } }
         public string Parameters { get { throw null; } set { } }
         public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
diff --git a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
index f0ad18e1545..d77c4295057 100644
--- a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
@@ -72,6 +72,7 @@ public partial class MuxLogger : Microsoft.Build.Framework.ILogger, Microsoft.Bu
         public MuxLogger() { }
         public bool IncludeEvaluationMetaprojects { get { throw null; } set { } }
         public bool IncludeEvaluationProfiles { get { throw null; } set { } }
+        public bool IncludeEvaluationPropertiesAndItems { get { throw null; } set { } }
         public bool IncludeTaskInputs { get { throw null; } set { } }
         public string Parameters { get { throw null; } set { } }
         public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index df63aa205be..53c843c112a 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -772,6 +772,7 @@ public enum ProjectLoadSettings
         DoNotEvaluateElementsWithFalseCondition = 32,
         IgnoreInvalidImports = 64,
         ProfileEvaluation = 128,
+        FailOnUnresolvedSdk = 256,
     }
     public partial class ProjectMetadata : System.IEquatable<Microsoft.Build.Evaluation.ProjectMetadata>
     {
@@ -1047,6 +1048,8 @@ public enum BuildRequestDataFlags
         SkipNonexistentTargets = 16,
         ProvideSubsetOfStateAfterBuild = 32,
         IgnoreMissingEmptyAndInvalidImports = 64,
+        SkipNonexistentNonEntryTargets = 128,
+        FailOnUnresolvedSdk = 256,
     }
     public partial class BuildResult
     {
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index 2e945e6c024..b1f8429b5cb 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -772,6 +772,7 @@ public enum ProjectLoadSettings
         DoNotEvaluateElementsWithFalseCondition = 32,
         IgnoreInvalidImports = 64,
         ProfileEvaluation = 128,
+        FailOnUnresolvedSdk = 256,
     }
     public partial class ProjectMetadata : System.IEquatable<Microsoft.Build.Evaluation.ProjectMetadata>
     {
@@ -1042,6 +1043,8 @@ public enum BuildRequestDataFlags
         SkipNonexistentTargets = 16,
         ProvideSubsetOfStateAfterBuild = 32,
         IgnoreMissingEmptyAndInvalidImports = 64,
+        SkipNonexistentNonEntryTargets = 128,
+        FailOnUnresolvedSdk = 256,
     }
     public partial class BuildResult
     {
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index 5409a6f3822..4b1857121e1 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
@@ -203,6 +204,16 @@ public bool IncludeEvaluationProfile
             set { }
         }
 
+        /// <summary>
+        /// Log properties and items on ProjectEvaluationFinishedEventArgs
+        /// instead of ProjectStartedEventArgs.
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems
+        {
+            get => false;
+            set { }
+        }
+
         /// <summary>
         /// Should task events include task inputs?
         /// </summary>
@@ -459,7 +470,13 @@ public void LogProjectEvaluationStarted(BuildEventContext eventContext, string p
         /// <summary>
         /// Logs a project evaluation finished event
         /// </summary>
-        public void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile)
+        public void LogProjectEvaluationFinished(
+            BuildEventContext projectEvaluationEventContext,
+            string projectFile,
+            IEnumerable globalProperties,
+            IEnumerable properties,
+            IEnumerable items,
+            ProfilerResult? profilerResult)
         {
         }
 
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 3e860fc7d5f..a3137f5b399 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
@@ -32,6 +33,7 @@ public void LogMessageConstructorNullBuildEvent()
             }
            );
         }
+
         /// <summary>
         /// Verify when creating a LogMessagePacket
         /// that the correct Event Type is set.
@@ -53,6 +55,8 @@ public void VerifyEventType()
             ProjectStartedEventArgs projectStarted = new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null);
             ProjectFinishedEventArgs projectFinished = new ProjectFinishedEventArgs("message", "help", "ProjectFile", true);
             ExternalProjectStartedEventArgs externalStartedEvent = new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames");
+            ProjectEvaluationStartedEventArgs evaluationStarted = new ProjectEvaluationStartedEventArgs();
+            ProjectEvaluationFinishedEventArgs evaluationFinished = new ProjectEvaluationFinishedEventArgs();
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -67,16 +71,87 @@ public void VerifyEventType()
             VerifyLoggingPacket(targetFinished, LoggingEventType.TargetFinishedEvent);
             VerifyLoggingPacket(projectStarted, LoggingEventType.ProjectStartedEvent);
             VerifyLoggingPacket(projectFinished, LoggingEventType.ProjectFinishedEvent);
+            VerifyLoggingPacket(evaluationStarted, LoggingEventType.ProjectEvaluationStartedEvent);
+            VerifyLoggingPacket(evaluationFinished, LoggingEventType.ProjectEvaluationFinishedEvent);
             VerifyLoggingPacket(externalStartedEvent, LoggingEventType.CustomEvent);
         }
 
-        private static TaskParameterEventArgs CreateTaskParameter()
+        private static BuildEventContext CreateBuildEventContext()
+        {
+            return new BuildEventContext(1, 2, 3, 4, 5, 6, 7);
+        }
+
+        private static ProjectEvaluationStartedEventArgs CreateProjectEvaluationStarted()
+        {
+            string projectFile = "test.csproj";
+            var result = new ProjectEvaluationStartedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationStarted"),
+                projectFile)
+            {
+                ProjectFile = projectFile
+            };
+            result.BuildEventContext = CreateBuildEventContext();
+
+            return result;
+        }
+
+        private static ProjectEvaluationFinishedEventArgs CreateProjectEvaluationFinished()
+        {
+            string projectFile = "test.csproj";
+            var result = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"),
+                projectFile)
+            {
+                ProjectFile = projectFile,
+                GlobalProperties = CreateProperties(),
+                Properties = CreateProperties(),
+                Items = new ArrayList
+                {
+                    new DictionaryEntry("Compile", new TaskItemData("a", null)),
+                    new DictionaryEntry("Compile", new TaskItemData("b", CreateStringDictionary())),
+                    new DictionaryEntry("Reference", new TaskItemData("c", CreateStringDictionary())),
+                }
+            };
+            result.BuildEventContext = CreateBuildEventContext();
+
+            return result;
+        }
+
+        private static IEnumerable CreateProperties()
+        {
+            return new ArrayList
+            {
+                new DictionaryEntry("a", "b"),
+                new DictionaryEntry("c", "d")
+            };
+        }
+
+        private static Dictionary<string, string> CreateStringDictionary()
+        {
+            return new Dictionary<string, string>
+            {
+                { "a", "b" },
+                { "c", "d" }
+            };
+        }
+
+        private static TaskItemData[] CreateTaskItems()
         {
             var items = new TaskItemData[]
             {
                 new TaskItemData("ItemSpec1", null),
-                new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
+                new TaskItemData("ItemSpec1", CreateStringDictionary()),
+                new TaskItemData("ItemSpec2", Enumerable.Range(1, 3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
             };
+            return items;
+        }
+
+        private static TaskParameterEventArgs CreateTaskParameter()
+        {
+            // touch ItemGroupLoggingHelper to ensure static constructor runs
+            _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
+
+            var items = CreateTaskItems();
             var result = new TaskParameterEventArgs(
                 TaskParameterMessageKind.TaskInput,
                 "ItemName",
@@ -88,6 +163,9 @@ private static TaskParameterEventArgs CreateTaskParameter()
             Assert.Equal(@"Task Parameter:
     ItemName=
         ItemSpec1
+        ItemSpec1
+                a=b
+                c=d
         ItemSpec2
                 1=1value
                 2=2value
@@ -127,7 +205,9 @@ public void TestTranslation()
                     new TargetFinishedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile", true, targetOutputs),
                     new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null),
                     new ProjectFinishedEventArgs("message", "help", "ProjectFile", true),
-                    new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames")
+                    new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames"),
+                    CreateProjectEvaluationStarted(),
+                    CreateProjectEvaluationFinished()
                 };
 
                 foreach (BuildEventArgs arg in testArgs)
@@ -283,6 +363,32 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     // Assert.AreEqual(leftProjectStarted.Properties, rightProjectStarted.Properties);
                     break;
 
+                case LoggingEventType.ProjectEvaluationStartedEvent:
+                    ProjectEvaluationStartedEventArgs leftEvaluationStarted = left.NodeBuildEvent.Value.Value as ProjectEvaluationStartedEventArgs;
+                    ProjectEvaluationStartedEventArgs rightEvaluationStarted = right.NodeBuildEvent.Value.Value as ProjectEvaluationStartedEventArgs;
+                    Assert.NotNull(leftEvaluationStarted);
+                    Assert.NotNull(rightEvaluationStarted);
+                    Assert.Equal(leftEvaluationStarted.ProjectFile, rightEvaluationStarted.ProjectFile);
+                    break;
+
+                case LoggingEventType.ProjectEvaluationFinishedEvent:
+                    ProjectEvaluationFinishedEventArgs leftEvaluationFinished = left.NodeBuildEvent.Value.Value as ProjectEvaluationFinishedEventArgs;
+                    ProjectEvaluationFinishedEventArgs rightEvaluationFinished = right.NodeBuildEvent.Value.Value as ProjectEvaluationFinishedEventArgs;
+                    Assert.NotNull(leftEvaluationFinished);
+                    Assert.NotNull(rightEvaluationFinished);
+                    Assert.Equal(leftEvaluationFinished.ProjectFile, rightEvaluationFinished.ProjectFile);
+                    Assert.Equal(leftEvaluationFinished.ProfilerResult, rightEvaluationFinished.ProfilerResult);
+                    Assert.Equal(
+                        TranslationHelpers.GetPropertiesString(leftEvaluationFinished.GlobalProperties),
+                        TranslationHelpers.GetPropertiesString(rightEvaluationFinished.GlobalProperties));
+                    Assert.Equal(
+                        TranslationHelpers.GetPropertiesString(leftEvaluationFinished.Properties),
+                        TranslationHelpers.GetPropertiesString(rightEvaluationFinished.Properties));
+                    Assert.Equal(
+                        TranslationHelpers.GetMultiItemsString(leftEvaluationFinished.Items),
+                        TranslationHelpers.GetMultiItemsString(rightEvaluationFinished.Items));
+                    break;
+
                 case LoggingEventType.TargetFinishedEvent:
                     TargetFinishedEventArgs leftTargetFinished = left.NodeBuildEvent.Value.Value as TargetFinishedEventArgs;
                     TargetFinishedEventArgs rightTargetFinished = right.NodeBuildEvent.Value.Value as TargetFinishedEventArgs;
@@ -292,6 +398,8 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftTargetFinished.Succeeded, rightTargetFinished.Succeeded);
                     Assert.Equal(leftTargetFinished.TargetFile, rightTargetFinished.TargetFile);
                     Assert.Equal(leftTargetFinished.TargetName, rightTargetFinished.TargetName);
+                    //TODO: target output translation is a special case and is done in TranslateTargetFinishedEvent
+                    //Assert.Equal(leftTargetFinished.TargetOutputs, rightTargetFinished.TargetOutputs);
                     break;
 
                 case LoggingEventType.TargetStartedEvent:
diff --git a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
index aaf86e1ad25..a4f5a3c09e5 100644
--- a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
+++ b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
@@ -2,10 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
 using System.IO;
+using System.Text;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -104,5 +107,64 @@ internal static bool CompareExceptions(Exception left, Exception right)
 
             return CompareExceptions(left.InnerException, right.InnerException);
         }
+
+        internal static string GetPropertiesString(IEnumerable properties)
+        {
+            var dictionary = properties
+                .OfType<DictionaryEntry>()
+                .ToDictionary(
+                    (Func<DictionaryEntry, string>)(d => d.Key.ToString()),
+                    (Func<DictionaryEntry, string>)(d => d.Value.ToString()));
+            return ToString(dictionary);
+        }
+
+        internal static string GetMultiItemsString(IEnumerable items)
+        {
+            var list = items
+                .OfType<DictionaryEntry>()
+                .Select(i => i.Key.ToString() + GetTaskItemString(i.Value));
+            var text = string.Join("\n", list);
+            return text;
+        }
+
+        internal static string GetItemsString(IEnumerable items)
+        {
+            var list = items
+                .OfType<object>()
+                .Select(i => GetTaskItemString(i));
+            var text = string.Join("\n", list);
+            return text;
+        }
+
+        internal static string GetTaskItemString(object item)
+        {
+            var sb = new StringBuilder();
+
+            if (item is ITaskItem taskItem)
+            {
+                sb.Append(taskItem.ItemSpec);
+                foreach (string name in taskItem.MetadataNames)
+                {
+                    var value = taskItem.GetMetadata(name);
+                    sb.Append($";{name}={value}");
+                }
+            }
+            else
+            {
+                sb.Append(Convert.ToString(item));
+            }
+
+            return sb.ToString();
+        }
+
+        internal static string ToString(IDictionary<string, string> dictionary)
+        {
+            if (dictionary == null)
+            {
+                return "null";
+            }
+
+            return string.Join(";", dictionary.Select(kvp => kvp.Key + "=" + kvp.Value));
+        }
     }
 }
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index a2874d96c06..16b4cb0e035 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -8,6 +8,8 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Logging;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -34,7 +36,7 @@ public void RoundtripBuildStartedEventArgs()
                     { "SampleName", "SampleValue" }
                 });
             Roundtrip(args,
-                e => ToString(e.BuildEnvironment),
+                e => TranslationHelpers.ToString(e.BuildEnvironment),
                 e => e.HelpKeyword,
                 e => e.ThreadId.ToString(),
                 e => e.SenderName);
@@ -73,37 +75,19 @@ public void RoundtripProjectStartedEventArgs()
 
             Roundtrip<ProjectStartedEventArgs>(args,
                 e => ToString(e.BuildEventContext),
-                e => ToString(e.GlobalProperties),
-                e => GetItemsString(e.Items),
+                e => TranslationHelpers.GetPropertiesString(e.GlobalProperties),
+                e => TranslationHelpers.GetMultiItemsString(e.Items),
                 e => e.Message,
                 e => ToString(e.ParentProjectBuildEventContext),
                 e => e.ProjectFile,
                 e => e.ProjectId.ToString(),
-                e => ToString(e.Properties.OfType<DictionaryEntry>().ToDictionary((Func<DictionaryEntry, string>)(d => d.Key.ToString()), (Func<DictionaryEntry, string>)(d => d.Value.ToString()))),
+                e => TranslationHelpers.GetPropertiesString(e.Properties),
                 e => e.TargetNames,
                 e => e.ThreadId.ToString(),
                 e => e.Timestamp.ToString(),
                 e => e.ToolsVersion);
         }
 
-        private string GetItemsString(IEnumerable items)
-        {
-            return ToString(items.OfType<DictionaryEntry>().ToDictionary(d => d.Key.ToString(), d => GetTaskItemString((ITaskItem)d.Value)));
-        }
-
-        private string GetTaskItemString(ITaskItem taskItem)
-        {
-            var sb = new StringBuilder();
-            sb.Append(taskItem.ItemSpec);
-            foreach (string name in taskItem.MetadataNames)
-            {
-                var value = taskItem.GetMetadata(name);
-                sb.Append($";{name}={value}");
-            }
-
-            return sb.ToString();
-        }
-
         [Fact]
         public void RoundtripProjectFinishedEventArgs()
         {
@@ -331,7 +315,7 @@ public void RoundtripTaskCommandLineEventArgs()
         [Fact]
         public void RoundtripTaskParameterEventArgs()
         {
-            var items = new TaskItemData[]
+            var items = new ITaskItem[]
             {
                 new TaskItemData("ItemSpec1", null),
                 new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
@@ -342,16 +326,19 @@ public void RoundtripTaskParameterEventArgs()
                 e => e.Kind.ToString(),
                 e => e.ItemType,
                 e => e.LogItemMetadata.ToString(),
-                e => GetItemsString(e.Items));
+                e => TranslationHelpers.GetItemsString(e.Items));
         }
 
         [Fact]
         public void RoundtripProjectEvaluationStartedEventArgs()
         {
-            var args = new ProjectEvaluationStartedEventArgs("Message")
+            var projectFile = @"C:\foo\bar.proj";
+            var args = new ProjectEvaluationStartedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationStarted"),
+                projectFile)
             {
                 BuildEventContext = BuildEventContext.Invalid,
-                ProjectFile = @"C:\foo\bar.proj",
+                ProjectFile = projectFile,
             };
 
             Roundtrip(args,
@@ -362,21 +349,33 @@ public void RoundtripProjectEvaluationStartedEventArgs()
         [Fact]
         public void RoundtripProjectEvaluationFinishedEventArgs()
         {
-            var args = new ProjectEvaluationFinishedEventArgs("Message")
+            var projectFile = @"C:\foo\bar.proj";
+            var args = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"),
+                projectFile)
             {
                 BuildEventContext = BuildEventContext.Invalid,
                 ProjectFile = @"C:\foo\bar.proj",
+                GlobalProperties = new Dictionary<string, string>() { { "GlobalKey", "GlobalValue" } },
+                Properties = new List<DictionaryEntry>() { new DictionaryEntry("Key", "Value") },
+                Items = new List<DictionaryEntry>() { new DictionaryEntry("Key", new MyTaskItem() { ItemSpec = "TestItemSpec" }) }
             };
 
             Roundtrip(args,
                 e => e.Message,
-                e => e.ProjectFile);
+                e => e.ProjectFile,
+                e => TranslationHelpers.GetPropertiesString(e.GlobalProperties),
+                e => TranslationHelpers.GetPropertiesString(e.Properties),
+                e => TranslationHelpers.GetMultiItemsString(e.Items));
         }
 
         [Fact]
         public void RoundtripProjectEvaluationFinishedEventArgsWithProfileData()
         {
-            var args = new ProjectEvaluationFinishedEventArgs("Message")
+            var projectFile = @"C:\foo\bar.proj";
+            var args = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"),
+                projectFile)
             {
                 BuildEventContext = BuildEventContext.Invalid,
                 ProjectFile = @"C:\foo\bar.proj",
@@ -560,16 +559,6 @@ private string ToString(BuildEventContext context)
             return $"{context.BuildRequestId} {context.NodeId} {context.ProjectContextId} {context.ProjectInstanceId} {context.SubmissionId} {context.TargetId} {context.TaskId}";
         }
 
-        private string ToString(IDictionary<string, string> dictionary)
-        {
-            if (dictionary == null)
-            {
-                return "null";
-            }
-
-            return string.Join(";", dictionary.Select(kvp => kvp.Key + "=" + kvp.Value));
-        }
-
         private string ToString(IEnumerable<ITaskItem> items)
         {
             return string.Join(";", items.Select(i => ToString(i)));
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 0457c2005f2..31c8209404d 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -254,7 +254,6 @@ public void ErrorMessage()
 
             pc.Collection.RegisterLogger(logger);
 
-
             var p = pc.Collection.LoadProject(project.ProjectFile);
 
             BuildManager.DefaultBuildManager.Build(
@@ -266,13 +265,20 @@ public void ErrorMessage()
             sc.ToString().ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + ":: Number=2]");
         }
 
-        [Fact]
-        public void ErrorMessageWithMultiplePropertiesInMessage()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ErrorMessageWithMultiplePropertiesInMessage(bool includeEvaluationPropertiesAndItems)
         {
             using var env = TestEnvironment.Create(_output);
 
             var pc = env.CreateProjectCollection();
 
+            if (includeEvaluationPropertiesAndItems)
+            {
+                pc.Collection.LoggingService.IncludeEvaluationPropertiesAndItems = true;
+            }
+
             var project = env.CreateTestProjectWithFiles(@"
          <Project>
             <PropertyGroup>
@@ -300,7 +306,6 @@ public void ErrorMessageWithMultiplePropertiesInMessage()
 
             pc.Collection.RegisterLogger(logger);
 
-
             var p = pc.Collection.LoadProject(project.ProjectFile);
 
             BuildManager.DefaultBuildManager.Build(
@@ -308,8 +313,9 @@ public void ErrorMessageWithMultiplePropertiesInMessage()
                 new BuildRequestData(p.CreateProjectInstance(), new[] { "Spawn" }));
 
             p.Build().ShouldBeFalse();
-            sc.ToString().ShouldContain("source_of_error : error : Hello from project 1 [" + project.ProjectFile + ":: Number=1 TargetFramework=netcoreapp2.1]");
-            sc.ToString().ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + ":: Number=2 TargetFramework=netcoreapp2.1]");
+            string output = sc.ToString();
+            output.ShouldContain("source_of_error : error : Hello from project 1 [" + project.ProjectFile + ":: Number=1 TargetFramework=netcoreapp2.1]");
+            output.ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + ":: Number=2 TargetFramework=netcoreapp2.1]");
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 38ee432877a..5d536380d86 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -152,9 +152,11 @@ public void SolutionFilterFiltersProjects()
                     @"
                 {
                   ""solution"": {
+                    // I'm a comment
                     ""path"": "".\\SimpleProject\\SimpleProject.sln"",
                     ""projects"": [
-                      ""SimpleProject\\SimpleProject.csproj""
+                    /* ""..\\ClassLibrary\\ClassLibrary\\ClassLibrary.csproj"", */
+                      ""SimpleProject\\SimpleProject.csproj"",
                     ]
                     }
                 }
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 559d426e357..e795484bc95 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1702,6 +1702,11 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                                 projectLoadSettings |= ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.IgnoreInvalidImports | ProjectLoadSettings.IgnoreEmptyImports;
                             }
 
+                            if (submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags.FailOnUnresolvedSdk))
+                            {
+                                projectLoadSettings |= ProjectLoadSettings.FailOnUnresolvedSdk;
+                            }
+
                             return new ProjectInstance(
                                 path,
                                 properties,
@@ -2578,7 +2583,11 @@ private NodeConfiguration GetNodeConfiguration()
 #if FEATURE_APPDOMAIN
                 , AppDomain.CurrentDomain.SetupInformation
 #endif
-                , new LoggingNodeConfiguration(loggingService.IncludeEvaluationMetaprojects, loggingService.IncludeEvaluationProfile, loggingService.IncludeTaskInputs)
+                , new LoggingNodeConfiguration(
+                    loggingService.IncludeEvaluationMetaprojects,
+                    loggingService.IncludeEvaluationProfile,
+                    loggingService.IncludeEvaluationPropertiesAndItems,
+                    loggingService.IncludeTaskInputs)
                 );
             }
 
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestData.cs b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
index 4123d7e0922..673ee5f0fdf 100644
--- a/src/Build/BackEnd/BuildManager/BuildRequestData.cs
+++ b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
@@ -75,6 +75,21 @@ public enum BuildRequestDataFlags
         /// This is especially useful during a restore since some imports might come from packages that haven't been restored yet.
         /// </summary>
         IgnoreMissingEmptyAndInvalidImports = 1 << 6,
+
+        /// <summary>
+        /// When this flag is present, non entry target(s) in the build request will be skipped if those targets
+        /// are not defined in the Project to build. The build will still fail if an entry target does not exist.
+        /// This only applies to this build request (if another target calls the "missing target" at any other point
+        /// this will still result in an error).
+        /// </summary>
+        SkipNonexistentNonEntryTargets = 1 << 7,
+
+        /// <summary>
+        /// When this flag is present, an unresolved MSBuild project SDK will fail the build.  This flag is used to
+        /// change the <see cref="IgnoreMissingEmptyAndInvalidImports" /> behavior to still fail when an SDK is missing
+        /// because those are more fatal.
+        /// </summary>
+        FailOnUnresolvedSdk = 1 << 8,
     }
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
index b2fb277ba84..db2e6aecb4f 100644
--- a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
@@ -1,8 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections;
+using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd.Components.Logging
@@ -31,10 +34,10 @@ public void LogProjectEvaluationStarted()
         /// <summary>
         /// Log that the project has finished
         /// </summary>
-        internal void LogProjectEvaluationFinished()
+        internal void LogProjectEvaluationFinished(IEnumerable globalProperties, IEnumerable properties, IEnumerable items, ProfilerResult? profilerResult)
         {
             ErrorUtilities.VerifyThrow(IsValid, "invalid");
-            LoggingService.LogProjectEvaluationFinished(BuildEventContext, _projectFile);
+            LoggingService.LogProjectEvaluationFinished(BuildEventContext, _projectFile, globalProperties, properties, items, profilerResult);
             IsValid = false;
         }
     }
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 4c321e4a15c..97b7512d14e 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -18,7 +18,7 @@ internal sealed class EventSourceSink :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        IEventSource3, IBuildEventSink
+        IEventSource4, IBuildEventSink
     {
         #region Events
 
@@ -138,7 +138,6 @@ public bool IncludeEvaluationMetaprojects
             private set;
         }
 
-
         /// <summary>
         /// Should evaluation events include profiling information?
         /// </summary>
@@ -157,6 +156,16 @@ public bool IncludeTaskInputs
             private set;
         }
 
+        /// <summary>
+        /// Determines whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems
+        {
+            get;
+            private set;
+        }
+
         #endregion
 
         #region Methods
@@ -180,6 +189,15 @@ void IEventSource3.IncludeTaskInputs()
 
         #endregion
 
+        #region IEventSource4 Methods
+
+        void IEventSource4.IncludeEvaluationPropertiesAndItems()
+        {
+            IncludeEvaluationPropertiesAndItems = true;
+        }
+
+        #endregion
+
         #region IEventSink Methods
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index eebb06bea2a..ef3db37b022 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
@@ -187,6 +188,16 @@ bool IncludeEvaluationProfile
             set;
         }
 
+        /// <summary>
+        /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>?
+        /// </summary>
+        bool IncludeEvaluationPropertiesAndItems
+        {
+            get;
+            set;
+        }
+
         /// <summary>
         /// Should task events include task inputs?
         /// </summary>
@@ -427,8 +438,18 @@ bool IncludeTaskInputs
         /// </summary>
         /// <param name="projectEvaluationEventContext">Event context for the project.</param>
         /// <param name="projectFile">Project file being built</param>
+        /// <param name="globalProperties">Global properties used for the evaluation.</param>
+        /// <param name="properties">Properties produced by the evaluation.</param>
+        /// <param name="items">Items produced by the evaluation.</param>
+        /// <param name="profilerResult">Profiler results if evaluation profiling was enabled.</param>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
-        void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile);
+        void LogProjectEvaluationFinished(
+            BuildEventContext projectEvaluationEventContext,
+            string projectFile,
+            IEnumerable globalProperties,
+            IEnumerable properties,
+            IEnumerable items,
+            ProfilerResult? profilerResult);
 
         /// <summary>
         /// Log that a project has started
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index c86ac786792..7f8aa44f50f 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -196,6 +196,12 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// </summary>
         private bool? _includeEvaluationProfile;
 
+        /// <summary>
+        /// Whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>.
+        /// </summary>
+        private bool? _includeEvaluationPropertiesAndItems;
+
         /// <summary>
         /// Whether to include task inputs in task events.
         /// </summary>
@@ -502,6 +508,16 @@ public bool IncludeTaskInputs
             set => _includeTaskInputs = value;
         }
 
+        /// <summary>
+        /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>?
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems
+        {
+            get => _includeEvaluationPropertiesAndItems ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationPropertiesAndItems);
+            set => _includeEvaluationPropertiesAndItems = value;
+        }
+
         /// <summary>
         /// Determines if the specified submission has logged an errors.
         /// </summary>
@@ -1154,7 +1170,12 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
                 {
                     ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectStartedEventArgs.ProjectId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
                     BuildRequestConfiguration buildRequestConfiguration = _configCache.Value[projectStartedEventArgs.ProjectId];
-                    s_projectStartedEventArgsGlobalProperties.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.GlobalProperties.ToDictionary(), null);
+
+                    // Always log GlobalProperties on ProjectStarted for compatibility.
+                    // There are loggers that depend on it being not-null and always set.
+                    // See https://github.com/dotnet/msbuild/issues/6341 for details.
+                    s_projectStartedEventArgsGlobalProperties.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.GlobalProperties.ToDictionary(), index: null);
+
                     s_projectStartedEventArgsToolsVersion.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.ToolsVersion, null);
                 }
             }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index d7c7cf13ad6..4e104910a97 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
@@ -513,8 +514,18 @@ public void LogProjectEvaluationStarted(BuildEventContext projectEvaluationEvent
         /// </summary>
         /// <param name="projectEvaluationEventContext">Event context for the project.</param>
         /// <param name="projectFile">Project file being built</param>
+        /// <param name="globalProperties">Global properties used for the evaluation.</param>
+        /// <param name="properties">Properties produced by the evaluation.</param>
+        /// <param name="items">Items produced by the evaluation.</param>
+        /// <param name="profilerResult">Profiler results if evaluation profiling was enabled.</param>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
-        public void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile)
+        public void LogProjectEvaluationFinished(
+            BuildEventContext projectEvaluationEventContext,
+            string projectFile,
+            IEnumerable globalProperties,
+            IEnumerable properties,
+            IEnumerable items,
+            ProfilerResult? profilerResult)
         {
             lock (_lockObject)
             {
@@ -524,7 +535,11 @@ public void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEven
                     new ProjectEvaluationFinishedEventArgs(ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile)
                     {
                         BuildEventContext = projectEvaluationEventContext,
-                        ProjectFile = projectFile
+                        ProjectFile = projectFile,
+                        ProfilerResult = profilerResult,
+                        GlobalProperties = globalProperties,
+                        Properties = properties,
+                        Items = items
                     };
                 ProcessLoggingEvent(buildEvent);
             }
@@ -579,17 +594,22 @@ public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventConte
 
                 ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectInstanceId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
                 var buildRequestConfiguration = _configCache.Value[projectInstanceId];
-                ProjectStartedEventArgs buildEvent = new ProjectStartedEventArgs
+
+                // Always log GlobalProperties on ProjectStarted
+                // See https://github.com/dotnet/msbuild/issues/6341 for details
+                IDictionary<string, string> globalProperties = buildRequestConfiguration.GlobalProperties.ToDictionary();
+
+                var buildEvent = new ProjectStartedEventArgs
                     (
                         projectInstanceId,
                         message,
-                        null,       // no help keyword
+                        helpKeyword: null,
                         projectFile,
                         targetNames,
                         properties,
                         items,
                         parentBuildEventContext,
-                        buildRequestConfiguration.GlobalProperties.ToDictionary(),
+                        globalProperties,
                         buildRequestConfiguration.ToolsVersion
                     );
                 buildEvent.BuildEventContext = projectBuildEventContext;
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index be1a86b0229..846c0b3a643 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Shared;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
@@ -85,7 +86,9 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
             string[] propertiesToSerialize = LoggingService.PropertiesToSerialize;
 
             // If we are only logging critical events lets not pass back the items or properties
-            if (!LoggingService.OnlyLogCriticalEvents && (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
+            if (!LoggingService.OnlyLogCriticalEvents &&
+                !LoggingService.IncludeEvaluationPropertiesAndItems &&
+                (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
             {
                 if (projectProperties != null)
                 {
@@ -101,7 +104,10 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
                 items = new ProjectItemInstanceEnumeratorProxy(projectItemsEnumerator);
             }
 
-            if (projectProperties != null && propertiesToSerialize?.Length > 0 && !LoggingService.SerializeAllProperties)
+            if (projectProperties != null &&
+                !LoggingService.IncludeEvaluationPropertiesAndItems &&
+                propertiesToSerialize?.Length > 0 &&
+                !LoggingService.SerializeAllProperties)
             {
                 PropertyDictionary<ProjectPropertyInstance> projectPropertiesToSerialize = new PropertyDictionary<ProjectPropertyInstance>();
                 foreach (string propertyToGet in propertiesToSerialize)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index 79142963436..33486a859be 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -143,15 +143,24 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
             foreach (string targetName in targetNames)
             {
                 var targetExists = _projectInstance.Targets.TryGetValue(targetName, out ProjectTargetInstance targetInstance);
-                if (!targetExists && entry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.SkipNonexistentTargets))
+                
+                if (!targetExists)
                 {
-                    _projectLoggingContext.LogComment(Framework.MessageImportance.Low,
-                        "TargetSkippedWhenSkipNonexistentTargets", targetName);
-                }
-                else
-                {
-                    targets.Add(new TargetSpecification(targetName, targetExists ? targetInstance.Location : _projectInstance.ProjectFileLocation));
+                    // Ignore the missing target if:
+                    //  SkipNonexistentTargets is set
+                    //  -or-
+                    //  SkipNonexistentNonEntryTargets and the target is is not a top level target
+                    if (entry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.SkipNonexistentTargets)
+                        || entry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.SkipNonexistentNonEntryTargets) && !entry.Request.Targets.Contains(targetName))
+                    {
+                        _projectLoggingContext.LogComment(Framework.MessageImportance.Low,
+                            "TargetSkippedWhenSkipNonexistentTargets", targetName);
+
+                        continue;
+                    }
                 }
+
+                targets.Add(new TargetSpecification(targetName, targetExists ? targetInstance.Location : _projectInstance.ProjectFileLocation));
             }
 
             // Push targets onto the stack.  This method will reverse their push order so that they
diff --git a/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs b/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
index 9578394e043..2c7a47703c0 100644
--- a/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
@@ -11,22 +11,27 @@ internal sealed class LoggingNodeConfiguration : ITranslatable
     {
         private bool _includeEvaluationMetaprojects;
         private bool _includeEvaluationProfiles;
+        private bool _includeEvaluationPropertiesAndItems;
         private bool _includeTaskInputs;
 
         public bool IncludeEvaluationMetaprojects => _includeEvaluationMetaprojects;
-
         public bool IncludeEvaluationProfiles => _includeEvaluationProfiles;
-
+        public bool IncludeEvaluationPropertiesAndItems => _includeEvaluationPropertiesAndItems;
         public bool IncludeTaskInputs => _includeTaskInputs;
 
         public LoggingNodeConfiguration()
         {
         }
 
-        public LoggingNodeConfiguration(bool includeEvaluationMetaprojects, bool includeEvaluationProfiles, bool includeTaskInputs)
+        public LoggingNodeConfiguration(
+            bool includeEvaluationMetaprojects,
+            bool includeEvaluationProfiles,
+            bool includeEvaluationPropertiesAndItems,
+            bool includeTaskInputs)
         {
             _includeEvaluationMetaprojects = includeEvaluationMetaprojects;
             _includeEvaluationProfiles = includeEvaluationProfiles;
+            _includeEvaluationPropertiesAndItems = includeEvaluationPropertiesAndItems;
             _includeTaskInputs = includeTaskInputs;
         }
 
@@ -34,6 +39,7 @@ void ITranslatable.Translate(ITranslator translator)
         {
             translator.Translate(ref _includeEvaluationMetaprojects);
             translator.Translate(ref _includeEvaluationProfiles);
+            translator.Translate(ref _includeEvaluationPropertiesAndItems);
             translator.Translate(ref _includeTaskInputs);
         }
     }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index d70930c1493..80e36648f23 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -742,6 +742,7 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
             {
                 _loggingService.IncludeEvaluationMetaprojects = true;
             }
+
             if (configuration.LoggingNodeConfiguration.IncludeEvaluationProfiles)
             {
                 _loggingService.IncludeEvaluationProfile = true;
@@ -752,6 +753,11 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
                 _loggingService.IncludeTaskInputs = true;
             }
 
+            if (configuration.LoggingNodeConfiguration.IncludeEvaluationPropertiesAndItems)
+            {
+                _loggingService.IncludeEvaluationPropertiesAndItems = true;
+            }
+
             try
             {
                 // If there are no node loggers to initialize dont do anything
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 97f9531e074..8398cb68479 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -466,6 +466,11 @@ internal void LoadProjectIntoConfiguration(
                     projectLoadSettings |= ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.IgnoreInvalidImports | ProjectLoadSettings.IgnoreEmptyImports;
                 }
 
+                if (buildRequestDataFlags.HasFlag(buildRequestDataFlags & BuildRequestDataFlags.FailOnUnresolvedSdk))
+                {
+                    projectLoadSettings |= ProjectLoadSettings.FailOnUnresolvedSdk;
+                }
+
                 return new ProjectInstance(
                     ProjectFullPath,
                     globalProperties,
diff --git a/src/Build/Collections/ArrayDictionary.cs b/src/Build/Collections/ArrayDictionary.cs
index 9cdf1d7a0e1..01e883f6058 100644
--- a/src/Build/Collections/ArrayDictionary.cs
+++ b/src/Build/Collections/ArrayDictionary.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Collections
     /// </summary>
     /// <typeparam name="TKey">Type of keys</typeparam>
     /// <typeparam name="TValue">Type of values</typeparam>
-    internal class ArrayDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary
+    internal class ArrayDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary, IReadOnlyDictionary<TKey, TValue>
     {
         private TKey[] keys;
         private TValue[] values;
@@ -65,6 +65,10 @@ object IDictionary.this[object key]
 
         public ICollection<TKey> Keys => keys;
 
+        IEnumerable<TKey> IReadOnlyDictionary<TKey, TValue>.Keys => keys;
+
+        IEnumerable<TValue> IReadOnlyDictionary<TKey, TValue>.Values => values;
+
         ICollection IDictionary.Keys => keys;
 
         public ICollection<TValue> Values => values;
diff --git a/src/Build/Collections/ItemDictionary.cs b/src/Build/Collections/ItemDictionary.cs
index 84efd27c913..b0e1ab517ef 100644
--- a/src/Build/Collections/ItemDictionary.cs
+++ b/src/Build/Collections/ItemDictionary.cs
@@ -167,6 +167,30 @@ IEnumerator IEnumerable.GetEnumerator()
             return _itemLists.GetEnumerator();
         }
 
+        /// <summary>
+        /// Enumerates item lists per each item type under the lock.
+        /// </summary>
+        /// <param name="itemTypeCallback">
+        /// A delegate that accepts the item type string and a list of items of that type.
+        /// Will be called for each item type in the list.
+        /// </param>
+        internal void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
+        {
+            lock (_itemLists)
+            {
+                foreach (var itemTypeBucket in _itemLists)
+                {
+                    if (itemTypeBucket.Value == null || itemTypeBucket.Value.Count == 0)
+                    {
+                        // skip empty markers
+                        continue;
+                    }
+
+                    itemTypeCallback(itemTypeBucket.Key, itemTypeBucket.Value);
+                }
+            }
+        }
+
         #region ItemDictionary<T> Members
 
         /// <summary>
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index e3c17b24fae..e1929f7ca58 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -492,22 +492,33 @@ internal void RemoveProperties(IEnumerable<T> other)
 
         /// <summary>
         /// Helper to convert into a read-only dictionary of string, string.
+        /// TODO: for performance, consider switching to returning IDictionary
+        /// and returning ArrayDictionary if lookup of results is not needed.
         /// </summary>
         internal Dictionary<string, string> ToDictionary()
         {
-            Dictionary<string, string> dictionary;
-
             lock (_properties)
             {
-                dictionary = new Dictionary<string, string>(_properties.Count, MSBuildNameIgnoreCaseComparer.Default);
+                var dictionary = new Dictionary<string, string>(_properties.Count, MSBuildNameIgnoreCaseComparer.Default);
 
                 foreach (T property in this)
                 {
                     dictionary[property.Key] = property.EscapedValue;
                 }
+
+                return dictionary;
             }
+        }
 
-            return dictionary;
+        internal void Enumerate(Action<string, string> keyValueCallback)
+        {
+            lock (_properties)
+            {
+                foreach (var kvp in _properties)
+                {
+                    keyValueCallback(kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));
+                }
+            }
         }
     }
 }
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 7de69fea0c3..874962890f4 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -415,7 +415,9 @@ internal static string ParseSolutionFromSolutionFilter(string solutionFilterFile
         {
             try
             {
-                JsonDocument text = JsonDocument.Parse(File.ReadAllText(solutionFilterFile));
+                // This is to align MSBuild with what VS permits in loading solution filter files. These are not in them by default but can be added manually.
+                JsonDocumentOptions options = new JsonDocumentOptions() { AllowTrailingCommas = true, CommentHandling = JsonCommentHandling.Skip };
+                JsonDocument text = JsonDocument.Parse(File.ReadAllText(solutionFilterFile), options);
                 solution = text.RootElement.GetProperty("solution");
                 return FileUtilities.GetFullPath(solution.GetProperty("path").GetString(), Path.GetDirectoryName(solutionFilterFile));
             }
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 451a26ef506..07519d583ba 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -1794,7 +1794,7 @@ public ProjectAddedToProjectCollectionEventArgs(ProjectRootElement element)
         /// The ReusableLogger wraps a logger and allows it to be used for both design-time and build-time.  It internally swaps
         /// between the design-time and build-time event sources in response to Initialize and Shutdown events.
         /// </summary>
-        internal class ReusableLogger : INodeLogger, IEventSource3
+        internal class ReusableLogger : INodeLogger, IEventSource4
         {
             /// <summary>
             /// The logger we are wrapping.
@@ -1892,6 +1892,8 @@ internal class ReusableLogger : INodeLogger, IEventSource3
 
             private bool _includeTaskInputs;
 
+            private bool _includeEvaluationPropertiesAndItems;
+
             /// <summary>
             /// Constructor.
             /// </summary>
@@ -2031,6 +2033,22 @@ public void IncludeTaskInputs()
 
                 _includeTaskInputs = true;
             }
+
+            public void IncludeEvaluationPropertiesAndItems()
+            {
+                if (_buildTimeEventSource is IEventSource4 buildEventSource4)
+                {
+                    buildEventSource4.IncludeEvaluationPropertiesAndItems();
+                }
+
+                if (_designTimeEventSource is IEventSource4 designTimeEventSource4)
+                {
+                    designTimeEventSource4.IncludeEvaluationPropertiesAndItems();
+                }
+
+                _includeEvaluationPropertiesAndItems = true;
+            }
+
             #endregion
 
             #region ILogger Members
@@ -2163,6 +2181,7 @@ private void RegisterForEvents(IEventSource eventSource)
                     {
                         eventSource3.IncludeEvaluationMetaprojects();
                     }
+
                     if (_includeEvaluationProfiles)
                     {
                         eventSource3.IncludeEvaluationProfiles();
@@ -2173,6 +2192,14 @@ private void RegisterForEvents(IEventSource eventSource)
                         eventSource3.IncludeTaskInputs();
                     }
                 }
+
+                if (eventSource is IEventSource4 eventSource4)
+                {
+                    if (_includeEvaluationPropertiesAndItems)
+                    {
+                        eventSource4.IncludeEvaluationPropertiesAndItems();
+                    }
+                }
             }
 
             /// <summary>
diff --git a/src/Build/Definition/ProjectLoadSettings.cs b/src/Build/Definition/ProjectLoadSettings.cs
index 7f1c9ad2d80..ef51122eca5 100644
--- a/src/Build/Definition/ProjectLoadSettings.cs
+++ b/src/Build/Definition/ProjectLoadSettings.cs
@@ -59,5 +59,10 @@ public enum ProjectLoadSettings
         /// Whether to profile the evaluation
         /// </summary>
         ProfileEvaluation = 128,
+
+        /// <summary>
+        /// Used in combination with <see cref="IgnoreMissingImports" /> to still treat an unresolved MSBuild project SDK as an error.
+        /// </summary>
+        FailOnUnresolvedSdk = 256,
     }
 }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index f9126e6c61f..fdc0ec6a0ec 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using ObjectModel = System.Collections.ObjectModel;
@@ -777,12 +778,19 @@ private void Evaluate()
             }
 
             ErrorUtilities.VerifyThrow(_evaluationProfiler.IsEmpty(), "Evaluation profiler stack is not empty.");
-            _evaluationLoggingContext.LogBuildEvent(new ProjectEvaluationFinishedEventArgs(ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile)
+
+            IEnumerable globalProperties = null;
+            IEnumerable properties = null;
+            IEnumerable items = null;
+
+            if (this._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
             {
-                BuildEventContext = _evaluationLoggingContext.BuildEventContext,
-                ProjectFile = projectFile,
-                ProfilerResult = _evaluationProfiler.ProfiledResult
-            });
+                globalProperties = _data.GlobalPropertiesDictionary;
+                properties = _data.Properties;
+                items = _data.Items;
+            }
+
+            _evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, _evaluationProfiler.ProfiledResult);
         }
 
         private void CollectProjectCachePlugins()
@@ -1761,7 +1769,8 @@ static string EvaluateProperty(string value, IElementLocation location,
 
                 if (!sdkResult.Success)
                 {
-                    if (_loadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports))
+                    // Ignore the missing import if IgnoreMissingImports is set unless FailOnUnresolvedSdk is also set
+                    if (_loadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports) && !_loadSettings.HasFlag(ProjectLoadSettings.FailOnUnresolvedSdk))
                     {
                         ProjectImportedEventArgs eventArgs = new ProjectImportedEventArgs(
                             importElement.Location.Line,
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index f9ef8388e3b..e29d3346621 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -1052,7 +1052,7 @@ ISet<string> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, Projec
         }
 
         /// <summary>
-        /// Gets the global properties
+        /// Gets the properties
         /// </summary>
         PropertyDictionary<ProjectPropertyInstance> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Properties
         {
@@ -1062,7 +1062,7 @@ PropertyDictionary<ProjectPropertyInstance> IEvaluatorData<ProjectPropertyInstan
         }
 
         /// <summary>
-        /// Gets the global properties
+        /// Gets the item definitions
         /// </summary>
         IEnumerable<ProjectItemDefinitionInstance> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.ItemDefinitionsEnumerable
         {
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index aad71143328..1768e7b3145 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -527,10 +527,9 @@ internal List<DictionaryEntry> ExtractPropertyList(IEnumerable properties)
         {
             // Gather a sorted list of all the properties.
             var list = new List<DictionaryEntry>(properties.FastCountOrZero());
-            foreach (DictionaryEntry prop in properties)
-            {
-                list.Add(prop);
-            }
+
+            Internal.Utilities.EnumerateProperties(properties, kvp => list.Add(new DictionaryEntry(kvp.Key, kvp.Value)));
+
             list.Sort(new DictionaryEntryKeyComparer());
             return list;
         }
@@ -620,18 +619,19 @@ internal SortedList ExtractItemList(IEnumerable items)
             // Use a SortedList instead of an ArrayList (because we need to lookup fast)
             // and instead of a Hashtable (because we need to sort it)
             SortedList itemTypes = new SortedList(CaseInsensitiveComparer.Default);
-            foreach (DictionaryEntry item in items)
+
+            Internal.Utilities.EnumerateItems(items, item =>
             {
-                // Create a new list for this itemtype, if we haven't already
-                if (itemTypes[(string)item.Key] == null)
+                string key = (string)item.Key;
+                var bucket = itemTypes[key] as ArrayList;
+                if (bucket == null)
                 {
-                    itemTypes[(string)item.Key] = new ArrayList();
+                    bucket = new ArrayList();
+                    itemTypes[key] = bucket;
                 }
 
-                // Add the item to the list for its itemtype
-                ArrayList itemsOfAType = (ArrayList)itemTypes[(string)item.Key];
-                itemsOfAType.Add(item.Value);
-            }
+                bucket.Add(item.Value);
+            });
 
             return itemTypes;
         }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 5274f54ab3a..c9515e817f5 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -43,7 +43,9 @@ public sealed class BinaryLogger : ILogger
         //                        where a list used to be written in-place
         // version 11:
         //   - new record kind: TaskParameterEventArgs
-        internal const int FileFormatVersion = 11;
+        // version 12:
+        //   - add GlobalProperties, Properties and Items on ProjectEvaluationFinished
+        internal const int FileFormatVersion = 12;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
@@ -103,6 +105,7 @@ public void Initialize(IEventSource eventSource)
             Environment.SetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING", "true");
             Environment.SetEnvironmentVariable("MSBUILDLOGIMPORTS", "1");
             Traits.Instance.EscapeHatches.LogProjectImports = true;
+            bool logPropertiesAndItemsAfterEvaluation = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;
 
             ProcessParameters();
 
@@ -135,6 +138,11 @@ public void Initialize(IEventSource eventSource)
                 {
                     eventSource3.IncludeEvaluationMetaprojects();
                 }
+
+                if (logPropertiesAndItemsAfterEvaluation && eventSource is IEventSource4 eventSource4)
+                {
+                    eventSource4.IncludeEvaluationPropertiesAndItems();
+                }
             }
             catch (Exception e)
             {
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index f9af8eed299..d6675d9eb7b 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -343,7 +343,9 @@ private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
             var fields = ReadBuildEventArgsFields();
             var projectFile = ReadDeduplicatedString();
 
-            var e = new ProjectEvaluationStartedEventArgs(fields.Message)
+            var e = new ProjectEvaluationStartedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationStarted"),
+                projectFile)
             {
                 ProjectFile = projectFile
             };
@@ -356,12 +358,30 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
             var fields = ReadBuildEventArgsFields();
             var projectFile = ReadDeduplicatedString();
 
-            var e = new ProjectEvaluationFinishedEventArgs(fields.Message)
+            var e = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"),
+                projectFile)
             {
                 ProjectFile = projectFile
             };
             SetCommonFields(e, fields);
 
+            if (fileFormatVersion >= 12)
+            {
+                IEnumerable globalProperties = null;
+                if (ReadBoolean())
+                {
+                    globalProperties = ReadStringDictionary();
+                }
+
+                var propertyList = ReadPropertyList();
+                var itemList = ReadProjectItems();
+
+                e.GlobalProperties = globalProperties;
+                e.Properties = propertyList;
+                e.Items = itemList;
+            }
+
             // ProfilerResult was introduced in version 5
             if (fileFormatVersion > 4)
             {
@@ -451,7 +471,7 @@ private BuildEventArgs ReadTargetStartedEventArgs()
             var targetFile = ReadOptionalString();
             var parentTarget = ReadOptionalString();
             // BuildReason was introduced in version 4
-            var buildReason = fileFormatVersion > 3 ? (TargetBuiltReason) ReadInt32() : TargetBuiltReason.None;
+            var buildReason = fileFormatVersion > 3 ? (TargetBuiltReason)ReadInt32() : TargetBuiltReason.None;
 
             var e = new TargetStartedEventArgs(
                 fields.Message,
@@ -617,15 +637,15 @@ private BuildEventArgs ReadTaskParameterEventArgs()
             ReadInt32();
 
             var kind = (TaskParameterMessageKind)ReadInt32();
-            var itemName = ReadDeduplicatedString();
+            var itemType = ReadDeduplicatedString();
             var items = ReadTaskItemList() as IList;
 
             var e = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
                 fields.BuildEventContext,
                 kind,
-                itemName,
+                itemType,
                 items,
-                true,
+                logItemMetadata: true,
                 fields.Timestamp);
             e.ProjectFile = fields.ProjectFile;
             return e;
@@ -845,23 +865,25 @@ private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields
 
             if ((fields.Flags & BuildEventArgsFieldFlags.Timestamp) != 0)
             {
-                buildEventArgsFieldTimestamp.SetValue(buildEventArgs, fields.Timestamp);
+                buildEventArgs.RawTimestamp = fields.Timestamp;
             }
         }
 
-        private ArrayList ReadPropertyList()
+        private IEnumerable ReadPropertyList()
         {
             var properties = ReadStringDictionary();
-            if (properties == null)
+            if (properties == null || properties.Count == 0)
             {
                 return null;
             }
 
-            var list = new ArrayList();
+            int count = properties.Count;
+            var list = new DictionaryEntry[count];
+            int i = 0;
             foreach (var property in properties)
             {
-                var entry = new DictionaryEntry(property.Key, property.Value);
-                list.Add(entry);
+                list[i] = new DictionaryEntry(property.Key, property.Value);
+                i++;
             }
 
             return list;
@@ -942,13 +964,7 @@ private ITaskItem ReadTaskItem()
 
         private IEnumerable ReadProjectItems()
         {
-            int count = ReadInt32();
-            if (count == 0)
-            {
-                return null;
-            }
-
-            List<DictionaryEntry> list;
+            IList<DictionaryEntry> list;
 
             // starting with format version 10 project items are grouped by name
             // so we only have to write the name once, and then the count of items
@@ -956,26 +972,68 @@ private IEnumerable ReadProjectItems()
             // old style flat list where the name is duplicated for each item.
             if (fileFormatVersion < 10)
             {
-                list = new List<DictionaryEntry>(count);
+                int count = ReadInt32();
+                if (count == 0)
+                {
+                    return null;
+                }
+
+                list = new DictionaryEntry[count];
                 for (int i = 0; i < count; i++)
                 {
                     string itemName = ReadString();
                     ITaskItem item = ReadTaskItem();
-                    list.Add(new DictionaryEntry(itemName, item));
+                    list[i] = new DictionaryEntry(itemName, item);
                 }
             }
-            else
+            else if (fileFormatVersion < 12)
             {
+                int count = ReadInt32();
+                if (count == 0)
+                {
+                    return null;
+                }
+
                 list = new List<DictionaryEntry>();
                 for (int i = 0; i < count; i++)
                 {
-                    string itemName = ReadDeduplicatedString();
+                    string itemType = ReadDeduplicatedString();
+                    var items = ReadTaskItemList();
+                    if (items != null)
+                    {
+                        foreach (var item in items)
+                        {
+                            list.Add(new DictionaryEntry(itemType, item));
+                        }
+                    }
+                }
+            }
+            else
+            {
+                list = new List<DictionaryEntry>();
+
+                while (true)
+                {
+                    string itemType = ReadDeduplicatedString();
+                    if (string.IsNullOrEmpty(itemType))
+                    {
+                        break;
+                    }
+
                     var items = ReadTaskItemList();
-                    foreach (var item in items)
+                    if (items != null)
                     {
-                        list.Add(new DictionaryEntry(itemName, item));
+                        foreach (var item in items)
+                        {
+                            list.Add(new DictionaryEntry(itemType, item));
+                        }
                     }
                 }
+
+                if (list.Count == 0)
+                {
+                    list = null;
+                }
             }
 
             return list;
@@ -989,12 +1047,12 @@ private IEnumerable ReadTaskItemList()
                 return null;
             }
 
-            var list = new List<ITaskItem>(count);
+            var list = new ITaskItem[count];
 
             for (int i = 0; i < count; i++)
             {
                 ITaskItem item = ReadTaskItem();
-                list.Add(item);
+                list[i] = item;
             }
 
             return list;
@@ -1109,7 +1167,7 @@ private EvaluationLocation ReadEvaluationLocation()
             var hasLine = ReadBoolean();
             if (hasLine)
             {
-                line = ReadInt32(); 
+                line = ReadInt32();
             }
 
             // Id and parent Id were introduced in version 6
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 1acc641650b..5774a80a27f 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -8,6 +8,8 @@
 using System.IO;
 using System.Linq;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -218,7 +220,7 @@ private void Write(BuildFinishedEventArgs e)
         private void Write(ProjectEvaluationStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.ProjectEvaluationStarted);
-            WriteBuildEventArgsFields(e);
+            WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.ProjectFile);
         }
 
@@ -226,15 +228,30 @@ private void Write(ProjectEvaluationFinishedEventArgs e)
         {
             Write(BinaryLogRecordKind.ProjectEvaluationFinished);
 
-            WriteBuildEventArgsFields(e);
+            WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.ProjectFile);
 
-            Write(e.ProfilerResult.HasValue);
-            if (e.ProfilerResult.HasValue)
+            if (e.GlobalProperties == null)
             {
-                Write(e.ProfilerResult.Value.ProfiledLocations.Count);
+                Write(false);
+            }
+            else
+            {
+                Write(true);
+                WriteProperties(e.GlobalProperties);
+            }
+
+            WriteProperties(e.Properties);
 
-                foreach (var item in e.ProfilerResult.Value.ProfiledLocations)
+            WriteProjectItems(e.Items);
+
+            var result = e.ProfilerResult;
+            Write(result.HasValue);
+            if (result.HasValue)
+            {
+                Write(result.Value.ProfiledLocations.Count);
+
+                foreach (var item in result.Value.ProfiledLocations)
                 {
                     Write(item.Key);
                     Write(item.Value);
@@ -664,7 +681,9 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
             return flags;
         }
 
+        // Both of these are used simultaneously so can't just have a single list
         private readonly List<object> reusableItemsList = new List<object>();
+        private readonly List<object> reusableProjectItemList = new List<object>();
 
         private void WriteTaskItemList(IEnumerable items, bool writeMetadata = true)
         {
@@ -736,18 +755,71 @@ private void WriteProjectItems(IEnumerable items)
                 return;
             }
 
-            var groups = items
-                .OfType<DictionaryEntry>()
-                .GroupBy(entry => entry.Key as string, entry => entry.Value as ITaskItem)
-                .Where(group => !string.IsNullOrEmpty(group.Key))
-                .ToArray();
+            if (items is ItemDictionary<ProjectItemInstance> itemInstanceDictionary)
+            {
+                // If we have access to the live data from evaluation, it exposes a special method
+                // to iterate the data structure under a lock and return results grouped by item type.
+                // There's no need to allocate or call GroupBy this way.
+                itemInstanceDictionary.EnumerateItemsPerType((itemType, itemList) =>
+                {
+                    WriteDeduplicatedString(itemType);
+                    WriteTaskItemList(itemList);
+                });
 
-            Write(groups.Length);
+                // signal the end
+                Write(0);
+            }
+            // not sure when this can get hit, but best to be safe and support this
+            else if (items is ItemDictionary<ProjectItem> itemDictionary)
+            {
+                itemDictionary.EnumerateItemsPerType((itemType, itemList) =>
+                {
+                    WriteDeduplicatedString(itemType);
+                    WriteTaskItemList(itemList);
+                });
 
-            foreach (var group in groups)
+                // signal the end
+                Write(0);
+            }
+            else
             {
-                WriteDeduplicatedString(group.Key);
-                WriteTaskItemList(group);
+                string currentItemType = null;
+
+                // Write out a sequence of items for each item type while avoiding GroupBy
+                // and associated allocations. We rely on the fact that items of each type
+                // are contiguous. For each item type, write the item type name and the list
+                // of items. Write 0 at the end (which would correspond to item type null).
+                // This is how the reader will know how to stop. We can't write out the
+                // count of item types at the beginning because we don't know how many there
+                // will be (we'd have to enumerate twice to calculate that). This scheme
+                // allows us to stream in a single pass with no allocations for intermediate
+                // results.
+                Internal.Utilities.EnumerateItems(items, dictionaryEntry =>
+                {
+                    string key = (string)dictionaryEntry.Key;
+
+                    // boundary between item types
+                    if (currentItemType != null && currentItemType != key)
+                    {
+                        WriteDeduplicatedString(currentItemType);
+                        WriteTaskItemList(reusableProjectItemList);
+                        reusableProjectItemList.Clear();
+                    }
+
+                    reusableProjectItemList.Add(dictionaryEntry.Value);
+                    currentItemType = key;
+                });
+
+                // write out the last item type
+                if (reusableProjectItemList.Count > 0)
+                {
+                    WriteDeduplicatedString(currentItemType);
+                    WriteTaskItemList(reusableProjectItemList);
+                    reusableProjectItemList.Clear();
+                }
+
+                // signal the end
+                Write(0);
             }
         }
 
@@ -787,22 +859,7 @@ private void WriteProperties(IEnumerable properties)
                 return;
             }
 
-            // there are no guarantees that the properties iterator won't change, so 
-            // take a snapshot and work with the readonly copy
-            var propertiesArray = properties.OfType<DictionaryEntry>().ToArray();
-
-            for (int i = 0; i < propertiesArray.Length; i++)
-            {
-                DictionaryEntry entry = propertiesArray[i];
-                if (entry.Key is string key && entry.Value is string value)
-                {
-                    nameValueListBuffer.Add(new KeyValuePair<string, string>(key, value));
-                }
-                else
-                {
-                    nameValueListBuffer.Add(new KeyValuePair<string, string>(string.Empty, string.Empty));
-                }
-            }
+            Internal.Utilities.EnumerateProperties(properties, kvp => nameValueListBuffer.Add(kvp));
 
             WriteNameValueList();
 
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index bae76905916..edcbe439efe 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -6,13 +6,14 @@
 using System.Collections;
 using System.Globalization;
 using System.Collections.Generic;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using ColorSetter = Microsoft.Build.Logging.ColorSetter;
 using ColorResetter = Microsoft.Build.Logging.ColorResetter;
 using WriteHandler = Microsoft.Build.Logging.WriteHandler;
-using Microsoft.Build.Exceptions;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
@@ -527,6 +528,7 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 {
                     DisplayDeferredProjectStartedEvent(e.BuildEventContext);
                 }
+
                 if (e.Properties != null)
                 {
                     WriteProperties(e, e.Properties);
@@ -538,30 +540,50 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 }
             }
 
-            if (e.BuildEventContext == null || e.Items == null)
+            ReadProjectConfigurationDescription(e.BuildEventContext, e.Items);
+        }
+
+        private void ReadProjectConfigurationDescription(BuildEventContext buildEventContext, IEnumerable items)
+        {
+            if (buildEventContext == null || items == null)
             {
                 return;
             }
 
             // node and project context ids for the propertyOutputMap key.
-            int nodeID = e.BuildEventContext.NodeId;
-            int projectContextId = e.BuildEventContext.ProjectContextId;
+            int nodeID = buildEventContext.NodeId;
+            int projectContextId = buildEventContext.ProjectContextId;
 
-            // Create the value to be added to the propertyOutputMap.
-            using var projectConfigurationDescription = new ReuseableStringBuilder();
+            ReuseableStringBuilder projectConfigurationDescription = null;
 
-            foreach (DictionaryEntry item in e.Items)
+            Internal.Utilities.EnumerateItems(items, item =>
             {
-                ITaskItem itemVal = (ITaskItem)item.Value;
                 // Determine if the LogOutputProperties item has been used.
                 if (string.Equals((string)item.Key, ItemMetadataNames.ProjectConfigurationDescription, StringComparison.OrdinalIgnoreCase))
                 {
+                    if (projectConfigurationDescription == null)
+                    {
+                        projectConfigurationDescription = new ReuseableStringBuilder();
+                    }
+
+                    string itemSpec = item.Value switch
+                    {
+                        IItem iitem => iitem.EvaluatedInclude, // ProjectItem
+                        ITaskItem taskItem => taskItem.ItemSpec, // ProjectItemInstance
+                        _ => throw new NotSupportedException(Convert.ToString(item.Value))
+                    };
+
                     // Add the item value to the string to be printed in error/warning messages.
-                    projectConfigurationDescription.Append(" ").Append(itemVal.ItemSpec);
+                    projectConfigurationDescription.Append(" ").Append(itemSpec);
                 }
-            }
+            });
+
             // Add the finished dictionary to propertyOutputMap.
-            propertyOutputMap.Add((nodeID, projectContextId), projectConfigurationDescription.ToString());
+            if (projectConfigurationDescription != null)
+            {
+                propertyOutputMap.Add((nodeID, projectContextId), projectConfigurationDescription.ToString());
+                (projectConfigurationDescription as IDisposable)?.Dispose();
+            }
         }
 
         /// <summary>
@@ -1117,25 +1139,36 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
 
         public override void StatusEventHandler(object sender, BuildStatusEventArgs e)
         {
-            if (showPerfSummary)
+            if (e is ProjectEvaluationStartedEventArgs projectEvaluationStarted)
             {
-                ProjectEvaluationStartedEventArgs projectEvaluationStarted = e as ProjectEvaluationStartedEventArgs;
-
-                if (projectEvaluationStarted != null)
+                if (showPerfSummary)
                 {
                     MPPerformanceCounter counter = GetPerformanceCounter(projectEvaluationStarted.ProjectFile, ref projectEvaluationPerformanceCounters);
                     counter.AddEventStarted(null, e.BuildEventContext, e.Timestamp, s_compareContextNodeId);
-
-                    return;
                 }
-
-                ProjectEvaluationFinishedEventArgs projectEvaluationFinished = e as ProjectEvaluationFinishedEventArgs;
-
-                if (projectEvaluationFinished != null)
+            }
+            else if (e is ProjectEvaluationFinishedEventArgs projectEvaluationFinished)
+            {
+                if (showPerfSummary)
                 {
                     MPPerformanceCounter counter = GetPerformanceCounter(projectEvaluationFinished.ProjectFile, ref projectEvaluationPerformanceCounters);
                     counter.AddEventFinished(null, e.BuildEventContext, e.Timestamp);
                 }
+
+                if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
+                {
+                    if (projectEvaluationFinished.Properties != null)
+                    {
+                        WriteProperties(projectEvaluationFinished, projectEvaluationFinished.Properties);
+                    }
+
+                    if (projectEvaluationFinished.Items != null)
+                    {
+                        WriteItems(projectEvaluationFinished, projectEvaluationFinished.Items);
+                    }
+                }
+
+                ReadProjectConfigurationDescription(projectEvaluationFinished.BuildEventContext, projectEvaluationFinished.Items);
             }
         }
 
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 50dd953d5e3..c47c5ed976d 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -571,25 +571,36 @@ public override void CustomEventHandler(object sender, CustomBuildEventArgs e)
 
         public override void StatusEventHandler(object sender, BuildStatusEventArgs e)
         {
-            if (showPerfSummary)
+            if (e is ProjectEvaluationStartedEventArgs projectEvaluationStarted)
             {
-                ProjectEvaluationStartedEventArgs projectEvaluationStarted = e as ProjectEvaluationStartedEventArgs;
-
-                if (projectEvaluationStarted != null)
+                if (showPerfSummary)
                 {
                     PerformanceCounter counter = GetPerformanceCounter(projectEvaluationStarted.ProjectFile, ref projectEvaluationPerformanceCounters);
                     counter.InScope = true;
-
-                    return;
                 }
-
-                ProjectEvaluationFinishedEventArgs projectEvaluationFinished = e as ProjectEvaluationFinishedEventArgs;
-
-                if (projectEvaluationFinished != null)
+            }
+            else if (e is ProjectEvaluationFinishedEventArgs projectEvaluationFinished)
+            {
+                if (showPerfSummary)
                 {
                     PerformanceCounter counter = GetPerformanceCounter(projectEvaluationFinished.ProjectFile, ref projectEvaluationPerformanceCounters);
                     counter.InScope = false;
                 }
+
+                if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
+                {
+                    if (projectEvaluationFinished.Properties != null)
+                    {
+                        var propertyList = ExtractPropertyList(projectEvaluationFinished.Properties);
+                        WriteProperties(propertyList);
+                    }
+
+                    if (projectEvaluationFinished.Items != null)
+                    {
+                        SortedList itemList = ExtractItemList(projectEvaluationFinished.Items);
+                        WriteItems(itemList);
+                    }
+                }
             }
         }
 
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index 6aae23a460e..325dc50740a 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -2,14 +2,16 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Xml;
+using System.Diagnostics;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
+using System.Xml;
 
 using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using Toolset = Microsoft.Build.Evaluation.Toolset;
@@ -613,5 +615,116 @@ public static T[] ToArray<T>(this IEnumerator<T> enumerator)
         {
             return enumerator.ToEnumerable().ToArray();
         }
+
+        public static void EnumerateProperties(IEnumerable properties, Action<KeyValuePair<string, string>> callback)
+        {
+            if (properties == null)
+            {
+                return;
+            }
+
+            if (properties is PropertyDictionary<ProjectPropertyInstance> propertyInstanceDictionary)
+            {
+                propertyInstanceDictionary.Enumerate((key, value) =>
+                {
+                    callback(new KeyValuePair<string, string>(key, value));
+                });
+            }
+            else if (properties is PropertyDictionary<ProjectProperty> propertyDictionary)
+            {
+                propertyDictionary.Enumerate((key, value) =>
+                {
+                    callback(new KeyValuePair<string, string>(key, value));
+                });
+            }
+            else
+            {
+                foreach (var item in properties)
+                {
+                    if (item is IProperty property && !string.IsNullOrEmpty(property.Name))
+                    {
+                        callback(new KeyValuePair<string, string>(property.Name, property.EvaluatedValue ?? string.Empty));
+                    }
+                    else if (item is DictionaryEntry dictionaryEntry && dictionaryEntry.Key is string key && !string.IsNullOrEmpty(key))
+                    {
+                        callback(new KeyValuePair<string, string>(key, dictionaryEntry.Value as string ?? string.Empty));
+                    }
+                    else if (item is KeyValuePair<string, string> kvp)
+                    {
+                        callback(kvp);
+                    }
+                    else
+                    {
+                        if (item == null)
+                        {
+                            Debug.Fail($"In {nameof(EnumerateProperties)}(): Unexpected: property is null");
+                        }
+                        else
+                        {
+                            Debug.Fail($"In {nameof(EnumerateProperties)}(): Unexpected property {item} of type {item?.GetType().ToString()}");
+                        }
+                    }
+                }
+            }
+        }
+
+        public static void EnumerateItems(IEnumerable items, Action<DictionaryEntry> callback)
+        {
+            if (items is ItemDictionary<ProjectItemInstance> projectItemInstanceDictionary)
+            {
+                projectItemInstanceDictionary.EnumerateItemsPerType((itemType, itemList) =>
+                {
+                    foreach (var item in itemList)
+                    {
+                        callback(new DictionaryEntry(itemType, item));
+                    }
+                });
+            }
+            else if (items is ItemDictionary<ProjectItem> projectItemDictionary)
+            {
+                projectItemDictionary.EnumerateItemsPerType((itemType, itemList) =>
+                {
+                    foreach (var item in itemList)
+                    {
+                        callback(new DictionaryEntry(itemType, item));
+                    }
+                });
+            }
+            else
+            {
+                foreach (var item in items)
+                {
+                    string itemType = default;
+                    object itemValue = null;
+
+                    if (item is IItem iitem)
+                    {
+                        itemType = iitem.Key;
+                        itemValue = iitem;
+                    }
+                    else if (item is DictionaryEntry dictionaryEntry)
+                    {
+                        itemType = dictionaryEntry.Key as string;
+                        itemValue = dictionaryEntry.Value;
+                    }
+                    else
+                    {
+                        if (item == null)
+                        {
+                            Debug.Fail($"In {nameof(EnumerateItems)}(): Unexpected: {nameof(item)} is null");
+                        }
+                        else
+                        {
+                            Debug.Fail($"In {nameof(EnumerateItems)}(): Unexpected {nameof(item)} {item} of type {item?.GetType().ToString()}");
+                        }
+                    }
+
+                    if (!String.IsNullOrEmpty(itemType))
+                    {
+                        callback(new DictionaryEntry(itemType, itemValue));
+                    }
+                }
+            }
+        }
     }
 }
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index 58dc81f838a..06e71865122 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -116,7 +116,7 @@ public DateTime Timestamp
         /// Used for serialization. Avoids the side effects of calling the
         /// <see cref="Timestamp"/> getter.
         /// </summary>
-        protected DateTime RawTimestamp
+        protected internal DateTime RawTimestamp
         {
             get => timestamp;
             set => timestamp = value;
diff --git a/src/Framework/IEventSource4.cs b/src/Framework/IEventSource4.cs
new file mode 100644
index 00000000000..3b6cc009be4
--- /dev/null
+++ b/src/Framework/IEventSource4.cs
@@ -0,0 +1,19 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// This interface defines the events raised by the build engine.
+    /// Loggers use this interface to subscribe to the events they
+    /// are interested in receiving.
+    /// </summary>
+    public interface IEventSource4 : IEventSource3
+    {
+        /// <summary>
+        /// Determines whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>.
+        /// </summary>
+        void IncludeEvaluationPropertiesAndItems();
+    }
+}
diff --git a/src/Framework/ProjectEvaluationFinishedEventArgs.cs b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
index 1d900b49c03..88073ecf3ac 100644
--- a/src/Framework/ProjectEvaluationFinishedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using Microsoft.Build.Framework.Profiler;
 
 namespace Microsoft.Build.Framework
@@ -23,7 +24,7 @@ public ProjectEvaluationFinishedEventArgs()
         /// Initializes a new instance of the ProjectEvaluationFinishedEventArgs class.
         /// </summary>
         public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs)
-            : base(message, null, null, DateTime.UtcNow, messageArgs)
+            : base(message, helpKeyword: null, senderName: null, DateTime.UtcNow, messageArgs)
         {
         }
 
@@ -32,12 +33,27 @@ public ProjectEvaluationFinishedEventArgs(string message, params object[] messag
         /// </summary>
         public string ProjectFile { get; set; }
 
+        /// <summary>
+        /// Global properties used during this evaluation.
+        /// </summary>
+        public IEnumerable GlobalProperties { get; set; }
+
+        /// <summary>
+        /// Final set of properties produced by this evaluation.
+        /// </summary>
+        public IEnumerable Properties { get; set; }
+
+        /// <summary>
+        /// Final set of items produced by this evaluation.
+        /// </summary>
+        public IEnumerable Items { get; set; }
+
         /// <summary>
         /// The result of profiling a project.
         /// </summary>
         /// <remarks>
         /// Null if profiling is not turned on
         /// </remarks>
-        public ProfilerResult? ProfilerResult { get; set; } 
+        public ProfilerResult? ProfilerResult { get; set; }
     }
 }
diff --git a/src/Framework/ProjectEvaluationStartedEventArgs.cs b/src/Framework/ProjectEvaluationStartedEventArgs.cs
index 80332d2c4f4..14100183747 100644
--- a/src/Framework/ProjectEvaluationStartedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationStartedEventArgs.cs
@@ -22,7 +22,7 @@ public ProjectEvaluationStartedEventArgs()
         /// Initializes a new instance of the ProjectEvaluationStartedEventArgs class.
         /// </summary>
         public ProjectEvaluationStartedEventArgs(string message, params object[] messageArgs)
-            : base(message, null, null, DateTime.UtcNow, messageArgs)
+            : base(message, helpKeyword: null, senderName: null, DateTime.UtcNow, messageArgs)
         {
         }
 
diff --git a/src/MSBuild.UnitTests/PerfLog_Tests.cs b/src/MSBuild.UnitTests/PerfLog_Tests.cs
index b39f192a446..be18d7b6a47 100644
--- a/src/MSBuild.UnitTests/PerfLog_Tests.cs
+++ b/src/MSBuild.UnitTests/PerfLog_Tests.cs
@@ -74,7 +74,7 @@ public void TestPerfLogEnabledProducedLogFile()
         }
 
         [Fact]
-        public void TestPerfLogDirectoryDoesNotExist()
+        public void TestPerfLogDirectoryGetsCreated()
         {
             using (TestEnvironment testEnv = TestEnvironment.Create(_output))
             {
@@ -101,7 +101,7 @@ public void TestPerfLogDirectoryDoesNotExist()
                 RunnerUtilities.ExecMSBuild(msbuildParameters, out bool successfulExit);
                 successfulExit.ShouldBeTrue();
 
-                Directory.Exists(perfLogPath).ShouldBeFalse();
+                Directory.Exists(perfLogPath).ShouldBeTrue();
             }
         }
     }
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index b3c65a114a6..e014f5652e3 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -2108,6 +2108,106 @@ public void RestoreIgnoresMissingImports()
             logContents.ShouldContain(guid2);
         }
 
+        /// <summary>
+        /// When specifying /t:restore, fail when an SDK can't be resolved.  Previous behavior was to try and continue anyway but then "restore" would succeed and build workflows continue on.
+        /// </summary>
+        [Fact]
+        public void RestoreFailsOnUnresolvedSdk()
+        {
+            string projectContents = ObjectModelHelpers.CleanupFileContents(
+$@"<Project>
+  <Sdk Name=""UnresolvedSdk"" />
+  <Target Name=""Restore"">
+    <Message Text=""Restore target ran"" />
+  </Target>
+</Project>");
+
+            string logContents = ExecuteMSBuildExeExpectFailure(projectContents, arguments: "/t:restore");
+
+            logContents.ShouldContain("error MSB4236: The SDK 'UnresolvedSdk' specified could not be found.");
+        }
+
+        /// <summary>
+        /// Verifies a non-existent target doesn't fail restore as long as its not considered an entry target, in this case Restore.
+        /// </summary>
+        [Fact]
+        public void RestoreSkipsNonExistentNonEntryTargets()
+        {
+            string restoreFirstProps = $"{Guid.NewGuid():N}.props";
+
+            string projectContents = ObjectModelHelpers.CleanupFileContents(
+$@"<Project DefaultTargets=""Build"" InitialTargets=""TargetThatComesFromRestore"">
+  <PropertyGroup>
+    <RestoreFirstProps>{restoreFirstProps}</RestoreFirstProps>
+  </PropertyGroup>
+  
+  <Import Project=""$(RestoreFirstProps)"" />
+  <Target Name=""Restore"">
+    <Message Text=""Restore target ran"" />
+    <ItemGroup>
+      <Lines Include=""&lt;Project&gt;&lt;Target Name=&quot;TargetThatComesFromRestore&quot;&gt;&lt;Message Text=&quot;Initial target ran&quot; /&gt;&lt;/Target&gt;&lt;/Project&gt;"" />
+    </ItemGroup>
+    
+    <WriteLinesToFile File=""$(RestoreFirstProps)"" Lines=""@(Lines)"" Overwrite=""true"" />
+  </Target>
+
+  <Target Name=""Build"">
+    <Message Text=""Build target ran&quot;"" />
+  </Target>
+</Project>");
+
+            string logContents = ExecuteMSBuildExeExpectSuccess(projectContents, arguments: "/restore");
+
+            logContents.ShouldContain("Restore target ran");
+            logContents.ShouldContain("Build target ran");
+            logContents.ShouldContain("Initial target ran");
+        }
+
+        /// <summary>
+        /// Verifies restore will fail if the entry target doesn't exist, in this case Restore.
+        /// </summary>
+        [Fact]
+        public void RestoreFailsWhenEntryTargetIsNonExistent()
+        {
+            string projectContents = ObjectModelHelpers.CleanupFileContents(
+@"<Project DefaultTargets=""Build"">
+  <Target Name=""Build"">
+    <Message Text=""Build target ran&quot;"" />
+  </Target>
+</Project>");
+
+            string logContents = ExecuteMSBuildExeExpectFailure(projectContents, arguments: "/t:restore");
+            
+            logContents.ShouldContain("error MSB4057: The target \"Restore\" does not exist in the project.");
+        }
+
+        /// <summary>
+        /// Verifies restore will run InitialTargets.
+        /// </summary>
+        [Fact]
+        public void RestoreRunsInitialTargets()
+        {
+            string projectContents = ObjectModelHelpers.CleanupFileContents(
+                @"<Project DefaultTargets=""Build"" InitialTargets=""InitialTarget"">
+  <Target Name=""InitialTarget"">
+    <Message Text=""InitialTarget target ran&quot;"" />
+  </Target>
+
+  <Target Name=""Restore"">
+    <Message Text=""Restore target ran&quot;"" />
+  </Target>
+
+  <Target Name=""Build"">
+    <Message Text=""Build target ran&quot;"" />
+  </Target>
+</Project>");
+
+            string logContents = ExecuteMSBuildExeExpectSuccess(projectContents, arguments: "/t:restore");
+
+            logContents.ShouldContain("InitialTarget target ran");
+            logContents.ShouldContain("Restore target ran");
+        }
+
         /// <summary>
         /// We check if there is only one target name specified and this logic caused a regression: https://github.com/Microsoft/msbuild/issues/3317
         /// </summary>
@@ -2312,6 +2412,24 @@ private string CopyMSBuild()
         }
 
         private string ExecuteMSBuildExeExpectSuccess(string projectContents, IDictionary<string, string> filesToCreate = null,  IDictionary<string, string> envsToCreate = null, params string[] arguments)
+        {
+            (bool result, string output) = ExecuteMSBuildExe(projectContents, filesToCreate, envsToCreate, arguments);
+
+            result.ShouldBeTrue(() => output);
+
+            return output;
+        }
+
+        private string ExecuteMSBuildExeExpectFailure(string projectContents, IDictionary<string, string> filesToCreate = null, IDictionary<string, string> envsToCreate = null, params string[] arguments)
+        {
+            (bool result, string output) = ExecuteMSBuildExe(projectContents, filesToCreate, envsToCreate, arguments);
+
+            result.ShouldBeFalse(() => output);
+
+            return output;
+        }
+
+        private (bool result, string output) ExecuteMSBuildExe(string projectContents, IDictionary<string, string> filesToCreate = null, IDictionary<string, string> envsToCreate = null, params string[] arguments)
         {
             using (TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create())
             {
@@ -2336,10 +2454,8 @@ private string ExecuteMSBuildExeExpectSuccess(string projectContents, IDictionar
                 bool success;
 
                 string output = RunnerUtilities.ExecMSBuild($"\"{testProject.ProjectFile}\" {String.Join(" ", arguments)}", out success, _output);
-
-                success.ShouldBeTrue(() => output);
-
-                return output;
+                
+                return (success, output);
             }
         }
     }
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index af98f64d8bc..912ca4f12ef 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -40,6 +40,7 @@
     <AddAppConfigToBuildOutputs>false</AddAppConfigToBuildOutputs>
 
     <DebugType Condition="'$(Platform)' == 'x64'">full</DebugType><!-- Setting DebugType here goes hand in hand with eng\AfterSigning.targets. This is to prompt the x64 build to produce a 'full' .pdb that's `more compatible` then 'portable' and 'embedded' .pdbs. This doesn't get set on 32 bit architecture, which will default to 'embedded' and 'pdb2pdb' will convert those as needed. See https://github.com/microsoft/msbuild/pull/5070 for context. -->
+    <DefineConstants>$(DefineConstants);MSBUILDENTRYPOINTEXE</DefineConstants>
   </PropertyGroup>
 
   <PropertyGroup>
diff --git a/src/MSBuild/PerformanceLogEventListener.cs b/src/MSBuild/PerformanceLogEventListener.cs
index a9ffec3aae4..b3857fd50f4 100644
--- a/src/MSBuild/PerformanceLogEventListener.cs
+++ b/src/MSBuild/PerformanceLogEventListener.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using System.Text;
 using Microsoft.Build.Eventing;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.CommandLine
 {
@@ -51,7 +52,8 @@ internal static PerformanceLogEventListener Create()
 
                 // Check to see if we should enable the event listener.
                 string logDirectory = Environment.GetEnvironmentVariable(PerfLogDirEnvVar);
-                if (Directory.Exists(logDirectory))
+
+                if (!string.IsNullOrEmpty(logDirectory) && Directory.CreateDirectory(logDirectory).Exists)
                 {
                     eventListener = new PerformanceLogEventListener();
                     eventListener.Initialize(logDirectory);
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index f991888ab0c..0e870bd61ff 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -676,7 +676,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 3357d17f9e5..a5418bc3735 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -1542,7 +1542,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1552,7 +1552,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serializuje všechny události sestavení do komprimovaného
                      binárního souboru. Tento soubor se standardně nachází
                      v aktuálním adresáři a má název msbuild.binlog. Binární
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 25bbe5047ee..fe6379ae049 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1534,7 +1534,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1544,7 +1544,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serialisiert alle Buildereignisse in eine komprimierte Binärdatei.
                      Standardmäßig befindet sich die Datei im aktuellen Verzeichnis und hat den Namen
                      "msbuild.binlog". Das binäre Protokoll ist eine detaillierte Beschreibung
diff --git a/src/MSBuild/Resources/xlf/Strings.en.xlf b/src/MSBuild/Resources/xlf/Strings.en.xlf
index 0a83c78326a..311a846f81f 100644
--- a/src/MSBuild/Resources/xlf/Strings.en.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.en.xlf
@@ -1045,7 +1045,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1088,7 +1088,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 9c43f2e54c7..0788961b4a8 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1543,7 +1543,7 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1553,7 +1553,7 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serializa todos los eventos de compilación en un archivo
                      binario comprimido. De manera predeterminada,
                      el archivo se encuentra en el directorio actual y tiene
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 8dffc1dcb1f..df3bc2b872b 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1536,7 +1536,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1546,7 +1546,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Sérialise tous les événements de build dans un fichier binaire compressé.
                      Par défaut, le fichier se trouve dans le répertoire actif et se nomme
                      "msbuild.binlog". Le journal binaire est une description détaillée
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 86e4bea0a6f..4923a3f18f9 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -1557,7 +1557,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1567,7 +1567,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serializza tutti gli eventi di compilazione in un file
                      binario compresso. Per impostazione predefinita, il file
                      si trova nella directory corrente e si chiama
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 1e8e62c4691..e968c0b1817 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1534,7 +1534,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1544,7 +1544,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      すべてのビルド イベントを圧縮バイナリ ファイルにシリアル化します。
                      既定では、このファイルは "msbuild.binlog" という名前で
                      現在のディレクトリに置かれます。バイナリ ログはビルド プロセスの
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 365eb71c56d..6d33e3f9d3e 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1534,7 +1534,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1544,7 +1544,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      모든 빌드 이벤트를 압축된 이진 파일로 직렬화합니다.
                      기본적으로 이 파일은 현재 디렉터리에 있으며 이름은
                      "msbuild.binlog"입니다. 이진 로그는 빌드 프로세스를
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 160f1b243b0..fb78441f4de 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -1547,7 +1547,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1557,7 +1557,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]wyjście.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]wyjście.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serializuje wszystkie zdarzenia kompilacji do skompresowanego pliku
                      binarnego. Domyślnie plik znajduje się w bieżącym katalogu i ma
                      nazwę „msbuild.binlog”. Dziennik binarny to szczegółowy opis procesu
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index fae30f6dafe..f7a427098f7 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1535,7 +1535,7 @@ isoladamente.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1545,7 +1545,7 @@ isoladamente.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serializa todos os eventos de build para um arquivo binário compactado.
                      Por padrão, o arquivo está no diretório atual e é chamado de
                      "msbuild.binlog". O log binário é uma descrição detalhada 
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 2bdd38238f4..33cc6ef1ea5 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1536,7 +1536,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1546,7 +1546,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Сериализует все события сборки в сжатый двоичный файл.
                      По умолчанию файл находится в текущем каталоге и называется
                      "msbuild.binlog". Двоичный журнал включает подробное описание
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 202406cbc31..712b6560fe7 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1538,7 +1538,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1548,7 +1548,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Tüm derleme olaylarını sıkıştırılmış bir ikili dosyada seri hale getirir.
                      Varsayılan olarak, dosya geçerli dizinde bulunur ve "msbuild.binlog"
                      olarak adlandırılır. Daha sonra metin günlüklerini yeniden
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 4ce44b14456..2118653f1f7 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1534,7 +1534,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1544,7 +1544,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      将所有生成事件序列化为压缩的二进制文件。
                      默认情况下该文件位于当前目录并且名为 "msbuild.binlog"。
                      二进制日志是生成过程的详细描述，
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 8b0536d6981..4bf83939d3a 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1534,7 +1534,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
                      Other loggers will receive the information contained
                      in the log file as if the original build was happening.
                      You can read more about the binary log and its usages at:
-                     https://github.com/Microsoft/msbuild/wiki/Binary-Log
+                     https://aka.ms/msbuild/binlog
 
                      Examples:
                        -bl
@@ -1544,7 +1544,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
                        -bl:..\..\custom.binlog
                        -binaryLogger
     </source>
-        <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
+        <target state="needs-review-translation">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                     將所有建置事件序列化成壓縮的二進位檔案。
                      根據預設，此檔案存放在目前的目錄下，
                      並會命名為 "msbuild.binlog"。此二進位記錄檔是
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index f6e3bc27f4b..792410a9964 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1422,16 +1422,19 @@ private static (BuildResultCode result, Exception exception) ExecuteRestore(stri
 
             // Create a new request with a Restore target only and specify:
             //  - BuildRequestDataFlags.ClearCachesAfterBuild to ensure the projects will be reloaded from disk for subsequent builds
-            //  - BuildRequestDataFlags.SkipNonexistentTargets to ignore missing targets since Restore does not require that all targets exist
+            //  - BuildRequestDataFlags.SkipNonexistentNonEntryTargets to ignore missing non-entry targets since Restore does not require that all targets
+            //      exist, only top-level ones like Restore itself
             //  - BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports to ignore imports that don't exist, are empty, or are invalid because restore might
             //     make available an import that doesn't exist yet and the <Import /> might be missing a condition.
+            //  - BuildRequestDataFlags.FailOnUnresolvedSdk to still fail in the case when an MSBuild project SDK can't be resolved since this is fatal and should
+            //     fail the build.
             BuildRequestData restoreRequest = new BuildRequestData(
                 projectFile,
                 restoreGlobalProperties,
                 toolsVersion,
                 targetsToBuild: new[] { MSBuildConstants.RestoreTargetName },
                 hostServices: null,
-                flags: BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports);
+                flags: BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentNonEntryTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports | BuildRequestDataFlags.FailOnUnresolvedSdk);
 
             return ExecuteBuild(buildManager, restoreRequest);
         }
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index d8b2c66c98d..eea2401dca9 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -166,6 +166,10 @@ internal static class ItemMetadataNames
         internal const string subType = "SubType";
         internal const string executableExtension = "ExecutableExtension";
         internal const string embedInteropTypes = "EmbedInteropTypes";
+
+        /// <summary>
+        /// The output path for a given item.
+        /// </summary>
         internal const string targetPath = "TargetPath";
         internal const string dependentUpon = "DependentUpon";
         internal const string msbuildSourceProjectFile = "MSBuildSourceProjectFile";
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index cf40546ec51..707657933d1 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -1031,27 +1031,55 @@ internal static string MakeRelative(string basePath, string path)
             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));
             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
 
-            if (basePath.Length == 0)
-            {
-                return path;
-            }
+            string fullBase = Path.GetFullPath(basePath);
+            string fullPath = Path.GetFullPath(path);
+
+            string[] splitBase = fullBase.Split(MSBuildConstants.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);
+            string[] splitPath = fullPath.Split(MSBuildConstants.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);
 
-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException
+            ErrorUtilities.VerifyThrow(splitPath.Length > 0, "Cannot call MakeRelative on a path of only slashes.");
 
-            Uri pathUri = CreateUriFromPath(path);
+            // On a mac, the path could start with any number of slashes and still be valid. We have to check them all.
+            int indexOfFirstNonSlashChar = 0;
+            while (path[indexOfFirstNonSlashChar] == Path.DirectorySeparatorChar)
+            {
+                indexOfFirstNonSlashChar++;
+            }
+            if (path.IndexOf(splitPath[0]) != indexOfFirstNonSlashChar)
+            {
+                // path was already relative so just return it
+                return FixFilePath(path);
+            }
 
-            if (!pathUri.IsAbsoluteUri)
+            int index = 0;
+            while (index < splitBase.Length && index < splitPath.Length && splitBase[index].Equals(splitPath[index], PathComparison))
             {
-                // the path is already a relative url, we will just normalize it...
-                pathUri = new Uri(baseUri, pathUri);
+                index++;
             }
 
-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);
-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());
+            if (index == splitBase.Length && index == splitPath.Length)
+            {
+                return ".";
+            }
+            
+            // If the paths have no component in common, the only valid relative path is the full path.
+            if (index == 0)
+            {
+                return fullPath;
+            }
 
-            string result = relativePath.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
+            StringBuilder sb = StringBuilderCache.Acquire();
 
-            return result;
+            for (int i = index; i < splitBase.Length; i++)
+            {
+                sb.Append("..").Append(Path.DirectorySeparatorChar);
+            }
+            for (int i = index; i < splitPath.Length; i++)
+            {
+                sb.Append(splitPath[i]).Append(Path.DirectorySeparatorChar);
+            }
+            sb.Length--;
+            return StringBuilderCache.GetStringAndRelease(sb);
         }
 
         /// <summary>
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index ab68c229c04..449f54c4dd2 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -2,12 +2,21 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Reflection;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Framework;
+
+#if !TASKHOST
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework.Profiler;
+using Microsoft.Build.Execution;
+#endif
+
 #if FEATURE_APPDOMAIN
 using TaskEngineAssemblyResolver = Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver;
 #endif
@@ -95,6 +104,16 @@ internal enum LoggingEventType : int
         /// Event is a TaskParameterEventArgs
         /// </summary>
         TaskParameterEvent = 13,
+
+        /// <summary>
+        /// Event is a ProjectEvaluationStartedEventArgs
+        /// </summary>
+        ProjectEvaluationStartedEvent = 14,
+
+        /// <summary>
+        /// Event is a ProjectEvaluationFinishedEventArgs
+        /// </summary>
+        ProjectEvaluationFinishedEvent = 15
     }
     #endregion
 
@@ -296,6 +315,17 @@ internal void WriteToStream(ITranslator translator)
                 translator.Translate(ref packetVersion);
 
                 bool eventCanSerializeItself = methodInfo != null;
+
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+                if (_buildEvent is ProjectEvaluationStartedEventArgs ||
+                    _buildEvent is ProjectEvaluationFinishedEventArgs)
+                {
+                    // switch to serialization methods that we provide in this file
+                    // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
+                    eventCanSerializeItself = false;
+                }
+#endif
+
                 translator.Translate(ref eventCanSerializeItself);
 
                 if (eventCanSerializeItself)
@@ -464,40 +494,27 @@ private static Delegate CreateDelegateRobust(Type type, Object firstArgument, Me
         /// </summary>
         private BuildEventArgs GetBuildEventArgFromId()
         {
-            switch (_eventType)
+            return _eventType switch
             {
-                case LoggingEventType.BuildErrorEvent:
-                    return new BuildErrorEventArgs(null, null, null, -1, -1, -1, -1, null, null, null);
-                case LoggingEventType.BuildFinishedEvent:
-                    return new BuildFinishedEventArgs(null, null, false);
-                case LoggingEventType.BuildMessageEvent:
-                    return new BuildMessageEventArgs(null, null, null, MessageImportance.Normal);
-                case LoggingEventType.BuildStartedEvent:
-                    return new BuildStartedEventArgs(null, null);
-                case LoggingEventType.BuildWarningEvent:
-                    return new BuildWarningEventArgs(null, null, null, -1, -1, -1, -1, null, null, null);
-                case LoggingEventType.ProjectFinishedEvent:
-                    return new ProjectFinishedEventArgs(null, null, null, false);
-                case LoggingEventType.ProjectStartedEvent:
-                    return new ProjectStartedEventArgs(null, null, null, null, null, null);
-                case LoggingEventType.TargetStartedEvent:
-                    return new TargetStartedEventArgs(null, null, null, null, null);
-                case LoggingEventType.TargetFinishedEvent:
-                    return new TargetFinishedEventArgs(null, null, null, null, null, false);
-                case LoggingEventType.TaskStartedEvent:
-                    return new TaskStartedEventArgs(null, null, null, null, null);
-                case LoggingEventType.TaskFinishedEvent:
-                    return new TaskFinishedEventArgs(null, null, null, null, null, false);
-                case LoggingEventType.TaskCommandLineEvent:
-                    return new TaskCommandLineEventArgs(null, null, MessageImportance.Normal);
+                LoggingEventType.BuildErrorEvent => new BuildErrorEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),
+                LoggingEventType.BuildFinishedEvent => new BuildFinishedEventArgs(null, null, false),
+                LoggingEventType.BuildMessageEvent => new BuildMessageEventArgs(null, null, null, MessageImportance.Normal),
+                LoggingEventType.BuildStartedEvent => new BuildStartedEventArgs(null, null),
+                LoggingEventType.BuildWarningEvent => new BuildWarningEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),
+                LoggingEventType.ProjectFinishedEvent => new ProjectFinishedEventArgs(null, null, null, false),
+                LoggingEventType.ProjectStartedEvent => new ProjectStartedEventArgs(null, null, null, null, null, null),
+                LoggingEventType.TargetStartedEvent => new TargetStartedEventArgs(null, null, null, null, null),
+                LoggingEventType.TargetFinishedEvent => new TargetFinishedEventArgs(null, null, null, null, null, false),
+                LoggingEventType.TaskStartedEvent => new TaskStartedEventArgs(null, null, null, null, null),
+                LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
+                LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
-                case LoggingEventType.TaskParameterEvent:
-                    return new TaskParameterEventArgs(0, null, null, true, default);
+                LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
+                LoggingEventType.ProjectEvaluationStartedEvent => new ProjectEvaluationStartedEventArgs(),
+                LoggingEventType.ProjectEvaluationFinishedEvent => new ProjectEvaluationFinishedEventArgs(),
 #endif
-                default:
-                    ErrorUtilities.VerifyThrow(false, "Should not get to the default of GetBuildEventArgFromId ID: " + _eventType);
-                    return null;
-            }
+                _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
+            };
         }
 
         /// <summary>
@@ -532,6 +549,16 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.ProjectStartedEvent;
             }
+#if !TASKHOST
+            else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))
+            {
+                return LoggingEventType.ProjectEvaluationFinishedEvent;
+            }
+            else if (eventType == typeof(ProjectEvaluationStartedEventArgs))
+            {
+                return LoggingEventType.ProjectEvaluationStartedEvent;
+            }
+#endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
                 return LoggingEventType.TargetStartedEvent;
@@ -576,6 +603,19 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
         /// </summary>
         private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType eventType, ITranslator translator)
         {
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+            if (eventType == LoggingEventType.ProjectEvaluationStartedEvent)
+            {
+                WriteProjectEvaluationStartedEventToStream((ProjectEvaluationStartedEventArgs)buildEvent, translator);
+                return;
+            }
+            else if (eventType == LoggingEventType.ProjectEvaluationFinishedEvent)
+            {
+                WriteProjectEvaluationFinishedEventToStream((ProjectEvaluationFinishedEventArgs)buildEvent, translator);
+                return;
+            }
+#endif
+
             string message = buildEvent.Message;
             string helpKeyword = buildEvent.HelpKeyword;
             string senderName = buildEvent.SenderName;
@@ -715,6 +755,207 @@ private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEv
             translator.TranslateEnum(ref importance, (int)importance);
         }
 
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+        private void WriteProjectEvaluationStartedEventToStream(ProjectEvaluationStartedEventArgs args, ITranslator translator)
+        {
+            WriteEvaluationEvent(args, args.ProjectFile, args.RawTimestamp, translator);
+        }
+
+        private void WriteProjectEvaluationFinishedEventToStream(ProjectEvaluationFinishedEventArgs args, ITranslator translator)
+        {
+            WriteEvaluationEvent(args, args.ProjectFile, args.RawTimestamp, translator);
+
+            WriteProperties(args.GlobalProperties, translator);
+            WriteProperties(args.Properties, translator);
+            WriteItems(args.Items, translator);
+            WriteProfileResult(args.ProfilerResult, translator);
+        }
+
+        private static void WriteEvaluationEvent(BuildStatusEventArgs args, string projectFile, DateTime timestamp, ITranslator translator)
+        {
+            var buildEventContext = args.BuildEventContext;
+            translator.Translate(ref buildEventContext);
+            translator.Translate(ref timestamp);
+            translator.Translate(ref projectFile);
+        }
+
+        private void WriteProfileResult(ProfilerResult? result, ITranslator translator)
+        {
+            bool hasValue = result.HasValue;
+            translator.Translate(ref hasValue);
+            if (hasValue)
+            {
+                var value = result.Value;
+                var count = value.ProfiledLocations.Count;
+                translator.Translate(ref count);
+
+                foreach (var item in value.ProfiledLocations)
+                {
+                    WriteEvaluationLocation(translator, item.Key);
+                    WriteProfiledLocation(translator, item.Value);
+                }
+            }
+        }
+
+        private void WriteEvaluationLocation(ITranslator translator, EvaluationLocation evaluationLocation)
+        {
+            string elementName = evaluationLocation.ElementName;
+            string elementDescription = evaluationLocation.ElementDescription;
+            string evaluationPassDescription = evaluationLocation.EvaluationPassDescription;
+            string file = evaluationLocation.File;
+            int kind = (int)evaluationLocation.Kind;
+            int evaluationPass = (int)evaluationLocation.EvaluationPass;
+            bool lineHasValue = evaluationLocation.Line.HasValue;
+            int line = lineHasValue ? evaluationLocation.Line.Value : 0;
+            long id = evaluationLocation.Id;
+            bool parentIdHasValue = evaluationLocation.ParentId.HasValue;
+            long parentId = parentIdHasValue ? evaluationLocation.ParentId.Value : 0;
+
+            translator.Translate(ref elementName);
+            translator.Translate(ref elementDescription);
+            translator.Translate(ref evaluationPassDescription);
+            translator.Translate(ref file);
+
+            translator.Translate(ref kind);
+            translator.Translate(ref evaluationPass);
+
+            translator.Translate(ref lineHasValue);
+            if (lineHasValue)
+            {
+                translator.Translate(ref line);
+            }
+
+            translator.Translate(ref id);
+            translator.Translate(ref parentIdHasValue);
+            if (parentIdHasValue)
+            {
+                translator.Translate(ref parentId);
+            }
+        }
+
+        private void WriteProfiledLocation(ITranslator translator, ProfiledLocation profiledLocation)
+        {
+            int numberOfHits = profiledLocation.NumberOfHits;
+            TimeSpan exclusiveTime = profiledLocation.ExclusiveTime;
+            TimeSpan inclusiveTime = profiledLocation.InclusiveTime;
+            translator.Translate(ref numberOfHits);
+            translator.Translate(ref exclusiveTime);
+            translator.Translate(ref inclusiveTime);
+        }
+
+        [ThreadStatic]
+        private static List<KeyValuePair<string, string>> reusablePropertyList;
+
+        [ThreadStatic]
+        private static List<(string itemType, object item)> reusableItemList;
+
+        private void WriteProperties(IEnumerable properties, ITranslator translator)
+        {
+            var writer = translator.Writer;
+            if (properties == null)
+            {
+                writer.Write((byte)0);
+                return;
+            }
+
+            if (reusablePropertyList == null)
+            {
+                reusablePropertyList = new List<KeyValuePair<string, string>>();
+            }
+
+            // it is expensive to access a ThreadStatic field every time
+            var list = reusablePropertyList;
+
+            Internal.Utilities.EnumerateProperties(properties, kvp => list.Add(kvp));
+
+            BinaryWriterExtensions.Write7BitEncodedInt(writer, list.Count);
+
+            foreach (var item in list)
+            {
+                writer.Write(item.Key);
+                writer.Write(item.Value);
+            }
+
+            list.Clear();
+        }
+
+        private void WriteItems(IEnumerable items, ITranslator translator)
+        {
+            var writer = translator.Writer;
+            if (items == null)
+            {
+                writer.Write((byte)0);
+                return;
+            }
+
+            if (reusableItemList == null)
+            {
+                reusableItemList = new List<(string itemType, object item)>();
+            }
+
+            var list = reusableItemList;
+
+            Internal.Utilities.EnumerateItems(items, dictionaryEntry =>
+            {
+                list.Add((dictionaryEntry.Key as string, dictionaryEntry.Value));
+            });
+
+            BinaryWriterExtensions.Write7BitEncodedInt(writer, list.Count);
+
+            foreach (var kvp in list)
+            {
+                writer.Write(kvp.itemType);
+                if (kvp.item is ITaskItem taskItem)
+                {
+                    writer.Write(taskItem.ItemSpec);
+                    WriteMetadata(taskItem, writer);
+                }
+                else
+                {
+                    writer.Write(kvp.item?.ToString() ?? "");
+                    writer.Write((byte)0);
+                }
+            }
+
+            list.Clear();
+        }
+
+        private void WriteMetadata(object metadataContainer, BinaryWriter writer)
+        {
+            if (metadataContainer is ITaskItem taskItem)
+            {
+                var metadata = taskItem.EnumerateMetadata();
+
+                if (reusablePropertyList == null)
+                {
+                    reusablePropertyList = new List<KeyValuePair<string, string>>();
+                }
+
+                // it is expensive to access a ThreadStatic field every time
+                var list = reusablePropertyList;
+
+                foreach (var item in metadata)
+                {
+                    list.Add(item);
+                }
+
+                BinaryWriterExtensions.Write7BitEncodedInt(writer, list.Count);
+                foreach (var kvp in list)
+                {
+                    writer.Write(kvp.Key ?? string.Empty);
+                    writer.Write(kvp.Value ?? string.Empty);
+                }
+
+                list.Clear();
+            }
+            else
+            {
+                writer.Write((byte)0);
+            }
+        }
+
+#endif
+
         #endregion
 
         #region Reads from Stream
@@ -725,6 +966,17 @@ private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEv
         /// </summary>
         private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslator translator)
         {
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+            if (eventType == LoggingEventType.ProjectEvaluationStartedEvent)
+            {
+                return ReadProjectEvaluationStartedEventFromStream(translator);
+            }
+            else if (eventType == LoggingEventType.ProjectEvaluationFinishedEvent)
+            {
+                return ReadProjectEvaluationFinishedEventFromStream(translator);
+            }
+#endif
+
             string message = null;
             string helpKeyword = null;
             string senderName = null;
@@ -921,6 +1173,213 @@ private BuildMessageEventArgs ReadBuildMessageEventFromStream(ITranslator transl
             return buildEvent;
         }
 
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+        private ProjectEvaluationStartedEventArgs ReadProjectEvaluationStartedEventFromStream(ITranslator translator)
+        {
+            var (buildEventContext, timestamp, projectFile) = ReadEvaluationEvent(translator);
+
+            var args = new ProjectEvaluationStartedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationStarted"), projectFile);
+
+            args.BuildEventContext = buildEventContext;
+            args.RawTimestamp = timestamp;
+            args.ProjectFile = projectFile;
+
+            return args;
+        }
+
+        private ProjectEvaluationFinishedEventArgs ReadProjectEvaluationFinishedEventFromStream(ITranslator translator)
+        {
+            var (buildEventContext, timestamp, projectFile) = ReadEvaluationEvent(translator);
+
+            var args = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile);
+
+            args.BuildEventContext = buildEventContext;
+            args.RawTimestamp = timestamp;
+            args.ProjectFile = projectFile;
+
+            args.GlobalProperties = ReadProperties(translator);
+            args.Properties = ReadProperties(translator);
+            args.Items = ReadItems(translator);
+            args.ProfilerResult = ReadProfileResult(translator);
+
+            return args;
+        }
+
+        private (BuildEventContext buildEventContext, DateTime timestamp, string projectFile)
+            ReadEvaluationEvent(ITranslator translator)
+        {
+            BuildEventContext buildEventContext = null;
+            translator.Translate(ref buildEventContext);
+
+            DateTime timestamp = default;
+            translator.Translate(ref timestamp);
+
+            string projectFile = null;
+            translator.Translate(ref projectFile);
+
+            return (buildEventContext, timestamp, projectFile);
+        }
+
+        private IEnumerable ReadProperties(ITranslator translator)
+        {
+            var reader = translator.Reader;
+            int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
+            if (count == 0)
+            {
+                return Array.Empty<DictionaryEntry>();
+            }
+
+            var list = new ArrayList(count);
+            for (int i = 0; i < count; i++)
+            {
+                string key = reader.ReadString();
+                string value = reader.ReadString();
+                var entry = new DictionaryEntry(key, value);
+                list.Add(entry);
+            }
+
+            return list;
+        }
+
+        private IEnumerable ReadItems(ITranslator translator)
+        {
+            var reader = translator.Reader;
+
+            int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
+            if (count == 0)
+            {
+                return Array.Empty<DictionaryEntry>();
+            }
+
+            var list = new ArrayList(count);
+            for (int i = 0; i < count; i++)
+            {
+                string itemType = reader.ReadString();
+                string evaluatedValue = reader.ReadString();
+                var metadata = ReadMetadata(reader);
+                var taskItemData = new TaskItemData(evaluatedValue, metadata);
+                var entry = new DictionaryEntry(itemType, taskItemData);
+                list.Add(entry);
+            }
+
+            return list;
+        }
+
+        private IDictionary<string, string> ReadMetadata(BinaryReader reader)
+        {
+            int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
+            if (count == 0)
+            {
+                return null;
+            }
+
+            var list = ArrayDictionary<string, string>.Create(count);
+            for (int i = 0; i < count; i++)
+            {
+                string key = reader.ReadString();
+                string value = reader.ReadString();
+                list.Add(key, value);
+            }
+
+            return list;
+        }
+
+        private ProfilerResult? ReadProfileResult(ITranslator translator)
+        {
+            bool hasValue = false;
+            translator.Translate(ref hasValue);
+            if (!hasValue)
+            {
+                return null;
+            }
+
+            int count = 0;
+            translator.Translate(ref count);
+
+            var dictionary = new ArrayDictionary<EvaluationLocation, ProfiledLocation>(count);
+
+            for (int i = 0; i < count; i++)
+            {
+                var evaluationLocation = ReadEvaluationLocation(translator);
+                var profiledLocation = ReadProfiledLocation(translator);
+                dictionary.Add(evaluationLocation, profiledLocation);
+            }
+
+            var result = new ProfilerResult(dictionary);
+            return result;
+        }
+
+        private EvaluationLocation ReadEvaluationLocation(ITranslator translator)
+        {
+            string elementName = default;
+            string elementDescription = default;
+            string evaluationPassDescription = default;
+            string file = default;
+            int kind = default;
+            int evaluationPass = default;
+            bool lineHasValue = default;
+            int line = default;
+            long id = default;
+            bool parentIdHasValue = default;
+            long parentId = default;
+
+            translator.Translate(ref elementName);
+            translator.Translate(ref elementDescription);
+            translator.Translate(ref evaluationPassDescription);
+            translator.Translate(ref file);
+
+            translator.Translate(ref kind);
+            translator.Translate(ref evaluationPass);
+
+            translator.Translate(ref lineHasValue);
+            if (lineHasValue)
+            {
+                translator.Translate(ref line);
+            }
+
+            translator.Translate(ref id);
+            translator.Translate(ref parentIdHasValue);
+            if (parentIdHasValue)
+            {
+                translator.Translate(ref parentId);
+            }
+
+            var evaluationLocation = new EvaluationLocation(
+                id,
+                parentIdHasValue ? parentId : null,
+                (EvaluationPass)evaluationPass,
+                evaluationPassDescription,
+                file,
+                lineHasValue ? line : null,
+                elementName,
+                elementDescription,
+                (EvaluationLocationKind)kind);
+
+            return evaluationLocation;
+        }
+
+        private ProfiledLocation ReadProfiledLocation(ITranslator translator)
+        {
+            int numberOfHits = default;
+            TimeSpan exclusiveTime = default;
+            TimeSpan inclusiveTime = default;
+
+            translator.Translate(ref numberOfHits);
+            translator.Translate(ref exclusiveTime);
+            translator.Translate(ref inclusiveTime);
+
+            var profiledLocation = new ProfiledLocation(
+                inclusiveTime,
+                exclusiveTime,
+                numberOfHits);
+
+            return profiledLocation;
+        }
+
+#endif
+
         #endregion
 
         #endregion
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index ae76d151a37..6f560189522 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -19,9 +19,10 @@ internal static partial class FileUtilities
         /// Caller must delete when finished.
         /// </summary>
         /// <param name="createDirectory"></param>
-        internal static string GetTemporaryDirectory(bool createDirectory = true)
+        /// <param name="subfolder"></param>
+        internal static string GetTemporaryDirectory(bool createDirectory = true, string subfolder = null)
         {
-            string temporaryDirectory = Path.Combine(Path.GetTempPath(), "Temporary" + Guid.NewGuid().ToString("N"));
+            string temporaryDirectory = Path.Combine(Path.GetTempPath(), "Temporary" + Guid.NewGuid().ToString("N"), subfolder ?? string.Empty);
 
             if (createDirectory)
             {
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 7aa78f0bbeb..09cca604107 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -175,6 +175,32 @@ public bool LogTaskInputs
             }
         }
 
+        private bool? _logPropertiesAndItemsAfterEvaluation;
+        private bool _logPropertiesAndItemsAfterEvaluationInitialized = false;
+        public bool? LogPropertiesAndItemsAfterEvaluation
+        {
+            get
+            {
+                if (!_logPropertiesAndItemsAfterEvaluationInitialized)
+                {
+                    _logPropertiesAndItemsAfterEvaluationInitialized = true;
+                    var variable = Environment.GetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION");
+                    if (!string.IsNullOrEmpty(variable))
+                    {
+                        _logPropertiesAndItemsAfterEvaluation = variable == "1" || string.Equals(variable, "true", StringComparison.OrdinalIgnoreCase);
+                    }
+                }
+
+                return _logPropertiesAndItemsAfterEvaluation;
+            }
+
+            set
+            {
+                _logPropertiesAndItemsAfterEvaluationInitialized = true;
+                _logPropertiesAndItemsAfterEvaluation = value;
+            }
+        }
+
         /// <summary>
         /// Read information only once per file per ResolveAssemblyReference invocation.
         /// </summary>
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index 636c41df025..7080a2e7ccc 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -83,9 +83,6 @@ private static void TestGetItemSpecModifier(string currentDirectory)
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
         public void MakeRelativeTests()
         {
             if (NativeMethodsShared.IsWindows)
@@ -97,20 +94,17 @@ public void MakeRelativeTests()
                 Assert.Equal(@"e:\abc\def\foo.cpp", FileUtilities.MakeRelative(@"c:\abc\def", @"e:\abc\def\foo.cpp"));
                 Assert.Equal(@"foo.cpp", FileUtilities.MakeRelative(@"\\aaa\abc\def", @"\\aaa\abc\def\foo.cpp"));
                 Assert.Equal(@"foo.cpp", FileUtilities.MakeRelative(@"c:\abc\def", @"foo.cpp"));
-                Assert.Equal(@"foo.cpp", FileUtilities.MakeRelative(@"c:\abc\def", @"..\def\foo.cpp"));
                 Assert.Equal(@"\\host\path\file", FileUtilities.MakeRelative(@"c:\abc\def", @"\\host\path\file"));
                 Assert.Equal(@"\\host\d$\file", FileUtilities.MakeRelative(@"c:\abc\def", @"\\host\d$\file"));
                 Assert.Equal(@"..\fff\ggg.hh", FileUtilities.MakeRelative(@"c:\foo\bar\..\abc\cde", @"c:\foo\bar\..\abc\fff\ggg.hh"));
             }
             else
             {
-                Assert.Equal(@"foo.cpp", FileUtilities.MakeRelative(@"/abc/def", @"/abc/def/foo.cpp"));
+                Assert.Equal(@"bar.cpp", FileUtilities.MakeRelative(@"/abc/def", @"/abc/def/bar.cpp"));
                 Assert.Equal(@"def/foo.cpp", FileUtilities.MakeRelative(@"/abc/", @"/abc/def/foo.cpp"));
-                Assert.Equal(@"..\foo.cpp", FileUtilities.MakeRelative(@"/abc/def/xyz", @"/abc/def/foo.cpp"));
-                Assert.Equal(@"..\ttt\foo.cpp", FileUtilities.MakeRelative(@"/abc/def/xyz/", @"/abc/def/ttt/foo.cpp"));
-                Assert.Equal(@"/abc/def/foo.cpp", FileUtilities.MakeRelative(@"/abc/def", @"/abc/def/foo.cpp"));
+                Assert.Equal(@"../foo.cpp", FileUtilities.MakeRelative(@"/abc/def/xyz", @"/abc/def/foo.cpp"));
+                Assert.Equal(@"../ttt/foo.cpp", FileUtilities.MakeRelative(@"/abc/def/xyz/", @"/abc/def/ttt/foo.cpp"));
                 Assert.Equal(@"foo.cpp", FileUtilities.MakeRelative(@"/abc/def", @"foo.cpp"));
-                Assert.Equal(@"foo.cpp", FileUtilities.MakeRelative(@"/abc/def", @"../def/foo.cpp"));
                 Assert.Equal(@"../fff/ggg.hh", FileUtilities.MakeRelative(@"/foo/bar/../abc/cde", @"/foo/bar/../abc/fff/ggg.hh"));
             }
         }
diff --git a/src/Shared/UnitTests/TestAssemblyInfo.cs b/src/Shared/UnitTests/TestAssemblyInfo.cs
index a325fb4cac4..e1e7ef66d5a 100644
--- a/src/Shared/UnitTests/TestAssemblyInfo.cs
+++ b/src/Shared/UnitTests/TestAssemblyInfo.cs
@@ -40,6 +40,10 @@ public MSBuildTestAssemblyFixture()
         //  (VerifySubToolsetVersionSetByConstructorOverridable), as the environment variable would take precedence.
         _testEnvironment.SetEnvironmentVariable("VisualStudioVersion", string.Empty);
 
+        // Prevent test assemblies from logging any performance info.
+        // https://github.com/dotnet/msbuild/pull/6274
+        _testEnvironment.SetEnvironmentVariable("DOTNET_PERFLOG_DIR", string.Empty);
+
         SetDotnetHostPath(_testEnvironment);
 
         //  Use a project-specific temporary path
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 569bd92a66e..9922585a325 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -172,6 +172,15 @@ public TransientTempPath CreateNewTempPath()
             return SetTempPath(folder.Path, true);
         }
 
+        /// <summary>
+        /// Creates a new temp path with a custom subfolder
+        /// </summary>
+        public TransientTempPath CreateNewTempPathWithSubfolder(string subfolder)
+        {
+            var folder = CreateFolder(null, true, subfolder);
+            return SetTempPath(folder.Path, true);
+        }
+
         /// <summary>
         /// Creates a new temp path
         /// Sets all OS temp environment variables to the new path
@@ -266,9 +275,9 @@ public TransientTestFile ExpectFile(TransientTestFolder transientTestFolder, str
         ///     Creates a test variant used to add a unique temporary folder during a test. Will be deleted when the test
         ///     completes.
         /// </summary>
-        public TransientTestFolder CreateFolder(string folderPath = null, bool createFolder = true)
+        public TransientTestFolder CreateFolder(string folderPath = null, bool createFolder = true, string subfolder = null)
         {
-            var folder = WithTransientTestState(new TransientTestFolder(folderPath, createFolder));
+            var folder = WithTransientTestState(new TransientTestFolder(folderPath, createFolder, subfolder));
 
             Assert.True(!(createFolder ^ FileSystems.Default.DirectoryExists(folder.Path)));
 
@@ -605,9 +614,9 @@ public void Delete()
 
     public class TransientTestFolder : TransientTestState
     {
-        public TransientTestFolder(string folderPath = null, bool createFolder = true)
+        public TransientTestFolder(string folderPath = null, bool createFolder = true, string subfolder = null)
         {
-            Path = folderPath ?? FileUtilities.GetTemporaryDirectory(createFolder);
+            Path = folderPath ?? FileUtilities.GetTemporaryDirectory(createFolder, subfolder);
 
             if (createFolder)
             {
diff --git a/src/Tasks.UnitTests/AssignTargetPath_Tests.cs b/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
index 8f159985a94..3f9dc087274 100644
--- a/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
+++ b/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
@@ -1,10 +1,12 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -20,15 +22,10 @@ public void Regress314791()
                           { new TaskItem(NativeMethodsShared.IsWindows ? @"c:\bin2\abc.efg" : "/bin2/abc.efg") };
             t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\bin" : "/bin";
 
-            bool success = t.Execute();
-
-            Assert.True(success);
-
-            Assert.Single(t.AssignedFiles);
-            Assert.Equal(
-                NativeMethodsShared.IsWindows ? @"c:\bin2\abc.efg" : "/bin2/abc.efg",
-                t.AssignedFiles[0].ItemSpec);
-            Assert.Equal(@"abc.efg", t.AssignedFiles[0].GetMetadata("TargetPath"));
+            t.Execute().ShouldBeTrue();
+            t.AssignedFiles.Length.ShouldBe(1);
+            t.AssignedFiles[0].ItemSpec.ShouldBe(NativeMethodsShared.IsWindows ? @"c:\bin2\abc.efg" : "/bin2/abc.efg");
+            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe("abc.efg");
         }
 
         [Fact]
@@ -40,12 +37,9 @@ public void AtConeRoot()
                           { new TaskItem(NativeMethodsShared.IsWindows ? @"c:\f1\f2\file.txt" : "/f1/f2/file.txt") };
             t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\f1\f2" : "/f1/f2";
 
-            bool success = t.Execute();
-
-            Assert.True(success);
-
-            Assert.Single(t.AssignedFiles);
-            Assert.Equal(@"file.txt", t.AssignedFiles[0].GetMetadata("TargetPath"));
+            t.Execute().ShouldBeTrue();
+            t.AssignedFiles.Length.ShouldBe(1);
+            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe("file.txt");
         }
 
         [Fact]
@@ -64,12 +58,9 @@ public void OutOfCone()
             // /f1 to /x1
             t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\f1" : "/x1";
 
-            bool success = t.Execute();
-
-            Assert.True(success);
-
-            Assert.Single(t.AssignedFiles);
-            Assert.Equal("file.txt", t.AssignedFiles[0].GetMetadata("TargetPath"));
+            t.Execute().ShouldBeTrue();
+            t.AssignedFiles.Length.ShouldBe(1);
+            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe("file.txt");
         }
 
         [Fact]
@@ -84,14 +75,69 @@ public void InConeButAbsolute()
                           };
             t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\f1\f2" : "/f1/f2";
 
-            bool success = t.Execute();
+            t.Execute().ShouldBeTrue();
+            t.AssignedFiles.Length.ShouldBe(1);
+            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe(NativeMethodsShared.IsWindows ? @"f3\f4\file.txt" : "f3/f4/file.txt");
+        }
+
+        [Theory]
+        [InlineData("c:/fully/qualified/path.txt")]
+        [InlineData("test/output/file.txt")]
+        [InlineData(@"some\dir\to\file.txt")]
+        [InlineData("file.txt")]
+        [InlineData("file")]
+        public void TargetPathAlreadySet(string targetPath)
+        {
+            AssignTargetPath t = new AssignTargetPath();
+            t.BuildEngine = new MockEngine();
+            Dictionary<string, string> metaData = new Dictionary<string, string>();
+            metaData.Add("TargetPath", targetPath);
+            metaData.Add("Link", "c:/foo/bar");
+            t.Files = new ITaskItem[]
+                          {
+                              new TaskItem(
+                                  itemSpec: NativeMethodsShared.IsWindows ? @"c:\f1\f2\file.txt" : "/f1/f2/file.txt",
+                                  itemMetadata: metaData)
+                          };
+            t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\f1\f2" : "/f1/f2";
+
+            t.Execute().ShouldBeTrue();
+            t.AssignedFiles.Length.ShouldBe(1);
+            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe(targetPath);
+        }
+
+        [Theory]
+        [InlineData("c:/fully/qualified/path.txt")]
+        [InlineData("test/output/file.txt")]
+        [InlineData(@"some\dir\to\file.txt")]
+        [InlineData("file.txt")]
+        [InlineData("file")]
+        public void TargetPathAlreadySet_DisabledUnderChangeWave16_10(string targetPath)
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string link = "c:/some/path";
+
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
-            Assert.True(success);
+            AssignTargetPath t = new AssignTargetPath();
+            t.BuildEngine = new MockEngine();
+            Dictionary<string, string> metaData = new Dictionary<string, string>();
+            metaData.Add("TargetPath", targetPath);
+            metaData.Add("Link", link);
+            t.Files = new ITaskItem[]
+                          {
+                              new TaskItem(
+                                  itemSpec: NativeMethodsShared.IsWindows ? @"c:\f1\f2\file.txt" : "/f1/f2/file.txt",
+                                  itemMetadata: metaData)
+                          };
+            t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\f1\f2" : "/f1/f2";
 
-            Assert.Single(t.AssignedFiles);
-            Assert.Equal(
-                NativeMethodsShared.IsWindows ? @"f3\f4\file.txt" : "f3/f4/file.txt",
-                t.AssignedFiles[0].GetMetadata("TargetPath"));
+            t.Execute().ShouldBeTrue();
+            t.AssignedFiles.Length.ShouldBe(1);
+            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe(link);
+            ChangeWaves.ResetStateForTests();
         }
     }
 }
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 3bc0657cab2..67fc7772e5b 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -48,6 +48,50 @@ private ExecWrapper PrepareExecWrapper(string command)
             return exec;
         }
 
+        [Fact]
+        [Trait("Category", "mono-osx-failing")]
+        [Trait("Category", "netcore-osx-failing")]
+        [Trait("Category", "netcore-linux-failing")]
+        public void EscapeSpecifiedCharactersInPathToGeneratedBatchFile()
+        {
+            using (var testEnvironment = TestEnvironment.Create())
+            {
+                var newTempPath = testEnvironment.CreateNewTempPathWithSubfolder("hello()w]o(rld)").TempPath;
+
+                string tempPath = Path.GetTempPath();
+                Assert.StartsWith(newTempPath, tempPath);
+
+                // Now run the Exec task on a simple command.
+                Exec exec = PrepareExec("echo Hello World!");
+                exec.Execute().ShouldBeTrue();
+            }
+        }
+
+        [Fact]
+        [Trait("Category", "mono-osx-failing")]
+        [Trait("Category", "netcore-osx-failing")]
+        [Trait("Category", "netcore-linux-failing")]
+        public void EscapeSpecifiedCharactersInPathToGeneratedBatchFile_DisabledUnderChangeWave16_10()
+        {
+            using (var testEnvironment = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                testEnvironment.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                var newTempPath = testEnvironment.CreateNewTempPathWithSubfolder("hello()w]o(rld)").TempPath;
+
+                string tempPath = Path.GetTempPath();
+                Assert.StartsWith(newTempPath, tempPath);
+
+                // Now run the Exec task on a simple command.
+                Exec exec = PrepareExec("echo Hello World!");
+                exec.Execute().ShouldBeFalse();
+
+                ChangeWaves.ResetStateForTests();
+            }
+        }
+
         /// <summary>
         /// Ensures that calling the Exec task does not leave any extra TEMP files
         /// lying around.
@@ -918,6 +962,117 @@ echo line 3"" />
                 }
             }
         }
+
+        [Fact]
+        [Trait("Category", "mono-osx-failing")]
+        [Trait("Category", "netcore-osx-failing")]
+        [Trait("Category", "netcore-linux-failing")]
+        public void EndToEndMultilineExec_EscapeSpecialCharacters()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                var testProject = env.CreateTestProjectWithFiles(@"<Project>
+<Target Name=""ExecCommand"">
+  <Exec Command=""echo Hello, World!"" />
+   </Target>
+</Project>");
+
+                // Ensure path has subfolders
+                var newTempPath = env.CreateNewTempPathWithSubfolder("hello()wo(rld)").TempPath;
+                string tempPath = Path.GetTempPath();
+                Assert.StartsWith(newTempPath, tempPath);
+
+                using (var buildManager = new BuildManager())
+                {
+                    MockLogger logger = new MockLogger(_output, profileEvaluation: false, printEventsToStdout: false);
+
+                    var parameters = new BuildParameters()
+                    {
+                        Loggers = new[] { logger },
+                    };
+
+                    var collection = new ProjectCollection(
+                        new Dictionary<string, string>(),
+                        new[] { logger },
+                        remoteLoggers: null,
+                        ToolsetDefinitionLocations.Default,
+                        maxNodeCount: 1,
+                        onlyLogCriticalEvents: false,
+                        loadProjectsReadOnly: true);
+
+                    var project = collection.LoadProject(testProject.ProjectFile).CreateProjectInstance();
+
+                    var request = new BuildRequestData(
+                        project,
+                        targetsToBuild: new[] { "ExecCommand" },
+                        hostServices: null);
+
+                    var result = buildManager.Build(parameters, request);
+
+                    logger.AssertLogContains("Hello, World!");
+
+                    result.OverallResult.ShouldBe(BuildResultCode.Success);
+                }
+            }
+        }
+
+        [Fact]
+        [Trait("Category", "mono-osx-failing")]
+        [Trait("Category", "netcore-osx-failing")]
+        [Trait("Category", "netcore-linux-failing")]
+        public void EndToEndMultilineExec_EscapeSpecialCharacters_DisabledUnderChangeWave16_10()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                var testProject = env.CreateTestProjectWithFiles(@"<Project>
+<Target Name=""ExecCommand"">
+  <Exec Command=""echo Hello, World!"" />
+   </Target>
+</Project>");
+
+                // Ensure path has subfolders
+                var newTempPath = env.CreateNewTempPathWithSubfolder("hello()wo(rld)").TempPath;
+                string tempPath = Path.GetTempPath();
+                Assert.StartsWith(newTempPath, tempPath);
+
+                using (var buildManager = new BuildManager())
+                {
+                    MockLogger logger = new MockLogger(_output, profileEvaluation: false, printEventsToStdout: false);
+
+                    var parameters = new BuildParameters()
+                    {
+                        Loggers = new[] { logger },
+                    };
+
+                    var collection = new ProjectCollection(
+                        new Dictionary<string, string>(),
+                        new[] { logger },
+                        remoteLoggers: null,
+                        ToolsetDefinitionLocations.Default,
+                        maxNodeCount: 1,
+                        onlyLogCriticalEvents: false,
+                        loadProjectsReadOnly: true);
+
+                    var project = collection.LoadProject(testProject.ProjectFile).CreateProjectInstance();
+
+                    var request = new BuildRequestData(
+                        project,
+                        targetsToBuild: new[] { "ExecCommand" },
+                        hostServices: null);
+
+                    var result = buildManager.Build(parameters, request);
+
+                    logger.AssertLogContains("Hello, World!");
+
+                    result.OverallResult.ShouldBe(BuildResultCode.Failure);
+                }
+                ChangeWaves.ResetStateForTests();
+            }
+        }
     }
 
     internal class ExecWrapper : Exec
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index bf668ed0950..b389d8c784c 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -655,6 +655,424 @@ public void OneAttributePositionalAndNamedParamsVisualBasic()
             File.Delete(task.OutputFile.ItemSpec);
         }
 
+        /// <summary>
+        /// A type can be declared for a positional arguments using the metadata
+        /// "_Parameter1_TypeName" where the value is the full type name.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeForPositionalParameter()
+        {
+            TaskItem attribute = new("CLSCompliantAttribute");
+            attribute.SetMetadata("_Parameter1", "True");
+            attribute.SetMetadata("_Parameter1_TypeName", "System.Boolean");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: CLSCompliantAttribute(true)]"
+            );
+        }
+
+        /// <summary>
+        /// A type can be declared for a positional arguments using the metadata
+        /// "Foo_TypeName" where the value is the full type name.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeForNamedParameter()
+        {
+            TaskItem attribute = new TaskItem("TestAttribute");
+            attribute.SetMetadata("BoolArgument", "False");
+            attribute.SetMetadata("BoolArgument_TypeName", "System.Boolean");
+            attribute.SetMetadata("Int32Argument", "42");
+            attribute.SetMetadata("Int32Argument_TypeName", "System.Int32");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: TestAttribute(Int32Argument=42, BoolArgument=false)]"
+            );
+        }
+
+        /// <summary>
+        /// Metadata that looks like a declared type, but doesn't have corresponding named parameter
+        /// metadata should be treated as another named parameter for backward-compatibility.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypedWithoutCorrespondingNamedParameter()
+        {
+            TaskItem attribute = new TaskItem("TestAttribute");
+            attribute.SetMetadata("BoolArgument", "False");
+            attribute.SetMetadata("BoolArgument_TypeName", "System.Boolean");
+            attribute.SetMetadata("Int32Argument_TypeName", "System.Int32");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: TestAttribute(Int32Argument_TypeName=""System.Int32"", BoolArgument=false)]"
+            );
+        }
+
+        /// <summary>
+        /// An unknown type name for a parameter should cause a failure.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeIsUnknown()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("TestParameter", "99");
+            attribute.SetMetadata("TestParameter_TypeName", "Foo.Bar");
+
+            ExecuteAndVerifyFailure(
+                CreateTask("c#", attribute),
+                "MSB3715"
+            );
+        }
+
+        /// <summary>
+        /// A parameter value that cannot be converted to the declared type should cause a failure.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeCausesConversionFailure()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("TestParameter", "99");
+            attribute.SetMetadata("TestParameter_TypeName", "System.Boolean");
+
+            ExecuteAndVerifyFailure(
+                CreateTask("c#", attribute),
+                "MSB3716"
+            );
+        }
+
+        /// <summary>
+        /// Parameter value that is too large for the declared data type should cause a failure.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeCausesOverflow()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("TestParameter", "1000");
+            attribute.SetMetadata("TestParameter_TypeName", "System.Byte");
+
+            ExecuteAndVerifyFailure(
+                CreateTask("c#", attribute),
+                "MSB3716"
+            );
+        }
+
+        /// <summary>
+        /// The metadata value should convert successfully to an enum.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeIsEnum()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("_Parameter1", "Local");
+            attribute.SetMetadata("_Parameter1_TypeName", "System.DateTimeKind");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: TestAttribute(System.DateTimeKind.Local)]"
+            );
+        }
+
+        /// <summary>
+        /// The metadata value should convert successfully to a type name in C#.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeIsTypeInCSharp()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("_Parameter1", "System.Console");
+            attribute.SetMetadata("_Parameter1_TypeName", "System.Type");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: TestAttribute(typeof(System.Console))]"
+            );
+        }
+
+        /// <summary>
+        /// The metadata value should convert successfully to a type name in VB.NET.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeIsTypeInVB()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("_Parameter1", "System.Console");
+            attribute.SetMetadata("_Parameter1_TypeName", "System.Type");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("visualbasic", attribute),
+                @"<Assembly: TestAttribute(GetType(System.Console))>"
+            );
+        }
+
+        /// <summary>
+        /// Arrays are not supported for declared types. Literal arguments need to be used instead.
+        /// This test confirms that it fails instead of falling back to being treated as a string.
+        /// </summary>
+        [Fact]
+        public void DeclaredTypeOfArrayIsNotSupported()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("_Parameter1", "1,2,3");
+            attribute.SetMetadata("_Parameter1_TypeName", "System.Int32[]");
+
+            ExecuteAndVerifyFailure(
+                CreateTask("c#", attribute),
+                "MSB3716"
+            );
+        }
+
+        /// <summary>
+        /// The exact code for a positional argument can be specified using
+        /// the metadata "_Parameter1_IsLiteral" with a value of "true".
+        /// </summary>
+        [Fact]
+        public void LiteralPositionalParameter()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("_Parameter1", "42 /* A comment */");
+            attribute.SetMetadata("_Parameter1_IsLiteral", "true");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: TestAttribute(42 /* A comment */)]"
+            );
+        }
+
+        /// <summary>
+        /// The exact code for a named argument can be specified using
+        /// the metadata "Foo_IsLiteral" with a value of "true".
+        /// </summary>
+        [Fact]
+        public void LiteralNamedParameter()
+        {
+            TaskItem attribute = new("TestAttribute");
+            attribute.SetMetadata("TestParameter", "42 /* A comment */");
+            attribute.SetMetadata("TestParameter_IsLiteral", "true");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: TestAttribute(TestParameter=42 /* A comment */)]"
+            );
+        }
+
+        /// <summary>
+        /// The type of a positional argument can be inferred
+        /// if the type of the attribute is in mscorlib.
+        /// </summary>
+        [Fact]
+        public void InferredTypeForPositionalParameter()
+        {
+            TaskItem attribute = new("CLSCompliantAttribute");
+            attribute.SetMetadata("_Parameter1", "True");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: CLSCompliantAttribute(true)]"
+            );
+        }
+
+        /// <summary>
+        /// The type of a named argument can be inferred
+        /// if the type of the attribute is in mscorlib.
+        /// </summary>
+        [Fact]
+        public void InferredTypeForNamedParameter()
+        {
+            TaskItem attribute = new("System.Runtime.CompilerServices.InternalsVisibleToAttribute");
+            attribute.SetMetadata("_Parameter1", "MyAssembly");
+            attribute.SetMetadata("AllInternalsVisible", "True");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute(""MyAssembly"", AllInternalsVisible=true)]"
+            );
+        }
+
+        /// <summary>
+        /// For backward-compatibility, if multiple constructors are found with the same number 
+        /// of position arguments that was specified in the metadata, then the constructor that
+        /// has strings for every parameter should be used.
+        /// </summary>
+        [Fact]
+        public void InferredTypePrefersStringWhenMultipleConstructorsAreFound()
+        {
+            TaskItem attribute = new("System.Diagnostics.Contracts.ContractOptionAttribute");
+            attribute.SetMetadata("_Parameter1", "a");
+            attribute.SetMetadata("_Parameter2", "b");
+            attribute.SetMetadata("_Parameter3", "false");
+
+            // There are two constructors with three parameters:
+            //   * ContractOptionAttribute(string, string, bool)
+            //   * ContractOptionAttribute(string, string, string)
+            //
+            // The first overload would come first when comparing the type names
+            // ("System.Boolean" comes before "System.String"), but because we
+            // need to remain backward-compatible, the constructor that takes
+            // all strings should be preferred over all other constructors.
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.Diagnostics.Contracts.ContractOptionAttribute(""a"", ""b"", ""false"")]"
+            );
+        }
+
+        /// <summary>
+        /// When multiple constructors are found with the same number of
+        /// position arguments that was specified in the metadata, and none
+        /// of them have parameters of all strings, then the constructors
+        /// should be sorted by the names of the parameter types.
+        /// The first constructor is then selected.
+        /// </summary>
+        [Fact]
+        public void InferredTypeWithMultipleAttributeConstructorsIsDeterministic()
+        {
+            TaskItem attribute = new("System.Reflection.AssemblyFlagsAttribute");
+            attribute.SetMetadata("_Parameter1", "2");
+
+            // There are three constructors with a single parameter:
+            //   * AssemblyFlagsAttribute(int)
+            //   * AssemblyFlagsAttribute(uint)
+            //   * AssemblyFlagsAttribute(System.Reflection.AssemblyNameFlags)
+            //
+            // The int overload should be used, because "System.Int32"
+            // is alphabetically before any of the other types.
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.Reflection.AssemblyFlagsAttribute(2)]"
+            );
+
+            // To prove that it's treating the argument as an int,
+            // we can specify an enum value which should fail type
+            // conversion and fall back to being used as a string.
+            attribute.SetMetadata("_Parameter1", "PublicKey");
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.Reflection.AssemblyFlagsAttribute(""PublicKey"")]"
+            );
+        }
+
+        /// <summary>
+        /// If the attribute type is not in mscorlib, then the
+        /// parameter should be treated as a string when the parameter
+        /// is not given a declared type or is not marked as a literal.
+        /// </summary>
+        [Fact]
+        public void InferredTypeFallsBackToStringWhenTypeCannotBeInferred()
+        {
+            // Use an attribute that is not in mscorlib. TypeConverterAttribute is in the "System" assembly.
+            TaskItem attribute = new("System.ComponentModel.TypeConverterAttribute");
+            attribute.SetMetadata("_Parameter1", "false");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.ComponentModel.TypeConverterAttribute(""false"")]"
+            );
+        }
+
+        /// <summary>
+        /// If the parameter type cannot be converted to the inferred type,
+        /// then the parameter should be treated as a string.
+        /// </summary>
+        [Fact]
+        public void InferredTypeFallsBackToStringWhenTypeConversionFails()
+        {
+            TaskItem attribute = new("System.Diagnostics.DebuggableAttribute");
+            attribute.SetMetadata("_Parameter1", "True"); // Should be a boolean. Will be converted.
+            attribute.SetMetadata("_Parameter2", "42"); // Should be a boolean. Will fail type conversion.
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.Diagnostics.DebuggableAttribute(true, ""42"")]"
+            );
+        }
+
+        /// <summary>
+        /// Individual parameters can be typed differently.
+        /// </summary>
+        [Fact]
+        public void UsingInferredDeclaredTypesAndLiteralsInSameAttribute()
+        {
+            TaskItem attribute = new("System.Diagnostics.Contracts.ContractOptionAttribute");
+            attribute.SetMetadata("_Parameter1", "foo");                    // Inferred as string.
+            attribute.SetMetadata("_Parameter2", @"""bar"" /* setting */"); // Literal string.
+            attribute.SetMetadata("_Parameter2_IsLiteral", "true");
+            attribute.SetMetadata("_Parameter3", "False");                  // Typed as boolean.
+            attribute.SetMetadata("_Parameter3_TypeName", "System.Boolean");
+
+            ExecuteAndVerifySuccess(
+                CreateTask("c#", attribute),
+                @"[assembly: System.Diagnostics.Contracts.ContractOptionAttribute(""foo"", ""bar"" /* setting */, false)]"
+            );
+        }
+
+        private WriteCodeFragment CreateTask(string language, params TaskItem[] attributes)
+        {
+            WriteCodeFragment task = new();
+            task.Language = language;
+            task.OutputDirectory = new TaskItem(Path.GetTempPath());
+            task.AssemblyAttributes = attributes;
+            return task;
+        }
+
+        private void ExecuteAndVerifySuccess(WriteCodeFragment task, params string[] expectedAttributes)
+        {
+            MockEngine engine = new(true);
+            task.BuildEngine = engine;
+
+            try
+            {
+                var result = task.Execute();
+
+                // Provide the log output as the user message so that the assertion failure
+                // message is a bit more meaningful than just "Expected false to equal true".
+                Assert.True(result, engine.Log);
+
+                string content = File.ReadAllText(task.OutputFile.ItemSpec);
+                Console.WriteLine(content);
+
+                if (task.Language == "c#")
+                {
+                    CheckContentCSharp(content, expectedAttributes);
+                }
+                else
+                {
+                    CheckContentVB(content, expectedAttributes);
+                }
+            }
+            finally
+            {
+                if ((task.OutputFile is not null) && File.Exists(task.OutputFile.ItemSpec))
+                {
+                    File.Delete(task.OutputFile.ItemSpec);
+                }
+            }
+        }
+
+        private void ExecuteAndVerifyFailure(WriteCodeFragment task, string errorCode)
+        {
+            MockEngine engine = new(true);
+            task.BuildEngine = engine;
+
+            try
+            {
+                var result = task.Execute();
+
+                // Provide the log output as the user message so that the assertion failure
+                // message is a bit more meaningful than just "Expected true to equal false".
+                Assert.False(result, engine.Log);
+
+                engine.AssertLogContains(errorCode);
+
+            }
+            finally
+            {
+                if ((task.OutputFile is not null) && File.Exists(task.OutputFile.ItemSpec))
+                {
+                    File.Delete(task.OutputFile.ItemSpec);
+                }
+            }
+        }
+
         private static void CheckContentCSharp(string actualContent, params string[] expectedAttributes)
         {
             CheckContent(
diff --git a/src/Tasks/AssignTargetPath.cs b/src/Tasks/AssignTargetPath.cs
index ffb085cfcf6..6b033ae1fb0 100644
--- a/src/Tasks/AssignTargetPath.cs
+++ b/src/Tasks/AssignTargetPath.cs
@@ -71,13 +71,19 @@ public override bool Execute()
 
                 for (int i = 0; i < Files.Length; ++i)
                 {
-                    string link = Files[i].GetMetadata(ItemMetadataNames.link);
                     AssignedFiles[i] = new TaskItem(Files[i]);
 
-                    // If file has a link, use that.
-                    string targetPath = link;
+                    // If TargetPath is already set, it takes priority.
+                    // https://github.com/dotnet/msbuild/issues/2795
+                    string targetPath =  ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10) ? Files[i].GetMetadata(ItemMetadataNames.targetPath) : null;
 
-                    if (string.IsNullOrEmpty(link))
+                    // If TargetPath not already set, fall back to default behavior.
+                    if (string.IsNullOrEmpty(targetPath))
+                    {
+                        targetPath = Files[i].GetMetadata(ItemMetadataNames.link);
+                    }
+
+                    if (string.IsNullOrEmpty(targetPath))
                     {
                         if (// if the file path is relative
                             !Path.IsPathRooted(Files[i].ItemSpec) &&
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index 2132b8266db..77fa495a484 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -54,6 +54,9 @@ public Exec()
         private Encoding _standardOutputEncoding;
         private string _command;
 
+        // '^' before _any_ character escapes that character, don't escape it.
+        private static readonly char[] _charactersToEscape = { '(', ')', '=', ';', '!', ',', '&', ' '};
+
         #endregion
 
         #region Properties
@@ -601,13 +604,45 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
                     }
                     commandLine.AppendSwitch("/C"); // run then terminate
 
-                    // If for some crazy reason the path has a & character and a space in it
-                    // then get the short path of the temp path, which should not have spaces in it
-                    // and then escape the &
-                    if (batchFileForCommandLine.Contains("&") && !batchFileForCommandLine.Contains("^&"))
+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
                     {
-                        batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);
-                        batchFileForCommandLine = batchFileForCommandLine.Replace("&", "^&");
+                        StringBuilder fileName = null;
+
+                        // Escape special characters that need to be escaped.
+                        for (int i = 0; i < batchFileForCommandLine.Length; i++)
+                        {
+                            char c = batchFileForCommandLine[i];
+
+                            if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))
+                            {
+                                // Avoid allocating a new string until we know we have something to escape.
+                                if (fileName == null)
+                                {
+                                    fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);
+                                    fileName.Append(batchFileForCommandLine, 0, i);
+                                }
+
+                                fileName.Append('^');
+                            }
+
+                            fileName?.Append(c);
+                        }
+
+                        if (fileName != null)
+                        {
+                            batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);
+                        }
+                    }
+                    else
+                    {
+                        // If for some crazy reason the path has a & character and a space in it
+                        // then get the short path of the temp path, which should not have spaces in it
+                        // and then escape the &
+                        if (batchFileForCommandLine.Contains("&") && !batchFileForCommandLine.Contains("^&"))
+                        {
+                            batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);
+                            batchFileForCommandLine = batchFileForCommandLine.Replace("&", "^&");
+                        }
                     }
                 }
 
@@ -615,6 +650,19 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
             }
         }
 
+        private bool ShouldEscapeCharacter(char c)
+        {
+            for (int i = 0; i < _charactersToEscape.Length; i++)
+            {
+                if (c == _charactersToEscape[i])
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
         #endregion
 
         #region Overridden properties
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 4db84f02967..55ca4152e4e 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -65,9 +65,11 @@ public ApplicationManifest(string targetFrameworkVersion)
         }
 
         /// <summary>
-        /// Indicates the application configuration file.
-        /// For a Win32 native manifest, this input is ignored.
+        /// Gets or sets the application configuration file.
         /// </summary>
+        /// <remarks>
+        /// For a Win32 native manifest, this input is ignored.
+        /// </remarks>
         [XmlIgnore]
         public string ConfigFile
         {
@@ -91,7 +93,7 @@ public override AssemblyReference EntryPoint
         }
 
         /// <summary>
-        /// Specifies the target framework version
+        /// Gets or sets the target framework version
         /// </summary>
         [XmlIgnore]
         public string TargetFrameworkVersion
@@ -101,7 +103,7 @@ public string TargetFrameworkVersion
         }
 
         /// <summary>
-        /// Specifies the link to use if there is a failure launching the application.
+        /// Gets or sets the link to use if there is a failure launching the application.
         /// The specified value should be a fully qualified URL or UNC path.
         /// </summary>
         [XmlIgnore]
@@ -162,8 +164,9 @@ private bool WinXPRequired
                                                              (_fileAssociationList = new FileAssociationCollection(_fileAssociations));
 
         /// <summary>
-        /// If true, the application will run in IE using WPF's xbap application model.
+        /// Gets or sets a value that indicates whether the application will run in IE using WPF's XBAP application model.
         /// </summary>
+        /// <value><see langword="true" /> if the application will run in IE using WPF's XBAP application model; otherwise, <see langword="false" />.</value>
         [XmlIgnore]
         public bool HostInBrowser
         {
@@ -172,11 +175,13 @@ public bool HostInBrowser
         }
 
         /// <summary>
-        /// Indicates the application icon file.
+        /// Gets or sets the application icon file.
+        /// </summary>
+        /// <remarks>
         /// The application icon is expressed in the generated application manifest and is used for the start menu and Add/Remove Programs dialog.
         /// If this input is not specified then a default icon is used.
         /// For a Win32 native manifest, this input is ignored.
-        /// </summary>
+        /// </remarks>
         [XmlIgnore]
         public string IconFile
         {
@@ -185,7 +190,7 @@ public string IconFile
         }
 
         /// <summary>
-        /// Indicates whether the manifest is a ClickOnce application manifest or a native Win32 application manifest.
+        /// Gets or sets a value that indicates whether the manifest is a ClickOnce application manifest or a native Win32 application manifest.
         /// </summary>
         [XmlIgnore]
         public bool IsClickOnceManifest
@@ -195,12 +200,14 @@ public bool IsClickOnceManifest
         }
 
         /// <summary>
-        /// Specifies the maximum allowable length of a file path in a ClickOnce application deployment.
+        /// Gets or sets the maximum allowable length of a file path in a ClickOnce application deployment.
+        /// </summary>
+        /// <remarks>
         /// If this value is specified, then the length of each file path in the application is checked against this limit.
         /// Any items that exceed the limit will result in a warning message.
         /// If this input is not specified or is zero, then no checking is performed.
         /// For a Win32 native manifest, this input is ignored.
-        /// </summary>
+        /// </remarks>
         [XmlIgnore]
         public int MaxTargetPath
         {
@@ -235,7 +242,7 @@ internal override void OnBeforeSave()
         }
 
         /// <summary>
-        /// Specifies a textual description for the OS dependency.
+        /// Gets or sets a textual description for the OS dependency.
         /// </summary>
         [XmlIgnore]
         public string OSDescription
@@ -245,7 +252,7 @@ public string OSDescription
         }
 
         /// <summary>
-        /// Specifies a support URL for the OS dependency.
+        /// Gets or sets a support URL for the OS dependency.
         /// </summary>
         [XmlIgnore]
         public string OSSupportUrl
@@ -255,13 +262,15 @@ public string OSSupportUrl
         }
 
         /// <summary>
-        /// Specifies the minimum required OS version required by the application.
-        /// An example value is "5.1.2600.0" for Windows XP.
-        /// If this input is not specified a default value is used.
-        /// The default value is the minimum supported OS of the .NET Framework, which is "4.10.0.0" for Windows 98SE.
-        /// However, if the application contains any native or Reg-Free COM references, then the default will be the Windows XP version.
-        /// For a Win32 native manifest, this input is ignored.
+        /// Gets or sets the minimum OS version required by the application.
         /// </summary>
+        /// <remarks>
+        /// An example value is "5.1.2600.0" for Windows XP.        
+        /// If you don't specify a value, a default value is used.
+        /// The default value is the minimum supported OS of the .NET Framework, which is "4.10.0.0" for Windows 98 Second Edition.
+        /// However, if the application contains any native or Reg-Free COM references, then the default is the Windows XP version, which is "5.1.2600.0".
+        /// For a Win32 native manifest, this input is ignored.
+        /// </remarks>
         [XmlIgnore]
         public string OSVersion
         {
@@ -304,10 +313,12 @@ public string OSVersion
         }
 
         /// <summary>
-        /// Specifies the name of the application.
+        /// Gets or sets the name of the application.
+        /// </summary>
+        /// <remarks>
         /// If this input is not specified then the Product is not written into the Application Manifest
         /// This name is used for the shortcut name on the Start menu and is part of the name that appears in the Add/Remove Programs dialog.
-        /// </summary>
+        /// </remarks>
         [XmlIgnore]
         public string Product
         {
@@ -316,10 +327,12 @@ public string Product
         }
 
         /// <summary>
-        /// Specifies the publisher of the application.
-        /// If this input is not specified then the Publisher is not written into the Application Manifest
-        /// This name is used for the folder name on the Start menu and is part of the name that appears in the Add/Remove Programs dialog.
+        /// Gets or sets the publisher of the application.
         /// </summary>
+        /// <remarks>
+        /// If this input is not, specified then the Publisher is not written into the Application Manifest
+        /// This name is used for the folder name on the Start menu and is part of the name that appears in the Add/Remove Programs dialog.
+        /// </remarks>
         [XmlIgnore]
         public string Publisher
         {
@@ -328,9 +341,11 @@ public string Publisher
         }
 
         /// <summary>
-        /// Specifies the suite name of the application.
-        /// This name is used for the sub-folder name on the Start menu (as a child of the publisher)
+        /// Gets or sets the suite name of the application.
         /// </summary>
+        /// <remarks>
+        /// This name is used for the sub-folder name on the Start menu (as a child of the publisher)
+        /// </remarks>
         [XmlIgnore]
         public string SuiteName
         {
@@ -339,9 +354,11 @@ public string SuiteName
         }
 
         /// <summary>
-        /// Specifies the link that appears in the Add/Remove Programs dialog for the application.
-        /// The specified value should be a fully qualified URL or UNC path.
+        /// Gets or sets the link that appears in the Add/Remove Programs dialog for the application.
         /// </summary>
+        /// <remarks>
+        /// The specified value should be a fully qualified URL or UNC path.
+        /// </remarks>
         [XmlIgnore]
         public string SupportUrl
         {
@@ -350,7 +367,7 @@ public string SupportUrl
         }
 
         /// <summary>
-        /// Specifies a trust object defining the application security.
+        /// Gets or sets a trust object defining the application security.
         /// </summary>
         [XmlIgnore]
         public TrustInfo TrustInfo
@@ -360,8 +377,11 @@ public TrustInfo TrustInfo
         }
 
         /// <summary>
-        /// If true, the install will use the settings in the application manifest in the trust prompt.
+        /// Gets or sets a value that indicates whether the install will use the settings in the application manifest in the trust prompt.
         /// </summary>
+        /// <value>
+        /// <see langword="true" /> to use the settings in the application manifest in the trust prompt; otherwise, <see langword="false" />.
+        /// </value>
         [XmlIgnore]
         public bool UseApplicationTrust
         {
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index e986acba46b..48b0bfb05a3 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -2378,6 +2378,14 @@
       <value>MSB3714: The parameter "{0}" was supplied, but not all previously numbered parameters.</value>
       <comment>{StrBegin="MSB3714: "}</comment>
     </data>
+    <data name="WriteCodeFragment.ParameterTypeNotFound" xml:space="preserve">
+      <value>MSB3715: The type "{0}" was not found.</value>
+      <comment>{StrBegin="MSB3715: "}</comment>
+    </data>
+    <data name="WriteCodeFragment.CouldNotConvertValue" xml:space="preserve">
+      <value>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</value>
+      <comment>{StrBegin="MSB3716: "}</comment>
+    </data>
     <data name="WriteCodeFragment.NoWorkToDo" xml:space="preserve">
       <value>No output file was written because no code was specified to create.</value>
     </data>
@@ -2387,6 +2395,15 @@
     <data name="WriteCodeFragment.Comment" xml:space="preserve">
       <value>Generated by the MSBuild WriteCodeFragment class.</value>
     </data>
+    <data name="WriteCodeFragment.CouldNotInferParameterType" xml:space="preserve">
+      <value>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</value>
+    </data>
+    <data name="WriteCodeFragment.CouldNotConvertToInferredType" xml:space="preserve">
+      <value>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</value>
+    </data>
+    <data name="WriteCodeFragment.MultipleConstructorsFound" xml:space="preserve">
+      <value>Multiple attribute constructors were found for type inferencing.</value>
+    </data>
 
 
  <!--
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 9ce911f55c9..35da63a960a 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: Neodpovídající hodnota hash souboru. Očekávalo se, že {0} bude mít hodnotu hash souboru {1} {2}, ale byla {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: Nelze zapsat řádky do souboru {0}. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index bd86221569c..6c21e3d0602 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: Keine Dateihashübereinstimmung. "{0}" muss einen {1}-Dateihash von "{2}" aufweisen, dieser lautet jedoch "{3}".</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: In die Datei "{0}" konnten keine Zeilen geschrieben werden. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.en.xlf b/src/Tasks/Resources/xlf/Strings.en.xlf
index afa8f0dbdc1..14b9fb2399b 100644
--- a/src/Tasks/Resources/xlf/Strings.en.xlf
+++ b/src/Tasks/Resources/xlf/Strings.en.xlf
@@ -2605,6 +2605,31 @@
         <target state="new">MSB3952: File hash mismatch. Expected {0} to have a {1} file hash of {2}, but it was {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="new">MSB3491: Could not write lines to file "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index aa643b920a8..3b174607b9e 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: El hash del archivo no coincide. Se esperaba que {0} tuviera un hash de archivo {1} de {2}, pero era {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: No se pudieron escribir líneas en el archivo "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 898ff0fc132..446990d0219 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: Incompatibilité au niveau du hachage de fichier. {0} devait avoir un hachage de fichier {1} de {2}, mais {3} a été utilisé.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: Impossible d'écrire des lignes dans le fichier "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 9edcf49c294..46ca3855406 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: hash di file non corrispondente. L'hash di file {1} previsto per {0} è {2}, ma quello individuato è {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: non è stato possibile scrivere righe nel file "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index dea0a0ac56e..eb5aeb1b065 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: ファイルのハッシュが一致しません。{0} には {2} の {1} ファイル ハッシュが想定されますが、実際は {3} でした。</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: 行をファイル "{0}" に書き込めませんでした。{1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 172ee98d265..6d49d15e1e8 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: 파일 해시가 일치하지 않습니다. {0}에 {2}의 {1} 파일 해시가 필요하지만 {3}이었습니다.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: "{0}" 파일에 줄을 쓸 수 없습니다. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 4522a89c716..fb568f16651 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: Niezgodność skrótów pliku. Oczekiwano, że element {0} będzie miał skrót pliku {1} równy {2}, ale miał skrót równy {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: Nie można zapisać wierszy w pliku „{0}”. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 9ce92ec7bd3..6e17e48ecc3 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: incompatibilidade de hash de arquivo. Era esperado que {0} tivesse um hash de arquivo {1} de {2}, mas ele tinha {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: Não foi possível gravar linhas no arquivo "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index c68d9cb8fd2..ef92dc744b6 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: несоответствие хэша файла. Для {0} ожидался хэш файла {1}, соответствующий {2}, но вычисленное значение было равно {3}.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: Не удалось записать строки в файл "{0}". {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index ab7742f6560..582179e717c 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: Dosya karması uyuşmazlığı. {0} dosyasının {2} şeklinde bir {1} dosya karması olması bekleniyordu ama {3} şeklindeydi.</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: Satırlar "{0}" dosyasına yazılamadı. {1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 5760ad9edcc..2d73459db6d 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: 文件哈希不匹配。{0} 应具有 {1} 文件哈希 {2}，但却具有 {3}。</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: 未能向文件“{0}”写入命令行。{1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 41cfdaac75b..6d37bf3ca7d 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -2555,6 +2555,31 @@
         <target state="translated">MSB3952: 檔案雜湊不符。{0} 應要有 {1} 檔案雜湊 {2}，但其為 {3}。</target>
         <note>{StrBegin="MSB3952: "}</note>
       </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertToInferredType">
+        <source>Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</source>
+        <target state="new">Could not convert the value for parameter "{0}" to the inferred type "{1}". The value will be treated as a string. {2}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotConvertValue">
+        <source>MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</source>
+        <target state="new">MSB3716: The parameter value "{0}" could not be converted to "{1}". {2}</target>
+        <note>{StrBegin="MSB3716: "}</note>
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
+        <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
+        <target state="new">Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
+        <source>Multiple attribute constructors were found for type inferencing.</source>
+        <target state="new">Multiple attribute constructors were found for type inferencing.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="WriteCodeFragment.ParameterTypeNotFound">
+        <source>MSB3715: The type "{0}" was not found.</source>
+        <target state="new">MSB3715: The type "{0}" was not found.</target>
+        <note>{StrBegin="MSB3715: "}</note>
+      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
         <source>MSB3491: Could not write lines to file "{0}". {1}</source>
         <target state="translated">MSB3491: 無法將行寫入檔案 "{0}"。{1}</target>
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index d7ece292dbb..e3b038412d7 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -10,6 +10,7 @@
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Security;
 using System.Text;
 using Microsoft.Build.Framework;
@@ -27,6 +28,11 @@ namespace Microsoft.Build.Tasks
     /// </comment>
     public class WriteCodeFragment : TaskExtension
     {
+        private const string TypeNameSuffix = "_TypeName";
+        private const string IsLiteralSuffix = "_IsLiteral";
+        private static readonly IEnumerable<string> NamespaceImports = new string[] { "System", "System.Reflection" };
+        private static readonly IReadOnlyDictionary<string, ParameterType> EmptyParameterTypes = new Dictionary<string, ParameterType>();
+
         /// <summary>
         /// Language of code to generate.
         /// Language name can be any language for which a CodeDom provider is
@@ -162,26 +168,37 @@ private string GenerateCode(out string extension)
             }
 
             // For convenience, bring in the namespaces, where many assembly attributes lie
-            globalNamespace.Imports.Add(new CodeNamespaceImport("System"));
-            globalNamespace.Imports.Add(new CodeNamespaceImport("System.Reflection"));
+            foreach (string name in NamespaceImports)
+            {
+                globalNamespace.Imports.Add(new CodeNamespaceImport(name));
+            }
 
             foreach (ITaskItem attributeItem in AssemblyAttributes)
             {
-                var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));
-
                 // Some attributes only allow positional constructor arguments, or the user may just prefer them.
                 // To set those, use metadata names like "_Parameter1", "_Parameter2" etc.
                 // If a parameter index is skipped, it's an error.
                 IDictionary customMetadata = attributeItem.CloneCustomMetadata();
 
-                var orderedParameters = new List<CodeAttributeArgument>(new CodeAttributeArgument[customMetadata.Count + 1] /* max possible slots needed */);
-                var namedParameters = new List<CodeAttributeArgument>();
+                // Some metadata may indicate the types of parameters. Use that metadata to determine
+                // the parameter types. Those metadata items will be removed from the dictionary.
+                IReadOnlyDictionary<string, ParameterType> parameterTypes = ExtractParameterTypes(customMetadata);
+
+                var orderedParameters = new List<AttributeParameter?>(new AttributeParameter?[customMetadata.Count + 1] /* max possible slots needed */);
+                var namedParameters = new List<AttributeParameter>();
 
                 foreach (DictionaryEntry entry in customMetadata)
                 {
                     string name = (string)entry.Key;
                     string value = (string)entry.Value;
 
+                    // Get the declared type information for this parameter.
+                    // If a type is not declared, then we infer the type.
+                    if (!parameterTypes.TryGetValue(name, out ParameterType type))
+                    {
+                        type = new ParameterType { Kind = ParameterTypeKind.Inferred };
+                    }
+
                     if (name.StartsWith("_Parameter", StringComparison.OrdinalIgnoreCase))
                     {
                         if (!Int32.TryParse(name.Substring("_Parameter".Length), out int index))
@@ -197,18 +214,19 @@ private string GenerateCode(out string extension)
                         }
 
                         // "_Parameter01" and "_Parameter1" would overwrite each other
-                        orderedParameters[index - 1] = new CodeAttributeArgument(String.Empty, new CodePrimitiveExpression(value));
+                        orderedParameters[index - 1] = new AttributeParameter { Type = type, Value = value };
                     }
                     else
                     {
-                        namedParameters.Add(new CodeAttributeArgument(name, new CodePrimitiveExpression(value)));
+                        namedParameters.Add(new AttributeParameter { Name = name, Type = type, Value = value });
                     }
                 }
 
                 bool encounteredNull = false;
+                List<AttributeParameter> providedOrderedParameters = new();
                 for (int i = 0; i < orderedParameters.Count; i++)
                 {
-                    if (orderedParameters[i] == null)
+                    if (!orderedParameters[i].HasValue)
                     {
                         // All subsequent args should be null, else a slot was missed
                         encounteredNull = true;
@@ -221,12 +239,24 @@ private string GenerateCode(out string extension)
                         return null;
                     }
 
-                    attribute.Arguments.Add(orderedParameters[i]);
+                    providedOrderedParameters.Add(orderedParameters[i].Value);
                 }
 
-                foreach (CodeAttributeArgument namedParameter in namedParameters)
+                var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));
+
+                // We might need the type of the attribute if we need to infer the
+                // types of the parameters. Search for it by the given type name,
+                // as well as within the namespaces that we automatically import.
+                Lazy<Type> attributeType = new(
+                    () => Type.GetType(attribute.Name, throwOnError: false) ?? NamespaceImports.Select(x => Type.GetType($"{x}.{attribute.Name}", throwOnError: false)).FirstOrDefault(),
+                    System.Threading.LazyThreadSafetyMode.None
+                );
+
+                if (
+                    !AddArguments(attribute, attributeType, providedOrderedParameters, isPositional: true)
+                    || !AddArguments(attribute, attributeType, namedParameters, isPositional: false))
                 {
-                    attribute.Arguments.Add(namedParameter);
+                    return null;
                 }
 
                 unit.AssemblyCustomAttributes.Add(attribute);
@@ -245,5 +275,339 @@ private string GenerateCode(out string extension)
             // as there's no point writing the file
             return haveGeneratedContent ? code : String.Empty;
         }
+
+        /// <summary>
+        /// Finds the metadata items that are used to indicate the types of
+        /// parameters, and removes those items from the given dictionary.
+        /// Returns a dictionary that maps parameter names to their declared types.
+        /// </summary>
+        private IReadOnlyDictionary<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata)
+        {
+            Dictionary<string, ParameterType> parameterTypes = null;
+            List<string> keysToRemove = null;
+
+            foreach (DictionaryEntry entry in customMetadata)
+            {
+                string key = (string)entry.Key;
+                string value = (string)entry.Value;
+
+                if (key.EndsWith(TypeNameSuffix, StringComparison.OrdinalIgnoreCase))
+                {
+                    // Remove the suffix to get the corresponding parameter name.
+                    var parameterNameKey = key.Substring(0, key.Length - TypeNameSuffix.Length);
+
+                    // To remain as backward-compatible as possible, we will only treat this metadata
+                    // item as a type name if there's a corresponding metadata item for the parameter.
+                    // This is done to avoid the very small chance of treating "Foo_TypeName" as a
+                    // type indicator when it was previously being used as a named attribute parameter.
+                    if (customMetadata.Contains(parameterNameKey))
+                    {
+                        // Delay-create the collections to avoid allocations
+                        // when no parameter types are specified.
+                        if (parameterTypes == null)
+                        {
+                            parameterTypes = new();
+                            keysToRemove = new();
+                        }
+
+                        // Remove this metadata item so that
+                        // we don't use it as a parameter name.
+                        keysToRemove.Add(key);
+
+                        // The parameter will have an explicit type. The metadata value is the type name.
+                        parameterTypes[parameterNameKey] = new ParameterType {
+                            Kind = ParameterTypeKind.Typed,
+                            TypeName = value
+                        };
+                    }
+                }
+                else if (key.EndsWith(IsLiteralSuffix, StringComparison.OrdinalIgnoreCase))
+                {
+                    // Remove the suffix to get the corresponding parameter name.
+                    var parameterNameKey = key.Substring(0, key.Length - IsLiteralSuffix.Length);
+
+                    // As mentioned above for the type name metadata, we will only treat
+                    // this metadata item as a literal flag if there's a corresponding
+                    // metadata item for the parameter for backward-compatibility reasons.
+                    if (customMetadata.Contains(parameterNameKey))
+                    {
+                        // Delay-create the collections to avoid allocations
+                        // when no parameter types are specified.
+                        if (parameterTypes == null)
+                        {
+                            parameterTypes = new();
+                            keysToRemove = new();
+                        }
+
+                        // Remove this metadata item so that
+                        // we don't use it as a parameter name.
+                        keysToRemove.Add(key);
+
+                        // If the value is true, the parameter value will be the exact code
+                        // that needs to be written to the generated file for that parameter.
+                        if (string.Equals(value, "true", StringComparison.OrdinalIgnoreCase))
+                        {
+                            parameterTypes[parameterNameKey] = new ParameterType {
+                                Kind = ParameterTypeKind.Literal
+                            };
+                        }
+                    }
+                }
+            }
+
+            // Remove any metadata items that we used
+            // for type names or literal flags.
+            if (keysToRemove != null)
+            {
+                foreach (var key in keysToRemove)
+                {
+                    customMetadata.Remove(key);
+                }
+            }
+
+            return parameterTypes ?? EmptyParameterTypes;
+        }
+
+        /// <summary>
+        /// Uses the given parameters to add CodeDom arguments to the given attribute.
+        /// Returns true if the arguments could be defined, or false if the values could
+        /// not be converted to the required type. An error is also logged for failures.
+        /// </summary>
+        private bool AddArguments(
+            CodeAttributeDeclaration attribute,
+            Lazy<Type> attributeType,
+            IReadOnlyList<AttributeParameter> parameters,
+            bool isPositional
+        )
+        {
+            Type[] constructorParameterTypes = null;
+
+            for (int i = 0; i < parameters.Count; i++)
+            {
+                AttributeParameter parameter = parameters[i];
+                CodeExpression value;
+
+                switch (parameter.Type.Kind)
+                {
+                    case ParameterTypeKind.Literal:
+                        // The exact value provided by the metadata is what we use.
+                        // Note that this value is used verbatim, so its the user's
+                        // responsibility to ensure that it is in the correct language.
+                        value = new CodeSnippetExpression(parameter.Value);
+                        break;
+
+                    case ParameterTypeKind.Typed:
+                        if (string.Equals(parameter.Type.TypeName, "System.Type"))
+                        {
+                            // Types are a special case, because we can't convert a string to a
+                            // type, but because we're using the CodeDom, we don't need to
+                            // convert it. we can just create a type expression.
+                            value = new CodeTypeOfExpression(parameter.Value);
+                        }
+                        else
+                        {
+                            // We've been told what type this parameter needs to be.
+                            // If we cannot convert the value to that type, then we need to fail.
+                            if (!TryConvertParameterValue(parameter.Type.TypeName, parameter.Value, out value))
+                            {
+                                return false;
+                            }
+                        }
+
+                        break;
+
+                    default:
+                        if (isPositional)
+                        {
+                            // For positional parameters, infer the type
+                            // using the constructor argument types.
+                            if (constructorParameterTypes is null)
+                            {
+                                constructorParameterTypes = FindPositionalParameterTypes(attributeType.Value, parameters);
+                            }
+
+                            value = ConvertParameterValueToInferredType(
+                                constructorParameterTypes[i],
+                                parameter.Value,
+                                $"#{i + 1}" /* back to 1 based */
+                            );
+                        }
+                        else
+                        {
+                            // For named parameters, use the type of the property if we can find it.
+                            value = ConvertParameterValueToInferredType(
+                                attributeType.Value?.GetProperty(parameter.Name)?.PropertyType,
+                                parameter.Value,
+                                parameter.Name
+                            );
+                        }
+
+                        break;
+
+                }
+
+                attribute.Arguments.Add(new CodeAttributeArgument(parameter.Name, value));
+            }
+
+            return true;
+        }
+
+        /// <summary>
+        /// Finds the types that the parameters are likely to be, by finding a constructor
+        /// on the attribute that has the same number of parameters that have been provided.
+        /// Returns an array of types with a length equal to the number of positional parameters.
+        /// If no suitable constructor is found, the array will contain null types.
+        /// </summary>
+        private Type[] FindPositionalParameterTypes(Type attributeType, IReadOnlyList<AttributeParameter> positionalParameters)
+        {
+            // The attribute type might not be known.
+            if (attributeType is not null)
+            {
+                // Find the constructors with the same number
+                // of parameters as we will be specifying.
+                List<Type[]> candidates = attributeType
+                    .GetConstructors()
+                    .Select(c => c.GetParameters().Select(p => p.ParameterType).ToArray())
+                    .Where(t => t.Length == positionalParameters.Count)
+                    .ToList();
+
+                if (candidates.Count == 1)
+                {
+                    return candidates[0];
+                }
+                else if (candidates.Count > 1)
+                {
+                    Log.LogMessageFromResources("WriteCodeFragment.MultipleConstructorsFound");
+
+                    // Before parameter types could be specified, all parameter values were
+                    // treated as strings. To be backward-compatible, we need to prefer 
+                    // the constructor that has all string parameters, if it exists.
+                    var allStringParameters = candidates.FirstOrDefault(c => c.All(t => t == typeof(string)));
+
+                    if (allStringParameters is not null)
+                    {
+                        return allStringParameters;
+                    }
+
+                    // There isn't a constructor where all parameters are strings, so we can pick any
+                    // of the constructors. This code path is very unlikely to be hit because we can only
+                    // infer parameter types for attributes in mscorlib (or System.Private.CoreLib).
+                    // The attribute type is loaded using `Type.GetType()`, and when you specify just a
+                    // type name and not an assembly-qualified type name, only types in this assembly
+                    // or mscorlib will be found.
+                    //
+                    // There are only about five attributes that would result in this code path being
+                    // reached due to those attributes having multiple constructors with the same number
+                    // of parameters. For that reason, it's not worth putting too much effort into picking
+                    // the best constructor. We will use the simple solution of sorting the constructors
+                    // (so that we always pick the same constructor, regardless of the order they are
+                    // returned from `Type.GetConstructors()`), and choose the first constructor.
+                    return candidates
+                        .OrderBy(c => string.Join(",", c.Select(t => t.FullName)))
+                        .First();
+                }
+            }
+
+            // If a matching constructor was not found, or we don't
+            // know the attribute type, then return an array of null
+            // types to indicate that each parameter type is unknown.
+            return positionalParameters.Select(x => default(Type)).ToArray();
+        }
+
+        /// <summary>
+        /// Attempts to convert the raw value provided in the metadata to the type with the specified name.
+        /// Returns true if conversion is successful. An error is logged and false is returned if the conversion fails.
+        /// </summary>
+        private bool TryConvertParameterValue(string typeName, string rawValue, out CodeExpression value)
+        {
+            var parameterType = Type.GetType(typeName, throwOnError: false);
+
+            if (parameterType is null)
+            {
+                Log.LogErrorWithCodeFromResources("WriteCodeFragment.ParameterTypeNotFound", typeName);
+                value = null;
+                return false;
+            }
+
+            try
+            {
+                value = ConvertToCodeExpression(rawValue, parameterType);
+                return true;
+            }
+            catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+            {
+                Log.LogErrorWithCodeFromResources("WriteCodeFragment.CouldNotConvertValue", rawValue, typeName, ex.Message);
+                value = null;
+                return false;
+            }
+        }
+
+        /// <summary>
+        /// Convert the raw value provided in the metadata to the type
+        /// that has been inferred based on the parameter position or name.
+        /// Returns the converted value as a CodeExpression if successful, or the raw value
+        /// as a CodeExpression if conversion fails. No errors are logged if the conversion fails.
+        /// </summary>
+        private CodeExpression ConvertParameterValueToInferredType(Type inferredType, string rawValue, string parameterName)
+        {
+            // If we don't know what type the parameter should be, then we 
+            // can't convert the type. We'll just treat is as a string.
+            if (inferredType is null)
+            {
+                Log.LogMessageFromResources("WriteCodeFragment.CouldNotInferParameterType", parameterName);
+                return new CodePrimitiveExpression(rawValue);
+            }
+
+            try
+            {
+                return ConvertToCodeExpression(rawValue, inferredType);
+            }
+            catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+            {
+                // The conversion failed, but since we are inferring the type,
+                // we won't fail. We'll just treat the value as a string.
+                Log.LogMessageFromResources("WriteCodeFragment.CouldNotConvertToInferredType", parameterName, inferredType.Name, ex.Message);
+                return new CodePrimitiveExpression(rawValue);
+            }
+        }
+
+        /// <summary>
+        /// Converts the given value to a CodeExpression object where the value is the specified type.
+        /// Returns the CodeExpression if successful, or throws an exception if the conversion fails.
+        /// </summary>
+        private CodeExpression ConvertToCodeExpression(string value, Type targetType)
+        {
+            if (targetType == typeof(Type))
+            {
+                return new CodeTypeOfExpression(value);
+            }
+
+            if (targetType.IsEnum)
+            {
+                return new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(targetType), value);
+            }
+
+            return new CodePrimitiveExpression(Convert.ChangeType(value, targetType, CultureInfo.InvariantCulture));
+        }
+
+        private enum ParameterTypeKind
+        {
+            Inferred,
+            Typed,
+            Literal
+        }
+
+        private struct ParameterType
+        {
+            public ParameterTypeKind Kind { get; init; }
+            public string TypeName { get; init; }
+        }
+
+        private struct AttributeParameter
+        {
+            public ParameterType Type { get; init; }
+            public string Name { get; init; }
+            public string Value { get; init; }
+        }
     }
 }
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 819fff3bf65..fdb9263ac2e 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -130,6 +130,12 @@ public MuxLogger()
         /// </summary>
         public bool IncludeTaskInputs { get; set; }
 
+        /// <summary>
+        /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>?
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems { get; set; }
+
         /// <summary>
         /// Initialize the logger.
         /// </summary>
@@ -159,6 +165,7 @@ public void Initialize(IEventSource eventSource, int maxNodeCount)
                 {
                     eventSource3.IncludeEvaluationMetaprojects();
                 }
+
                 if (IncludeEvaluationProfiles)
                 {
                     eventSource3.IncludeEvaluationProfiles();
@@ -169,6 +176,14 @@ public void Initialize(IEventSource eventSource, int maxNodeCount)
                     eventSource3.IncludeTaskInputs();
                 }
             }
+
+            if (_eventSourceForBuild is IEventSource4 eventSource4)
+            {
+                if (IncludeEvaluationPropertiesAndItems)
+                {
+                    eventSource4.IncludeEvaluationPropertiesAndItems();
+                }
+            }
         }
 
         /// <summary>
