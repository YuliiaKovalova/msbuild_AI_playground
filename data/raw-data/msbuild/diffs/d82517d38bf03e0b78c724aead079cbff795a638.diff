diff --git a/MSBuild.Dev.slnf b/MSBuild.Dev.slnf
index 893aa59154f..dde79ca09e4 100644
--- a/MSBuild.Dev.slnf
+++ b/MSBuild.Dev.slnf
@@ -6,17 +6,36 @@
       "src\\Build.UnitTests\\Microsoft.Build.Engine.UnitTests.csproj",
       "src\\BuildCheck.UnitTests\\Microsoft.Build.BuildCheck.UnitTests.csproj",
       "src\\Build\\Microsoft.Build.csproj",
+      "src\\Deprecated\\Conversion\\Microsoft.Build.Conversion.csproj",
+      "src\\Deprecated\\Engine\\Microsoft.Build.Engine.csproj",
       "src\\Framework.UnitTests\\Microsoft.Build.Framework.UnitTests.csproj",
       "src\\Framework\\Microsoft.Build.Framework.csproj",
+      "src\\MSBuild.Bootstrap\\MSBuild.Bootstrap.csproj",
       "src\\MSBuild.UnitTests\\Microsoft.Build.CommandLine.UnitTests.csproj",
+      "src\\MSBuildTaskHost\\MSBuildTaskHost.csproj",
       "src\\MSBuild\\MSBuild.csproj",
+      "src\\Package\\DevDivPackage\\DevDivPackage.csproj",
+      "src\\Package\\Localization\\Localization.csproj",
+      "src\\Package\\MSBuild.VSSetup.Arm64\\MSBuild.VSSetup.Arm64.csproj",
+      "src\\Package\\MSBuild.VSSetup\\MSBuild.VSSetup.csproj",
+      "src\\Package\\Microsoft.Build.UnGAC\\Microsoft.Build.UnGAC.csproj",
+      "src\\Samples\\Dependency\\Dependency.csproj",
+      "src\\Samples\\PortableTask\\PortableTask.csproj",
+      "src\\Samples\\ProjectCachePlugin\\ProjectCachePlugin.csproj",
+      "src\\Samples\\TaskUsageLogger\\TaskUsageLogger.csproj",
+      "src\\Samples\\TaskWithDependency\\TaskWithDependency.csproj",
+      "src\\Samples\\XmlFileLogger\\XmlFileLogger.csproj",
+      "src\\StringTools.Benchmark\\StringTools.Benchmark.csproj",
+      "src\\StringTools.UnitTests\\StringTools.UnitTests.csproj",
+      "src\\StringTools.UnitTests\\StringTools.UnitTests.net35.csproj",
       "src\\StringTools\\StringTools.csproj",
       "src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj",
       "src\\Tasks\\Microsoft.Build.Tasks.csproj",
       "src\\UnitTests.Shared\\Microsoft.Build.UnitTests.Shared.csproj",
       "src\\Utilities.UnitTests\\Microsoft.Build.Utilities.UnitTests.csproj",
       "src\\Utilities\\Microsoft.Build.Utilities.csproj",
-      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj"
+      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj",
+      "template_feed\\Microsoft.Build.Templates.csproj"
     ]
   }
-}
+}
\ No newline at end of file
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index d1e4654f648..027922a1c8a 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -663,10 +663,10 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)
 
         #endregion
 
-        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)
+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext checkContext)
         { /* Ignore the data */ }
 
-        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext analysisContext)
+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext checkContext)
         { /* Ignore the data */ }
     }
 }
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 9657019dc00..0ce71397288 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -840,7 +840,7 @@ public bool Question
         }
 
         /// <summary>
-        /// Gets or sets an indication of build analysis enablement.
+        /// Gets or sets an indication of build check enablement.
         /// </summary>
         public bool IsBuildCheckEnabled
         {
diff --git a/src/Build/BuildCheck/API/BuildCheckResult.cs b/src/Build/BuildCheck/API/BuildCheckResult.cs
index f030e9780b7..040c7ec3d25 100644
--- a/src/Build/BuildCheck/API/BuildCheckResult.cs
+++ b/src/Build/BuildCheck/API/BuildCheckResult.cs
@@ -9,7 +9,7 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Representation of a single report of a single finding from a BuildAnalyzer
+/// Representation of a single report of a single finding from a BuildCheck
 /// Each rule has upfront known message format - so only the concrete arguments are added
 /// Optionally a location is attached - in the near future we might need to support multiple locations
 ///  (for 2 cases - a) grouped result for multiple occurrences; b) a single report for a finding resulting from combination of multiple locations)
diff --git a/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs b/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs
index 30190647fb5..546e1259153 100644
--- a/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs
+++ b/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs
@@ -9,11 +9,11 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Configuration for a build analyzer.
-/// Default values can be specified by the Analyzer in code.
+/// Configuration for a build check.
+/// Default values can be specified by the Check in code.
 /// Users can overwrite the defaults by explicit settings in the .editorconfig file.
 /// Each rule can have its own configuration, which can differ per each project.
-/// The <see cref="EvaluationAnalysisScope"/> setting must be same for all rules in the same analyzer (but can differ between projects)
+/// The <see cref="EvaluationCheckScope"/> setting must be same for all rules in the same check (but can differ between projects)
 /// </summary>
 public class BuildExecutionCheckConfiguration
 {
@@ -31,7 +31,7 @@ public class BuildExecutionCheckConfiguration
 
     /// <summary>
     /// This applies only to specific events, that can distinguish whether they are directly inferred from
-    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from analysis.
+    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from check.
     ///
     /// If not supported by the data source - then the setting is ignored
     /// </summary>
@@ -43,14 +43,14 @@ public class BuildExecutionCheckConfiguration
     public BuildExecutionCheckResultSeverity? Severity { get; internal init; }
 
     /// <summary>
-    /// Whether the analyzer rule is enabled.
-    /// If all rules within the analyzer are not enabled, it will not be run.
-    /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.
+    /// Whether the check rule is enabled.
+    /// If all rules within the check are not enabled, it will not be run.
+    /// If some rules are enabled and some are not, the check will be run and reports will be post-filtered.
     /// </summary>
     public bool? IsEnabled {
         get
         {
-            // Do not consider Default as enabled, because the default severity of the rule coule be set to None
+            // Do not consider Default as enabled, because the default severity of the rule could be set to None
             if (Severity.HasValue && Severity.Value != BuildExecutionCheckResultSeverity.Default)
             {
                 return !Severity.Value.Equals(BuildExecutionCheckResultSeverity.None);
@@ -61,20 +61,20 @@ public bool? IsEnabled {
     }
 
     /// <summary>
-    /// Creates a <see cref="BuildAnalyzerConfiguration"/> object based on the provided configuration dictionary.
-    /// If the BuildAnalyzerConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
+    /// Creates a <see cref="BuildExecutionCheckConfiguration"/> object based on the provided configuration dictionary.
+    /// If the BuildCheckConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
     /// If parsing failed the value will be equal to null.
     /// </summary>
-    /// <param name="configDictionary">The configuration dictionary containing the settings for the build analyzer. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
-    /// <returns>A new instance of <see cref="BuildAnalyzerConfiguration"/> with the specified settings.</returns>
+    /// <param name="configDictionary">The configuration dictionary containing the settings for the build check. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
+    /// <returns>A new instance of <see cref="BuildExecutionCheckConfiguration"/> with the specified settings.</returns>
     internal static BuildExecutionCheckConfiguration Create(Dictionary<string, string>? configDictionary) => new()
     {
-        EvaluationCheckScope = TryExtractEvaluationAnalysisScope(configDictionary),
+        EvaluationCheckScope = TryExtractEvaluationCheckScope(configDictionary),
         Severity = TryExtractSeverity(configDictionary),
     };
 
 
-    private static EvaluationCheckScope? TryExtractEvaluationAnalysisScope(Dictionary<string, string>? config)
+    private static EvaluationCheckScope? TryExtractEvaluationCheckScope(Dictionary<string, string>? config)
     {
 
         if (!TryExtractValue(BuildCheckConstants.scopeConfigurationKey, config, out string? stringValue) || stringValue is null)
diff --git a/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs b/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs
index ee6e008b71e..62a48e501ea 100644
--- a/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs
+++ b/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs
@@ -4,8 +4,8 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Represents a rule that is a unit of build analysis.
-/// <see cref="BuildExecutionCheck"/> is a unit of executing the analysis, but it can be discovering multiple distinct violation types,
+/// Represents a rule that is a unit of a build check.
+/// <see cref="BuildExecutionCheck"/> is a unit of executing the check, but it can be discovering multiple distinct violation types,
 ///  for this reason a single <see cref="BuildExecutionCheck"/> can expose multiple <see cref="BuildExecutionCheckRule"/>s.
 /// </summary>
 public class BuildExecutionCheckRule
diff --git a/src/Build/BuildCheck/API/EvaluationCheckScope.cs b/src/Build/BuildCheck/API/EvaluationCheckScope.cs
index d5f16020b34..2ac88ed5518 100644
--- a/src/Build/BuildCheck/API/EvaluationCheckScope.cs
+++ b/src/Build/BuildCheck/API/EvaluationCheckScope.cs
@@ -5,29 +5,29 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
 /// For datasource events that can differentiate from where exactly they originate - e.g.
-///  For a condition string or AST - was that directly in hte analyzed project or imported?
+///  For a condition string or AST - was that directly in the checked project or imported?
 ///
 /// Ignored by infrastructure if the current datasource doesn't support this level of setting.
 /// </summary>
 public enum EvaluationCheckScope
 {
     /// <summary>
-    /// Only the data from currently analyzed project will be sent to the analyzer. Imports will be discarded.
+    /// Only the data from currently checked project will be sent to the check. Imports will be discarded.
     /// </summary>
     ProjectOnly,
 
     /// <summary>
-    /// Only the data from currently analyzed project and imports from files under the entry project or solution will be sent to the analyzer. Other imports will be discarded.
+    /// Only the data from currently checked project and imports from files under the entry project or solution will be sent to the checks. Other imports will be discarded.
     /// </summary>
     ProjectWithImportsFromCurrentWorkTree,
 
     /// <summary>
-    /// Imports from SDKs will not be sent to the analyzer. Other imports will be sent.
+    /// Imports from SDKs will not be sent to the check. Other imports will be sent.
     /// </summary>
     ProjectWithImportsWithoutSdks,
 
     /// <summary>
-    /// All data will be sent to the analyzer.
+    /// All data will be sent to the check.
     /// </summary>
     ProjectWithAllImports,
 }
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index aeb29f53a37..a6443309645 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -23,11 +23,11 @@ internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
 #endif
 
     /// <summary>
-    /// Creates a list of factory delegates for building analyzer rules instances from a given assembly path.
+    /// Creates a list of factory delegates for building check rules instances from a given assembly path.
     /// </summary>
     public List<BuildExecutionCheckFactory> CreateBuildExecutionCheckFactories(
         CheckAcquisitionData checkAcquisitionData,
-        ICheckContext analysisContext)
+        ICheckContext checkContext)
     {
         var checksFactories = new List<BuildExecutionCheckFactory>();
 
@@ -46,13 +46,13 @@ public List<BuildExecutionCheckFactory> CreateBuildExecutionCheckFactories(
             foreach (Type checkCandidate in checkTypes)
             {
                 checksFactories.Add(() => (BuildExecutionCheck)Activator.CreateInstance(checkCandidate)!);
-                analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerRegistered", checkCandidate.Name, checkCandidate.Assembly);
+                checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckRegistered", checkCandidate.Name, checkCandidate.Assembly);
             }
 
             if (availableTypes.Count != checkTypes.Count)
             {
                 availableTypes.Except(checkTypes).ToList()
-                    .ForEach(t => analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerBaseTypeNotAssignable", t.Name, t.Assembly));
+                    .ForEach(t => checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckBaseTypeNotAssignable", t.Name, t.Assembly));
             }
         }
         catch (ReflectionTypeLoadException ex)
@@ -61,13 +61,13 @@ public List<BuildExecutionCheckFactory> CreateBuildExecutionCheckFactories(
             {
                 foreach (Exception? loaderException in ex.LoaderExceptions)
                 {
-                    analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerFailedRuleLoading", loaderException?.Message);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", loaderException?.Message);
                 }
             }
         }
         catch (Exception ex)
         {
-            analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerFailedRuleLoading", ex?.Message);
+            checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", ex?.Message);
         }
 
         return checksFactories;
diff --git a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
index 8b06dd966a8..68ea3314298 100644
--- a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
@@ -10,7 +10,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 internal interface IBuildCheckAcquisitionModule
 {
     /// <summary>
-    /// Creates a list of factory delegates for building analyzer rules instances from a given assembly path.
+    /// Creates a list of factory delegates for building check rules instances from a given assembly path.
     /// </summary>
-    List<BuildExecutionCheckFactory> CreateBuildExecutionCheckFactories(CheckAcquisitionData analyzerAcquisitionData, ICheckContext analysisContext);
+    List<BuildExecutionCheckFactory> CreateBuildExecutionCheckFactories(CheckAcquisitionData checkAcquisitionData, ICheckContext checkContext);
 }
diff --git a/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
index 0ecc016d3d7..a2e2f51210c 100644
--- a/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
+++ b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
@@ -27,7 +27,7 @@ internal sealed class DoubleWritesCheck : BuildExecutionCheck
         "Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.",
         new BuildExecutionCheckConfiguration() { Severity = BuildExecutionCheckResultSeverity.Warning });
 
-    public override string FriendlyName => "MSBuild.DoubleWritesAnalyzer";
+    public override string FriendlyName => "MSBuild.DoubleWritesCheck";
 
     public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = [SupportedRule];
 
@@ -48,37 +48,37 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
 
     private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
-        // This analyzer uses a hard-coded list of tasks known to write files.
+        // This check uses a hard-coded list of tasks known to write files.
         switch (context.Data.TaskName)
         {
             case "Csc":
             case "Vbc":
-            case "Fsc": AnalyzeCompilerTask(context); break;
-            case "Copy": AnalyzeCopyTask(context); break;
+            case "Fsc": CheckCompilerTask(context); break;
+            case "Copy": CheckCopyTask(context); break;
         }
     }
 
-    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationCheckData> context)
+    private void CheckCompilerTask(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
         var taskParameters = context.Data.Parameters;
 
         // Compiler tasks have several parameters representing files being written.
-        AnalyzeParameter("OutputAssembly");
-        AnalyzeParameter("OutputRefAssembly");
-        AnalyzeParameter("DocumentationFile");
-        AnalyzeParameter("PdbFile");
+        CheckParameter("OutputAssembly");
+        CheckParameter("OutputRefAssembly");
+        CheckParameter("DocumentationFile");
+        CheckParameter("PdbFile");
 
-        void AnalyzeParameter(string parameterName)
+        void CheckParameter(string parameterName)
         {
             if (taskParameters.TryGetValue(parameterName, out TaskParameter? taskParameter))
             {
                 string outputPath = taskParameter.EnumerateStringValues().FirstOrDefault() ?? "";
-                AnalyzeWrite(context, outputPath);
+                CheckWrite(context, outputPath);
             }
         }
     }
 
-    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationCheckData> context)
+    private void CheckCopyTask(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
         var taskParameters = context.Data.Parameters;
 
@@ -89,19 +89,19 @@ private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationCheckData> cont
             string destinationFolderPath = destinationFolder.EnumerateStringValues().FirstOrDefault() ?? "";
             foreach (string sourceFilePath in sourceFiles.EnumerateStringValues())
             {
-                AnalyzeWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));
+                CheckWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));
             }
         }
         else if (taskParameters.TryGetValue("DestinationFiles", out TaskParameter? destinationFiles))
         {
             foreach (string destinationFilePath in destinationFiles.EnumerateStringValues())
             {
-                AnalyzeWrite(context, destinationFilePath);
+                CheckWrite(context, destinationFilePath);
             }
         }
     }
 
-    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationCheckData> context, string fileBeingWritten)
+    private void CheckWrite(BuildCheckDataContext<TaskInvocationCheckData> context, string fileBeingWritten)
     {
         if (!string.IsNullOrEmpty(fileBeingWritten))
         {
diff --git a/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
index eda747f80a1..0d22fcf1ee3 100644
--- a/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
+++ b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
@@ -16,12 +16,12 @@ internal sealed class NoEnvironmentVariablePropertyCheck : BuildExecutionCheck
 
     public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(
         "BC0103",
-        "NoEnvironmentVariablePropertyAnalyzer",
+        "NoEnvironmentVariablePropertyCheck",
         "No implicit property derived from an environment variable should be used during the build",
         "Property is derived from environment variable: '{0}' with value: '{1}'. Properties should be passed explicitly using the /p option.",
         new BuildExecutionCheckConfiguration() { Severity = BuildExecutionCheckResultSeverity.Suggestion });
 
-    public override string FriendlyName => "MSBuild.NoEnvironmentVariablePropertyAnalyzer";
+    public override string FriendlyName => "MSBuild.NoEnvironmentVariablePropertyCheck";
 
     public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = [SupportedRule];
 
diff --git a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
index 0bf498b1de5..9fdaf5af0e0 100644
--- a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
+++ b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
@@ -21,7 +21,7 @@ internal sealed class SharedOutputPathCheck : BuildExecutionCheck
         "Projects {0} and {1} have conflicting output paths: {2}.",
         new BuildExecutionCheckConfiguration() { RuleId = RuleId, Severity = BuildExecutionCheckResultSeverity.Warning });
 
-    public override string FriendlyName => "MSBuild.SharedOutputPathAnalyzer";
+    public override string FriendlyName => "MSBuild.SharedOutputPathCheck";
 
     public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = [SupportedRule];
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index c796d502a7a..5266d458905 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -11,7 +11,7 @@
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
-/// A manager of the runs of the analyzers - deciding based on configuration of what to run and what to postfilter.
+/// A manager of the runs of the checks - deciding based on configuration of what to run and what to postfilter.
 /// </summary>
 internal sealed class BuildCheckCentralContext
 {
@@ -44,7 +44,7 @@ internal void DeregisterCheck(BuildExecutionCheckWrapper check)
     private readonly CallbackRegistry _globalCallbacks = new();
 
     // This we can potentially use to subscribe for receiving evaluated props in the
-    //  build event args. However - this needs to be done early on, when analyzers might not be known yet
+    //  build event args. However - this needs to be done early on, when checks might not be known yet
     internal bool HasEvaluatedPropertiesActions => _globalCallbacks.EvaluatedPropertiesActions.Count > 0;
 
     internal bool HasParsedItemsActions => _globalCallbacks.ParsedItemsActions.Count > 0;
@@ -130,19 +130,19 @@ internal void RunPropertyReadActions(
 
     internal void RunPropertyWriteActions(
         PropertyWriteData propertyWriteData,
-        CheckLoggingContext analysisContext,
+        CheckLoggingContext checkContext,
         Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.PropertyWriteActions, propertyWriteData,
-            analysisContext, resultHandler);
+            checkContext, resultHandler);
 
     internal void RunProjectProcessingDoneActions(
         ProjectProcessingDoneData projectProcessingDoneData,
-        ICheckContext analysisContext,
+        ICheckContext checkContext,
         Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.ProjectProcessingDoneActions, projectProcessingDoneData,
-            analysisContext, resultHandler);
+            checkContext, resultHandler);
 
     private void RunRegisteredActions<T>(
         List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
@@ -156,7 +156,7 @@ private void RunRegisteredActions<T>(
         foreach (var checkCallback in registeredCallbacks)
         {
             // Tracing - https://github.com/dotnet/msbuild/issues/9629 - we might want to account this entire block
-            //  to the relevant analyzer (with BuildAnalyzerConfigurationEffectiveonly the currently accounted part as being the 'core-execution' subspan)
+            //  to the relevant check (with BuildCheckConfigurationEffectively the currently accounted part as being the 'core-execution' subspan)
 
             BuildExecutionCheckConfigurationEffective? commonConfig = checkCallback.Item1.CommonConfig;
             BuildExecutionCheckConfigurationEffective[] configPerRule;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
index 69f3335681d..00cb17cff70 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
@@ -13,7 +13,7 @@ internal sealed class BuildCheckConfigurationException : Exception
 {
     /// <summary>
     /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.
-    /// This exception usually leads to defuncting the particular analyzer for the rest of the build (even if issue occured with a single project).
+    /// This exception usually leads to defuncting the particular check for the rest of the build (even if issue occured with a single project).
     /// </summary>
     internal BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope;
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 3f194ac699a..fec3ebc7f26 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -88,7 +88,7 @@ internal BuildCheckManager()
 
         /// <summary>
         /// Notifies the manager that the data source will be used -
-        ///   so it should register the built-in analyzers for the source if it hasn't been done yet.
+        ///   so it should register the built-in checks for the source if it hasn't been done yet.
         /// </summary>
         /// <param name="buildCheckDataSource"></param>
         public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
@@ -117,7 +117,7 @@ public void ProcessCheckAcquisition(
                 }
                 else
                 {
-                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerFailedAcquisition", acquisitionData.AssemblyPath);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedAcquisition", acquisitionData.AssemblyPath);
                 }
             }
             else
@@ -147,7 +147,7 @@ private static readonly (string[] ruleIds, bool defaultEnablement, BuildExecutio
         ];
 
         /// <summary>
-        /// For tests only. TODO: Remove when analyzer acquisition is done.
+        /// For tests only. TODO: Remove when check acquisition is done.
         /// </summary>
         internal static (string[] ruleIds, bool defaultEnablement, BuildExecutionCheckFactory factory)[][]? s_testFactoriesPerDataSource;
 
@@ -167,7 +167,7 @@ private void RegisterBuiltInChecks(BuildCheckDataSource buildCheckDataSource)
 
         /// <summary>
         /// To be used by acquisition module.
-        /// Registers the custom analyzers, the construction of analyzers is deferred until the first using project is encountered.
+        /// Registers the custom checks, the construction of checks is deferred until the first using project is encountered.
         /// </summary>
         internal void RegisterCustomChecks(
             BuildCheckDataSource buildCheckDataSource,
@@ -183,18 +183,18 @@ internal void RegisterCustomChecks(
                     _checkRegistry.Add(new BuildExecutionCheckFactoryContext(factory, ruleIds, defaultEnablement));
 
                     var instance = factory();
-                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckSuccessfulAcquisition", instance.FriendlyName);
                 }
             }
         }
 
         /// <summary>
         /// To be used by acquisition module
-        /// Registers the custom analyzer, the construction of analyzer is needed during registration.
+        /// Registers the custom check, the construction of check is needed during registration.
         /// </summary>
         /// <param name="buildCheckDataSource">Represents different data sources used in build check operations.</param>
-        /// <param name="factories">A collection of build analyzer factories for rules instantiation.</param>
-        /// <param name="analysisContext">The logging context of the build event.</param>
+        /// <param name="factories">A collection of build check factories for rules instantiation.</param>
+        /// <param name="checkContext">The logging context of the build event.</param>
         internal void RegisterCustomCheck(
             BuildCheckDataSource buildCheckDataSource,
             IEnumerable<BuildExecutionCheckFactory> factories,
@@ -209,17 +209,17 @@ internal void RegisterCustomCheck(
                         factory,
                         instance.SupportedRules.Select(r => r.Id).ToArray(),
                         instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
-                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckSuccessfulAcquisition", instance.FriendlyName);
                 }
             }
         }
 
         private void SetupSingleCheck(BuildExecutionCheckFactoryContext checkFactoryContext, string projectFullPath)
         {
-            // For custom analyzers - it should run only on projects where referenced
+            // For custom checks - it should run only on projects where referenced
             // (otherwise error out - https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57849480)
             // on others it should work similarly as disabling them.
-            // Disabled analyzer should not only post-filter results - it shouldn't even see the data 
+            // Disabled check should not only post-filter results - it shouldn't even see the data 
             BuildExecutionCheckWrapper wrapper;
             BuildExecutionCheckConfigurationEffective[] configurations;
             if (checkFactoryContext.MaterializedCheck == null)
@@ -229,7 +229,7 @@ private void SetupSingleCheck(BuildExecutionCheckFactoryContext checkFactoryCont
 
                 if (userConfigs.All(c => !(c.IsEnabled ?? checkFactoryContext.IsEnabledByDefault)))
                 {
-                    // the analyzer was not yet instantiated nor mounted - so nothing to do here now.
+                    // the check was not yet instantiated nor mounted - so nothing to do here now.
                     return;
                 }
 
@@ -245,7 +245,7 @@ private void SetupSingleCheck(BuildExecutionCheckFactoryContext checkFactoryCont
                 checkFactoryContext.MaterializedCheck = wrapper;
                 BuildExecutionCheck check = wrapper.BuildExecutionCheck;
 
-                // This is to facilitate possible perf improvement for custom analyzers - as we might want to
+                // This is to facilitate possible perf improvement for custom checks - as we might want to
                 //  avoid loading the assembly and type just to check if it's supported.
                 // If we expose a way to declare the enablement status and rule ids during registration (e.g. via
                 //  optional arguments of the intrinsic property function) - we can then avoid loading it.
@@ -258,10 +258,10 @@ private void SetupSingleCheck(BuildExecutionCheckFactoryContext checkFactoryCont
                 )
                 {
                     throw new BuildCheckConfigurationException(
-                        $"The analyzer '{check.FriendlyName}' exposes rules '{check.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{checkFactoryContext.RuleIds.ToCsvString()}'");
+                        $"The check '{check.FriendlyName}' exposes rules '{check.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{checkFactoryContext.RuleIds.ToCsvString()}'");
                 }
 
-                // technically all analyzers rules could be disabled, but that would mean
+                // technically all checks rules could be disabled, but that would mean
                 // that the provided 'IsEnabledByDefault' value wasn't correct - the only
                 // price to be paid in that case is slight performance cost.
 
@@ -286,7 +286,7 @@ private void SetupSingleCheck(BuildExecutionCheckFactoryContext checkFactoryCont
             if (configurations.GroupBy(c => c.EvaluationCheckScope).Count() > 1)
             {
                 throw new BuildCheckConfigurationException(
-                    string.Format("All rules for a single analyzer should have the same EvaluationAnalysisScope for a single project (violating rules: [{0}], project: {1})",
+                    string.Format("All rules for a single check should have the same EvaluationCheckScope for a single project (violating rules: [{0}], project: {1})",
                         checkFactoryContext.RuleIds.ToCsvString(),
                         projectFullPath));
             }
@@ -294,8 +294,8 @@ private void SetupSingleCheck(BuildExecutionCheckFactoryContext checkFactoryCont
 
         private void SetupChecksForNewProject(string projectFullPath, ICheckContext checkContext)
         {
-            // Only add analyzers here
-            // On an execution node - we might remove and dispose the analyzers once project is done
+            // Only add checks here
+            // On an execution node - we might remove and dispose the checks once project is done
 
             // If it's already constructed - just control the custom settings do not differ
             Stopwatch stopwatch = Stopwatch.StartNew();
@@ -321,7 +321,7 @@ private void SetupChecksForNewProject(string projectFullPath, ICheckContext chec
             checksToRemove.ForEach(c =>
             {
                 _checkRegistry.Remove(c);
-                checkContext.DispatchAsCommentFromText(MessageImportance.High, $"Dismounting analyzer '{c.FriendlyName}'");
+                checkContext.DispatchAsCommentFromText(MessageImportance.High, $"Dismounting check '{c.FriendlyName}'");
             });
             foreach (var checkToRemove in checksToRemove.Select(a => a.MaterializedCheck).Where(a => a != null))
             {
@@ -447,7 +447,7 @@ public void StartProjectEvaluation(
 
         /*
          *
-         * Following methods are for future use (should we decide to approach in-execution analysis)
+         * Following methods are for future use (should we decide to approach in-execution check)
          *
          */
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index b3a555da595..a620248a142 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -17,7 +17,7 @@ internal class BuildEventsProcessor(BuildCheckCentralContext buildCheckCentralCo
     /// Represents a task currently being executed.
     /// </summary>
     /// <remarks>
-    /// <see cref="TaskParameters"/> is stored in its own field typed as a mutable dictionary because <see cref="AnalysisData"/>
+    /// <see cref="TaskParameters"/> is stored in its own field typed as a mutable dictionary because <see cref="CheckData"/>
     /// is immutable.
     /// </remarks>
     private struct ExecutingTaskData
@@ -94,7 +94,7 @@ internal void ProcessTaskStartedEventArgs(
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
         {
-            // No analyzer is interested in task invocation actions -> nothing to do.
+            // No check is interested in task invocation actions -> nothing to do.
             return;
         }
 
@@ -131,7 +131,7 @@ internal void ProcessTaskFinishedEventArgs(
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
         {
-            // No analyzer is interested in task invocation actions -> nothing to do.
+            // No check is interested in task invocation actions -> nothing to do.
             return;
         }
 
@@ -153,7 +153,7 @@ internal void ProcessTaskParameterEventArgs(
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
         {
-            // No analyzer is interested in task invocation actions -> nothing to do.
+            // No check is interested in task invocation actions -> nothing to do.
             return;
         }
 
@@ -209,7 +209,7 @@ private static void ReportResult(
         {
             checkContext.DispatchAsErrorFromText(null, null, null,
                 BuildEventFileInfo.Empty,
-                $"The analyzer '{checkWrapper.BuildExecutionCheck.FriendlyName}' reported a result for a rule '{result.BuildExecutionCheckRule.Id}' that it does not support.");
+                $"The check '{checkWrapper.BuildExecutionCheck.FriendlyName}' reported a result for a rule '{result.BuildExecutionCheckRule.Id}' that it does not support.");
             return;
         }
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckConfigurationEffective.cs b/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckConfigurationEffective.cs
index e1bad8f76c3..cc2b5d329ac 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckConfigurationEffective.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckConfigurationEffective.cs
@@ -7,7 +7,7 @@
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
-/// Counterpart type for BuildAnalyzerConfiguration - with all properties non-nullable
+/// Counterpart type for BuildCheckConfiguration - with all properties non-nullable
 /// </summary>
 public sealed class BuildExecutionCheckConfigurationEffective
 {
@@ -32,7 +32,7 @@ public BuildExecutionCheckConfigurationEffective(string ruleId, EvaluationCheckS
     public bool IsEnabled => Severity >= BuildExecutionCheckResultSeverity.Suggestion;
 
     // Intentionally not checking the RuleId
-    //  as for analyzers with multiple rules, we can squash config to a single one,
+    //  as for checks with multiple rules, we can squash config to a single one,
     //  if the ruleId is the only thing differing.
     public bool IsSameConfigurationAs(BuildExecutionCheckConfigurationEffective? other) =>
         other != null &&
diff --git a/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckWrapper.cs b/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckWrapper.cs
index 61d8521de2f..bb2e16171e2 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckWrapper.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckWrapper.cs
@@ -11,7 +11,7 @@
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
-/// A wrapping, enriching class for BuildAnalyzer - so that we have additional data and functionality.
+/// A wrapping, enriching class for BuildCheck - so that we have additional data and functionality.
 /// </summary>
 internal sealed class BuildExecutionCheckWrapper
 {
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index 944915af262..741019678b0 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -18,7 +18,7 @@ internal sealed class ConfigurationProvider
     private const string BuildCheck_ConfigurationKey = "build_check";
 
     /// <summary>
-    /// The dictionary used for storing the BuildAnalyzerConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
+    /// The dictionary used for storing the BuildCheckConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
     /// </summary>
     private readonly ConcurrentDictionary<string, BuildExecutionCheckConfiguration> _buildExecutionCheckConfiguration = new ConcurrentDictionary<string, BuildExecutionCheckConfiguration>(StringComparer.InvariantCultureIgnoreCase);
 
@@ -38,7 +38,7 @@ internal sealed class ConfigurationProvider
     };
 
     /// <summary>
-    /// Gets the user specified unrecognized configuration for the given analyzer rule.
+    /// Gets the user specified unrecognized configuration for the given check rule.
     /// 
     /// The configuration module should as well check that CustomConfigurationData
     ///  for a particular rule is equal across the whole build (for all projects)  - otherwise it should error out.
@@ -217,10 +217,10 @@ internal Dictionary<string, string> GetConfiguration(string projectFullPath, str
     }
 
     /// <summary>
-    /// Gets effective user specified (or default) configuration for the given analyzer rule.
+    /// Gets effective user specified (or default) configuration for the given check rule.
     /// The configuration values CAN be null upon this operation.
     /// 
-    /// The configuration module should as well check that BuildAnalyzerConfigurationInternal.EvaluationAnalysisScope
+    /// The configuration module should as well check that BuildCheckConfigurationInternal.EvaluationCheckScope
     ///  for all rules is equal - otherwise it should error out.
     /// </summary>
     /// <param name="projectFullPath"></param>
@@ -248,11 +248,11 @@ internal BuildExecutionCheckConfiguration GetUserConfiguration(string projectFul
     }
 
     /// <summary>
-    /// Gets effective configuration for the given analyzer rule.
+    /// Gets effective configuration for the given check rule.
     /// The configuration values are guaranteed to be non-null upon this merge operation.
     /// </summary>
     /// <param name="projectFullPath"></param>
-    /// <param name="analyzerRule"></param>
+    /// <param name="checkRule"></param>
     /// <returns></returns>
     internal BuildExecutionCheckConfigurationEffective GetMergedConfiguration(string projectFullPath, BuildExecutionCheckRule checkRule)
         => GetMergedConfiguration(projectFullPath, checkRule.Id, checkRule.DefaultConfiguration);
diff --git a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
index afd3645cf2e..04ffb953f05 100644
--- a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
+++ b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Holder for the key-value pairs of unstructured data from .editorconfig file,
 ///  that were attribute to a particular rule, but were not recognized by the infrastructure.
-/// The configuration data that is recognized by the infrastructure is passed as <see cref="BuildAnalyzerConfiguration"/>.
+/// The configuration data that is recognized by the infrastructure is passed as <see cref="BuildExecutionCheckConfiguration"/>.
 /// </summary>
 public sealed class CustomConfigurationData
 {
@@ -41,7 +41,7 @@ public CustomConfigurationData(string ruleId, Dictionary<string, string> propert
     /// Key-value pairs of unstructured data from .editorconfig file.
     /// E.g. if in editorconfig file we'd have:
     /// [*.csrpoj]
-    /// build_analyzer.microsoft.BC0101.name_of_targets_to_restrict = "Build,CoreCompile,ResolveAssemblyReferences"
+    /// build_check.microsoft.BC0101.name_of_targets_to_restrict = "Build,CoreCompile,ResolveAssemblyReferences"
     ///
     /// the ConfigurationData would be:
     /// "name_of_targets_to_restrict" -> "Build,CoreCompile,ResolveAssemblyReferences"
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index fbeb7c68f42..81b74bca9fb 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -65,8 +65,8 @@ void ProcessTaskParameterEventArgs(
 
     // All those to be called from RequestBuilder,
     //  but as well from the ConnectorLogger - as even if interleaved, it gives the info
-    //  to manager about what analyzers need to be materialized and configuration fetched.
-    // No unloading of analyzers is yet considered - once loaded it stays for whole build.
+    //  to manager about what checks need to be materialized and configuration fetched.
+    // No unloading of checks is yet considered - once loaded it stays for whole build.
     void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, ICheckContext checksContext, string projectFullPath);
 
     void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs
index 9331ad4bc38..ac9a4323dfb 100644
--- a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs
@@ -5,7 +5,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// Consumer of the data from the build engine.
-/// Currently, this is used to send data for analysis to the BuildCheck.
+/// Currently, this is used to send data for checks to the BuildCheck.
 /// In the future we can multiplex the data to other consumers (e.g. copilot).
 /// </summary>
 internal interface IBuildEngineDataConsumer
@@ -19,5 +19,5 @@ internal interface IBuildEngineDataConsumer
     void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo);
 
     // TODO: We might want to move acquisition data processing into this interface as well
-    // void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData);
+    // void ProcessCheckAcquisition(CheckAcquisitionData acquisitionData);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
index 0c543194184..b837b71f07e 100644
--- a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
@@ -5,14 +5,14 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// The module that routes the data to the final consumer.
-/// Typically, it is the BuildCheck (in case of in-node analysis) or LoggingService
-///  (in case of centralized analysis, where the data will first be wrapped to BuildEventArgs and sent to central node).
+/// Typically, it is the BuildCheck (in case of in-node check) or LoggingService
+///  (in case of centralized check, where the data will first be wrapped to BuildEventArgs and sent to central node).
 /// </summary>
 internal interface IBuildEngineDataRouter
 {
     void ProcessPropertyRead(
         PropertyReadInfo propertyReadInfo,
-        // This is intentionally AnalysisLoggingContext instead of ICheckContext - to avoid boxing allocations
+        // This is intentionally CheckLoggingContext instead of ICheckContext - to avoid boxing allocations
         //  on a hot path of properties reading (same for writing)
         CheckLoggingContext checkContext);
 
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index a3d400c92b0..12bf78f3d6c 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -15,7 +15,7 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Base for a data passed from infrastructure to build analyzers.
+/// Base for a data passed from infrastructure to build checks.
 /// </summary>
 /// <param name="projectFilePath">Currently built project.</param>
 /// <param name="projectConfigurationId">The unique id of a project with unique global properties set.</param>
@@ -57,9 +57,9 @@ public abstract class CheckData(string projectFilePath, int? projectConfiguratio
 }
 
 /// <summary>
-/// Data passed from infrastructure to build analyzers.
+/// Data passed from infrastructure to build checks.
 /// </summary>
-/// <typeparam name="T">The type of the actual data for analysis.</typeparam>
+/// <typeparam name="T">The type of the actual data for checking.</typeparam>
 public class BuildCheckDataContext<T> where T : CheckData
 {
     private readonly BuildExecutionCheckWrapper _executionCheckWrapper;
@@ -82,14 +82,14 @@ internal BuildCheckDataContext(
     }
 
     /// <summary>
-    /// Method for reporting the result of the build analyzer rule.
+    /// Method for reporting the result of the build check rule.
     /// </summary>
     /// <param name="result"></param>
     public void ReportResult(BuildCheckResult result)
         => _resultHandler(_executionCheckWrapper, _checkContext, _configPerRule, result);
 
     /// <summary>
-    /// Data to be analyzed.
+    /// Data to be checked.
     /// </summary>
     public T Data { get; }
 }
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 7f2680b75ab..c0158021881 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -340,7 +340,7 @@ internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem, Loggi
         /// Properties may be null.
         ///
         /// Used for tests and for ToolsetReader - that operates agnostic on the project
-        ///   - so no logging context is passed, and no BuildCheck analysis will be executed.
+        ///   - so no logging context is passed, and no BuildCheck check will be executed.
         /// </summary>
         internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
         : this(properties, fileSystem, null)
@@ -394,7 +394,7 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMeta
         /// Any or all may be null.
         ///
         /// This is for the purpose of evaluations through API calls, that might not be able to pass the logging context
-        ///  - BuildCheck analysis won't be executed for those.
+        ///  - BuildCheck checking won't be executed for those.
         /// (for one of the calls we can actually pass IDataConsumingContext - as we have logging service and project)
         ///
         /// </summary>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 741e731b9ad..8a5522f4d44 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -2107,25 +2107,25 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
     </comment>
   </data>
-  <data name="CustomAnalyzerSuccessfulAcquisition" xml:space="preserve">
-    <value>Custom analyzer rule: '{0}' has been registered successfully.</value>
-    <comment>The message is emitted on successful loading of the custom analyzer rule in process.</comment>
+  <data name="CustomCheckSuccessfulAcquisition" xml:space="preserve">
+    <value>Custom check rule: '{0}' has been registered successfully.</value>
+    <comment>The message is emitted on successful loading of the custom check rule in process.</comment>
   </data>
-  <data name="CustomAnalyzerFailedAcquisition" xml:space="preserve">
-    <value>Failed to register the custom analyzer: '{0}'.</value>
-    <comment>The message is emitted on failed loading of the custom analyzer in process.</comment>
+  <data name="CustomCheckFailedAcquisition" xml:space="preserve">
+    <value>Failed to register the custom check: '{0}'.</value>
+    <comment>The message is emitted on failed loading of the custom check in process.</comment>
   </data>
-  <data name="CustomAnalyzerFailedRuleLoading" xml:space="preserve">
-    <value>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</value>
-    <comment>The message is emitted on failed loading of the custom analyzer rule in process.</comment>
+  <data name="CustomCheckFailedRuleLoading" xml:space="preserve">
+    <value>Failed to instantiate the custom check rule with the following exception: '{0}'.</value>
+    <comment>The message is emitted on failed loading of the custom check rule in process.</comment>
   </data>
-  <data name="CustomAnalyzerAssemblyNotExist" xml:space="preserve">
-    <value>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</value>
-    <comment>The message is emitted when the custom analyzer assembly can not be found.</comment>
+  <data name="CustomCheckAssemblyNotExist" xml:space="preserve">
+    <value>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</value>
+    <comment>The message is emitted when the custom check assembly can not be found.</comment>
   </data>
-  <data name="CustomAnalyzerBaseTypeNotAssignable" xml:space="preserve">
-    <value>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
-    <comment>The message is emitted when the custom analyzer assembly can not be successfully registered.</comment>
+  <data name="CustomCheckBaseTypeNotAssignable" xml:space="preserve">
+    <value>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
+    <comment>The message is emitted when the custom check assembly can not be successfully registered.</comment>
   </data>
   <data name="TaskAssemblyLocationMismatch" xml:space="preserve">
     <value>Task assembly was loaded from '{0}' while the desired location was '{1}'.</value>
@@ -2136,8 +2136,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="BuildCheckEnabled" xml:space="preserve">
     <value>The BuildCheck is enabled for this build.</value>
   </data>
-  <data name="CustomAnalyzerRegistered" xml:space="preserve">
-    <value>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</value>
+  <data name="CustomCheckRegistered" xml:space="preserve">
+    <value>The custom check: '{0}' is registered for the build from the location: '{1}'.</value>
   </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
diff --git a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
index d5dd8341b6a..6759d783aae 100644
--- a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
+++ b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
@@ -33,8 +33,8 @@ public BuildCheckManagerTests(ITestOutputHelper output)
     }
 
     [Theory]
-    [InlineData(true, new[] { "Custom analyzer rule: 'Rule1' has been registered successfully.", "Custom analyzer rule: 'Rule2' has been registered successfully." })]
-    [InlineData(false, new[] { "Failed to register the custom analyzer: 'DummyPath'." })]
+    [InlineData(true, new[] { "Custom check rule: 'Rule1' has been registered successfully.", "Custom check rule: 'Rule2' has been registered successfully." })]
+    [InlineData(false, new[] { "Failed to register the custom check: 'DummyPath'." })]
     public void ProcessCheckAcquisitionTest(bool isCheckRuleExist, string[] expectedMessages)
     {
         MockBuildCheckAcquisition(isCheckRuleExist);
@@ -92,7 +92,7 @@ internal BuildExecutionCheckRuleMock(string friendlyName)
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
-        // configurationContext to be used only if analyzer needs external configuration data.
+        // configurationContext to be used only if check needs external configuration data.
     }
 
     public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
diff --git a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
index 1b1b0c5aaa4..84e9af60f02 100644
--- a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
+++ b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
@@ -841,13 +841,13 @@ public void CanGetSectionsWithSpecialCharacters()
 build_metadata.Compile.ToRetrieve = def456
 ");
 
-        var set = AnalyzerConfigSet.Create(ImmutableArray.Create(config));
+        var set = CheckConfigSet.Create(ImmutableArray.Create(config));
 
         var sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/{releaseid}.cs");
-        Assert.Equal("abc123", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+        Assert.Equal("abc123", sectionOptions.CheckOptions["build_metadata.compile.toretrieve"]);
 
         sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/Pages/#foo/HomePage.cs");
-        Assert.Equal("def456", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+        Assert.Equal("def456", sectionOptions.CheckOptions["build_metadata.compile.toretrieve"]);
     }*/
 
     [Fact]
@@ -895,9 +895,9 @@ public void CaseInsensitivePropKey()
     public void NonReservedKeyPreservedCaseVal()
     {
         var config = ParseConfigFile(string.Join(Environment.NewLine,
-            AnalyzerConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
+            CheckConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
         AssertEx.SetEqual(
-            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
+            CheckConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
             config.GlobalSection.Properties);
     }*/
 
@@ -1055,10 +1055,10 @@ public void ReservedValues()
     {
         int index = 0;
         var config = ParseConfigFile(string.Join(Environment.NewLine,
-            AnalyzerConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
+            CheckConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
         index = 0;
         AssertEx.SetEqual(
-            AnalyzerConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
+            CheckConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
             config.GlobalSection.Properties);
     }
     */
@@ -1068,9 +1068,9 @@ public void ReservedValues()
     public void ReservedKeys()
     {
         var config = ParseConfigFile(string.Join(Environment.NewLine,
-            AnalyzerConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
+            CheckConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
         AssertEx.SetEqual(
-            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
+            CheckConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
             config.GlobalSection.Properties);
     }
     */
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 6a72903b8e6..3961ef049c3 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -17,9 +17,9 @@
   </ItemGroup>
   
   <ItemGroup Label="TestAssests">
-    <ProjectReference Include=".\TestAssets\CustomAnalyzer\CustomAnalyzer.csproj" />
-    <ProjectReference Include=".\TestAssets\CustomAnalyzer2\CustomAnalyzer2.csproj" />
-    <ProjectReference Include=".\TestAssets\InvalidCustomAnalyzer\InvalidCustomAnalyzer.csproj" />
+    <ProjectReference Include=".\TestAssets\CustomCheck\CustomCheck.csproj" />
+    <ProjectReference Include=".\TestAssets\CustomCheck2\CustomCheck2.csproj" />
+    <ProjectReference Include=".\TestAssets\InvalidCustomCheck\InvalidCustomCheck.csproj" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
index 5926cdd6d83..edd60254fa9 100644
--- a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
@@ -26,7 +26,7 @@ internal sealed class TestCheck : BuildExecutionCheck
             public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule("BC0000", "TestRule", "TestDescription", "TestMessage",
                 new BuildExecutionCheckConfiguration() { Severity = BuildExecutionCheckResultSeverity.Warning });
 
-            public override string FriendlyName => "MSBuild.TestAnalyzer";
+            public override string FriendlyName => "MSBuild.TestCheck";
 
             public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = [SupportedRule];
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Check1.cs b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Check1.cs
index 047f4810835..b7f1ac7ab2b 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Check1.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Check1.cs
@@ -19,7 +19,7 @@ public sealed class Check1 : BuildExecutionCheck
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
         public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Check2.cs b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Check2.cs
index 19caab85e3a..58fdc998478 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Check2.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Check2.cs
@@ -19,7 +19,7 @@ public sealed class Check2 : BuildExecutionCheck
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
         public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
index 5b7bc689b0d..ef41e00277e 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
@@ -1,21 +1,21 @@
-# MSBuild Custom Analyzer Template
+# MSBuild Custom Check Template
 
 ## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
 
 ## Features
-- Simplified template for creating MSBuild analyzer libraries.
+- Simplified template for creating MSBuild check libraries.
 - Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
+- Provides a starting point for implementing custom check rules.
 
 ## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
+To use the MSBuild Custom Check Template, follow these steps:
 1. Install the template using the following command:
    ```bash
-   dotnet new install msbuildanalyzer
+   dotnet new install msbuildcheck
 2. Instantiate a custom template:
    ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
+   dotnet new msbuildcheck -n <ProjectName>
 
 ### Prerequisites
 - .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Check3.cs b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Check3.cs
index 01058f577cb..76cd522b1f5 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Check3.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Check3.cs
@@ -19,7 +19,7 @@ public sealed class Check3 : BuildExecutionCheck
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
         public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
index 4f29145e7f0..ef41e00277e 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
@@ -1,21 +1,21 @@
-# MSBuild Custom Analyzer Template
+# MSBuild Custom Check Template
 
 ## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
 
 ## Features
-- Simplified template for creating MSBuild analyzer libraries.
+- Simplified template for creating MSBuild check libraries.
 - Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
+- Provides a starting point for implementing custom check rules.
 
 ## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
+To use the MSBuild Custom Check Template, follow these steps:
 1. Install the template using the following command:
    ```bash
-   dotnet new install msbuildanalyzer
+   dotnet new install msbuildcheck
 2. Instantiate a custom template:
    ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
+   dotnet new msbuildcheck -n <ProjectName>
 
 ### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
+- .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md
index 4f29145e7f0..ef41e00277e 100644
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md
@@ -1,21 +1,21 @@
-# MSBuild Custom Analyzer Template
+# MSBuild Custom Check Template
 
 ## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
 
 ## Features
-- Simplified template for creating MSBuild analyzer libraries.
+- Simplified template for creating MSBuild check libraries.
 - Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
+- Provides a starting point for implementing custom check rules.
 
 ## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
+To use the MSBuild Custom Check Template, follow these steps:
 1. Install the template using the following command:
    ```bash
-   dotnet new install msbuildanalyzer
+   dotnet new install msbuildcheck
 2. Instantiate a custom template:
    ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
+   dotnet new msbuildcheck -n <ProjectName>
 
 ### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
+- .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigbasic b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigbasic
index 6943aa8dd95..0ee9a04a5ae 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigbasic
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigbasic
@@ -7,5 +7,5 @@ build_check.BC0102.Severity=warning
 build_check.BC0103.Severity=warning
 
 build_check.COND0543.Severity=Error
-build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
+build_check.COND0543.EvaluationCheckScope=AnalyzedProjectOnly
 build_check.COND0543.CustomSwitch=QWERTY
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigcustomised b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigcustomised
index 28ca732c908..18c24cce509 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigcustomised
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigcustomised
@@ -7,5 +7,5 @@ build_check.BC0102.Severity=warning
 build_check.BC0103.Severity=warning
 
 build_check.COND0543.Severity=Error
-build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
+build_check.COND0543.EvaluationCheckScope=AnalyzedProjectOnly
 build_check.COND0543.CustomSwitch=QWERTY
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
index 9a8c3459b87..135a354a526 100644
--- a/src/Framework/BuildCheck/BuildCheckEventArgs.cs
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -79,7 +79,7 @@ internal BuildCheckAcquisitionEventArgs()
     }
 
     /// <summary>
-    /// Gets the path to the analyzer assembly that needs to be loaded into the application context.
+    /// Gets the path to the check assembly that needs to be loaded into the application context.
     /// </summary>
     /// <remarks>
     /// The <see cref="AcquisitionPath"/> property contains the file system path to the assembly
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index bfc061b5a1d..282ce14f354 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2784,8 +2784,8 @@ private static bool ProcessCommandLineSwitches(
         private static bool IsBuildCheckEnabled(CommandLineSwitches commandLineSwitches)
         {
             // Opt-in behavior to be determined by: https://github.com/dotnet/msbuild/issues/9723
-            bool isAnalysisEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Analyze);
-            return isAnalysisEnabled;
+            bool isBuildCheckEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Analyze);
+            return isBuildCheckEnabled;
         }
 
         private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)
diff --git a/template_feed/README.md b/template_feed/README.md
index f2b021d3647..f6bd358ffcd 100644
--- a/template_feed/README.md
+++ b/template_feed/README.md
@@ -1,9 +1,9 @@
-## MSBuild Custom Analyzer Template Package
+## MSBuild Custom Check Template Package
 
-The package contains the template designed to streamline the creation of MSBuild analyzer libraries.
+The package contains the template designed to streamline the creation of MSBuild check libraries.
 | Template name | Short name | Description|
 |---|---|---|
-|MSBuild Custom Analyzer Template|`msbuildanalyzer`|A project for creating a MSBuild analyzer library that targets .NET Standard.|
+|MSBuild Custom Check Template|`msbuildcheck`|A project for creating a MSBuild check library that targets .NET Standard.|
 
 The package is available for download from nuget.org.
 Please feel to contribute or provide the feedback in discussions or via opening the issue in dotnet/msbuild repo.
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs b/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
index 78dae77947b..135a014fc55 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
+++ b/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
@@ -2,24 +2,24 @@
 using Microsoft.Build.Experimental.BuildCheck;
 using System.Collections.Generic;
 
-namespace Company.AnalyzerTemplate
+namespace Company.CheckTemplate
 {
-    public sealed class Analyzer1 : BuildAnalyzer
+    public sealed class Check1 : BuildExecutionCheck
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static BuildCheckRule SupportedRule = new BuildExecutionCheckRule(
             "X01234",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new BuildCheckConfiguration());
 
-        public override string FriendlyName => "Company.Analyzer1";
+        public override string FriendlyName => "Company.Check1";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = new List<BuildExecutionCheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
 
@@ -28,7 +28,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj b/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
index 33d8c992326..009b2ad1fe0 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
+++ b/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
@@ -10,7 +10,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="Company.AnalyzerTemplate.props" Pack="true" PackagePath="build\Company.AnalyzerTemplate.props" />
+    <None Include="Company.CheckTemplate.props" Pack="true" PackagePath="build\Company.CheckTemplate.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props b/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
index 5a606b3cac6..8de608f1023 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
+++ b/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Project>
   <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)Company.AnalyzerTemplate.dll))</MSBuildAnalyzer>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)Company.AnalyzerTemplate.dll))</MSBuildCheck>
   </PropertyGroup>
   <ItemGroup>
     <PackageVersion Include="Microsoft.Build" Version="1.0.0-MicrosoftBuildPackageVersion" />
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/README.md b/template_feed/content/Microsoft.AnalyzerTemplate/README.md
index 4f29145e7f0..ef41e00277e 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/README.md
+++ b/template_feed/content/Microsoft.AnalyzerTemplate/README.md
@@ -1,21 +1,21 @@
-# MSBuild Custom Analyzer Template
+# MSBuild Custom Check Template
 
 ## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
 
 ## Features
-- Simplified template for creating MSBuild analyzer libraries.
+- Simplified template for creating MSBuild check libraries.
 - Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
+- Provides a starting point for implementing custom check rules.
 
 ## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
+To use the MSBuild Custom Check Template, follow these steps:
 1. Install the template using the following command:
    ```bash
-   dotnet new install msbuildanalyzer
+   dotnet new install msbuildcheck
 2. Instantiate a custom template:
    ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
+   dotnet new msbuildcheck -n <ProjectName>
 
 ### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
+- .NET SDK installed on your machine.
