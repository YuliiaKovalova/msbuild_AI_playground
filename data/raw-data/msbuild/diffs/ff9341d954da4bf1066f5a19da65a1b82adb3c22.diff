diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 60a757b7803..f978d746468 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -70,6 +70,8 @@ jobs:
     inputs:
       filename: 'eng/cibuild_bootstrapped_msbuild.cmd'
       arguments: -onlyDocChanged $(onlyDocChanged)
+    env:
+      MSBUILD_TELEMETRY_SAMPLE_RATE: '0.5'
   - task: PublishTestResults@2
     displayName: Publish .NET Framework Test Results
     inputs:
@@ -196,12 +198,16 @@ jobs:
     inputs:
       filename: 'eng/cibuild.cmd'
       arguments: '-configuration Release -test'
+    env:
+      MSBUILD_TELEMETRY_SAMPLE_RATE: '0.5'
     condition: eq(variables.onlyDocChanged, 0)
   - task: BatchScript@1
     displayName: cibuild.cmd without test
     inputs:
       filename: 'eng/cibuild.cmd'
       arguments: '-configuration Release'
+    env:
+      MSBUILD_TELEMETRY_SAMPLE_RATE: '0.5'
     condition: eq(variables.onlyDocChanged, 1)
   - task: PublishTestResults@2
     displayName: Publish .NET Framework Test Results
diff --git a/NuGet.config b/NuGet.config
index 107cd4542dc..beebd60e603 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -13,6 +13,14 @@
     <add key="dotnet8" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json" />
     <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
     <add key="dotnet9" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json" />
+    <add key="vs-impl" value="https://pkgs.dev.azure.com/azure-public/vside/_packaging/vs-impl/nuget/v3/index.json" />
+
+    <!-- We don't want other than VS OpenTelemetry libraries from vs-impl -->
+    <packageSourceMapping>
+      <packageSource key="vs-impl">
+        <package pattern="Microsoft.VisualStudio.OpenTelemetry*" />
+      </packageSource>
+    </packageSourceMapping>
   </packageSources>
   <disabledPackageSources>
     <!--Begin: Package sources managed by Dependency Flow automation. Do not edit the sources below.-->
diff --git a/eng/Packages.props b/eng/Packages.props
index 87cf3b78909..cfc7e34a83c 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -33,5 +33,11 @@
     <PackageVersion Include="System.Threading.Channels" Version="$(SystemThreadingChannelsVersion)" />
     <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
     <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
+    <PackageVersion Include="Microsoft.VisualStudio.OpenTelemetry.Collector" Version="$(MicrosoftVisualStudioOpenTelemetryVersion)" />
+    <PackageVersion Include="Microsoft.VisualStudio.OpenTelemetry.ClientExtensions" Version="$(MicrosoftVisualStudioOpenTelemetryVersion)" />
+    <PackageVersion Include="OpenTelemetry" Version="$(OpenTelemetryVersion)" />
+    <PackageVersion Include="System.Diagnostics.DiagnosticSource" Version="$(SystemDiagnosticsDiagnosticSourceVersion)" />
+    <PackageVersion Include="Microsoft.Bcl.AsyncInterfaces" Version="$(MicrosoftBclAsyncInterfacesVersion)" />
+    <PackageVersion Include="Microsoft.Extensions.Primitives" Version="$(MicrosoftExtensionsPrimitivesVersion)" />
   </ItemGroup>
 </Project>
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 6693866df16..5f37ab3cf73 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -19,6 +19,8 @@
     <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.1*" />
 	  <UsagePattern IdentityGlob="Microsoft.VisualStudio.SolutionPersistence/*1.0.9*" />
+    <!-- Defined in Version.Details.xml - live version used in SB. -->
+    <UsagePattern IdentityGlob="System.Diagnostics.DiagnosticSource/*9.0.0*" />
   </IgnorePatterns>
   <Usages>
   </Usages>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 5be9d85b6a1..22715bc8adc 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -69,6 +69,10 @@
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
       <Sha>2aade6beb02ea367fd97c4070a4198802fe61c03</Sha>
     </Dependency>
+    <Dependency Name="System.Diagnostics.DiagnosticSource" Version="9.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>981a85989d49daee6b2147113b7de639f5e5d903</Sha>
+    </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
     <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.24623.3">
diff --git a/eng/Versions.props b/eng/Versions.props
index f9b4edfe5df..393234529bf 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -54,6 +54,12 @@
     <SystemTextJsonVersion>8.0.5</SystemTextJsonVersion>
     <SystemThreadingChannelsVersion>8.0.0</SystemThreadingChannelsVersion>
     <SystemThreadingTasksDataflowVersion>8.0.0</SystemThreadingTasksDataflowVersion>
+    <SystemDiagnosticsDiagnosticSourceVersion>9.0.0</SystemDiagnosticsDiagnosticSourceVersion>
+    <MicrosoftVisualStudioOpenTelemetryVersion>0.1.700-beta</MicrosoftVisualStudioOpenTelemetryVersion>
+    <OpenTelemetryVersion>1.10.0</OpenTelemetryVersion>
+    <SystemDiagnosticsDiagnosticSourceVersion>9.0.0</SystemDiagnosticsDiagnosticSourceVersion>
+    <MicrosoftBclAsyncInterfacesVersion>9.0.0</MicrosoftBclAsyncInterfacesVersion>
+    <MicrosoftExtensionsPrimitivesVersion>9.0.0</MicrosoftExtensionsPrimitivesVersion>
   </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
diff --git a/src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs b/src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs
new file mode 100644
index 00000000000..ed49dfc54e7
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs
@@ -0,0 +1,196 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using Xunit;
+using Shouldly;
+
+namespace Microsoft.Build.Framework.Telemetry.Tests
+{
+    public class ActivityExtensionsTests
+    {
+        [Fact]
+        public void WithTag_ShouldSetUnhashedValue()
+        {
+            var activity = new Activity("TestActivity");
+            activity.Start(); 
+
+            var telemetryItem = new TelemetryItem(
+                Name: "TestItem",
+                Value: "TestValue",
+                Hashed: false);
+
+            activity.WithTag(telemetryItem);
+
+            var tagValue = activity.GetTagItem("VS.MSBuild.TestItem");
+            tagValue.ShouldNotBeNull();
+            tagValue.ShouldBe("TestValue");
+
+            activity.Dispose();
+        }
+
+        [Fact]
+        public void WithTag_ShouldSetHashedValue()
+        {
+            var activity = new Activity("TestActivity");
+            var telemetryItem = new TelemetryItem(
+                Name: "TestItem",
+                Value: "SensitiveValue",
+                Hashed: true);
+
+            activity.WithTag(telemetryItem);
+
+            var tagValue = activity.GetTagItem("VS.MSBuild.TestItem");
+            tagValue.ShouldNotBeNull();
+            tagValue.ShouldNotBe("SensitiveValue"); // Ensure it’s not the plain text
+            activity.Dispose();
+        }
+
+        [Fact]
+        public void WithTags_ShouldSetMultipleTags()
+        {
+            var activity = new Activity("TestActivity");
+            var tags = new List<TelemetryItem>
+            {
+                new("Item1", "Value1", false),
+                new("Item2", "Value2", true)  // hashed
+            };
+
+            activity.WithTags(tags);
+
+            var tagValue1 = activity.GetTagItem("VS.MSBuild.Item1");
+            var tagValue2 = activity.GetTagItem("VS.MSBuild.Item2");
+
+            tagValue1.ShouldNotBeNull();
+            tagValue1.ShouldBe("Value1");
+
+            tagValue2.ShouldNotBeNull();
+            tagValue2.ShouldNotBe("Value2"); // hashed
+
+            activity.Dispose();
+        }
+
+        [Fact]
+        public void WithTags_DataHolderShouldSetMultipleTags()
+        {
+            var activity = new Activity("TestActivity");
+            var dataHolder = new MockTelemetryDataHolder(); // see below
+
+            activity.WithTags(dataHolder);
+
+            var tagValueA = activity.GetTagItem("VS.MSBuild.TagA");
+            var tagValueB = activity.GetTagItem("VS.MSBuild.TagB");
+
+            tagValueA.ShouldNotBeNull();
+            tagValueA.ShouldBe("ValueA");
+
+            tagValueB.ShouldNotBeNull();
+            tagValueB.ShouldNotBe("ValueB"); // should be hashed
+            activity.Dispose();
+        }
+
+        [Fact]
+        public void WithStartTime_ShouldSetActivityStartTime()
+        {
+            var activity = new Activity("TestActivity");
+            var now = DateTime.UtcNow;
+
+            activity.WithStartTime(now);
+
+            activity.StartTimeUtc.ShouldBe(now);
+            activity.Dispose();
+        }
+
+        [Fact]
+        public void WithStartTime_NullDateTime_ShouldNotSetStartTime()
+        {
+            var activity = new Activity("TestActivity");
+            var originalStartTime = activity.StartTimeUtc; // should be default (min) if not started
+
+            activity.WithStartTime(null);
+
+            activity.StartTimeUtc.ShouldBe(originalStartTime);
+
+            activity.Dispose();
+        }
+    }
+
+    /// <summary>
+    /// A simple mock for testing IActivityTelemetryDataHolder. 
+    /// Returns two items: one hashed, one not hashed.
+    /// </summary>
+    internal sealed class MockTelemetryDataHolder : IActivityTelemetryDataHolder
+    {
+        public IList<TelemetryItem> GetActivityProperties()
+        {
+            return new List<TelemetryItem>
+            {
+                new("TagA", "ValueA", false),
+                new("TagB", "ValueB", true),
+            };
+        }
+    }
+
+
+    public class MSBuildActivitySourceTests
+    {
+        [Fact]
+        public void StartActivity_ShouldPrefixNameCorrectly_WhenNoRemoteParent()
+        {
+            var source = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace);
+            using var listener = new ActivityListener
+            {
+                ShouldListenTo = activitySource => activitySource.Name == TelemetryConstants.DefaultActivitySourceNamespace,
+                Sample = (ref ActivityCreationOptions<ActivityContext> options) => ActivitySamplingResult.AllData,
+            };
+            ActivitySource.AddActivityListener(listener);
+
+
+            var activity = source.StartActivity("Build");
+
+            activity.ShouldNotBeNull();
+            activity?.DisplayName.ShouldBe("VS/MSBuild/Build");
+
+            activity?.Dispose();
+        }
+
+        [Fact]
+        public void StartActivity_ShouldUseParentId_WhenRemoteParentExists()
+        {
+            // Arrange
+            var parentActivity = new Activity("ParentActivity");
+            parentActivity.SetParentId("|12345.abcde.");  // Simulate some parent trace ID
+            parentActivity.AddTag("sampleTag", "sampleVal");
+            parentActivity.Start();
+
+            var source = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace);
+            using var listener = new ActivityListener
+            {
+                ShouldListenTo = activitySource => activitySource.Name == TelemetryConstants.DefaultActivitySourceNamespace,
+                Sample = (ref ActivityCreationOptions<ActivityContext> options) => ActivitySamplingResult.AllData,
+            };
+            ActivitySource.AddActivityListener(listener);
+
+            // Act
+            var childActivity = source.StartActivity("ChildBuild");
+
+            // Assert
+            childActivity.ShouldNotBeNull();
+            // If HasRemoteParent is true, the code uses `parentId: Activity.Current.ParentId`.
+            // However, by default .NET Activity doesn't automatically set HasRemoteParent = true
+            // unless you explicitly set it. If you have logic that sets it, you can test it here.
+            // For demonstration, we assume the ParentId is carried over if HasRemoteParent == true.
+            if (Activity.Current?.HasRemoteParent == true)
+            {
+                childActivity?.ParentId.ShouldBe("|12345.abcde.");
+            }
+
+            parentActivity.Dispose();
+            childActivity?.Dispose();
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs b/src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs
new file mode 100644
index 00000000000..3132af1fb30
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs
@@ -0,0 +1,182 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Reflection;
+using Xunit;
+using Shouldly;
+
+namespace Microsoft.Build.Framework.Telemetry.Tests
+{
+    /// <summary>
+    /// Ensures tests run serially so environment variables and the singleton do not interfere with parallel test runs.
+    /// </summary>
+    [Collection("OpenTelemetryManagerTests")]
+    public class OpenTelemetryManagerTests : IDisposable
+    {
+        // Store original environment variables so we can restore after each test
+        private readonly string _originalDotnetOptOut;
+        private readonly string _originalMsBuildTelemetryOptOut;
+        private readonly string _originalSampleRateOverride;
+
+        public OpenTelemetryManagerTests()
+        {
+            // Capture existing env vars
+            _originalDotnetOptOut = Environment.GetEnvironmentVariable(TelemetryConstants.DotnetOptOut) ?? "";
+            _originalMsBuildTelemetryOptOut = Environment.GetEnvironmentVariable(TelemetryConstants.TelemetryFxOptoutEnvVarName) ?? "";
+            _originalSampleRateOverride = Environment.GetEnvironmentVariable(TelemetryConstants.TelemetrySampleRateOverrideEnvVarName) ?? "";
+
+            // Ensure a clean manager state before each test
+            ResetManagerState();
+        }
+
+        public void Dispose()
+        {
+            // Restore environment variables
+            Environment.SetEnvironmentVariable(TelemetryConstants.DotnetOptOut, _originalDotnetOptOut);
+            Environment.SetEnvironmentVariable(TelemetryConstants.TelemetryFxOptoutEnvVarName, _originalMsBuildTelemetryOptOut);
+            Environment.SetEnvironmentVariable(TelemetryConstants.TelemetrySampleRateOverrideEnvVarName, _originalSampleRateOverride);
+
+            // Ensure manager is reset after each test
+            ResetManagerState();
+        }
+
+        [Theory]
+        [InlineData(TelemetryConstants.DotnetOptOut, "true")]
+        [InlineData(TelemetryConstants.TelemetryFxOptoutEnvVarName, "true")]
+        [InlineData(TelemetryConstants.DotnetOptOut, "1")]
+        [InlineData(TelemetryConstants.TelemetryFxOptoutEnvVarName, "1")]
+        public void Initialize_ShouldSetStateToOptOut_WhenOptOutEnvVarIsTrue(string optoutvar, string value)
+        {
+            // Arrange
+            Environment.SetEnvironmentVariable(optoutvar, value);
+
+            // Act
+            OpenTelemetryManager.Instance.Initialize(isStandalone: false);
+
+            // Assert
+            var state = GetTelemetryState(OpenTelemetryManager.Instance);
+            state.ShouldBe(TelemetryState.OptOut);
+            OpenTelemetryManager.Instance.DefaultActivitySource.ShouldBeNull();
+        }
+#if NET
+        [Fact]
+        public void Initialize_ShouldSetStateToUnsampled_WhenNoOverrideOnNetCore()
+        {
+
+            // Clear any override that might have existed
+            Environment.SetEnvironmentVariable(TelemetryConstants.TelemetrySampleRateOverrideEnvVarName, null);
+
+            // Also ensure we are not opting out
+            Environment.SetEnvironmentVariable(TelemetryConstants.DotnetOptOut, "false");
+            Environment.SetEnvironmentVariable(TelemetryConstants.TelemetryFxOptoutEnvVarName, "false");
+
+            OpenTelemetryManager.Instance.Initialize(isStandalone: false);
+
+            var state = GetTelemetryState(OpenTelemetryManager.Instance);
+            state.ShouldBe(TelemetryState.Unsampled);
+            OpenTelemetryManager.Instance.DefaultActivitySource.ShouldBeNull();
+        }
+#endif
+        [WindowsFullFrameworkOnlyTheory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void Initialize_ShouldSetSampleRateOverride_AndCreateActivitySource_WhenRandomBelowOverride(bool standalone)
+        {
+
+            // Arrange
+            Environment.SetEnvironmentVariable(TelemetryConstants.TelemetryFxOptoutEnvVarName, "false");
+            Environment.SetEnvironmentVariable(TelemetryConstants.DotnetOptOut, "false");
+            Environment.SetEnvironmentVariable(TelemetryConstants.TelemetrySampleRateOverrideEnvVarName, "1.0");
+
+            // Act
+            OpenTelemetryManager.Instance.Initialize(isStandalone: standalone);
+
+            // Assert
+            var state = GetTelemetryState(OpenTelemetryManager.Instance);
+            // On .NET Framework, we expect TelemetryState.ExporterInitialized
+            // On .NET / .NET Standard, the code doesn't explicitly set TelemetryState 
+            // => it remains TelemetryState.Uninitialized if not net48 or netframework.
+            // So we can do a check to see if it is either ExporterInitialized or left at Uninitialized.
+            // If your code has changed to set a different state, adapt accordingly.
+
+#if NETFRAMEWORK
+            if (standalone)
+            {
+                state.ShouldBe(TelemetryState.CollectorInitialized);
+            }
+            else
+            {
+                // TODO: collector in VS
+                // state.ShouldBe(TelemetryState.ExporterInitialized);
+                state.ShouldBe(TelemetryState.CollectorInitialized);
+            }
+#else
+            state.ShouldBe(TelemetryState.TracerInitialized);
+#endif
+            // In either scenario, we expect a non-null DefaultActivitySource
+            OpenTelemetryManager.Instance.DefaultActivitySource.ShouldNotBeNull();
+        }
+
+        [Fact]
+        public void Initialize_ShouldNoOp_WhenCalledMultipleTimes()
+        {
+            // Arrange
+            Environment.SetEnvironmentVariable(TelemetryConstants.DotnetOptOut, "true");
+
+            // Act #1
+            OpenTelemetryManager.Instance.Initialize(isStandalone: true);
+            var firstState = GetTelemetryState(OpenTelemetryManager.Instance);
+
+            // Act #2
+            // Try to re-initialize with different env var settings
+            Environment.SetEnvironmentVariable(TelemetryConstants.DotnetOptOut, null);
+            OpenTelemetryManager.Instance.Initialize(isStandalone: true);
+            var secondState = GetTelemetryState(OpenTelemetryManager.Instance);
+
+            // Assert
+            // Because the manager was already set to "OptOut" on the first call, 
+            // the second call is a no-op (the state remains the same).
+            firstState.ShouldBe(TelemetryState.OptOut);
+            secondState.ShouldBe(TelemetryState.OptOut);
+        }
+
+        /* Helper methods */
+
+        /// <summary>
+        /// Resets the singleton manager to a known uninitialized state so each test is isolated.
+        /// </summary>
+        private void ResetManagerState()
+        {
+            // The manager is a private static Lazy<OpenTelemetryManager>. We can forcibly 
+            // set the instance's internal fields to revert it to Uninitialized. 
+            // Another approach is to forcibly re-create the Lazy<T>, but that's more complicated.
+            //
+            // For demonstration, we do minimal reflection to set:
+            //    _telemetryState = TelemetryState.Uninitialized
+            //    DefaultActivitySource = null
+
+            var instance = OpenTelemetryManager.Instance;
+            // 1. telemetryState
+            var telemetryStateField = typeof(OpenTelemetryManager)
+                .GetField("_telemetryState", BindingFlags.NonPublic | BindingFlags.Instance);
+            telemetryStateField?.SetValue(instance, TelemetryState.Uninitialized);
+
+            // 2. DefaultActivitySource
+            var defaultSourceProp = typeof(OpenTelemetryManager)
+                .GetProperty(nameof(OpenTelemetryManager.DefaultActivitySource),
+                    BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
+            defaultSourceProp?.SetValue(instance, null);
+        }
+
+        /// <summary>
+        /// Reads the private _telemetryState field from the given manager instance using reflection.
+        /// </summary>
+        private TelemetryState GetTelemetryState(OpenTelemetryManager manager)
+        {
+            var field = typeof(OpenTelemetryManager)
+                .GetField("_telemetryState", BindingFlags.NonPublic | BindingFlags.Instance);
+            return (TelemetryState)field?.GetValue(manager)!;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 10cf3577bf1..82df158e04a 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -453,6 +453,7 @@ private void UpdatePriority(Process p, ProcessPriorityClass priority)
         /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
         public void BeginBuild(BuildParameters parameters)
         {
+            OpenTelemetryManager.Instance.Initialize(isStandalone: false); 
             if (_previousLowPriority != null)
             {
                 if (parameters.LowPriority != _previousLowPriority)
@@ -1081,6 +1082,12 @@ public void EndBuild()
                             _buildTelemetry.SACEnabled = sacState == NativeMethodsShared.SAC_State.Evaluation || sacState == NativeMethodsShared.SAC_State.Enforcement;
 
                             loggingService.LogTelemetry(buildEventContext: null, _buildTelemetry.EventName, _buildTelemetry.GetProperties());
+                            OpenTelemetryManager.Instance.DefaultActivitySource?
+                                .StartActivity("Build")?
+                                .WithTags(_buildTelemetry)
+                                .WithStartTime(_buildTelemetry.InnerStartAt);
+                            OpenTelemetryManager.Instance.ForceFlush();
+
                             // Clean telemetry to make it ready for next build submission.
                             _buildTelemetry = null;
                         }
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 271026705ba..b31edfef74b 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
     <TargetFrameworks>$(LibraryTargetFrameworks)</TargetFrameworks>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
@@ -23,6 +23,20 @@
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" />
     <Reference Include="System.Xaml" />
+    
+    <!-- Telemetry in Framework-->
+    <PackageReference Include="Microsoft.VisualStudio.OpenTelemetry.Collector"/>
+    <PackageReference Include="Microsoft.VisualStudio.OpenTelemetry.ClientExtensions">
+      <!-- Give the client extensions package a custom alias to avoid VS Telemetry collisions. -->
+      <Aliases>clientext</Aliases>
+    </PackageReference>
+    <PackageReference Include="OpenTelemetry" />
+    <PackageReference Include="Microsoft.Extensions.Primitives" />
+  </ItemGroup>
+  
+  <!-- Framework and standard don't have DiagnosticSource. -->
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' OR '$(TargetFrameworkIdentifier)' == '.NETStandard'">
+    <PackageReference Include="System.Diagnostics.DiagnosticSource" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
diff --git a/src/Framework/Telemetry/ActivityExtensions.cs b/src/Framework/Telemetry/ActivityExtensions.cs
new file mode 100644
index 00000000000..3ac32fa6e18
--- /dev/null
+++ b/src/Framework/Telemetry/ActivityExtensions.cs
@@ -0,0 +1,111 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+#if NETFRAMEWORK
+extern alias clientext;   // for Microsoft.VisualStudio.OpenTelemetry.ClientExtensions
+
+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;
+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;
+#else
+using System.Security.Cryptography;
+using System.Text;
+#endif
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Runtime.CompilerServices;
+using System.Threading;
+using System.Threading.Tasks;
+
+
+
+namespace Microsoft.Build.Framework.Telemetry
+{
+
+    internal static class ActivityExtensions
+    {
+        public static Activity WithTags(this Activity activity, IActivityTelemetryDataHolder dataHolder)
+        {
+            activity.WithTags(dataHolder.GetActivityProperties());
+            return activity;
+        }
+
+        public static Activity WithTags(this Activity activity, IList<TelemetryItem> tags)
+        {
+            foreach (var tag in tags)
+            {
+                activity.WithTag(tag);
+            }
+            return activity;
+        }
+
+        public static Activity WithTag(this Activity activity, TelemetryItem item)
+        {
+            object value = item.Hashed ? GetHashed(item.Value) : item.Value;
+            activity.SetTag($"{TelemetryConstants.PropertyPrefix}{item.Name}", value);
+            return activity;
+        }
+
+        public static Activity WithStartTime(this Activity activity, DateTime? startTime)
+        {
+            if (startTime.HasValue)
+            {
+                activity.SetStartTime(startTime.Value);
+            }
+            return activity;
+        }
+
+        private static object GetHashed(object value)
+        {
+#if NETFRAMEWORK
+                        return new clientext::Microsoft.VisualStudio.Telemetry.TelemetryHashedProperty(value);
+#else
+            return Sha256Hasher.Hash(value.ToString() ?? "");
+#endif
+        }
+
+
+        // https://github.com/dotnet/sdk/blob/8bd19a2390a6bba4aa80d1ac3b6c5385527cc311/src/Cli/Microsoft.DotNet.Cli.Utils/Sha256Hasher.cs + workaround for netstandard2.0
+#if NET || NETSTANDARD2_0_OR_GREATER
+        private static class Sha256Hasher
+        {
+            /// <summary>
+            /// The hashed mac address needs to be the same hashed value as produced by the other distinct sources given the same input. (e.g. VsCode)
+            /// </summary>
+            public static string Hash(string text)
+            {
+                byte[] bytes = Encoding.UTF8.GetBytes(text);
+#if NET
+                byte[] hash = SHA256.HashData(bytes);
+#if NET9_0_OR_GREATER
+                return Convert.ToHexStringLower(hash);
+#else
+            return Convert.ToHexString(hash).ToLowerInvariant();
+#endif
+
+#else
+            // Create the SHA256 object and compute the hash
+            using (var sha256 = SHA256.Create())
+            {
+                byte[] hash = sha256.ComputeHash(bytes);
+
+                // Convert the hash bytes to a lowercase hex string (manual loop approach)
+                var sb = new StringBuilder(hash.Length * 2);
+                foreach (byte b in hash)
+                {
+                    sb.AppendFormat("{0:x2}", b);
+                }
+
+                return sb.ToString();
+            }
+#endif
+            }
+
+            public static string HashWithNormalizedCasing(string text)
+            {
+                return Hash(text.ToUpperInvariant());
+            }
+        }
+#endif
+    }
+}
diff --git a/src/Framework/Telemetry/BuildTelemetry.cs b/src/Framework/Telemetry/BuildTelemetry.cs
index c23d9269c9b..38e34c76435 100644
--- a/src/Framework/Telemetry/BuildTelemetry.cs
+++ b/src/Framework/Telemetry/BuildTelemetry.cs
@@ -10,7 +10,7 @@ namespace Microsoft.Build.Framework.Telemetry
     /// <summary>
     /// Telemetry of build.
     /// </summary>
-    internal class BuildTelemetry : TelemetryBase
+    internal class BuildTelemetry : TelemetryBase, IActivityTelemetryDataHolder
     {
         public override string EventName => "build";
 
@@ -167,5 +167,56 @@ public override IDictionary<string, string> GetProperties()
 
             return properties;
         }
+
+        /// <summary>
+        /// Create a list of properties sent to VS telemetry with the information whether they should be hashed.
+        /// </summary>
+        /// <returns></returns>
+        public IList<TelemetryItem> GetActivityProperties()
+        {
+            List<TelemetryItem> telemetryItems = new(8);
+
+            if (StartAt.HasValue && FinishedAt.HasValue)
+            {
+                telemetryItems.Add(new TelemetryItem("BuildDurationInMilliseconds", (FinishedAt.Value - StartAt.Value).TotalMilliseconds, false));
+            }
+
+            if (InnerStartAt.HasValue && FinishedAt.HasValue)
+            {
+                telemetryItems.Add(new TelemetryItem("InnerBuildDurationInMilliseconds", (FinishedAt.Value - InnerStartAt.Value).TotalMilliseconds, false));
+            }
+
+            if (Host != null)
+            {
+                telemetryItems.Add(new TelemetryItem("BuildEngineHost", Host, false));
+            }
+
+            if (Success.HasValue)
+            {
+                telemetryItems.Add(new TelemetryItem("BuildSuccess", Success, false));
+            }
+
+            if (Target != null)
+            {
+                telemetryItems.Add(new TelemetryItem("BuildTarget", Target, true));
+            }
+
+            if (Version != null)
+            {
+                telemetryItems.Add(new TelemetryItem("BuildEngineVersion", Version.ToString(), false));
+            }
+
+            if (BuildCheckEnabled != null)
+            {
+                telemetryItems.Add(new TelemetryItem("BuildCheckEnabled", BuildCheckEnabled, false));
+            }
+
+            if (SACEnabled != null)
+            {
+                telemetryItems.Add(new TelemetryItem("SACEnabled", SACEnabled, false));
+            }
+
+            return telemetryItems;
+        }
     }
 }
diff --git a/src/Framework/Telemetry/IActivityTelemetryDataHolder.cs b/src/Framework/Telemetry/IActivityTelemetryDataHolder.cs
new file mode 100644
index 00000000000..ae2a86c9971
--- /dev/null
+++ b/src/Framework/Telemetry/IActivityTelemetryDataHolder.cs
@@ -0,0 +1,16 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace Microsoft.Build.Framework.Telemetry;
+
+/// <summary>
+/// Interface for classes that hold telemetry data that should be added as tags to an <see cref="Activity"/>.
+/// </summary>
+internal interface IActivityTelemetryDataHolder
+{
+    IList<TelemetryItem> GetActivityProperties();
+}
diff --git a/src/Framework/Telemetry/MSBuildActivitySource.cs b/src/Framework/Telemetry/MSBuildActivitySource.cs
new file mode 100644
index 00000000000..0290698dea8
--- /dev/null
+++ b/src/Framework/Telemetry/MSBuildActivitySource.cs
@@ -0,0 +1,35 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Runtime.CompilerServices;
+using System.Threading;
+using System.Threading.Tasks;
+
+
+namespace Microsoft.Build.Framework.Telemetry
+{
+    internal class MSBuildActivitySource
+    {
+        private readonly ActivitySource _source;
+
+        public MSBuildActivitySource(string name)
+        {
+            _source = new ActivitySource(name);
+        }
+        /// <summary>
+        /// Prefixes activity with VS OpenTelemetry.
+        /// </summary>
+        /// <param name="name">Name of the telemetry event without prefix.</param>
+        /// <returns></returns>
+        public Activity? StartActivity(string name)
+        {
+            var activity = Activity.Current?.HasRemoteParent == true
+                ? _source.StartActivity($"{TelemetryConstants.EventPrefix}{name}", ActivityKind.Internal, parentId: Activity.Current.ParentId)
+                : _source.StartActivity($"{TelemetryConstants.EventPrefix}{name}");
+            return activity;
+        }
+    }
+}
diff --git a/src/Framework/Telemetry/OpenTelemetryManager.cs b/src/Framework/Telemetry/OpenTelemetryManager.cs
new file mode 100644
index 00000000000..075b2b1ed45
--- /dev/null
+++ b/src/Framework/Telemetry/OpenTelemetryManager.cs
@@ -0,0 +1,265 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+#if NETFRAMEWORK
+extern alias clientext;
+
+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;
+using clientext::Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;
+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;
+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;
+using OpenTelemetry;
+using OpenTelemetry.Trace;
+#endif
+using System;
+using System.Diagnostics;
+using System.Runtime.CompilerServices;
+using System.Threading;
+using System.Threading.Tasks;
+
+
+namespace Microsoft.Build.Framework.Telemetry
+{
+
+    /// <summary>
+    /// State of the telemetry infrastructure.
+    /// </summary>
+    internal enum TelemetryState
+    {
+        /// <summary>
+        /// Initial state.
+        /// </summary>
+        Uninitialized,
+
+        /// <summary>
+        /// Opt out of telemetry.
+        /// </summary>
+        OptOut,
+
+        /// <summary>
+        /// Run not sampled for telemetry.
+        /// </summary>
+        Unsampled,
+
+        /// <summary>
+        /// For core hook, ActivitySource is created.
+        /// </summary>
+        TracerInitialized,
+
+        /// <summary>
+        /// For VS scenario with a collector. ActivitySource, OTel TracerProvider are created.
+        /// </summary>
+        ExporterInitialized,
+
+        /// <summary>
+        /// For standalone, ActivitySource, OTel TracerProvider, VS OpenTelemetry Collector are created.
+        /// </summary>
+        CollectorInitialized,
+
+        /// <summary>
+        /// End state.
+        /// </summary>
+        Disposed
+    }
+
+    /// <summary>
+    /// Singleton class for configuring and managing the telemetry infrastructure with System.Diagnostics.Activity,
+    /// OpenTelemetry SDK, and VS OpenTelemetry Collector.
+    /// </summary>
+    internal class OpenTelemetryManager
+    {
+        // Lazy<T> provides thread-safe lazy initialization.
+        private static readonly Lazy<OpenTelemetryManager> s_instance =
+            new Lazy<OpenTelemetryManager>(() => new OpenTelemetryManager(), LazyThreadSafetyMode.ExecutionAndPublication);
+
+        /// <summary>
+        /// Globally accessible instance of <see cref="OpenTelemetryManager"/>.
+        /// </summary>
+        public static OpenTelemetryManager Instance => s_instance.Value;
+
+        private TelemetryState _telemetryState = TelemetryState.Uninitialized;
+        private readonly object _initializeLock = new();
+        private double _sampleRate = TelemetryConstants.DefaultSampleRate;
+
+#if NETFRAMEWORK
+        private TracerProvider? _tracerProvider;
+        private IOpenTelemetryCollector? _collector;
+#endif
+
+        /// <summary>
+        /// Optional activity source for MSBuild or other telemetry usage.
+        /// </summary>
+        public MSBuildActivitySource? DefaultActivitySource { get; private set; }
+
+        private OpenTelemetryManager()
+        {
+        }
+
+        /// <summary>
+        /// Initializes the telemetry infrastructure. Multiple invocations are no-op, thread-safe.
+        /// </summary>
+        /// <param name="isStandalone">Differentiates between executing as MSBuild.exe or from VS/API.</param>
+        public void Initialize(bool isStandalone)
+        {
+            lock (_initializeLock)
+            {
+                if (_telemetryState != TelemetryState.Uninitialized)
+                {
+                    return;
+                }
+
+                if (IsOptOut())
+                {
+                    _telemetryState = TelemetryState.OptOut;
+                    return;
+                }
+
+                if (!IsSampled())
+                {
+                    _telemetryState = TelemetryState.Unsampled;
+                    return;
+                }
+
+                DefaultActivitySource = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace);
+
+#if NETFRAMEWORK
+                InitializeTracerProvider();
+                // TODO: Enable commented logic when Collector is present in VS
+                // if (isStandalone)
+                InitializeCollector();
+
+                // }
+#endif
+            }
+        }
+
+#if NETFRAMEWORK
+        /// <summary>
+        /// Initializes the OpenTelemetry SDK TracerProvider with VS default exporter settings.
+        /// </summary>
+        private void InitializeTracerProvider()
+        {
+            var exporterSettings = OpenTelemetryExporterSettingsBuilder
+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)
+                .Build();
+
+            TracerProviderBuilder tracerProviderBuilder = Sdk
+                .CreateTracerProviderBuilder()
+                // register all ActivitySources that should be listened to
+                .AddSource(TelemetryConstants.DefaultActivitySourceNamespace)
+                .AddVisualStudioDefaultTraceExporter(exporterSettings);
+
+            _tracerProvider = tracerProviderBuilder.Build();
+            _telemetryState = TelemetryState.ExporterInitialized;
+        }
+
+        /// <summary>
+        /// Initializes the VS OpenTelemetry Collector with VS default settings.
+        /// </summary>
+        private void InitializeCollector()
+        {
+            IOpenTelemetryCollectorSettings collectorSettings = OpenTelemetryCollectorSettingsBuilder
+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)
+                .Build();
+
+            _collector = OpenTelemetryCollectorProvider.CreateCollector(collectorSettings);
+            _collector.StartAsync();
+
+            _telemetryState = TelemetryState.CollectorInitialized;
+        }
+#endif
+        /// <summary>
+        /// Flush the telemetry in TracerProvider/Exporter.
+        /// </summary>
+        public void ForceFlush()
+        {
+#if NETFRAMEWORK
+            _tracerProvider?.ForceFlush();
+#endif
+        }
+
+        /// <summary>
+        /// Shuts down the telemetry infrastructure.
+        /// </summary>
+        public void Shutdown()
+        {
+            lock (_initializeLock)
+            {
+#if NETFRAMEWORK
+                _tracerProvider?.Shutdown();
+                _collector?.Dispose();
+#endif
+                _telemetryState = TelemetryState.Disposed;
+            }
+        }
+
+        /// <summary>
+        /// Determines if the user has explicitly opted out of telemetry.
+        /// </summary>
+        private bool IsOptOut()
+        {
+            if (IsEnvVarTrue(TelemetryConstants.TelemetryFxOptoutEnvVarName))
+            {
+                return true;
+            }
+
+            if (IsEnvVarTrue(TelemetryConstants.DotnetOptOut))
+            {
+                return true;
+            }
+
+            /* VS OTel manages opt outs by not sending data. */
+
+            return false;
+        }
+
+        /// <summary>
+        /// Determines if telemetry should be initialized based on sampling and environment variable overrides.
+        /// </summary>
+        private bool IsSampled()
+        {
+            double? overrideRate = ReadDoubleEnvVar(TelemetryConstants.TelemetrySampleRateOverrideEnvVarName);
+            if (overrideRate.HasValue)
+            {
+                _sampleRate = overrideRate.Value;
+            }
+            else
+            {
+#if !NETFRAMEWORK
+                // In core, OTel infrastructure is not initialized by default.
+                return false;
+#endif
+            }
+
+            // Simple random sampling, this method is called 
+            Random random = new();
+            return random.NextDouble() < _sampleRate;
+        }
+
+        /// <summary>
+        /// Parses a double environment variable, if present.
+        /// </summary>
+        private double? ReadDoubleEnvVar(string name)
+        {
+            string? sampleRateString =
+                Environment.GetEnvironmentVariable(name);
+
+            if (double.TryParse(sampleRateString, out double result))
+            {
+                return result;
+            }
+
+            return null;
+        }
+
+        /// <summary>
+        /// Evaluates if an environment variable is set to "1" or "true".
+        /// </summary>
+        private bool IsEnvVarTrue(string name)
+        {
+            string? value = Environment.GetEnvironmentVariable(name);
+            return value != null &&
+                   (value.Equals("1", StringComparison.OrdinalIgnoreCase) ||
+                    value.Equals("true", StringComparison.OrdinalIgnoreCase));
+        }
+    }
+}
diff --git a/src/Framework/Telemetry/TelemetryConstants.cs b/src/Framework/Telemetry/TelemetryConstants.cs
new file mode 100644
index 00000000000..418f555d3a3
--- /dev/null
+++ b/src/Framework/Telemetry/TelemetryConstants.cs
@@ -0,0 +1,57 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+namespace Microsoft.Build.Framework.Telemetry;
+
+/// <summary>
+/// Constants for VS OpenTelemetry for basic configuration and appropriate naming for VS exporting/collection.
+/// </summary>
+internal static class TelemetryConstants
+{
+    /// <summary>
+    /// "Microsoft.VisualStudio.OpenTelemetry.*" namespace is required by VS exporting/collection.
+    /// </summary>
+    public const string ActivitySourceNamespacePrefix = "Microsoft.VisualStudio.OpenTelemetry.MSBuild.";
+
+    /// <summary>
+    /// Namespace of the default ActivitySource handling e.g. End of build telemetry.
+    /// </summary>
+    public const string DefaultActivitySourceNamespace = $"{ActivitySourceNamespacePrefix}Default";
+
+    /// <summary>
+    /// Prefix required by VS exporting/collection.
+    /// </summary>
+    public const string EventPrefix = "VS/MSBuild/";
+
+    /// <summary>
+    /// Prefix required by VS exporting/collection.
+    /// </summary>
+    public const string PropertyPrefix = "VS.MSBuild.";
+
+    /// <summary>
+    /// For VS OpenTelemetry Collector to apply the correct privacy policy.
+    /// </summary>
+    public const string VSMajorVersion = "17.0";
+
+    /// <summary>
+    /// Opt out by setting this environment variable to "1" or "true", mirroring
+    /// https://learn.microsoft.com/en-us/dotnet/core/tools/telemetry
+    /// </summary>
+    public const string DotnetOptOut = "DOTNET_CLI_TELEMETRY_OPTOUT";
+
+    /// <summary>
+    /// Variable controlling opt out at the level of not initializing telemetry infrastructure. Set to "1" or "true" to opt out.
+    /// </summary>
+    public const string TelemetryFxOptoutEnvVarName = "MSBUILD_TELEMETRY_OPTOUT";
+
+    /// <summary>
+    /// Overrides sample rate for all namespaces. 
+    /// In core, OTel infrastructure is not initialized by default. Set to a nonzero value to opt in.
+    /// </summary>
+    public const string TelemetrySampleRateOverrideEnvVarName = "MSBUILD_TELEMETRY_SAMPLE_RATE";
+
+    /// <summary>
+    /// Sample rate for the default namespace.
+    /// 1:25000 gives us sample size of sufficient confidence with the assumption we collect the order of 1e7 - 1e8 events per day.
+    /// </summary>
+    public const double DefaultSampleRate = 4e-5;
+}
diff --git a/src/Framework/Telemetry/TelemetryItem.cs b/src/Framework/Telemetry/TelemetryItem.cs
new file mode 100644
index 00000000000..94605d8d5a1
--- /dev/null
+++ b/src/Framework/Telemetry/TelemetryItem.cs
@@ -0,0 +1,6 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Framework.Telemetry;
+
+internal record TelemetryItem(string Name, object Value, bool Hashed);
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index aeddef7aba4..c9fe5fcc5b2 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -248,6 +248,8 @@ string[] args
 
             // Initialize new build telemetry and record start of this build.
             KnownTelemetry.PartialBuildTelemetry = new BuildTelemetry { StartAt = DateTime.UtcNow };
+            // Initialize OpenTelemetry infrastructure
+            OpenTelemetryManager.Instance.Initialize(isStandalone: true);
 
             using PerformanceLogEventListener eventListener = PerformanceLogEventListener.Create();
 
@@ -296,6 +298,9 @@ string[] args
                 DumpCounters(false /* log to console */);
             }
 
+            // Send OpenTelemetry before exiting
+            OpenTelemetryManager.Instance.Shutdown();
+
             return exitCode;
         }
 
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 339dfe620bf..b2ff35a1606 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -62,8 +62,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 9bc9a4c595c..dc3da939549 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -33,7 +33,7 @@
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.IO.Redist" culture="neutral" publicKeyToken="cc7b13ffcd2ddd51" />
