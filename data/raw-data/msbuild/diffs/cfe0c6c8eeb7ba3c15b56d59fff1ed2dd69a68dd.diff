diff --git a/.editorconfig b/.editorconfig
index fc8b2d155df..4a47432ae4f 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -295,6 +295,9 @@ dotnet_diagnostic.IDE0049.severity = suggestion
 # Use compound assignment
 dotnet_diagnostic.IDE0054.severity = suggestion
 
+# Fix formatting
+dotnet_diagnostic.IDE0055.severity = suggestion
+
 # Indexing can be simplified
 dotnet_diagnostic.IDE0056.severity = suggestion
 
@@ -387,8 +390,11 @@ dotnet_diagnostic.IDE0241.severity = suggestion
 # Struct can be made 'readonly'
 dotnet_diagnostic.IDE0250.severity = suggestion
 
+# Struct methods can be made 'readonly'
+dotnet_diagnostic.IDE0251.severity = suggestion
+
 # Null check can be simplified
 dotnet_diagnostic.IDE0270.severity = suggestion
 
 # naming rule violation
-dotnet_diagnostic.IDE1006.severity = suggestion
\ No newline at end of file
+dotnet_diagnostic.IDE1006.severity = suggestion
diff --git a/.github/ISSUE_TEMPLATE/06_feature_request.yml b/.github/ISSUE_TEMPLATE/06_feature_request.yml
new file mode 100644
index 00000000000..c2108af202e
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/06_feature_request.yml
@@ -0,0 +1,27 @@
+name: 💡 Feature  Request
+description: Suggest an idea for this project.
+title: "[Feature Request]: "
+labels: ["Feature Request", "needs-triage"]
+body:
+  - type: textarea
+    attributes:
+      label: Summary
+      description: Brief summary of what this proposal is about.
+    validations:
+      required: true
+  - type: textarea
+    attributes:
+      label: Background and Motivation
+      description: What is the problem we are solving and in what context did you encounter it?
+    validations:
+      required: true
+  - type: textarea
+    attributes:
+      label: Proposed Feature
+      description: Please provide a sketch of the feature you are proposing.
+    validations:
+      required: true
+  - type: textarea
+    attributes:
+      label: Alternative Designs
+      description: If you have an idea how to achieve this new feature, let us know that here. Please include any pointers to code, relevant changes, or related issues you know of.
diff --git a/.github/fabricbot.json b/.github/fabricbot.json
index 61fca534d95..af4f1a94a7a 100644
--- a/.github/fabricbot.json
+++ b/.github/fabricbot.json
@@ -444,7 +444,129 @@
           }
         ]
       }
+    },
+    {
+      "taskType": "trigger",
+      "capabilityId": "IssueResponder",
+      "subCapability": "PullRequestResponder",
+      "version": "1.0",
+      "config": {
+        "conditions": {
+          "operator": "and",
+          "operands": [
+            {
+              "operator": "or",
+              "operands": [
+                {
+                  "name": "isAction",
+                  "parameters": {
+                    "action": "opened"
+                  }
+                },
+                {
+                  "name": "isAction",
+                  "parameters": {
+                    "action": "reopened"
+                  }
+                },
+                {
+                  "name": "labelAdded",
+                  "parameters": {
+                    "label": "Servicing-consider"
+                  }
+                }
+              ]
+            },
+            {
+              "operator": "or",
+              "operands": [
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.0"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.2"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.4"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.5"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.6"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.7"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.8"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.9"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs17.10"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs16.11"
+                  }
+                },
+                {
+                  "name": "prTargetsBranch",
+                  "parameters": {
+                    "branchName": "vs15.9"
+                  }
+                }
+              ]
+            }
+          ]
+        },
+        "eventType": "pull_request",
+        "eventNames": [
+          "pull_request",
+          "issues",
+          "project_card"
+        ],
+        "taskName": "Comment on vs* branches",
+        "actions": [
+          {
+            "name": "addReply",
+            "parameters": {
+              "comment": "Hello! I noticed that you're targeting one of our servicing branches. Please consider updating the version."
+            }
+          }
+        ]
+      }
     }
   ],
   "userGroups": []
-}
+}
\ No newline at end of file
diff --git a/.gitignore b/.gitignore
index 854f738d435..cf8134eada3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -218,3 +218,6 @@ stage1/
 
 # .DS_Store for macOS
 **/.DS_Store
+
+# We keep launchSettings.json local
+**/launchSettings.json
diff --git a/.opt-prof.yml b/.opt-prof.yml
index 35a5a5382d8..47c168210ca 100644
--- a/.opt-prof.yml
+++ b/.opt-prof.yml
@@ -34,6 +34,15 @@ resources:
     name: DartLab.OptProf
     ref: refs/heads/main
 
+parameters:
+  # Whether or not to delete the test machines after the run completes
+  - name: testMachineCleanUpStrategy
+    type: string
+    default: delete
+    values:
+    - delete
+    - stop
+
 stages:
 - template: \templates\stages\visual-studio\single-runsettings.yml@DartLabOptProfTemplates
   parameters:
@@ -45,6 +54,7 @@ stages:
     displayName: OptProf Profiling Workflow
     optOptimizationInputsDropName: $(OptimizationInputsDropName)
     testLabPoolName: VS-Platform # The test lab pool to run your tests in
+    testMachineCleanUpStrategy: ${{parameters.testMachineCleanUpStrategy}}
     testMachineImageName: Windows-10-Enterprise-20H2
     visualStudioSigning: Test
     variables:
@@ -68,7 +78,7 @@ stages:
           $vsBranch = $bootstrapperInfoJson[0].VSBranch
           Write-Host "VSBootstrapperBranch: $vsBranch"
           Set-AzurePipelinesVariable 'VSBootstrapperBranch' $vsBranch
-        }        
+        }
         catch {
           Write-Host $_
           Write-Error "Failed to set VSBootstrapperBranch pipeline variable"
@@ -81,4 +91,4 @@ stages:
         filePath: $(DartLab.Path)\Scripts\VisualStudio\Bootstrapper\Get-BootstrapperURL.ps1
         arguments: -BootstrapperInfoJsonURI '$(Pipeline.Workspace)\ComponentBuildUnderTest\MicroBuildOutputs\BootstrapperInfo.json' -VSBranch '$(VSBootstrapperBranch)' -OutVariableName 'VisualStudio.InstallationUnderTest.BootstrapperURL'
     preDeployAndRunTestsStepList:
-    - download: ComponentBuildUnderTest
\ No newline at end of file
+    - download: ComponentBuildUnderTest
diff --git a/PublishToBlob.proj b/PublishToBlob.proj
deleted file mode 100644
index 3f37b55ba64..00000000000
--- a/PublishToBlob.proj
+++ /dev/null
@@ -1,34 +0,0 @@
-<Project>
-
-  <!--
-
-  This is for the internal orchestrated build scenarios and will likely never be run on a
-  developer's machine.  The official build definition builds this file directly.
-
-  -->
-
-  <PropertyGroup>
-    <FeedTasksPackage>Microsoft.DotNet.Build.Tasks.Feed</FeedTasksPackage>
-    <!-- This version should be kept in sync with `project.json` -->
-    <FeedTasksPackageVersion>2.1.0-prerelease-02419-02</FeedTasksPackageVersion>
-  </PropertyGroup>
-
-  <Import Project="$(MSBuildThisFileDirectory)packages\$(FeedTasksPackage)\$(FeedTasksPackageVersion)\build\$(FeedTasksPackage).targets" />
-
-  <ItemGroup>
-    <ItemsToPush Include="$(MSBuildThisFileDirectory)bin\Packages\*.nupkg" />
-  </ItemGroup>
-
-  <Target Name="Build">
-    <PushToBlobFeed ExpectedFeedUrl="$(ExpectedFeedUrl)"
-                    AccountKey="$(AccountKey)"
-                    ItemsToPush="@(ItemsToPush)"
-                    Overwrite="$(PublishOverwrite)"
-                    ManifestBranch="$(ManifestBranch)"
-                    ManifestBuildId="$(ManifestBuildId)"
-                    ManifestCommit="$(ManifestCommit)"
-                    ManifestName="msbuild"
-                    SkipCreateManifest="false" />
-  </Target>
-
-</Project>
diff --git a/build.sh b/build.sh
index 2d2a01b1ee0..f9a7889f52c 100755
--- a/build.sh
+++ b/build.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 
 SOURCE="${BASH_SOURCE[0]}"
 while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index f2e6b6e4753..2497ff6eb37 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -47,7 +47,7 @@ When `Clean`ing the output of a project, `CleanReferencedProjects` ensures that
 
 ## Targets required to be referenceable
 
-These targets should exist in a project to be compatible with the common targets' `ProjectReference`. Some are called only conditionally.
+These targets should exist in a project to be compatible with the common targets' `ProjectReference` (unless [marked with the `SkipNonexistentTargets='true'` metadatum](#targets-marked-with-skipnonexistenttargetstrue-metadatum)). Some are called only conditionally.
 
 These targets are all defined in `Microsoft.Common.targets` and are defined in Microsoft SDKs. You should only have to implement them yourself if you require custom behavior or are authoring a project that doesn't import the common targets.
 
@@ -85,6 +85,10 @@ If implementing a project with an “outer” (determine what properties to pass
   * As of 15.7, this is _optional_. If a project does not contain a `GetCopyToOutputDirectoryItems` target, projects that reference it will not copy any of its outputs to their own output folders, but the build can succeed.
 * `Clean` should delete all outputs of the project.
   * It is not called during a normal build, only during "Clean" and "Rebuild".
+
+### Targets Marked With `SkipNonexistentTargets='true'` Metadatum
+`GetTargetFrameworks` and `GetTargetFrameworksWithPlatformForSingleTargetFramework` are skippable if nonexistent since some project types (for example, `wixproj` projects) may not define them. See [this comment](https://github.com/dotnet/msbuild/blob/cc55017f88688cbe3f9aa810cdf44273adea76ea/src/Tasks/Microsoft.Managed.After.targets#L74-L77) for more details.
+
 ## Other protocol requirements
 
 As with all MSBuild logic, targets can be added to do other work with `ProjectReference`s.
diff --git a/documentation/README.md b/documentation/README.md
index 082fab41bb3..ec88f6bcae7 100644
--- a/documentation/README.md
+++ b/documentation/README.md
@@ -39,6 +39,7 @@ The folder contains collection of docs and references for MSBuild, detailed info
 ### Problems?
 
 * [Rebuilding when nothing changed](wiki/Rebuilding-when-nothing-changed.md)
+* [Controling References Behavior](wiki/Controlling-Dependencies-Behavior.md)
 * [Something's wrong in my build](wiki/Something's-wrong-in-my-build.md)
 * [Some gotchas around the Microsoft.Build.Framework project/assembly](wiki/Microsoft.Build.Framework.md)
 * [GAC and MSBuild](wiki/UnGAC.md)
@@ -50,16 +51,17 @@ The folder contains collection of docs and references for MSBuild, detailed info
 * [`ProjectReference`](ProjectReference-Protocol.md)
 * [MSBuild Server](MSBuild-Server.md)
 * [Low priority nodes](specs/low-priority-switch.md)
+* [Threading in MSBuild worker nodes](specs/threading.md)
+* [Nodes orchestration](wiki/Nodes-Orchestration.md)
 * [Project cache plugin](specs/project-cache.md)
 * [Support for remote host objects](specs/remote-host-object.md)
 * [Static graph](specs/static-graph.md)
 * [Single project isolated builds: implementation details](specs/single-project-isolated-builds.md)
 * [Task isolation](specs/task-isolation-and-dependencies.md)
-* [Threading in MSBuild worker nodes](specs/threading.md)
 * [Target maps](wiki/Target-Maps.md)
 * [Managing parallelism in MSBuild](specs/resource-management.md)
 * [SDK resolution](specs/sdk-resolvers-algorithm.md)
-* [Nodes orchestration](wiki/Nodes-Orchestration.md)
+* [RAR core scenarios](specs/rar-core-scenarios.md)
 
 ### Tasks
 
@@ -74,11 +76,14 @@ The folder contains collection of docs and references for MSBuild, detailed info
 * [Binary log](wiki/Binary-Log.md)
 * [Live logger: how to opt in](livelogger/Opt-In-Mechanism.md)
 
-## Designs
-
-* [Resolve Assembly Reference as a service](design/rar-as-service.md)
+## Archived Designs
+* [Resolve Assembly Reference as a service](specs/rar-as-service.md)
    * Prototype: https://github.com/dotnet/msbuild/issues/6193
 
+## Proposed Designs
+* [Packages Sourcing](specs/proposed/interactive-package-references.md)
+* [Secrets Metadata](specs/proposed/security-metadata.md)
+
 ## Community contributions
 
 * [MSBuild overview](Contributions/MSBuild-overview.md)
diff --git a/documentation/design/rar-as-service.md b/documentation/specs/archive/rar-as-service.md
similarity index 100%
rename from documentation/design/rar-as-service.md
rename to documentation/specs/archive/rar-as-service.md
diff --git a/documentation/specs/proposed/security-metadata.md b/documentation/specs/proposed/security-metadata.md
new file mode 100644
index 00000000000..e2ed58050b6
--- /dev/null
+++ b/documentation/specs/proposed/security-metadata.md
@@ -0,0 +1,253 @@
+
+# Security Metadata
+
+The feature is meant to improve the security of builds executed via MSBuild, by reducing the chances of spilling secrets (and possibly other sensitive data) from otherwise secured or/and inaccessible build environments.
+
+It builds upon the other efforts reducing the cases accidentaly logging secrets - ['not logging unused environemnt variables'](https://github.com/dotnet/msbuild/pull/7484), 'redacting known secret patterns' (internal, by @michaelcfanning). Distinction here is that we want to give users option how to configure their build scripts and build data so that they can indicate what contains secret/sensitive data and shouldn't get output into logs.
+
+The feature is envisioned to be delivered in multiple interations, while first itearation will be facilitated via global items and/or properties that will be indicating masking logging of specific types of data in log entries (hence no syntactic changes will be imposed for now).
+
+# North Star / Longer-term vision
+
+We envision MSBuild to have a first-class-citisen type system for it's data and tasks. 'Secret' would be one of the data types - allowable to be passed only to other variables or task inputs denoted as 'secret' (so e.g. it would not be possible to pass secrets to [`WriteLinesToFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/writelinestofile-task)) and vice versa 'secret' task input or data type could be initialized/evaluated only from other 'secrets' or predefined external sources of data - environment variables, commandline arguments, files, apropriately denoted task output parameters.
+
+Such a strong typing would allow to hold to stronger guarantees of not spilling properly denoted sensitive data and redact them with minimal impact on build performance (as opposed to intermediate attempts that will need to perform string inspections).
+
+**Ilustrative sample:**
+
+```xml
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Secrets>
+    <!-- initialize from command line -->
+    <GH_token />
+    <!-- initialize from env -->
+    <ACR_login>$(ACR_login)</ACR_login>
+    <!-- initialize by task -->
+    <ACR_password />
+	</Secrets>
+
+  <UsingTask TaskName="ReadCreadentialFromValut" AssemblyFile="$(MSBuildProjectDirectory)/Tasks/ACR-Tasks.dll" />
+  <UsingTask TaskName="PushImageToACR" AssemblyFile="$(MSBuildProjectDirectory)/Tasks/ACR-Tasks.dll" />
+	
+  <Target Name='PushImage'> 
+    <Message Text="Pushin image to ACR" />
+    <ReadCreadentialFromValut 
+      Key="$(ACR_password_key)"
+    >
+      <Output TaskParameter="Value" PropertyName="ACR_password"/>
+    </ReadCreadentialFromValut>
+    <PushImageToACR 
+      Login="$(ACR_login)"
+      Password="$(ACR_password)"
+    />
+  </Target>
+</Project>
+```
+
+```cs
+ReadCreadentialFromValut : Task
+{
+  /// <summary>
+  /// Key to be fetched
+  /// </summary>
+  public string Key { get; set; }
+
+  /// <summary>
+  /// Fetched value
+  /// </summary>
+  [Output]
+  [Secret]
+  public string Value { get; set; }
+
+  // ... Execute() ...
+}
+```
+
+```cs
+PushImageToACR : Task
+{
+  /// <summary>
+  /// Azure Container Registry Login
+  /// </summary>
+  public Secret Login { get; set; }
+
+  /// <summary>
+  /// Azure Container Registry Password
+  /// </summary>
+  public Secret Password { get; set; }
+
+  // ... Execute() ...
+}
+```
+
+An opt-out mechanism would allow usage of properly denoted tasks with plain string input data (and vice versa) - to allow smoother gradual onboarding to the new type system, without the need to rework the entire build script suite at one shot.
+
+
+# Scope of initial iteration
+
+## In scope
+ * Following data can be opted-in for redacting:
+    * property values
+    * item values
+    * item metadata values
+    * all item metadata
+    * any combination of above
+    * task input parameters (to denote that task is requiring sensitive data and only such can be passed in)
+    * task OutputItems (This can be handy in cases similar to [`ReadLinesFromFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/readlinesfromfile-task))
+ * Redacting the above will happen in all log events before they are being sent to subscribed loggers. 
+ * Redacting will apply to data initializations and passing:
+    * task input parameters
+    * task OutputItems
+    * transfering value to other properties/items via evaluation, transforms, flattening, [Property functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/property-functions), [Item functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/item-functions)
+    * initialization from environemnt variables or command line
+ * Redacting **will NOT** occure on:
+    * log events emited from tasks (this might be added as extra opt-in option - but would lead to significant build performance degradation).
+    * any other alternative output of tasks (direct writes to file system, network connections etc.)
+
+## Out of scope
+  * Redacting **will NOT** occure on:
+    * Log events emited from tasks (this might be added as extra opt-in option - but would lead to significant build performance degradation).
+    * Any other alternative output of tasks (direct writes to file system, network connections etc.)
+    * MSBuild xml nodes (elements/attributes) names. (Sensitive data within MSBuild script itself is strongly discouraged)
+    * Passing values to task and there embedding into additional text and passing out as output parameter - unless such is explicitly marked as containing sensitive data.
+    * Encrypting/securing data in memory during therun of the build.
+ 
+
+# User interaction
+
+There needs to be a way how user specifies which data should be redacted from logs. We have several options:
+
+ * New data type - this is part of the [North Star vision](#north-star--longer-term-vision), but is out of scope for the initial iteration.
+ * [Not recomended] Denoting those via some metadata on a definition of the data to be redacted - this has two main drawbacks - a) For some data types (properties, metadata) we'd need new constructs how to attach additional info (property metadata; item meta-metadata). b) some data can be defined implicitly or dynamicaly
+ * Property with global scope - e.g. 
+   ```xml
+   <DataToRedactFromLogs>Foo;Bar;Baz->SomeMetadata;MyItem->*</DataToRedactFromLogs>
+   ```
+   single property might look bit cryptic for denoting different data types. On the other hand it might be more efficient in simple redacting scenarios (pointing to a set of regexes; single sustom redactor etc.) and would allow limiting the log events pre-buffering needs.
+
+ * Item with global scope - e.g. 
+   ```xml
+   <ItemGroup>
+     <!-- Redacting property content based on the name of the property (or environment variable) -->
+     <DataToRedactFromLogs Include="Foo" Type="Property">
+     </DataToRedactFromLogs>
+     <!-- Redacting item content based on the name of the item. Metadat are not redacted -->
+     <DataToRedactFromLogs Include="Bar" Type="Item" RedactValue=True>
+     </DataToRedactFromLogs>
+     <!-- Redacting item metadata content based on the name. -->
+     <DataToRedactFromLogs Include="Baz" Type="Item" RedactValue=False Metadata="SomeMetadata">
+     </DataToRedactFromLogs>
+     <!-- Redacting all metadata content of specific item based on the name of the item. -->
+     <DataToRedactFromLogs Include="MyItem" Type="Item" RedactValue=False Metadata="*" />
+     <!-- Redacting property content passed from the task. At the same time requiring that the data receiving the output of the task are denoted as secret as well. -->
+     <DataToRedactFromLogs Include="OutputA" Type="TaskOutput" TaskName="TaskX" />
+     <!-- Redacting task parameter value. At the same time requiring that the data passed to the parameter of the task are denoted as secret as well. -->
+     <DataToRedactFromLogs Include="ParamA" Type="TaskParameter" TaskName="TaskX" />
+     </DataToRedactFromLogs>
+   </ItemGroup>
+   ```
+   This can offer a more chatty, but better understandable (and possibly beter script generatable) way of denoting the redacting intent.
+ * A regex on *value* to redact above discused data types based on their content - e.g.:
+    ```xml
+   <ItemGroup>
+     <!-- Redact GH tokens based on https://github.blog/changelog/2021-03-31-authentication-token-format-updates-are-generally-available -->
+     <DataToRedactFromLogs Include="ghp_[A-Za-z0-9_]" Type="ValueRegex">
+     </DataToRedactFromLogs>
+   </ItemGroup>
+   ```
+   This way we can give build architects a tool to define common `.props` files opting-in for redacting specific types strings known to be tokens/secrets/sensitive data, without the need to guess under which properties or items they would show within the build
+* A custom plugin flagging values for redaction. e.g.:
+    ```xml
+   <ItemGroup>
+     <DataToRedactFromLogs Include="MySecretsClassifier.dll,Contoso.Secrets.Classifier.ClassifySecrets" Type="ValueClassifierPlugin">
+     </DataToRedactFromLogs>
+   </ItemGroup>
+   ```
+
+   where:
+
+   ```csharp
+   Contoso.Secrets;
+
+   public class Classifier: IValueClassifier
+   {
+      public ISet<string>? GetPartsToRedact(string value) {/* Logic goes here */}
+   }
+   ```
+   This option has additional security considerations, but allows most versatile secrets redaction.
+
+   The last option can possibly be allowed to be injected via other means, that MSBuild currently uses for injecting pluggable fnctionality (command line argument; environment variable; binary placed in a specific search location)
+* A built in redacting plugin - to be opted-in via env var or command line. Plugin will use same extension point as custom plugins - with extended interface allowing to provide redaction values as well:
+   ```csharp
+
+   public interface IValueRedactor
+   {
+      public ISet<Tuple<string, string>>? GetPartsToRedact(string value);
+   }
+   ```
+   This plugin will allow for no-touch redacting of most comon secret patterns by various providers. The default plugin is going to be provided as contribution by 1ES (by @michaelcfanning) and is currently out of scope of this document.
+
+
+First presented option is not to be used. All the other options will likely be supported.
+
+# Special considerations
+
+* There should be no (or very minimal) performance impact to cases where redacting is not opted-in and/or to cases where there is lower/minimal level of logging. In another words - we should not spend cycles detecting and redacting secrets on log events that are not going to be loged (todo: second case might be more problematic - as loggers can decide their level of logging).
+* Order of processing and imports is important here - if we indicate secret metadata in items, the properties are processed first and hence we can miss preanalyzing (or even redacting) some data. Same applies for order of processing of the properties.
+* Considering above two facts - we need a opt-in commandline switch or environemnt variable (or combination) to indicate that secrets metadata might be used - in which case we'll need to buffer build/log events before we have processed all the metadata indicating what needs to be redacted. Extra care will need to be given to sending command line args via EventSource ([source](https://github.com/dotnet/msbuild/blob/main/src/MSBuild/XMake.cs#L655))
+* There are no global items today - this can be simulated by putting those to directory.props
+* Even seemingly innocent tasks with seemingly innocent logging can spill possibly sensitive data (e.g. think the RAR task, logging all the inputs, while those are just reference related info - those can contain paths that might already by itself be sensitive info). Related: [#8493](https://github.com/dotnet/msbuild/issues/8493) 
+* `MSBuild` task can pose a boundary for some context passing (e.g. properties/items).
+* Properties/items can occure dynamically after the initial processing of the script - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task). That should not be a problem, but we should keep it in mind (as additional entrypoint of external data into internal data holders).
+* Task authors and consumers are posibly different personas with disconected codebases. For this reason we want to support ability to indicate that task input/output is meant to be a secret. A user of the task should follow the contract and denote the data to be mounted to the task appropriately (otherwise a build warning/error will be issued).
+
+# Suggested Implementation
+
+* Need for explicit opt-in - command line switch or environment variable.
+* On detection of opt in, all build events for loggers need to be buffered for a deffered dispatch to loggers (similarly as we have ['DeferredBuildMessage'](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L400) and [`LogDeferredMessages`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L2890)), until the full pass through the build script (including all imports and `.props` and `.targets` files) so that properties initialization and items initialization is fully performed - as only then we know the full extent of requested redacting.
+  * In the future version - with first-class citizen type for secrets, we can possibly frontload single pass through the script just for detection of the secret redaction declarations and avoid the buffering and post-process need.
+* Buffered events need to be post-processed in respect with the redaction requests, only then dispatched.
+* We'll maintain lookup of elements requested for redaction - those explicitly requested by the name of property/item and those identified as sensitive by value or by transfer of value from other sensitive element.
+* We'll intercept assigments of value to property ([`TrackPropertyWrite`](https://github.com/dotnet/msbuild/blob/main/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs#L223)), item and task parameter
+  * If value is assigned to a task parameter and such is indicated by user as sensitive, the holder of the value (the R-value - parameter/item being assigned to the task input) needs to be as well tracked as sensitive, otherwise build waring/error will be issued.
+  * If value is assigned to a task parameter and such is not indicated by user as sensitive, but the holder of the value (the R-value - parameter/item being assigned to the task input) is tracked as sensitive (either because it was explicitly denoted by name, or it was later marked by MSBuild due to holding value matching a sensitivity value regex or callback) - a build warning/error will be issued.
+  * If value is assigned to property/item from a task output and such is indicated by user as sensitive, the L-value holder of the value (the property/item being assigned to) need to be as well tracked as sensitive, otherwise build waring/error will be issued.
+  * If value is being assigned to property or item
+    * and such is indicated by user as sensitive, the generated build event needs to be redacted.
+    * and such is not indicated by user as sensitive, but the R-value is indicated as sensitive - the data holder (property/item) is marked as holding sensitive data and treated accordingly.
+    * and such is not indicated by user as sensitive, the value is passed to sensitivity indicating regex or callback (in case any of those are configured by user) and if matched - the data holder (property/item) is marked as holding sensitive data and treated accordingly.
+* No other redacting of log events will be performed. This is not a strong requirement - we can introduce another opt-in level of strict inspection of all log events. The gain is very questionable though, while the performance impact is severe (internal experiments by @michaelcfanning measured by @rokonec indicate 4-times slow-down on mid-size build). Additionally to being perf-expensive, it can possibly get easily confused - e.g.:
+
+```xml
+<ItemGroup>
+  <DataToRedactFromLogs>MySecret</DataToRedactFromLogs>
+  <MySecret>a</MySecret>
+  <MyInnocentData>hahaha</MyInnocentData>
+  <SomeProp></SomeProp>
+</ItemGroup>
+
+<Target Name="Test">
+  <MyTask FirstInput="MySecret" SecondInput="MyInnocentData">
+    <Output PropertyName="SomeProp" TaskParameter="Result">
+  </MyTask>
+  <!-- Might log: 
+       Result from task: h<redacted>h<redacted>h<redacted>
+  -->
+  <Message Text="Result from task: $(SomeProp)">
+</Target>
+```
+
+In case we'd want to redact all occurences of value of `MySecret` from the task result - we might get a lot of false positives and very confusing results.
+
+# Open questions
+ * What to use as a replacement of the data to be redacted? (Randomized hash, fixed token, etc.) - *very likely just a static pattern ('******'). The built-in redactor plugin will be allowed to provide custom replacements*
+ * Do we want to allow to supply custom replacement value for injectable redaction functionality? There would need to be very strong compeling reason, as this is easily suspectible to [log forging attack](https://owasp.org/www-community/attacks/Log_Injection) - *most likely no.*
+ * Balancing performance and accuracy - can we afford to not support arbitrary output of tasks? Otherwise we'd need to process all log events (similar experiments indicate 4 times slowdown of the build of mid-size project (Orchard)). On the other with explicit 'secret metadata' feature users might expect 100% correctness. Should we make this configurable as well (input data only vs all log entries)? Plus this might be suspectible to false positives (see above).
+
+
+# Links
+ * Nightfall data redaction syntax: https://docs.nightfall.ai/docs/redacting-sensitive-data-in-4-lines-of-code
+ * `spark.redaction.regex`: https://people.apache.org/~pwendell/spark-releases/latest/configuration.html
+ * Redacting secrets in k8s logs in ops tool `Komodor`: https://docs.komodor.com/Learn/Sensitive-Information-Redaction.html
+ * MSBuild opt-in functionality for properties/items/metadata logging disabling: https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs#L1199
+
diff --git a/documentation/specs/rar-core-scenarios.md b/documentation/specs/rar-core-scenarios.md
new file mode 100644
index 00000000000..3fb19ad7846
--- /dev/null
+++ b/documentation/specs/rar-core-scenarios.md
@@ -0,0 +1,200 @@
+# Resolve Assembly Reference core scenarios
+
+This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.
+The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously
+slow build tasks.
+
+## Overview
+
+RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different
+locations where it searches for assemblies. Please see the [official documentation](https://learn.microsoft.com/visualstudio/msbuild/resolveassemblyreference-task) and
+the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description
+of its features.
+
+While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,
+if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of
+the "resolvers", internal classes implementing various resolution strategies, are not used in modern scenarios.
+
+## Requirements
+
+Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the
+assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because
+assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,
+RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.
+
+### Inputs
+
+In a typical build targeting modern .NET (*not* .NET Framework), RAR inputs come from three sources.
+
+1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the
+corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are
+transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are
+guaranteed to be passed in.
+
+1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,
+signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.
+
+1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly
+reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly
+files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are
+resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is
+established.
+
+The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the
+combined SDK, NuGet, and project references in one input array.
+
+## Design
+
+To meet the requirements, RAR must internally be able to do the following.
+
+- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores
+the reference.
+
+- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as
+`C:\_nugetpackages\microsoft.netcore.app.ref\7.0.2\ref\net7.0\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be
+`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees
+such an AssemblyRef in another assembly.
+
+- For project references (reference given as a path to an assembly file that is not guaranteed to have its dependencies resolved), RAR must be able to look
+up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.
+Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,
+`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is
+configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,
+if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.
+
+## Scale
+
+The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything
+that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.
+In the OrchardCore solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.
+
+While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR
+has to touch the disk.
+
+- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually
+exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.
+- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the
+file with a .NET metadata reader.
+- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening
+the file with a .NET metadata reader.
+
+## Optimizations
+
+RAR optimizations tend to revolve around caching of information that is expensive to calculate.
+
+### Existing caching
+
+Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.
+
+#### **Per invocation in-memory cache**
+
+Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot
+assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.
+One issue with this cache is that the key is not normalized so a file specified as `C:\dir\file` will use a different cache entry than the same file specified as
+`C:/dir/file`.
+
+#### **Per process in-memory cache**
+
+This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last
+modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer
+considered valid.
+
+Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`
+and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that
+comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is
+more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like
+`C:\_nugetpackages\microsoft.aspnetcore.app.ref\7.0.2\ref\net7.0`, for example.
+
+#### **Per project disk cache**
+
+To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the
+`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified
+during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written
+back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.
+Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.
+
+From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents
+already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom
+hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.
+
+#### **SDK disk pre-cache**
+
+The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global
+pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the
+file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.
+
+The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`
+but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.
+
+The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.
+For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the
+per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also
+wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.
+
+## Proposed design
+
+Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly
+configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional
+effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help
+address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.
+
+For regular project references the system works as about as efficient as possible.
+- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.
+- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the
+corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.
+- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.
+
+There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.
+File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race
+condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.
+The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.
+
+The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project
+references, so optimizing them has the best bang for the buck.
+
+### Obtain assembly names from the SDK
+
+The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its
+.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies
+outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)
+from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense
+to save it to disk.
+
+If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,
+significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.
+
+This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not
+valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only
+the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.
+
+### Treat NuGet references as immutable [shelved]
+
+NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as
+well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller
+because the number of NuGet references is typically lower. The proposal is to shelve this opportunity for now due to the unfavorable risk-benefit ratio.
+
+### Don't load the per project disk cache when not needed
+
+As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to
+load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is
+built over and over again, the cache would typically not be loaded at all, unless the developer makes a change that actually changes the dependency graph.
+
+### Save only relevant data to the per project disk cache
+
+As for saving the per-project cache, we would guarantee that after RAR is done, the cache contains exactly the data needed for this specific project. This would
+be done by keeping track of the items used during RAR execution, and writing those and only those to the cache. Having a cache that's guaranteed to have certain
+well-defined content after each build is a very good property to have. For instance, in dev box scenarios it would otherwise be hard to reliably "prime" a repo
+enlistment - the system may prime by building the full solution and then the developer uses the box to build a specific project that happens to have an incomplete
+cache and get sub-optimal first-time build performance.
+
+Saving of the per-project disk cache may be further optimized by
+- Keeping the timestamp of the cache file in memory and skipping the save if the relevant cache items haven't become dirty (i.e. the dependencies have not changed)
+*and* the timestamp of the cache file hasn't changed since the last save. In hot inner loop scenarios this would reduce the save to a timestamp check.
+- Saving the file asynchronously, i.e. not blocking the build on completing the save operation.
+
+### Don't use the SDK disk pre-cache
+
+The idea of pre-generated on-disk cache is sound. For the `ExternallyResolved` SDK assemblies specifically, though, it effectively duplicates the information already
+present in `FrameworkList.xml`. That is, it maps assembly paths to assembly names. If the need arises we may want to re-design the pre-cache to remove the major
+drawback that it duplicates itself into all per-project caches. Cold RAR would load both caches and combine their contents (currently it's either or). Until then,
+it should be OK to leave it unchanged and unused.
diff --git a/documentation/specs/single-project-isolated-builds.md b/documentation/specs/single-project-isolated-builds.md
index e3f8b94670d..75b15fc5b82 100644
--- a/documentation/specs/single-project-isolated-builds.md
+++ b/documentation/specs/single-project-isolated-builds.md
@@ -1,54 +1,43 @@
-# Single project isolated builds: implementation details
+# Single Project Isolated Builds: Implementation Details
 
 <!-- workflow -->
 Single project isolated builds can be achieved by providing MSBuild with input and output cache files.
 
-The input cache files contain the cached results of all the targets that a project calls on its references. When a project builds without isolation, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves their results from the provided input caches. In an isolated project build, only the top level project (built via the BuildManager APIs) should build targets. Any referenced projects by the top level project should be provided from the input caches.
+The input cache files contain the cached `TargetResult`s of all targets that a project calls on its references. When a project builds without isolation, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves their results from the provided input caches. In an isolated project build, only the top level project (built via the `BuildManager` APIs) should build targets; Any referenced projects by the top level project should be provided from the input caches.
 
-The output cache file tells MSBuild where to serialize the results of building the current project. This output cache becomes an input cache for all other projects that depend on the current project.
-The output cache file can be omitted in which case the build reuses prior results but does not write out any new results. This is useful when one wants to re-execute the build for a project without building its references.
+The output cache file tells MSBuild where to serialize the `TargetResult`s for a project's built targets and becomes an input cache for dependent projects.
 
 The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).
 
-## Input / Output cache implementation
+## Input / Output Cache Implementation
 <!-- cache structure -->
-The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22).
-
-One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.
+The cache files contain the serialized state of MSBuild's [`ConfigCache`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [`ResultsCache`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCache.cs), which have been traditionally used by the engine to cache build results. They ensure that a target is only built once per build submission. `ConfigCache` entries are instances of [`BuildRequestConfiguration`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25)s (a `(project path, global properties)` tuple), and `ResultsCache` entries are instances of [`BuildResult`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34)s, which contain [`TargetResult`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22)s. The `ConfigCache` entries and `ResultsCache` entries form a [bijection](https://en.wikipedia.org/wiki/Bijection).
 
 <!-- cache lifetime -->
-The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
+In a build, the input and output cache files have the same lifetime as the `ConfigCache` and  `ResultsCache`. The `ConfigCache` and  `ResultsCache` are owned by the [`BuildManager`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On command-line builds, the cache lifetime is the same as the entire process lifetime since `MSBuild.exe` uses one `BuildManager` with one `BeginBuild` / `EndBuild` session. When other processes (e.g. Visual Studio's `devenv.exe`) perform MSBuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
 
 <!-- constraints -->
 
-When MSBuild is loading input cache files, it has to merge multiple incoming instances of `ConfigCache` and `ResultsCache` into one instance of each. The [CacheAggregator](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L13) is responsible for stitching together the pairs of deserialized `ConfigCache`/`ResultsCache` entries from each input cache file.
-The following constraints are enforced during cache aggregation:
-- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
-- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache (on `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`)
-- Colliding configurations (defined as tuples of `(project path, global properties)`) get their corresponding BuildResult entries merged at the level of TargetResult entries. TargetResult conflicts are handled via the "first one wins" strategy. This is in line with vanilla msbuild's behaviour where a target tuple of `(project path, global properties, target)` gets executed only once.
+When loading input cache files, MSBuild merges incoming instances of `ConfigCache`s and `ResultsCache`s into one instance of each with the help of the [`CacheAggregator`](https://github.com/dotnet/msbuild/blob/51df47643a8ee2715ac67fab8d652b25be070cd2/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L15), which enforces the following constraints:
+- No duplicate cache entries
+- Bijection:
+   - `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
+   - `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`
 
-The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.
+Note that the output cache file contains a single `BuildResult` with the `TargetResult`s from the project specified to be built in the `BeginBuild` / `EndBuild` session, as any `BuildResult`s obtained through isolation exemption are excluded to prevent potential duplicate input cache entries; Entries from input caches are not transferred to the output cache.
 
 <!-- How input / output cache entries are separated with the override caches -->
-Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache. The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.
+Input cache entries are separated from output cache entries with the composite caches [`ConfigCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [`ResultsCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). Each composite cache contains two underlying caches: a cache where input caches files are loaded into (the override cache), and a cache where new results are written into (the current cache).* In the `ConfigCacheWithOverride`, these caches are instances of `ConfigCache`s and, in the `ResultsCacheWithOverride`, these caches are instances of `ResultsCache`s. A query for a cache entry is first attempted from the override cache and, if unsatisfied, a second attempt is made from the current cache. Writes are only written to the current cache, never into the override cache.* It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache query.
 
-## Isolation implementation
+## Isolation Implementation
 
-[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the Scheduler and the TaskBuilder. [TaskBuilder.ExecuteInstantiatedTask](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in `ProjectReference`. [Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
+[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the `Scheduler` and  `TaskBuilder`. [`TaskBuilder.ExecuteInstantiatedTask`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in a `ProjectReference` item. [`Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
 
-### How isolation exemption complicates everything
-<!-- Potential cache scenarios caused by exemption -->
-Project references [can be exempt](static-graph.md#exempting-references-from-isolation-constraints) from isolation constraints via the `GraphIsolationExemptReference` item.
+### Isolation Exemption
+The `Scheduler` [skips isolation constraints](static-graph.md#exempting-references-from-isolation-constraints) on project references via the:
 
-The `Scheduler` knows to skip isolation constraints on an exempt `BuildRequest` because the [ProjectBuilder compares](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L349) each new `BuildRequest` against the `GraphIsolationExemptReference` items defined in the calling project, and if exempt, sets `BuildRequest.SkipStaticGraphIsolationConstraints`. When a `BuildRequest` is marked as exempt, the `Scheduler` also marks its corresponding `BuildRequestConfiguration` as exempt as well, which aids in further identification of exempt projects outside the `Scheduler`.
+* `GraphIsolationExemptReference` item. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of a `BuildRequest` to `true` if the `RequestBuilder` matches it against a `GraphIsolationExemptReference` item defined in the calling project. Additionally, the `RequestBuilder` marks the `BuildRequest`'s corresponding `BuildRequestConfiguration` as exempt to allow the `TaskBuilder` to verify exemption from isolation constraints.
 
-The build results for the exempt project are also included in the current cache (according to the above mentioned rule that newly built results are serialized in the output cache file). This complicates the way caches interact in several scenarios:
-1. the same project can be exempt via multiple references, thus potentially colliding when multiple output cache files containing the same exempt project get aggregated. For example, given the graph `{A->B, A->C}`, where both `B` and `C` build the exempt project `D`, `D` will appear in the output caches of both `B` and `C`. When `A` aggregates these two caches, it will encounter duplicate entries for `D`, and will need to merge the results.
-2. a project can be both exempt and present in the graph at the same time. For example, given the graph `{A->B}`, both `A` and `B` are in the graph, but `A` can also mark `B` as exempt (meaning that `A` contains both a `ProjectReference` item to `B`, and a `GraphIsolationExemptReference` item to `B`). The fact that `B` is in the graph means that `A` will receive an input cache containing B's build results. There are two subcases here:
-   1.  `A` builds targets from `B` that already exist in the input cache file from `B`. In this case, all the builds of `B` will be cache hits, and no target results from `B` will make it into `A`'s output cache, since nothing new was built.
-   2.  `A` builds targets from `B` that do not exist in the input cache file from `B`. If `B` weren't exempt from isolation constraints, this scenario would lead to a build break, as cache misses are illegal under isolation. With `B` being exempt, the new builds of `B` will get included in `A`'s output cache. The results from `B`'s cache file won't get included in `A`'s output cache file, as they weren't built by `A`.
-3. A project, which is not in the graph, can be exempt by two parent/child projects from the graph. For example, given the graph `{A->B}`, both `A` and `B` can exempt project `D` (meaning that neither `A` nor `B` have a `ProjectReference` to `D`, but both `A` and `B` have a `GraphIsolationExemptReference` to `D`). The fact that `B` is in the graph means that `A` will receive an input cache containing `B`'s build results. Since `B` builds targets from `D`, it means that `B`'s output cache file also contains target results from `D`. There are two subcases here:
-   1. `A` builds targets from `D` that already exist in the input cache file from `B`. This is handled in the same way as the above case `2.1.`
-   2. `A` builds targets from `D` that do not exist in the input cache file from `B`, meaning that `A` builds additional targets from `D` which `B` didn't build. This is handled in the same way as teh above case `2.2.`
+* `isolate:MessageUponIsolationViolation` switch. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of _every_ `BuildRequest` to `true`. The `TaskBuilder` verifies exemption from isolation constraints just by the switch value.
 
-**Current issue:** if multiple nodes in the graph exempt the same project file, the build results of the exempt project will trickle up and conflict in the first parent that tries to merge them. Documented in issue [#4386](https://github.com/dotnet/msbuild/issues/4386).
+\* Except in the following scenario when a `ProjectReference` is exempted from isolation constraints: a dependency project A outputs a cache file F containing a `BuildResult` with `TargetResult`s T<sub>cached</sub> for targets t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>m</sub> and a dependent project B uses F as an input cache file but builds and obtains the `TargetResult`s T<sub>new</sub> for targets t<sub>m + 1</sub>, t<sub>m + 2</sub>, ..., t<sub>n</sub> such that 0 < m < n. In this case, T<sub>new</sub> will be placed into the `ResultsCache` containing T<sub>cached</sub> to enforce no overlap between the override and current caches in the `ConfigCacheWithOverride`.
\ No newline at end of file
diff --git a/documentation/specs/static-graph.md b/documentation/specs/static-graph.md
index 99bceac17ab..49acebe57fe 100644
--- a/documentation/specs/static-graph.md
+++ b/documentation/specs/static-graph.md
@@ -223,15 +223,17 @@ A project reference protocol may contain multiple targets, for example `A -> B,
 
 The common project reference protocols (Build, Rebuild, Restore, Clean) will be specified by the common props and targets file in the msbuild repository. Other SDKs can implement their own protocols (e.g. ASPNET implementing Publish).
 
+For this section and the remainder of this spec, a project's default target(s) (what it would execute if no other targets are specified, so often Build but configurable via DefaultTargets) will be referred to as `.default`. That is also how it is used in MSBuild code.
+
 Here are the rules for the common protocols:
 
-`Build -> GetTargetFrameworks, <default>, GetNativeManifest, GetCopyToOutputDirectoryItems`
+`Build -> GetTargetFrameworks, .default, GetNativeManifest, GetCopyToOutputDirectoryItems`
 
-The default target (represented in this spec's pseudo protocol representation as `<default>`) is resolved for each project.
+`.default` is resolved for each project.
 
 `Clean -> GetTargetFrameworks, Clean`
 
-`Rebuild -> GetTargetFrameworks, Clean, <default>, GetNativeManifest, GetCopyToOutputDirectoryItems`
+`Rebuild -> GetTargetFrameworks, Clean, .default, GetNativeManifest, GetCopyToOutputDirectoryItems`
 
 `Rebuild` actually calls `Clean` and `Build`, which in turn uses the concatenation of the `Clean` and `Build` mappings. `GetTargetFrameworks` is repeated so only the first call to it remains in the final target list.
 
@@ -358,7 +360,7 @@ namespace Microsoft.Build.Experimental.Graph
 ```
 
 ## Isolated builds
-Building a project in isolation means enforcing the constraint that whenever a graph node is built, all the target calls that it does on its references **do not execute** because their results are already available. This means that any BuildResult objects for project references must be pre-computed and somehow provided as inputs to the referencing project.
+Building a project in isolation means enforcing the constraint that whenever a graph node is built, all the target calls that it does on its references **do not execute** because their results are already available. This means that any `BuildResult` objects for project references must be precomputed and somehow provided as inputs to the referencing project.
 
 If a project uses the MSBuild task, the build result must be in MSBuild's build result cache instead of just-in-time executing targets on that referenced project. If it is not in the build result cache, an error will be logged and the build will fail. If the project is calling into itself either via `CallTarget` or the MSBuild task with a different set of global properties, this will be allowed to support multitargeting and other build dimensions implemented in a similar way.
 
@@ -367,7 +369,7 @@ Because referenced projects and their entry targets are guaranteed to be in the
 ### Isolated graph builds
 When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.
 
-Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
+Furthermore, running in this mode enforces that each `(project, global properties)` pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
 
 This discrete start and end time also allows for easy integration with [I/O Tracking](#io-tracking) to observe all inputs and outputs for a project. Note however that I/O during target execution, particular target execution which may not normally happen as part of a project's individual build execution, would be attributed to the project reference project rather the project with the project reference. This differs from today's behavior, but seems like a desirable difference anyway.
 
@@ -387,9 +389,9 @@ These incremental builds could be extended to the entire graph by keeping a proj
 Details on how isolation and cache files are implemented in MSBuild can be found [here](./static-graph-implementation-details.md).
 
 #### APIs
-Cache file information is provided via [BuildParameters](https://github.com/dotnet/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one BuildManager BeginBuild/EndBuild session.
+Cache file information is provided via [`BuildParameters`](https://github.com/dotnet/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one `BuildManager` `BeginBuild`/`EndBuild` session.
 
-Isolation constraints are turned on via [BuildParameters.IsolateProjects](https://github.com/dotnet/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used.
+Isolation constraints are turned on via [`BuildParameters.IsolateProjects`](https://github.com/dotnet/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used, except when the `isolate:MessageUponIsolationViolation` switch is used.
 
 #### Command line
 Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.
@@ -401,14 +403,21 @@ In certain situations one may want to exempt a reference from isolation constrai
 - exempting references whose project files are generated at build times with random names (for example, each WPF project, before the Build target, generates and builds a helper .csproj with a random file name)
 - relaxing constraints for MSBuild task calling patterns that static graph cannot express (for exemple, if a project is calculating references, or the targets to call on references, at runtime via an arbitrary algorithm)
 
-A project is exempt from isolation constraints by adding its full path to the `GraphIsolationExemptReference` item. For example, if project A.csproj references project B.csproj, the following snippet exempts B.csproj from isolation constraints while A.csproj is built:
-```xml
-<ItemGroup>
-  <GraphIsolationExemptReference Include="/Full/Path/To/B.csproj" />
-</ItemGroup>
-```
-
-A reference is exempt only in projects that add the reference in `GraphIsolationExemptReference`. If multiple projects need to exempt the same reference, all of them need to add the reference to `GraphIsolationExemptReference`.
+A project may be exempt from isolation constraints in two ways:
+
+<!-- List is encoded in HTML since XML code block
+and its following text won't be indented properly. -->
+<ul>
+<li>its full path is added to the <code>GraphIsolationExemptReference</code> item. For example, if project <code>A.csproj</code> references project <code>B.csproj</code>, the following snippet exempts <code>B.csproj</code> from isolation constraints while <code>A.csproj</code> is built:
+<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
+  <span class="hljs-tag">&lt;<span class="hljs-name">GraphIsolationExemptReference</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"/Full/Path/To/B.csproj"</span> /&gt;</span>
+<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
+</code></pre>
+If multiple projects need to exempt the same reference, all of them need to add the reference to <code>GraphIsolationExemptReference</code>.
+</li>
+<li> via the <code>isolate:MessageUponIsolationViolation</code> switch
+</li>
+</ul>
 
 For now, self-builds (a project building itself with different global properties) are also exempt from isolation constraints, but this behaviour is of dubious value and might be changed in the future.
 
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 4ef85d8de35..f96cbb83e99 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -28,6 +28,8 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
 - [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
 - [Log assembly loads](https://github.com/dotnet/msbuild/pull/8316)
+- [AnyHaveMetadataValue returns false when passed an empty list](https://github.com/dotnet/msbuild/pull/8603)
+- [Log item self-expansion](https://github.com/dotnet/msbuild/pull/8581)
 
 ### 17.4
 - [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
diff --git a/documentation/wiki/Controlling-Dependencies-Behavior.md b/documentation/wiki/Controlling-Dependencies-Behavior.md
new file mode 100644
index 00000000000..ceafb75a2d1
--- /dev/null
+++ b/documentation/wiki/Controlling-Dependencies-Behavior.md
@@ -0,0 +1,264 @@
+# Controlling references behavior
+
+MSBuild recognizes a [few types of references](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the references workings - transitive references resolution, multitargeted references resolution, copying references to output directory.
+
+## .NET SDK projects and access to transitive references
+
+[.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) by default make all transitive references accessible as if they were direct references.
+
+This is provided for the compiler and analyzers to be able to properly inspect the whole dependency or/and inheritance chain of types when deciding about particular checks.
+
+It is facilitated via `project.assets.json` file created by NuGet client during the restore operation. This file captures the whole transitive closure of the project dependency tree.
+
+SDK build tasks require existence of this file (hence the infamous `Assets file <path>\project.assets.json not found` if the MSBuild.exe is run without prior restore operation). It is used to reconstruct the `ProjectReference`s and create `Reference` items for the content of `PackageReference`s for the project and make them available to the rest of the build. For this reason MSBuild and compiler by default sees those transitive references as if they were direct references.
+
+## Access to transitive project references
+
+Above described behavior can lead to easy unintentional breaking out of layering architecture separation. 
+
+This behavior can be opted-out for `ProjectReference`s via `DisableTransitiveProjectReferences` property on the referencing project.
+
+<a name="OnionArchSample"></a>*Example*:
+
+Let's imagine an `Onion Architecture` design:
+
+```mermaid
+flowchart LR
+    Service[Service Layer] --> Repository
+    Repository[Repository Layer] --> Domain[Domain Layer]
+```
+
+Service Layer definition:
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <ItemGroup>
+    <ProjectReference Include="..\Repository\Repository.csproj" />
+  </ItemGroup>
+
+  <PropertyGroup>
+    <TargetFramework>net48</TargetFramework>
+    <LangVersion>10</LangVersion>
+    <!-- This prevents referencing types from transitive project references. -->
+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>
+  </PropertyGroup>
+</Project>
+```
+
+```csharp
+namespace Service;
+	
+public class PersonsAccessor
+{
+    private Repository.Persona _persona;
+    // This is allowed unless DisableTransitiveProjectReferences=true is passed into build.
+    // private Domain.PersonTable _tbl;
+}
+```
+
+## Access to transitive package references
+
+The transitive access to references works by default for package references as well. This can be opted out for referencing projects via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets)).
+
+When using this metadatum - the access to the package, its dirrect and transitive dependencies is **not** restricted for the project declaring the refenerence on the package in its `Project` element. It is restricted for the projects referencing the project (or package) that specified the `PackageRegerence` with the `PrivateAssets` metadatum.
+
+*Example*:
+
+In our previous example let's have `Repository Layer` reference `newtonsoft.json`:
+
+```mermaid
+flowchart LR
+    Service[Service Layer] --> Repository
+    Repository[Repository Layer] --> newtonsoft.json[newtonsoft.json]
+```
+
+We are not able to influence access to `newtonsoft.json` and its dependencies (would there be any) in the `Repository Layer`, but we can prevent it from propagating to `Service Layer`.
+
+`Repository Layer`:
+
+```xml
+<ItemGroup>
+  <PackageReference Include="newtonsoft.json" Version="13.0.1">
+    <!-- This prevents the reference to be available to referencing types. -->
+    <PrivateAssets>compile</PrivateAssets>
+  </PackageReference>
+</ItemGroup>
+```
+
+Unless opted out via `PrivateAssets=compile`, our `Service Layer` would have access to `newtonsoft.json`:
+
+```csharp
+namespace Service;
+//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.
+//using Newtonsoft.Json;
+	
+public class PersonsAccessor
+{
+    private Repository.Persona _persona;
+}
+```
+
+**Notes:**
+   `PrivateAssets` metadatum (and it's counterparts `IncludeAssets` and `ExcludeAssets`) is applicable to `PackageReference` and controls exposure of dependencies to the consuming projects, not the current project. It is currently not possible to prevent access to package references from within directly referencing project - this is purely decision of the package itself (as it can define it's dependencies as `PrivateAssets`).
+
+## Not copying dependencies to output
+
+By default the above mentioned dependency types are copied to the build output directory during the build. There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).
+
+Overriding this logic depends on the type of the dependency.
+
+### Not copying Assembly Reference
+
+Copying can be opted out via [Private metadata on the Reference item](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items?view=vs-2015#reference) (which corresponds to the `Copy Local` property of the reference in the Visual Studio properties dialog for the reference):
+
+```xml
+<ItemGroup>
+  <Reference Include="mydll">
+    <HintPath>..\somepath\mydll.dll</HintPath>
+    <!-- This indicates that the reference should not be copied to output folder. -->
+    <Private>false</Private>
+  </Reference>
+</ItemGroup>
+```
+
+### Not copying PackageReference
+
+Detailed options description can be found in [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets). Here we'll offer three artifical examples:
+
+**Not copying package dependency to the immediate output folder:**
+
+```xml
+<ItemGroup>
+  <PackageReference Include="newtonsoft.json" Version="13.0.1">
+    <!-- This allows compiling against the dependency, but prevents it's copying to output folder or flow to downstream dependant projects. -->
+    <IncludeAssets>compile</IncludeAssets>
+  </PackageReference>
+</ItemGroup>
+```
+
+**Not copying package dependency to the downstream dependants output folder:**
+
+```xml
+<ItemGroup>
+  <PackageReference Include="newtonsoft.json" Version="13.0.1">
+    <!-- The dependency is copied to output folder in current referencing project, 
+           but it's not copied to output folder of projects referencing current project. -->
+    <PrivateAssets>all</PrivateAssets>
+  </PackageReference>
+</ItemGroup>
+```
+
+**Not copying package dependency from the upstream dependencies:**
+
+```xml
+<ItemGroup>
+  <ProjectReference Include="../somepath/MyProj.csproj">
+    <!-- This prevents PackageReferences from MyProj.csproj to be copied to output of current project. -->
+    <ExcludeAssets>all</ExcludeAssets>
+  </ProjectReference>
+</ItemGroup>
+```
+
+### Not copying ProjectReference
+
+The opt-out mechanism is analogous to [Assembly Reference copy opt-out](#not-copying-assembly-reference):
+
+```xml
+<ItemGroup>
+  <ProjectReference Include="../somepath/MyProj.csproj">
+    <!-- This indicates that the referenced project output should not be copied to output folder. -->
+    <Private>false</Private>
+  </ProjectReference>
+</ItemGroup>
+```
+
+Same metadata and logic applies here as it is being inherited from the `Reference` Item definition and the logic treats it identicaly. 
+
+## ProjectReference without accessibility and copying to output
+
+In a specific scenarios we might want to indicate that specific project should be built prior our project but said project should not be reference accessible nor its output copied to current project output. This can be helpful for build time only dependencies - projects defining behavior that is going to be used as build step of a current project.
+
+Such a behavior can be achived with [`ReferenceOutputAssembly` metadata](https://learn.microsoft.com/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#projectreference):
+
+```xml
+<ItemGroup>
+  <ProjectReference Include="../somepath/MyProj.csproj">
+    <!-- This indicates that the referenced project should not be referenced in code and output should not be copied to output folder. 
+         This way we basically only indicate the build order.
+    -->
+    <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+  </ProjectReference>
+</ItemGroup>
+```
+
+**Note:** This technique has possibly unexpected behavior when referencing project with executable output type (`<OutputType>Exe</OutputType>`) - in such case the output assembly (`.dll`) is still not copied and referenced (as the metadatum name implies) and hence the types defined within the project cannot be referenced, however other supplementary output (added as `content` or `none`) is copied to the current project output folder (for .NET Core this includes `deps.json`, `runtimeconfig.json` and mainly `<app>.exe`). In that case we can combine (or replace) the `ReferenceOutputAssembly` metadata with `Private` metadata - [as described above](#not-copying-projectreference). More details on this case [here](https://github.com/dotnet/msbuild/issues/4795#issuecomment-1442390297)
+
+## Forcing TargetFramework of a referenced multitargeted project
+
+Consider agaoin our previous [Onion architecture example](#OnionArchSample), but now the individual projects will be [multitargeted](https://learn.microsoft.com/nuget/create-packages/multiple-target-frameworks-project-file). 
+
+Repository Layer:
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <TargetFrameworks>netstandard2.0;net48</TargetFrameworks>
+  </PropertyGroup>
+
+  <ItemGroup Condition="'$(TargetFramework)' == 'net48'">
+    <ProjectReference Include="..\Domain-net48\Domain-net48.csproj" />
+    <PackageReference Include="System.Text.Json" Version="7.0.2" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
+    <ProjectReference Include="..\Domain-netstd20\Domain-netstd20.csproj" />
+    <PackageReference Include="newtonsoft.json" Version="13.0.1">
+  </ItemGroup>
+</Project>
+```
+
+And it's going to be referenced by Service Layer:
+
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <OutputType>Exe</OutputType>
+    <TargetFrameworks>net48;netstandard2.0</TargetFrameworks>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\Repository\Repository.csproj"  />
+  </ItemGroup>
+</Project>
+```
+
+Building the Service Layer will create output folders for `net7` and `net48`:
+
+```
+net48
+ |---- Repository.dll (targeted for net48)
+ |---- Domain-net48.dll
+ |---- System.Text.Json.dll
+
+net7
+ |---- Repository.dll (targeted for netstandard2.0)
+ |---- Domain-netstd20.dll
+ |---- Newtonsoft.Json.dll 
+```
+
+Should we want to reference the netstandard version of the Repository Layer in our Service Layer - we can force the reference chain via `SetTargetFramework` metadata on `ProjectReference` item:
+
+```xml
+  <ItemGroup>
+    <ProjectReference Include="..\Repository\Repository.csproj" SetTargetFramework="TargetFramework=netstandard2.0" />
+  </ItemGroup>
+```
+
+**Notes:** 
+
+`SetTargetFramework` is currently not honored by the NuGet client([nuget issue #12436](https://github.com/NuGet/Home/issues/12436)), so the output folder will contain binaries from nuget packages as if this metadata was not used. To workaround this the apropriate nuget needs to be directly referenced from the project enforcing reference framework via `SetTargetFramework`, or copied to output/publish folder via different means.
+
+
+`SetTargetFramework` will properly enforce the framework for the `ProjectReference` chain. Once the `TargetFramework` overriding is encountered it is passed down the reference chain and the `ProjectReference`s respect it during the `TargetFramework` resolution. Due to the nature of handling of [transitive references in .NET-SDK style projects](#net-sdk-projects-and-access-to-transitive-references) and the fact that NuGet client doesn't honor `SetTargetFramework`, the transitive references can get resolved and built for multiple `TargetFramework`s. This means the output folder will contain proper version of the direct dependency - Repository Layer. The transitive references might overbuild, and output folder of current project (Service Layer) might contain both versions of the transitive project dependency (Domain-net48.dll and Domain-netstd20.dll). This limitation can be workarounded by switching of the transitive project references via `DisableTransitiveProjectReferences` (same as shown in [Access to transitive project references](#access-to-transitive-project-references))
+
diff --git a/documentation/wiki/Providing-Binary-Logs.md b/documentation/wiki/Providing-Binary-Logs.md
index b9be0b3f59b..3fa12a84f6a 100644
--- a/documentation/wiki/Providing-Binary-Logs.md
+++ b/documentation/wiki/Providing-Binary-Logs.md
@@ -6,25 +6,39 @@ However, you should be aware what type of information is captured in the binary
 
 ⚠ NOTE: some build environments make secrets available using environment variables. Before sharing a binary log, make sure it does not expose API tokens or other important secrets.
 
+## Capturing Binary Logs for command-line builds
+
 You can create a binary log by passing the `-bl` parameter to MSBuild (`MSBuild.exe` or `dotnet build`). You can explore the contents of the generated .binlog file using [MSBuild Structured Log Viewer](http://msbuildlog.com/) or in your browser using [Live Structured Log Viewer](https://live.msbuildlog.com). Note: We don't capture any data from binary logs viewed on your browser.
 
+Examples:
+
+```sh
+dotnet build -bl
+dotnet build -bl:SpecificStep.binlog
+MSBuild.exe -bl:ServiceRelease.binlog -p:Configuration=Release
+```
+
 [More details about binary logs](Binary-Log.md)
 
 ## Capturing Binary Logs Through Visual Studio
-### (Preferred way) Capturing logs for all MSBuild invocations
+
+### Capturing logs for all MSBuild invocations
+
 Set `MSBUILDDEBUGENGINE` environment variable to `'1'` and (optionally) set `MSBUILDDEBUGPATH` to an existing destination folder to store the captured logs. Then start Visual Studio from the same shell to inherit the environment:
 
 `cmd:`
-```
+
+```batch
 > SET MSBUILDDEBUGENGINE=1
 > SET MSBUILDDEBUGPATH=C:\MSBuildReproLogs
 > devenv.exe MySolution.sln
 ```
 
 `PowerShell:`
-```
+
+```powershell
 > $env:MSBUILDDEBUGENGINE = 1
-> $env:MSBUILDDEBUGPATH= C:\MSBuildReproLogs
+> $env:MSBUILDDEBUGPATH="C:\MSBuildReproLogs"
 > & "devenv.exe" MySolution.sln
 ```
 
@@ -33,8 +47,10 @@ MSBuild binary logs are then captured to a location specified via `MSBUILDDEBUGP
 ⚠ NOTE: logs are being recorded for each MSBuild invocation (including design time builds) and kept in the folder without removing older ones - so the number of log files can grow quickly. It is recommended to set the opt-in environment variable only for the short duration of reproducing the issue to be investigated (though it is understandable that some nondeterministic issues might need multiple reproduction attempts)
 
 Further reading:
+
 * [More technical info](Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md#logs)
 * [Design time builds logs](https://github.com/dotnet/project-system/blob/main/docs/repo/debugging/design-time-builds.md#gathering-full-fidelity-binlogs)
 
 ### Capturing specific logs for chosen build invocations
+
 See [this guide](https://github.com/dotnet/project-system-tools) in the Project System Tools repo for capturing binlogs through Visual Studio.
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index 5a6b132e78e..e625498d4a9 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -38,9 +38,12 @@
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('NuGetSdkResolver'))' == 'True'" />
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Microsoft.Extensions.'))' == 'True'" />
 
-        <!-- NuGet.targets will be in the ResolvedRuntimeTargets ItemGroup -->
+        <!-- NuGet.targets and NuGet.RestoreEx.targets will be in the RuntimeTargetsCopyLocalItems ItemGroup -->
         <_NuGetRuntimeDependencies Include="%(RuntimeTargetsCopyLocalItems.Identity)" Condition="'@(RuntimeTargetsCopyLocalItems->Contains('NuGet.'))' == 'True'" />
 
+        <!-- NuGet.Build.Tasks.Console.exe will be in the None ItemGroup -->
+        <_NuGetRuntimeDependencies Include="%(None.Identity)" Condition="'@(None->Contains('NuGet.'))' == 'True'" />
+
         <_NuGetRuntimeDependencies Include="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\RuntimeIdentifierGraph.json" />
     </ItemGroup>
   </Target>
@@ -122,35 +125,45 @@
 
     <!-- Copy in props and targets from the machine-installed MSBuildExtensionsPath -->
     <Copy SourceFiles="@(InstalledVersionedExtensions)"
-          DestinationFiles="@(InstalledVersionedExtensions->'$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(InstalledVersionedExtensions->'$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
     <Copy SourceFiles="@(SdkResolverFiles)"
-          DestinationFiles="@(SdkResolverFiles->'$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(SdkResolverFiles->'$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <Copy SourceFiles="@(InstalledMicrosoftExtensions)"
-          DestinationFiles="@(InstalledMicrosoftExtensions->'$(BootstrapDestination)Microsoft\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(InstalledMicrosoftExtensions->'$(BootstrapDestination)Microsoft\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <Copy SourceFiles="@(InstalledSdks)"
           DestinationFiles="@(InstalledSdks -> '$(BootstrapDestination)Sdks\%(RecursiveDir)%(Filename)%(Extension)')"
-          Condition="'$(MonoBuild)' != 'true'" />
+          Condition="'$(MonoBuild)' != 'true'"
+          SkipUnchangedFiles="true" />
     <Copy SourceFiles="@(InstalledSdks)"
           DestinationFiles="@(InstalledSdks -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\Sdks\%(RecursiveDir)%(Filename)%(Extension)')"
-          Condition="'$(MonoBuild)' == 'true'" />
+          Condition="'$(MonoBuild)' == 'true'"
+          SkipUnchangedFiles="true" />
 
     <Copy SourceFiles="@(InstalledStaticAnalysisTools)"
-          DestinationFiles="@(InstalledStaticAnalysisTools -> '$(BootstrapDestination)..\Team Tools\Static Analysis Tools\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(InstalledStaticAnalysisTools -> '$(BootstrapDestination)..\Team Tools\Static Analysis Tools\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <Copy SourceFiles="@(InstalledNuGetFiles)"
-          DestinationFiles="@(InstalledNuGetFiles->'$(BootstrapDestination)Microsoft\NuGet\%(Filename)%(Extension)')" />
+          DestinationFiles="@(InstalledNuGetFiles->'$(BootstrapDestination)Microsoft\NuGet\%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <Copy Condition="'$(MonoBuild)' != 'true'"
           SourceFiles="@(_NuGetRuntimeDependencies)"
-          DestinationFolder="$(BootstrapDestination)..\Common7\IDE\CommonExtensions\Microsoft\NuGet\" />
+          DestinationFolder="$(BootstrapDestination)..\Common7\IDE\CommonExtensions\Microsoft\NuGet\"
+          SkipUnchangedFiles="true" />
     <Copy Condition="'$(MonoBuild)' == 'true'"
           SourceFiles="@(_NuGetRuntimeDependencies)"
-          DestinationFolder="$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin" />
+          DestinationFolder="$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin"
+          SkipUnchangedFiles="true" />
 
     <Copy SourceFiles="@(NuGetSdkResolverManifest)"
-          DestinationFolder="$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.Build.NuGetSdkResolver" />
+          DestinationFolder="$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.Build.NuGetSdkResolver"
+          SkipUnchangedFiles="true" />
 
     <!-- Delete shim projects, because they point where we can't follow. -->
     <!-- It would be better to just not copy these. -->
@@ -158,27 +171,36 @@
 
     <!-- Copy our binaries -->
     <Copy SourceFiles="@(FreshlyBuiltBinaries)"
-          DestinationFiles="@(FreshlyBuiltBinaries -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(FreshlyBuiltBinaries -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
+
     <Copy SourceFiles="@(RoslynBinaries)"
-          DestinationFiles="@(RoslynBinaries -> '$(BootstrapDestination)15.0\Bin\Roslyn\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(RoslynBinaries -> '$(BootstrapDestination)15.0\Bin\Roslyn\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <!-- Copy our binaries to the x64 location. -->
-     <Copy SourceFiles="@(FreshlyBuiltBinariesx64)"
-          DestinationFiles="@(FreshlyBuiltBinariesx64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')" />
+    <Copy SourceFiles="@(FreshlyBuiltBinariesx64)"
+          DestinationFiles="@(FreshlyBuiltBinariesx64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <!-- Copy our binaries to the arm64 location. -->
-     <Copy SourceFiles="@(FreshlyBuiltBinariesArm64)"
-          DestinationFiles="@(FreshlyBuiltBinariesArm64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')" />
+    <Copy SourceFiles="@(FreshlyBuiltBinariesArm64)"
+          DestinationFiles="@(FreshlyBuiltBinariesArm64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
     <!-- Copy our freshly-built props and targets, overwriting anything we copied from the machine -->
     <Copy SourceFiles="@(FreshlyBuiltRootProjects)"
-          DestinationFiles="@(FreshlyBuiltRootProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(Filename)%(Extension)')" />
+          DestinationFiles="@(FreshlyBuiltRootProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
     <Copy SourceFiles="@(FreshlyBuiltProjects)"
-          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
     <Copy SourceFiles="@(FreshlyBuiltProjects)"
-          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
     <Copy SourceFiles="@(FreshlyBuiltProjects)"
-          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')" />
+          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')"
+          SkipUnchangedFiles="true" />
 
   </Target>
 
@@ -221,6 +243,9 @@
     <Copy SourceFiles="@(_NuGetRuntimeDependencies)"
           DestinationFolder="$(BootstrapDestination)" />
 
+    <Copy SourceFiles="$(RepoRoot)src\MSBuild.Bootstrap\RedirectNuGetConsoleProcess.After.Microsoft.Common.targets"
+          DestinationFolder="$(BootstrapDestination)\Current\Microsoft.Common.targets\ImportAfter" />
+
     <!-- Disable workload resolver until we can figure out whether it can work in the bootstrap
          https://github.com/dotnet/msbuild/issues/6566 -->
     <Touch Files="$(BootstrapDestination)\DisableWorkloadResolver.sentinel" AlwaysCreate="true" />
diff --git a/eng/Packages.props b/eng/Packages.props
index 5623df27263..3b73eb59ecc 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -14,6 +14,7 @@
     <PackageVersion Include="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
     <PackageVersion Include="Microsoft.IO.Redist" Version="$(MicrosoftIORedistVersion)" />
     <PackageVersion Include="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
+    <PackageVersion Include="NuGet.Build.Tasks.Console" Version="$(NuGetBuildTasksVersion)" />
     <PackageVersion Include="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
     <PackageVersion Include="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
     <PackageVersion Include="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
diff --git a/eng/SourceBuild.props b/eng/SourceBuild.props
index 0bc1c2b8324..2bd3712f6ee 100644
--- a/eng/SourceBuild.props
+++ b/eng/SourceBuild.props
@@ -3,6 +3,7 @@
   <PropertyGroup>
     <GitHubRepositoryName>msbuild</GitHubRepositoryName>
     <SourceBuildManagedOnly>true</SourceBuildManagedOnly>
+    <SourceBuildTrimNetFrameworkTargets>true</SourceBuildTrimNetFrameworkTargets>
   </PropertyGroup>
 
   <Target Name="ConfigureInnerBuildArgs" BeforeTargets="GetSourceBuildCommandConfiguration">
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index c1b6dfbf053..559d7bc11d1 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -1,5 +1,34 @@
 <UsageData>
   <IgnorePatterns>
-    <UsagePattern IdentityGlob="*/*" />
+    <UsagePattern IdentityGlob="Microsoft.SourceBuild.Intermediate.*/*" />
+
+    <!-- These dependencies are a result of building for netframework TFMs. These are filtered out 
+         in full source-build, and would be filtered out if msbuild was using an 8.0 arcade + 8.0 SDK -->
+         <UsagePattern IdentityGlob="Microsoft.NETFramework.ReferenceAssemblies/*1.0.3*" />
+         <UsagePattern IdentityGlob="Microsoft.NETFramework.ReferenceAssemblies.net472/*1.0.3*" />
+
+    <!-- Baseline 7.0 dependencies until msbuild targets net8 and uses a net8 arcade, SBRP, etc.
+         These cannot be added to 7.0 SBRP, because they would are produced in the 7.0 build. -->
+    <UsagePattern IdentityGlob="Microsoft.Bcl.AsyncInterfaces/*7.0.0*" />
+    <UsagePattern IdentityGlob="Microsoft.Win32.SystemEvents/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.CodeDom/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Collections.Immutable/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Drawing.Common/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Formats.Asn1/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.Metadata/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Resources.Extensions/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*7.0.1*" />
+    <UsagePattern IdentityGlob="System.Security.Permissions/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Encoding.CodePages/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Encodings.Web/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*7.0.0*" />
+    <UsagePattern IdentityGlob="System.Windows.Extensions/*7.0.0*" />
+
   </IgnorePatterns>
 </UsageData>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 009a31bbea5..4cd2f88e6e7 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,40 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
+  <ProductDependencies>
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="7.0.0-alpha.1.23219.1">
+      <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
+      <Sha>525b6c35cc5c5c9b80b47044be2e4e77858d505a</Sha>
+      <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
+    </Dependency>
+  </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.23114.5">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.23221.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>0c93c1cb1ef9c9d5c1a59f4ab98c2f7e37f12197</Sha>
+      <Sha>3d9c9a4d3d893e903bb3295fd5b55b8e40699888</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.5.0-rc.149">
+    <Dependency Name="Microsoft.SourceLink.GitHub" Version="1.1.0-beta-21480-02" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+      <Uri>https://github.com/dotnet/sourcelink</Uri>
+      <Sha>8031e5220baf2acad991e661d8308b783d2acf3e</Sha>
+      <SourceBuild RepoName="sourcelink" ManagedOnly="true" />
+    </Dependency>
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.21431.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+      <Uri>https://github.com/dotnet/xliff-tasks</Uri>
+      <Sha>bc3233146e1fcd393ed471d5005333c83363e0fe</Sha>
+      <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
+    </Dependency>
+    <Dependency Name="NuGet.Build.Tasks" Version="6.7.0-preview.1.20">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>ca5029046d7b6e55f322c45abb7b342054543710</Sha>
+      <Sha>f1757fe7a9a3e178562518f4535f71348a117010</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.6.0-1.23109.10">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.6.0-2.23171.5">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>73338d92270b9f26982eca2e8872037a0214b912</Sha>
+      <Sha>48b13597fee9df5ecfbd0b8c0758b3f46bc1d440</Sha>
+      <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23114.5">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23221.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>0c93c1cb1ef9c9d5c1a59f4ab98c2f7e37f12197</Sha>
+      <Sha>3d9c9a4d3d893e903bb3295fd5b55b8e40699888</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 1b66f02385a..a0cf6b8d1b2 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,8 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.6.0</VersionPrefix>
-    <PackageValidationBaselineVersion>17.5.0-preview-23075-01</PackageValidationBaselineVersion>
+    <VersionPrefix>17.7.0</VersionPrefix>
+    <PackageValidationBaselineVersion>17.6.0-preview-23178-11</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -48,11 +48,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23114.5</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23221.7</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.6.0-1.23109.10</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.5.0-rc.149</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.6.0-2.23171.5</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.7.0-preview.1.20</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.0</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
diff --git a/eng/common/templates/job/job.yml b/eng/common/templates/job/job.yml
index 547d878da07..e5784440d0b 100644
--- a/eng/common/templates/job/job.yml
+++ b/eng/common/templates/job/job.yml
@@ -24,7 +24,7 @@ parameters:
   enablePublishBuildAssets: false
   enablePublishTestResults: false
   enablePublishUsingPipelines: false
-  disableComponentGovernance: false
+  disableComponentGovernance: ''
   mergeTestResults: false
   testRunTitle: ''
   testResultsFormat: ''
@@ -141,9 +141,13 @@ jobs:
         richNavLogOutputDirectory: $(Build.SourcesDirectory)/artifacts/bin
       continueOnError: true
 
-  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), ne(parameters.disableComponentGovernance, 'true')) }}:
-      - task: ComponentGovernanceComponentDetection@0
-        continueOnError: true
+  - template: /eng/common/templates/steps/component-governance.yml
+    parameters:
+      ${{ if eq(parameters.disableComponentGovernance, '') }}:
+        ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), eq(parameters.runAsPublic, 'false'), or(contains(variables['Build.SourceBranch'], 'internal/release'), eq(variables['Build.SourceBranch'], 'main'))) }}:
+          disableComponentGovernance: false
+        ${{ else }}:
+          disableComponentGovernance: true
 
   - ${{ if eq(parameters.enableMicrobuild, 'true') }}:
     - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
diff --git a/eng/common/templates/steps/component-governance.yml b/eng/common/templates/steps/component-governance.yml
new file mode 100644
index 00000000000..babc2757d8d
--- /dev/null
+++ b/eng/common/templates/steps/component-governance.yml
@@ -0,0 +1,10 @@
+parameters:
+  disableComponentGovernance: false
+
+steps:
+- ${{ if eq(parameters.disableComponentGovernance, 'true') }}:
+  - script: "echo ##vso[task.setvariable variable=skipComponentGovernanceDetection]true"
+    displayName: Set skipComponentGovernanceDetection variable
+- ${{ if ne(parameters.disableComponentGovernance, 'true') }}:
+  - task: ComponentGovernanceComponentDetection@0
+    continueOnError: true
\ No newline at end of file
diff --git a/eng/sdl-tsa-vars.config b/eng/sdl-tsa-vars.config
new file mode 100644
index 00000000000..a6303401812
--- /dev/null
+++ b/eng/sdl-tsa-vars.config
@@ -0,0 +1,11 @@
+-SourceToolsList @("policheck","credscan")
+-TsaInstanceURL https://devdiv.visualstudio.com/
+-TsaProjectName DEVDIV
+-TsaNotificationEmail dotnetdevexcli@microsoft.com
+-TsaCodebaseAdmin REDMOND\marcpop
+-TsaBugAreaPath "DevDiv\NET Tools\MSBuild"
+-TsaIterationPath DevDiv
+-TsaRepositoryName DotNet-msbuild-Trusted
+-TsaCodebaseName DotNet-msbuild-Trusted
+-TsaOnboard $True
+-TsaPublish $True
diff --git a/global.json b/global.json
index 6db16c7387f..26528f8957e 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "7.0.200",
+    "dotnet": "7.0.203",
     "vs": {
       "version": "17.4.1"
     },
     "xcopy-msbuild": "17.4.1"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23114.5"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23221.7"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
index ac62b8e21d7..721a4521fdc 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
@@ -82,6 +82,30 @@ public void ReadNoChildren(string project)
             Assert.Equal(0, Helpers.Count(item.Metadata));
         }
 
+        [Fact]
+        public void ReadMetadataLocationPreserved()
+        {
+            string project = """
+                <Project>
+                    <Target Name='t'>
+                        <ItemGroup>
+                            <i Include='i' MetadataA='123' MetadataB='xyz' />
+                        </ItemGroup>
+                    </Target>
+                </Project>
+                """;
+
+            ProjectItemElement item = GetItemFromContent(project);
+            Assert.Equal(2, item.Metadata.Count);
+            ProjectMetadataElement metadatum1 = item.Metadata.First();
+            ProjectMetadataElement metadatum2 = item.Metadata.Skip(1).First();
+
+            Assert.Equal(4, metadatum1.Location.Line);
+            Assert.Equal(4, metadatum2.Location.Line);
+            Assert.Equal(27, metadatum1.Location.Column);
+            Assert.Equal(43, metadatum2.Location.Column);
+        }
+
         /// <summary>
         /// Read item with no include
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 14c83442af4..1dcc2fb9fc2 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -35,9 +35,6 @@
     <Compile Include="..\Shared\EncodingStringWriter.cs">
       <Link>EncodingStringWriter.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\EncodingUtilities.cs">
-      <Link>EncodingUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index 4eb2b6a1307..9b0a1eae9bb 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -772,6 +771,121 @@ public void ItemsIncludeExcludePathsCombinations()
             }
         }
 
+        /// <summary>
+        /// Referring to an item outside of target leads to 'naturally expected' reference to the item being processed.
+        ///  No expansion occurs.
+        /// </summary>
+        [Fact]
+        public void ItemsRecursionOutsideTarget()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string projectContent = """
+                    <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+                     <ItemGroup>
+                        <iout1 Include='a/b.foo' TargetPath='%(Filename)%(Extension)' />
+                        <iout1 Include='c/d.foo' TargetPath='%(Filename)%(Extension)' />
+                        <iout1 Include='g/h.foo' TargetPath='%(Filename)%(Extension)' />
+                      </ItemGroup>
+                      <Target Name='a'>
+                        <Message Text="iout1=[@(iout1)]" Importance='High' />
+                        <Message Text="iout1-target-paths=[@(iout1->'%(TargetPath)')]" Importance='High' />
+                      </Target>
+                    </Project>
+                """;
+            var projectFile = env.CreateFile("test.proj", ObjectModelHelpers.CleanupFileContents(projectContent));
+
+            MockLogger logger = new MockLogger(_testOutput);
+            ObjectModelHelpers.BuildTempProjectFileExpectSuccess(projectFile.Path, logger);
+
+            _testOutput.WriteLine(logger.FullLog);
+
+            logger.AssertLogContains("iout1=[a/b.foo;c/d.foo;g/h.foo]");
+            logger.AssertLogContains("iout1-target-paths=[b.foo;d.foo;h.foo]");
+        }
+
+        /// <summary>
+        /// Referring to an item within target leads to item expansion which might be unintended behavior - hence warning.
+        /// </summary>
+        [Fact]
+        public void ItemsRecursionWithinTarget()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string projectContent = """
+                    <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+                      <Target Name='a'>
+                        <ItemGroup>
+                          <iin1 Include='a/b.foo' TargetPath='%(Filename)%(Extension)' />
+                          <iin1 Include='c/d.foo' TargetPath='%(Filename)%(Extension)' />
+                          <iin1 Include='g/h.foo' TargetPath='%(Filename)%(Extension)' />
+                        </ItemGroup>
+                        <Message Text="iin1=[@(iin1)]" Importance='High' />
+                        <Message Text="iin1-target-paths=[@(iin1->'%(TargetPath)')]" Importance='High' />
+                      </Target>
+                    </Project>
+                """;
+            string projFileName = "test.proj";
+            var projectFile = env.CreateFile(projFileName, ObjectModelHelpers.CleanupFileContents(projectContent));
+
+            MockLogger logger = new MockLogger(_testOutput);
+            ObjectModelHelpers.BuildTempProjectFileExpectSuccess(projectFile.Path, logger);
+
+            _testOutput.WriteLine(logger.FullLog);
+
+            logger.AssertLogDoesntContain("iin1=[a/b.foo;c/d.foo;g/h.foo]");
+            logger.AssertLogDoesntContain("iin1-target-paths=[b.foo;d.foo;h.foo]");
+            logger.AssertLogContains("iin1=[a/b.foo;c/d.foo;g/h.foo;g/h.foo]");
+            logger.AssertLogContains("iin1-target-paths=[;b.foo;b.foo;d.foo]");
+
+            logger.AssertLogContains(string.Format(ResourceUtilities.GetResourceString("ItemReferencingSelfInTarget"), "iin1", "Filename"));
+            logger.AssertLogContains(string.Format(ResourceUtilities.GetResourceString("ItemReferencingSelfInTarget"), "iin1", "Extension"));
+            logger.AssertMessageCount("MSB4120", 6);
+            // The location of the offending attribute (TargetPath) is transferred - for both metadatums (%(Filename) and %(Extension)) on correct locations in xml
+            logger.AssertMessageCount($"{projFileName}(4,34):", 2, false);
+            logger.AssertMessageCount($"{projFileName}(5,34):", 2, false);
+            logger.AssertMessageCount($"{projFileName}(6,34):", 2, false);
+            Assert.Equal(0, logger.WarningCount);
+            Assert.Equal(0, logger.ErrorCount);
+        }
+
+        /// <summary>
+        /// Referring to an unrelated item within target leads to expected expansion.
+        /// </summary>
+        [Fact]
+        public void UnrelatedItemsRecursionWithinTarget()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string projectContent = """
+                    <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+                      <ItemGroup>
+                        <iout1 Include='a/b.foo'/>
+                        <iout1 Include='c/d.foo'/>
+                        <iout1 Include='g/h.foo'/>
+                      </ItemGroup>
+
+                      <Target Name='a'>
+                        <ItemGroup>
+                          <iin1 Include='@(iout1)' TargetPath='%(Filename)%(Extension)' />
+                        </ItemGroup>
+                        <Message Text="iin1=[@(iin1)]" Importance='High' />
+                        <Message Text="iin1-target-paths=[@(iin1->'%(TargetPath)')]" Importance='High' />
+                      </Target>
+                    </Project>
+                """;
+            var projectFile = env.CreateFile("test.proj", ObjectModelHelpers.CleanupFileContents(projectContent));
+
+            MockLogger logger = new MockLogger(_testOutput);
+            ObjectModelHelpers.BuildTempProjectFileExpectSuccess(projectFile.Path, logger);
+
+            _testOutput.WriteLine(logger.FullLog);
+
+            logger.AssertLogContains("iin1=[a/b.foo;c/d.foo;g/h.foo]");
+            logger.AssertLogContains("iin1-target-paths=[b.foo;d.foo;h.foo]");
+
+            logger.AssertLogDoesntContain("MSB4120");
+            Assert.Equal(0, logger.WarningCount);
+            Assert.Equal(0, logger.ErrorCount);
+        }
+
         /// <summary>
         /// Check if passing different global properties via metadata works
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index 30eafec7e91..5644861dbc9 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -236,6 +236,41 @@ Skipping target ""Build"" because all output files are up-to-date with respect t
             }
         }
 
+        [Fact]
+        public void TestErrorForSkippedTargetInputsAndOutputs()
+        {
+            string projectContents = @"
+<Project>
+  <Target Name=""Build"" Inputs=""a.txt;b.txt"" Outputs=""c.txt"">
+    <Message Text=""test"" Importance=""High"" />
+  </Target>
+</Project>";
+
+            using (var env = TestEnvironment.Create())
+            {
+                var buildParameters = new BuildParameters()
+                {
+                    Question = true,
+                };
+
+                using (var buildSession = new Helpers.BuildManagerSession(env, buildParameters))
+                {
+                    var files = env.CreateTestProjectWithFiles(projectContents, new[] { "a.txt", "b.txt", "c.txt" });
+                    var fileA = new FileInfo(files.CreatedFiles[0]);
+                    var fileB = new FileInfo(files.CreatedFiles[1]);
+                    var fileC = new FileInfo(files.CreatedFiles[2]);
+
+                    var now = DateTime.UtcNow;
+                    fileA.LastWriteTimeUtc = now - TimeSpan.FromSeconds(10);
+                    fileB.LastWriteTimeUtc = now + TimeSpan.FromSeconds(10);
+                    fileC.LastWriteTimeUtc = now;
+
+                    var result = buildSession.BuildProjectFile(files.ProjectFile);
+                    result.OverallResult.ShouldBe(BuildResultCode.Failure);
+                }
+            }
+        }
+
         /// <summary>
         /// Ensure that skipped targets only infer outputs once
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 42a4d6545d3..065958278e0 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -572,7 +572,7 @@ private DependencyAnalysisResult PerformDependencyAnalysisTestHelper(
                 ItemBucket itemBucket = new ItemBucket(null, null, new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), 0);
                 TargetUpToDateChecker analyzer = new TargetUpToDateChecker(p, p.Targets["Build"], _mockHost, BuildEventContext.Invalid);
 
-                return analyzer.PerformDependencyAnalysis(itemBucket, out changedTargetInputs, out upToDateTargetInputs);
+                return analyzer.PerformDependencyAnalysis(itemBucket, false, out changedTargetInputs, out upToDateTargetInputs);
             }
             finally
             {
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 6f66f263d26..1e6b56edd0e 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -16,6 +16,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -84,6 +85,32 @@ public void TasksAreDiscoveredWhenTaskConditionTrue()
             logger.AssertLogDoesntContain("Made it");
         }
 
+        [Fact]
+        public void TasksOnlyLogStartedEventOnceEach()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string projectFileContents = ObjectModelHelpers.CleanupFileContents(
+            @"<Project>
+              <Target Name='t'>
+                  <Message Text='Made it'/>
+              </Target>
+            </Project>");
+
+            TransientTestFile projectFile = env.CreateFile("myProj.proj", projectFileContents);
+            env.SetEnvironmentVariable("DOTNET_PERFLOG_DIR", @"C:\Users\namytelk\Desktop");
+
+            string results = RunnerUtilities.ExecMSBuild(projectFile.Path + " /v:diag", out bool success);
+
+            int count = 0;
+            for (int index = results.IndexOf("Task \"Message\""); index >= 0; index = results.IndexOf("Task \"Message\"", index))
+            {
+                count++;
+                index += 14; // Skip to the end of this string
+            }
+
+            count.ShouldBe(1);
+        }
+
         /// <summary>
         /// Tests that when the task condition is false, Execute still returns true even though we never loaded
         /// the task.  We verify that we never loaded the task because if we did try, the task load itself would
@@ -137,7 +164,6 @@ public void CanceledTasksDoNotLogMSB4181()
                     Loggers = new ILogger[] { logger },
                     EnableNodeReuse = false
                 };
-                ;
 
                 BuildRequestData data = new BuildRequestData(project.CreateProjectInstance(), new string[] { "test" }, collection.HostServices);
                 manager.BeginBuild(_parameters);
@@ -570,6 +596,31 @@ public void NullMetadataOnLegacyOutputItems()
             logger.AssertLogContains("[foo: ]");
         }
 
+        /// <summary>
+        /// If an item returned from a task has bare-minimum metadata implementation, we shouldn't crash.
+        /// </summary>
+        [Fact]
+        public void MinimalLegacyOutputItems()
+        {
+            string customTaskPath = Assembly.GetExecutingAssembly().Location;
+
+            string projectContents = $"""
+                                     <Project>
+                                       <UsingTask TaskName="TaskThatReturnsMinimalItem" AssemblyFile="{customTaskPath}" />
+
+                                       <Target Name="Build">
+                                         <TaskThatReturnsMinimalItem>
+                                           <Output TaskParameter="MinimalTaskItemOutput" ItemName="Outputs"/>
+                                         </TaskThatReturnsMinimalItem>
+
+                                         <Message Text="[%(Outputs.Identity): %(Outputs.a)]" Importance="High" />
+                                       </Target>
+                                     </Project>
+                                     """;
+
+            MockLogger logger = ObjectModelHelpers.BuildProjectExpectSuccess(projectContents, _testOutput, LoggerVerbosity.Diagnostic);
+        }
+
         /// <summary>
         /// Regression test for https://github.com/dotnet/msbuild/issues/5080
         /// </summary>
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 10e697437e2..e16f3578b22 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -262,7 +262,8 @@ public void BinaryLoggerShouldEmbedFilesViaTaskOutput()
 
             // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
             // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
         }
 
         [RequiresSymbolicLinksFact]
@@ -321,10 +322,14 @@ public void BinaryLoggerShouldEmbedSymlinkFilesViaTaskOutput()
 
             // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
             // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkName));
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkLvl2Name));
-            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(emptyFileName));
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkName),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkLvl2Name),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(emptyFileName),
+                () => $"Embedded files: {string.Join(",", zipArchive.Entries)}");
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Definition/Project_Internal_Tests.cs b/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
index c08c92c9134..0e9ea26e3c7 100644
--- a/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
+++ b/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
@@ -5,7 +5,10 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Xml;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
@@ -254,5 +257,92 @@ public void ProjectEvaluationShouldRespectConditionsIfProjectLoadSettingsSaysSo(
                 });
             }
         }
+
+        /// <summary>
+        /// Verifies that when calling <see cref="Project.FromFile(string, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectFromFileInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                Project project = Project.FromFile(
+                    projectRootElement.FullPath,
+                    new ProjectOptions
+                    {
+                        Interactive = interactive,
+                        ProjectCollection = projectCollection,
+                    });
+
+                project.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+            }
+        }
+
+        /// <summary>
+        /// Verifies that when calling <see cref="Project.FromProjectRootElement(ProjectRootElement, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectFromProjectRootElementInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                Project project = Project.FromProjectRootElement(
+                    projectRootElement,
+                    new ProjectOptions
+                    {
+                        Interactive = interactive,
+                        ProjectCollection = projectCollection,
+                    });
+
+                project.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+            }
+        }
+
+        /// <summary>
+        /// Verifies that when calling <see cref="Project.FromXmlReader(XmlReader, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectFromXmlReaderInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                using (XmlReader xmlReader = XmlReader.Create(projectRootElement.FullPath))
+                {
+                    Project project = Project.FromXmlReader(
+                        xmlReader,
+                        new ProjectOptions
+                        {
+                            Interactive = interactive,
+                            ProjectCollection = projectCollection,
+                        });
+
+                    project.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+                }
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index d93e4342dc0..b55b0dec344 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -222,6 +222,18 @@ public void ExpandItemVectorFunctionsAnyHaveMetadataValue()
             Assert.Equal("false", itemsFalse[0].EvaluatedInclude);
         }
 
+        [Fact]
+        public void ExpandEmptyItemVectorFunctionWithAnyHaveMetadataValue()
+        {
+            ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = CreateItemFunctionExpander();
+            ProjectItemInstanceFactory itemFactory = new ProjectItemInstanceFactory(project, "i");
+
+            IList<ProjectItemInstance> itemsEmpty = expander.ExpandIntoItemsLeaveEscaped("@(unsetItem->AnyHaveMetadataValue('Metadatum', 'value'))", itemFactory, ExpanderOptions.ExpandItems, MockElementLocation.Instance);
+            ProjectItemInstance pii = itemsEmpty.ShouldHaveSingleItem<ProjectItemInstance>();
+            pii.EvaluatedInclude.ShouldBe("false");
+        }
+
         /// <summary>
         /// Expand an item vector function Metadata()->DirectoryName()->Distinct()
         /// </summary>
@@ -3388,22 +3400,25 @@ public void PropertyFunctionStaticMethodIntrinsicMaths()
 
             double expectedResult = 9223372036854775807D + 20D;
             Assert.Equal(expectedResult.ToString(), result);
+        }
 
-            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseOr(40, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
-
-            Assert.Equal((40 | 2).ToString(), result);
-
-            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseAnd(42, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
-
-            Assert.Equal((42 & 2).ToString(), result);
-
-            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseXor(213, 255))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
-
-            Assert.Equal((213 ^ 255).ToString(), result);
+        /// <summary>
+        /// Expand intrinsic property functions that call a bit operator
+        /// </summary>
+        [Fact]
+        public void PropertyFunctionStaticMethodIntrinsicBitOperations()
+        {
+            PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
 
-            result = expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseNot(-43))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
 
-            Assert.Equal((~-43).ToString(), result);
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseOr(40, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((40 | 2).ToString());
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseAnd(42, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((42 & 2).ToString());
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseXor(213, 255))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((213 ^ 255).ToString());
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::BitwiseNot(-43))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((~-43).ToString());
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::LeftShift(1, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((1 << 2).ToString());
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::RightShift(-8, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((-8 >> 2).ToString());
+            expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::RightShiftUnsigned(-8, 2))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance).ShouldBe((-8 >>> 2).ToString());
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
index fdce69b8b3b..845b0c556c8 100644
--- a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
@@ -34,6 +34,33 @@ namespace Microsoft.Build.Graph.UnitTests
     public class ProjectGraphSetPlatformTests
     {
 
+        [Fact]
+        public void ValidateGlobalPropertyCopyByValueNotReference()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" />
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                            <Platforms>AnyCPU</Platforms>
+                                                        </PropertyGroup>
+                                                    </Project>");
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 1).ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+            }
+        }
+
         [Fact]
         public void ValidateSetPlatformOverride()
         {
@@ -75,6 +102,48 @@ public void ValidateSetPlatformOverride()
             }
         }
 
+        [Fact]
+        public void ValidateNegotiationOverride()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" >
+                                                                                                    <OverridePlatformNegotiationValue>x86</OverridePlatformNegotiationValue>
+                                                                                                </ProjectReference>
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                            <Platforms>x64;AnyCPU</Platforms>
+                                                            <Platform>x86</Platform>
+                                                        </PropertyGroup>
+                                                        <ItemGroup>
+                                                            <ProjectReference Include=""$(MSBuildThisFileDirectory)3.proj"" >
+                                                            </ProjectReference>
+                                                        </ItemGroup>
+                                                    </Project>");
+                var proj3 = env.CreateFile("3.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <Platforms>AnyCPU;x86</Platforms>
+                                                        </PropertyGroup>
+                                                    </Project>");
+
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+            }
+        }
+
         [Fact]
         public void ResolvesMultipleReferencesToSameProject()
         {
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 3bc916aa4bb..5033b018ce7 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.Linq;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Exceptions;
@@ -523,6 +524,20 @@ public void SolutionsCanInjectEdgesIntoTheProjectGraph(Dictionary<int, int[]> ed
 
             var graphFromSolutionEdges = graphFromSolution.TestOnly_Edges.TestOnly_AsConfigurationMetadata();
 
+            // Solutions add the CurrentSolutionConfigurationContents global property for platform resolution
+            foreach ((ConfigurationMetadata, ConfigurationMetadata) graphFromSolutionEdge in graphFromSolutionEdges.Keys)
+            {
+                graphFromSolutionEdge.Item1.GlobalProperties.ShouldContainKey("CurrentSolutionConfigurationContents");
+                graphFromSolutionEdge.Item2.GlobalProperties.ShouldContainKey("CurrentSolutionConfigurationContents");
+            }
+
+            // Remove CurrentSolutionConfigurationContents for comparison purposes. This is done as a separate pass since some edges may be sharing an instance.
+            foreach ((ConfigurationMetadata, ConfigurationMetadata) graphFromSolutionEdge in graphFromSolutionEdges.Keys)
+            {
+                graphFromSolutionEdge.Item1.GlobalProperties.Remove("CurrentSolutionConfigurationContents");
+                graphFromSolutionEdge.Item2.GlobalProperties.Remove("CurrentSolutionConfigurationContents");
+            }
+
             // Original edges get preserved.
             foreach (var graphEdge in graphEdges)
             {
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index d07f8cc81fc..57cc996a27c 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
@@ -674,6 +675,130 @@ public void ConstructGraphWithDifferentEntryPointsAndGraphRoots()
             }
         }
 
+        [Fact]
+        public void ConstructGraphWithSolution()
+        {
+            // This test exercises two key features of solution-based builds from AssignProjectConfiguration:
+            // 1. Adding synthetic project references
+            // 2. Resolving project configuration based on the sln
+            using (var env = TestEnvironment.Create())
+            {
+                const string SolutionFileContents = """
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 17
+                    VisualStudioVersion = 17.0.31903.59
+                    MinimumVisualStudioVersion = 17.0.31903.59
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project1", "Project1.csproj", "{8761499A-7280-43C4-A32F-7F41C47CA6DF}"
+                        ProjectSection(ProjectDependencies) = postProject
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98} = {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}
+                        EndProjectSection
+                    EndProject
+                    Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Project2", "Project2.vcxproj", "{D638A8EF-3A48-45F2-913C-88B29FED03CB}"
+                    EndProject
+                    Project("{13B669BE-BB05-4DDF-9536-439F39A36129}") = "Project3", "Project3.vcxproj", "{52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|Win32 = Debug|Win32
+                            Debug|x64 = Debug|x64
+                            Debug|x86 = Debug|x86
+                            Release|Win32 = Release|Win32
+                            Release|x64 = Release|x64
+                            Release|x86 = Release|x86
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|Win32.ActiveCfg = Debug|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|Win32.Build.0 = Debug|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.ActiveCfg = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.Build.0 = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x86.ActiveCfg = Debug|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x86.Build.0 = Debug|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|Win32.ActiveCfg = Release|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|Win32.Build.0 = Release|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.ActiveCfg = Release|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.Build.0 = Release|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x86.ActiveCfg = Release|x86
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x86.Build.0 = Release|x86
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Debug|Win32.ActiveCfg = Debug|Win32
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Debug|Win32.Build.0 = Debug|Win32
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Debug|x64.ActiveCfg = Debug|x64
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Debug|x64.Build.0 = Debug|x64
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Release|Win32.ActiveCfg = Release|Win32
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Release|Win32.Build.0 = Release|Win32
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Release|x64.ActiveCfg = Release|x64
+                            {D638A8EF-3A48-45F2-913C-88B29FED03CB}.Release|x64.Build.0 = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|Win32.ActiveCfg = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|Win32.Build.0 = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x64.ActiveCfg = Debug|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x64.Build.0 = Debug|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x86.ActiveCfg = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x86.Build.0 = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|Win32.ActiveCfg = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|Win32.Build.0 = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.ActiveCfg = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.Build.0 = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.ActiveCfg = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.Build.0 = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|Win32.ActiveCfg = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|Win32.Build.0 = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x64.ActiveCfg = Debug|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x64.Build.0 = Debug|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x86.ActiveCfg = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Debug|x86.Build.0 = Debug|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|Win32.ActiveCfg = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|Win32.Build.0 = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.ActiveCfg = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x64.Build.0 = Release|x64
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.ActiveCfg = Release|Win32
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}.Release|x86.Build.0 = Release|Win32
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                    EndGlobal
+                    """;
+                TransientTestFile slnFile = env.CreateFile(@"Solution.sln", SolutionFileContents);
+                SolutionFile solutionFile = SolutionFile.Parse(slnFile.Path);
+
+                ProjectRootElement project1Xml = ProjectRootElement.Create();
+
+                // Project 1 depends on Project 2 using ProjectReference but there is a sln-based dependency defined on Project 3 as well.
+                project1Xml.AddItem("ProjectReference", "Project2.vcxproj");
+
+                ProjectRootElement project2Xml = ProjectRootElement.Create();
+                ProjectRootElement project3Xml = ProjectRootElement.Create();
+
+                string project1Path = Path.Combine(env.DefaultTestDirectory.Path, "Project1.csproj");
+                string project2Path = Path.Combine(env.DefaultTestDirectory.Path, "Project2.vcxproj");
+                string project3Path = Path.Combine(env.DefaultTestDirectory.Path, "Project3.vcxproj");
+
+                project1Xml.Save(project1Path);
+                project2Xml.Save(project2Path);
+                project3Xml.Save(project3Path);
+
+                var projectGraph = new ProjectGraph(slnFile.Path);
+                projectGraph.EntryPointNodes.Count.ShouldBe(3);
+                projectGraph.GraphRoots.Count.ShouldBe(1);
+                projectGraph.GraphRoots.First().ProjectInstance.FullPath.ShouldBe(project1Path);
+                projectGraph.ProjectNodes.Count.ShouldBe(3);
+
+                ProjectGraphNode project1Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project1Path);
+                project1Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project1Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                project1Node.ProjectReferences.Count.ShouldBe(2);
+
+                ProjectGraphNode project2Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project2Path);
+                project2Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project2Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
+                project2Node.ProjectReferences.Count.ShouldBe(0);
+
+                ProjectGraphNode project3Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project3Path);
+                project3Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project3Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
+                project3Node.ProjectReferences.Count.ShouldBe(0);
+            }
+        }
+
         [Fact]
         public void GetTargetListsAggregatesFromMultipleEdges()
         {
@@ -2508,6 +2633,71 @@ public void MultipleProjectReferencesSameFileDifferentTargets()
             targetLists[project2].ShouldBe(new[] { "SomeDefaultTarget2", "SomeOtherTarget" });
         }
 
+        [Fact]
+        public void MultitargettingTargetsWithBuildProjectReferencesFalse()
+        {
+            // This test should emulate Microsoft.Managed.After.targets's handling of multitargetting projects.
+            ProjectGraph graph = Helpers.CreateProjectGraph(
+                env: _env,
+                dependencyEdges: new Dictionary<int, int[]>()
+                {
+                    { 1, new[] { 2 } },
+                },
+                globalProperties: new Dictionary<string, string> { { "BuildProjectReferences", "false" } },
+                extraContentForAllNodes: """
+                <PropertyGroup>
+                  <TargetFrameworks>netcoreapp3.1;net6.0;net7.0</TargetFrameworks>
+                </PropertyGroup>
+
+                <PropertyGroup Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''">
+                  <IsCrossTargetingBuild>true</IsCrossTargetingBuild>
+                </PropertyGroup>
+
+                <PropertyGroup>
+                  <InnerBuildProperty>TargetFramework</InnerBuildProperty>
+                  <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>
+                </PropertyGroup>
+
+                <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' != 'true'">
+                  <_MainReferenceTargetForBuild Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>
+                  <_MainReferenceTargetForBuild Condition="'$(_MainReferenceTargetForBuild)' == ''">GetTargetPath</_MainReferenceTargetForBuild>
+
+                  <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+                </PropertyGroup>
+                <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' == 'true'">
+                  <ProjectReferenceTargetsForBuild>.default;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+                </PropertyGroup>
+
+                <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
+                  <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
+                  <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
+
+                  <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
+                </ItemGroup>
+
+                <Target Name="Build" />
+                <Target Name="GetTargetPath" />
+                <Target Name="GetNativeManifest" />
+                <Target Name="GetTargetFrameworks" />
+                <Target Name="GetTargetFrameworksWithPlatformForSingleTargetFramework" />
+                """);
+
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = graph.GetTargetLists(Array.Empty<string>());
+
+            targetLists[GetOuterBuild(graph, 1)].ShouldBe(new[] { "Build" });
+            foreach (ProjectGraphNode inner in GetInnerBuilds(graph, 1))
+            {
+                targetLists[inner].ShouldBe(new[] { "Build" });
+            }
+
+            targetLists[GetOuterBuild(graph, 2)].ShouldBe(new[] { "GetTargetFrameworks" });
+            foreach (ProjectGraphNode inner in GetInnerBuilds(graph, 2))
+            {
+                // GetTargetFrameworks actually shouldn't be here...
+                targetLists[inner].ShouldBe(new[] { "GetTargetFrameworks", "GetTargetPath", "GetNativeManifest", "GetTargetFrameworksWithPlatformForSingleTargetFramework" });
+            }
+        }
+
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
index 546c42c9432..9cbb3ea8b5f 100644
--- a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
 using Shouldly;
@@ -68,11 +69,11 @@ public void GetTaskRegistrations()
 
                 ProjectInstance project = new Project(ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)))).CreateProjectInstance();
 
-                Assert.Equal(3, project.TaskRegistry.TaskRegistrations.Count);
-                Assert.Equal(Path.Combine(Directory.GetCurrentDirectory(), "af0"), project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t0", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile);
-                Assert.Equal(Path.Combine(Directory.GetCurrentDirectory(), "af1a"), project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile);
-                Assert.Equal("an1", project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][1].TaskFactoryAssemblyLoadInfo.AssemblyName);
-                Assert.Equal("an2", project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t2", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyName);
+                project.TaskRegistry.TaskRegistrations.Count.ShouldBe(3);
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t0", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), "af0"));
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), "af1a"));
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][1].TaskFactoryAssemblyLoadInfo.AssemblyName.ShouldBe("an1");
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t2", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyName.ShouldBe("an2");
             }
             finally
             {
@@ -115,8 +116,8 @@ public void InitialTargetsDefaultTargets()
 
                 ProjectInstance project = new Project(ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)))).CreateProjectInstance();
 
-                Helpers.AssertListsValueEqual(new string[] { "d0a", "d0b" }, project.DefaultTargets);
-                Helpers.AssertListsValueEqual(new string[] { "i0a", "i0b", "i1a", "i1b", "i3a", "i3b", "i2a", "i2b" }, project.InitialTargets);
+                project.DefaultTargets.ShouldBe(new string[] { "d0a", "d0b" });
+                project.InitialTargets.ShouldBe(new string[] { "i0a", "i0b", "i1a", "i1b", "i3a", "i3b", "i2a", "i2b" });
             }
             finally
             {
@@ -140,8 +141,8 @@ public void InitialTargetsDefaultTargetsEscaped()
 
                 ProjectInstance project = new Project(ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)))).CreateProjectInstance();
 
-                Helpers.AssertListsValueEqual(new string[] { "d0a;d0b" }, project.DefaultTargets);
-                Helpers.AssertListsValueEqual(new string[] { "i0a;i0b" }, project.InitialTargets);
+                project.DefaultTargets.ShouldBe(new string[] { "d0a;d0b" });
+                project.InitialTargets.ShouldBe(new string[] { "i0a;i0b" });
             }
             finally
             {
@@ -169,16 +170,16 @@ public void GetPropertyGroupUnderTarget()
             ProjectInstance p = GetProjectInstance(content);
             ProjectPropertyGroupTaskInstance propertyGroup = (ProjectPropertyGroupTaskInstance)(p.Targets["t"].Children[0]);
 
-            Assert.Equal("c1", propertyGroup.Condition);
+            propertyGroup.Condition.ShouldBe("c1");
 
             List<ProjectPropertyGroupTaskPropertyInstance> properties = Helpers.MakeList(propertyGroup.Properties);
-            Assert.Equal(2, properties.Count);
+            properties.Count.ShouldBe(2);
 
-            Assert.Equal("c2", properties[0].Condition);
-            Assert.Equal("v1", properties[0].Value);
+            properties[0].Condition.ShouldBe("c2");
+            properties[0].Value.ShouldBe("v1");
 
-            Assert.Equal(String.Empty, properties[1].Condition);
-            Assert.Equal(String.Empty, properties[1].Value);
+            properties[1].Condition.ShouldBe(String.Empty);
+            properties[1].Value.ShouldBe(String.Empty);
         }
 
         /// <summary>
@@ -207,41 +208,41 @@ public void GetItemGroupUnderTarget()
             ProjectInstance p = GetProjectInstance(content);
             ProjectItemGroupTaskInstance itemGroup = (ProjectItemGroupTaskInstance)(p.Targets["t"].Children[0]);
 
-            Assert.Equal("c1", itemGroup.Condition);
+            itemGroup.Condition.ShouldBe("c1");
 
             List<ProjectItemGroupTaskItemInstance> items = Helpers.MakeList(itemGroup.Items);
-            Assert.Equal(3, items.Count);
+            items.Count.ShouldBe(3);
 
-            Assert.Equal("i1", items[0].Include);
-            Assert.Equal("e1", items[0].Exclude);
-            Assert.Equal(String.Empty, items[0].Remove);
-            Assert.Equal("c2", items[0].Condition);
+            items[0].Include.ShouldBe("i1");
+            items[0].Exclude.ShouldBe("e1");
+            items[0].Remove.ShouldBe(String.Empty);
+            items[0].Condition.ShouldBe("c2");
 
-            Assert.Equal(String.Empty, items[1].Include);
-            Assert.Equal(String.Empty, items[1].Exclude);
-            Assert.Equal("r1", items[1].Remove);
-            Assert.Equal(String.Empty, items[1].Condition);
+            items[1].Include.ShouldBe(String.Empty);
+            items[1].Exclude.ShouldBe(String.Empty);
+            items[1].Remove.ShouldBe("r1");
+            items[1].Condition.ShouldBe(String.Empty);
 
-            Assert.Equal(String.Empty, items[2].Include);
-            Assert.Equal(String.Empty, items[2].Exclude);
-            Assert.Equal(String.Empty, items[2].Remove);
-            Assert.Equal(String.Empty, items[2].Condition);
+            items[2].Include.ShouldBe(String.Empty);
+            items[2].Exclude.ShouldBe(String.Empty);
+            items[2].Remove.ShouldBe(String.Empty);
+            items[2].Condition.ShouldBe(String.Empty);
 
             List<ProjectItemGroupTaskMetadataInstance> metadata1 = Helpers.MakeList(items[0].Metadata);
             List<ProjectItemGroupTaskMetadataInstance> metadata2 = Helpers.MakeList(items[1].Metadata);
             List<ProjectItemGroupTaskMetadataInstance> metadata3 = Helpers.MakeList(items[2].Metadata);
 
-            Assert.Equal(2, metadata1.Count);
-            Assert.Empty(metadata2);
-            Assert.Single(metadata3);
+            metadata1.Count.ShouldBe(2);
+            metadata2.ShouldBeEmpty();
+            metadata3.ShouldHaveSingleItem();
 
-            Assert.Equal("c3", metadata1[0].Condition);
-            Assert.Equal("m1", metadata1[0].Value);
-            Assert.Equal(String.Empty, metadata1[1].Condition);
-            Assert.Equal("n1", metadata1[1].Value);
+            metadata1[0].Condition.ShouldBe("c3");
+            metadata1[0].Value.ShouldBe("m1");
+            metadata1[1].Condition.ShouldBe(String.Empty);
+            metadata1[1].Value.ShouldBe("n1");
 
-            Assert.Equal(String.Empty, metadata3[0].Condition);
-            Assert.Equal("o1", metadata3[0].Value);
+            metadata3[0].Condition.ShouldBe(String.Empty);
+            metadata3[0].Value.ShouldBe("o1");
         }
 
         /// <summary>
@@ -252,7 +253,7 @@ public void GetTaskRegistry()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Assert.True(p.TaskRegistry != null);
+            p.TaskRegistry.ShouldNotBeNull();
         }
 
         /// <summary>
@@ -263,8 +264,8 @@ public void GetGlobalProperties()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Assert.Equal("v1", p.GlobalPropertiesDictionary["g1"].EvaluatedValue);
-            Assert.Equal("v2", p.GlobalPropertiesDictionary["g2"].EvaluatedValue);
+            p.GlobalPropertiesDictionary["g1"].EvaluatedValue.ShouldBe("v1");
+            p.GlobalPropertiesDictionary["g2"].EvaluatedValue.ShouldBe("v2");
         }
 
         /// <summary>
@@ -275,7 +276,7 @@ public void GetToolsVersion()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
+            p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         [Fact]
@@ -298,9 +299,9 @@ public void CloneToolsetData()
             CreateMockToolsetIfNotExists("TESTTV", projectCollection);
             ProjectInstance first = GetSampleProjectInstance(null, null, projectCollection, toolsVersion: "TESTTV");
             ProjectInstance second = first.DeepCopy();
-            Assert.Equal(first.ToolsVersion, second.ToolsVersion);
-            Assert.Equal(first.ExplicitToolsVersion, second.ExplicitToolsVersion);
-            Assert.Equal(first.ExplicitToolsVersionSpecified, second.ExplicitToolsVersionSpecified);
+            second.ToolsVersion.ShouldBe(first.ToolsVersion);
+            second.ExplicitToolsVersion.ShouldBe(first.ExplicitToolsVersion);
+            second.ExplicitToolsVersionSpecified.ShouldBe(first.ExplicitToolsVersionSpecified);
         }
 
         /// <summary>
@@ -317,16 +318,16 @@ public void GetSubToolsetVersion()
 
                 ProjectInstance p = GetSampleProjectInstance(null, null, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
-                Assert.Equal(p.Toolset.DefaultSubToolsetVersion, p.SubToolsetVersion);
+                p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe(p.Toolset.DefaultSubToolsetVersion);
 
                 if (p.Toolset.DefaultSubToolsetVersion == null)
                 {
-                    Assert.Equal(MSBuildConstants.CurrentVisualStudioVersion, p.GetPropertyValue("VisualStudioVersion"));
+                    p.GetPropertyValue("VisualStudioVersion").ShouldBe(MSBuildConstants.CurrentVisualStudioVersion);
                 }
                 else
                 {
-                    Assert.Equal(p.Toolset.DefaultSubToolsetVersion, p.GetPropertyValue("VisualStudioVersion"));
+                    p.GetPropertyValue("VisualStudioVersion").ShouldBe(p.Toolset.DefaultSubToolsetVersion);
                 }
             }
             finally
@@ -350,9 +351,9 @@ public void GetSubToolsetVersion_FromEnvironment()
 
                 ProjectInstance p = GetSampleProjectInstance(null, null, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
-                Assert.Equal("ABCD", p.SubToolsetVersion);
-                Assert.Equal("ABCD", p.GetPropertyValue("VisualStudioVersion"));
+                p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCD");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCD");
             }
             finally
             {
@@ -377,9 +378,9 @@ public void GetSubToolsetVersion_FromProjectGlobalProperties()
 
                 ProjectInstance p = GetSampleProjectInstance(null, globalProperties, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
-                Assert.Equal("ABCDE", p.SubToolsetVersion);
-                Assert.Equal("ABCDE", p.GetPropertyValue("VisualStudioVersion"));
+                p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCDE");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCDE");
             }
             finally
             {
@@ -416,9 +417,9 @@ public void GetSubToolsetVersion_FromConstructor()
 
                 ProjectInstance p = new ProjectInstance(xml, globalProperties, ObjectModelHelpers.MSBuildDefaultToolsVersion, "ABCDEF", new ProjectCollection(projectCollectionGlobalProperties));
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.Toolset.ToolsVersion);
-                Assert.Equal("ABCDEF", p.SubToolsetVersion);
-                Assert.Equal("ABCDEF", p.GetPropertyValue("VisualStudioVersion"));
+                p.Toolset.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCDEF");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCDEF");
             }
             finally
             {
@@ -434,7 +435,7 @@ public void GetDefaultTargets()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Helpers.AssertListsValueEqual(new string[] { "dt" }, p.DefaultTargets);
+            p.DefaultTargets.ShouldBe(new string[] { "dt" });
         }
 
         /// <summary>
@@ -445,7 +446,7 @@ public void GetInitialTargets()
         {
             ProjectInstance p = GetSampleProjectInstance();
 
-            Helpers.AssertListsValueEqual(new string[] { "it" }, p.InitialTargets);
+            p.InitialTargets.ShouldBe(new string[] { "it" });
         }
 
         /// <summary>
@@ -460,13 +461,14 @@ public void CloneTargets()
             ProjectInstance second = first.DeepCopy();
 
             // Targets, tasks are immutable so we can expect the same objects
-            Assert.True(Object.ReferenceEquals(first.Targets, second.Targets));
-            Assert.True(Object.ReferenceEquals(first.Targets["t"], second.Targets["t"]));
+            first.Targets.ShouldBeSameAs(second.Targets);
+
+            first.Targets["t"].ShouldBeSameAs(second.Targets["t"]);
 
             var firstTasks = first.Targets["t"];
             var secondTasks = second.Targets["t"];
 
-            Assert.True(Object.ReferenceEquals(firstTasks.Children[0], secondTasks.Children[0]));
+            firstTasks.Children[0].ShouldBeSameAs(secondTasks.Children[0]);
         }
 
         /// <summary>
@@ -479,7 +481,7 @@ public void CloneTaskRegistry()
             ProjectInstance second = first.DeepCopy();
 
             // Task registry object should be immutable
-            Assert.Same(first.TaskRegistry, second.TaskRegistry);
+            first.TaskRegistry.ShouldBeSameAs(second.TaskRegistry);
         }
 
         /// <summary>
@@ -491,8 +493,8 @@ public void CloneGlobalProperties()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Assert.Equal("v1", second.GlobalPropertiesDictionary["g1"].EvaluatedValue);
-            Assert.Equal("v2", second.GlobalPropertiesDictionary["g2"].EvaluatedValue);
+            second.GlobalPropertiesDictionary["g1"].EvaluatedValue.ShouldBe("v1");
+            second.GlobalPropertiesDictionary["g2"].EvaluatedValue.ShouldBe("v2");
         }
 
         /// <summary>
@@ -504,7 +506,7 @@ public void CloneDefaultTargets()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Helpers.AssertListsValueEqual(new string[] { "dt" }, second.DefaultTargets);
+            second.DefaultTargets.ShouldBe(new string[] { "dt" });
         }
 
         /// <summary>
@@ -516,7 +518,7 @@ public void CloneInitialTargets()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Helpers.AssertListsValueEqual(new string[] { "it" }, second.InitialTargets);
+            second.InitialTargets.ShouldBe(new string[] { "it" });
         }
 
         /// <summary>
@@ -528,7 +530,7 @@ public void CloneToolsVersion()
             ProjectInstance first = GetSampleProjectInstance();
             ProjectInstance second = first.DeepCopy();
 
-            Assert.Equal(first.Toolset, second.Toolset);
+            second.Toolset.ShouldBe(first.Toolset);
         }
 
         /// <summary>
@@ -542,7 +544,7 @@ public void CloneStateTranslation()
 
             ProjectInstance second = first.DeepCopy();
 
-            Assert.True(second.TranslateEntireState);
+            second.TranslateEntireState.ShouldBeTrue();
         }
 
         /// <summary>
@@ -574,7 +576,7 @@ public void Build()
             loggers.Add(mockLogger);
             bool success = projectInstance.Build("Build", loggers);
 
-            Assert.True(success);
+            success.ShouldBeTrue();
             mockLogger.AssertLogContains(new string[] { "Building...", "Completed!" });
         }
 
@@ -684,7 +686,7 @@ public void ProjectInstanceCanSerializeEntireStateViaTranslator(string projectCo
             ((ITranslatable)original).Translate(TranslationHelpers.GetWriteTranslator());
             var copy = ProjectInstance.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            Assert.Equal(original, copy, new ProjectInstanceComparer());
+            new ProjectInstanceComparer().Equals(original, copy).ShouldBeTrue($"{nameof(copy)} and {original} should be equal according to the {nameof(ProjectInstanceComparer)}");
         }
 
         public delegate ProjectInstance ProjectInstanceFactory(string file, ProjectRootElement xml, ProjectCollection collection);
@@ -757,7 +759,7 @@ public void ProjectInstanceHasEvaluationId(ProjectInstanceFactory projectInstanc
                 xml.Save(file);
 
                 var projectInstance = projectInstanceFactory.Invoke(file, xml, projectCollection);
-                Assert.NotEqual(BuildEventContext.InvalidEvaluationId, projectInstance.EvaluationId);
+                projectInstance.EvaluationId.ShouldNotBe(BuildEventContext.InvalidEvaluationId);
             }
         }
 
@@ -773,27 +775,27 @@ public void AddTargetAddsNewTarget()
 
             ProjectTargetInstance targetInstance = projectInstance.AddTarget("b", "1==1", "inputs", "outputs", "returns", "keepDuplicateOutputs", "dependsOnTargets", "beforeTargets", "afterTargets", true);
 
-            Assert.Equal(2, projectInstance.Targets.Count);
-            Assert.Equal(targetInstance, projectInstance.Targets["b"]);
-            Assert.Equal("b", targetInstance.Name);
-            Assert.Equal("1==1", targetInstance.Condition);
-            Assert.Equal("inputs", targetInstance.Inputs);
-            Assert.Equal("outputs", targetInstance.Outputs);
-            Assert.Equal("returns", targetInstance.Returns);
-            Assert.Equal("keepDuplicateOutputs", targetInstance.KeepDuplicateOutputs);
-            Assert.Equal("dependsOnTargets", targetInstance.DependsOnTargets);
-            Assert.Equal("beforeTargets", targetInstance.BeforeTargets);
-            Assert.Equal("afterTargets", targetInstance.AfterTargets);
-            Assert.Equal(projectInstance.ProjectFileLocation, targetInstance.Location);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.ConditionLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.InputsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.OutputsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.ReturnsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.KeepDuplicateOutputsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.DependsOnTargetsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.BeforeTargetsLocation);
-            Assert.Equal(ElementLocation.EmptyLocation, targetInstance.AfterTargetsLocation);
-            Assert.True(targetInstance.ParentProjectSupportsReturnsAttribute);
+            projectInstance.Targets.Count.ShouldBe(2);
+            projectInstance.Targets["b"].ShouldBe(targetInstance);
+            targetInstance.Name.ShouldBe("b");
+            targetInstance.Condition.ShouldBe("1==1");
+            targetInstance.Inputs.ShouldBe("inputs");
+            targetInstance.Outputs.ShouldBe("outputs");
+            targetInstance.Returns.ShouldBe("returns");
+            targetInstance.KeepDuplicateOutputs.ShouldBe("keepDuplicateOutputs");
+            targetInstance.DependsOnTargets.ShouldBe("dependsOnTargets");
+            targetInstance.BeforeTargets.ShouldBe("beforeTargets");
+            targetInstance.AfterTargets.ShouldBe("afterTargets");
+            targetInstance.Location.ShouldBe(projectInstance.ProjectFileLocation);
+            targetInstance.ConditionLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.InputsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.OutputsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.ReturnsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.KeepDuplicateOutputsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.DependsOnTargetsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.BeforeTargetsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.AfterTargetsLocation.ShouldBe(ElementLocation.EmptyLocation);
+            targetInstance.ParentProjectSupportsReturnsAttribute.ShouldBeTrue();
         }
 
         [Fact]
@@ -806,7 +808,7 @@ public void AddTargetThrowsWithExistingTarget()
             ProjectRootElement rootElement = ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)));
             ProjectInstance projectInstance = new ProjectInstance(rootElement);
 
-            Assert.Throws<InternalErrorException>(() => projectInstance.AddTarget("a", "1==1", "inputs", "outputs", "returns", "keepDuplicateOutputs", "dependsOnTargets", "beforeTargets", "afterTargets", true));
+            Should.Throw<InternalErrorException>(() => projectInstance.AddTarget("a", "1==1", "inputs", "outputs", "returns", "keepDuplicateOutputs", "dependsOnTargets", "beforeTargets", "afterTargets", true));
         }
 
         [Theory]
@@ -856,8 +858,8 @@ public void GetImportPathsAndImportPathsIncludingDuplicates(bool useDirectConstr
                     ? new string[] { import1Path, import2Path, import3Path, import2Path, import1Path }
                     : expectedImportPaths;
 
-                Helpers.AssertListsValueEqual(expectedImportPaths, projectInstance.ImportPaths.ToList());
-                Helpers.AssertListsValueEqual(expectedImportPathsIncludingDuplicates, projectInstance.ImportPathsIncludingDuplicates.ToList());
+                projectInstance.ImportPaths.ToList().ShouldBe(expectedImportPaths);
+                projectInstance.ImportPathsIncludingDuplicates.ToList().ShouldBe(expectedImportPathsIncludingDuplicates);
             }
             finally
             {
@@ -865,6 +867,62 @@ public void GetImportPathsAndImportPathsIncludingDuplicates(bool useDirectConstr
             }
         }
 
+        /// <summary>
+        /// Verifies that when calling <see cref="ProjectInstance.FromFile(string, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectInstanceFromFileInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                ProjectInstance projectInstance = ProjectInstance.FromFile(
+                    projectRootElement.FullPath,
+                    new ProjectOptions
+                    {
+                        Interactive = interactive,
+                        ProjectCollection = projectCollection,
+                    });
+
+                projectInstance.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+            }
+        }
+
+        /// <summary>
+        /// Verifies that when calling <see cref="ProjectInstance.FromProjectRootElement(ProjectRootElement, ProjectOptions)" /> with <see cref="ProjectOptions.Interactive" /> <see langword="true" />, the built-in &quot;MSBuildInteractive&quot; property is set to <see langword="true" />, otherwise the property is <see cref="string.Empty" />.
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ProjectInstanceFromProjectRootElementInteractive(bool interactive)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
+
+                ProjectRootElement projectRootElement = ProjectRootElement.Create(projectCollection);
+
+                projectRootElement.Save(testEnvironment.CreateFile().Path);
+
+                ProjectInstance projectInstance = ProjectInstance.FromProjectRootElement(
+                    projectRootElement,
+                    new ProjectOptions
+                    {
+                        Interactive = interactive,
+                        ProjectCollection = projectCollection,
+                    });
+
+                projectInstance.GetPropertyValue(ReservedPropertyNames.interactive).ShouldBe(interactive ? bool.TrueString : string.Empty, StringCompareShould.IgnoreCase);
+            }
+        }
+
         /// <summary>
         /// Create a ProjectInstance from provided project content
         /// </summary>
diff --git a/src/Build.UnitTests/TaskThatReturnsMinimalItem.cs b/src/Build.UnitTests/TaskThatReturnsMinimalItem.cs
new file mode 100644
index 00000000000..7f8eec32b2a
--- /dev/null
+++ b/src/Build.UnitTests/TaskThatReturnsMinimalItem.cs
@@ -0,0 +1,48 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Engine.UnitTests;
+
+/// <summary>
+/// Task that emulates .NET 3.5 tasks.
+/// </summary>
+public sealed class TaskThatReturnsMinimalItem : ITask
+{
+    public IBuildEngine? BuildEngine { get; set; }
+    public ITaskHost? HostObject { get; set; }
+
+    [Output]
+    public ITaskItem MinimalTaskItemOutput { get => new MinimalTaskItem(); }
+
+    public bool Execute() => true;
+
+    /// <summary>
+    /// Minimal implementation of <see cref="ITaskItem"/> that uses a <see cref="Hashtable"/> for metadata,
+    /// like MSBuild 3 did.
+    /// </summary>
+    internal sealed class MinimalTaskItem : ITaskItem
+    {
+        public string ItemSpec { get => $"{nameof(MinimalTaskItem)}spec"; set => throw new NotImplementedException(); }
+
+        public ICollection MetadataNames => throw new NotImplementedException();
+
+        public int MetadataCount => throw new NotImplementedException();
+
+        public IDictionary CloneCustomMetadata()
+        {
+            Hashtable t = new();
+            t["key"] = "value";
+
+            return t;
+        }
+        public void CopyMetadataTo(ITaskItem destinationItem) => throw new NotImplementedException();
+        public string GetMetadata(string metadataName) => "value";
+        public void RemoveMetadata(string metadataName) => throw new NotImplementedException();
+        public void SetMetadata(string metadataName, string metadataValue) => throw new NotImplementedException();
+    }
+}
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index db8405646a1..8d7a8268648 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -205,6 +205,8 @@ public class BuildParameters : ITranslatable
         /// </summary>
         private bool _logInitialPropertiesAndItems;
 
+        private bool _question;
+
         /// <summary>
         /// The settings used to load the project under build
         /// </summary>
@@ -303,6 +305,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             _outputResultsCacheFile = other._outputResultsCacheFile;
             DiscardBuildResults = other.DiscardBuildResults;
             LowPriority = other.LowPriority;
+            Question = other.Question;
             ProjectCacheDescriptor = other.ProjectCacheDescriptor;
         }
 
@@ -808,6 +811,15 @@ public string OutputResultsCacheFile
         /// </summary>
         public bool LowPriority { get; set; }
 
+        /// <summary>
+        /// Gets or sets a value that will error when the build process fails an incremental check.
+        /// </summary>
+        public bool Question
+        {
+            get => _question;
+            set => _question = value;
+        }
+
         /// <summary>
         /// Gets or sets the project cache description to use for all <see cref="BuildSubmission"/> or <see cref="GraphBuildSubmission"/>
         /// in addition to any potential project caches described in each project.
@@ -871,6 +883,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _logInitialPropertiesAndItems);
             translator.TranslateEnum(ref _projectLoadSettings, (int)_projectLoadSettings);
             translator.Translate(ref _interactive);
+            translator.Translate(ref _question);
             translator.TranslateEnum(ref _projectIsolationMode, (int)_projectIsolationMode);
 
             // ProjectRootElementCache is not transmitted.
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 9f4a4cdb9e2..693912475d0 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -229,11 +229,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
                 CommunicationsUtilities.Trace("Build finished.");
             }
 
-            if (NativeMethodsShared.IsWindows && _originalConsoleMode is not null)
-            {
-                IntPtr stdOut = NativeMethodsShared.GetStdHandle(NativeMethodsShared.STD_OUTPUT_HANDLE);
-                NativeMethodsShared.SetConsoleMode(stdOut, _originalConsoleMode.Value);
-            }
+            NativeMethodsShared.RestoreConsoleMode(_originalConsoleMode);
 
             return _exitResult;
         }
@@ -265,9 +261,10 @@ private bool TryShutdownServer(CancellationToken cancellationToken)
                 return true;
             }
 
-            // Check that server is not busy.
-            bool serverWasBusy = ServerWasBusy();
-            if (serverWasBusy)
+            // Check and wait for server to be not busy for some short time to avoid race condition when server reports build is finished but had not released ServerBusy mutex yet.
+            // If during that short time, a script would try to shutdown server, it would be rejected and server would continue to run.
+            bool serverIsBusy = ServerIsBusyWithWaitAndRetry(250);
+            if (serverIsBusy)
             {
                 CommunicationsUtilities.Trace("Server cannot be shut down for it is not idle.");
                 return false;
@@ -291,6 +288,20 @@ private bool TryShutdownServer(CancellationToken cancellationToken)
             return _exitResult.MSBuildClientExitType == MSBuildClientExitType.Success;
         }
 
+        private bool ServerIsBusyWithWaitAndRetry(int milliseconds)
+        {
+            bool isBusy = ServerWasBusy();
+            Stopwatch sw = Stopwatch.StartNew();
+            while (isBusy && sw.ElapsedMilliseconds < milliseconds)
+            {
+                CommunicationsUtilities.Trace("Wait for server to be not busy - will retry soon...");
+                Thread.Sleep(100);
+                isBusy = ServerWasBusy();
+            }
+
+            return isBusy;
+        }
+
         internal bool ServerIsRunning()
         {
             string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);
@@ -362,63 +373,13 @@ private void ReadPacketsLoop(CancellationToken cancellationToken)
 
         private void ConfigureAndQueryConsoleProperties()
         {
-            var (acceptAnsiColorCodes, outputIsScreen) = QueryIsScreenAndTryEnableAnsiColorCodes();
+            (var acceptAnsiColorCodes, var outputIsScreen, _originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
             int bufferWidth = QueryConsoleBufferWidth();
             ConsoleColor backgroundColor = QueryConsoleBackgroundColor();
 
             _consoleConfiguration = new TargetConsoleConfiguration(bufferWidth, acceptAnsiColorCodes, outputIsScreen, backgroundColor);
         }
 
-        private (bool acceptAnsiColorCodes, bool outputIsScreen) QueryIsScreenAndTryEnableAnsiColorCodes()
-        {
-            bool acceptAnsiColorCodes = false;
-            bool outputIsScreen = false;
-
-            if (NativeMethodsShared.IsWindows)
-            {
-                try
-                {
-                    IntPtr stdOut = NativeMethodsShared.GetStdHandle(NativeMethodsShared.STD_OUTPUT_HANDLE);
-                    if (NativeMethodsShared.GetConsoleMode(stdOut, out uint consoleMode))
-                    {
-                        bool success;
-                        if ((consoleMode & NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING) == NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING)
-                        {
-                            // Console is already in required state
-                            success = true;
-                        }
-                        else
-                        {
-                            _originalConsoleMode = consoleMode;
-                            consoleMode |= NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING;
-                            success = NativeMethodsShared.SetConsoleMode(stdOut, consoleMode);
-                        }
-
-                        if (success)
-                        {
-                            acceptAnsiColorCodes = true;
-                        }
-
-                        uint fileType = NativeMethodsShared.GetFileType(stdOut);
-                        // The std out is a char type(LPT or Console)
-                        outputIsScreen = fileType == NativeMethodsShared.FILE_TYPE_CHAR;
-                        acceptAnsiColorCodes &= outputIsScreen;
-                    }
-                }
-                catch (Exception ex)
-                {
-                    CommunicationsUtilities.Trace("MSBuild client warning: problem during enabling support for VT100: {0}.", ex);
-                }
-            }
-            else
-            {
-                // On posix OSes we expect console always supports VT100 coloring unless it is redirected
-                acceptAnsiColorCodes = outputIsScreen = !Console.IsOutputRedirected;
-            }
-
-            return (acceptAnsiColorCodes: acceptAnsiColorCodes, outputIsScreen: outputIsScreen);
-        }
-
         private int QueryConsoleBufferWidth()
         {
             int consoleBufferWidth = -1;
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 3e926e2e75e..1ded6e6fc8a 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -5,8 +5,9 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
-using Microsoft.Build.Execution;
+using System.Linq;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Execution;
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 
 #nullable disable
@@ -289,15 +290,7 @@ public List<BuildRequestConfiguration> GetUnresolvedConfigurationsToIssue()
         /// </summary>
         public string[] GetActiveTargets()
         {
-            var activeTargets = new string[RequestConfiguration.ActivelyBuildingTargets.Count];
-
-            int index = 0;
-            foreach (string target in RequestConfiguration.ActivelyBuildingTargets.Keys)
-            {
-                activeTargets[index++] = target;
-            }
-
-            return activeTargets;
+            return RequestConfiguration.ActivelyBuildingTargets.Keys.ToArray();
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index c9223838572..7346954557d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -287,7 +287,10 @@ bool TryReuseAnyFromPossibleRunningNodes(int nodeId)
                         // Connection successful, use this node.
                         CommunicationsUtilities.Trace("Successfully connected to existed node {0} which is PID {1}", nodeId, nodeToReuse.Id);
                         string msg = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("NodeReused", nodeId, nodeToReuse.Id);
-                        _componentHost.LoggingService.LogBuildEvent(new BuildMessageEventArgs(msg, null, null, MessageImportance.Low));
+                        _componentHost.LoggingService.LogBuildEvent(new BuildMessageEventArgs(msg, null, null, MessageImportance.Low)
+                        {
+                            BuildEventContext = new BuildEventContext(nodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId)
+                        });
 
                         CreateNodeContext(nodeId, nodeToReuse, nodeStream);
                         return true;
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index 3f7a58fdd83..1efec57dc44 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -128,6 +128,36 @@ internal void LogComment(MessageImportance importance, string messageResourceNam
             _loggingService.LogComment(_eventContext, importance, messageResourceName, messageArgs);
         }
 
+        /// <summary>
+        ///  Helper method to create a message build event from a string resource and some parameters
+        /// </summary>
+        /// <param name="importance">Importance level of the message</param>
+        /// <param name="file">The file in which the event occurred</param>
+        /// <param name="messageResourceName">string within the resource which indicates the format string to use</param>
+        /// <param name="messageArgs">string resource arguments</param>
+        internal void LogComment(MessageImportance importance, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
+        {
+            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+
+            _loggingService.LogBuildEvent(new BuildMessageEventArgs(
+                null,
+                null,
+                file.File,
+                file.Line,
+                file.Column,
+                file.EndLine,
+                file.EndColumn,
+                ResourceUtilities.GetResourceString(messageResourceName),
+                helpKeyword: null,
+                senderName: "MSBuild",
+                importance,
+                DateTime.UtcNow,
+                messageArgs)
+            {
+                BuildEventContext = _eventContext
+            });
+        }
+
         /// <summary>
         /// Helper method to create a message build event from a string
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 0f80c152ba5..8e6b9ef1c0e 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -246,15 +246,15 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <summary>
         /// Event set when message is consumed from queue.
         /// </summary>
-        private ManualResetEventSlim _dequeueEvent;
+        private AutoResetEvent _dequeueEvent;
         /// <summary>
         /// Event set when queue become empty.
         /// </summary>
-        private ManualResetEventSlim _emptyQueueEvent;
+        private ManualResetEvent _emptyQueueEvent;
         /// <summary>
         /// Even set when message is added into queue.
         /// </summary>
-        private ManualResetEventSlim _enqueueEvent;
+        private AutoResetEvent _enqueueEvent;
 
         /// <summary>
         /// CTS for stopping logging event processing.
@@ -1183,8 +1183,7 @@ internal virtual void ProcessLoggingEvent(object buildEvent)
                 while (_eventQueue.Count >= _queueCapacity)
                 {
                     // Block and wait for dequeue event.
-                    _dequeueEvent.Wait();
-                    _dequeueEvent.Reset();
+                    _dequeueEvent.WaitOne();
                 }
 
                 _eventQueue.Enqueue(buildEvent);
@@ -1209,12 +1208,12 @@ public void WaitForLoggingToProcessEvents()
         {
             while (_eventQueue?.IsEmpty == false)
             {
-                _emptyQueueEvent?.Wait();
+                _emptyQueueEvent?.WaitOne();
             }
             // To avoid race condition when last message has been removed from queue but
             //   not yet fully processed (handled by loggers), we need to make sure _emptyQueueEvent
             //   is set as it is guaranteed to be in set state no sooner than after event has been processed.
-            _emptyQueueEvent?.Wait();
+            _emptyQueueEvent?.WaitOne();
         }
 
         /// <summary>
@@ -1263,9 +1262,9 @@ private static int GetWarningsAsErrorOrMessageKey(BuildEventArgs buildEventArgs)
         private void StartLoggingEventProcessing()
         {
             _eventQueue = new ConcurrentQueue<object>();
-            _dequeueEvent = new ManualResetEventSlim(false);
-            _emptyQueueEvent = new ManualResetEventSlim(false);
-            _enqueueEvent = new ManualResetEventSlim(false);
+            _dequeueEvent = new AutoResetEvent(false);
+            _emptyQueueEvent = new ManualResetEvent(false);
+            _enqueueEvent = new AutoResetEvent(false);
             _loggingEventProcessingCancellation = new CancellationTokenSource();
 
             _loggingEventProcessingThread = new Thread(LoggingEventProc);
@@ -1276,7 +1275,7 @@ private void StartLoggingEventProcessing()
             void LoggingEventProc()
             {
                 var completeAdding = _loggingEventProcessingCancellation.Token;
-                WaitHandle[] waitHandlesForNextEvent = { completeAdding.WaitHandle, _enqueueEvent.WaitHandle };
+                WaitHandle[] waitHandlesForNextEvent = { completeAdding.WaitHandle, _enqueueEvent };
 
                 do
                 {
@@ -1295,7 +1294,6 @@ void LoggingEventProc()
                             WaitHandle.WaitAny(waitHandlesForNextEvent);
                         }
 
-                        _enqueueEvent.Reset();
                         _emptyQueueEvent.Reset();
                     }
                 } while (!_eventQueue.IsEmpty || !completeAdding.IsCancellationRequested);
@@ -1639,7 +1637,7 @@ ILogger UnwrapLoggerType(ILogger log)
         /// </remarks>
         private void UpdateMinimumMessageImportance(ILogger logger)
         {
-            var innerLogger = (logger is Evaluation.ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;
+            var innerLogger = (logger is ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;
 
             MessageImportance? minimumImportance = innerLogger switch
             {
@@ -1653,8 +1651,11 @@ private void UpdateMinimumMessageImportance(ILogger logger)
                 // The null logger has no effect on minimum verbosity.
                 Execution.BuildManager.NullLogger => null,
 
-                // If the logger is not on our whitelist, there are no importance guarantees. Fall back to "any importance".
-                _ => MessageImportance.Low
+                // The live logger consumes only high priority messages.
+                _ => innerLogger.GetType().FullName == "Microsoft.Build.Logging.LiveLogger.LiveLogger"
+                    ? MessageImportance.High
+                    // If the logger is not on our allow list, there are no importance guarantees. Fall back to "any importance".
+                    : MessageImportance.Low,
             };
 
             if (minimumImportance != null)
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index cf228ca379a..9d1cefe040d 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -543,22 +543,19 @@ static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromS
                 string definingProjectPath,
                 Dictionary<string, string> templateGlobalProperties)
             {
-                // TODO: fix code clone for parsing CurrentSolutionConfiguration xml: https://github.com/dotnet/msbuild/issues/6751
-                var doc = new XmlDocument();
-                doc.LoadXml(solutionConfigurationXml);
-
-                var root = doc.DocumentElement!;
-                var projectConfigurationNodes = root.GetElementsByTagName("ProjectConfiguration");
-
-                ErrorUtilities.VerifyThrow(projectConfigurationNodes.Count > 0, "Expected at least one project in solution");
+                XmlNodeList? projectConfigurations = SolutionConfiguration.GetProjectConfigurations(solutionConfigurationXml);
+                if (projectConfigurations == null || projectConfigurations.Count == 0)
+                {
+                    return Array.Empty<ProjectGraphEntryPoint>();
+                }
 
-                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurationNodes.Count);
+                var graphEntryPoints = new List<ProjectGraphEntryPoint>(projectConfigurations.Count);
 
-                foreach (XmlNode node in projectConfigurationNodes)
+                foreach (XmlElement projectConfiguration in projectConfigurations)
                 {
-                    ErrorUtilities.VerifyThrowInternalNull(node.Attributes, nameof(node.Attributes));
+                    ErrorUtilities.VerifyThrowInternalNull(projectConfiguration.Attributes, nameof(projectConfiguration.Attributes));
 
-                    var buildProjectInSolution = node.Attributes!["BuildProjectInSolution"];
+                    var buildProjectInSolution = projectConfiguration.Attributes![SolutionConfiguration.BuildProjectInSolutionAttribute];
                     if (buildProjectInSolution is not null &&
                         string.IsNullOrWhiteSpace(buildProjectInSolution.Value) is false &&
                         bool.TryParse(buildProjectInSolution.Value, out var buildProject) &&
@@ -567,12 +564,12 @@ static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromS
                         continue;
                     }
 
-                    var projectPathAttribute = node.Attributes!["AbsolutePath"];
+                    XmlAttribute? projectPathAttribute = projectConfiguration.Attributes![SolutionConfiguration.AbsolutePathAttribute];
                     ErrorUtilities.VerifyThrow(projectPathAttribute is not null, "Expected VS to set the project path on each ProjectConfiguration element.");
 
-                    var projectPath = projectPathAttribute!.Value;
+                    string projectPath = projectPathAttribute!.Value;
 
-                    var (configuration, platform) = SolutionFile.ParseConfigurationName(node.InnerText, definingProjectPath, 0, solutionConfigurationXml);
+                    (string configuration, string platform) = SolutionFile.ParseConfigurationName(projectConfiguration.InnerText, definingProjectPath, 0, solutionConfigurationXml);
 
                     // Take the defining project global properties and override the configuration and platform.
                     // It's sufficient to only set Configuration and Platform.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
index 61f4bcb31fb..0f9f1858b52 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
@@ -150,7 +150,7 @@ private void StopTracking()
         private void CurrentDomainOnAssemblyLoad(object? sender, AssemblyLoadEventArgs args)
         {
             string? assemblyName = args.LoadedAssembly.FullName;
-            string assemblyPath = args.LoadedAssembly.Location;
+            string assemblyPath = args.LoadedAssembly.IsDynamic ? string.Empty : args.LoadedAssembly.Location;
             Guid mvid = args.LoadedAssembly.ManifestModule.ModuleVersionId;
             string? appDomainDescriptor = _appDomain.IsDefaultAppDomain()
                 ? null
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 8dd00b2148b..096c90e5ff9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -184,7 +184,17 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
+                    ExpanderOptions expanderOptions = ExpanderOptions.ExpandAll;
+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) &&
+                        // If multiple buckets were expanded - we do not want to repeat same error for same metadatum on a same line
+                        bucket.BucketSequenceNumber == 0 &&
+                        // Referring to unqualified metadata of other item (transform) is fine.
+                        child.Include.IndexOf("@(", StringComparison.Ordinal) == -1)
+                    {
+                        expanderOptions |= ExpanderOptions.LogOnItemMetadataSelfReference;
+                    }
+
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, metadataInstance.Location, loggingContext);
 
                     // This both stores the metadata so we can add it to all the items we just created later, and 
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
@@ -612,7 +622,7 @@ private List<ProjectItemInstance> FindItemsMatchingMetadataSpecification(
         /// 1. The metadata table created for the bucket, may be null.
         /// 2. The metadata table derived from the item definition group, may be null.
         /// </summary>
-        private class NestedMetadataTable : IMetadataTable
+        private class NestedMetadataTable : IMetadataTable, IItemTypeDefinition
         {
             /// <summary>
             /// The table for all metadata added during expansion
@@ -722,6 +732,8 @@ internal void SetValue(string name, string value)
             {
                 _addTable[name] = value;
             }
+
+            string IItemTypeDefinition.ItemType => _itemType;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 79f3c4cd0f7..cef0fb834f9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -462,7 +462,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                         // UNDONE: (Refactor) Refactor TargetUpToDateChecker to take a logging context, not a logging service.
                         MSBuildEventSource.Log.TargetUpToDateStart();
                         TargetUpToDateChecker dependencyAnalyzer = new TargetUpToDateChecker(requestEntry.RequestConfiguration.Project, _target, targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext);
-                        DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, out changedTargetInputs, out upToDateTargetInputs);
+                        DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, _host.BuildParameters.Question, out changedTargetInputs, out upToDateTargetInputs);
                         MSBuildEventSource.Log.TargetUpToDateStop((int)dependencyResult);
 
                         switch (dependencyResult)
@@ -471,6 +471,13 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                             case DependencyAnalysisResult.FullBuild:
                             case DependencyAnalysisResult.IncrementalBuild:
                             case DependencyAnalysisResult.SkipUpToDate:
+                                if (dependencyResult != DependencyAnalysisResult.SkipUpToDate && _host.BuildParameters.Question && !string.IsNullOrEmpty(_target.Inputs) && !string.IsNullOrEmpty(_target.Outputs))
+                                {
+                                    targetSuccess = false;
+                                    aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Canceled, WorkUnitActionCode.Stop, null));
+                                    break;
+                                }
+
                                 // Create the lookups used to hold the current set of properties and items
                                 lookupForInference = bucket.Lookup;
                                 lookupForExecution = bucket.Lookup.Clone();
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index bb99f7d5237..dcf16e16545 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -118,6 +118,7 @@ private string TargetOutputSpecification
         /// incremental build is needed.
         /// </remarks>
         /// <param name="bucket"></param>
+        /// <param name="question"></param>
         /// <param name="changedTargetInputs"></param>
         /// <param name="upToDateTargetInputs"></param>
         /// <returns>
@@ -129,6 +130,7 @@ private string TargetOutputSpecification
         /// </returns>
         internal DependencyAnalysisResult PerformDependencyAnalysis(
             ItemBucket bucket,
+            bool question,
             out ItemDictionary<ProjectItemInstance> changedTargetInputs,
             out ItemDictionary<ProjectItemInstance> upToDateTargetInputs)
         {
@@ -200,7 +202,7 @@ internal DependencyAnalysisResult PerformDependencyAnalysis(
                          * 
                          */
                         ErrorUtilities.VerifyThrow(itemVectorsReferencedInBothTargetInputsAndOutputs.Count > 0, "The target must have inputs.");
-                        ErrorUtilities.VerifyThrow(GetItemSpecsFromItemVectors(itemVectorsInTargetInputs).Count > 0, "The target must have inputs.");
+                        ErrorUtilities.VerifyThrow(!IsItemVectorEmpty(itemVectorsInTargetInputs), "The target must have inputs.");
 
                         result = PerformDependencyAnalysisIfDiscreteInputs(itemVectorsInTargetInputs,
                                     itemVectorTransformsInTargetInputs, discreteItemsInTargetInputs, itemVectorsReferencedOnlyInTargetInputs,
@@ -252,7 +254,7 @@ internal DependencyAnalysisResult PerformDependencyAnalysis(
                 }
             }
 
-            LogReasonForBuildingTarget(result);
+            LogReasonForBuildingTarget(result, question);
 
             return result;
         }
@@ -261,15 +263,23 @@ internal DependencyAnalysisResult PerformDependencyAnalysis(
         /// Does appropriate logging to indicate why this target is being built fully or partially.
         /// </summary>
         /// <param name="result"></param>
-        private void LogReasonForBuildingTarget(DependencyAnalysisResult result)
+        /// <param name="question"></param>
+        private void LogReasonForBuildingTarget(DependencyAnalysisResult result, bool question)
         {
             // Only if we are not logging just critical events should we be logging the details
             if (!_loggingService.OnlyLogCriticalEvents)
             {
                 if (result == DependencyAnalysisResult.FullBuild && _dependencyAnalysisDetail.Count > 0)
                 {
-                    // For the full build decision the are three possible outcomes
-                    _loggingService.LogComment(_buildEventContext, MessageImportance.Low, "BuildTargetCompletely", _targetToAnalyze.Name);
+                    if (question)
+                    {
+                        _loggingService.LogError(_buildEventContext, new BuildEventFileInfo(String.Empty), "BuildTargetCompletely", _targetToAnalyze.Name);
+                    }
+                    else
+                    {
+                        // For the full build decision, there are three possible outcomes
+                        _loggingService.LogComment(_buildEventContext, MessageImportance.Low, "BuildTargetCompletely", _targetToAnalyze.Name);
+                    }
 
                     foreach (DependencyAnalysisLogDetail logDetail in _dependencyAnalysisDetail)
                     {
@@ -279,8 +289,15 @@ private void LogReasonForBuildingTarget(DependencyAnalysisResult result)
                 }
                 else if (result == DependencyAnalysisResult.IncrementalBuild)
                 {
-                    // For the partial build decision the are three possible outcomes
-                    _loggingService.LogComment(_buildEventContext, MessageImportance.Normal, "BuildTargetPartially", _targetToAnalyze.Name);
+                    if (question)
+                    {
+                        _loggingService.LogError(_buildEventContext, new BuildEventFileInfo(String.Empty), "BuildTargetPartially", _targetToAnalyze.Name);
+                    }
+                    else
+                    {
+                        // For the partial build decision the are three possible outcomes
+                        _loggingService.LogComment(_buildEventContext, MessageImportance.Normal, "BuildTargetPartially", _targetToAnalyze.Name);
+                    }
                     foreach (DependencyAnalysisLogDetail logDetail in _dependencyAnalysisDetail)
                     {
                         string reason = GetIncrementalBuildReason(logDetail);
@@ -510,7 +527,7 @@ private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteInputs(
             // cannot correlate them to any output item
             foreach (string itemVectorType in itemVectorsReferencedOnlyInTargetInputs)
             {
-                discreteTargetInputItemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectorsInTargetInputs, itemVectorType));
+                discreteTargetInputItemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectorsInTargetInputs, itemVectorType, itemVectorsInTargetInputs[itemVectorType]));
             }
 
             // if there are any discrete input items, we can treat them as "meta" inputs, because:
@@ -840,6 +857,19 @@ private void SeparateItemVectorsFromDiscreteItems(
             }
         }
 
+        private static bool IsItemVectorEmpty(ItemVectorPartitionCollection itemVectors)
+        {
+            foreach (KeyValuePair<string, ItemVectorPartition> item in itemVectors)
+            {
+                if (GetItemSpecsFromItemVectors(itemVectors, item.Key, item.Value).Any())
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
         /// <summary>
         /// Retrieves the item-specs of all items in the given item vector collection.
         /// </summary>
@@ -847,11 +877,11 @@ private void SeparateItemVectorsFromDiscreteItems(
         /// <returns>list of item-specs</returns>
         private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors)
         {
-            List<string> itemSpecs = new List<string>();
+            List<string> itemSpecs = new();
 
-            foreach (string itemType in itemVectors.Keys)
+            foreach (KeyValuePair<string, ItemVectorPartition> item in itemVectors)
             {
-                itemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectors, itemType));
+                itemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectors, item.Key, item.Value));
             }
 
             return itemSpecs;
@@ -862,13 +892,10 @@ private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionColle
         /// </summary>
         /// <param name="itemVectors"></param>
         /// <param name="itemType"></param>
+        /// <param name="itemVectorPartition"></param>
         /// <returns>list of item-specs</returns>
-        private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors, string itemType)
+        private static IEnumerable<string> GetItemSpecsFromItemVectors(ItemVectorPartitionCollection itemVectors, string itemType, ItemVectorPartition itemVectorPartition)
         {
-            List<string> itemSpecs = new List<string>();
-
-            ItemVectorPartition itemVectorPartition = itemVectors[itemType];
-
             if (itemVectorPartition != null)
             {
                 foreach (IList<ProjectItemInstance> items in itemVectorPartition.Values)
@@ -878,12 +905,10 @@ private static List<string> GetItemSpecsFromItemVectors(ItemVectorPartitionColle
                         // The item can be null in the case of an item transform.
                         // eg., @(Compile->'%(NonExistentMetadata)')
                         // Nevertheless, include these, so that correlation can still occur.
-                        itemSpecs.Add((item == null) ? null : ((IItem)item).EvaluatedIncludeEscaped);
+                        yield return item == null ? null : ((IItem)item).EvaluatedIncludeEscaped;
                     }
                 }
             }
-
-            return itemSpecs;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index b83da0aa245..f8768988732 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -391,12 +391,6 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
             }
 
             // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
-            if (MSBuildEventSource.Log.IsEnabled())
-            {
-                TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
-                MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
-            }
-
             // If this is an Intrinsic task, it gets handled in a special fashion.
             if (_taskNode == null)
             {
@@ -433,6 +427,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                     if (requirements != null)
                     {
                         TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
+                        MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
                         _buildRequestEntry.Request.CurrentTaskContext = taskLoggingContext.BuildEventContext;
 
                         try
@@ -487,6 +482,8 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                                 // We coerce the failing result to a successful result.
                                 taskResult = new WorkUnitResult(WorkUnitResultCode.Success, taskResult.ActionCode, taskResult.Exception);
                             }
+
+                            MSBuildEventSource.Log.ExecuteTaskStop(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
                         }
                     }
                 }
@@ -514,13 +511,6 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 }
             }
 
-            // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
-            if (MSBuildEventSource.Log.IsEnabled())
-            {
-                TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
-                MSBuildEventSource.Log.ExecuteTaskStop(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
-            }
-
             return taskResult;
         }
 
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 0c11f731cb5..bedccfe03cd 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -906,53 +906,53 @@ private bool GetSchedulingPlanAndAlgorithm()
         /// </summary>
         private void AssignUnscheduledRequestsWithPlanByMostImmediateReferences(List<ScheduleResponse> responses, HashSet<int> idleNodes)
         {
-            foreach (int idleNodeId in idleNodes)
-            {
-                Dictionary<int, SchedulableRequest> configsWhichCanBeScheduledToThisNode = new Dictionary<int, SchedulableRequest>();
-
-                // Find the most expensive request in the plan to schedule from among the ones available.
-                foreach (SchedulableRequest request in _schedulingData.UnscheduledRequestsWhichCanBeScheduled)
-                {
-                    if (CanScheduleRequestToNode(request, idleNodeId))
-                    {
-                        configsWhichCanBeScheduledToThisNode[request.BuildRequest.ConfigurationId] = request;
-                    }
-                }
-
-                if (configsWhichCanBeScheduledToThisNode.Count > 0)
-                {
-                    int configToSchedule = _schedulingPlan.GetConfigWithGreatestNumberOfReferences(configsWhichCanBeScheduledToThisNode.Keys);
-
-                    ErrorUtilities.VerifyThrow(configToSchedule != BuildRequestConfiguration.InvalidConfigurationId, "No configuration returned even though there are some available.");
-                    AssignUnscheduledRequestToNode(configsWhichCanBeScheduledToThisNode[configToSchedule], idleNodeId, responses);
-                }
-            }
+            AssignUnscheduledRequestsWithPlan(responses, idleNodes, (plan1, plan2) => plan1.ReferencesCount < plan2.ReferencesCount);
         }
 
         /// <summary>
         /// Assigns requests to nodes based on those which have the most plan time.
         /// </summary>
         private void AssignUnscheduledRequestsWithPlanByGreatestPlanTime(List<ScheduleResponse> responses, HashSet<int> idleNodes)
+        {
+            AssignUnscheduledRequestsWithPlan(responses, idleNodes, (plan1, plan2) => plan1.TotalPlanTime < plan2.TotalPlanTime);
+        }
+
+        private void AssignUnscheduledRequestsWithPlan(List<ScheduleResponse> responses, HashSet<int> idleNodes, Func<SchedulingPlan.PlanConfigData, SchedulingPlan.PlanConfigData, bool> comparisonFunction)
         {
             foreach (int idleNodeId in idleNodes)
             {
-                Dictionary<int, SchedulableRequest> configsWhichCanBeScheduledToThisNode = new Dictionary<int, SchedulableRequest>();
+                SchedulingPlan.PlanConfigData bestConfig = null;
+                SchedulableRequest bestRequest = null;
 
                 // Find the most expensive request in the plan to schedule from among the ones available.
                 foreach (SchedulableRequest request in _schedulingData.UnscheduledRequestsWhichCanBeScheduled)
                 {
                     if (CanScheduleRequestToNode(request, idleNodeId))
                     {
-                        configsWhichCanBeScheduledToThisNode[request.BuildRequest.ConfigurationId] = request;
+                        SchedulingPlan.PlanConfigData configToConsider = _schedulingPlan.GetConfiguration(request.BuildRequest.ConfigurationId);
+                        if (configToConsider is null)
+                        {
+                            if (bestConfig is null)
+                            {
+                                // By default we assume configs we don't know about aren't as important, and will only schedule them
+                                // if nothing else is suitable
+                                bestRequest ??= request;
+                            }
+                        }
+                        else
+                        {
+                            if (bestConfig is null || comparisonFunction(bestConfig, configToConsider))
+                            {
+                                bestConfig = configToConsider;
+                                bestRequest = request;
+                            }
+                        }
                     }
                 }
 
-                if (configsWhichCanBeScheduledToThisNode.Count > 0)
+                if (bestRequest is not null)
                 {
-                    int configToSchedule = _schedulingPlan.GetConfigWithGreatestPlanTime(configsWhichCanBeScheduledToThisNode.Keys);
-
-                    ErrorUtilities.VerifyThrow(configToSchedule != BuildRequestConfiguration.InvalidConfigurationId, "No configuration returned even though there are some available.");
-                    AssignUnscheduledRequestToNode(configsWhichCanBeScheduledToThisNode[configToSchedule], idleNodeId, responses);
+                    AssignUnscheduledRequestToNode(bestRequest, idleNodeId, responses);
                 }
             }
         }
@@ -962,23 +962,7 @@ private void AssignUnscheduledRequestsWithPlanByGreatestPlanTime(List<ScheduleRe
         /// </summary>
         private void AssignUnscheduledRequestsByTraversalsFirst(List<ScheduleResponse> responses, HashSet<int> idleNodes)
         {
-            if (idleNodes.Contains(InProcNodeId))
-            {
-                // Assign traversal projects first (to find more work.)
-                List<SchedulableRequest> unscheduledRequests = new List<SchedulableRequest>(_schedulingData.UnscheduledRequestsWhichCanBeScheduled);
-                foreach (SchedulableRequest request in unscheduledRequests)
-                {
-                    if (CanScheduleRequestToNode(request, InProcNodeId))
-                    {
-                        if (IsTraversalRequest(request.BuildRequest))
-                        {
-                            AssignUnscheduledRequestToNode(request, InProcNodeId, responses);
-                            idleNodes.Remove(InProcNodeId);
-                            break;
-                        }
-                    }
-                }
-            }
+            AssignUnscheduledRequestsToInProcNode(responses, idleNodes, request => IsTraversalRequest(request.BuildRequest));
         }
 
         /// <summary>
@@ -986,13 +970,18 @@ private void AssignUnscheduledRequestsByTraversalsFirst(List<ScheduleResponse> r
         /// paying the IPC cost and re-evaluating them on out of proc nodes (they are guaranteed to be evaluated in the Scheduler process).
         /// </summary>
         private void AssignUnscheduledProxyBuildRequestsToInProcNode(List<ScheduleResponse> responses, HashSet<int> idleNodes)
+        {
+            AssignUnscheduledRequestsToInProcNode(responses, idleNodes, request => request.IsProxyBuildRequest());
+        }
+
+        private void AssignUnscheduledRequestsToInProcNode(List<ScheduleResponse> responses, HashSet<int> idleNodes, Func<SchedulableRequest, bool> shouldBeScheduled)
         {
             if (idleNodes.Contains(InProcNodeId))
             {
                 List<SchedulableRequest> unscheduledRequests = new List<SchedulableRequest>(_schedulingData.UnscheduledRequestsWhichCanBeScheduled);
                 foreach (SchedulableRequest request in unscheduledRequests)
                 {
-                    if (CanScheduleRequestToNode(request, InProcNodeId) && request.IsProxyBuildRequest())
+                    if (CanScheduleRequestToNode(request, InProcNodeId) && shouldBeScheduled(request))
                     {
                         AssignUnscheduledRequestToNode(request, InProcNodeId, responses);
                         idleNodes.Remove(InProcNodeId);
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 022b6acf9d0..19f75d8da72 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -56,6 +56,12 @@ public SchedulingPlan(IConfigCache configCache, SchedulingData schedulingData)
             this.MaximumConfigurationId = BuildRequestConfiguration.InvalidConfigurationId;
         }
 
+        public PlanConfigData GetConfiguration(int configId)
+        {
+            _configPathToData.TryGetValue(_configCache[configId].ProjectFullPath, out PlanConfigData data);
+            return data;
+        }
+
         /// <summary>
         /// Returns true if a valid plan was read, false otherwise.
         /// </summary>
@@ -104,11 +110,11 @@ public void WritePlan(int submissionId, ILoggingService loggingService, BuildEve
                     Dictionary<int, double> accumulatedTimeByConfiguration = new Dictionary<int, double>();
                     RecursiveAccumulateConfigurationTimes(rootRequest, accumulatedTimeByConfiguration);
 
-                    List<int> configurationsInOrder = new List<int>(accumulatedTimeByConfiguration.Keys);
-                    configurationsInOrder.Sort();
-                    foreach (int configId in configurationsInOrder)
+                    List<KeyValuePair<int, double>> configurationsInOrder = new(accumulatedTimeByConfiguration);
+                    configurationsInOrder.Sort((KeyValuePair<int, double> l, KeyValuePair<int, double> r) => Comparer<int>.Default.Compare(l.Key, r.Key));
+                    foreach (KeyValuePair<int, double> configuration in configurationsInOrder)
                     {
-                        file.WriteLine(String.Format(CultureInfo.InvariantCulture, "{0} {1} {2}", configId, accumulatedTimeByConfiguration[configId], _configCache[configId].ProjectFullPath));
+                        file.WriteLine(String.Format(CultureInfo.InvariantCulture, "{0} {1} {2}", configuration.Key, configuration.Value, _configCache[configuration.Key].ProjectFullPath));
                     }
 
                     file.WriteLine();
@@ -192,80 +198,6 @@ public int GetConfigIdForPath(string configPath)
             return config.ConfigId;
         }
 
-        /// <summary>
-        /// Given a list of configuration IDs, returns the id of the config with the greatest number of immediate references.
-        /// </summary>
-        /// <param name="configsToSchedule">The set of configurations to consider.</param>
-        /// <returns>The id of the configuration with the most immediate references.</returns>
-        public int GetConfigWithGreatestNumberOfReferences(IEnumerable<int> configsToSchedule)
-        {
-            return GetConfigWithComparison(configsToSchedule, delegate (PlanConfigData left, PlanConfigData right) { return Comparer<int>.Default.Compare(left.ReferencesCount, right.ReferencesCount); });
-        }
-
-        /// <summary>
-        /// Given a list of real configuration IDs, returns the id of the config with the largest plan time.
-        /// </summary>
-        public int GetConfigWithGreatestPlanTime(IEnumerable<int> realConfigsToSchedule)
-        {
-            return GetConfigWithComparison(realConfigsToSchedule, delegate (PlanConfigData left, PlanConfigData right) { return Comparer<double>.Default.Compare(left.TotalPlanTime, right.TotalPlanTime); });
-        }
-
-        /// <summary>
-        /// Determines how many references a config with a particular path has.
-        /// </summary>
-        public int GetReferencesCountForConfigByPath(string configFullPath)
-        {
-            PlanConfigData data;
-            if (!_configPathToData.TryGetValue(configFullPath, out data))
-            {
-                return 0;
-            }
-
-            return data.ReferencesCount;
-        }
-
-        /// <summary>
-        /// Advances the state of the plan by removing the specified config from all paths
-        /// </summary>
-        public void VisitConfig(string configName)
-        {
-            PlanConfigData data;
-            if (!_configPathToData.TryGetValue(configName, out data))
-            {
-                return;
-            }
-
-            // UNDONE: Parallelize
-            foreach (List<Stack<PlanConfigData>> paths in _configIdToPaths.Values)
-            {
-                foreach (Stack<PlanConfigData> path in paths)
-                {
-                    if (path.Count > 0 && path.Peek() == data)
-                    {
-                        path.Pop();
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Advances the state of the plan by zeroing out the time spend on the config.
-        /// </summary>
-        public void CompleteConfig(string configName)
-        {
-            PlanConfigData data;
-            if (!_configPathToData.TryGetValue(configName, out data))
-            {
-                return;
-            }
-
-            ErrorUtilities.VerifyThrow(data.AccumulatedTimeOfReferences < 0.00001, "Unexpected config completed before references were completed.");
-
-            // Recursively subtract the amount of time from this config's referrers.
-            data.RecursivelyApplyReferenceTimeToReferrers(-data.AccumulatedTime);
-            data.AccumulatedTime = 0;
-        }
-
         /// <summary>
         /// Gets the name of the plan file for a specified submission.
         /// </summary>
@@ -279,39 +211,6 @@ private string GetPlanName(SchedulableRequest rootRequest)
             return _configCache[rootRequest.BuildRequest.ConfigurationId].ProjectFullPath + ".buildplan";
         }
 
-        /// <summary>
-        /// Returns the config id with the greatest value according to the comparer.
-        /// </summary>
-        private int GetConfigWithComparison(IEnumerable<int> realConfigsToSchedule, Comparison<PlanConfigData> comparer)
-        {
-            PlanConfigData bestConfig = null;
-            int bestRealConfigId = BuildRequestConfiguration.InvalidConfigurationId;
-
-            foreach (int realConfigId in realConfigsToSchedule)
-            {
-                PlanConfigData configToConsider;
-                if (!_configPathToData.TryGetValue(_configCache[realConfigId].ProjectFullPath, out configToConsider))
-                {
-                    // By default we assume configs we don't know about aren't as important, and will only schedule them
-                    // if nothing else is suitable
-                    if (bestRealConfigId == BuildRequestConfiguration.InvalidConfigurationId)
-                    {
-                        bestRealConfigId = realConfigId;
-                    }
-
-                    continue;
-                }
-
-                if (bestConfig == null || (comparer(bestConfig, configToConsider) < 0))
-                {
-                    bestConfig = configToConsider;
-                    bestRealConfigId = realConfigId;
-                }
-            }
-
-            return bestRealConfigId;
-        }
-
         /// <summary>
         /// Analyzes the plan data which has been read.
         /// </summary>
@@ -334,12 +233,12 @@ private void AnalyzeData()
         /// </summary>
         private void DetermineConfigsWithGreatestPlanTime()
         {
-            List<int> projectsInOrderOfTotalPlanTime = new List<int>(_configIdToData.Keys);
-            projectsInOrderOfTotalPlanTime.Sort(delegate (int left, int right) { return -Comparer<double>.Default.Compare(_configIdToData[left].TotalPlanTime, _configIdToData[right].TotalPlanTime); });
-            foreach (int configId in projectsInOrderOfTotalPlanTime)
+            List<KeyValuePair<int, PlanConfigData>> projectsInOrderOfTotalPlanTime = new(_configIdToData);
+            projectsInOrderOfTotalPlanTime.Sort((left, right) => Comparer<double>.Default.Compare(right.Value.TotalPlanTime, left.Value.TotalPlanTime));
+            foreach (KeyValuePair<int, PlanConfigData> configuration in projectsInOrderOfTotalPlanTime)
             {
-                PlanConfigData config = _configIdToData[configId];
-                Console.WriteLine("{0}: {1} ({2} referrers) {3}", configId, config.TotalPlanTime, config.ReferrerCount, config.ConfigFullPath);
+                PlanConfigData config = configuration.Value;
+                Console.WriteLine("{0}: {1} ({2} referrers) {3}", configuration.Key, config.TotalPlanTime, config.ReferrerCount, config.ConfigFullPath);
                 foreach (PlanConfigData referrer in config.Referrers)
                 {
                     Console.WriteLine("     {0} {1}", referrer.ConfigId, referrer.ConfigFullPath);
@@ -357,11 +256,11 @@ private void DetermineConfigsWithGreatestPlanTime()
         private void DetermineConfigsWithTheMostImmediateReferences()
         {
             Console.WriteLine("Projects with the most immediate children:");
-            List<int> projectsInOrderOfImmediateChildCount = new List<int>(_configIdToData.Keys);
-            projectsInOrderOfImmediateChildCount.Sort(delegate (int left, int right) { return -Comparer<int>.Default.Compare(_configIdToData[left].ReferencesCount, _configIdToData[right].ReferencesCount); });
-            foreach (int configId in projectsInOrderOfImmediateChildCount)
+            List<KeyValuePair<int, PlanConfigData>> projectsInOrderOfImmediateChildCount = new(_configIdToData);
+            projectsInOrderOfImmediateChildCount.Sort((left, right) => Comparer<int>.Default.Compare(right.Value.ReferencesCount, left.Value.ReferencesCount));
+            foreach (KeyValuePair<int, PlanConfigData> configuration in projectsInOrderOfImmediateChildCount)
             {
-                Console.WriteLine("{0}: {1} {2}", configId, _configIdToData[configId].ReferencesCount, _configIdToData[configId].ConfigFullPath);
+                Console.WriteLine("{0}: {1} {2}", configuration.Key, configuration.Value.ReferencesCount, configuration.Value.ConfigFullPath);
             }
 
             Console.WriteLine();
@@ -577,7 +476,7 @@ private void RecursiveAccumulateConfigurationTimes(SchedulableRequest request, D
         /// <summary>
         /// The data associated with a config as read from a build plan.
         /// </summary>
-        private class PlanConfigData
+        internal class PlanConfigData
         {
             /// <summary>
             /// The configuration id.
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 8b5f572381a..a684c59618a 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -317,13 +317,12 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
 
                 SdkResultFactory resultFactory = new SdkResultFactory(sdk);
 
-                SdkResult result;
+                SdkResult result = null;
 
                 try
                 {
                     MSBuildEventSource.Log.SdkResolverResolveSdkStart();
                     result = (SdkResult)sdkResolver.Resolve(sdk, context, resultFactory);
-                    MSBuildEventSource.Log.SdkResolverResolveSdkStop(sdkResolver.Name, sdk.Name, solutionPath, projectPath, result?.Path, result?.Success ?? false);
                 }
                 catch (Exception e) when ((e is FileNotFoundException || e is FileLoadException) && sdkResolver.GetType().GetTypeInfo().Name.Equals("NuGetSdkResolver", StringComparison.Ordinal))
                 {
@@ -339,6 +338,10 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
                     // The SDK resolver "{0}" failed while attempting to resolve the SDK "{1}": {2}
                     throw new SdkResolverException("SDKResolverFailed", sdkResolver, sdk, e, sdkResolver.Name, sdk.ToString(), e.ToString());
                 }
+                finally
+                {
+                    MSBuildEventSource.Log.SdkResolverResolveSdkStop(sdkResolver.Name, sdk.Name, solutionPath, projectPath, result?.Path, result?.Success ?? false);
+                }
 
                 SetResolverState(submissionId, sdkResolver, context.State);
 
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index ca443451880..149ec426518 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -598,9 +598,9 @@ internal static BuildResult FactoryForDeserialization(ITranslator translator)
         /// </summary>
         internal void CacheIfPossible()
         {
-            foreach (string target in _resultsByTarget.Keys)
+            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget)
             {
-                _resultsByTarget[target].CacheItems(ConfigurationId, target);
+                targetResultPair.Value.CacheItems(ConfigurationId, targetResultPair.Key);
             }
         }
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index eed1d5872a3..705ca12979e 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
+using System.Linq;
 using System.Reflection;
 #if FEATURE_APPDOMAIN
 using System.Runtime.Remoting;
@@ -123,7 +124,7 @@ internal class TaskExecutionHost : ITaskExecutionHost, IDisposable
         private List<TaskItem> _remotedTaskItems;
 
         /// <summary>
-        /// We need access to the build component host so that we can get at the 
+        /// We need access to the build component host so that we can get at the
         /// task host node provider when running a task wrapped by TaskHostTask
         /// </summary>
         private readonly IBuildComponentHost _buildComponentHost;
@@ -368,6 +369,11 @@ bool ITaskExecutionHost.SetTaskParameters(IDictionary<string, (string, ElementLo
                 }
             }
 
+            if (this.TaskInstance is IIncrementalTask incrementalTask)
+            {
+                incrementalTask.FailIfNotIncremental = _buildComponentHost.BuildParameters.Question;
+            }
+
             if (taskInitialized)
             {
                 // See if any required properties were not set
@@ -813,15 +819,15 @@ private string[] GetValueOutputs(TaskPropertyInfo parameter)
         /// 2) checks the global task declarations (in *.TASKS in MSbuild bin dir), searching by exact name and task identity parameters
         /// 3) checks the tasks declared by the project, searching by fuzzy match (missing namespace, etc.) and task identity parameters
         /// 4) checks the global task declarations (in *.TASKS in MSbuild bin dir), searching by fuzzy match (missing namespace, etc.) and task identity parameters
-        /// 5) 1-4 again in order without the task identity parameters, to gather additional information for the user (if the task identity 
-        ///    parameters don't match, it is an error, but at least we can return them a more useful error in this case than just "could not 
+        /// 5) 1-4 again in order without the task identity parameters, to gather additional information for the user (if the task identity
+        ///    parameters don't match, it is an error, but at least we can return them a more useful error in this case than just "could not
         ///    find task")
-        /// 
+        ///
         /// The search ordering is meant to reduce the number of assemblies we scan, because loading assemblies can be expensive.
         /// The tasks and assemblies declared by the project are scanned first, on the assumption that if the project declared
         /// them, they are likely used.
-        /// 
-        /// If the set of task identity parameters are defined, only tasks that match that identity are chosen. 
+        ///
+        /// If the set of task identity parameters are defined, only tasks that match that identity are chosen.
         /// </summary>
         /// <returns>The Type of the task, or null if it was not found.</returns>
         private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskIdentityParameters)
@@ -874,7 +880,7 @@ private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskId
                                 taskRuntime ?? XMakeAttributes.MSBuildRuntimeValues.any,
                                 taskArchitecture ?? XMakeAttributes.MSBuildArchitectureValues.any);
 
-                        // if we've logged this error, even though we've found something, we want to act like we didn't.  
+                        // if we've logged this error, even though we've found something, we want to act like we didn't.
                         return null;
                     }
                 }
@@ -1240,8 +1246,8 @@ private bool InitializeTaskVectorParameter(
             bool success;
             IList<TaskItem> finalTaskItems = _batchBucket.Expander.ExpandIntoTaskItemsLeaveEscaped(parameterValue, ExpanderOptions.ExpandAll, parameterLocation);
 
-            // If there were no items, don't change the parameter's value.  EXCEPT if it's marked as a required 
-            // parameter, in which case we made an explicit decision to pass in an empty array.  This is 
+            // If there were no items, don't change the parameter's value.  EXCEPT if it's marked as a required
+            // parameter, in which case we made an explicit decision to pass in an empty array.  This is
             // to avoid project authors having to add Conditions on all their tasks to avoid calling them
             // when a particular item list is empty.  This way, we just call the task with an empty list,
             // the task will loop over an empty list, and return quickly.
@@ -1367,7 +1373,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
 
                             if (outputAsProjectItem != null)
                             {
-                                // The common case -- all items involved are Microsoft.Build.Execution.ProjectItemInstance.TaskItems.  
+                                // The common case -- all items involved are Microsoft.Build.Execution.ProjectItemInstance.TaskItems.
                                 // Furthermore, because that is true, we know by definition that they also implement ITaskItem2.
                                 newItem = new ProjectItemInstance(_projectInstance, outputTargetName, outputAsProjectItem.IncludeEscaped, parameterLocationEscaped);
 
@@ -1377,25 +1383,21 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                             {
                                 if (output is ITaskItem2 outputAsITaskItem2)
                                 {
-                                    // Probably a Microsoft.Build.Utilities.TaskItem.  Not quite as good, but we can still preserve escaping. 
+                                    // Probably a Microsoft.Build.Utilities.TaskItem.  Not quite as good, but we can still preserve escaping.
                                     newItem = new ProjectItemInstance(_projectInstance, outputTargetName, outputAsITaskItem2.EvaluatedIncludeEscaped, parameterLocationEscaped);
 
-                                    // It would be nice to be copy-on-write here, but Utilities.TaskItem doesn't know about CopyOnWritePropertyDictionary. 
-                                    foreach (DictionaryEntry entry in outputAsITaskItem2.CloneCustomMetadataEscaped())
-                                    {
-                                        newItem.SetMetadataOnTaskOutput((string)entry.Key, (string)entry.Value);
-                                    }
+                                    // It would be nice to be copy-on-write here, but Utilities.TaskItem doesn't know about CopyOnWritePropertyDictionary.
+                                    newItem.SetMetadataOnTaskOutput(outputAsITaskItem2.CloneCustomMetadataEscaped().Cast<KeyValuePair<string, string>>());
                                 }
                                 else
                                 {
-                                    // Not a ProjectItemInstance.TaskItem or even a ITaskItem2, so we have to fake it.  
-                                    // Setting an item spec expects the escaped value, as does setting metadata. 
+                                    // Not a ProjectItemInstance.TaskItem or even a ITaskItem2, so we have to fake it.
+                                    // Setting an item spec expects the escaped value, as does setting metadata.
                                     newItem = new ProjectItemInstance(_projectInstance, outputTargetName, EscapingUtilities.Escape(output.ItemSpec), parameterLocationEscaped);
 
-                                    foreach (DictionaryEntry entry in output.CloneCustomMetadata())
-                                    {
-                                        newItem.SetMetadataOnTaskOutput((string)entry.Key, EscapingUtilities.Escape((string)entry.Value));
-                                    }
+                                    newItem.SetMetadataOnTaskOutput(output.CloneCustomMetadata()
+                                        .Cast<DictionaryEntry>()
+                                        .Select(x => new KeyValuePair<string, string>((string)x.Key, EscapingUtilities.Escape((string)x.Value))));
                                 }
                             }
 
@@ -1418,7 +1420,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                     // to store an ITaskItem array in a property, join all the item-specs with semi-colons to make the
                     // property value, and ignore/discard the attributes on the ITaskItems.
                     //
-                    // An empty ITaskItem[] should create a blank value property, for compatibility.                 
+                    // An empty ITaskItem[] should create a blank value property, for compatibility.
                     StringBuilder joinedOutputs = (outputs.Length == 0) ? new StringBuilder() : null;
 
                     foreach (ITaskItem output in outputs)
@@ -1463,7 +1465,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
         /// </summary>
         private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string outputTargetName, string[] outputs, ElementLocation parameterLocation, TaskPropertyInfo parameter)
         {
-            // if the task has generated outputs (if it didn't, don't do anything)            
+            // if the task has generated outputs (if it didn't, don't do anything)
             if (outputs != null)
             {
                 if (outputTargetIsItem)
@@ -1494,7 +1496,7 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                     // to store an object array in a property, join all the string representations of the objects with
                     // semi-colons to make the property value
                     //
-                    // An empty ITaskItem[] should create a blank value property, for compatibility.                 
+                    // An empty ITaskItem[] should create a blank value property, for compatibility.
                     StringBuilder joinedOutputs = (outputs.Length == 0) ? new StringBuilder() : null;
 
                     foreach (string output in outputs)
diff --git a/src/Build/Collections/ConvertingEnumerable.cs b/src/Build/Collections/ConvertingEnumerable.cs
index b4b3e1d7058..e5933cd53dc 100644
--- a/src/Build/Collections/ConvertingEnumerable.cs
+++ b/src/Build/Collections/ConvertingEnumerable.cs
@@ -82,7 +82,7 @@ internal ConvertingEnumerator(IEnumerator<TFrom2> backingEnumerator, Func<TFrom2
             /// <summary>
             /// Get the current element, converted
             /// </summary>
-            public TTo2 Current
+            public readonly TTo2 Current
             {
                 get
                 {
diff --git a/src/Build/Collections/WeakValueDictionary.cs b/src/Build/Collections/WeakValueDictionary.cs
index c4c04d802eb..34d1267a234 100644
--- a/src/Build/Collections/WeakValueDictionary.cs
+++ b/src/Build/Collections/WeakValueDictionary.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
@@ -15,7 +16,7 @@ namespace Microsoft.Build.Collections
     /// </summary>
     /// <typeparam name="K">Type of key</typeparam>
     /// <typeparam name="V">Type of value, without the WeakReference wrapper.</typeparam>
-    internal class WeakValueDictionary<K, V>
+    internal class WeakValueDictionary<K, V> : IEnumerable<KeyValuePair<K, V>>
         where V : class
     {
         /// <summary>
@@ -233,5 +234,22 @@ public void Clear()
         {
             _dictionary.Clear();
         }
+
+        public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
+        {
+            foreach (KeyValuePair<K, WeakReference<V>> kvp in _dictionary)
+            {
+                if (kvp.Value is null)
+                {
+                    yield return new KeyValuePair<K, V>(kvp.Key, null);
+                }
+                else if (kvp.Value.TryGetTarget(out V target))
+                {
+                    yield return new KeyValuePair<K, V>(kvp.Key, target);
+                }
+            }
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
     }
 }
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 4eb8f8edb91..6d8d7a394b6 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -742,7 +742,7 @@ internal ProjectElementSiblingEnumerable(ProjectElement initial, bool forwards =
             /// <summary>
             /// Get enumerator
             /// </summary>
-            public IEnumerator<ProjectElement> GetEnumerator()
+            public readonly IEnumerator<ProjectElement> GetEnumerator()
             {
                 return _enumerator;
             }
@@ -808,7 +808,7 @@ object System.Collections.IEnumerator.Current
                 /// <summary>
                 /// Dispose. Do nothing.
                 /// </summary>
-                public void Dispose()
+                public readonly void Dispose()
                 {
                 }
 
diff --git a/src/Build/Construction/ProjectMetadataElement.cs b/src/Build/Construction/ProjectMetadataElement.cs
index a8ba5cd5c10..473f39c0476 100644
--- a/src/Build/Construction/ProjectMetadataElement.cs
+++ b/src/Build/Construction/ProjectMetadataElement.cs
@@ -100,13 +100,13 @@ public string Value
         /// Creates an unparented ProjectMetadataElement, wrapping an unparented XmlElement.
         /// Caller should then ensure the element is added to a parent.
         /// </summary>
-        internal static ProjectMetadataElement CreateDisconnected(string name, ProjectRootElement containingProject)
+        internal static ProjectMetadataElement CreateDisconnected(string name, ProjectRootElement containingProject, ElementLocation location = null)
         {
             XmlUtilities.VerifyThrowArgumentValidElementName(name);
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name), "ItemSpecModifierCannotBeCustomMetadata", name);
             ErrorUtilities.VerifyThrowInvalidOperation(!XMakeElements.ReservedItemNames.Contains(name), "CannotModifyReservedItemMetadata", name);
 
-            XmlElementWithLocation element = containingProject.CreateElement(name);
+            XmlElementWithLocation element = containingProject.CreateElement(name, location);
 
             return new ProjectMetadataElement(element, containingProject);
         }
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index b0ff4459c4a..626751e11cf 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -1327,13 +1327,22 @@ public ProjectMetadataElement CreateMetadataElement(string name)
         /// Caller must add it to the location of choice in the project.
         /// </summary>
         public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue)
+        {
+            return this.CreateMetadataElement(name, unevaluatedValue, null);
+        }
+
+        /// <summary>
+        /// Creates a metadata node.
+        /// Caller must add it to the location of choice in the project.
+        /// </summary>
+        public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue, ElementLocation location)
         {
             if (Link != null)
             {
                 return RootLink.CreateMetadataElement(name, unevaluatedValue);
             }
 
-            ProjectMetadataElement metadatum = ProjectMetadataElement.CreateDisconnected(name, this);
+            ProjectMetadataElement metadatum = ProjectMetadataElement.CreateDisconnected(name, this, location);
 
             metadatum.Value = unevaluatedValue;
 
@@ -1785,14 +1794,23 @@ internal static ProjectRootElement OpenProjectOrSolution(string fullPath, IDicti
             return projectRootElement;
         }
 
+        /// <summary>
+        /// Creates a metadata node.
+        /// Caller must add it to the location of choice in the project.
+        /// </summary>
+        internal ProjectMetadataElement CreateMetadataElement(XmlAttributeWithLocation attribute)
+        {
+            return CreateMetadataElement(attribute.Name, attribute.Value, attribute.Location);
+        }
+
         /// <summary>
         /// Creates a XmlElement with the specified name in the document
         /// containing this project.
         /// </summary>
-        internal XmlElementWithLocation CreateElement(string name)
+        internal XmlElementWithLocation CreateElement(string name, ElementLocation location = null)
         {
             ErrorUtilities.VerifyThrow(Link == null, "External project");
-            return (XmlElementWithLocation)XmlDocument.CreateElement(name, XmlNamespace);
+            return (XmlElementWithLocation)XmlDocument.CreateElement(name, XmlNamespace, location);
         }
 
         /// <summary>
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 02b2bc09e15..7b3d3c05b43 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -239,6 +239,23 @@ internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement
             msbuildProject.AppendChild(solutionConfigurationProperties);
             solutionConfigurationProperties.Condition = GetConditionStringForConfiguration(solutionConfiguration);
 
+            string escapedSolutionConfigurationContents = GetSolutionConfiguration(solutionFile, solutionConfiguration);
+
+            solutionConfigurationProperties.AddProperty("CurrentSolutionConfigurationContents", escapedSolutionConfigurationContents);
+
+            msbuildProject.AddItem(
+                "SolutionConfiguration",
+                solutionConfiguration.FullName,
+                new Dictionary<string, string>
+                {
+                    { "Configuration", solutionConfiguration.ConfigurationName },
+                    { "Platform", solutionConfiguration.PlatformName },
+                    { "Content", escapedSolutionConfigurationContents },
+                });
+        }
+
+        internal static string GetSolutionConfiguration(SolutionFile solutionFile, SolutionConfigurationInSolution solutionConfiguration)
+        {
             var solutionConfigurationContents = new StringBuilder(1024);
             var settings = new XmlWriterSettings
             {
@@ -247,7 +264,7 @@ internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement
             };
             using (XmlWriter xw = XmlWriter.Create(solutionConfigurationContents, settings))
             {
-                // TODO: fix code clone for parsing CurrentSolutionConfiguration xml: https://github.com/dotnet/msbuild/issues/6751
+                // TODO: Consider augmenting SolutionConfiguration with this code
                 xw.WriteStartElement("SolutionConfiguration");
 
                 // add a project configuration entry for each project in the solution
@@ -292,19 +309,8 @@ internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement
                 xw.WriteEndElement(); // </SolutionConfiguration>
             }
 
-            var escapedSolutionConfigurationContents = EscapingUtilities.Escape(solutionConfigurationContents.ToString());
-
-            solutionConfigurationProperties.AddProperty("CurrentSolutionConfigurationContents", escapedSolutionConfigurationContents);
-
-            msbuildProject.AddItem(
-                "SolutionConfiguration",
-                solutionConfiguration.FullName,
-                new Dictionary<string, string>
-                {
-                    { "Configuration", solutionConfiguration.ConfigurationName },
-                    { "Platform", solutionConfiguration.PlatformName },
-                    { "Content", escapedSolutionConfigurationContents },
-                });
+            string escapedSolutionConfigurationContents = EscapingUtilities.Escape(solutionConfigurationContents.ToString());
+            return escapedSolutionConfigurationContents;
         }
 
         /// <summary>
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index c3df653db94..09d2321cad4 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -257,12 +257,12 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
+            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
         private Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
-            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -273,7 +273,7 @@ private Project(ProjectRootElement xml, IDictionary<string, string> globalProper
             implementation = defaultImplementation;
 
             _directoryCacheFactory = directoryCacheFactory;
-            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext, interactive);
         }
 
         /// <summary>
@@ -351,12 +351,12 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
+            : this(xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
         private Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
-            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xmlReader, nameof(xmlReader));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -367,7 +367,7 @@ private Project(XmlReader xmlReader, IDictionary<string, string> globalPropertie
             implementation = defaultImplementation;
 
             _directoryCacheFactory = directoryCacheFactory;
-            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext, interactive);
         }
 
         /// <summary>
@@ -447,12 +447,12 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
         public Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, evaluationContext: null, directoryCacheFactory: null, interactive: false)
         {
         }
 
         private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
-            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -469,7 +469,7 @@ private Project(string projectFile, IDictionary<string, string> globalProperties
             // seems the XmlReader based one should also clean the same way.
             try
             {
-                defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+                defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext, interactive);
             }
             catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
             {
@@ -500,7 +500,8 @@ public static Project FromFile(string file, ProjectOptions options)
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
-                options.DirectoryCacheFactory);
+                options.DirectoryCacheFactory,
+                options.Interactive);
         }
 
         /// <summary>
@@ -518,7 +519,8 @@ public static Project FromProjectRootElement(ProjectRootElement rootElement, Pro
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
-                options.DirectoryCacheFactory);
+                options.DirectoryCacheFactory,
+                options.Interactive);
         }
 
         /// <summary>
@@ -536,7 +538,8 @@ public static Project FromXmlReader(XmlReader reader, ProjectOptions options)
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
                 options.EvaluationContext,
-                options.DirectoryCacheFactory);
+                options.DirectoryCacheFactory,
+                options.Interactive);
         }
 
         /// <summary>
@@ -1871,6 +1874,11 @@ private class ProjectImpl : ProjectLink, IProjectLinkInternal
             /// </summary>
             private RenameHandlerDelegate _renameHandler;
 
+            /// <summary>
+            /// Indicates if the process of loading the project is allowed to interact with the user.
+            /// </summary>
+            private bool _interactive = false;
+
             /// <summary>
             ///
             /// </summary>
@@ -2550,7 +2558,7 @@ public static CumulativeRemoveElementData Create()
                     };
                 }
 
-                public void AccumulateInformationFromRemoveItemSpec(EvaluationItemSpec removeSpec)
+                public readonly void AccumulateInformationFromRemoveItemSpec(EvaluationItemSpec removeSpec)
                 {
                     IEnumerable<string> removeSpecFragmentStrings = removeSpec.FlattenFragmentsAsStrings();
                     var removeGlob = removeSpec.ToMSBuildGlob();
@@ -3733,7 +3741,8 @@ private void Reevaluate(
                     s_buildEventContext,
                     evaluationContext.SdkResolverService,
                     BuildEventContext.InvalidSubmissionId,
-                    evaluationContext);
+                    evaluationContext,
+                    _interactive);
 
                 ErrorUtilities.VerifyThrow(LastEvaluationId != BuildEventContext.InvalidEvaluationId, "Evaluation should produce an evaluation ID");
 
@@ -3766,7 +3775,7 @@ private void Reevaluate(
             /// Global properties may be null.
             /// Tools version may be null.
             /// </summary>
-            internal void Initialize(IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+            internal void Initialize(IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext, bool interactive)
             {
                 Xml.MarkAsExplicitlyLoaded();
 
@@ -3801,6 +3810,7 @@ internal void Initialize(IDictionary<string, string> globalProperties, string to
                 _data = new Data(Owner, globalPropertiesCollection, toolsVersion, subToolsetVersion, canEvaluateElementsWithFalseConditions);
 
                 _loadSettings = loadSettings;
+                _interactive = interactive;
 
                 ErrorUtilities.VerifyThrow(LastEvaluationId == BuildEventContext.InvalidEvaluationId, "This is the first evaluation therefore the last evaluation id is invalid");
 
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index 5cbad98cb06..cfffb456d72 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -26,7 +26,7 @@ namespace Microsoft.Build.Evaluation
     /// ProjectMetadataElement, and these can be added, removed, and modified.
     /// </remarks>
     [DebuggerDisplay("{_itemType} #Metadata={MetadataCount}")]
-    public class ProjectItemDefinition : IKeyed, IMetadataTable, IItemDefinition<ProjectMetadata>, IProjectMetadataParent
+    public class ProjectItemDefinition : IKeyed, IMetadataTable, IItemDefinition<ProjectMetadata>, IProjectMetadataParent, IItemTypeDefinition
     {
         /// <summary>
         /// Project that this item definition lives in.
diff --git a/src/Build/Definition/ProjectOptions.cs b/src/Build/Definition/ProjectOptions.cs
index 5c5e3cee3f9..c03507b3d3c 100644
--- a/src/Build/Definition/ProjectOptions.cs
+++ b/src/Build/Definition/ProjectOptions.cs
@@ -31,7 +31,7 @@ public class ProjectOptions
         public string SubToolsetVersion { get; set; }
 
         /// <summary>
-        /// The <see cref="ProjectCollection"/> the project is added to. Default is <see cref="ProjectCollection.GlobalProjectCollection"/>/>
+        /// The <see cref="ProjectCollection"/> the project is added to. Default is <see cref="ProjectCollection.GlobalProjectCollection"/>.
         /// </summary>
         public ProjectCollection ProjectCollection { get; set; }
 
@@ -49,5 +49,10 @@ public class ProjectOptions
         /// Provides <see cref="IDirectoryCache"/> to be used for evaluation.
         /// </summary>
         public IDirectoryCacheFactory DirectoryCacheFactory { get; set; }
+
+        /// <summary>
+        /// Gets or sets a value indicating if loading the project is allowed to interact with the user.
+        /// </summary>
+        public bool Interactive { get; set; }
     }
 }
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 9c064f5e68f..d7d81e88dc6 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -817,7 +817,7 @@ private MSBuildExtensionsPathReferenceKind(string value)
         /// <summary>
         /// Returns the corresponding property name - eg. "$(MSBuildExtensionsPath32)"
         /// </summary>
-        public string MSBuildPropertyName => String.Format($"$({StringRepresentation})");
+        public readonly string MSBuildPropertyName => String.Format($"$({StringRepresentation})");
 
         /// <summary>
         /// Tries to find a reference to MSBuildExtensionsPath* property in the given string
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index bbc34c86a57..88b0de71dbb 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.IO;
+using System.Threading;
 using System.Xml;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -59,6 +60,13 @@ internal class XmlDocumentWithLocation : XmlDocument
         /// </summary>
         private bool? _loadAsReadOnly;
 
+        /// <summary>
+        /// Location of the element to be created via 'CreateElement' call. So that we can
+        ///  receive and use location from the caller up the stack even if we are being called via
+        /// <see cref="XmlDocument"/> internal methods.
+        /// </summary>
+        private readonly AsyncLocal<ElementLocation> _elementLocation = new AsyncLocal<ElementLocation>();
+
         /// <summary>
         /// Constructor
         /// </summary>
@@ -180,6 +188,31 @@ public override void Load(string fullPath)
             }
         }
 
+        /// <summary>
+        /// Called during parse, to add an element.
+        /// </summary>
+        /// <remarks>
+        /// We create our own kind of element, that we can give location information to.
+        /// In order to pass the location through the callchain, that contains XmlDocument function
+        ///  that then calls back to our XmlDocumentWithLocation (so we cannot use call stack via passing via parameters),
+        ///  we use async local field, that simulates variable on call stack.
+        /// </remarks>
+        internal XmlElement CreateElement(string localName, string namespaceURI, ElementLocation location)
+        {
+            if (location != null)
+            {
+                this._elementLocation.Value = location;
+            }
+            try
+            {
+                return CreateElement(localName, namespaceURI);
+            }
+            finally
+            {
+                this._elementLocation.Value = null;
+            }
+        }
+
         /// <summary>
         /// Called during load, to add an element.
         /// </summary>
@@ -192,6 +225,10 @@ public override XmlElement CreateElement(string prefix, string localName, string
             {
                 return new XmlElementWithLocation(prefix, localName, namespaceURI, this, _reader.LineNumber, _reader.LinePosition);
             }
+            else if (_elementLocation?.Value != null)
+            {
+                return new XmlElementWithLocation(prefix, localName, namespaceURI, this, _elementLocation.Value.Line, _elementLocation.Value.Column);
+            }
 
             // Must be a subsequent edit; we can't provide location information
             return new XmlElementWithLocation(prefix, localName, namespaceURI, this);
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 5e3147ec52f..459217b3389 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -88,6 +88,13 @@ internal enum ExpanderOptions
         /// </summary>
         Truncate = 0x40,
 
+        /// <summary>
+        /// Issues build message if item references unqualified or qualified metadata odf self - as this can lead to unintended expansion and
+        ///  cross-combination of other items.
+        /// More info: https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-batching#item-batching-on-self-referencing-metadata
+        /// </summary>
+        LogOnItemMetadataSelfReference = 0x80,
+
         /// <summary>
         /// Expand only properties and then item lists
         /// </summary>
@@ -203,7 +210,7 @@ public void Add(ReadOnlyMemory<char> span)
             /// concatenation of the string representation of the values, each additionally subjected
             /// to file path adjustment.
             /// </returns>
-            public object GetResult()
+            public readonly object GetResult()
             {
                 CheckDisposed();
                 if (_firstObject != null)
@@ -228,7 +235,7 @@ public void Dispose()
             /// <summary>
             /// Throws <see cref="ObjectDisposedException"/> if this concatenator is already disposed.
             /// </summary>
-            private void CheckDisposed() =>
+            private readonly void CheckDisposed() =>
                 ErrorUtilities.VerifyThrowObjectDisposed(!_disposed, nameof(SpanBasedConcatenator));
 
             /// <summary>
@@ -441,7 +448,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
 
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
-            string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
+            string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation, loggingContext);
             result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem, loggingContext);
             result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
@@ -871,8 +878,9 @@ private static class MetadataExpander
             /// <param name="metadata">The metadata to be expanded.</param>
             /// <param name="options">Used to specify what to expand.</param>
             /// <param name="elementLocation">The location information for error reporting purposes.</param>
+            /// <param name="loggingContext">The logging context for this operation.</param>
             /// <returns>The string with item metadata expanded in-place, escaped.</returns>
-            internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTable metadata, ExpanderOptions options, IElementLocation elementLocation)
+            internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTable metadata, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
             {
                 try
                 {
@@ -896,7 +904,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                     {
                         // if there are no item vectors in the string
                         // run a simpler Regex to find item metadata references
-                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options);
+                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options, elementLocation, loggingContext);
                         result = RegularExpressions.ItemMetadataPattern.Value.Replace(expression, new MatchEvaluator(matchEvaluator.ExpandSingleMetadata));
                     }
                     else
@@ -915,7 +923,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                         using SpanBasedStringBuilder finalResultBuilder = Strings.GetSpanBasedStringBuilder();
 
                         int start = 0;
-                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options);
+                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options, elementLocation, loggingContext);
 
                         if (itemVectorExpressions != null)
                         {
@@ -993,13 +1001,23 @@ private class MetadataMatchEvaluator
                 /// </summary>
                 private ExpanderOptions _options;
 
+                private IElementLocation _elementLocation;
+
+                private LoggingContext _loggingContext;
+
                 /// <summary>
                 /// Constructor taking a source of metadata.
                 /// </summary>
-                internal MetadataMatchEvaluator(IMetadataTable metadata, ExpanderOptions options)
+                internal MetadataMatchEvaluator(
+                    IMetadataTable metadata,
+                    ExpanderOptions options,
+                    IElementLocation elementLocation,
+                    LoggingContext loggingContext)
                 {
                     _metadata = metadata;
-                    _options = options & (ExpanderOptions.ExpandMetadata | ExpanderOptions.Truncate);
+                    _options = options & (ExpanderOptions.ExpandMetadata | ExpanderOptions.Truncate | ExpanderOptions.LogOnItemMetadataSelfReference);
+                    _elementLocation = elementLocation;
+                    _loggingContext = loggingContext;
 
                     ErrorUtilities.VerifyThrow(options != ExpanderOptions.Invalid, "Must be expanding metadata of some kind");
                 }
@@ -1030,6 +1048,17 @@ internal string ExpandSingleMetadata(Match itemMetadataMatch)
                        (!isBuiltInMetadata && ((_options & ExpanderOptions.ExpandCustomMetadata) != 0)))
                     {
                         metadataValue = _metadata.GetEscapedValue(itemType, metadataName);
+
+                        if ((_options & ExpanderOptions.LogOnItemMetadataSelfReference) != 0 &&
+                            _loggingContext != null &&
+                            !string.IsNullOrEmpty(metadataName) &&
+                            _metadata is IItemTypeDefinition itemMetadata &&
+                            (string.IsNullOrEmpty(itemType) || string.Equals(itemType, itemMetadata.ItemType, StringComparison.Ordinal)))
+                        {
+                            _loggingContext.LogComment(MessageImportance.High, new BuildEventFileInfo(_elementLocation),
+                                "ItemReferencingSelfInTarget", itemMetadata.ItemType, metadataName);
+                        }
+
                         if (IsTruncationEnabled(_options) && metadataValue.Length > CharacterLimitPerExpansion)
                         {
                             metadataValue = metadataValue.Substring(0, CharacterLimitPerExpansion - 3) + "...";
@@ -1946,11 +1975,16 @@ internal static bool ExpandExpressionCapture<S>(
                 // If there are no items of the given type, then bail out early
                 if (itemsOfType.Count == 0)
                 {
-                    // .. but only if there isn't a function "Count()", since that will want to return something (zero) for an empty list
+                    // ... but only if there isn't a function "Count", since that will want to return something (zero) for an empty list
                     if (expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "Count", StringComparison.OrdinalIgnoreCase)) != true)
                     {
-                        itemsFromCapture = new List<Pair<string, S>>();
-                        return false;
+                        // ...or a function "AnyHaveMetadataValue", since that will want to return false for an empty list.
+                        if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) ||
+                            expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "AnyHaveMetadataValue", StringComparison.OrdinalIgnoreCase)) != true)
+                        {
+                            itemsFromCapture = new List<Pair<string, S>>();
+                            return false;
+                        }
                     }
                 }
 
@@ -3108,7 +3142,7 @@ private struct FunctionBuilder<T>
             /// </summary>
             public UsedUninitializedProperties UsedUninitializedProperties { get; set; }
 
-            internal Function<T> Build()
+            internal readonly Function<T> Build()
             {
                 return new Function<T>(
                     ReceiverType,
@@ -3882,6 +3916,14 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Unescape), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.Unescape(arg0);
+                                return true;
+                            }
+                        }
                         else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetPathOfFileAbove), StringComparison.OrdinalIgnoreCase))
                         {
                             if (TryGetArgs(args, out string arg0, out string arg1))
@@ -3894,7 +3936,7 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                         {
                             if (TryGetArgs(args, out double arg0, out double arg1))
                             {
-                                returnVal = arg0 + arg1;
+                                returnVal = IntrinsicFunctions.Add(arg0, arg1);
                                 return true;
                             }
                         }
@@ -3902,7 +3944,7 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                         {
                             if (TryGetArgs(args, out double arg0, out double arg1))
                             {
-                                returnVal = arg0 - arg1;
+                                returnVal = IntrinsicFunctions.Subtract(arg0, arg1);
                                 return true;
                             }
                         }
@@ -3910,7 +3952,7 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                         {
                             if (TryGetArgs(args, out double arg0, out double arg1))
                             {
-                                returnVal = arg0 * arg1;
+                                returnVal = IntrinsicFunctions.Multiply(arg0, arg1);
                                 return true;
                             }
                         }
@@ -3918,7 +3960,15 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                         {
                             if (TryGetArgs(args, out double arg0, out double arg1))
                             {
-                                returnVal = arg0 / arg1;
+                                returnVal = IntrinsicFunctions.Divide(arg0, arg1);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Modulo), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out double arg0, out double arg1))
+                            {
+                                returnVal = IntrinsicFunctions.Modulo(arg0, arg1);
                                 return true;
                             }
                         }
@@ -4108,6 +4158,62 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseOr), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0, out int arg1))
+                            {
+                                returnVal = IntrinsicFunctions.BitwiseOr(arg0, arg1);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseAnd), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0, out int arg1))
+                            {
+                                returnVal = IntrinsicFunctions.BitwiseAnd(arg0, arg1);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseXor), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0, out int arg1))
+                            {
+                                returnVal = IntrinsicFunctions.BitwiseXor(arg0, arg1);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseNot), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0))
+                            {
+                                returnVal = IntrinsicFunctions.BitwiseNot(arg0);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.LeftShift), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0, out int arg1))
+                            {
+                                returnVal = IntrinsicFunctions.LeftShift(arg0, arg1);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RightShift), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0, out int arg1))
+                            {
+                                returnVal = IntrinsicFunctions.RightShift(arg0, arg1);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RightShiftUnsigned), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArgs(args, out int arg0, out int arg1))
+                            {
+                                returnVal = IntrinsicFunctions.RightShiftUnsigned(arg0, arg1);
+                                return true;
+                            }
+                        }
                     }
                     else if (_receiverType == typeof(Path))
                     {
@@ -4484,6 +4590,18 @@ private static bool TryGetArgs(object[] args, out string arg0, out StringCompari
                 return Enum.TryParse(comparisonTypeName, out arg1);
             }
 
+            private static bool TryGetArgs(object[] args, out int arg0)
+            {
+                arg0 = 0;
+
+                if (args.Length != 1)
+                {
+                    return false;
+                }
+
+                return TryConvertToInt(args[0], out arg0);
+            }
+
             private static bool TryGetArgs(object[] args, out int arg0, out int arg1)
             {
                 arg0 = 0;
diff --git a/src/Build/Evaluation/IItemTypeDefinition.cs b/src/Build/Evaluation/IItemTypeDefinition.cs
new file mode 100644
index 00000000000..4d594e6ff39
--- /dev/null
+++ b/src/Build/Evaluation/IItemTypeDefinition.cs
@@ -0,0 +1,12 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Evaluation;
+
+internal interface IItemTypeDefinition
+{
+    /// <summary>
+    /// The item type to which this metadata applies.
+    /// </summary>
+    string ItemType { get; }
+}
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 45ebc5e9a0c..3fff5c28e65 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -165,6 +165,21 @@ internal static int BitwiseNot(int first)
             return ~first;
         }
 
+        internal static int LeftShift(int operand, int count)
+        {
+            return operand << count;
+        }
+
+        internal static int RightShift(int operand, int count)
+        {
+            return operand >> count;
+        }
+
+        internal static int RightShiftUnsigned(int operand, int count)
+        {
+            return operand >>> count;
+        }
+
         /// <summary>
         /// Get the value of the registry key and value, default value is null
         /// </summary>
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 89b2ffd1938..c45edf0764b 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -80,7 +80,7 @@ public ItemExpressionFragment(
 
             public override int MatchCount(string itemToMatch)
             {
-                return ReferencedItems.Count(v => v.ItemAsValueFragment.MatchCount(itemToMatch) > 0);
+                return ReferencedItems.Count(v => v.ItemAsValueFragment.IsMatch(itemToMatch));
             }
 
             public override bool IsMatch(string itemToMatch)
diff --git a/src/Build/Evaluation/ItemsAndMetadataPair.cs b/src/Build/Evaluation/ItemsAndMetadataPair.cs
index 3348d1b1662..9ff1f7c3354 100644
--- a/src/Build/Evaluation/ItemsAndMetadataPair.cs
+++ b/src/Build/Evaluation/ItemsAndMetadataPair.cs
@@ -40,7 +40,7 @@ internal ItemsAndMetadataPair(HashSet<string> items, Dictionary<string, Metadata
         /// </summary>
         internal HashSet<string> Items
         {
-            get
+            readonly get
             {
                 return _items;
             }
@@ -58,7 +58,7 @@ internal HashSet<string> Items
         /// </summary>
         internal Dictionary<string, MetadataReference> Metadata
         {
-            get
+            readonly get
             {
                 return _metadata;
             }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index e02ef565869..3d87cca546b 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -135,7 +135,7 @@ public ItemData(I item, ProjectItemElement originatingItemElement, int elementOr
                 _normalizedItemValue = normalizedItemValue;
             }
 
-            public ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initialItemElementForFactory)
+            public readonly ItemData Clone(IItemFactory<I, I> itemFactory, ProjectItemElement initialItemElementForFactory)
             {
                 // setting the factory's item element to the original item element that produced the item
                 // otherwise you get weird things like items that appear to have been produced by update elements
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index e622acbfdc5..5de3520dab8 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -324,7 +324,7 @@ private ProjectItemElement ParseProjectItemElement(XmlElementWithLocation elemen
                 }
                 else if (isValidMetadataNameInAttribute)
                 {
-                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute.Name, attribute.Value);
+                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute);
                     metadatum.ExpressedAsAttribute = true;
                     metadatum.Parent = item;
 
@@ -744,7 +744,7 @@ private ProjectItemDefinitionElement ParseProjectItemDefinitionXml(XmlElementWit
                 }
                 else if (isValidMetadataNameInAttribute)
                 {
-                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute.Name, attribute.Value);
+                    ProjectMetadataElement metadatum = _project.CreateMetadataElement(attribute);
                     metadatum.ExpressedAsAttribute = true;
                     metadatum.Parent = itemDefinition;
 
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 49e921d8160..0a910c0a334 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -2,13 +2,16 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Xml;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
@@ -88,11 +91,30 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase
 
 #if DEBUG
         /// <summary>
-        /// Number of entries into Get function of the ProjectRootElementCache.
-        /// Shall be always 0 or 1. Reentrance to the Get function (value > 1) could lead to race condition.
+        /// A simple IDisposable struct implementing the holder/guard pattern over the Get reentrancy counter.
         /// </summary>
-        [ThreadStatic]
-        private static int s_getEntriesNumber = 0;
+        private struct ReentrancyGuard : IDisposable
+        {
+            /// <summary>
+            /// Number of entries into Get function of the ProjectRootElementCache.
+            /// Shall be always 0 or 1. Reentrance to the Get function (value > 1) could lead to race condition.
+            /// </summary>
+            [ThreadStatic]
+            private static int s_getEntriesNumber = 0;
+
+            public ReentrancyGuard()
+            {
+                s_getEntriesNumber++;
+                ErrorUtilities.VerifyThrow(
+                    s_getEntriesNumber == 1,
+                    "Reentrance to the ProjectRootElementCache.Get function detected.");
+            }
+
+            public void Dispose()
+            {
+                s_getEntriesNumber--;
+            }
+        }
 #endif
 
         /// <summary>
@@ -104,6 +126,11 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase
         /// </remarks>
         private WeakValueDictionary<string, ProjectRootElement> _weakCache;
 
+        /// <summary>
+        /// Lock objects keyed by project file path.
+        /// </summary>
+        private ConcurrentDictionary<string, object> _fileLoadLocks;
+
         /// <summary>
         /// The list of strongly-held ProjectRootElement's
         /// </summary>
@@ -119,7 +146,7 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase
         /// <summary>
         /// Locking object for this shared cache
         /// </summary>
-        private Object _locker = new Object();
+        private object _locker = new object();
 
         /// <summary>
         /// Creates an empty cache.
@@ -130,6 +157,7 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO
 
             _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);
             _strongCache = new LinkedList<ProjectRootElement>();
+            _fileLoadLocks = new ConcurrentDictionary<string, object>(StringComparer.OrdinalIgnoreCase);
             _autoReloadFromDisk = autoReloadFromDisk;
             LoadProjectsReadOnly = loadProjectsReadOnly;
         }
@@ -140,45 +168,57 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO
         /// </summary>
         private bool IsInvalidEntry(string projectFile, ProjectRootElement projectRootElement)
         {
-            if (projectRootElement != null && _autoReloadFromDisk)
+            // When we do not _autoReloadFromDisk we expect that cached value is always valid.
+            // Usually lifespan of cache is expected to be build duration (process will terminate after build).
+            if (projectRootElement == null || !_autoReloadFromDisk)
             {
-                FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);
+                return false;
+            }
 
-                // If the file doesn't exist on disk, go ahead and use the cached version.
-                // It's an in-memory project that hasn't been saved yet.
-                if (fileInfo != null)
-                {
-                    if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)
-                    {
-                        // File was changed on disk by external means. Cached version is no longer valid.
-                        // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file
-                        // externally and load a new project over it to see the new content. So we dump it from the cache
-                        // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,
-                        // but clients ought not get themselves into such a state - and unless they save them to disk,
-                        // it may not be a problem.
-                        return true;
-                    }
-                    else if (s_сheckFileContent)
-                    {
-                        // QA tests run too fast for the timestamp check to work. This environment variable is for their
-                        // use: it checks the file content as well as the timestamp. That's better than completely disabling
-                        // the cache as we get test coverage of the rest of the cache code.
-                        XmlDocument document = new XmlDocument();
-                        document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;
+            // If the project file is non modifiable, assume it is up to date and consider the cached value valid.
+            if (!Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck && FileClassifier.Shared.IsNonModifiable(projectFile))
+            {
+                return false;
+            }
 
-                        using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))
-                        {
-                            document.Load(xtr.Reader);
-                        }
+            FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);
 
-                        string diskContent = document.OuterXml;
-                        string cacheContent = projectRootElement.XmlDocument.OuterXml;
+            // If the file doesn't exist on disk, go ahead and use the cached version.
+            // It's an in-memory project that hasn't been saved yet.
+            if (fileInfo == null)
+            {
+                return false;
+            }
 
-                        if (diskContent != cacheContent)
-                        {
-                            return true;
-                        }
-                    }
+            if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)
+            {
+                // File was changed on disk by external means. Cached version is no longer valid.
+                // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file
+                // externally and load a new project over it to see the new content. So we dump it from the cache
+                // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,
+                // but clients ought not get themselves into such a state - and unless they save them to disk,
+                // it may not be a problem.
+                return true;
+            }
+            else if (s_сheckFileContent)
+            {
+                // QA tests run too fast for the timestamp check to work. This environment variable is for their
+                // use: it checks the file content as well as the timestamp. That's better than completely disabling
+                // the cache as we get test coverage of the rest of the cache code.
+                XmlDocument document = new XmlDocument();
+                document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;
+
+                using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))
+                {
+                    document.Load(xtr.Reader);
+                }
+
+                string diskContent = document.OuterXml;
+                string cacheContent = projectRootElement.XmlDocument.OuterXml;
+
+                if (diskContent != cacheContent)
+                {
+                    return true;
                 }
             }
 
@@ -211,106 +251,127 @@ internal override ProjectRootElement Get(string projectFile, OpenProjectRootElem
         {
 #if DEBUG
             // Verify that loadProjectRootElement delegate does not call ProjectRootElementCache.Get().
-            s_getEntriesNumber++;
+            using var reentrancyGuard = new ReentrancyGuard();
+
+            // Verify that we never call this with _locker held, as that would create a lock ordering inversion with the per-file lock.
             ErrorUtilities.VerifyThrow(
-                s_getEntriesNumber == 1,
-                "Reentrance to the ProjectRootElementCache.Get function detected.");
+                !System.Threading.Monitor.IsEntered(_locker),
+                "Detected lock ordering inversion in ProjectRootElementCache.");
+#endif
+            // Should already have been canonicalized
+            ErrorUtilities.VerifyThrowInternalRooted(projectFile);
 
-            try
+            // First try getting the ProjectRootElement from the cache.
+            ProjectRootElement projectRootElement = GetOrLoad(projectFile, loadProjectRootElement: null, isExplicitlyLoaded, preserveFormatting);
+
+            if (projectRootElement != null || loadProjectRootElement == null)
             {
-#endif
-#pragma warning disable format // the release configuration fails as try-catch block is conditioned only for Debug; making the formatting in correct in Release.
-                // Should already have been canonicalized
-                ErrorUtilities.VerifyThrowInternalRooted(projectFile);
+                // If we found it or no load callback was specified, we are done.
+                return projectRootElement;
+            }
 
-                ProjectRootElement projectRootElement;
-                lock (_locker)
+            try
+            {
+                // We are about to load. Take a per-file lock to prevent multiple threads from duplicating the work multiple times.
+                object perFileLock = _fileLoadLocks.GetOrAdd(projectFile, () => new object());
+                lock (perFileLock)
                 {
-                    _weakCache.TryGetValue(projectFile, out projectRootElement);
+                    // Call GetOrLoad again, this time with the OpenProjectRootElement callback.
+                    return GetOrLoad(projectFile, loadProjectRootElement, isExplicitlyLoaded, preserveFormatting);
+                }
+            }
+            finally
+            {
+                // Remove the lock object as we have otherwise no good way of preventing _fileLoadLocks from growing unboundedly.
+                // If another thread is inside the lock, we effectively create a race condition where someone else may enter
+                // GetOrLoad. This is OK because this fine-grained locking is just a perf optimization, and we have either loaded
+                // the ProjectRootElement by now, or it is an error condition where perf is not critical.
+                _fileLoadLocks.TryRemove(projectFile, out _);
+            }
+        }
 
-                    if (projectRootElement != null)
-                    {
-                        BoostEntryInStrongCache(projectRootElement);
+        /// <summary>
+        /// A helper used by <see cref="Get"/>.
+        /// </summary>
+        private ProjectRootElement GetOrLoad(string projectFile, OpenProjectRootElement loadProjectRootElement, bool isExplicitlyLoaded,
+            bool? preserveFormatting)
+        {
+            ProjectRootElement projectRootElement;
+            lock (_locker)
+            {
+                _weakCache.TryGetValue(projectFile, out projectRootElement);
 
-                        // An implicit load will never reset the explicit flag.
-                        if (isExplicitlyLoaded)
-                        {
-                            projectRootElement.MarkAsExplicitlyLoaded();
-                        }
-                    }
-                    else
-                    {
-                        DebugTraceCache("Not found in cache: ", projectFile);
-                    }
+                if (projectRootElement != null)
+                {
+                    BoostEntryInStrongCache(projectRootElement);
 
-                    if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)
+                    // An implicit load will never reset the explicit flag.
+                    if (isExplicitlyLoaded)
                     {
-                        // Cached project doesn't match preserveFormatting setting, so reload it
-                        projectRootElement.Reload(true, preserveFormatting);
+                        projectRootElement.MarkAsExplicitlyLoaded();
                     }
                 }
-
-                bool projectRootElementIsInvalid = IsInvalidEntry(projectFile, projectRootElement);
-                if (projectRootElementIsInvalid)
+                else
                 {
-                    DebugTraceCache("Not satisfied from cache: ", projectFile);
-                    ForgetEntryIfExists(projectRootElement);
+                    DebugTraceCache("Not found in cache: ", projectFile);
                 }
 
-                if (loadProjectRootElement == null)
+                if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)
                 {
-                    if (projectRootElement == null || projectRootElementIsInvalid)
-                    {
-                        return null;
-                    }
-                    else
-                    {
-                        DebugTraceCache("Satisfied from XML cache: ", projectFile);
-                        return projectRootElement;
-                    }
+                    // Cached project doesn't match preserveFormatting setting, so reload it
+                    projectRootElement.Reload(true, preserveFormatting);
                 }
+            }
+
+            bool projectRootElementIsInvalid = IsInvalidEntry(projectFile, projectRootElement);
+            if (projectRootElementIsInvalid)
+            {
+                DebugTraceCache("Not satisfied from cache: ", projectFile);
+                ForgetEntryIfExists(projectRootElement);
+            }
 
-                // Use openProjectRootElement to reload the element if the cache element does not exist or need to be reloaded.
+            if (loadProjectRootElement == null)
+            {
                 if (projectRootElement == null || projectRootElementIsInvalid)
                 {
-                    // We do not lock loading with common _locker of the cache, to avoid lock contention.
-                    // Decided also not to lock this section with the key specific locker to avoid the overhead and code overcomplication, as
-                    // it is not likely that two threads would use Get function for the same project simultaneously and it is not a big deal if in some cases we load the same project twice.
-
-                    projectRootElement = loadProjectRootElement(projectFile, this);
-                    ErrorUtilities.VerifyThrowInternalNull(projectRootElement, "projectRootElement");
-                    ErrorUtilities.VerifyThrow(
-                        projectRootElement.FullPath.Equals(projectFile, StringComparison.OrdinalIgnoreCase),
-                        "Got project back with incorrect path. Expected path: {0}, received path: {1}.",
-                        projectFile,
-                        projectRootElement.FullPath);
-
-                    // An implicit load will never reset the explicit flag.
-                    if (isExplicitlyLoaded)
-                    {
-                        projectRootElement.MarkAsExplicitlyLoaded();
-                    }
-
-                    // Update cache element.
-                    // It is unlikely, but it might be that while without the lock, the projectRootElement in cache was updated by another thread.
-                    // And here its entry will be replaced with the loaded projectRootElement. This is fine:
-                    // if loaded projectRootElement is out of date (so, it changed since the time we loaded it), it will be updated the next time some thread calls Get function.
-                    AddEntry(projectRootElement);
+                    return null;
                 }
                 else
                 {
                     DebugTraceCache("Satisfied from XML cache: ", projectFile);
+                    return projectRootElement;
                 }
+            }
 
-                return projectRootElement;
-#pragma warning restore format
-#if DEBUG
+            // Use openProjectRootElement to reload the element if the cache element does not exist or need to be reloaded.
+            if (projectRootElement == null || projectRootElementIsInvalid)
+            {
+                projectRootElement = loadProjectRootElement(projectFile, this);
+                ErrorUtilities.VerifyThrowInternalNull(projectRootElement, "projectRootElement");
+                ErrorUtilities.VerifyThrow(
+                    projectRootElement.FullPath.Equals(projectFile, StringComparison.OrdinalIgnoreCase),
+                    "Got project back with incorrect path. Expected path: {0}, received path: {1}.",
+                    projectFile,
+                    projectRootElement.FullPath);
+
+                // An implicit load will never reset the explicit flag.
+                if (isExplicitlyLoaded)
+                {
+                    projectRootElement.MarkAsExplicitlyLoaded();
+                }
+
+                // Update cache element.
+                // It is unlikely, but it might be that while without the lock, the projectRootElement in cache was updated by another thread.
+                // And here its entry will be replaced with the loaded projectRootElement. This is fine:
+                // if loaded projectRootElement is out of date (so, it changed since the time we loaded it), it will be updated the next time some thread calls Get function.
+                AddEntry(projectRootElement);
             }
-            finally
+            else
             {
-                s_getEntriesNumber--;
+                DebugTraceCache("Satisfied from XML cache: ", projectFile);
             }
-#endif
+
+            return projectRootElement;
         }
 
         /// <summary>
@@ -398,13 +459,44 @@ internal override void Clear()
         {
             lock (_locker)
             {
-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
-                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);
-                _strongCache = new LinkedList<ProjectRootElement>();
+                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)
+                {
+                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
+                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);
+                    _strongCache = new LinkedList<ProjectRootElement>();
 
-                foreach (ProjectRootElement projectRootElement in oldStrongCache)
+                    foreach (ProjectRootElement projectRootElement in oldStrongCache)
+                    {
+                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
+                    }
+                }
+                else
                 {
-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
+                    // Manually iterate through LinkedList so we can remove items during this iteration
+                    for (var listNode = _strongCache.First; listNode != null;)
+                    {
+                        var nextNode = listNode.Next;
+
+                        ProjectRootElement projectRootElement = listNode.Value;
+                        // Do not remove cache of files from immutable locations.
+                        // Those are mostly SDK project files and will be most probably needed in next builds.
+                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))
+                        {
+                            _weakCache.Remove(projectRootElement.FullPath);
+                            _strongCache.Remove(listNode);
+                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
+                        }
+
+                        listNode = nextNode;
+                    }
+
+                    // From weak list remove all which is not in strong list anymore
+                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();
+                    foreach (string victim in toBeRemovedFromWeakRefs)
+                    {
+                        _weakCache.Remove(victim);
+                    }
+                    _weakCache.Scavenge();
                 }
             }
         }
@@ -430,25 +522,27 @@ internal override void DiscardImplicitReferences()
                 LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
                 _strongCache = new LinkedList<ProjectRootElement>();
 
-                foreach (string projectPath in oldWeakCache.Keys)
+                foreach (KeyValuePair<string, ProjectRootElement> kvp in oldWeakCache)
                 {
-                    ProjectRootElement rootElement;
+                    if (kvp.Value is null)
+                    {
+                        continue;
+                    }
 
-                    if (oldWeakCache.TryGetValue(projectPath, out rootElement))
+                    if (kvp.Value.IsExplicitlyLoaded)
                     {
-                        if (rootElement.IsExplicitlyLoaded)
-                        {
-                            _weakCache[projectPath] = rootElement;
-                        }
+                        _weakCache[kvp.Key] = kvp.Value;
+                    }
 
-                        if (rootElement.IsExplicitlyLoaded && oldStrongCache.Contains(rootElement))
+                    if (oldStrongCache.Contains(kvp.Value))
+                    {
+                        if (kvp.Value.IsExplicitlyLoaded)
                         {
-                            _strongCache.AddFirst(rootElement);
+                            _strongCache.AddFirst(kvp.Value);
                         }
                         else
                         {
-                            _strongCache.Remove(rootElement);
-                            RaiseProjectRootElementRemovedFromStrongCache(rootElement);
+                            RaiseProjectRootElementRemovedFromStrongCache(kvp.Value);
                         }
                     }
                 }
@@ -511,7 +605,7 @@ private void RenameEntryInternal(string oldFullPathIfAny, ProjectRootElement pro
             ProjectRootElement existingWeakEntry;
             _weakCache.TryGetValue(projectRootElement.FullPath, out existingWeakEntry);
 
-            if (existingWeakEntry != null && !Object.ReferenceEquals(existingWeakEntry, projectRootElement))
+            if (existingWeakEntry != null && !object.ReferenceEquals(existingWeakEntry, projectRootElement))
             {
                 _strongCache.Remove(existingWeakEntry);
                 RaiseProjectRootElementRemovedFromStrongCache(existingWeakEntry);
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index a226c96acdf..ec977d2f474 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -254,11 +254,15 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
 
             ErrorUtilities.VerifyThrowArgument(entryPoints.Count == 1, "StaticGraphAcceptsSingleSolutionEntryPoint");
 
-            var solutionEntryPoint = entryPoints.Single();
-            var solutionGlobalProperties = ImmutableDictionary.CreateRange(
+            ProjectGraphEntryPoint solutionEntryPoint = entryPoints.Single();
+            ImmutableDictionary<string, string>.Builder solutionGlobalPropertiesBuilder = ImmutableDictionary.CreateBuilder(
                 keyComparer: StringComparer.OrdinalIgnoreCase,
-                valueComparer: StringComparer.OrdinalIgnoreCase,
-                items: solutionEntryPoint.GlobalProperties ?? ImmutableDictionary<string, string>.Empty);
+                valueComparer: StringComparer.OrdinalIgnoreCase);
+
+            if (solutionEntryPoint.GlobalProperties != null)
+            {
+                solutionGlobalPropertiesBuilder.AddRange(solutionEntryPoint.GlobalProperties);
+            }
 
             var solution = SolutionFile.Parse(solutionEntryPoint.ProjectFile);
 
@@ -272,29 +276,39 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                         string.Join(";", solution.SolutionParserErrorCodes)));
             }
 
-            var projectsInSolution = GetBuildableProjects(solution);
+            IReadOnlyCollection<ProjectInSolution> projectsInSolution = GetBuildableProjects(solution);
+
+            SolutionConfigurationInSolution currentSolutionConfiguration = SelectSolutionConfiguration(solution, solutionEntryPoint.GlobalProperties);
+
+            string solutionConfigurationXml = SolutionProjectGenerator.GetSolutionConfiguration(solution, currentSolutionConfiguration);
+            solutionGlobalPropertiesBuilder["CurrentSolutionConfigurationContents"] = solutionConfigurationXml;
 
-            var currentSolutionConfiguration = SelectSolutionConfiguration(solution, solutionGlobalProperties);
+            // Project configurations are reused heavily, so cache the global properties for each
+            Dictionary<string, ImmutableDictionary<string, string>> globalPropertiesForProjectConfiguration = new(StringComparer.OrdinalIgnoreCase);
 
             var newEntryPoints = new List<ProjectGraphEntryPoint>(projectsInSolution.Count);
 
-            foreach (var project in projectsInSolution)
+            foreach (ProjectInSolution project in projectsInSolution)
             {
                 if (project.ProjectConfigurations.Count == 0)
                 {
                     continue;
                 }
 
-                var projectConfiguration = SelectProjectConfiguration(currentSolutionConfiguration, project.ProjectConfigurations);
+                ProjectConfigurationInSolution projectConfiguration = SelectProjectConfiguration(currentSolutionConfiguration, project.ProjectConfigurations);
 
                 if (projectConfiguration.IncludeInBuild)
                 {
-                    newEntryPoints.Add(
-                        new ProjectGraphEntryPoint(
-                            project.AbsolutePath,
-                            solutionGlobalProperties
-                                .SetItem("Configuration", projectConfiguration.ConfigurationName)
-                                .SetItem("Platform", projectConfiguration.PlatformName)));
+                    if (!globalPropertiesForProjectConfiguration.TryGetValue(projectConfiguration.FullName, out ImmutableDictionary<string, string> projectGlobalProperties))
+                    {
+                        solutionGlobalPropertiesBuilder["Configuration"] = projectConfiguration.ConfigurationName;
+                        solutionGlobalPropertiesBuilder["Platform"] = projectConfiguration.PlatformName;
+
+                        projectGlobalProperties = solutionGlobalPropertiesBuilder.ToImmutable();
+                        globalPropertiesForProjectConfiguration.Add(projectConfiguration.FullName, projectGlobalProperties);
+                    }
+
+                    newEntryPoints.Add(new ProjectGraphEntryPoint(project.AbsolutePath, projectGlobalProperties));
                 }
             }
 
@@ -307,13 +321,13 @@ IReadOnlyCollection<ProjectInSolution> GetBuildableProjects(SolutionFile solutio
                 return solutionFile.ProjectsInOrder.Where(p => p.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat && solutionFile.ProjectShouldBuild(p.RelativePath)).ToImmutableArray();
             }
 
-            SolutionConfigurationInSolution SelectSolutionConfiguration(SolutionFile solutionFile, ImmutableDictionary<string, string> globalProperties)
+            SolutionConfigurationInSolution SelectSolutionConfiguration(SolutionFile solutionFile, IDictionary<string, string> globalProperties)
             {
-                var solutionConfiguration = globalProperties.TryGetValue("Configuration", out string configuration)
+                var solutionConfiguration = globalProperties != null && globalProperties.TryGetValue("Configuration", out string configuration)
                     ? configuration
                     : solutionFile.GetDefaultConfigurationName();
 
-                var solutionPlatform = globalProperties.TryGetValue("Platform", out string platform)
+                var solutionPlatform = globalProperties != null && globalProperties.TryGetValue("Platform", out string platform)
                     ? platform
                     : solutionFile.GetDefaultPlatformName();
 
@@ -545,7 +559,6 @@ private void SubmitProjectForParsing(ConfigurationMetadata projectToEvaluate)
         {
             var referenceInfos = new List<ProjectInterpretation.ReferenceInfo>();
 
-
             foreach (var referenceInfo in _projectInterpretation.GetReferences(parsedProject.ProjectInstance, _projectCollection, _projectInstanceFactory))
             {
                 if (FileUtilities.IsSolutionFilename(referenceInfo.ReferenceConfiguration.ProjectFullPath))
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index 1e1248865be..39993e3a4fc 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -766,7 +766,7 @@ public ProjectGraphBuildRequest(ProjectGraphNode node, ImmutableList<string> tar
 
             public ImmutableList<string> RequestedTargets { get; }
 
-            public bool Equals(ProjectGraphBuildRequest other)
+            public readonly bool Equals(ProjectGraphBuildRequest other)
             {
                 if (Node != other.Node
                     || RequestedTargets.Count != other.RequestedTargets.Count)
@@ -786,12 +786,12 @@ public bool Equals(ProjectGraphBuildRequest other)
                 return true;
             }
 
-            public override bool Equals(object obj)
+            public override readonly bool Equals(object obj)
             {
                 return !(obj is null) && obj is ProjectGraphBuildRequest graphNodeWithTargets && Equals(graphNodeWithTargets);
             }
 
-            public override int GetHashCode()
+            public override readonly int GetHashCode()
             {
                 unchecked
                 {
diff --git a/src/Build/Graph/ProjectGraphEntryPoint.cs b/src/Build/Graph/ProjectGraphEntryPoint.cs
index 8e229b7bd61..6b0f4713494 100644
--- a/src/Build/Graph/ProjectGraphEntryPoint.cs
+++ b/src/Build/Graph/ProjectGraphEntryPoint.cs
@@ -61,7 +61,7 @@ internal static IEnumerable<ProjectGraphEntryPoint> CreateEnumerable(IEnumerable
             }
         }
 
-        internal IEnumerable<ProjectGraphEntryPoint> AsEnumerable()
+        internal readonly IEnumerable<ProjectGraphEntryPoint> AsEnumerable()
         {
             yield return this;
         }
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index fa1642fb36b..93eb29782fd 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -6,8 +6,10 @@
 using System.Collections.Immutable;
 using System.Globalization;
 using System.Linq;
+using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
@@ -33,6 +35,9 @@ internal sealed class ProjectInterpretation
         private const string PlatformMetadataName = "Platform";
         private const string PlatformsMetadataName = "Platforms";
         private const string EnableDynamicPlatformResolutionMetadataName = "EnableDynamicPlatformResolution";
+        private const string OverridePlatformNegotiationValue = "OverridePlatformNegotiationValue";
+        private const string ProjectMetadataName = "Project";
+        private const string ConfigurationMetadataName = "Configuration";
 
         private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
 
@@ -51,17 +56,7 @@ internal enum ProjectType
             NonMultitargeting,
         }
 
-        internal readonly struct ReferenceInfo
-        {
-            public ConfigurationMetadata ReferenceConfiguration { get; }
-            public ProjectItemInstance ProjectReferenceItem { get; }
-
-            public ReferenceInfo(ConfigurationMetadata referenceConfiguration, ProjectItemInstance projectReferenceItem)
-            {
-                ReferenceConfiguration = referenceConfiguration;
-                ProjectReferenceItem = projectReferenceItem;
-            }
-        }
+        internal readonly record struct ReferenceInfo(ConfigurationMetadata ReferenceConfiguration, ProjectItemInstance ProjectReferenceItem);
 
         private readonly struct TargetSpecification
         {
@@ -82,7 +77,7 @@ public TargetSpecification(string target, bool skipIfNonexistent)
             public bool SkipIfNonexistent { get; }
         }
 
-        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection _projectCollection, ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory)
+        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection projectCollection, ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory)
         {
             IEnumerable<ProjectItemInstance> projectReferenceItems;
             IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;
@@ -104,7 +99,14 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                     throw new ArgumentOutOfRangeException();
             }
 
-            foreach (var projectReferenceItem in projectReferenceItems)
+            SolutionConfiguration solutionConfiguration = null;
+            string solutionConfigurationXml = requesterInstance.GetPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents);
+            if (!string.IsNullOrWhiteSpace(solutionConfigurationXml))
+            {
+                solutionConfiguration = new SolutionConfiguration(solutionConfigurationXml);
+            }
+
+            foreach (ProjectItemInstance projectReferenceItem in projectReferenceItems)
             {
                 if (!String.IsNullOrEmpty(projectReferenceItem.GetMetadataValue(ToolsVersionMetadataName)))
                 {
@@ -117,24 +119,59 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                             requesterInstance.FullPath));
                 }
 
-                var projectReferenceFullPath = projectReferenceItem.GetMetadataValue(FullPathMetadataName);
+                string projectReferenceFullPath = projectReferenceItem.GetMetadataValue(FullPathMetadataName);
+                bool enableDynamicPlatformResolution = ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName));
 
-                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReferenceItem, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);
+                PropertyDictionary<ProjectPropertyInstance> referenceGlobalProperties = GetGlobalPropertiesForItem(
+                    projectReferenceItem,
+                    requesterInstance.GlobalPropertiesDictionary,
+                    // Only allow reuse in scenarios where we will not mutate the collection.
+                    // TODO: Should these mutations be moved to globalPropertiesModifiers in the future?
+                    allowCollectionReuse: solutionConfiguration == null && !enableDynamicPlatformResolution,
+                    globalPropertiesModifiers);
 
-                var requesterPlatform = "";
-                var requesterPlatformLookupTable = "";
+                // Match what AssignProjectConfiguration does to resolve project references.
+                if (solutionConfiguration != null)
+                {
+                    string projectGuid = projectReferenceItem.GetMetadataValue(ProjectMetadataName);
+                    if (solutionConfiguration.TryGetProjectByGuid(projectGuid, out XmlElement projectElement)
+                        || solutionConfiguration.TryGetProjectByAbsolutePath(projectReferenceFullPath, out projectElement))
+                    {
+                        // Note: AssignProjectConfiguration sets various metadata on the ProjectReference item, but ultimately it just translates to the Configuration and Platform global properties on the MSBuild task.
+                        string projectConfiguration = projectElement.InnerText;
+                        string[] configurationPlatformParts = projectConfiguration.Split(SolutionConfiguration.ConfigPlatformSeparator[0]);
+                        SetProperty(referenceGlobalProperties, ConfigurationMetadataName, configurationPlatformParts[0]);
 
-                if (!projectReferenceItem.HasMetadata(SetPlatformMetadataName) && ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
+                        if (configurationPlatformParts.Length > 1)
+                        {
+                            SetProperty(referenceGlobalProperties, PlatformMetadataName, configurationPlatformParts[1]);
+                        }
+                        else
+                        {
+                            referenceGlobalProperties.Remove(PlatformMetadataName);
+                        }
+                    }
+                    else
+                    {
+                        referenceGlobalProperties.Remove(ConfigurationMetadataName);
+                        referenceGlobalProperties.Remove(PlatformMetadataName);
+                    }
+                }
+
+                // Note: Dynamic platform resolution is not enabled for sln-based builds.
+                else if (!projectReferenceItem.HasMetadata(SetPlatformMetadataName) && enableDynamicPlatformResolution)
                 {
-                    requesterPlatform = requesterInstance.GetPropertyValue("Platform");
-                    requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
+                    string requesterPlatform = requesterInstance.GetPropertyValue("Platform");
+                    string requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
 
-                    var projectInstance = _projectInstanceFactory(
+                    var projectInstance = projectInstanceFactory(
                         projectReferenceFullPath,
                         null, // Platform negotiation requires an evaluation with no global properties first
-                        _projectCollection);
+                        projectCollection);
+
+                    string overridePlatformNegotiationMetadataValue = projectReferenceItem.GetMetadataValue(OverridePlatformNegotiationValue);
 
-                    var selectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformMetadataName), projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), requesterInstance.GetPropertyValue(PlatformLookupTableMetadataName), projectInstance.FullPath, requesterInstance.GetPropertyValue(PlatformMetadataName));
+                    var selectedPlatform = PlatformNegotiation.GetNearestPlatform(overridePlatformNegotiationMetadataValue, projectInstance.GetPropertyValue(PlatformMetadataName), projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), requesterInstance.GetPropertyValue(PlatformLookupTableMetadataName), projectInstance.FullPath, requesterInstance.GetPropertyValue(PlatformMetadataName));
 
                     if (selectedPlatform.Equals(String.Empty))
                     {
@@ -142,14 +179,19 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                     }
                     else
                     {
-                        var platformPropertyInstance = ProjectPropertyInstance.Create(PlatformMetadataName, selectedPlatform);
-                        referenceGlobalProperties[PlatformMetadataName] = platformPropertyInstance;
+                        SetProperty(referenceGlobalProperties, PlatformMetadataName, selectedPlatform);
                     }
                 }
 
                 var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);
 
                 yield return new ReferenceInfo(referenceConfig, projectReferenceItem);
+
+                static void SetProperty(PropertyDictionary<ProjectPropertyInstance> properties, string propertyName, string propertyValue)
+                {
+                    ProjectPropertyInstance propertyInstance = ProjectPropertyInstance.Create(propertyName, propertyValue);
+                    properties[propertyName] = propertyInstance;
+                }
             }
         }
 
@@ -324,7 +366,8 @@ public GlobalPropertyPartsForMSBuildTask AddPropertyToUndefine(string propertyTo
         private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesForItem(
             ProjectItemInstance projectReference,
             PropertyDictionary<ProjectPropertyInstance> requesterGlobalProperties,
-            IEnumerable<GlobalPropertiesModifier> globalPropertyModifiers = null)
+            bool allowCollectionReuse,
+            IEnumerable<GlobalPropertiesModifier> globalPropertyModifiers)
         {
             ErrorUtilities.VerifyThrowInternalNull(projectReference, nameof(projectReference));
             ErrorUtilities.VerifyThrowArgumentNull(requesterGlobalProperties, nameof(requesterGlobalProperties));
@@ -337,7 +380,7 @@ private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesFo
 
             var globalPropertyParts = globalPropertyModifiers?.Aggregate(defaultParts, (currentProperties, modifier) => modifier(currentProperties, projectReference)) ?? defaultParts;
 
-            if (globalPropertyParts.AllEmpty())
+            if (globalPropertyParts.AllEmpty() && allowCollectionReuse)
             {
                 return requesterGlobalProperties;
             }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 763a09442b3..9a301afd793 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -241,7 +241,7 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="projectCollection">Project collection</param>
         /// <returns>A new project instance</returns>
         public ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, interactive: false)
         {
         }
 
@@ -260,8 +260,9 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="projectCollection">Project collection</param>
         /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
+        /// <param name="interactive">Indicates if loading the project is allowed to interact with the user.</param>
         /// <returns>A new project instance</returns>
-        private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
+        private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, bool interactive)
         {
             ErrorUtilities.VerifyThrowArgumentLength(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -270,7 +271,10 @@ private ProjectInstance(string projectFile, IDictionary<string, string> globalPr
             // passed a relative path, the caller assumes we will prepend the current directory.
             projectFile = FileUtilities.NormalizePath(projectFile);
 
-            BuildParameters buildParameters = new BuildParameters(projectCollection);
+            BuildParameters buildParameters = new BuildParameters(projectCollection)
+            {
+                Interactive = interactive
+            };
 
             BuildEventContext buildEventContext = new BuildEventContext(buildParameters.NodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
             ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile, globalProperties, toolsVersion, buildParameters.ProjectRootElementCache, true /*Explicitly Loaded*/);
@@ -323,7 +327,7 @@ public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globa
         /// <param name="projectCollection">Project collection</param>
         /// <returns>A new project instance</returns>
         public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
-            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null)
+            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null, interactive: false)
         {
         }
 
@@ -395,11 +399,18 @@ public ProjectInstance(Project project, ProjectInstanceSettings settings)
         /// <param name="projectCollection">Project collection</param>
         /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
+        /// <param name="interactive">Indicates if loading the project is allowed to interact with the user.</param>
         /// <returns>A new project instance</returns>
-        private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
+        private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext, bool interactive)
         {
             BuildEventContext buildEventContext = new BuildEventContext(0, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
-            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version specified */, new BuildParameters(projectCollection), projectCollection.LoggingService, buildEventContext, projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext);
+
+            BuildParameters buildParameters = new BuildParameters(projectCollection)
+            {
+                Interactive = interactive
+            };
+
+            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version specified */, buildParameters, projectCollection.LoggingService, buildEventContext, projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext);
         }
 
         /// <summary>
@@ -743,7 +754,8 @@ public static ProjectInstance FromFile(string file, ProjectOptions options)
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.Interactive);
         }
 
         /// <summary>
@@ -760,7 +772,8 @@ public static ProjectInstance FromProjectRootElement(ProjectRootElement rootElem
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.Interactive);
         }
 
         /// <summary>
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 9bde7d2db83..7a4bffd0290 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.Execution
     /// Immutable.
     /// </summary>
     [DebuggerDisplay("{_itemType} #Metadata={MetadataCount}")]
-    public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefinition<ProjectMetadataInstance>, ITranslatable
+    public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefinition<ProjectMetadataInstance>, ITranslatable, IItemTypeDefinition
     {
         /// <summary>
         /// Item type, for example "Compile", that this item definition applies to
@@ -235,5 +235,7 @@ internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITransla
 
             return instance;
         }
+
+        string IItemTypeDefinition.ItemType => _itemType;
     }
 }
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 2d124f82d8d..ab16a994eee 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -33,7 +33,8 @@ public class ProjectItemInstance :
         ITaskItem2,
         IMetadataTable,
         ITranslatable,
-        IMetadataContainer
+        IMetadataContainer,
+        IItemTypeDefinition
     {
         /// <summary>
         /// The project instance to which this item belongs.
@@ -628,11 +629,11 @@ internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance>
         /// which legally have built-in metadata. If necessary we can calculate it on the new items we're making if requested.
         /// We don't copy them too because tasks shouldn't set them (they might become inconsistent)
         /// </summary>
-        internal void SetMetadataOnTaskOutput(string name, string evaluatedValueEscaped)
+        internal void SetMetadataOnTaskOutput(IEnumerable<KeyValuePair<string, string>> items)
         {
             _project.VerifyThrowNotImmutable();
 
-            _taskItem.SetMetadataOnTaskOutput(name, evaluatedValueEscaped);
+            _taskItem.SetMetadataOnTaskOutput(items);
         }
 
         /// <summary>
@@ -1489,8 +1490,8 @@ void ITranslatable.Translate(ITranslator translator)
             /// </summary>
             public override int GetHashCode()
             {
-                // This is ignore case to ensure that task items whose item specs differ only by 
-                // casing still have the same hash code, since this is used to determine if we have duplicates when 
+                // This is ignore case to ensure that task items whose item specs differ only by
+                // casing still have the same hash code, since this is used to determine if we have duplicates when
                 // we do duplicate removal.
                 return StringComparer.OrdinalIgnoreCase.GetHashCode(ItemSpec);
             }
@@ -1785,6 +1786,18 @@ internal void SetMetadataOnTaskOutput(string name, string evaluatedValueEscaped)
                 }
             }
 
+            internal void SetMetadataOnTaskOutput(IEnumerable<KeyValuePair<string, string>> items)
+            {
+                ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
+                _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+
+                var metadata = items
+                    .Where(item => !FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(item.Key))
+                    .Select(item => new ProjectMetadataInstance(item.Key, item.Value, true /* may be built-in metadata name */));
+
+                _directMetadata.ImportProperties(metadata);
+            }
+
             /// <summary>
             /// Deep clone this into another TaskItem
             /// </summary>
@@ -2125,7 +2138,7 @@ public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metada
             /// Also, more importantly, because typically the same regular metadata values can be shared by many items,
             /// and keeping item-specific metadata out of it could allow it to be implemented as a copy-on-write table.
             /// </summary>
-            private class BuiltInMetadataTable : IMetadataTable
+            private class BuiltInMetadataTable : IMetadataTable, IItemTypeDefinition
             {
                 /// <summary>
                 /// Item type
@@ -2183,6 +2196,8 @@ public string GetEscapedValueIfPresent(string requiredItemType, string name)
 
                     return value;
                 }
+
+                string IItemTypeDefinition.ItemType => _itemType;
             }
         }
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index c2757e1ff4d..c73282b3df1 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -56,9 +56,6 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\EncodingUtilities.cs">
-      <Link>SharedUtilities\EncodingUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\EnvironmentUtilities.cs">
       <Link>SharedUtilities\EnvironmentUtilities.cs</Link>
     </Compile>
@@ -126,6 +123,7 @@
       <Link>PlatformNegotiation.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\SolutionConfiguration.cs" />
     <Compile Include="..\Shared\TaskLoggingHelper.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\TaskLoggingHelper.cs</Link>
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
@@ -162,6 +160,7 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
+    <Compile Include="Evaluation\IItemTypeDefinition.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 52faacfee31..5a8f8640a74 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1983,4 +1983,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="NodeReused" xml:space="preserve">
     <value>Reusing node {0} (PID: {1}).</value>
   </data>
-</root>
\ No newline at end of file
+  <data name="ItemReferencingSelfInTarget" xml:space="preserve">
+    <value>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</value>
+    <comment>{StrBegin="MSB4120: "}</comment>
+  </data>
+</root>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 278dbe4c739..0f52b70e2b8 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Objekty EvaluationContext vytvořené pomocí SharingPolicy.Isolated nepodporují předávání souborového systému MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Ukončuje se proces s pid = {0}.</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; nebyl rozpoznán.</target>
+        <target state="translated">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; nebyl rozpoznán.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 759cbf24118..363edd349b7 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Die Übergabe eines MSBuildFileSystemBase-Dateisystems an EvaluationContext-Objekte, die mit "SharingPolicy.Isolated" erstellt wurden, wird nicht unterstützt.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Der Prozess mit PID {0} wird beendet.</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: Das &lt;{0}&gt;-Element unterhalb des &lt;{1}&gt;-Elements ist unbekannt.</target>
+        <target state="translated">MSB4067: Das &lt;{0}&gt;-Element unterhalb des &lt;{1}&gt;-Elements ist unbekannt.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 88c3b698231..b614cd5d41a 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Terminando el proceso con el PID = {0}.</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: No se reconoce el subelemento &lt;{0}&gt; del elemento &lt;{1}&gt;.</target>
+        <target state="translated">MSB4067: No se reconoce el subelemento &lt;{0}&gt; del elemento &lt;{1}&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 2264173e816..c38b649d037 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Les objets EvaluationContext créés avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un système de fichiers MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Arrêt du processus ayant le PID = {0}.</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: L'élément "{0}" situé sous l'élément &lt;{1}&gt; n'est pas reconnu.</target>
+        <target state="translated">MSB4067: L'élément "{0}" situé sous l'élément &lt;{1}&gt; n'est pas reconnu.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 4c5f37c1953..4c4932631a8 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non è possibile passare un file system MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Terminazione del processo con PID = {0}.</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: elemento &lt;{0}&gt; sotto l'elemento &lt;{1}&gt; non riconosciuto.</target>
+        <target state="translated">MSB4067: elemento &lt;{0}&gt; sotto l'elemento &lt;{1}&gt; non riconosciuto.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 25261590068..0ab12ba89e3 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -154,6 +154,11 @@
         <target state="translated">SharingPolicy.Isolated を指定して作成された EvaluationContext オブジェクトに MSBuildFileSystemBase ファイル システムを渡すことはサポートされていません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">PID = {0} のプロセスを中止しています。</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: 要素 &lt;{1}&gt; の下の要素 &lt;{0}&gt; は認識されていません。</target>
+        <target state="translated">MSB4067: 要素 &lt;{1}&gt; の下の要素 &lt;{0}&gt; は認識されていません。</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index a315a48652f..8101d90c436 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -154,6 +154,11 @@
         <target state="translated">SharingPolicy.Isolated로 만든 EvaluationContext 개체는 MSBuildFileSystemBase 파일 시스템 전달을 지원하지 않습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">pid가 {0}인 프로세스를 종료하는 중입니다.</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: &lt;{1}&gt; 요소 아래의 &lt;{0}&gt; 요소를 인식할 수 없습니다.</target>
+        <target state="translated">MSB4067: &lt;{1}&gt; 요소 아래의 &lt;{0}&gt; 요소를 인식할 수 없습니다.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 00856a177e8..334e24ff11e 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Obiekty EvaluationContext utworzone za pomocą elementu SharingPolicy.Isolated nie obsługują przekazywania za pomocą systemu plików MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Kasowanie procesu z identyfikatorem pid = {0}.</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: Element &lt;{0}&gt; znajdujący się pod elementem &lt;{1}&gt; nie został rozpoznany.</target>
+        <target state="translated">MSB4067: Element &lt;{0}&gt; znajdujący się pod elementem &lt;{1}&gt; nie został rozpoznany.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index becfa993d0d..1231fa2b51b 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Os objetos EvaluationContext criados com SharingPolicy.Isolated não são compatíveis com o recebimento de um sistema de arquivos MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Encerrando o processo com o PID = {0}.</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: O elemento &lt;{0}&gt; abaixo do elemento &lt;{1}&gt; não é reconhecido.</target>
+        <target state="translated">MSB4067: O elemento &lt;{0}&gt; abaixo do elemento &lt;{1}&gt; não é reconhecido.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index abdf27bb687..2858ea61d4b 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -154,6 +154,11 @@
         <target state="translated">Объекты EvaluationContext, созданные с помощью SharingPolicy.Isolated, не поддерживают передачу в файловую систему MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">Завершение процесса с идентификатором {0}.</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: неопознанный элемент &lt;{0}&gt; в элементе &lt;{1}&gt;.</target>
+        <target state="translated">MSB4067: неопознанный элемент &lt;{0}&gt; в элементе &lt;{1}&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 023ad6274fd..dda58e54d67 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -154,6 +154,11 @@
         <target state="translated">SharingPolicy.Isolated ile oluşturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin geçirilmesini desteklemez.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">PID = {0} işlemi sonlandırılıyor.</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: &lt;{1}&gt; öğesinin altındaki &lt;{0}&gt; öğesi tanınmıyor.</target>
+        <target state="translated">MSB4067: &lt;{1}&gt; öğesinin altındaki &lt;{0}&gt; öğesi tanınmıyor.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 400130f727e..8a2d41f5a59 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -154,6 +154,11 @@
         <target state="translated">使用 SharingPolicy.Isolated 创建的 EvaluationContext 对象不支持通过 MSBuildFileSystemBase 文件系统传递。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">正在终止进程，pid = {0}。</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: 无法识别元素 &lt;{1}&gt; 下面的元素 &lt;{0}&gt;。</target>
+        <target state="translated">MSB4067: 无法识别元素 &lt;{1}&gt; 下面的元素 &lt;{0}&gt;。</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 970cd8cd04f..3bae314d441 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -154,6 +154,11 @@
         <target state="translated">使用 SharingPolicy.Isolated 建立的 EvaluationContext 物件不支援以 MSBuildFileSystemBase 檔案系統傳遞。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ItemReferencingSelfInTarget">
+        <source>MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</source>
+        <target state="new">MSB4120: Item '{0}' definition within target references itself via (qualified or unqualified) metadatum '{1}'. This can lead to unintended expansion and cross-applying of pre-existing items. More info: https://aka.ms/msbuild/metadata-self-ref</target>
+        <note>{StrBegin="MSB4120: "}</note>
+      </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
         <target state="translated">正在終止 pid = {0} 的處理序。</target>
@@ -1851,7 +1856,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="needs-review-translation">MSB4067: 無法辨認項目 &lt;{1}&gt; 下的項目 &lt;{0}&gt;。</target>
+        <target state="translated">MSB4067: 無法辨認項目 &lt;{1}&gt; 下的項目 &lt;{0}&gt;。</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs b/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
index acd3388da81..8fc5e75a7b5 100644
--- a/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
@@ -63,7 +63,7 @@ public XmlElementChildIterator GetEnumerator()
                 return this;
             }
 
-            public XmlElementWithLocation Current
+            public readonly XmlElementWithLocation Current
             {
                 get
                 {
@@ -73,7 +73,7 @@ public XmlElementWithLocation Current
                 }
             }
 
-            private XmlElementWithLocation GetNextNode(XmlNode child)
+            private readonly XmlElementWithLocation GetNextNode(XmlNode child)
             {
                 while (child != null)
                 {
diff --git a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
index 15f8d543192..fe15c1e9287 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
@@ -425,13 +425,13 @@ internal ItemsAndMetadataPair(Hashtable items, Dictionary<string, MetadataRefere
 
         internal Hashtable Items
         {
-            get { return items; }
+            readonly get { return items; }
             set { items = value; }
         }
 
         internal Dictionary<string, MetadataReference> Metadata
         {
-            get { return metadata; }
+            readonly get { return metadata; }
             set { metadata = value; }
         }
     }
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index fe1a2d71613..b3f2e35187c 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -129,7 +129,7 @@
     </ItemGroup>
   </Target>
 
-  <Target Name="CreateTypeLib" BeforeTargets="AfterBuild" Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(CreateTlb)' == 'true' and $([MSBuild]::IsOSPlatform('windows')) and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MSBuildRuntimeType)' != 'Core'">
+  <Target Name="CreateTypeLib" BeforeTargets="AfterBuild" Inputs="$(TargetPath)" Outputs="$(TargetDir)$(TargetName).tlb;$(TargetDir)x64\$(TargetName).tlb" Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(CreateTlb)' == 'true' and $([MSBuild]::IsOSPlatform('windows')) and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MSBuildRuntimeType)' != 'Core'">
     <PropertyGroup>
       <TlbExpPath>$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPathToDotNetFrameworkSdkFile('tlbexp.exe'))</TlbExpPath>
       <!-- Provide a mechanism for turning on verbose TlbExp output for diagnosing issues -->
diff --git a/src/Framework/BuildEngineResult.cs b/src/Framework/BuildEngineResult.cs
index 9bb2a0c0b08..4371726a8a3 100644
--- a/src/Framework/BuildEngineResult.cs
+++ b/src/Framework/BuildEngineResult.cs
@@ -42,7 +42,7 @@ public BuildEngineResult(bool result, List<IDictionary<string, ITaskItem[]>> tar
         /// <summary>
         /// Did the build pass or fail. True means the build succeeded, False means the build failed.
         /// </summary>
-        public bool Result
+        public readonly bool Result
         {
             get
             {
diff --git a/src/Shared/EncodingUtilities.cs b/src/Framework/EncodingUtilities.cs
similarity index 97%
rename from src/Shared/EncodingUtilities.cs
rename to src/Framework/EncodingUtilities.cs
index b7d1813f368..9ad987bd730 100644
--- a/src/Shared/EncodingUtilities.cs
+++ b/src/Framework/EncodingUtilities.cs
@@ -7,6 +7,8 @@
 using System.Linq;
 using System.Text;
 
+using Microsoft.Build.Framework;
+
 #nullable disable
 
 namespace Microsoft.Build.Shared
@@ -48,17 +50,17 @@ internal static Encoding CurrentSystemOemEncoding
 
                 try
                 {
-                    if (NativeMethodsShared.IsWindows)
+                    if (NativeMethods.IsWindows)
                     {
 #if RUNTIME_TYPE_NETCORE
                         Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
 #endif
                         // get the current OEM code page
-                        s_currentOemEncoding = Encoding.GetEncoding(NativeMethodsShared.GetOEMCP());
+                        s_currentOemEncoding = Encoding.GetEncoding(NativeMethods.GetOEMCP());
                     }
                 }
                 // theoretically, GetEncoding may throw an ArgumentException or a NotSupportedException. This should never
-                // really happen, since the code page we pass in has just been returned from the "underlying platform", 
+                // really happen, since the code page we pass in has just been returned from the "underlying platform",
                 // so it really should support it. If it ever happens, we'll just fall back to the default encoding.
                 // No point in showing any errors to the users, since they most likely wouldn't be actionable.
                 catch (ArgumentException ex)
@@ -214,7 +216,7 @@ internal static bool CanEncodeString(int codePage, string stringToEncode)
         /// </remarks>
         internal static Encoding BatchFileEncoding(string contents, string encodingSpecification)
         {
-            if (!NativeMethodsShared.IsWindows)
+            if (!NativeMethods.IsWindows)
             {
                 return EncodingUtilities.Utf8WithoutBom;
             }
diff --git a/src/Framework/IIncrementalTask.cs b/src/Framework/IIncrementalTask.cs
new file mode 100644
index 00000000000..7a44e93f14b
--- /dev/null
+++ b/src/Framework/IIncrementalTask.cs
@@ -0,0 +1,19 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Interface for tasks which is supports incrementality.
+    /// </summary>
+    /// <remarks>The tasks implementing this interface should return false to stop the build when in <see cref="FailIfNotIncremental"/> is true and task is not fully incremental.  Try to provide helpful information to diagnose incremental behavior.</remarks>
+    public interface IIncrementalTask
+    {
+        /// <summary>
+        /// Set by MSBuild when Question flag is used.
+        /// </summary>
+        bool FailIfNotIncremental { set; }
+    }
+}
diff --git a/src/Framework/ITaskItemExtensions.cs b/src/Framework/ITaskItemExtensions.cs
index 9c4f18ea8ef..6ba56e1a880 100644
--- a/src/Framework/ITaskItemExtensions.cs
+++ b/src/Framework/ITaskItemExtensions.cs
@@ -35,7 +35,9 @@ public static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(this I
                 return enumerableMetadata;
             }
 
-            // In theory this should never be reachable.
+            // Fallback for
+            //  * ITaskItem implementations from MSBuild 3.5 from the GAC
+            //  * Custom ITaskItems that don't use Dictionary<string,string>
             var list = new KeyValuePair<string, string>[customMetadata.Count];
             int i = 0;
 
@@ -57,8 +59,7 @@ public static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(this I
                     Debug.Fail(e.ToString());
                 }
 
-                list[i] = new KeyValuePair<string, string>(metadataName, valueOrError);
-                i += 1;
+                list[i++] = new KeyValuePair<string, string>(metadataName, valueOrError);
             }
 
             return list;
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 85fbdddd446..c71d9f49ff6 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -345,7 +345,7 @@ private struct PROCESS_BASIC_INFORMATION
         public UIntPtr UniqueProcessId;
         public UIntPtr InheritedFromUniqueProcessId;
 
-        public uint Size
+        public readonly uint Size
         {
             get
             {
@@ -1480,6 +1480,73 @@ internal static void VerifyThrowWin32Result(int result)
         }
     }
 
+#if !CLR2COMPATIBILITY
+    internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalConsoleMode) QueryIsScreenAndTryEnableAnsiColorCodes()
+    {
+        if (Console.IsOutputRedirected)
+        {
+            // There's no ANSI terminal support is console output is redirected.
+            return (acceptAnsiColorCodes: false, outputIsScreen: false, originalConsoleMode: null);
+        }
+
+        bool acceptAnsiColorCodes = false;
+        bool outputIsScreen = false;
+        uint? originalConsoleMode = null;
+        if (IsWindows)
+        {
+            try
+            {
+                IntPtr stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
+                if (GetConsoleMode(stdOut, out uint consoleMode))
+                {
+                    if ((consoleMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == ENABLE_VIRTUAL_TERMINAL_PROCESSING)
+                    {
+                        // Console is already in required state.
+                        acceptAnsiColorCodes = true;
+                    }
+                    else
+                    {
+                        originalConsoleMode = consoleMode;
+                        consoleMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
+                        if (SetConsoleMode(stdOut, consoleMode) && GetConsoleMode(stdOut, out consoleMode))
+                        {
+                            // We only know if vt100 is supported if the previous call actually set the new flag, older
+                            // systems ignore the setting.
+                            acceptAnsiColorCodes = (consoleMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == ENABLE_VIRTUAL_TERMINAL_PROCESSING;
+                        }
+                    }
+
+                    uint fileType = GetFileType(stdOut);
+                    // The std out is a char type (LPT or Console).
+                    outputIsScreen = fileType == FILE_TYPE_CHAR;
+                    acceptAnsiColorCodes &= outputIsScreen;
+                }
+            }
+            catch
+            {
+                // In the unlikely case that the above fails we just ignore and continue.
+            }
+        }
+        else
+        {
+            // On posix OSes we expect console always supports VT100 coloring unless it is explicitly marked as "dumb".
+            acceptAnsiColorCodes = Environment.GetEnvironmentVariable("TERM") != "dumb";
+            // It wasn't redirected as tested above so we assume output is screen/console
+            outputIsScreen = true; 
+        }
+        return (acceptAnsiColorCodes, outputIsScreen, originalConsoleMode);
+    }
+
+    internal static void RestoreConsoleMode(uint? originalConsoleMode)
+    {
+        if (IsWindows && originalConsoleMode is not null)
+        {
+            IntPtr stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
+            _ = SetConsoleMode(stdOut, originalConsoleMode.Value);
+        }
+    }
+#endif // !CLR2COMPATIBILITY
+
     #endregion
 
     #region PInvoke
diff --git a/src/Framework/Profiler/EvaluationLocation.cs b/src/Framework/Profiler/EvaluationLocation.cs
index 43dc75bf28d..9f8f95ee9a6 100644
--- a/src/Framework/Profiler/EvaluationLocation.cs
+++ b/src/Framework/Profiler/EvaluationLocation.cs
@@ -101,7 +101,7 @@ public struct EvaluationLocation
         public EvaluationLocationKind Kind { get; }
 
         /// <nodoc/>
-        public bool IsEvaluationPass => File == null;
+        public readonly bool IsEvaluationPass => File == null;
 
         /// <nodoc/>
         public static EvaluationLocation CreateLocationForCondition(long? parentId, EvaluationPass evaluationPass, string evaluationDescription, string file,
@@ -183,7 +183,7 @@ public EvaluationLocation(EvaluationPass evaluationPass, string evaluationPassDe
         public static EvaluationLocation EmptyLocation { get; } = CreateEmptyLocation();
 
         /// <nodoc/>
-        public EvaluationLocation WithEvaluationPass(EvaluationPass evaluationPass, string passDescription = null)
+        public readonly EvaluationLocation WithEvaluationPass(EvaluationPass evaluationPass, string passDescription = null)
         {
             return new EvaluationLocation(this.Id, evaluationPass, passDescription ?? PassDefaultDescription[evaluationPass],
                 this.File, this.Line, this.ElementName, this.ElementDescription, this.Kind);
diff --git a/src/Framework/XamlTypes/ProjectSchemaDefinitions.cs b/src/Framework/XamlTypes/ProjectSchemaDefinitions.cs
index 818795fbe20..0a261bceaba 100644
--- a/src/Framework/XamlTypes/ProjectSchemaDefinitions.cs
+++ b/src/Framework/XamlTypes/ProjectSchemaDefinitions.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
+using System.Linq;
 using System.Windows.Markup;
 
 #nullable disable
@@ -41,16 +42,7 @@ public List<IProjectSchemaNode> Nodes
         [SuppressMessage("Microsoft.Usage", "CA2301:EmbeddableTypesInContainersRule", MessageId = "allTypes", Justification = "All object types come from within this assembly, so there will not be any type equivalence problems")]
         public IEnumerable<Type> GetSchemaObjectTypes()
         {
-            Dictionary<Type, bool> allTypes = new Dictionary<Type, bool>();
-            foreach (IProjectSchemaNode node in Nodes)
-            {
-                foreach (Type t in node.GetSchemaObjectTypes())
-                {
-                    allTypes[t] = true;
-                }
-            }
-
-            return allTypes.Keys;
+            return Nodes.SelectMany(node => node.GetSchemaObjectTypes()).Distinct();
         }
 
         /// <summary>
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 5ebb1fa8b8a..423de50897b 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -24,6 +24,7 @@
 
     <!-- Include NuGet build tasks -->
     <PackageReference Include="NuGet.Build.Tasks" />
+    <PackageReference Include="NuGet.Build.Tasks.Console" />
     <PackageReference Include="Microsoft.Build.NuGetSdkResolver" />
 
     <!-- As of 17.5, NuGet.Build.Tasks and Microsoft.Build.NuGetSdkResolver depends on Newtonsoft.Json version 13.0.1,
@@ -45,10 +46,10 @@
 
   <!-- Use deps file from this project with additional dependencies listed instead of the one generated in the MSBuild project -->
   <Target Name="UpdateMSBuildDepsFile" AfterTargets="Build" Condition="'$(MonoBuild)' != 'true' and ($([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp2.1')) or '$(TargetFramework)' == 'netstandard2.0')">
-    <Copy SourceFiles="$(OutputPath)$(AssemblyName).deps.json" DestinationFiles="$(OutputPath)MSBuild.deps.json" />
+    <Copy SourceFiles="$(OutputPath)$(AssemblyName).deps.json" DestinationFiles="$(OutputPath)MSBuild.deps.json" SkipUnchangedFiles="true" />
   </Target>
   <Target Name="UpdatePublishedMSBuildDepsFile" AfterTargets="Publish" Condition="'$(TargetFramework)' == '$(LatestDotNetCoreForMSBuild)'">
-    <Copy SourceFiles="$(PublishDir)$(AssemblyName).deps.json" DestinationFiles="$(PublishDir)MSBuild.deps.json" />
+    <Copy SourceFiles="$(PublishDir)$(AssemblyName).deps.json" DestinationFiles="$(PublishDir)MSBuild.deps.json" SkipUnchangedFiles="true" />
   </Target>
 
   <Import Project="..\Package\GetBinPaths.targets" Condition="$(TargetFramework.StartsWith('net4'))"/>
diff --git a/src/MSBuild.Bootstrap/RedirectNuGetConsoleProcess.After.Microsoft.Common.targets b/src/MSBuild.Bootstrap/RedirectNuGetConsoleProcess.After.Microsoft.Common.targets
new file mode 100644
index 00000000000..3571d7e37f5
--- /dev/null
+++ b/src/MSBuild.Bootstrap/RedirectNuGetConsoleProcess.After.Microsoft.Common.targets
@@ -0,0 +1,23 @@
+<Project>
+  <!-- The CoreCLR flavor of NuGet.Build.Tasks.Console.exe looks for dotnet under "..\..\dotnet", so we need to redirect it for the bootstrap to the currently executing dotnet.exe.
+       See: https://github.com/NuGet/NuGet.Client/blob/91f6fdb26b09e16c4520b1d13ee30bb38172a7bd/src/NuGet.Core/NuGet.Build.Tasks/StaticGraphRestoreTaskBase.cs#L240-L252 -->
+  <UsingTask
+    TaskName="GetCurrentProcessFileName"
+    TaskFactory="RoslynCodeTaskFactory"
+    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
+    <ParameterGroup>
+      <CurrentProcessFileName ParameterType="System.String" Output="true" />
+    </ParameterGroup>
+    <Task>
+      <Using Namespace="System.Diagnostics" />
+      <Code Type="Fragment" Language="cs"><![CDATA[
+      CurrentProcessFileName = Process.GetCurrentProcess().MainModule.FileName;
+      ]]></Code>
+    </Task>
+  </UsingTask>
+  <Target Name="RedirectNuGetConsoleProcess" BeforeTargets="Restore">
+    <GetCurrentProcessFileName>
+      <Output TaskParameter="CurrentProcessFileName" PropertyName="NuGetConsoleProcessFileName" />
+    </GetCurrentProcessFileName>
+  </Target>
+</Project>
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index ca52d2e3156..551114540e1 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -156,6 +156,31 @@ public void DistributedFileLoggerSwitchIdentificationTests(string distributedfil
             duplicateSwitchErrorMessage.ShouldBeNull();
         }
 
+        [Theory]
+        [InlineData("ll")]
+        [InlineData("LL")]
+        [InlineData("livelogger")]
+        [InlineData("LiveLogger")]
+        [InlineData("LIVELOGGER")]
+        [InlineData("tl")]
+        [InlineData("TL")]
+        [InlineData("terminallogger")]
+        [InlineData("TerminalLogger")]
+        [InlineData("TERMINALLOGGER")]
+        public void LiveLoggerSwitchIdentificationTests(string livelogger)
+        {
+            CommandLineSwitches.ParameterizedSwitch parameterlessSwitch;
+            string duplicateSwitchErrorMessage;
+
+            CommandLineSwitches.IsParameterizedSwitch(livelogger, out parameterlessSwitch, out duplicateSwitchErrorMessage, out bool multipleParametersAllowed, out string missingParametersErrorMessage, out bool unquoteParameters, out bool emptyParametersAllowed).ShouldBeTrue();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.LiveLogger);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldBeNull();
+            unquoteParameters.ShouldBeTrue();
+            emptyParametersAllowed.ShouldBeTrue();
+        }
+
         [Theory]
         [InlineData("flp")]
         [InlineData("FLP")]
@@ -1023,6 +1048,7 @@ public void InvalidToolsVersionErrors()
                                         isolateProjects: ProjectIsolationMode.False,
                                         graphBuildOptions: null,
                                         lowPriority: false,
+                                        question: false,
                                         inputResultsCaches: null,
                                         outputResultsCache: null,
                                         commandLine: null);
diff --git a/src/MSBuild.UnitTests/LiveLogger_Tests.cs b/src/MSBuild.UnitTests/LiveLogger_Tests.cs
new file mode 100644
index 00000000000..bf4b542d3b1
--- /dev/null
+++ b/src/MSBuild.UnitTests/LiveLogger_Tests.cs
@@ -0,0 +1,230 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Net.NetworkInformation;
+using System.Text.RegularExpressions;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Logging.LiveLogger;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests
+{
+    public class LiveLogger_Tests : IEventSource, IDisposable
+    {
+        private const int _nodeCount = 8;
+        private const int _terminalWidth = 80;
+        private const int _terminalHeight = 40;
+        private const string _eventSender = "Test";
+        private const string _projectFile = @"C:\src\project.proj";
+
+        private readonly MockTerminal _mockTerminal;
+        private readonly LiveLogger _liveLogger;
+
+        private readonly DateTime _buildStartTime = new DateTime(2023, 3, 30, 16, 30, 0);
+        private readonly DateTime _buildFinishTime = new DateTime(2023, 3, 30, 16, 30, 5);
+
+        public LiveLogger_Tests()
+        {
+            _mockTerminal = new MockTerminal(_terminalWidth, _terminalHeight);
+            _liveLogger = new LiveLogger(_mockTerminal);
+
+            _liveLogger.Initialize(this, _nodeCount);
+        }
+
+        #region IEventSource implementation
+
+#pragma warning disable CS0067
+        public event BuildMessageEventHandler? MessageRaised;
+
+        public event BuildErrorEventHandler? ErrorRaised;
+
+        public event BuildWarningEventHandler? WarningRaised;
+
+        public event BuildStartedEventHandler? BuildStarted;
+
+        public event BuildFinishedEventHandler? BuildFinished;
+
+        public event ProjectStartedEventHandler? ProjectStarted;
+
+        public event ProjectFinishedEventHandler? ProjectFinished;
+
+        public event TargetStartedEventHandler? TargetStarted;
+
+        public event TargetFinishedEventHandler? TargetFinished;
+
+        public event TaskStartedEventHandler? TaskStarted;
+
+        public event TaskFinishedEventHandler? TaskFinished;
+
+        public event CustomBuildEventHandler? CustomEventRaised;
+
+        public event BuildStatusEventHandler? StatusEventRaised;
+
+        public event AnyEventHandler? AnyEventRaised;
+#pragma warning restore CS0067
+
+        #endregion
+
+        #region IDisposable implementation
+
+        public void Dispose()
+        {
+            _liveLogger.Shutdown();
+        }
+
+        #endregion
+
+        #region Event args helpers
+
+        private BuildEventContext MakeBuildEventContext()
+        {
+            return new BuildEventContext(1, 1, 1, 1);
+        }
+
+        private BuildStartedEventArgs MakeBuildStartedEventArgs()
+        {
+            return new BuildStartedEventArgs(null, null, _buildStartTime);
+        }
+
+        private BuildFinishedEventArgs MakeBuildFinishedEventArgs(bool succeeded)
+        {
+            return new BuildFinishedEventArgs(null, null, succeeded, _buildFinishTime);
+        }
+
+        private ProjectStartedEventArgs MakeProjectStartedEventArgs(string projectFile, string targetNames = "Build")
+        {
+            return new ProjectStartedEventArgs("", "", projectFile, targetNames, new Dictionary<string, string>(), new List<DictionaryEntry>())
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private ProjectFinishedEventArgs MakeProjectFinishedEventArgs(string projectFile, bool succeeded)
+        {
+            return new ProjectFinishedEventArgs(null, null, projectFile, succeeded)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TargetStartedEventArgs MakeTargetStartedEventArgs(string projectFile, string targetName)
+        {
+            return new TargetStartedEventArgs("", "", targetName, projectFile, targetFile: projectFile)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TargetFinishedEventArgs MakeTargetFinishedEventArgs(string projectFile, string targetName, bool succeeded)
+        {
+            return new TargetFinishedEventArgs("", "", targetName, projectFile, targetFile: projectFile, succeeded)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TaskStartedEventArgs MakeTaskStartedEventArgs(string projectFile, string taskName)
+        {
+            return new TaskStartedEventArgs("", "", projectFile, taskFile: projectFile, taskName)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private TaskFinishedEventArgs MakeTaskFinishedEventArgs(string projectFile, string taskName, bool succeeded)
+        {
+            return new TaskFinishedEventArgs("", "", projectFile, taskFile: projectFile, taskName, succeeded)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private BuildWarningEventArgs MakeWarningEventArgs(string warning)
+        {
+            return new BuildWarningEventArgs("", "", "", 0, 0, 0, 0, warning, null, null)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        private BuildErrorEventArgs MakeErrorEventArgs(string error)
+        {
+            return new BuildErrorEventArgs("", "", "", 0, 0, 0, 0, error, null, null)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
+        #endregion
+
+        #region Build summary tests
+
+        private void InvokeLoggerCallbacksForSimpleProject(bool succeeded, Action additionalCallbacks)
+        {
+            BuildStarted?.Invoke(_eventSender, MakeBuildStartedEventArgs());
+            ProjectStarted?.Invoke(_eventSender, MakeProjectStartedEventArgs(_projectFile));
+
+            TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
+            TaskStarted?.Invoke(_eventSender, MakeTaskStartedEventArgs(_projectFile, "Task"));
+
+            additionalCallbacks();
+
+            TaskFinished?.Invoke(_eventSender, MakeTaskFinishedEventArgs(_projectFile, "Task", succeeded));
+            TargetFinished?.Invoke(_eventSender, MakeTargetFinishedEventArgs(_projectFile, "Build", succeeded));
+
+            ProjectFinished?.Invoke(_eventSender, MakeProjectFinishedEventArgs(_projectFile, succeeded));
+            BuildFinished?.Invoke(_eventSender, MakeBuildFinishedEventArgs(succeeded));
+        }
+
+        [Fact]
+        public void PrintsBuildSummary_Succeeded()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: true, () => { });
+            _mockTerminal.GetLastLine().WithoutAnsiCodes().ShouldBe("Build succeeded in 5.0s");
+        }
+
+        [Fact]
+        public void PrintBuildSummary_SucceededWithWarnings()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: true, () =>
+            {
+                WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("Warning!"));
+            });
+            _mockTerminal.GetLastLine().WithoutAnsiCodes().ShouldBe("Build succeeded with warnings in 5.0s");
+        }
+
+        [Fact]
+        public void PrintBuildSummary_Failed()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, () => { });
+            _mockTerminal.GetLastLine().WithoutAnsiCodes().ShouldBe("Build failed in 5.0s");
+        }
+
+        [Fact]
+        public void PrintBuildSummary_FailedWithErrors()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, () =>
+            {
+                ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Error!"));
+            });
+            _mockTerminal.GetLastLine().WithoutAnsiCodes().ShouldBe("Build failed with errors in 5.0s");
+        }
+
+        #endregion
+
+    }
+
+    internal static class StringVT100Extensions
+    {
+        private static Regex s_removeAnsiCodes = new Regex("\\x1b\\[[0-9;]*[mGKHF]");
+
+        public static string WithoutAnsiCodes(this string text)
+        {
+            return s_removeAnsiCodes.Replace(text, string.Empty);
+        }
+    }
+}
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index a7ea9759b10..87759cd7929 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -221,10 +221,6 @@ public void CanShutdownServerProcess(bool byBuildManager)
         {
             _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
 
-            // This test seems to be flaky, lets enable better logging to investigate it next time
-            // TODO: delete after investigated its flakiness
-            _env.WithTransientDebugEngineForNewProcesses(true);
-
             TransientTestFile project = _env.CreateFile("testProject.proj", printPidContents);
 
             // Start a server node and find its PID.
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index 61f2c68c312..f7c8683c7af 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -45,6 +45,9 @@
     <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
 
+    <Compile Remove="LiveLogger_Tests.cs" Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'" />
+    <Compile Remove="MockTerminal.cs" Condition="'$(TargetFrameworkIdentifier)' != '.NETCoreApp'" />
+
     <EmbeddedResource Include="..\MSBuild\MSBuild\Microsoft.Build.Core.xsd">
       <Link>Microsoft.Build.Core.xsd</Link>
       <SubType>
diff --git a/src/MSBuild.UnitTests/MockTerminal.cs b/src/MSBuild.UnitTests/MockTerminal.cs
new file mode 100644
index 00000000000..26f5c39d973
--- /dev/null
+++ b/src/MSBuild.UnitTests/MockTerminal.cs
@@ -0,0 +1,119 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using Microsoft.Build.Logging.LiveLogger;
+
+namespace Microsoft.Build.UnitTests
+{
+    /// <summary>
+    /// A test implementation of <see cref="ITerminal"/>.
+    /// </summary>
+    internal sealed class MockTerminal : ITerminal
+    {
+        private readonly int _width;
+        private readonly int _height;
+
+        /// <summary>
+        /// Contains output lines written to the terminal.
+        /// </summary>
+        private List<string> _outputLines = new();
+
+        private StringBuilder _bufferedOutput = new();
+        private bool _isBuffering = false;
+
+        public MockTerminal(int width, int height)
+        {
+            _width = width;
+            _height = height;
+            _outputLines.Add("");
+        }
+
+        /// <summary>
+        /// Gets the last line written to the terminal.
+        /// </summary>
+        /// <remarks>
+        /// If the last character was \n, it returns characters between the second to last \n and last \n.
+        /// If the last character was not \n, it returns characters between the last \n and the end of the output.
+        /// </remarks>
+        public string GetLastLine()
+        {
+            string lastLine = _outputLines[^1];
+            if (lastLine.Length == 0 && _outputLines.Count > 1)
+            {
+                lastLine = _outputLines[^2];
+            }
+            return lastLine;
+        }
+
+        /// <summary>
+        /// Adds a string to <see cref="_outputLines"/>.
+        /// </summary>
+        private void AddOutput(string text)
+        {
+            if (_isBuffering)
+            {
+                _bufferedOutput.Append(text);
+            }
+            else
+            {
+                string[] lines = text.Split('\n');
+                _outputLines[^1] += lines[0];
+                for (int i = 1; i < lines.Length; i++)
+                {
+                    _outputLines.Add("");
+                    _outputLines[^1] += lines[i];
+                }
+            }
+        }
+
+        #region ITerminal implementation
+
+        public int Width => _width;
+        public int Height => _height;
+
+        public void BeginUpdate()
+        {
+            if (_isBuffering)
+            {
+                throw new InvalidOperationException();
+            }
+            _isBuffering = true;
+        }
+
+        public void EndUpdate()
+        {
+            if (!_isBuffering)
+            {
+                throw new InvalidOperationException();
+            }
+            _isBuffering = false;
+
+            AddOutput(_bufferedOutput.ToString());
+            _bufferedOutput.Clear();
+        }
+
+        public void Write(string text) => AddOutput(text);
+        public void Write(ReadOnlySpan<char> text) { AddOutput(text.ToString()); }
+        public void WriteColor(TerminalColor color, string text) => AddOutput(text);
+        public void WriteColorLine(TerminalColor color, string text) { AddOutput(text); AddOutput("\n"); }
+
+        public void WriteLine(string text) { AddOutput(text); AddOutput("\n"); }
+        public void WriteLineFitToWidth(ReadOnlySpan<char> text)
+        {
+            AddOutput(text.Slice(0, Math.Min(text.Length, _width - 1)).ToString());
+            AddOutput("\n");
+        }
+
+        #endregion
+
+        #region IDisposable implementation
+
+        public void Dispose()
+        { }
+
+        #endregion
+    }
+}
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 9a7d968a673..5b2f7e67fb4 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -47,7 +47,6 @@ internal enum ParameterlessSwitch
             FileLogger8,
             FileLogger9,
             DistributedFileLogger,
-            LiveLogger,
 #if DEBUG
             WaitForDebugger,
 #endif
@@ -90,6 +89,7 @@ internal enum ParameterizedSwitch
             FileLoggerParameters7,
             FileLoggerParameters8,
             FileLoggerParameters9,
+            LiveLogger,
             NodeReuse,
             Preprocess,
             Targets,
@@ -106,6 +106,7 @@ internal enum ParameterizedSwitch
             InputResultsCaches,
             OutputResultsCache,
             LowPriority,
+            Question,
             DetailedSummary,
             NumberOfParameterizedSwitches,
         }
@@ -150,12 +151,15 @@ private struct ParameterizedSwitchInfo
             /// <summary>
             /// Initializes struct data.
             /// </summary>
-            /// <param name="switchNames"></param>
-            /// <param name="parameterizedSwitch"></param>
-            /// <param name="duplicateSwitchErrorMessage"></param>
-            /// <param name="multipleParametersAllowed"></param>
-            /// <param name="missingParametersErrorMessage"></param>
-            /// <param name="unquoteParameters"></param>
+            /// <param name="switchNames">Names of the switch (without leading switch indicator).</param>
+            /// <param name="parameterizedSwitch">The switch id.</param>
+            /// <param name="duplicateSwitchErrorMessage">If <see langword="null"/>, indicates that switch is allowed to appear multiple times on the command line; otherwise, holds the error message to display if switch appears more than once</param>
+            /// <param name="multipleParametersAllowed">Indicates if switch can take multiple parameters (equivalent to switch appearing multiple times on command line)
+            /// NOTE: for most switches, if a switch is allowed to appear multiple times on the command line, then multiple
+            /// parameters can be provided per switch; however, some switches cannot take multiple parameters.</param>
+            /// <param name="missingParametersErrorMessage">If <see langword="null"/>, indicates that switch is allowed to have no parameters; otherwise, holds the error message to show if switch is found without parameters on the command line</param>
+            /// <param name="unquoteParameters">Indicates if quotes should be removed from the switch parameters</param>
+            /// <param name="emptyParametersAllowed">Indicates if empty parameters are allowed and if so an empty string will be added to the list of parameter values.</param>
             internal ParameterizedSwitchInfo(
                 string[] switchNames,
                 ParameterizedSwitch parameterizedSwitch,
@@ -174,23 +178,12 @@ internal ParameterizedSwitchInfo(
                 this.emptyParametersAllowed = emptyParametersAllowed;
             }
 
-            // names of the switch (without leading switch indicator)
             internal string[] switchNames;
-            // if null, indicates that switch is allowed to appear multiple times on the command line; otherwise, holds the error
-            // message to display if switch appears more than once
             internal string duplicateSwitchErrorMessage;
-            // indicates if switch can take multiple parameters (equivalent to switch appearing multiple times on command line)
-            // NOTE: for most switches, if a switch is allowed to appear multiple times on the command line, then multiple
-            // parameters can be provided per switch; however, some switches cannot take multiple parameters
             internal bool multipleParametersAllowed;
-            // if null, indicates that switch is allowed to have no parameters; otherwise, holds the error message to show if
-            // switch is found without parameters on the command line
             internal string missingParametersErrorMessage;
-            // indicates if quotes should be removed from the switch parameters
             internal bool unquoteParameters;
-            // the switch id
             internal ParameterizedSwitch parameterizedSwitch;
-            // indicates if empty parameters are allowed and if so an empty string will be added to the list of parameter values
             internal bool emptyParametersAllowed;
         }
 
@@ -217,7 +210,6 @@ internal ParameterizedSwitchInfo(
             new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },                     ParameterlessSwitch.FileLogger8,           null),
             new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },                     ParameterlessSwitch.FileLogger9,           null),
             new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },           ParameterlessSwitch.DistributedFileLogger, null),
-            new ParameterlessSwitchInfo(  new string[] { "livelogger", "ll", "fancylogger", "flg" }, ParameterlessSwitch.LiveLogger,            null),
 #if DEBUG
             new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },                 ParameterlessSwitch.WaitForDebugger,       null),
 #endif
@@ -254,6 +246,7 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters7", "flp7" },     ParameterizedSwitch.FileLoggerParameters7,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters8", "flp8" },     ParameterizedSwitch.FileLoggerParameters8,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters9", "flp9" },     ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "livelogger", "ll", "terminallogger", "tl" }, ParameterizedSwitch.LiveLogger,          null,                           true,          null,                                  true,   true),
             new ParameterizedSwitchInfo(  new string[] { "nodereuse", "nr" },                   ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false),
             new ParameterizedSwitchInfo(  new string[] { "preprocess", "pp" },                  ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "targets", "ts" },                     ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false),
@@ -270,6 +263,7 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "inputResultsCaches", "irc" },         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true),
             new ParameterizedSwitchInfo(  new string[] { "outputResultsCache", "orc" },         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true),
             new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false),
         };
 
diff --git a/src/MSBuild/LiveLogger/ANSIBuilder.cs b/src/MSBuild/LiveLogger/ANSIBuilder.cs
deleted file mode 100644
index f787c2949b3..00000000000
--- a/src/MSBuild/LiveLogger/ANSIBuilder.cs
+++ /dev/null
@@ -1,452 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Text.RegularExpressions;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-    internal static class ANSIBuilder
-    {
-        public static string ANSIRegex = @"\x1b(?:[@-Z\-_]|\[[0-?]*[ -\/]*[@-~]|(?:\]8;;.*?\x1b\\))";
-        // TODO: This should replace ANSIRegex once LiveLogger's API is internal
-        public static Regex ANSIRegexRegex = new Regex(ANSIRegex);
-        public static string ANSIRemove(string text)
-        {
-            return ANSIRegexRegex.Replace(text, "");
-        }
-
-        /// <summary>
-        /// Find a place to break a string after a number of visible characters, not counting VT-100 codes.
-        /// </summary>
-        /// <param name="text">String to split.</param>
-        /// <param name="position">Number of visible characters to split after.</param>
-        /// <returns>Index in <paramref name="text"/> that represents <paramref name="position"/> visible characters.</returns>
-        // TODO: This should be an optional parameter for ANSIBreakpoint(string text, int positioon, int initialPosition = 0)
-        public static int ANSIBreakpoint(string text, int position)
-        {
-            return ANSIBreakpoint(text, position, 0);
-        }
-        public static int ANSIBreakpoint(string text, int position, int initialPosition)
-        {
-            if (position >= text.Length)
-            {
-                return text.Length;
-            }
-            int nonAnsiIndex = 0;
-            Match nextMatch = ANSIRegexRegex.Match(text, initialPosition);
-            int logicalIndex = 0;
-            while (logicalIndex < text.Length && nonAnsiIndex != position)
-            {
-                // Jump over ansi codes
-                if (logicalIndex == nextMatch.Index && nextMatch.Length > 0)
-                {
-                    logicalIndex += nextMatch.Length;
-                    nextMatch = nextMatch.NextMatch();
-                }
-                // Increment non ansi index
-                nonAnsiIndex++;
-                logicalIndex++;
-            }
-            return logicalIndex;
-        }
-
-        public static List<string> ANSIWrap(string text, int maxLength)
-        {
-            ReadOnlySpan<char> textSpan = text.AsSpan();
-            List<string> result = new();
-            int breakpoint = ANSIBreakpoint(text, maxLength);
-            while (textSpan.Length > breakpoint)
-            {
-                result.Add(textSpan.Slice(0, breakpoint).ToString());
-                textSpan = textSpan.Slice(breakpoint);
-                breakpoint = ANSIBreakpoint(text, maxLength, breakpoint);
-            }
-            result.Add(textSpan.ToString());
-            return result;
-        }
-
-        public static class Alignment
-        {
-            public static string Center(string text)
-            {
-                string result = String.Empty;
-                string noFormatString = ANSIRemove(text);
-                if (noFormatString.Length > Console.BufferWidth)
-                {
-                    return text;
-                }
-
-                int space = (Console.BufferWidth - noFormatString.Length) / 2;
-                result += new string(' ', space);
-                result += text;
-                result += new string(' ', space);
-                return result;
-            }
-
-            public static string Right(string text)
-            {
-                string result = String.Empty;
-                string noFormatString = ANSIRemove(text);
-                if (noFormatString.Length > Console.BufferWidth)
-                {
-                    return text;
-                }
-
-                int space = Console.BufferWidth - noFormatString.Length;
-                result += new string(' ', space);
-                result += text;
-                return result;
-            }
-
-            public static string Left(string text)
-            {
-                string result = String.Empty;
-                string noFormatString = ANSIRemove(text);
-                if (noFormatString.Length > Console.BufferWidth)
-                {
-                    return text;
-                }
-
-                int space = Console.BufferWidth - noFormatString.Length;
-                result += text;
-                result += new string(' ', space);
-                return result;
-            }
-
-            public static string SpaceBetween(string leftText, string rightText, int width)
-            {
-                string result = String.Empty;
-                string leftNoFormatString = ANSIRemove(leftText);
-                string rightNoFormatString = ANSIRemove(rightText);
-                if (leftNoFormatString.Length + rightNoFormatString.Length >= width)
-                {
-                    return leftText + rightText;
-                }
-
-                int space = width - (leftNoFormatString.Length + rightNoFormatString.Length);
-                result += leftText;
-                result += new string(' ', space - 1);
-                result += rightText;
-                return result;
-            }
-        }
-
-        public static class Formatting
-        {
-            public enum ForegroundColor
-            {
-                Black = 30,
-                Red = 31,
-                Green = 32,
-                Yellow = 33,
-                Blue = 34,
-                Magenta = 35,
-                Cyan = 36,
-                White = 37,
-                Default = 39
-            };
-
-            public enum BackgroundColor
-            {
-                Black = 40,
-                Red = 41,
-                Green = 42,
-                Yellow = 43,
-                Blue = 44,
-                Magenta = 45,
-                Cyan = 46,
-                White = 47,
-                Default = 49
-            }
-
-            public static string Color(string text, ForegroundColor color)
-            {
-                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
-            }
-
-            public static string Color(string text, BackgroundColor color)
-            {
-                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
-            }
-
-            public static string Color(string text, BackgroundColor backgrdoundColor, ForegroundColor foregroundColor)
-            {
-                return String.Format("\x1b[{0};{1}m{2}\x1b[0m", (int)backgrdoundColor, (int)foregroundColor, text);
-            }
-
-            public static string Bold(string text)
-            {
-                return String.Format("\x1b[1m{0}\x1b[22m", text);
-            }
-
-            public static string Dim(string text)
-            {
-                return String.Format("\x1b[2m{0}\x1b[22m", text);
-            }
-
-            public static string Italic(string text)
-            {
-                return String.Format("\x1b[3m{0}\x1b[23m", text);
-            }
-
-            public static string Underlined(string text)
-            {
-                return String.Format("\x1b[4m{0}\x1b[24m", text);
-            }
-
-            public static string DoubleUnderlined(string text)
-            {
-                return String.Format("\x1b[21m{0}\x1b[24m", text);
-            }
-
-            public static string Inverse(string text)
-            {
-                return String.Format("\x1b[7m{0}\x1b[27m", text);
-            }
-
-            public static string Invisible(string text)
-            {
-                return String.Format("\x1b[8m{0}\x1b[28m", text);
-            }
-
-            public static string CrossedOut(string text)
-            {
-                return String.Format("\x1b[9m{0}\x1b[29m", text);
-            }
-
-            public static string Overlined(string text)
-            {
-                return String.Format("\x1b[53m{0}\x1b[55m", text);
-            }
-
-            public static string Hyperlink(string text, string rawUrl)
-            {
-                string url = rawUrl.Length > 0 ? new System.Uri(rawUrl).AbsoluteUri : rawUrl;
-                return $"\x1b]8;;{url}\x1b\\{text}\x1b]8;;\x1b\\";
-            }
-
-            public static string DECLineDrawing(string text)
-            {
-                return String.Format("\x1b(0{0}\x1b(B", text);
-            }
-        }
-
-        public static class Cursor
-        {
-            public enum CursorStyle
-            {
-                Default = 0,
-                BlockBlinking = 1,
-                BlockSteady = 2,
-                UnderlineBlinking = 3,
-                UnderlineSteady = 4,
-                BarBlinking = 5,
-                BarSteady = 6,
-            }
-
-            public static string Style(CursorStyle style)
-            {
-                return String.Format("\x1b[{0} q", (int)style);
-            }
-
-            public static string Up(int n = 1)
-            {
-                return String.Format("\x1b[{0}A", n);
-            }
-
-            public static string UpAndScroll(int n)
-            {
-                string result = "";
-                for (int i = 0; i < n; i++)
-                {
-                    result += "\x1bM";
-                }
-                return result;
-            }
-
-            public static string Down(int n = 1)
-            {
-                return String.Format("\x1b[{0}B", n);
-            }
-
-            public static string Forward(int n = 1)
-            {
-                return String.Format("\x1b[{0}C", n);
-            }
-
-            public static string Backward(int n = 1)
-            {
-                return String.Format("\x1b[{0}D", n);
-            }
-
-            public static string Home()
-            {
-                return String.Format("\x1b[H");
-            }
-
-            public static string Position(int row, int column)
-            {
-                return String.Format("\x1b[{0};{1}H", row, column);
-            }
-
-            public static string SavePosition()
-            {
-                return String.Format("\x1b[s");
-            }
-
-            public static string RestorePosition()
-            {
-                return String.Format("\x1b[u");
-            }
-
-            public static string Invisible()
-            {
-                return "\x1b[?25l";
-            }
-
-            public static string Visible()
-            {
-                return "\x1b[?25h";
-            }
-        }
-
-        public static class Tabulator
-        {
-            public static string SetStop()
-            {
-                return String.Format("\x1bH");
-            }
-
-            public static string ForwardTab(int n)
-            {
-                if (n == 0)
-                {
-                    return "";
-                }
-
-                return String.Format("\x1b[{0}I", n);
-            }
-
-            public static string BackwardTab(int n)
-            {
-                return String.Format("\x1b[{0}Z", n);
-            }
-
-            public static string UnsetStop()
-            {
-                return String.Format("\x1b[0g");
-            }
-
-            public static string UnserAlStops()
-            {
-                return String.Format("\x1b[3g");
-            }
-        }
-
-        public static class Viewport
-        {
-            public static string ScrollDown(int n)
-            {
-                return String.Format("\x1b[{0}T", n);
-            }
-
-            public static string ScrollUp(int n)
-            {
-                return String.Format("\x1b[{0}S", n);
-            }
-
-            public static string SetScrollingRegion(int start, int end)
-            {
-                return String.Format("\x1b[{0};{1}r", start, end);
-            }
-
-            public static string PrependLines(int n)
-            {
-                return String.Format("\x1b[{0}L", n);
-            }
-
-            public static string DeleteLines(int n)
-            {
-                return String.Format("\x1b[{0}M", n);
-            }
-        }
-
-        public static class Eraser
-        {
-            public static string DisplayCursorToEnd()
-            {
-                return String.Format("\x1b[0J");
-            }
-
-            public static string DisplayStartToCursor()
-            {
-                return String.Format("\x1b[1J");
-            }
-
-            public static string Display()
-            {
-                return String.Format("\x1b[2J");
-            }
-
-            public static string LineCursorToEnd()
-            {
-                return String.Format("\x1b[0K");
-            }
-
-            public static string LineStartToCursor()
-            {
-                return String.Format("\x1b[1K");
-            }
-
-            public static string Line()
-            {
-                return String.Format("\x1b[2k");
-            }
-        }
-
-        public static class Graphics
-        {
-            private static int spinnerCounter = 0;
-            public static string Spinner()
-            {
-                return Spinner(spinnerCounter++);
-            }
-
-            public static string Spinner(int n)
-            {
-                char[] chars = { '\\', '|', '/', '-' };
-                return chars[n % (chars.Length - 1)].ToString();
-            }
-
-            public static string ProgressBar(float percentage, int width = 10, char completedChar = '█', char remainingChar = '░')
-            {
-                return new string(completedChar, (int)Math.Floor(width * percentage)) + new string(remainingChar, width - (int)Math.Floor(width * percentage));
-            }
-
-            public static string Bell()
-            {
-                return String.Format("\x07");
-            }
-        }
-
-        public static class Buffer
-        {
-            public static string Fill()
-            {
-                return String.Format("\x1b#8");
-            }
-
-            public static string UseAlternateBuffer()
-            {
-                return "\x1b[?1049h";
-            }
-
-            public static string UseMainBuffer()
-            {
-                return "\x1b[?1049l";
-            }
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/AnsiCodes.cs b/src/MSBuild/LiveLogger/AnsiCodes.cs
new file mode 100644
index 00000000000..edeb0fc4dcc
--- /dev/null
+++ b/src/MSBuild/LiveLogger/AnsiCodes.cs
@@ -0,0 +1,98 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// A collection of standard ANSI/VT100 control codes.
+/// </summary>
+internal static class AnsiCodes
+{
+    /// <summary>
+    /// The control sequence introducer.
+    /// </summary>
+    public const string CSI = "\x1b[";
+
+    /// <summary>
+    /// Select graphic rendition.
+    /// </summary>
+    /// <remarks>\
+    /// Print <see cref="CSI"/>color-code<see cref="SetColor"/> to change text color.
+    /// </remarks>
+    public const string SetColor = ";1m";
+
+    /// <summary>
+    /// A shortcut to reset color back to normal.
+    /// </summary>
+    public const string SetDefaultColor = CSI + "m";
+
+    /// <summary>
+    /// Non-xterm extension to render a hyperlink.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="LinkPrefix"/>url<see cref="LinkInfix"/>text<see cref="LinkSuffix"/> to render a hyperlink.
+    /// </remarks>
+    public const string LinkPrefix = "\x1b]8;;";
+
+    /// <summary>
+    /// <see cref="LinkPrefix"/>
+    /// </summary>
+    public const string LinkInfix = "\x1b\\";
+
+    /// <summary>
+    /// <see cref="LinkPrefix"/>
+    /// </summary>
+    public const string LinkSuffix = "\x1b]8;;\x1b\\";
+
+    /// <summary>
+    /// Moves up the specified number of lines and puts cursor at the beginning of the line.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/>N<see cref="MoveUpToLineStart"/> to move N lines up.
+    /// </remarks>
+    public const string MoveUpToLineStart = "F";
+
+    /// <summary>
+    /// Moves forward (to the right) the specified number of characters.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/>N<see cref="MoveForward"/> to move N characters forward.
+    /// </remarks>
+    public const string MoveForward = "C";
+
+    /// <summary>
+    /// Clears everything from cursor to end of screen.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/><see cref="EraseInDisplay"/> to clear.
+    /// </remarks>
+    public const string EraseInDisplay = "J";
+
+    /// <summary>
+    /// Clears everything from cursor to the end of the current line.
+    /// </summary>
+    /// <remarks>
+    /// Print <see cref="CSI"/><see cref="EraseInLine"/> to clear.
+    /// </remarks>
+    public const string EraseInLine = "K";
+
+    /// <summary>
+    /// Hides the cursor.
+    /// </summary>
+    public const string HideCursor = "\x1b[?25l";
+
+    /// <summary>
+    /// Shows/restores the cursor.
+    /// </summary>
+    public const string ShowCursor = "\x1b[?25h";
+
+    public static string Colorize(string? s, TerminalColor color)
+    {
+        if (string.IsNullOrWhiteSpace(s))
+        {
+            return s ?? "";
+        }
+
+        return $"{CSI}{(int)color}{SetColor}{s}{SetDefaultColor}";
+    }
+}
diff --git a/src/MSBuild/LiveLogger/BuildMessage.cs b/src/MSBuild/LiveLogger/BuildMessage.cs
new file mode 100644
index 00000000000..93a9cf26f94
--- /dev/null
+++ b/src/MSBuild/LiveLogger/BuildMessage.cs
@@ -0,0 +1,10 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// Represents a piece of diagnostic output (message/warning/error).
+/// </summary>
+internal record struct BuildMessage(MessageSeverity Severity, string Message)
+{ }
diff --git a/src/MSBuild/LiveLogger/ITerminal.cs b/src/MSBuild/LiveLogger/ITerminal.cs
new file mode 100644
index 00000000000..ace2f0656c3
--- /dev/null
+++ b/src/MSBuild/LiveLogger/ITerminal.cs
@@ -0,0 +1,66 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// An abstraction of a terminal, built specifically to fit the <see cref="LiveLogger"/> needs.
+/// </summary>
+internal interface ITerminal : IDisposable
+{
+    /// <summary>
+    /// Width of the terminal buffer.
+    /// </summary>
+    int Width { get; }
+
+    /// <summary>
+    /// Height of the terminal buffer.
+    /// </summary>
+    int Height { get; }
+
+    /// <summary>
+    /// Starts buffering the text passed via the <c>Write*</c> methods.
+    /// </summary>
+    /// <remarks>
+    /// Upon calling this method, the terminal should be buffering all output internally until <see cref="EndUpdate"/> is called.
+    /// </remarks>
+    void BeginUpdate();
+
+    /// <summary>
+    /// Flushes the text buffered between <see cref="BeginUpdate"/> was called and now into the output.
+    /// </summary>
+    void EndUpdate();
+
+    /// <summary>
+    /// Writes a string to the output. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void Write(string text);
+
+    /// <summary>
+    /// Writes a string to the output. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void Write(ReadOnlySpan<char> text);
+
+    /// <summary>
+    /// Writes a string to the output. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteLine(string text);
+
+    /// <summary>
+    /// Writes a string to the output, truncating it if it wouldn't fit on one screen line.
+    /// Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteLineFitToWidth(ReadOnlySpan<char> text);
+
+    /// <summary>
+    /// Writes a string to the output using the given color. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteColor(TerminalColor color, string text);
+
+    /// <summary>
+    /// Writes a string to the output using the given color. Or buffers it if <see cref="BeginUpdate"/> was called.
+    /// </summary>
+    void WriteColorLine(TerminalColor color, string text);
+}
diff --git a/src/MSBuild/LiveLogger/LiveLogger.cs b/src/MSBuild/LiveLogger/LiveLogger.cs
index 7068886ba69..a1ff373a6b6 100644
--- a/src/MSBuild/LiveLogger/LiveLogger.cs
+++ b/src/MSBuild/LiveLogger/LiveLogger.cs
@@ -2,36 +2,150 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Threading.Tasks;
-using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.Logging.LiveLogger
+using System.Text;
+using System.Threading;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+#if NETFRAMEWORK
+using Microsoft.IO;
+#else
+using System.IO;
+#endif
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// A logger which updates the console output "live" during the build.
+/// </summary>
+/// <remarks>
+/// Uses ANSI/VT100 control codes to erase and overwrite lines as the build is progressing.
+/// </remarks>
+internal sealed class LiveLogger : INodeLogger
 {
-    internal class LiveLogger : ILogger
+    /// <summary>
+    /// A wrapper over the project context ID passed to us in <see cref="IEventSource"/> logger events.
+    /// </summary>
+    internal record struct ProjectContext(int Id)
     {
-        private ConcurrentDictionary<int, ProjectNode> projects = new();
-
-        private bool succeeded;
-        private int startedProjects = 0;
-        private int finishedProjects = 0;
-        private ConcurrentDictionary<string, int> blockedProjects = new();
-
-        private Stopwatch? _stopwatch;
-
-        public LoggerVerbosity Verbosity { get; set; }
-        public string Parameters { get; set; }
+        public ProjectContext(BuildEventContext context)
+            : this(context.ProjectContextId)
+        { }
+    }
 
-        /// <summary>
-        /// List of events the logger needs as parameters to the <see cref="ConfigurableForwardingLogger"/>.
-        /// </summary>
-        /// <remarks>
-        /// If LiveLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main node using an instance of <see cref="ConfigurableForwardingLogger"/> with the following parameters.
-        /// </remarks>
-        public static readonly string[] ConfigurableForwardingLoggerParameters =
+    /// <summary>
+    /// Encapsulates the per-node data shown in live node output.
+    /// </summary>
+    internal record NodeStatus(string Project, string? TargetFramework, string Target, Stopwatch Stopwatch)
+    {
+        public override string ToString()
         {
+            string duration = Stopwatch.Elapsed.TotalSeconds.ToString("F1");
+
+            return string.IsNullOrEmpty(TargetFramework)
+                ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectBuilding_NoTF",
+                    Indentation,
+                    Project,
+                    Target,
+                    duration)
+                : ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectBuilding_WithTF",
+                    Indentation,
+                    Project,
+                    AnsiCodes.Colorize(TargetFramework, TargetFrameworkColor),
+                    Target,
+                    duration);
+        }
+    }
+
+    /// <summary>
+    /// The indentation to use for all build output.
+    /// </summary>
+    private const string Indentation = "  ";
+
+    private const TerminalColor TargetFrameworkColor = TerminalColor.Cyan;
+
+    /// <summary>
+    /// Protects access to state shared between the logger callbacks and the rendering thread.
+    /// </summary>
+    private readonly object _lock = new();
+
+    /// <summary>
+    /// A cancellation token to signal the rendering thread that it should exit.
+    /// </summary>
+    private readonly CancellationTokenSource _cts = new();
+
+    /// <summary>
+    /// Tracks the status of all relevant projects seen so far.
+    /// </summary>
+    /// <remarks>
+    /// Keyed by an ID that gets passed to logger callbacks, this allows us to quickly look up the corresponding project.
+    /// </remarks>
+    private readonly Dictionary<ProjectContext, Project> _projects = new();
+
+    /// <summary>
+    /// Tracks the work currently being done by build nodes. Null means the node is not doing any work worth reporting.
+    /// </summary>
+    private NodeStatus?[] _nodes = Array.Empty<NodeStatus>();
+
+    /// <summary>
+    /// The timestamp of the <see cref="IEventSource.BuildStarted"/> event.
+    /// </summary>
+    private DateTime _buildStartTime;
+
+    /// <summary>
+    /// The working directory when the build starts, to trim relative output paths.
+    /// </summary>
+    private readonly string _initialWorkingDirectory = Environment.CurrentDirectory;
+
+    /// <summary>
+    /// True if the build has encountered at least one error.
+    /// </summary>
+    private bool _buildHasErrors;
+
+    /// <summary>
+    /// True if the build has encountered at least one warning.
+    /// </summary>
+    private bool _buildHasWarnings;
+
+    /// <summary>
+    /// True if restore failed and this failure has already been reported.
+    /// </summary>
+    private bool _restoreFailed;
+
+    /// <summary>
+    /// The project build context corresponding to the <c>Restore</c> initial target, or null if the build is currently
+    /// bot restoring.
+    /// </summary>
+    private ProjectContext? _restoreContext;
+
+    /// <summary>
+    /// The thread that performs periodic refresh of the console output.
+    /// </summary>
+    private Thread? _refresher;
+
+    /// <summary>
+    /// What is currently displaying in Nodes section as strings representing per-node console output.
+    /// </summary>
+    private NodesFrame _currentFrame = new(Array.Empty<NodeStatus>(), 0, 0);
+
+    /// <summary>
+    /// The <see cref="Terminal"/> to write console output to.
+    /// </summary>
+    private ITerminal Terminal { get; }
+
+    /// <summary>
+    /// List of events the logger needs as parameters to the <see cref="ConfigurableForwardingLogger"/>.
+    /// </summary>
+    /// <remarks>
+    /// If LiveLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main
+    /// node using an instance of <see cref="ConfigurableForwardingLogger"/> with the following parameters.
+    /// Important: Note that LiveLogger is special-cased in <see cref="BackEnd.Logging.LoggingService.UpdateMinimumMessageImportance"/>
+    /// so changing this list may impact the minimum message importance logging optimization.
+    /// </remarks>
+    public static readonly string[] ConfigurableForwardingLoggerParameters =
+    {
             "BUILDSTARTEDEVENT",
             "BUILDFINISHEDEVENT",
             "PROJECTSTARTEDEVENT",
@@ -42,302 +156,652 @@ internal class LiveLogger : ILogger
             "HIGHMESSAGEEVENT",
             "WARNINGEVENT",
             "ERROREVENT"
-        };
+    };
+
+    /// <summary>
+    /// Default constructor, used by the MSBuild logger infra.
+    /// </summary>
+    public LiveLogger()
+    {
+        Terminal = new Terminal();
+    }
+
+    /// <summary>
+    /// Internal constructor accepting a custom <see cref="ITerminal"/> for testing.
+    /// </summary>
+    internal LiveLogger(ITerminal terminal)
+    {
+        Terminal = terminal;
+    }
+
+    #region INodeLogger implementation
+
+    /// <inheritdoc/>
+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Minimal; set { } }
+
+    /// <inheritdoc/>
+    public string Parameters { get => ""; set { } }
+
+    /// <inheritdoc/>
+    public void Initialize(IEventSource eventSource, int nodeCount)
+    {
+        _nodes = new NodeStatus[nodeCount];
+
+        Initialize(eventSource);
+    }
 
-        public LiveLogger()
+    /// <inheritdoc/>
+    public void Initialize(IEventSource eventSource)
+    {
+        eventSource.BuildStarted += BuildStarted;
+        eventSource.BuildFinished += BuildFinished;
+        eventSource.ProjectStarted += ProjectStarted;
+        eventSource.ProjectFinished += ProjectFinished;
+        eventSource.TargetStarted += TargetStarted;
+        eventSource.TargetFinished += TargetFinished;
+        eventSource.TaskStarted += TaskStarted;
+
+        eventSource.MessageRaised += MessageRaised;
+        eventSource.WarningRaised += WarningRaised;
+        eventSource.ErrorRaised += ErrorRaised;
+    }
+
+    /// <inheritdoc/>
+    public void Shutdown()
+    {
+        Terminal.Dispose();
+    }
+
+    #endregion
+
+    #region Logger callbacks
+
+    /// <summary>
+    /// The <see cref="IEventSource.BuildStarted"/> callback.
+    /// </summary>
+    private void BuildStarted(object sender, BuildStartedEventArgs e)
+    {
+        _refresher = new Thread(ThreadProc);
+        _refresher.Start();
+
+        _buildStartTime = e.Timestamp;
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.BuildFinished"/> callback.
+    /// </summary>
+    private void BuildFinished(object sender, BuildFinishedEventArgs e)
+    {
+        _cts.Cancel();
+        _refresher?.Join();
+
+        _projects.Clear();
+
+        Terminal.BeginUpdate();
+        try
         {
-            Parameters = "";
+            string duration = (e.Timestamp - _buildStartTime).TotalSeconds.ToString("F1");
+            string buildResult = RenderBuildResult(e.Succeeded, _buildHasErrors, _buildHasWarnings);
+
+            Terminal.WriteLine("");
+            if (_restoreFailed)
+            {
+                Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("RestoreCompleteWithMessage",
+                    buildResult,
+                    duration));
+            }
+            else
+            {
+                Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("BuildFinished",
+                    buildResult,
+                    duration));
+            }
         }
+        finally
+        {
+            Terminal.EndUpdate();
+        }
+
+        _buildHasErrors = false;
+        _buildHasWarnings = false;
+        _restoreFailed = false;
+    }
 
-        public void Initialize(IEventSource eventSource)
+    /// <summary>
+    /// The <see cref="IEventSource.ProjectStarted"/> callback.
+    /// </summary>
+    private void ProjectStarted(object sender, ProjectStartedEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is null)
         {
-            // Start the stopwatch as soon as the logger is initialized to capture
-            // any time before the BuildStarted event
-            _stopwatch = Stopwatch.StartNew();
-            // Register for different events. Make sure that ConfigurableForwardingLoggerParameters are in sync with them.
-            // Started and Finished events  
-            eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);
-            eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);
-            eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);
-            eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);
-            eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);
-            eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);
-            eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);
-
-            // Messages/Warnings/Errors
-            // BuildMessageEventHandler event handler below currently process only High importance events. 
-            eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);
-            eventSource.WarningRaised += new BuildWarningEventHandler(eventSource_WarningRaised);
-            eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);
-
-            // Cancelled
-            Console.CancelKeyPress += new ConsoleCancelEventHandler(console_CancelKeyPressed);
-
-            Task.Run(() =>
+            return;
+        }
+
+        ProjectContext c = new ProjectContext(buildEventContext);
+
+        if (_restoreContext is null)
+        {
+            if (e.GlobalProperties?.TryGetValue("TargetFramework", out string? targetFramework) != true)
             {
-                Render();
-            });
+                targetFramework = null;
+            }
+            _projects[c] = new(targetFramework);
         }
 
-        private void Render()
+        if (e.TargetNames == "Restore")
         {
-            // Initialize LiveLoggerBuffer
-            TerminalBuffer.Initialize();
-            // TODO: Fix. First line does not appear at top. Leaving empty line for now
-            TerminalBuffer.WriteNewLine(string.Empty);
+            _restoreContext = c;
+            _nodes[0] = new NodeStatus(e.ProjectFile!, null, "Restore", _projects[c].Stopwatch);
+        }
+    }
 
-            // Top line indicates the number of finished projects.
-            TerminalBuffer.FinishedProjects = this.finishedProjects;
+    /// <summary>
+    /// The <see cref="IEventSource.ProjectFinished"/> callback.
+    /// </summary>
+    private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is null)
+        {
+            return;
+        }
 
-            // First render
-            TerminalBuffer.Render();
-            int i = 0;
-            // Rerender periodically
-            while (!TerminalBuffer.IsTerminated)
+        // Mark node idle until something uses it again
+        if (_restoreContext is null)
+        {
+            lock (_lock)
             {
-                i++;
-                // Delay by 1/60 seconds
-                // Use task delay to avoid blocking the task, so that keyboard input is listened continously
-                Task.Delay((i / 60) * 1_000).ContinueWith((t) =>
+                _nodes[NodeIndexForContext(buildEventContext)] = null;
+            }
+        }
+
+        ProjectContext c = new(buildEventContext);
+
+        if (_projects.TryGetValue(c, out Project? project))
+        {
+            lock (_lock)
+            {
+                Terminal.BeginUpdate();
+                try
                 {
-                    TerminalBuffer.FinishedProjects = this.finishedProjects;
+                    EraseNodes();
+
+                    string duration = project.Stopwatch.Elapsed.TotalSeconds.ToString("F1");
+                    ReadOnlyMemory<char>? outputPath = project.OutputPath;
+
+                    string projectFile = e.ProjectFile is not null ?
+                        Path.GetFileNameWithoutExtension(e.ProjectFile) :
+                        string.Empty;
 
-                    // Rerender projects only when needed
-                    foreach (var project in projects)
+                    // Build result. One of 'failed', 'succeeded with warnings', or 'succeeded' depending on the build result and diagnostic messages
+                    // reported during build.
+                    bool haveErrors = project.BuildMessages?.Exists(m => m.Severity == MessageSeverity.Error) == true;
+                    bool haveWarnings = project.BuildMessages?.Exists(m => m.Severity == MessageSeverity.Warning) == true;
+
+                    string buildResult = RenderBuildResult(e.Succeeded, haveErrors, haveWarnings);
+
+                    // Check if we're done restoring.
+                    if (c == _restoreContext)
                     {
-                        project.Value.Log();
+                        if (e.Succeeded)
+                        {
+                            if (haveErrors || haveWarnings)
+                            {
+                                Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("RestoreCompleteWithMessage",
+                                    buildResult,
+                                    duration));
+                            }
+                            else
+                            {
+                                Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("RestoreComplete",
+                                    duration));
+                            }
+                        }
+                        else
+                        {
+                            // It will be reported after build finishes.
+                            _restoreFailed = true;
+                        }
+
+                        _restoreContext = null;
                     }
-
-                    // Rerender buffer
-                    TerminalBuffer.Render();
-                });
-                // Handle keyboard input
-                if (Console.KeyAvailable)
-                {
-                    ConsoleKey key = Console.ReadKey().Key;
-                    switch (key)
+                    // If this was a notable project build, we print it as completed only if it's produced an output or warnings/error.
+                    else if (project.OutputPath is not null || project.BuildMessages is not null)
                     {
-                        case ConsoleKey.UpArrow:
-                            if (TerminalBuffer.TopLineIndex > 0)
+                        // Show project build complete and its output
+
+                        if (string.IsNullOrEmpty(project.TargetFramework))
+                        {
+                            Terminal.Write(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectFinished_NoTF",
+                                Indentation,
+                                projectFile,
+                                buildResult,
+                                duration));
+                        }
+                        else
+                        {
+                            Terminal.Write(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectFinished_WithTF",
+                                Indentation,
+                                projectFile,
+                                AnsiCodes.Colorize(project.TargetFramework, TargetFrameworkColor),
+                                buildResult,
+                                duration));
+                        }
+
+                        // Print the output path as a link if we have it.
+                        if (outputPath is not null)
+                        {
+                            ReadOnlySpan<char> outputPathSpan = outputPath.Value.Span;
+                            ReadOnlySpan<char> url = outputPathSpan;
+                            try
+                            {
+                                // If possible, make the link point to the containing directory of the output.
+                                url = Path.GetDirectoryName(url);
+                            }
+                            catch
+                            {
+                                // Ignore any GetDirectoryName exceptions.
+                            }
+
+                            // Generates file:// schema url string which is better handled by various Terminal clients than raw folder name.
+                            string urlString = url.ToString();
+                            if (Uri.TryCreate(urlString, UriKind.Absolute, out Uri? uri))
                             {
-                                TerminalBuffer.TopLineIndex--;
+                                urlString = uri.AbsoluteUri;
                             }
-                            TerminalBuffer.ShouldRerender = true;
-                            break;
-                        case ConsoleKey.DownArrow:
-                            TerminalBuffer.TopLineIndex++;
-                            TerminalBuffer.ShouldRerender = true;
-                            break;
-                        default:
-                            break;
+
+                            // If the output path is under the initial working directory, make the console output relative to that to save space.
+                            if (outputPathSpan.StartsWith(_initialWorkingDirectory.AsSpan(), FileUtilities.PathComparison))
+                            {
+                                if (outputPathSpan.Length > _initialWorkingDirectory.Length
+                                    && (outputPathSpan[_initialWorkingDirectory.Length] == Path.DirectorySeparatorChar
+                                        || outputPathSpan[_initialWorkingDirectory.Length] == Path.AltDirectorySeparatorChar))
+                                {
+                                    outputPathSpan = outputPathSpan.Slice(_initialWorkingDirectory.Length + 1);
+                                }
+                            }
+
+                            Terminal.WriteLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectFinished_OutputPath",
+                                $"{AnsiCodes.LinkPrefix}{urlString}{AnsiCodes.LinkInfix}{outputPathSpan.ToString()}{AnsiCodes.LinkSuffix}"));
+                        }
+                        else
+                        {
+                            Terminal.WriteLine(string.Empty);
+                        }
                     }
+
+                    // Print diagnostic output under the Project -> Output line.
+                    if (project.BuildMessages is not null)
+                    {
+                        foreach (BuildMessage buildMessage in project.BuildMessages)
+                        {
+                            TerminalColor color = buildMessage.Severity switch
+                            {
+                                MessageSeverity.Warning => TerminalColor.Yellow,
+                                MessageSeverity.Error => TerminalColor.Red,
+                                _ => TerminalColor.Default,
+                            };
+                            Terminal.WriteColorLine(color, $"{Indentation}{Indentation}{buildMessage.Message}");
+                        }
+                    }
+
+                    _buildHasErrors |= haveErrors;
+                    _buildHasWarnings |= haveWarnings;
+
+                    DisplayNodes();
+                }
+                finally
+                {
+                    Terminal.EndUpdate();
                 }
             }
         }
+    }
 
-        private void UpdateFooter()
+    /// <summary>
+    /// The <see cref="IEventSource.TargetStarted"/> callback.
+    /// </summary>
+    private void TargetStarted(object sender, TargetStartedEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (_restoreContext is null && buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
-            float percentage = startedProjects == 0 ? 0.0f : (float)finishedProjects / startedProjects;
-            TerminalBuffer.FooterText = ANSIBuilder.Alignment.SpaceBetween(
-                $"Build progress (approx.) [{ANSIBuilder.Graphics.ProgressBar(percentage)}]",
-                ANSIBuilder.Formatting.Italic(ANSIBuilder.Formatting.Dim("[Up][Down] Scroll")),
-                Console.BufferWidth);
+            project.Stopwatch.Start();
+
+            string projectFile = Path.GetFileNameWithoutExtension(e.ProjectFile);
+            NodeStatus nodeStatus = new(projectFile, project.TargetFramework, e.TargetName, project.Stopwatch);
+            lock (_lock)
+            {
+                _nodes[NodeIndexForContext(buildEventContext)] = nodeStatus;
+            }
         }
+    }
 
-        // Build
-        private void eventSource_BuildStarted(object sender, BuildStartedEventArgs e)
+    /// <summary>
+    /// The <see cref="IEventSource.TargetFinished"/> callback. Unused.
+    /// </summary>
+    private void TargetFinished(object sender, TargetFinishedEventArgs e)
+    {
+    }
+
+    /// <summary>
+    /// The <see cref="IEventSource.TaskStarted"/> callback.
+    /// </summary>
+    private void TaskStarted(object sender, TaskStartedEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (_restoreContext is null && buildEventContext is not null && e.TaskName == "MSBuild")
         {
+            // This will yield the node, so preemptively mark it idle
+            lock (_lock)
+            {
+                _nodes[NodeIndexForContext(buildEventContext)] = null;
+            }
+
+            if (_projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+            {
+                project.Stopwatch.Stop();
+            }
         }
+    }
 
-        private void eventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
+    /// <summary>
+    /// The <see cref="IEventSource.MessageRaised"/> callback.
+    /// </summary>
+    private void MessageRaised(object sender, BuildMessageEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is null)
         {
-            succeeded = e.Succeeded;
+            return;
         }
 
-        // Project
-        private void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
+        string? message = e.Message;
+        if (message is not null && e.Importance == MessageImportance.High)
         {
-            startedProjects++;
-
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-
-            // If id does not exist...
-            projects.GetOrAdd(id, (_) =>
+            // Detect project output path by matching high-importance messages against the "$(MSBuildProjectName) -> ..."
+            // pattern used by the CopyFilesToOutputDirectory target.
+            int index = message.IndexOf(" -> ", StringComparison.Ordinal);
+            if (index > 0)
             {
-                // Add project
-                ProjectNode node = new(e)
+                var projectFileName = Path.GetFileName(e.ProjectFile.AsSpan());
+                if (!projectFileName.IsEmpty &&
+                    message.AsSpan().StartsWith(Path.GetFileNameWithoutExtension(projectFileName)) &&
+                    _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
                 {
-                    ShouldRerender = true,
-                };
-                UpdateFooter();
-
-                return node;
-            });
+                    ReadOnlyMemory<char> outputPath = e.Message.AsMemory().Slice(index + 4);
+                    project.OutputPath = outputPath;
+                }
+            }
         }
+    }
 
-        private void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
+    /// <summary>
+    /// The <see cref="IEventSource.WarningRaised"/> callback.
+    /// </summary>
+    private void WarningRaised(object sender, BuildWarningEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
+            string message = EventArgsFormatting.FormatEventMessage(e, false);
+            project.AddBuildMessage(MessageSeverity.Warning, $"⚠\uFE0E {message}");
+        }
+    }
 
-            // Update line
-            node.Finished = true;
-            node.ShouldRerender = true;
-            finishedProjects++;
-            UpdateFooter();
+    /// <summary>
+    /// The <see cref="IEventSource.ErrorRaised"/> callback.
+    /// </summary>
+    private void ErrorRaised(object sender, BuildErrorEventArgs e)
+    {
+        var buildEventContext = e.BuildEventContext;
+        if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+        {
+            string message = EventArgsFormatting.FormatEventMessage(e, false);
+            project.AddBuildMessage(MessageSeverity.Error, $"❌\uFE0E {message}");
         }
+    }
+
+    #endregion
 
-        // Target
-        private void eventSource_TargetStarted(object sender, TargetStartedEventArgs e)
+    #region Refresher thread implementation
+
+    /// <summary>
+    /// The <see cref="_refresher"/> thread proc.
+    /// </summary>
+    private void ThreadProc()
+    {
+        while (!_cts.IsCancellationRequested)
         {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
+            Thread.Sleep(1_000 / 30); // poor approx of 30Hz
+
+            lock (_lock)
             {
-                return;
+                DisplayNodes();
             }
-            // Update
-            node.AddTarget(e);
-            // Log
-            node.ShouldRerender = true;
         }
 
-        private void eventSource_TargetFinished(object sender, TargetFinishedEventArgs e)
+        EraseNodes();
+    }
+
+    /// <summary>
+    /// Render Nodes section.
+    /// It shows what all build nodes do.
+    /// </summary>
+    private void DisplayNodes()
+    {
+        NodesFrame newFrame = new NodesFrame(_nodes, width: Terminal.Width, height: Terminal.Height);
+
+        // Do not render delta but clear everything if Terminal width or height have changed.
+        if (newFrame.Width != _currentFrame.Width || newFrame.Height != _currentFrame.Height)
         {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-            // Update
-            node.FinishedTargets++;
-            // Log
-            node.ShouldRerender = true;
+            EraseNodes();
         }
 
-        // Task
-        private void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
+        string rendered = newFrame.Render(_currentFrame);
+
+        // Hide the cursor to prevent it from jumping around as we overwrite the live lines.
+        Terminal.Write(AnsiCodes.HideCursor);
+        try
         {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-            // Update
-            node.AddTask(e);
-            // Log
-            node.ShouldRerender = true;
+            // Move cursor back to 1st line of nodes.
+            Terminal.WriteLine($"{AnsiCodes.CSI}{_currentFrame.NodesCount + 1}{AnsiCodes.MoveUpToLineStart}");
+            Terminal.Write(rendered);
+        }
+        finally
+        {
+            Terminal.Write(AnsiCodes.ShowCursor);
+        }
 
-            if (e.TaskName.Equals("MSBuild"))
-            {
-                TerminalBufferLine? line = null; // TerminalBuffer.WriteNewLineAfterMidpoint($"{e.ProjectFile} is blocked by the MSBuild task.");
-                if (line is not null)
-                {
-                    blockedProjects[e.ProjectFile] = line.Id;
-                }
-            }
+        _currentFrame = newFrame;
+    }
+
+    /// <summary>
+    /// Erases the previously printed live node output.
+    /// </summary>
+    private void EraseNodes()
+    {
+        if (_currentFrame.NodesCount == 0)
+        {
+            return;
         }
+        Terminal.WriteLine($"{AnsiCodes.CSI}{_currentFrame.NodesCount + 1}{AnsiCodes.MoveUpToLineStart}");
+        Terminal.Write($"{AnsiCodes.CSI}{AnsiCodes.EraseInDisplay}");
+        _currentFrame.Clear();
+    }
+
+    /// <summary>
+    /// Capture states on nodes to be rendered on display.
+    /// </summary>
+    private sealed class NodesFrame
+    {
+        private readonly List<string> _nodeStrings = new();
+        private readonly StringBuilder _renderBuilder = new();
 
-        // Raised messages, warnings and errors
-        private void eventSource_MessageRaised(object sender, BuildMessageEventArgs e)
+        public int Width { get; }
+        public int Height { get; }
+        public int NodesCount { get; private set; }
+
+        public NodesFrame(NodeStatus?[] nodes, int width, int height)
         {
-            if (e is TaskCommandLineEventArgs)
-            {
-                return;
-            }
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
-            {
-                return;
-            }
-            // Update
-            node.AddMessage(e);
-            // Log
-            node.ShouldRerender = true;
+            Width = width;
+            Height = height;
+            Init(nodes);
         }
 
-        private void eventSource_WarningRaised(object sender, BuildWarningEventArgs e)
+        public string NodeString(int index)
         {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
+            if (index >= NodesCount)
             {
-                return;
+                throw new ArgumentOutOfRangeException(nameof(index));
             }
-            // Update
-            node.AddWarning(e);
-            // Log
-            node.ShouldRerender = true;
+
+            return _nodeStrings[index];
         }
 
-        private void eventSource_ErrorRaised(object sender, BuildErrorEventArgs e)
+        private void Init(NodeStatus?[] nodes)
         {
-            // Get project id
-            int id = e.BuildEventContext!.ProjectInstanceId;
-            if (!projects.TryGetValue(id, out ProjectNode? node))
+            int i = 0;
+            foreach (NodeStatus? n in nodes)
             {
-                return;
+                if (n is null)
+                {
+                    continue;
+                }
+                string str = n.ToString();
+
+                if (i < _nodeStrings.Count)
+                {
+                    _nodeStrings[i] = str;
+                }
+                else
+                {
+                    _nodeStrings.Add(str);
+                }
+                i++;
+
+                // We cant output more than what fits on screen
+                // -2 because cursor command F cant reach, in Windows Terminal, very 1st line, and last line is empty caused by very last WriteLine
+                if (i >= Height - 2)
+                {
+                    break;
+                }
             }
-            // Update
-            node.AddError(e);
-            // Log
-            node.ShouldRerender = true;
+
+            NodesCount = i;
         }
 
-        private void console_CancelKeyPressed(object? sender, ConsoleCancelEventArgs eventArgs)
+        private ReadOnlySpan<char> FitToWidth(ReadOnlySpan<char> input)
         {
-            // Shutdown logger
-            Shutdown();
+            return input.Slice(0, Math.Min(input.Length, Width - 1));
         }
 
-        public void Shutdown()
+        /// <summary>
+        /// Render VT100 string to update from current to next frame.
+        /// </summary>
+        public string Render(NodesFrame previousFrame)
         {
-            TerminalBuffer.Terminate();
-            int errorCount = 0;
-            int warningCount = 0;
-            foreach (var project in projects)
+            StringBuilder sb = _renderBuilder;
+            sb.Clear();
+
+            int i = 0;
+            for (; i < NodesCount; i++)
             {
-                if (project.Value.AdditionalDetails.Count == 0)
+                var needed = FitToWidth(NodeString(i).AsSpan());
+
+                // Do we have previous node string to compare with?
+                if (previousFrame.NodesCount > i)
                 {
-                    continue;
-                }
+                    var previous = FitToWidth(previousFrame.NodeString(i).AsSpan());
 
-                Console.WriteLine(project.Value.ToANSIString());
-                errorCount += project.Value.ErrorCount;
-                warningCount += project.Value.WarningCount;
-                foreach (var message in project.Value.AdditionalDetails)
+                    if (!previous.SequenceEqual(needed))
+                    {
+                        int commonPrefixLen = previous.CommonPrefixLength(needed);
+                        if (commonPrefixLen == 0)
+                        {
+                            // whole string
+                            sb.Append(needed);
+                        }
+                        else
+                        {
+                            // set cursor to different char
+                            sb.Append($"{AnsiCodes.CSI}{commonPrefixLen}{AnsiCodes.MoveForward}");
+                            sb.Append(needed.Slice(commonPrefixLen));
+                            // Shall we clear rest of line
+                            if (needed.Length < previous.Length)
+                            {
+                                sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInLine}");
+                            }
+                        }
+                    }
+                }
+                else
                 {
-                    Console.WriteLine($"    └── {message.ToANSIString()}");
+                    // From now on we have to simply WriteLine
+                    sb.Append(needed);
                 }
-                Console.WriteLine();
+
+                // Next line
+                sb.AppendLine();
             }
 
-            // Empty line
-            Console.WriteLine();
+            // clear no longer used lines
+            if (i < previousFrame.NodesCount)
+            {
+                sb.Append($"{AnsiCodes.CSI}{AnsiCodes.EraseInDisplay}");
+            }
 
-            Debug.Assert(_stopwatch is not null, $"Expected {nameof(_stopwatch)} to be initialized long before Shutdown()");
-            TimeSpan buildDuration = _stopwatch!.Elapsed;
+            return sb.ToString();
+        }
 
-            string prettyDuration = buildDuration.TotalHours > 1.0 ?
-                buildDuration.ToString(@"h\:mm\:ss") :
-                buildDuration.ToString(@"m\:ss");
+        public void Clear()
+        {
+            NodesCount = 0;
+        }
+    }
 
-            string status = succeeded ?
-                ANSIBuilder.Formatting.Color("succeeded", ANSIBuilder.Formatting.ForegroundColor.Green) :
-                ANSIBuilder.Formatting.Color("failed", ANSIBuilder.Formatting.ForegroundColor.Red);
+    #endregion
 
-            Console.WriteLine($"Build {status} in {prettyDuration}");
-            Console.WriteLine($"\t{warningCount} Warnings(s)");
-            Console.WriteLine($"\t{errorCount} Errors(s)");
-            Console.WriteLine();
+    #region Helpers
+
+    /// <summary>
+    /// Print a build result summary to the output.
+    /// </summary>
+    /// <param name="succeeded">True if the build completed with success.</param>
+    /// <param name="hasError">True if the build has logged at least one error.</param>
+    /// <param name="hasWarning">True if the build has logged at least one warning.</param>
+    private string RenderBuildResult(bool succeeded, bool hasError, bool hasWarning)
+    {
+        if (!succeeded)
+        {
+            // If the build failed, we print one of three red strings.
+            string text = (hasError, hasWarning) switch
+            {
+                (true, _) => ResourceUtilities.GetResourceString("BuildResult_FailedWithErrors"),
+                (false, true) => ResourceUtilities.GetResourceString("BuildResult_FailedWithWarnings"),
+                _ => ResourceUtilities.GetResourceString("BuildResult_Failed"),
+            };
+            return AnsiCodes.Colorize(text, TerminalColor.Red);
+        }
+        else if (hasWarning)
+        {
+            return AnsiCodes.Colorize(ResourceUtilities.GetResourceString("BuildResult_SucceededWithWarnings"), TerminalColor.Yellow);
         }
+        else
+        {
+            return AnsiCodes.Colorize(ResourceUtilities.GetResourceString("BuildResult_Succeeded"), TerminalColor.Green);
+        }
+    }
+
+    /// <summary>
+    /// Returns the <see cref="_nodes"/> index corresponding to the given <see cref="BuildEventContext"/>.
+    /// </summary>
+    private int NodeIndexForContext(BuildEventContext context)
+    {
+        // Node IDs reported by the build are 1-based.
+        return context.NodeId - 1;
     }
+
+    #endregion
 }
diff --git a/src/MSBuild/LiveLogger/MessageNode.cs b/src/MSBuild/LiveLogger/MessageNode.cs
deleted file mode 100644
index 7d6029e041d..00000000000
--- a/src/MSBuild/LiveLogger/MessageNode.cs
+++ /dev/null
@@ -1,103 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.IO;
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-
-    internal class MessageNode
-    {
-        // Use this to change the max lenngth (relative to screen size) of messages
-        private static int MAX_LENGTH = 3 * Console.BufferWidth;
-        public enum MessageType
-        {
-            HighPriorityMessage,
-            Warning,
-            Error,
-            ProjectOutputMessage
-        }
-        public string Message;
-        public TerminalBufferLine? Line;
-        public MessageType Type;
-        public string? Code;
-        public string? FilePath;
-        public int? LineNumber;
-        public int? ColumnNumber;
-        public string? ProjectOutputExecutablePath;
-        public MessageNode(LazyFormattedBuildEventArgs args)
-        {
-            Message = args.Message ?? string.Empty;
-            if (Message.Length > MAX_LENGTH)
-            {
-                Message = Message.Substring(0, MAX_LENGTH - 1) + "…";
-            }
-            // Get type
-            switch (args)
-            {
-                case BuildMessageEventArgs message:
-                    // Detect output messages
-                    var finalOutputMarker = " -> ";
-                    int i = message.Message!.IndexOf(finalOutputMarker, StringComparison.Ordinal);
-                    if (i > 0)
-                    {
-                        Type = MessageType.ProjectOutputMessage;
-                        ProjectOutputExecutablePath = message.Message!.Substring(i + finalOutputMarker.Length);
-                    }
-                    else
-                    {
-                        Type = MessageType.HighPriorityMessage;
-                        Code = message.Subcategory;
-                    }
-                    break;
-                case BuildWarningEventArgs warning:
-                    Type = MessageType.Warning;
-                    Code = warning.Code;
-                    FilePath = warning.File;
-                    LineNumber = warning.LineNumber;
-                    ColumnNumber = warning.ColumnNumber;
-                    break;
-                case BuildErrorEventArgs error:
-                    Type = MessageType.Error;
-                    Code = error.Code;
-                    FilePath = error.File;
-                    LineNumber = error.LineNumber;
-                    ColumnNumber = error.ColumnNumber;
-                    break;
-            }
-        }
-
-        public string ToANSIString()
-        {
-            switch (Type)
-            {
-                case MessageType.Warning:
-                    return $"⚠️ {ANSIBuilder.Formatting.Color(
-                        $"Warning {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
-                        ANSIBuilder.Formatting.ForegroundColor.Yellow)}";
-                case MessageType.Error:
-                    return $"❌ {ANSIBuilder.Formatting.Color(
-                        $"Error {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
-                        ANSIBuilder.Formatting.ForegroundColor.Red)}";
-                case MessageType.ProjectOutputMessage:
-                    return $"⚙️ {ANSIBuilder.Formatting.Hyperlink(ProjectOutputExecutablePath!, Path.GetDirectoryName(ProjectOutputExecutablePath)!)}";
-                case MessageType.HighPriorityMessage:
-                default:
-                    return $"ℹ️ {Code}{(Code is not null ? ": " : string.Empty)} {ANSIBuilder.Formatting.Italic(Message)}";
-            }
-        }
-
-        // TODO: Rename to Log after LiveLogger's API becomes internal
-        public void Log()
-        {
-            if (Line == null)
-            {
-                return;
-            }
-
-            Line.Text = $"    └── {ToANSIString()}";
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/MessageSeverity.cs b/src/MSBuild/LiveLogger/MessageSeverity.cs
new file mode 100644
index 00000000000..4b63a7317b2
--- /dev/null
+++ b/src/MSBuild/LiveLogger/MessageSeverity.cs
@@ -0,0 +1,9 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// Enumerates the supported message severities.
+/// </summary>
+internal enum MessageSeverity { Warning, Error }
diff --git a/src/MSBuild/LiveLogger/Project.cs b/src/MSBuild/LiveLogger/Project.cs
new file mode 100644
index 00000000000..d5c414907b4
--- /dev/null
+++ b/src/MSBuild/LiveLogger/Project.cs
@@ -0,0 +1,52 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// Represents a project being built.
+/// </summary>
+internal sealed class Project
+{
+    /// <summary>
+    /// Initialized a new <see cref="Project"/> with the given <paramref name="targetFramework"/>.
+    /// </summary>
+    /// <param name="targetFramework">The target framework of the project or null if not multi-targeting.</param>
+    public Project(string? targetFramework)
+    {
+        TargetFramework = targetFramework;
+    }
+
+    /// <summary>
+    /// A stopwatch to time the build of the project.
+    /// </summary>
+    public Stopwatch Stopwatch { get; } = Stopwatch.StartNew();
+
+    /// <summary>
+    /// Full path to the primary output of the project, if known.
+    /// </summary>
+    public ReadOnlyMemory<char>? OutputPath { get; set; }
+
+    /// <summary>
+    /// The target framework of the project or null if not multi-targeting.
+    /// </summary>
+    public string? TargetFramework { get; }
+
+    /// <summary>
+    /// A lazily initialized list of build messages/warnings/errors raised during the build.
+    /// </summary>
+    public List<BuildMessage>? BuildMessages { get; private set; }
+
+    /// <summary>
+    /// Adds a build message of the given severity to <see cref="BuildMessages"/>.
+    /// </summary>
+    public void AddBuildMessage(MessageSeverity severity, string message)
+    {
+        BuildMessages ??= new List<BuildMessage>();
+        BuildMessages.Add(new BuildMessage(severity, message));
+    }
+}
diff --git a/src/MSBuild/LiveLogger/ProjectNode.cs b/src/MSBuild/LiveLogger/ProjectNode.cs
deleted file mode 100644
index 9561ead1647..00000000000
--- a/src/MSBuild/LiveLogger/ProjectNode.cs
+++ /dev/null
@@ -1,233 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-    internal class ProjectNode
-    {
-        /// <summary>
-        /// Given a list of paths, this method will get the shortest not ambiguous path for a project.
-        /// Example: for `/users/documents/foo/project.csproj` and `/users/documents/bar/project.csproj`, the respective non ambiguous paths would be `foo/project.csproj` and `bar/project.csproj`
-        /// Still work in progress...
-        /// </summary>
-        private static string GetUnambiguousPath(string path)
-        {
-            return Path.GetFileName(path);
-        }
-
-        public int Id;
-        public string ProjectPath;
-        public string TargetFramework;
-        public bool Finished;
-        public string? ProjectOutputExecutable;
-        // Line to display project info
-        public TerminalBufferLine? Line;
-        // Targets
-        public int FinishedTargets;
-        public TerminalBufferLine? CurrentTargetLine;
-        public TargetNode? CurrentTargetNode;
-        // Messages, errors and warnings
-        public List<MessageNode> AdditionalDetails = new();
-        // Count messages, warnings and errors
-        public int MessageCount = 0;
-        public int WarningCount = 0;
-        public int ErrorCount = 0;
-        // Bool if node should rerender
-        internal bool ShouldRerender = true;
-        public ProjectNode(ProjectStartedEventArgs args)
-        {
-            Id = args.ProjectId;
-            ProjectPath = args.ProjectFile!;
-            Finished = false;
-            FinishedTargets = 0;
-            if (args.GlobalProperties != null && args.GlobalProperties.ContainsKey("TargetFramework"))
-            {
-                TargetFramework = args.GlobalProperties["TargetFramework"];
-            }
-            else
-            {
-                TargetFramework = "";
-            }
-        }
-
-        public string ToANSIString()
-        {
-            ANSIBuilder.Formatting.ForegroundColor color = ANSIBuilder.Formatting.ForegroundColor.Default;
-            string icon = ANSIBuilder.Graphics.Spinner() + " ";
-
-            if (Finished && WarningCount + ErrorCount == 0)
-            {
-                color = ANSIBuilder.Formatting.ForegroundColor.Green;
-                icon = "✓";
-            }
-            else if (ErrorCount > 0)
-            {
-                color = ANSIBuilder.Formatting.ForegroundColor.Red;
-                icon = "X";
-            }
-            else if (WarningCount > 0)
-            {
-                color = ANSIBuilder.Formatting.ForegroundColor.Yellow;
-                icon = "✓";
-            }
-            return icon + " " + ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), color) + " " + ANSIBuilder.Formatting.Inverse(TargetFramework);
-        }
-
-        // TODO: Rename to Render() after LiveLogger's API becomes internal
-        public void Log()
-        {
-            if (!ShouldRerender)
-            {
-                return;
-            }
-
-            ShouldRerender = false;
-            // Project details
-            string lineContents = ANSIBuilder.Alignment.SpaceBetween(ToANSIString(), $"({MessageCount} ℹ️, {WarningCount} ⚠️, {ErrorCount} ❌)", Console.BufferWidth - 1);
-            // Create or update line
-            if (Line is null)
-            {
-                Line = TerminalBuffer.WriteNewLineBeforeMidpoint(lineContents, false);
-            }
-            else
-            {
-                Line.Text = lineContents;
-            }
-
-            // For finished projects
-            if (Finished)
-            {
-                if (CurrentTargetLine is not null)
-                {
-                    TerminalBuffer.DeleteLine(CurrentTargetLine.Id);
-                }
-
-                bool foundErrorOrWarning = false;
-
-                foreach (MessageNode node in AdditionalDetails)
-                {
-                    if (node.Type != MessageNode.MessageType.HighPriorityMessage)
-                    {
-                        foundErrorOrWarning = true;
-                    }
-
-                    // Only delete high priority messages
-                    if (node.Type != MessageNode.MessageType.HighPriorityMessage)
-                    {
-                        continue;
-                    }
-
-                    if (node.Line is not null)
-                    {
-                        TerminalBuffer.DeleteLine(node.Line.Id);
-                    }
-                }
-
-                if (!foundErrorOrWarning && this.Line is not null)
-                {
-                    foreach (MessageNode node in AdditionalDetails)
-                    {
-                        int? id = node.Line?.Id;
-                        if (id is not null)
-                        {
-                            TerminalBuffer.DeleteLine(id.Value);
-                        }
-                    }
-
-                    TerminalBuffer.DeleteLine(this.Line.Id);
-                }
-            }
-
-            // Current target details
-            if (CurrentTargetNode is null)
-            {
-                return;
-            }
-
-            string currentTargetLineContents = $"    └── {CurrentTargetNode.TargetName} : {CurrentTargetNode.CurrentTaskNode?.TaskName ?? String.Empty}";
-            if (CurrentTargetLine is null)
-            {
-                CurrentTargetLine = TerminalBuffer.WriteNewLineAfter(Line!.Id, currentTargetLineContents);
-            }
-            else
-            {
-                CurrentTargetLine.Text = currentTargetLineContents;
-            }
-
-            // Messages, warnings and errors
-            foreach (MessageNode node in AdditionalDetails)
-            {
-                if (Finished && node.Type == MessageNode.MessageType.HighPriorityMessage)
-                {
-                    continue;
-                }
-
-                if (node.Line is null)
-                {
-                    node.Line = TerminalBuffer.WriteNewLineAfter(Line!.Id, "Message");
-                }
-
-                node.Log();
-            }
-        }
-
-        public TargetNode AddTarget(TargetStartedEventArgs args)
-        {
-            CurrentTargetNode = new TargetNode(args);
-            return CurrentTargetNode;
-        }
-        public TaskNode? AddTask(TaskStartedEventArgs args)
-        {
-            // Get target id
-            int targetId = args.BuildEventContext!.TargetId;
-            if (CurrentTargetNode?.Id == targetId)
-            {
-                return CurrentTargetNode.AddTask(args);
-            }
-            else
-            {
-                return null;
-            }
-        }
-        public MessageNode? AddMessage(BuildMessageEventArgs args)
-        {
-            if (args.Importance != MessageImportance.High)
-            {
-                return null;
-            }
-
-            MessageCount++;
-            MessageNode node = new MessageNode(args);
-            // Add output executable path
-            if (node.ProjectOutputExecutablePath is not null)
-            {
-                ProjectOutputExecutable = node.ProjectOutputExecutablePath;
-            }
-
-            AdditionalDetails.Add(node);
-            return node;
-        }
-        public MessageNode? AddWarning(BuildWarningEventArgs args)
-        {
-            WarningCount++;
-            MessageNode node = new MessageNode(args);
-            AdditionalDetails.Add(node);
-            TerminalBuffer.overallBuildState = TerminalBuffer.overallBuildState == OverallBuildState.Error ? OverallBuildState.Error : OverallBuildState.Warning;
-            return node;
-        }
-        public MessageNode? AddError(BuildErrorEventArgs args)
-        {
-            ErrorCount++;
-            MessageNode node = new MessageNode(args);
-            AdditionalDetails.Add(node);
-            TerminalBuffer.overallBuildState = OverallBuildState.Error;
-            return node;
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/TargetNode.cs b/src/MSBuild/LiveLogger/TargetNode.cs
deleted file mode 100644
index 06d61dd431a..00000000000
--- a/src/MSBuild/LiveLogger/TargetNode.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-
-    internal class TargetNode
-    {
-        public int Id;
-        public string TargetName;
-        public TaskNode? CurrentTaskNode;
-        public TargetNode(TargetStartedEventArgs args)
-        {
-            Id = args.BuildEventContext!.TargetId;
-            TargetName = args.TargetName;
-        }
-        public TaskNode AddTask(TaskStartedEventArgs args)
-        {
-            CurrentTaskNode = new TaskNode(args);
-            return CurrentTaskNode;
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/TaskNode.cs b/src/MSBuild/LiveLogger/TaskNode.cs
deleted file mode 100644
index 4e8d8118675..00000000000
--- a/src/MSBuild/LiveLogger/TaskNode.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-
-    internal class TaskNode
-    {
-        public int Id;
-        public string TaskName;
-        public TaskNode(TaskStartedEventArgs args)
-        {
-            Id = args.BuildEventContext!.TaskId;
-            TaskName = args.TaskName;
-        }
-    }
-}
diff --git a/src/MSBuild/LiveLogger/Terminal.cs b/src/MSBuild/LiveLogger/Terminal.cs
new file mode 100644
index 00000000000..7155d387779
--- /dev/null
+++ b/src/MSBuild/LiveLogger/Terminal.cs
@@ -0,0 +1,158 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Text;
+#if NETFRAMEWORK
+using Microsoft.Build.Shared;
+#endif
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// An <see cref="ITerminal"/> implementation for ANSI/VT100 terminals.
+/// </summary>
+internal sealed class Terminal : ITerminal
+{
+    /// <summary>
+    /// The encoding read from <see cref="Console.OutputEncoding"/> when the terminal is instantiated.
+    /// </summary>
+    private readonly Encoding _originalOutputEncoding;
+
+    /// <summary>
+    /// A string buffer used with <see cref="BeginUpdate"/>/<see cref="EndUpdate"/>.
+    /// </summary>
+    private readonly StringBuilder _outputBuilder = new();
+
+    /// <summary>
+    /// True if <see cref="BeginUpdate"/> was called and <c>Write*</c> methods are buffering instead of directly printing.
+    /// </summary>
+    private bool _isBuffering = false;
+
+    /// <inheritdoc/>
+    public int Height => Console.BufferHeight;
+
+    /// <inheritdoc/>
+    public int Width => Console.BufferWidth;
+
+    public Terminal()
+    {
+        _originalOutputEncoding = Console.OutputEncoding;
+        Console.OutputEncoding = Encoding.UTF8;
+    }
+
+    /// <inheritdoc/>
+    public void BeginUpdate()
+    {
+        if (_isBuffering)
+        {
+            throw new InvalidOperationException();
+        }
+        _isBuffering = true;
+    }
+
+    /// <inheritdoc/>
+    public void EndUpdate()
+    {
+        if (!_isBuffering)
+        {
+            throw new InvalidOperationException();
+        }
+        _isBuffering = false;
+
+        Console.Write(_outputBuilder.ToString());
+        _outputBuilder.Clear();
+    }
+
+    /// <inheritdoc/>
+    public void Write(string text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder.Append(text);
+        }
+        else
+        {
+            Console.Write(text);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void Write(ReadOnlySpan<char> text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder.Append(text);
+        }
+        else
+        {
+            Console.Out.Write(text);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteLine(string text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder.AppendLine(text);
+        }
+        else
+        {
+            Console.WriteLine(text);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteLineFitToWidth(ReadOnlySpan<char> text)
+    {
+        ReadOnlySpan<char> truncatedText = text.Slice(0, Math.Min(text.Length, Width - 1));
+        if (_isBuffering)
+        {
+            _outputBuilder.Append(truncatedText);
+            _outputBuilder.AppendLine();
+        }
+        else
+        {
+            Console.Out.WriteLine(truncatedText);
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteColor(TerminalColor color, string text)
+    {
+        if (_isBuffering)
+        {
+            _outputBuilder
+                .Append(AnsiCodes.CSI)
+                .Append((int)color)
+                .Append(AnsiCodes.SetColor)
+                .Append(text)
+                .Append(AnsiCodes.SetDefaultColor);
+        }
+        else
+        {
+            Write(AnsiCodes.Colorize(text, color));
+        }
+    }
+
+    /// <inheritdoc/>
+    public void WriteColorLine(TerminalColor color, string text)
+    {
+        if (_isBuffering)
+        {
+            WriteColor(color, text);
+            _outputBuilder.AppendLine();
+        }
+        else
+        {
+            WriteLine($"{AnsiCodes.CSI}{(int)color}{AnsiCodes.SetColor}{text}{AnsiCodes.SetDefaultColor}");
+        }
+    }
+
+    /// <inheritdoc/>
+    public void Dispose()
+    {
+        Console.OutputEncoding = _originalOutputEncoding;
+    }
+}
diff --git a/src/MSBuild/LiveLogger/TerminalBuffer.cs b/src/MSBuild/LiveLogger/TerminalBuffer.cs
deleted file mode 100644
index d58b42c7689..00000000000
--- a/src/MSBuild/LiveLogger/TerminalBuffer.cs
+++ /dev/null
@@ -1,295 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Runtime.CompilerServices;
-using System.Text;
-using static System.Net.Mime.MediaTypeNames;
-
-namespace Microsoft.Build.Logging.LiveLogger
-{
-    internal class TerminalBufferLine
-    {
-        private static int Counter = 0;
-        private string _text = string.Empty;
-        public List<string> WrappedText { get; private set; } = new();
-        public int Id;
-        public bool ShouldWrapLines;
-        public string Text
-        {
-            get => _text;
-            set
-            {
-                // Set text value and get wrapped lines
-                _text = value;
-                if (ShouldWrapLines)
-                {
-                    WrappedText = ANSIBuilder.ANSIWrap(value, Console.BufferWidth);
-                }
-                else
-                {
-                    WrappedText = new List<string> { value };
-                }
-                // Buffer should rerender
-                TerminalBuffer.ShouldRerender = true;
-            }
-        }
-
-        public TerminalBufferLine()
-        {
-            Id = Counter++;
-            Text = string.Empty;
-            ShouldWrapLines = false;
-        }
-        public TerminalBufferLine(string text)
-            : this()
-        {
-            Text = text;
-        }
-        public TerminalBufferLine(string text, bool shouldWrapLines)
-            : this()
-        {
-            ShouldWrapLines = shouldWrapLines;
-            Text = text;
-        }
-    }
-
-    internal class TerminalBuffer
-    {
-        private const char errorSymbol = '❌';
-        private const char warningSymbol = '⚠';
-        private static List<TerminalBufferLine> Lines = new();
-        public static string FooterText = string.Empty;
-        public static int TopLineIndex = 0;
-        public static string Footer = string.Empty;
-        internal static bool IsTerminated = false;
-        internal static bool ShouldRerender = true;
-        internal static OverallBuildState overallBuildState = OverallBuildState.None;
-        internal static int FinishedProjects = 0;
-        private static int midLineId;
-        internal static int ScrollableAreaHeight
-        {
-            get
-            {
-                // Height of the buffer -3 (titlebar, footer, and footer line)
-                return Console.BufferHeight - 3;
-            }
-        }
-        public static void Initialize()
-        {
-            // Configure buffer, encoding and cursor
-            Console.OutputEncoding = Encoding.UTF8;
-            Console.Write(ANSIBuilder.Buffer.UseAlternateBuffer());
-            Console.Write(ANSIBuilder.Cursor.Invisible());
-            // TerminalBufferLine midLine = new(new string('-', Console.BufferWidth), true);
-            // WriteNewLine(midLine);
-            // midLineId = midLine.Id;
-            midLineId = -1;
-        }
-
-        public static void Terminate()
-        {
-            IsTerminated = true;
-            // Delete contents from alternate buffer before switching back to main buffer
-            Console.Write(
-                ANSIBuilder.Cursor.Home() +
-                ANSIBuilder.Eraser.DisplayCursorToEnd());
-            // Reset configuration for buffer and cursor, and clear screen
-            Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
-            Console.Write(ANSIBuilder.Cursor.Visible());
-            Lines = new();
-        }
-
-        #region Rendering
-        public static void Render()
-        {
-            if (IsTerminated || !ShouldRerender)
-            {
-                return;
-            }
-
-            ShouldRerender = false;
-            ANSIBuilder.Formatting.ForegroundColor desiredColor =
-                overallBuildState == OverallBuildState.Error ? ANSIBuilder.Formatting.ForegroundColor.Red :
-                overallBuildState == OverallBuildState.Warning ? ANSIBuilder.Formatting.ForegroundColor.Yellow :
-                ANSIBuilder.Formatting.ForegroundColor.White;
-
-            string text = $"MSBuild - Build in progress - {FinishedProjects} finished projects";
-            text =
-                overallBuildState == OverallBuildState.Error ? $"{errorSymbol} {text} {errorSymbol}" :
-                overallBuildState == OverallBuildState.Warning ? $"{warningSymbol} {text} {warningSymbol}" :
-                text;
-
-            Console.Write(
-                // Write header
-                ANSIBuilder.Cursor.Home() +
-                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center(text)), ANSIBuilder.Formatting.BackgroundColor.Black, desiredColor) +
-                // Write footer
-                ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) +
-                    ANSIBuilder.Eraser.LineCursorToEnd() +
-                    new string('-', Console.BufferWidth) +
-                    Environment.NewLine +
-                    FooterText);
-
-            if (Lines.Count == 0)
-            {
-                return;
-            }
-
-            // Iterate over lines and display on terminal
-            string contents = string.Empty;
-            int accumulatedLineCount = 0;
-            int lineIndex = 0;
-            foreach (TerminalBufferLine line in Lines)
-            {
-                // Continue if accum line count + next lines < scrolling area
-                if (accumulatedLineCount + line.WrappedText.Count < TopLineIndex)
-                {
-                    accumulatedLineCount += line.WrappedText.Count;
-                    continue;
-                }
-
-                // Break if exceeds scrolling area
-                if (accumulatedLineCount - TopLineIndex > ScrollableAreaHeight)
-                {
-                    break;
-                }
-
-                foreach (string s in line.WrappedText)
-                {
-                    // Get line index relative to scroll area
-                    lineIndex = accumulatedLineCount - TopLineIndex;
-                    // Print if line in scrolling area
-                    if (lineIndex >= 0 && lineIndex < ScrollableAreaHeight)
-                    {
-                        contents += ANSIBuilder.Cursor.Position(lineIndex + 2, 0) + ANSIBuilder.Eraser.LineCursorToEnd() + s;
-                    }
-
-                    accumulatedLineCount++;
-                }
-            }
-            // Iterate for the rest of the screen
-            for (int i = lineIndex + 1; i < ScrollableAreaHeight; i++)
-            {
-                contents += ANSIBuilder.Cursor.Position(i + 2, 0) + ANSIBuilder.Eraser.LineCursorToEnd();
-            }
-            Console.Write(contents);
-        }
-        #endregion
-
-        #region Line identification
-        public static int GetLineIndexById(int lineId)
-        {
-            return Lines.FindIndex(x => x.Id == lineId);
-        }
-
-        public static TerminalBufferLine? GetLineById(int lineId)
-        {
-            int index = GetLineIndexById(lineId);
-            if (index == -1)
-            {
-                return null;
-            }
-
-            return Lines[index];
-        }
-        #endregion
-
-        #region Line create, update and delete
-        // Write new line
-        public static TerminalBufferLine? WriteNewLineAfter(int lineId, string text)
-        {
-            return WriteNewLineAfter(lineId, text, true);
-        }
-        public static TerminalBufferLine? WriteNewLineAfter(int lineId, string text, bool shouldWrapLines)
-        {
-            TerminalBufferLine line = new TerminalBufferLine(text, shouldWrapLines);
-            return WriteNewLineAfter(lineId, line);
-        }
-        public static TerminalBufferLine? WriteNewLineAfter(int lineId, TerminalBufferLine line)
-        {
-            if (lineId != -1)
-            {
-                // Get line index
-                int lineIndex = GetLineIndexById(lineId);
-                if (lineIndex == -1)
-                {
-                    return null;
-                }
-                // Get line end index
-                Lines.Insert(lineIndex + 1, line);
-            }
-            else
-            {
-                Lines.Add(line);
-            }
-            return line;
-        }
-
-        public static TerminalBufferLine? WriteNewLineAfterMidpoint(string text, bool shouldWrapLines = false)
-        {
-            TerminalBufferLine line = new(text, shouldWrapLines);
-            return WriteNewLineAfter(midLineId, line);
-        }
-
-        public static TerminalBufferLine? WriteNewLineBeforeMidpoint(string text, bool shouldWrapLines)
-        {
-            TerminalBufferLine line = new(text, shouldWrapLines);
-            int lineIndex = GetLineIndexById(midLineId);
-            if (lineIndex == -1)
-            {
-                WriteNewLine(line);
-                return null;
-            }
-
-            Lines.Insert(lineIndex, line);
-
-            return line;
-        }
-
-        public static TerminalBufferLine? WriteNewLine(string text)
-        {
-            return WriteNewLine(text, true);
-        }
-        public static TerminalBufferLine? WriteNewLine(string text, bool shouldWrapLines)
-        {
-            TerminalBufferLine line = new TerminalBufferLine(text, shouldWrapLines);
-            return WriteNewLine(line);
-        }
-        public static TerminalBufferLine? WriteNewLine(TerminalBufferLine line)
-        {
-            return WriteNewLineAfter(Lines.Count > 0 ? Lines.Last().Id : -1, line);
-        }
-
-        // Update line
-        // TODO: Remove. Use line.Text instead
-        public static TerminalBufferLine? UpdateLine(int lineId, string text)
-        {
-            return null;
-        }
-
-        // Delete line
-        public static void DeleteLine(int lineId)
-        {
-            // Get line index
-            int lineIndex = GetLineIndexById(lineId);
-            if (lineIndex == -1)
-            {
-                return;
-            }
-            // Delete
-            Lines.RemoveAt(lineIndex);
-            ShouldRerender = true;
-        }
-        #endregion
-    }
-
-    internal enum OverallBuildState
-    {
-        None,
-        Warning,
-        Error,
-    }
-}
diff --git a/src/MSBuild/LiveLogger/TerminalColor.cs b/src/MSBuild/LiveLogger/TerminalColor.cs
new file mode 100644
index 00000000000..ec27040eb3e
--- /dev/null
+++ b/src/MSBuild/LiveLogger/TerminalColor.cs
@@ -0,0 +1,20 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.LiveLogger;
+
+/// <summary>
+/// Enumerates the text colors supported by <see cref="ITerminal"/>.
+/// </summary>
+internal enum TerminalColor
+{
+    Black = 30,
+    Red = 31,
+    Green = 32,
+    Yellow = 33,
+    Blue = 34,
+    Magenta = 35,
+    Cyan = 36,
+    White = 37,
+    Default = 39
+}
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 00bbd4e0bf4..dfff888c132 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -157,6 +157,7 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ThreadPoolExtensions.cs" />
+    <Compile Include="..\Shared\StringExtensions.cs" />
     <Compile Include="AssemblyInfo.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index e9991973cf6..fe203f77a91 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1419,6 +1419,11 @@ elementFormDefault="qualified">
     <xs:element name="CLRSupport" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="UseDebugLibraries" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="CodePage" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="CompilerGeneratedFilesOutputPath" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="CompilerGeneratedFilesOutputPath" _locComment="" -->Controls where source generated files are saved.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="Configuration" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ConfigurationName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ConfigurationOverrideFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1700,6 +1705,11 @@ elementFormDefault="qualified">
         </xs:annotation>
     </xs:element>
     <xs:element name="DocumentationFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="EmitCompilerGeneratedFiles" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EmitCompilerGeneratedFiles" _locComment="" -->Controls whether source generated files will be saved.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="EnableASPDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="EnableASPXDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="EnableSQLServerDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1730,6 +1740,20 @@ elementFormDefault="qualified">
         <xs:documentation><!-- _locID_text="GenerateDocumentationFile" _locComment="" -->Value indicating whether a documentation file will be generated by the compiler</xs:documentation>
       </xs:annotation>
     </xs:element>
+    <xs:element name="CopyDebugSymbolFilesFromPackages" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation>
+                <!-- _locID_text="CopyDebugSymbolFilesFromPackages" _locComment="" -->Value indicating whether symbol files will be copied from NuGet packages by the compiler
+            </xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="CopyDocumentationFilesFromPackages" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation>
+                <!-- _locID_text="CopyDocumentationFilesFromPackages" _locComment="" -->Value indicating whether documentation files will be copied from NuGet packages by the compiler
+            </xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="GenerateManifests" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="GenerateLibraryLayout" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="GeneratePackageOnBuild" type="msb:boolean" substitutionGroup="msb:Property">
@@ -6173,5 +6197,11 @@ elementFormDefault="qualified">
       </xs:complexContent>
     </xs:complexType>
   </xs:element>
+  
+  <xs:element name="InvariantGlobalization" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:annotation>
+      <xs:documentation><!-- _locID_text="InvariantGlobalization" _locComment="" -->Indicates whether an app runs in globalization-invariant mode without access to culture-specific data and behavior.</xs:documentation>
+    </xs:annotation>
+  </xs:element>
 
 </xs:schema>
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 31209200c7b..f1f7c3b7ffe 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -982,16 +982,16 @@ private void SetTaskHostEnvironment(IDictionary<string, string> environment)
 
             if (_updateEnvironment)
             {
-                foreach (string variable in s_mismatchedEnvironmentValues.Keys)
+                foreach (KeyValuePair<string, KeyValuePair<string, string>> variable in s_mismatchedEnvironmentValues)
                 {
-                    string oldValue = s_mismatchedEnvironmentValues[variable].Key;
-                    string newValue = s_mismatchedEnvironmentValues[variable].Value;
+                    string oldValue = variable.Value.Key;
+                    string newValue = variable.Value.Value;
 
                     // We don't check the return value, because having the variable not exist == be
                     // null is perfectly valid, and mismatchedEnvironmentValues stores those values
                     // as null as well, so the String.Equals should still return that they are equal.
                     string environmentValue = null;
-                    environment.TryGetValue(variable, out environmentValue);
+                    environment.TryGetValue(variable.Key, out environmentValue);
 
                     if (String.Equals(environmentValue, oldValue, StringComparison.OrdinalIgnoreCase))
                     {
@@ -1009,14 +1009,14 @@ private void SetTaskHostEnvironment(IDictionary<string, string> environment)
                         {
                             if (_updateEnvironmentAndLog)
                             {
-                                LogMessageFromResource(MessageImportance.Low, "ModifyingTaskHostEnvironmentVariable", variable, newValue, environmentValue ?? String.Empty);
+                                LogMessageFromResource(MessageImportance.Low, "ModifyingTaskHostEnvironmentVariable", variable.Key, newValue, environmentValue ?? String.Empty);
                             }
 
-                            updatedEnvironment[variable] = newValue;
+                            updatedEnvironment[variable.Key] = newValue;
                         }
                         else
                         {
-                            updatedEnvironment.Remove(variable);
+                            updatedEnvironment.Remove(variable.Key);
                         }
                     }
                 }
@@ -1045,35 +1045,32 @@ private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<str
 
             if (_updateEnvironment)
             {
-                foreach (string variable in s_mismatchedEnvironmentValues.Keys)
+                foreach (KeyValuePair<string, KeyValuePair<string, string>> variable in s_mismatchedEnvironmentValues)
                 {
                     // Since this is munging the property list for returning to the parent process,
                     // then the value we wish to replace is the one that is in this process, and the
                     // replacement value is the one that originally came from the parent process,
                     // instead of the other way around.
-                    string oldValue = s_mismatchedEnvironmentValues[variable].Value;
-                    string newValue = s_mismatchedEnvironmentValues[variable].Key;
+                    string oldValue = variable.Value.Value;
+                    string newValue = variable.Value.Key;
 
                     // We don't check the return value, because having the variable not exist == be
                     // null is perfectly valid, and mismatchedEnvironmentValues stores those values
                     // as null as well, so the String.Equals should still return that they are equal.
                     string environmentValue = null;
-                    environment.TryGetValue(variable, out environmentValue);
+                    environment.TryGetValue(variable.Key, out environmentValue);
 
                     if (String.Equals(environmentValue, oldValue, StringComparison.OrdinalIgnoreCase))
                     {
-                        if (updatedEnvironment == null)
-                        {
-                            updatedEnvironment = new Dictionary<string, string>(environment, StringComparer.OrdinalIgnoreCase);
-                        }
+                        updatedEnvironment ??= new Dictionary<string, string>(environment, StringComparer.OrdinalIgnoreCase);
 
                         if (newValue != null)
                         {
-                            updatedEnvironment[variable] = newValue;
+                            updatedEnvironment[variable.Key] = newValue;
                         }
                         else
                         {
-                            updatedEnvironment.Remove(variable);
+                            updatedEnvironment.Remove(variable.Key);
                         }
                     }
                 }
@@ -1106,36 +1103,36 @@ private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> en
                 // after the node is launched.
                 s_mismatchedEnvironmentValues = new Dictionary<string, KeyValuePair<string, string>>(StringComparer.OrdinalIgnoreCase);
 
-                foreach (string variable in _savedEnvironment.Keys)
+                foreach (KeyValuePair<string, string> variable in _savedEnvironment)
                 {
-                    string oldValue = _savedEnvironment[variable];
+                    string oldValue = variable.Value;
                     string newValue;
-                    if (!environment.TryGetValue(variable, out newValue))
+                    if (!environment.TryGetValue(variable.Key, out newValue))
                     {
-                        s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(null, oldValue);
+                        s_mismatchedEnvironmentValues[variable.Key] = new KeyValuePair<string, string>(null, oldValue);
                     }
                     else
                     {
                         if (!String.Equals(oldValue, newValue, StringComparison.OrdinalIgnoreCase))
                         {
-                            s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, oldValue);
+                            s_mismatchedEnvironmentValues[variable.Key] = new KeyValuePair<string, string>(newValue, oldValue);
                         }
                     }
                 }
 
-                foreach (string variable in environment.Keys)
+                foreach (KeyValuePair<string, string> variable in environment)
                 {
-                    string newValue = environment[variable];
+                    string newValue = variable.Value;
                     string oldValue;
-                    if (!_savedEnvironment.TryGetValue(variable, out oldValue))
+                    if (!_savedEnvironment.TryGetValue(variable.Key, out oldValue))
                     {
-                        s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, null);
+                        s_mismatchedEnvironmentValues[variable.Key] = new KeyValuePair<string, string>(newValue, null);
                     }
                     else
                     {
                         if (!String.Equals(oldValue, newValue, StringComparison.OrdinalIgnoreCase))
                         {
-                            s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, oldValue);
+                            s_mismatchedEnvironmentValues[variable.Key] = new KeyValuePair<string, string>(newValue, oldValue);
                         }
                     }
                 }
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 3cea4a096b1..63b31b65654 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -833,8 +833,7 @@
     </comment>
   </data>
   <data name="HelpMessage_40_WarnNotAsErrorSwitch" Visibility="Public">
-    <value>
-      -warnNotAsError[:code[;code2]]
+    <value>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -848,6 +847,20 @@
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </comment>
   </data>
+  <data name="HelpMessage_41_QuestionSwitch" Visibility="Public">
+    <value>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </value>
+    <comment>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
   <data name="InvalidConfigurationFile" Visibility="Public">
     <value>MSBUILD : Configuration error MSB1043: The application could not start. {0}</value>
     <comment>
@@ -1350,6 +1363,113 @@
     <value>MSBUILD : error MSB1062: The -warnnotaserror switch cannot be specified unless the -warnaserror switch is also specified and left empty.</value>
     <comment>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</comment>
   </data>
+  <data name="UnsupportedSwitchForSolutionFiles" Visibility="Public">
+    <value>The '{0}' switch is not supported for solution files.</value>
+  </data>
+  <!-- **** LiveLogger strings begin **** -->
+  <data name="RestoreComplete" xml:space="preserve">
+    <value>Restore complete ({0}s)</value>
+    <comment>
+      {0}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="RestoreCompleteWithMessage" xml:space="preserve">
+    <value>Restore {0} in {1}s</value>
+    <comment>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="BuildFinished" xml:space="preserve">
+    <value>Build {0} in {1}s</value>
+    <comment>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="BuildResult_FailedWithErrors" xml:space="preserve">
+    <value>failed with errors</value>
+    <comment>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_FailedWithWarnings" xml:space="preserve">
+    <value>failed with warnings</value>
+    <comment>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_Failed" xml:space="preserve">
+    <value>failed</value>
+    <comment>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_Succeeded" xml:space="preserve">
+    <value>succeeded</value>
+    <comment>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_SucceededWithWarnings" xml:space="preserve">
+    <value>succeeded with warnings</value>
+    <comment>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="ProjectFinished_NoTF" xml:space="preserve">
+    <value>{0}{1} {2} ({3}s)</value>
+    <comment>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="ProjectFinished_WithTF" xml:space="preserve">
+    <value>{0}{1} {2} {3} ({4}s)</value>
+    <comment>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="ProjectFinished_OutputPath" xml:space="preserve">
+    <value> → {0}</value>
+    <comment>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </comment>
+  </data>
+  <data name="ProjectBuilding_NoTF" xml:space="preserve">
+    <value>{0}{1} {2} ({3}s)</value>
+    <comment>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <data name="ProjectBuilding_WithTF" xml:space="preserve">
+    <value>{0}{1} {2} {3} ({4}s)</value>
+    <comment>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </comment>
+  </data>
+  <!-- **** LiveLogger strings end **** -->
+
     <!--
         The command line message bucket is: MSB1001 - MSB1999
 
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 827a5cd91a3..b7cda4b5393 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: Přepínač -noAutoResponse nelze zadat v souboru automatických odpovědí MSBuild.rsp ani v žádném jiném souboru odpovědí, na který se v souboru automatických odpovědí odkazuje.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -150,16 +215,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Způsobí, že MSBuild sestaví jednotlivé projekty izolovaně.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
+
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Jde o omezenější režim nástroje MSBuild, protože vyžaduje,
-                     aby byl graf projektu staticky zjistitelný v okamžiku
-                     vyhodnocení, může ale vylepšit plánování a snížit
-                     režii paměti při sestavování velké sady projektů.
-                     (Krátký tvar: -isolate)
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
 
-                     Tento příznak je experimentální a nemusí fungovat tak, jak byl zamýšlen.
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -265,8 +339,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -275,14 +348,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     Seznam kódů upozornění, které se nemají považovat za chyby.
-                     Pomocí středníku nebo čárky oddělte
-                     více kódů upozornění. Nemá žádný vliv, pokud přepínač -warnaserror
-                     není nastavený.
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
+                     switch is not set.
 
-                     Příklad:
+                     Example:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -345,9 +417,9 @@
         <target state="translated">  @&lt;soubor&gt;            Vložení nastavení příkazového řádku z textového souboru. Chcete-li zadat
                      více souborů odpovědí, uveďte každý soubor
                      odpovědí zvlášť.
-
-                     Automaticky jsou použity všechny soubory s názvem msbuild.rsp
-                     nacházející se v následujících umístěních:
+                     
+                     Automaticky jsou použity všechny soubory s názvem msbuild.rsp 
+                     nacházející se v následujících umístěních: 
                      (1) adresář nástroje msbuild.exe
                      (2) adresář prvního sestaveného projektu nebo řešení
 </target>
@@ -408,7 +480,7 @@
 </source>
         <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Nastavení nebo potlačení daných vlastností na úrovni
                      projektu. &lt;n&gt; je název vlastnosti a &lt;v&gt; je její hodnota. Více
-                     vlastností oddělte středníkem či čárkou nebo zadejte
+                     vlastností oddělte středníkem či čárkou nebo zadejte 
                      každou vlastnost zvlášť. (Krátký tvar: -p)
                      Příklad:
                        -property:WarningLevel=2;OutDir=bin\Debug\
@@ -449,7 +521,7 @@
                      Syntaxe hodnoty &lt;sestavení_protok_nást&gt;:
                         {&lt;název_sestavení&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavení&gt;}
                      Parametry protokolovacího nástroje určují, jak MSBuild vytvoří protokolovací nástroj.
-                     Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se
+                     Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se 
                      protokolovacímu nástroji přesně v tom tvaru, v jakém
                      byly zadány. (Krátký tvar: -l)
                      Příklady:
@@ -596,10 +668,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate          Ověřit projekt podle výchozího schématu.
+        <target state="translated">  -validate          Ověřit projekt podle výchozího schématu. 
                      (Krátký tvar: -val)
 
-  -validate:&lt;schéma&gt; Ověřit projekt podle zadaného schématu.
+  -validate:&lt;schéma&gt; Ověřit projekt podle zadaného schématu. 
                      (Krátký tvar: -val)
                      Příklad:
                        -validate:MyExtendedBuildSchema.xsd
@@ -659,11 +731,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Seznam středníkem oddělených vstupních souborů mezipaměti, ze kterých
-                     MSBuild přečte výsledky sestavení.
-                     Nastavení tohoto atributu zároveň zapne izolované buildy (-isolate).
-                     (Krátký tvar: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -677,11 +748,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[souborMezipaměti]...
-                     Výstupní soubor mezipaměti, do něhož bude MSBuild
-                     zapisovat obsah svých mezipamětí výsledků sestavení.
-                     Nastavením této možnosti zapnete také izolované buildy (-isolate).
-                     (krátký tvar: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -713,11 +784,11 @@
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
-        <target state="translated">  -distributedlogger:&lt;centr_protok_nást&gt;*&lt;předáv_protok_nást&gt;
+        <target state="translated">  -distributedlogger:&lt;centr_protok_nást&gt;*&lt;předáv_protok_nást&gt;                     
                      Použít zadaný protokolovací nástroj pro protokolování událostí
-                     z nástroje MSBuild; ke každému uzlu připojit jinou instanci
-                     protokolovacího nástroje. Chcete-li zadat více
-                     protokolovacích nástrojů, uveďte je jednotlivě.
+                     z nástroje MSBuild; ke každému uzlu připojit jinou instanci 
+                     protokolovacího nástroje. Chcete-li zadat více 
+                     protokolovacích nástrojů, uveďte je jednotlivě. 
                      (Krátký tvar: -dl)
                      Syntaxe hodnoty &lt;protok_nást&gt;:
                         [&lt;třída_protok_nást&gt;,]&lt;sestav_protok_nást&gt;
@@ -781,7 +852,7 @@
         <target state="translated">  -toolsversion:&lt;verze&gt;
                      Verze sady nástrojů MSBuild (úloh, cílů apod.), která má být
                      použita při sestavení. Tato verze má přednost před verzemi
-                     uvedenými v jednotlivých projektech.
+                     uvedenými v jednotlivých projektech. 
                      (Krátký tvar: -tv)
                      Příklad:
                        -toolsversion:3.5
@@ -899,25 +970,25 @@
                      popis přepínače -distributedFileLogger.
                      (Krátký tvar: -flp[n])
                      K dispozici jsou stejné parametry jako ty,
-                     které jsou uvedeny u protokolovacího nástroje
+                     které jsou uvedeny u protokolovacího nástroje 
                      konzoly. Některé další dostupné parametry:
                        LogFile – cesta k souboru protokolu, do nějž bude zapsán
-                                  protokol sestavení
+                                  protokol sestavení 
                        Append  – určuje, zda bude protokol sestavení připojen
-                                  k souboru protokolu, nebo jej přepíše. Při nastavení
+                                  k souboru protokolu, nebo jej přepíše. Při nastavení 
                                   přepínače bude protokol sestavení připojen k souboru
-                                  protokolu. Není-li přepínač nastaven, bude obsah
-                                  existujícího souboru protokolu přepsán.
+                                  protokolu. Není-li přepínač nastaven, bude obsah 
+                                  existujícího souboru protokolu přepsán. 
                                   Podle výchozího nastavení je soubor protokolu přepsán.
-                       Encoding – určuje kódování souboru, například
+                       Encoding – určuje kódování souboru, například 
                      UTF-8, Unicode nebo ASCII.
                        Výchozí úroveň podrobností je Detailed.
                      Příklady:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                              Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1040,7 +1111,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Hodnota izolace projektů není platná. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Hodnota izolace projektů není platná. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1307,6 +1378,60 @@
         <target state="translated">Proces = {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Soubor projektu neexistuje.</target>
@@ -1352,6 +1477,22 @@
         <target state="translated">{0} přišla z {1}</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1413,6 +1554,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild nejde spustit v této verzi operačního systému. Podporuje se jenom v systémech Windows 7 a novějších verzích.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Probíhá vynucení načtení Microsoft.Build.Engine, protože MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index a48f6fd867d..9fb42e5905b 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: Der Schalter "-noAutoResponse" kann weder in der automatischen Antwortdatei "MSBuild.rsp" noch in einer anderen Antwortdatei verwendet werden, auf die die automatische Antwortdatei verweist.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -116,7 +181,7 @@
                      value that comes from a response file.
     </source>
         <target state="translated">  -interactive[:True|False]
-                     Weist darauf hin, dass für Aktionen im Build eine
+                     Weist darauf hin, dass für Aktionen im Build eine 
                      Interaktion mit dem Benutzer zugelassen ist. Verwenden Sie dieses Argument
                      in einem automatisierten Szenario, in dem keine Interaktivität
                      erwartet wird.
@@ -150,16 +215,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Führt dazu, dass MSBuild jedes Projekt isoliert erstellt.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Dies ist ein restriktiverer Modus von MSBuild, da er erfordert, dass
-                     der Projektgraph zur Auswertungszeit statisch ermittelbar ist. Er kann jedoch
-                     die Planung verbessern und den Speichermehraufwand
-                     beim Erstellen einer großen Anzahl von Projekten verringern.
-                     (Kurzform: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Dieses Flag ist experimentell und funktioniert möglicherweise nicht wie vorgesehen.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -265,8 +339,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -275,14 +348,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     Liste der Warnungscodes, die nicht als Fehler behandelt werden sollen.
-                     Semikolon oder Komma zum Trennen verwenden
-                     mehrere Warnungscodes. Hat keine Auswirkungen, wenn der -warnaserror
-                     Switch nicht festgelegt ist.
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
+                     switch is not set.
 
-Beispiel:
+                     Example:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -346,8 +418,8 @@ Beispiel:
                      Antwortdateien anzugeben, geben Sie jede Antwortdatei
                      gesondert an.
 
-                     Alle Antwortdateien mit dem Name "msbuild.rsp" werden automatisch
-                     in den folgenden Speicherorten verwendet:
+                     Alle Antwortdateien mit dem Name "msbuild.rsp" werden automatisch 
+                     in den folgenden Speicherorten verwendet: 
                      (1) Verzeichnis von "msbuild.exe"
                      (2) Verzeichnis des ersten erstellten Projekts oder Projektmappe
 </target>
@@ -438,7 +510,7 @@ Beispiel:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben,
+        <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben, 
                      wird jede Protokollierung gesondert angegeben.
                      Die Syntax für die &lt;Protokollierung&gt; lautet:
                        [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
@@ -447,7 +519,7 @@ Beispiel:
                      Die Syntax für die &lt;Protokollierungsassembly&gt; lautet:
                        {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
-                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau
+                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung übergeben, wie sie eingegeben wurden. (Kurzform: -l)
                      Beispiele:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -656,11 +728,10 @@ Beispiel:
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Durch Semikolons getrennte Liste von Eingabecachedateien, aus denen MSBuild
-                     Buildergebnisse liest.
-                     Durch Festlegen dieser Option werden auch isolierte Builds aktiviert (-isolate).
-                     (Kurzform: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,11 +745,11 @@ Beispiel:
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[Cachedatei]
-                     Ausgabecachedateien, in die MSBuild am Ende des Buildvorgangs die Inhalte
-                     der zugehörigen Caches mit Buildergebnissen schreibt.
-                     Durch Festlegung dieser Option werden außerdem isolierte Builds aktiviert (-isolate).
-                     (Kurzform: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -711,8 +782,8 @@ Beispiel:
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
         <target state="translated">  -distributedlogger:&lt;Zentrale Protokollierung&gt;*&lt;Weiterleitende Protokollierung&gt;
-                     Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert, wobei an jeden Knoten eine andere
-                     Protokollierungsinstanz angefügt wird. Um mehrere Protokollierungen anzugeben, wird jede Protokollierung
+                     Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert, wobei an jeden Knoten eine andere 
+                     Protokollierungsinstanz angefügt wird. Um mehrere Protokollierungen anzugeben, wird jede Protokollierung 
                      gesondert angegeben.
                      (Kurzform -dl)
                      Die Syntax für die &lt;Protokollierung&gt; lautet:
@@ -722,7 +793,7 @@ Beispiel:
                      Die Syntax für die &lt;Protokollierungsassembly&gt; lautet:
                        {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
-                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau
+                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung übergeben, wie sie eingegeben wurden. (Kurzform: -l)
                      Beispiele:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -747,8 +818,8 @@ Beispiel:
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreprojectextensions:&lt;Erweiterungen&gt;
-                     Liste der zu ignorierenden Erweiterungen, wenn die zu erstellende
-                     Projektdatei ermittelt wird. Verwenden Sie ein Semikolon oder ein Komma,
+                     Liste der zu ignorierenden Erweiterungen, wenn die zu erstellende 
+                     Projektdatei ermittelt wird. Verwenden Sie ein Semikolon oder ein Komma, 
                      um mehrere Erweiterungen voneinander zu trennen.
                      (Kurzform: -ignore)
                      Beispiel:
@@ -774,8 +845,8 @@ Beispiel:
    </source>
         <target state="translated">  -toolsversion:&lt;Version&gt;
                      Die Version des MSBuild-Toolsets (Aufgaben, Ziele usw.),
-                     die während des Erstellens zu verwenden ist. Diese Version überschreibt die
-                     von einzelnen Projekten angegebenen Versionen. (Kurzform:
+                     die während des Erstellens zu verwenden ist. Diese Version überschreibt die 
+                     von einzelnen Projekten angegebenen Versionen. (Kurzform: 
                      -tv)
                      Beispiel:
                        -toolsversion:3.5
@@ -834,14 +905,14 @@ Beispiel:
         <target state="translated">  -distributedFileLogger
                      Protokolliert die Erstellungsausgabe in mehrere Dateien, eine Protokolldatei
                      pro MSBuild-Knoten. Der anfängliche Speicherort für diese Dateien ist
-                     das aktuelle Verzeichnis. Standardmäßig werden die Dateien
+                     das aktuelle Verzeichnis. Standardmäßig werden die Dateien 
                      "MSBuild&lt;Knoten-ID&gt;.log" benannt. Der Speicherort der Datei und
-                     andere Parameter für fileLogger können durch das Hinzufügen
+                     andere Parameter für fileLogger können durch das Hinzufügen 
                      des Schalters "-fileLoggerParameters" angegeben werden.
 
                      Wenn mithilfe des fileLoggerParameters-Parameters ein Protokolldateiname festgelegt wurde,
-                     verwendet die verteilte Protokollierung den Dateinamen als
-                     Vorlage und fügt die Knoten-ID an diesen Dateinamen an,
+                     verwendet die verteilte Protokollierung den Dateinamen als 
+                     Vorlage und fügt die Knoten-ID an diesen Dateinamen an, 
                      um für jeden Knoten eine Protokolldatei zu erstellen.
     </target>
         <note>
@@ -885,31 +956,31 @@ Beispiel:
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;Parameter&gt;
                      Gibt zusätzliche Parameter für Dateiprotokollierungen an.
-                     Dieser Schalter bedeutet, dass der entsprechende
+                     Dieser Schalter bedeutet, dass der entsprechende 
                      Schalter "-fileLogger[n]" ebenfalls vorhanden ist.
                      "n" (optional) kann eine Zahl von 1–9 sein.
-                     "-fileLoggerParameters" wird auch von verteilten
+                     "-fileLoggerParameters" wird auch von verteilten 
                      Dateiprotokollierungen verwendet (siehe Beschreibung zu "-distributedFileLogger").
                      (Kurzform: -flp[n])
                      Es sind dieselben Parameter wie für die Konsolenprotokollierung
                      verfügbar. Einige zusätzliche Parameter:
-                        LogFile: Pfad der Protokolldatei, in die das
+                        LogFile: Pfad der Protokolldatei, in die das 
                             Buildprotokoll geschrieben wird.
-                        Append: Gibt an, ob das Buildprotokoll erweitert oder
+                        Append: Gibt an, ob das Buildprotokoll erweitert oder 
                             oder überschrieben wird. Mit diesem Schalter
                             wird das Buildprotokoll an die Protokolldatei angefügt;
-                            Ohne diesen Schalter wird der Inhalt
-                            der vorhandenen Protokolldatei überschrieben.
+                            Ohne diesen Schalter wird der Inhalt 
+                            der vorhandenen Protokolldatei überschrieben. 
                             Standardmäßig wird die Protokolldatei nicht erweitert.
-                        Encoding: Gibt die Codierung der Datei an,
+                        Encoding: Gibt die Codierung der Datei an, 
                             z. B. UTF-8, Unicode oder ASCII.
                      Die Standardeinstellung für "verbosity" ist "Detailed".
                      Beispiele:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -935,7 +1006,7 @@ Beispiel:
         <target state="translated">  -nodeReuse:&lt;Parameter&gt;
                      Aktiviert oder deaktiviert die Wiederverwendung von MSBuild-Knoten.
                      Die Parameter lauten:
-                     True: Knoten bleiben nach dem Abschluss der Erstellung
+                     True: Knoten bleiben nach dem Abschluss der Erstellung 
                      erhalten und werden bei folgenden Erstellungen wiederverwendet (Standardeinstellung).
                      False: Knoten bleiben nach dem Abschluss der Erstellung nicht erhalten.
                      (Kurzform: -nr)
@@ -1032,7 +1103,7 @@ Beispiel:
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Der Wert für das Isolieren von Projekten ist nicht gültig. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Der Wert für das Isolieren von Projekten ist nicht gültig. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1299,6 +1370,60 @@ Beispiel:
         <target state="translated">Prozess = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Die Projektdatei ist nicht vorhanden.</target>
@@ -1344,6 +1469,22 @@ Beispiel:
         <target state="translated">„{0}“ stammt aus „{1}“</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1405,6 +1546,11 @@ Beispiel:
         <target state="translated">MSBUILD : error MSB1015: MSBuild kann unter dieser Version des Betriebssystems nicht ausgeführt werden. Nur Windows 7 und Folgeversionen werden unterstützt.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Laden von "Microsoft.Build.Engine" wird erzwungen, da MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index bf8d89e1c84..8a46fac0eba 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: El modificador -noAutoResponse no puede especificarse en el archivo de respuesta automática MSBuild.rsp ni en ningún archivo de respuesta al que el archivo de respuesta automática haga referencia.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -150,16 +215,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Hace que MSBuild compile cada proyecto en aislamiento.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Este es un modo de MSBuild más restrictivo ya que requiere
-                     que el grafo de proyecto se pueda detectar estáticamente en el
-                     momento de evaluación, pero puede mejorar la programación y reducir
-                     la sobrecarga de memoria al compilar un gran conjunto de proyectos.
-                     (Forma corta: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Este indicador es experimental y puede que no funcione como se espera.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -265,8 +339,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -275,14 +348,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     Lista de códigos de advertencia para que no se traten como errores.
-                     Use un punto y coma o una coma para separar
-                     varios códigos de advertencia. No tiene efecto si el modificador -warnaserror
-                     no se ha establecido.
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
+                     switch is not set.
 
-                     Ejemplo:
+                     Example:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -660,11 +732,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;archivoCaché&gt;...
-                     Lista de archivos de caché de entrada, separados por punto y coma, de la que MSBuild
-                     leerá los resultados de la compilación.
-                     Si se establece esta opción, se activan también las compilaciones aisladas (-isolate).
-                     (Forma corta: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -678,13 +749,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[archivo-de-caché]
-                     Archivo de caché de salida donde MSBuild escribe
-                     el contenido de las memorias caché de resultados
-                     de compilación cuando esta acaba.
-                     Si se establece esta opción, se activan también las
-                     compilaciones aisladas (-isolate).
-                     (Forma corta: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -756,8 +825,8 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;extensiones&gt;
-                     Lista de extensiones que se omiten al determinar el
-                     archivo del proyecto que se va a compilar. Use el carácter de
+                     Lista de extensiones que se omiten al determinar el 
+                     archivo del proyecto que se va a compilar. Use el carácter de 
                      punto y coma o coma para separar varias extensiones.
                     (Forma corta: -ignore)
                      Ejemplo:
@@ -908,9 +977,9 @@
                             sobrescribirá el archivo de registro. Si se establece el
                             modificador, se adjunta el registro de compilación al archivo de registro;
                             Si no se especifica el modificador, se sobrescribe
-                            el contenido del archivo de registro existente.
+                            el contenido del archivo de registro existente. 
                             El valor predeterminado es adjuntar el archivo de registro.
-                        Encoding: especifica la codificación del archivo,
+                        Encoding: especifica la codificación del archivo, 
                             por ejemplo, UTF-8, Unicode o ASCII
                      El nivel de detalle predeterminado es Detailed.
                      Ejemplos:
@@ -1041,7 +1110,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: El valor de los proyectos aislados no es válido. {0}.</target>
+        <target state="translated">MSBUILD : error MSB1056: El valor de los proyectos aislados no es válido. {0}.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1308,6 +1377,60 @@
         <target state="translated">Proceso: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: El archivo de proyecto no existe.</target>
@@ -1353,6 +1476,22 @@
         <target state="translated">'{0}' procedía de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1414,6 +1553,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild no se ha podido ejecutar en esta versión del sistema operativo. Solo se admite en Windows 7 y versiones posteriores.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Forzando la carga de Microsoft.Build.Engine porque MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 572e704317d..1e385f6951c 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: Impossible de spécifier le commutateur -noAutoResponse dans le fichier réponse automatique MSBuild.rsp, ni dans aucun autre fichier réponse référencé par le fichier réponse automatique.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -150,16 +215,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Force MSBuild à générer chaque projet de manière isolée.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Ce mode de MSBuild est plus restrictif car il nécessite
-                     que le graphe du projet soit statiquement découvrable au
-                     moment de l'évaluation, mais il peut améliorer la planification et réduire
-                     la surcharge de mémoire lors de la génération d'un grand nombre de projets.
-                     (Forme abrégée : -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Cet indicateur est expérimental et peut ne pas fonctionner comme prévu.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -265,8 +339,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -275,16 +348,15 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-     -warnNotAsError[:code[;code2]]
-                     Liste des codes d’avertissement à traiter non comme des erreurs.
-                     Utiliser un point-virgule ou une virgule pour séparer
-                     plusieurs codes d’avertissement. N’a aucun effet si -warnaserror
-                     n’est pas défini.
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
+                     switch is not set.
 
-                     Exemple:
+                     Example:
                        -warnNotAsError:MSB3026
-   </target>
+    </target>
         <note>
       LOCALIZATION: "-warnNotAsError" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -656,11 +728,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;fichierCache&gt;...
-         Liste de fichiers cache d'entrée séparés par des points-virgules, à
-         partir desquels MSBuild va lire les résultats de la build.
-         Ce paramètre active également les builds isolées (-isolate).
-         (Forme abrégée : -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,11 +745,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     Fichier cache de sortie dans lequel MSBuild écrit le contenu de
-                     ses caches de résultats de la build à la fin de la build.
-                     Ce paramètre active également les builds isolées (-isolate).
-                     (forme abrégée : -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1032,7 +1103,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: La valeur d’isolation des projets n'est pas valide. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: La valeur d’isolation des projets n'est pas valide. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1299,6 +1370,60 @@
         <target state="translated">Processus = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Le fichier projet n'existe pas.</target>
@@ -1344,6 +1469,22 @@
         <target state="translated">'{0}' provient de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1405,6 +1546,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild ne s'exécute pas sur cette version du système d'exploitation. Il n'est pris en charge que sur Windows 7 et les versions ultérieures.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Chargement forcé de Microsoft.Build.Engine, car MSBUILDOLDOM=1...</target>
@@ -1761,7 +1907,7 @@ fois plus petit que le journal
         <target state="translated">  -profileEvaluation:&lt;fichier&gt;
          Profile l'évaluation MSBuild et écrit le résultat
          dans le fichier spécifié. Si l'extension du fichier spécifié
-         est '.md', le résultat est généré au format Markdown.
+         est '.md', le résultat est généré au format Markdown. 
          Sinon, un fichier de valeurs séparées par des tabulations est généré.
     </target>
         <note />
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index d97eee21a68..8e79d36d8fc 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: non è possibile specificare l'opzione -noAutoResponse nel file di risposta automatica MSBuild.rsp o in file di risposta a cui il file di risposta automatica fa riferimento.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -151,19 +216,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Fa in modo che MSBuild compili ogni progetto in modalità
-                     isolamento.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Si tratta di una modalità più restrittiva di
-                     MSBuild perché richiede che il grafico del progetto sia
-                     rilevabile staticamente in fase di valutazione, ma può
-                     migliorare la pianificazione e ridurre il sovraccarico
-                     della memoria quando si compila un set esteso di progetti.
-                     Forma breve: -isolate.
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Questo flag è sperimentale e potrebbe non funzionare come
-                     previsto.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -272,8 +343,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -282,14 +352,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     Elenco di codici di avviso da non considerare come errori.
-                     Usare un punto e virgola o una virgola per separare
-                     più codici di avviso. Non ha alcun effetto se l’opzione -warnaserror
-                     non è impostata.
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
+                     switch is not set.
 
-Esempio:
+                     Example:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -357,7 +426,7 @@ Esempio:
                      separatamente.
 
                      Qualsiasi file di risposta denominato "msbuild.rsp" viene usato
-                     automaticamente dai percorsi seguenti:
+                     automaticamente dai percorsi seguenti: 
                      (1) la directory di msbuild.exe
                      (2) la directory della prima compilazione di soluzione o progetto
 </target>
@@ -666,11 +735,10 @@ Esempio:
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;fileCache&gt;...
-                     Elenco di file di cache di input delimitati da punto e virgola da cui MSBuild
-                     leggerà i risultati della compilazione.
-                     Se si imposta questa opzione, si attivano anche le compilazioni isolate (-isolate).
-                     Forma breve: -irc
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -684,11 +752,11 @@ Esempio:
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[fileCache]
-                     File di cache di output in cui MSBuild scriverà il contenuto delle
-                     cache dei risultati della compilazione al termine della compilazione.
-                     Se si imposta questa opzione, si attivano anche le compilazioni isolate (-isolate).
-                     Forma breve: -orc
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1046,7 +1114,7 @@ Esempio:
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: il valore di isolateProjects non è valido. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: il valore di isolateProjects non è valido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1313,6 +1381,60 @@ Esempio:
         <target state="translated">Processo = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: il file di progetto non esiste.</target>
@@ -1358,6 +1480,22 @@ Esempio:
         <target state="translated">'{0}' proviene da '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1419,6 +1557,11 @@ Esempio:
         <target state="translated">MSBUILD : error MSB1015: MSBuild non può essere eseguito su questa versione del sistema operativo. È supportato solo in Windows 7 e versioni successive.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Verrà imposto il caricamento di Microsoft.Build.Engine perché MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index c590ae60203..a7753de3d15 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp 自動応答ファイルや、自動応答ファイルによって参照される応答ファイルに -noAutoResponse スイッチを指定することはできません。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -150,16 +215,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     MSBuild は、各プロジェクトを分離してビルドします。
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     これは MSBuild のより制限的なモードです。
-                     評価時にプロジェクト グラフが静的に検出できなければならないためです。
-                     しかし、大きなプロジェクト セットをビルドするときに、
-                     スケジュール設定を向上させ、メモリ オーバーヘッドを削減できます。
-                     (短い形式: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     このフラグは実験的で、意図どおりに機能しない可能性があります。
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -214,7 +288,7 @@
     </source>
         <target state="translated">  -targets[:file]
                      使用可能なターゲットの一覧を、実際のビルド処理を
-                     実行せずに出力します。既定では、出力はコンソール
+                     実行せずに出力します。既定では、出力はコンソール 
                      ウィンドウに書き込まれます。出力ファイルへのパスを
                      指定した場合は、代わりにそのファイルが使用されます。
                      (短い形式:-ts)
@@ -265,8 +339,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -275,14 +348,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     エラーとして扱わない警告コードのリスト.
-                     セミコロンまたはコンマを使用して、複数の警告コード
-                     区切ります。-warnaserror スイッチが設定されていない場合
-                     効果はありません。
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
+                     switch is not set.
 
-                     例:
+                     Example:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -656,11 +728,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     MSBuild がビルド結果を読み込む、入力キャッシュ ファイルの
-                     セミコロンで区切られたリスト。
-                     これを設定すると、分離されたビルド (-isolate) も有効になります。
-                     (短縮形: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,11 +745,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     MSBuild がビルドの最後にビルド結果キャッシュの
-                     内容を書き込む出力キャッシュ ファイル。
-                     設定すると、分離されたビルドも有効になります (-isolate)。
-                     (短い形式: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1032,7 +1103,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Isolate projects 値が無効です。{0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Isolate projects 値が無効です。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1299,6 +1370,60 @@
         <target state="translated">プロセス = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: プロジェクト ファイルが存在しません。</target>
@@ -1344,6 +1469,22 @@
         <target state="translated">`{0}`からの `{1}`</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1405,6 +1546,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild はこのバージョンのオペレーティング システムでは実行できません。Windows 7 およびそれ以降のバージョンでのみサポートされています。</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">MSBUILDOLDOM=1 のため、Microsoft.Build.Engine を強制的に読み込んでいます...</target>
@@ -1700,7 +1846,7 @@
                      (Short form: -r)
     </source>
         <target state="translated">  -restore[:True|False]
-                     他のターゲットをビルドする前に Restore
+                     他のターゲットをビルドする前に Restore 
                      という名前のターゲットを実行し、これらのターゲットのビルドが
                      最新の復元ビルド ロジックを使用するようにします。
                      これは、パッケージ ツリーでパッケージをビルド
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index e136d34da21..e27c3cdbfd0 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp 자동 지시 파일과 자동 지시 파일에서 참조하는 모든 지시 파일에는 -noAutoResponse 스위치를 지정할 수 없습니다.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -116,12 +181,12 @@
                      value that comes from a response file.
     </source>
         <target state="translated">  -interactive[:True|False]
-                     빌드의 작업이 사용자와 상호 작용할 수
-                     있음을 나타냅니다. 상호 작용이 필요하지
-                     않은 자동화된 시나리오에서는 이 인수를
+                     빌드의 작업이 사용자와 상호 작용할 수 
+                     있음을 나타냅니다. 상호 작용이 필요하지 
+                     않은 자동화된 시나리오에서는 이 인수를 
                      사용하지 마세요.
                      -interactive를 지정하는 것은 -interactive:true를
-                     지정하는 것과 같습니다. 매개 변수를
+                     지정하는 것과 같습니다. 매개 변수를 
                      사용하여 지시 파일에서 가져오는 값을 재정의합니다.
     </target>
         <note>
@@ -150,16 +215,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     MSBuild가 격리 모드에서 각 프로젝트를 빌드하도록 합니다.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
+
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     이 모드는 프로젝트 그래프가 평가 시간에 정적으로
-                     검색 가능해야 하므로 더 제한적인 MSBuild 모드이나,
-                     대규모 프로젝트를 빌드할 경우 예약을 개선하고
-                     메모리 오버헤드를 줄일 수 있습니다.
-                     (약식: -isolate)
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
 
-                     이 플래그는 실험적이며 예상대로 작동하지 않을 수 있습니다.
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -182,9 +256,9 @@
         <target state="translated">  -graphBuild[:True|False]
                      MSBuild가 프로젝트 그래프를 생성 및 빌드하도록 합니다.
 
-                     그래프 생성에는 종속성을 형성하기 위한 프로젝트
-                     참조 식별이 관련됩니다. 해당 그래프 빌드에는 프로젝트
-                     참조를 참조하는 프로젝트 전에 프로젝트 참조를
+                     그래프 생성에는 종속성을 형성하기 위한 프로젝트 
+                     참조 식별이 관련됩니다. 해당 그래프 빌드에는 프로젝트 
+                     참조를 참조하는 프로젝트 전에 프로젝트 참조를 
                      빌드하는 시도가 관련되며, 이는 기존 MSBuild
                      예약과 다릅니다.
                      (약식: -graph)
@@ -238,7 +312,7 @@
         <target state="translated">  -lowPriority[:True|False]
                      MSBuild가 낮은 프로세스 우선 순위로 실행됩니다.
 
-                     -lowPriority를 지정하는 것은
+                     -lowPriority를 지정하는 것은 
                      -lowPriority:True를 지정하는 것과 같습니다.
                      (약식: -low)
     </target>
@@ -265,8 +339,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -275,16 +348,15 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-       -warnNotAsError[:code[;code2]]
-                     오류로 처리하지 않을 경고 코드 목록입니다.
-                     세미콜론이나 쉼표를 사용하여 구분하세요.
-                     여러 경고 코드. -warnaserror
- 스위치가 설정되어 있지 않으면 효과가 없습니다.
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
+                     switch is not set.
 
-                     예:
-                     -warnNotAsError:MSB3026
-   </target>
+                     Example:
+                       -warnNotAsError:MSB3026
+    </target>
         <note>
       LOCALIZATION: "-warnNotAsError" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
@@ -342,11 +414,11 @@
                      (1) the directory of msbuild.exe
                      (2) the directory of the first project or solution built
 </source>
-        <target state="translated">  @&lt;file&gt;            텍스트 파일에서 명령줄 설정을 삽입합니다.
-                     여러 지시 파일을 지정하려면 각 지시 파일을 개별적으로
+        <target state="translated">  @&lt;file&gt;            텍스트 파일에서 명령줄 설정을 삽입합니다. 
+                     여러 지시 파일을 지정하려면 각 지시 파일을 개별적으로 
                      지정합니다.
 
-                     "msbuild.rsp"라는 지시 파일이 다음 위치에서
+                     "msbuild.rsp"라는 지시 파일이 다음 위치에서 
                      자동으로 사용됩니다.
                      (1) msbuild.exe의 디렉터리
                      (2) 빌드된 첫 번째 프로젝트 또는 솔루션의 디렉터리
@@ -383,8 +455,8 @@
                      Example:
                        -target:Resources;Compile
 </source>
-        <target state="translated">  -target:&lt;targets&gt;  이 프로젝트에서 대상을 빌드합니다. 세미콜론 또는 쉼표를 사용하여
-                     여러 대상을 구분하거나, 각 대상을
+        <target state="translated">  -target:&lt;targets&gt;  이 프로젝트에서 대상을 빌드합니다. 세미콜론 또는 쉼표를 사용하여 
+                     여러 대상을 구분하거나, 각 대상을 
                      개별적으로 지정합니다. (약식: -t)
                      예:
                        -target:Resources;Compile
@@ -406,9 +478,9 @@
                      Example:
                        -property:WarningLevel=2;OutDir=bin\Debug\
 </source>
-        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  프로젝트 수준 속성을 설정하거나 재정의합니다. &lt;n&gt;은
-                     속성 이름이고 &lt;v&gt;는 속성 값입니다.
-                     세미콜론 또는 쉼표를 사용하여 여러 속성을 구분하거나,
+        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  프로젝트 수준 속성을 설정하거나 재정의합니다. &lt;n&gt;은 
+                     속성 이름이고 &lt;v&gt;는 속성 값입니다. 
+                     세미콜론 또는 쉼표를 사용하여 여러 속성을 구분하거나, 
                      각 속성을 개별적으로 지정합니다. (약식: -p)
                      예:
                        -property:WarningLevel=2;OutDir=bin\Debug\
@@ -593,10 +665,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate          기본 스키마를 기준으로 프로젝트의 유효성을 검사합니다.
+        <target state="translated">  -validate          기본 스키마를 기준으로 프로젝트의 유효성을 검사합니다. 
                      (약식: -val)
 
-  -validate:&lt;schema&gt; 지정된 스키마를 기준으로 프로젝트의 유효성을 검사합니다.
+  -validate:&lt;schema&gt; 지정된 스키마를 기준으로 프로젝트의 유효성을 검사합니다. 
                      (약식: -val)
                      예:
                        -validate:MyExtendedBuildSchema.xsd
@@ -656,11 +728,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     MSBuild가 빌드 결과를 읽는 소스 입력 캐시 파일의
-                     세미콜론으로 구분된 목록입니다.
-                     이 스위치를 설정하면 격리된 빌드(-isolate)도 켜집니다.
-                     (약식: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,10 +745,10 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     MSBuild에서 빌드 마지막에 빌드 결과 캐시의
-                     콘텐츠를 쓰는 출력 캐시 파일입니다.
-                     설정하면 격리된 빌드에서도 설정됩니다(-isolate).
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </target>
         <note>
@@ -747,8 +818,8 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;extensions&gt;
-                     빌드할 프로젝트 파일을 결정할 때
-                     무시할 확장 목록입니다. 여러 확장을 구분하는 데는
+                     빌드할 프로젝트 파일을 결정할 때 
+                     무시할 확장 목록입니다. 여러 확장을 구분하는 데는 
                      세미콜론 또는 쉼표를 사용합니다.
                      (약식: -ignore)
                      예:
@@ -774,7 +845,7 @@
    </source>
         <target state="translated">  -toolsVersion:&lt;version&gt;
                      빌드 중에 사용할 MSBuild 도구 세트(작업, 대상 등)의 버전입니다.
-                     이 버전은 개별 프로젝트에서 지정한 버전을
+                     이 버전은 개별 프로젝트에서 지정한 버전을 
                      재정의합니다. (약식:
                      -tv)
                      예:
@@ -803,9 +874,9 @@
                      파일은 현재 디렉터리에 있고
                      "msbuild[n].log"로 이름이 지정되어 있습니다. 모든 노드의 이벤트는 단일 로그로
                      결합됩니다. 파일의 위치 및 fileLogger의
-                     다른 매개 변수는 "-fileLoggerParameters[n]" 스위치를
+                     다른 매개 변수는 "-fileLoggerParameters[n]" 스위치를 
                      추가하여 지정할 수 있습니다.
-                     "n"은 1-9 사이의 숫자일 수 있으며 최대 10개의
+                     "n"은 1-9 사이의 숫자일 수 있으며 최대 10개의 
                      파일 로거가 추가될 수 있습니다. (약식: -fl[n])
     </target>
         <note>
@@ -832,16 +903,16 @@
                      create a log file for each node.
     </source>
         <target state="translated">  -distributedFileLogger
-                     MSBuild 노드당 로그 파일 하나씩, 여러 로그 파일에 빌드 출력을
-                     기록합니다. 해당 파일의 초기 위치는
-                     현재 디렉터리입니다. 기본적으로 해당 파일을
-                     "MSBuild&lt;nodeid&gt;.log"라고 합니다. 파일 위치 및 fileLogger의 기타 매개 변수는
-                     "-fileLoggerParameters" 스위치를 추가해서
+                     MSBuild 노드당 로그 파일 하나씩, 여러 로그 파일에 빌드 출력을 
+                     기록합니다. 해당 파일의 초기 위치는 
+                     현재 디렉터리입니다. 기본적으로 해당 파일을 
+                     "MSBuild&lt;nodeid&gt;.log"라고 합니다. 파일 위치 및 fileLogger의 기타 매개 변수는 
+                     "-fileLoggerParameters" 스위치를 추가해서 
                      지정할 수 있습니다.
 
-                     로그 파일 이름이 fileLoggerParameters 스위치를 통해 설정되면
-                     배포된 로거가 fileName을 템플릿으로 사용하고
-                     노드 ID를 이 fileName에 추가하여
+                     로그 파일 이름이 fileLoggerParameters 스위치를 통해 설정되면 
+                     배포된 로거가 fileName을 템플릿으로 사용하고 
+                     노드 ID를 이 fileName에 추가하여 
                      각 노드의 로그 파일을 만듭니다.
     </target>
         <note>
@@ -885,20 +956,20 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parameters&gt;
                      파일 로거의 추가 매개 변수를 제공합니다.
-                     이 스위치가 있다는 것은
+                     이 스위치가 있다는 것은 
                      해당 fileLogger[n] 스위치를 의미합니다.
                      "n"(있는 경우)은 1~9의 숫자일 수 있습니다.
-                     -fileLoggerParameters는 배포된 파일 로거에서도
+                     -fileLoggerParameters는 배포된 파일 로거에서도 
                      사용됩니다. -distributedFileLogger에 대한 설명을 참조하세요.
                      (약식: -flp[n])
                      콘솔 로거용으로 나열된 동일한 매개 변수를 사용할 수 있습니다.
                      다음과 같은 몇 가지 추가 매개 변수를 사용할 수 있습니다.
-                        LogFile--빌드 로그가 기록되는
+                        LogFile--빌드 로그가 기록되는 
                             로그 파일의 경로입니다.
-                        Append--빌드 로그가 로그 파일에 추가되는지,
-                            아니면 로그 파일을 덮어쓰는지 여부를 결정합니다.
+                        Append--빌드 로그가 로그 파일에 추가되는지, 
+                            아니면 로그 파일을 덮어쓰는지 여부를 결정합니다. 
                             스위치를 설정하면 빌드 로그가 로그 파일에 추가됩니다.
-                            스위치를 설정하지 않으면 기존 로그 파일의
+                            스위치를 설정하지 않으면 기존 로그 파일의 
                             콘텐츠를 덮어씁니다.
                             기본값은 로그 파일에 추가하지 않는 것입니다.
                         Encoding--파일의 인코딩을 지정합니다
@@ -935,7 +1006,7 @@
         <target state="translated">  -nodeReuse:&lt;parameters&gt;
                      MSBuild 노드를 다시 사용하거나 다시 사용하지 않도록 설정합니다.
                      매개 변수는 다음가 같습니다.
-                     True --빌드 완료 후 노드가 유지되고
+                     True --빌드 완료 후 노드가 유지되고 
                             후속 빌드에서 다시 사용됩니다(기본값).
                      False--빌드 완료 후 노드가 유지되지 않습니다.
                      (약식: -nr)
@@ -1032,7 +1103,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: 프로젝트 격리 값이 유효하지 않습니다. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: 프로젝트 격리 값이 유효하지 않습니다. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1299,6 +1370,60 @@
         <target state="translated">프로세스 = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: 프로젝트 파일이 없습니다.</target>
@@ -1344,6 +1469,22 @@
         <target state="translated">'{0}'은(는) '{1}'에서 제공되었습니다.</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1405,6 +1546,11 @@
         <target state="translated">MSBUILD : error MSB1015: 이 운영 체제 버전에서는 MSBuild를 실행할 수 없습니다. MSBuild는 Windows 7 이상의 버전에서만 지원됩니다.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">MSBUILDOLDOM=1이므로 Microsoft.Build.Engine을 강제로 로드하는 중...</target>
@@ -1701,10 +1847,10 @@
     </source>
         <target state="translated">  -restore[:True|False]
                      다른 대상을 빌드하기 전에 Restore라는 대상을
-                     실행하고 이러한 대상의 빌드에 최신 복원된
-                     빌드 논리가 사용되는지 확인합니다.
-                     프로젝트 트리를 빌드하기 전에
-                     프로젝트 트리에서 패키지를 복원해야 하는
+                     실행하고 이러한 대상의 빌드에 최신 복원된 
+                     빌드 논리가 사용되는지 확인합니다. 
+                     프로젝트 트리를 빌드하기 전에 
+                     프로젝트 트리에서 패키지를 복원해야 하는 
                      경우에 유용합니다. -restore를 지정하는 것은
                      -restore:True를 지정하는 것과 동일합니다. 이 매개 변수를 사용하여
                      지시 파일에서 가져오는 값을 재정의할 수 있습니다.
@@ -1742,7 +1888,7 @@
     </source>
         <target state="translated">  -profileEvaluation:&lt;file&gt;
                      MSBuild 평가를 프로파일링하고 결과를 지정된 파일에 기록합니다.
-                     지정된 파일의 확장명이 '.md'이면
+                     지정된 파일의 확장명이 '.md'이면 
                      결과가 Markdown 형식으로 생성됩니다.
                      그렇지 않으면 탭으로 구분된 파일이 생성됩니다.
     </target>
@@ -1761,9 +1907,9 @@
                        -restoreProperty:IsRestore=true;MyProperty=value
     </source>
         <target state="translated">  -restoreProperty:&lt;n&gt;=&lt;v&gt;
-                     복원하는 동안 프로젝트 수준 속성만 설정하거나
-                     재정의하고, -property 인수로 지정된 속성을
-                     사용하지 않습니다. &lt;n&gt;은 속성 이름이고
+                     복원하는 동안 프로젝트 수준 속성만 설정하거나 
+                     재정의하고, -property 인수로 지정된 속성을 
+                     사용하지 않습니다. &lt;n&gt;은 속성 이름이고 
                      &lt;v&gt;는 속성 값입니다.
                      세미콜론 또는 쉼표를 사용하여 여러 속성을 구분하거나,
                      각 속성을 개별적으로 지정합니다.
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index acd8432703f..84f60d00097 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: przełącznika -noAutoResponse nie można określić w pliku autoodpowiedzi MSBuild.rsp ani w żadnym pliku odpowiedzi, do którego odwołuje się plik autoodpowiedzi.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -122,7 +187,7 @@
                      interakcyjność nie jest oczekiwana.
                      Podanie parametru -interactive jest równoznaczne
                      z podaniem parametru -interactive:true. Użyj tego
-                     parametru, aby przesłonić wartość pochodzącą z pliku
+                     parametru, aby przesłonić wartość pochodzącą z pliku 
                      odpowiedzi.
     </target>
         <note>
@@ -151,19 +216,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Powoduje, że program MSBuild kompiluje każdy projekt
-                     w sposób izolowany.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Jest to bardziej restrykcyjny tryb programu MSBuild, ponieważ
-                     wymaga, aby graf projektu był statycznie wykrywalny podczas
-                     oceny, ale może usprawnić planowanie i zmniejszyć
-                     obciążenie pamięci podczas kompilowania dużego zestawu
-                     projektów.
-                     (Krótka wersja: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Ta flaga jest eksperymentalna i może nie działać w oczekiwany
-                     sposób.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -184,7 +255,7 @@
                      This flag is experimental and may not work as intended.
     </source>
         <target state="translated">  -graphBuild[:True|False]
-                     Powoduje, że program MSBuild tworzy i kompiluje graf
+                     Powoduje, że program MSBuild tworzy i kompiluje graf                 
                      projektu.
 
                      Tworzenie grafu obejmuje identyfikowanie odwołań do
@@ -272,8 +343,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -282,11 +352,10 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
- -warnNotAsError[:code[;code2]]
- Lista kodów ostrzeżeń, które mają być traktowane jako błędy.
- Rozdziel średnik lub przecinek
- wiele kodów ostrzeżeń. Nie ma żadnego efektu, jeśli przełącznik -warnaserror
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
                      switch is not set.
 
                      Example:
@@ -354,7 +423,7 @@
                      osobno.
 
                      Wszelkie pliki odpowiedzi o nazwie „msbuild.rsp” będą automatycznie
-                     wykorzystywane z następujących lokalizacji:
+                     wykorzystywane z następujących lokalizacji: 
                      (1) katalog programu msbuild.exe
                      (2) katalog pierwszej kompilacji projektu lub rozwiązania
 </target>
@@ -666,11 +735,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;plik pamięci podręcznej&gt;...
-                     Rozdzielana średnikami lista wejściowych plików pamięci podręcznej, z których program MSBuild
-                     będzie odczytywać wyniki kompilacji.
-                     Ustawienie tej opcji włącza też kompilacje izolowane (-isolate).
-                     (Krótka wersja: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -684,11 +752,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[plik pamięci podręcznej]
-                     Plik pamięci podręcznej, w którym program MSBuild zapisze zawartość
-                     swoich pamięci podręcznych wyników kompilacji po zakończeniu kompilacji.
-                     Ustawienie tej opcji włącza też kompilacje izolowane (-isolate).
-                     (Krótka wersja: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -906,7 +974,7 @@
                      Dostępne są parametry takie same, jak podane dla rejestratora
                      konsoli. Dostępne są również dodatkowe parametry:
                        LogFile — ścieżka do pliku dziennika, w którym będzie
-                                 zapisywany dziennik kompilacji.
+                                 zapisywany dziennik kompilacji. 
                        Append — określa, czy plik dziennika kompilacji zostanie
                                 dołączony do pliku dziennika, czy go zastąpi.
                                 Ustawienie tego przełącznika powoduje dołączenie dziennika kompilacji
@@ -920,8 +988,8 @@
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1044,7 +1112,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Wartość projektów izolacji jest nieprawidłowa. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Wartość projektów izolacji jest nieprawidłowa. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1311,6 +1379,60 @@
         <target state="translated">Proces = „{0}”</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: plik projektu nie istnieje.</target>
@@ -1356,6 +1478,22 @@
         <target state="translated">Element „{0}“ pochodzi z „{1}“</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1417,6 +1555,11 @@
         <target state="translated">MSBUILD : error MSB1015: Program MSBuild nie działa w tej wersji systemu operacyjnego. Jest obsługiwany tylko w systemie Windows 7 i nowszych wersjach.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Wymuszanie załadowania aparatu Microsoft.Build.Engine, ponieważ MSBUILDOLDOM=1...</target>
@@ -1713,10 +1856,10 @@ dzienników                     tekstowych i wykorzystać w innych narzędziach
     </source>
         <target state="translated">  -restore[:True|False]
                      Uruchamia element docelowy o nazwie Restore przed skompilowaniem
-                     innych elementów docelowych i zapewnia, że kompilacja tych
-                     elementów docelowych korzysta z najnowszej logiki przywróconej
-                     kompilacji. Jest to przydatne, gdy drzewo projektu wymaga
-                     przywrócenia pakietów przed ich skompilowaniem. Podanie parametru
+                     innych elementów docelowych i zapewnia, że kompilacja tych 
+                     elementów docelowych korzysta z najnowszej logiki przywróconej 
+                     kompilacji. Jest to przydatne, gdy drzewo projektu wymaga 
+                     przywrócenia pakietów przed ich skompilowaniem. Podanie parametru 
                      -restore jest równoznaczne z podaniem parametru -restore:True.
                      Za pomocą tego parametru można przesłonić wartość pochodzącą
                      z pliku odpowiedzi.
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 8ef4d8c30d2..1f855c1da7a 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: A opção /noAutoResponse não pode ser especificada no arquivo de resposta automática MSBuild.rsp nem em qualquer arquivo de resposta usado como referência para o arquivo de resposta automática.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -151,16 +216,25 @@ arquivo de resposta.
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Faz o MSBuild compilar cada projeto
-isoladamente.
-                     Esse é um modo mais restritivo do MSBuild, pois requer
-                     que o gráfico do projeto seja estatisticamente detectável no
-                     tempo de avaliação, mas pode melhorar o agendamento e reduzir
-                     a sobrecarga de memória ao compilar um grande conjunto de projetos.
-                     (Forma abreviada: -isolate)
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
+
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
 
-                     Esse sinalizador é experimental e pode não funcionar como pretendido.
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -266,8 +340,7 @@ isoladamente.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -276,14 +349,13 @@ isoladamente.
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     Lista de códigos de aviso para tratar e não tratar como erros.
-                     Use ponto e vírgula ou vírgula para separar
-                     vários códigos de aviso. Não tem efeito se o -warnaserror
-                     interruptor não está definido.
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
+                     switch is not set.
 
-                     Examplo:
+                     Example:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -618,10 +690,10 @@ isoladamente.
                      MSBuild will use up to the number of processors on the
                      computer. (Short form: -m[:n])
       </source>
-        <target state="translated">  -maxCpuCount[:n] Especifica o número máximo de processos simultâneos a serem
+        <target state="translated">  -maxCpuCount[:n] Especifica o número máximo de processos simultâneos a serem 
                      compilados. Se a opção não for usada, o valor padrão
                      usado será 1. Se a opção for usada sem um valor, o
-                     MSBuild usará o número de processadores do
+                     MSBuild usará o número de processadores do 
                      computador. (Forma abreviada: -m[:n])
       </target>
         <note>
@@ -639,7 +711,7 @@ isoladamente.
         <target state="translated">Exemplos:
 
         MSBuild MyApp.sln -t:Rebuild -p:Configuration=Release
-        MSBuild MyApp.csproj -t:Clean
+        MSBuild MyApp.csproj -t:Clean 
                              -p:Configuration=Debug;TargetFrameworkVersion=v3.5
     </target>
         <note>
@@ -657,11 +729,10 @@ isoladamente.
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Lista separada por ponto e vírgula de arquivos de cache de entrada dos quais o MSBuild
-                     lerá os resultados do build.
-                     A definição dessa opção também habilita os builds isolados (-isolate).
-                     (forma abreviada: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -675,11 +746,11 @@ isoladamente.
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     Arquivo de cache de saída no qual o MSBuild gravará o conteúdo
-                     dos caches de resultado do build no final do build.
-                     A configuração dessa opção também habilita builds isolado (-isolate).
-                     (forma abreviada: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -801,12 +872,12 @@ isoladamente.
                      10 file loggers to be attached. (Short form: -fl[n])
     </source>
         <target state="translated">  -fileLogger[n] Registra a saída do build em um arquivo. Por padrão,
-                     o arquivo está no diretório atual e tem o nome
+                     o arquivo está no diretório atual e tem o nome 
                      "msbuild[n].log". Os eventos de todos os nós são combinados em
                      um único log. A localização do arquivo e outros
-                     parâmetros do fileLogger pode ser especificada por meio
+                     parâmetros do fileLogger pode ser especificada por meio 
                      do acréscimo da opção "-fileLoggerParameters[n]".
-                     "n", se presente, pode ser um dígito de 1 a 9, permitindo que até
+                     "n", se presente, pode ser um dígito de 1 a 9, permitindo que até 
                      10 agentes de arquivo sejam anexados. (Forma abreviada: -fl[n])
     </target>
         <note>
@@ -959,14 +1030,14 @@ isoladamente.
                      Example:
                        -pp:out.txt
     </source>
-        <target state="translated">  -preprocess[:arquivo]
+        <target state="translated">  -preprocess[:arquivo] 
                      Cria um arquivo de projeto único e agregado
                      embutindo todos os arquivos que poderiam ser importados durante um
                      build, com seus limites marcados. Isso pode ser
                      útil para descobrir quais arquivos são importados,
                      de qual localização e como contribuirão para
                      o build. Por padrão, a saída é gravada na
-                     janela do console. Se o caminho de um arquivo de saída
+                     janela do console. Se o caminho de um arquivo de saída 
                      for fornecido, ele será usado.
                      (Forma abreviada: -pp)
                      Exemplo:
@@ -1033,7 +1104,7 @@ isoladamente.
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: O valor de projetos isolados não é válido. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: O valor de projetos isolados não é válido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1300,6 +1371,60 @@ isoladamente.
         <target state="translated">Processo = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Arquivo de projeto não existe.</target>
@@ -1345,6 +1470,22 @@ isoladamente.
         <target state="translated">'{0}' proveniente de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1406,6 +1547,11 @@ isoladamente.
         <target state="translated">MSBUILD : error MSB1015: O MSBuild não é executado nesta versão do sistema operacional. É suportado apenas no Windows 7 e em versões posteriores.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Forçando carregamento do Microsoft.Build.Engine porque MSBUILDOLDOM=1...</target>
@@ -1547,7 +1693,7 @@ isoladamente.
                        -warnAsError:MSB4130
 
                      Quando um aviso for tratado como um erro, o destino continuará
-                     a ser executado como se ele fosse um aviso, mas o
+                     a ser executado como se ele fosse um aviso, mas o 
                      build geral falhará.
     </target>
         <note>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 252b68b4885..13abe205358 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: ключ noAutoResponse не может быть указан в файле автоответа MSBuild.rsp или в любом другом файле ответа, на который файл автоответа ссылается.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -149,16 +214,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     Сообщает MSBuild, что нужно собирать каждый проект по отдельности.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Это более строгий режим MSBuild, так как он требует,
-                     чтобы граф проекта можно было статически обнаружить
-                     во время оценки, но он может улучшить планирование и сократить
-                     издержки памяти при сборке больших наборов проектов.
-                     (Краткая форма: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Это экспериментальный флаг. Может работать не так, как ожидалось.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -264,8 +338,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -274,14 +347,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     Список кодов предупреждений, которые не будут рассматриваться как ошибки.
-                     Используйте точку с запятой или запятую для разделения
-                     нескольких кодов предупреждения. Не действует, если параметр -warnaserror
-                     не задан.
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
+                     switch is not set.
 
-                     Пример:
+                     Example:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -655,11 +727,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;файл_кэша&gt;...
-                     Разделенный точкам с запятой список входных файлов кэша, откуда MSBuild
-                     будет считывать результаты.
-                     Задание этого параметра также включает изолированные сборки (-isolate).
-                     (Краткая форма: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -673,11 +744,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[файл_кэша]
-                     Выходной файл кэша, где MSBuild будет записывать содержимое
-                     результата кэша сборки в конце.
-                     При задании этого параметра также включаются изолированные сборки (-isolate).
-                     (Краткая форма: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -1031,7 +1102,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: значение изолирования проектов является недопустимым. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: значение изолирования проектов является недопустимым. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1298,6 +1369,60 @@
         <target state="translated">Процесс = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: файл проекта не существует.</target>
@@ -1343,6 +1468,22 @@
         <target state="translated">\"{0}\" получен из \"{1}\"</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1404,6 +1545,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild не работает в этой версии операционной системы. Он поддерживается только в Windows 7, Windows XP и более поздних версиях.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">Принудительная загрузка Microsoft.Build.Engine перед MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 4ff9206f999..5a5898a92c8 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse anahtarı, MSBuild.rsp otomatik yanıt dosyasında ve bu dosyanın başvuruda bulunduğu herhangi bir yanıt dosyasında belirtilemez.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -120,7 +185,7 @@
                      izin verildiğini gösterir.  Etkileşimin beklenmediği
                      otomatik bir senaryoda bu bağımsız değişkeni
                      kullanmayın.
-                     -interactive değerinin belirtilmesi, -interactive:true
+                     -interactive değerinin belirtilmesi, -interactive:true 
                      değerinin belirtilmesiyle aynıdır.  Parametreyi, yanıt
                      dosyasından gelen bir değeri geçersiz kılmak için kullanın.
     </target>
@@ -150,16 +215,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     MSBuild tarafından her projenin yalıtılmış olarak oluşturulmasına yol açar.
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     Bu mod, değerlendirme sırasında proje grafiğinin
-                     istatistiksel olarak keşfedilebilmesini gerektirdiğinden
-                     nispeten daha kısıtlayıcı bir MSBuild modudur, ancak çok sayıda
-                     proje oluşturulurken zamanlamayı geliştirebilir ve bellek ek yükünü azaltabilir.
-                     (Kısa biçim: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     Bu bayrak deneme amaçlıdır ve amaçlandığı gibi çalışmayabilir.
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -265,8 +339,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -275,14 +348,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
--warnNotAsError[:code[;code2]]
-                     Hata olarak kabul edilmeyen uyarı kodlarının listesi.
-                     Ayırmak için noktalı virgül veya virgül kullanın
-                    çoklu uyarı kodları -warnaserror ise hiçbir etkisi yoktur
-                     anahtarı ayarlanmadı.
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
+                     switch is not set.
 
-Örnek:
+                     Example:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -406,7 +478,7 @@
                      Example:
                        -property:WarningLevel=2;OutDir=bin\Debug\
 </source>
-        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Bu proje düzeyi özellikleri ayarlayın veya geçersiz kılın. &lt;n&gt;
+        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Bu proje düzeyi özellikleri ayarlayın veya geçersiz kılın. &lt;n&gt; 
                      özelliğin adı ve &lt;v&gt; özelliğin değeridir. Birden çok
                      özelliği birbirinden ayırmak için noktalı virgül veya virgül
                      kullanın veya her özelliği ayrı ayrı belirtin. (Kısa biçim: -p)
@@ -447,7 +519,7 @@
                      &lt;günlükçü derlemesi&gt; söz dizimi şöyledir:
                        {&lt;derleme adı&gt;[,&lt;strong name&gt;] | &lt;derleme dosyası&gt;}
                      Günlükçü seçenekleri, MSBuild'in günlükçüyü oluşturma biçimini belirtir.
-                     &lt;günlükçü parametreleri &gt; isteğe bağlıdır ve tam olarak
+                     &lt;günlükçü parametreleri &gt; isteğe bağlıdır ve tam olarak 
                      yazdığınız şekliyle günlükçüye geçirilir. (Kısa biçim: -l)
                      Örnekler:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -656,11 +728,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;önbellekDosyası&gt;...
-                     MSBuild'in derleme sonuçlarını okuyacağı giriş
-                     önbellek dosyalarının noktalı virgülle ayrılmış listesi.
-                     Ayarlandığında yalıtılmış derlemeler de açılır (-isolate).
-                     (kısa biçim: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,11 +745,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[önbellekDosyası]
-                     MSBuild’in derleme sonunda derleme sonucu önbelleklerinin
-                     içeriğini yazacağı çıkış önbellek dosyası.
-                     Bu açıldığında yalıtılmış derlemeler (-isolate) de açılır.
-                     (kısa biçim: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -747,9 +818,9 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;uzantılar&gt;
-                     Hangi proje dosyasının oluşturulacağı belirlenirken
-                     yoksayılacak uzantıların listesi. Birden çok uzantıyı
-                     birbirinden ayırmak için noktalı virgül veya
+                     Hangi proje dosyasının oluşturulacağı belirlenirken 
+                     yoksayılacak uzantıların listesi. Birden çok uzantıyı 
+                     birbirinden ayırmak için noktalı virgül veya 
                      virgül kullanın.
                      (Kısa biçim: -ignore)
                      Örnek:
@@ -775,8 +846,8 @@
    </source>
         <target state="translated">  -toolsVersion:&lt;sürüm&gt;
                      Derleme sırasında kullanılacak MSBuild Araç Kümesinin
-                     (görevler, hedefler vb.) sürümü. Bu sürüm, tek tek projelerde
-                     belirtilen sürümleri geçersiz kılar. (Kısa biçim:
+                     (görevler, hedefler vb.) sürümü. Bu sürüm, tek tek projelerde 
+                     belirtilen sürümleri geçersiz kılar. (Kısa biçim: 
                      -tv)
                      Örnek:
                        -toolsVersion:3.5
@@ -835,14 +906,14 @@
         <target state="translated">  -distributedFileLogger
                      Derleme çıkışını, her MSBuild düğümü için bir günlük
                      dosyası olmak üzere birden çok günlük dosyasına kaydeder. Bu
-                     dosyaların ilk konumu geçerli dizindir. Dosyaların
-                     varsayılan adı "MSBuild&lt;düğümkimliği&gt;.log"dur.
-                     Dosyaların konumu ve fileLogger'ın diğer parametreleri
+                     dosyaların ilk konumu geçerli dizindir. Dosyaların 
+                     varsayılan adı "MSBuild&lt;düğümkimliği&gt;.log"dur. 
+                     Dosyaların konumu ve fileLogger'ın diğer parametreleri 
                      "/fileLoggerParameters" anahtarının eklenmesi yoluyla
                      belirtilebilir.
 
                      Günlük dosyası adı fileLoggerParameters anahtarı
-                     aracılığıyla ayarlanırsa dağıtılmış günlükçü fileName
+                     aracılığıyla ayarlanırsa dağıtılmış günlükçü fileName 
                      değerini şablon olarak kullanıp her düğümün günlük dosyasını
                      oluşturmak için bu fileName değerine düğüm kimliğini ekler.
     </target>
@@ -887,32 +958,32 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parametreler&gt;
                      Dosya günlükçüleri için ek parametreler sağlar.
-                     Bu anahtarın olması karşılık gelen -fileLogger[n]
+                     Bu anahtarın olması karşılık gelen -fileLogger[n] 
                      anahtarının olduğu anlamına gelir.
                      "n" varsa, 1-9 arasında bir rakam olabilir.
-                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters
-                     bunlar tarafından da kullanılır; -distributedFileLogger
+                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters 
+                     bunlar tarafından da kullanılır; -distributedFileLogger 
                      açıklamasına bakın.
                      (Kısa biçim: -flp[n])
-                     Konsol günlükçüsü için listelenenlerle aynı parametreler
+                     Konsol günlükçüsü için listelenenlerle aynı parametreler 
                      kullanılabilir. Kullanılabilecek bazı ek parametreler:
-                        LogFile--Oluşturma günlüğünün yazılacağı günlük
+                        LogFile--Oluşturma günlüğünün yazılacağı günlük 
                             dosyasının yolu.
-                        Append--Derleme günlüğünün gün dosyasının sonuna mı
-                            ekleneceğini yoksa üzerine mi yazılacağını
-                            belirler. Anahtar ayarlandığında oluşturma günlüğü
-                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında
-                            varolan günlük dosyasının üzerine yazılır.
+                        Append--Derleme günlüğünün gün dosyasının sonuna mı 
+                            ekleneceğini yoksa üzerine mi yazılacağını 
+                            belirler. Anahtar ayarlandığında oluşturma günlüğü 
+                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında 
+                            varolan günlük dosyasının üzerine yazılır. 
                             Varsayılan: günlük dosyasının sonuna eklenmez.
-                        Encoding--Dosyanın kodlamasını belirtir; örneğin,
+                        Encoding--Dosyanın kodlamasını belirtir; örneğin, 
                             UTF-8, Unicode veya ASCII
                      Varsayılan ayrıntı düzeyi ayarı Detailed'dır.
                      Örnekler:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1036,7 +1107,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: Projeleri yalıtma değeri geçerli değil. {0}</target>
+        <target state="translated">MSBUILD : error MSB1056: Projeleri yalıtma değeri geçerli değil. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1303,6 +1374,60 @@
         <target state="translated">İşlem = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Proje dosyası yok.</target>
@@ -1348,6 +1473,22 @@
         <target state="translated">'{0}', '{1}' kaynağından geldi</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1409,6 +1550,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild işletim sisteminin bu sürümünde çalışmaz. Yalnızca Windows 7 ve üzeri sürümlerde desteklenir.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">MSBUILDOLDOM=1 olduğundan Microsoft.Build.Engine yükleme zorlanıyor...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index a5ec18908f5..2a74fc95a16 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: 不能在 MSBuild.rsp 自动响应文件中或由该自动响应文件引用的任何响应文件中指定 -noAutoResponse 开关。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -150,16 +215,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     使 MSBuild 独立生成每个项目。
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     这是 MSBuild 更具限制性的模式，因为它要求
-                     可在评估时静态地发现项目
-                     关系图，但可在生成大型项目集时
-                     改善计划并降低内存开销。
-                     (缩写: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     此标记处于试验阶段，可能无法按预期工作。
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -265,8 +339,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -275,14 +348,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     不视为错误的警告代码列表.
-                     使用分号或逗号分隔
-                     多个警告代码。如果未设置 -warnaserror
-                     开关，则不会产生任何影响。
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
+                     switch is not set.
 
-                     示例:
+                     Example:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -593,10 +665,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate     依据默认架构验证项目。(缩写:
+        <target state="translated">  -validate     依据默认架构验证项目。(缩写: 
            -val)
 
- -validate:&lt;schema&gt; 依据指定的架构验证项目。(缩写:
+ -validate:&lt;schema&gt; 依据指定的架构验证项目。(缩写: 
            -val)
            示例:
             -validate:MyExtendedBuildSchema.xsd
@@ -656,11 +728,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     输入缓存文件的分号分隔列表，MSBuild
-                     将从这些文件中读取生成结果。
-                     设置此列表还将打开分隔的生成(-isolate)。
-                     (缩写: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,10 +745,10 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     输出缓存文件，MSBuild 将在
-                     生成结束时写入其生成结果缓存的内容。
-                     设置它也会打开隔离的生成 (-isolate).
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </target>
         <note>
@@ -775,7 +846,7 @@
         <target state="translated">  -toolsversion:&lt;version&gt;
            要在生成过程中使用的 MSBuild 工具集
            (任务、目标等)的版本。此版本将重写
-           各个项目指定的版本。(缩写:
+           各个项目指定的版本。(缩写: 
            -tv)
            示例:
             -toolsversion:3.5
@@ -831,17 +902,17 @@
                      template and append the node id to this fileName to
                      create a log file for each node.
     </source>
-        <target state="translated">  -distributedFileLogger
+        <target state="translated">  -distributedFileLogger                            
            将生成输出记录到多个日志文件，每个 MSBuild 节点
            一个日志文件。这些文件的初始位置为
            当前目录。默认情况下，这些文件名为
            “MSBuild&lt;nodeid&gt;.log”。可通过添加
-           “-fileLoggerParameters”开关来指定
+           “-fileLoggerParameters”开关来指定 
            这些文件的位置和 fileLogger 的其他参数。
 
            如果日志文件名是通过 fileLoggerParameters
            开关设置的，分布式记录器将使用 fileName 作为
-           模板并将节点 ID 附加到此 fileName
+           模板并将节点 ID 附加到此 fileName 
            以便为每个节点创建一个日志文件。
     </target>
         <note>
@@ -883,12 +954,12 @@
                        -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </source>
-        <target state="translated">  -fileloggerparameters[n]:&lt;parameters&gt;
+        <target state="translated">  -fileloggerparameters[n]:&lt;parameters&gt;                
            为文件记录器提供任何额外的参数。
            存在此开关意味着
            存在对应的 -filelogger[n] 开关。
           “n”(如果存在)可以为 1-9 的数字。
-           任何分布式文件记录器也可以使用
+           任何分布式文件记录器也可以使用 
            -fileloggerparameters，具体可参阅 -distributedFileLogger 的说明。
            (缩写: -flp[n])
            为控制台记录器列出的相同参数
@@ -908,8 +979,8 @@
             -fileLoggerParameters:LogFile=MyLog.log;Append;
                       Verbosity=diagnostic;Encoding=UTF-8
 
-            -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-            -flp1:warningsonly;logfile=msbuild.wrn
+            -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+            -flp1:warningsonly;logfile=msbuild.wrn 
             -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1032,7 +1103,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: 独立项目值无效。{0}</target>
+        <target state="translated">MSBUILD : error MSB1056: 独立项目值无效。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1299,6 +1370,60 @@
         <target state="translated">进程 = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: 项目文件不存在。</target>
@@ -1344,6 +1469,22 @@
         <target state="translated">“{0}”来自“{1}”</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1405,6 +1546,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild 不在此版本操作系统上运行，而仅在 Windows 7 及更高版本的操作系统上受支持。</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">强制加载 Microsoft.Build.Engine，因为 MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 521bc7fb13b..4f16c88f306 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -9,6 +9,50 @@
       project or solution file in the current directory by looking for *.*PROJ and *.SLN. If more than one file is found that matches this wildcard, we
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="new">Build {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="new">failed</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with errors</source>
+        <target state="new">failed with errors</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with warnings</source>
+        <target state="new">failed with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="new">succeeded</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with warnings</source>
+        <target state="new">succeeded with warnings</target>
+        <note>
+      Part of Live Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
       </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
@@ -28,6 +72,27 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse 參數不能在 MSBuild.rsp 自動回應檔中指定，也不能在自動回應檔所參考的任何回應檔中指定。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="HelpMessage_41_QuestionSwitch">
+        <source>  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </source>
+        <target state="new">  -question
+                     (Experimental) Question whether there is any build work.
+                     MSBuild will error out when it detects a target or task
+                     that can be incremental (has inputs and outputs),
+                     but isn't up to date.
+                     (Short form: -q)
+    </target>
+        <note>
+      LOCALIZATION: "MSBuild" should not be localized.
+      LOCALIZATION: "-question" and "-q" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="new">MSBuild version {0} for {1}</target>
@@ -150,16 +215,25 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="needs-review-translation">  -isolateProjects[:True|False]
-                     引發 MSBuild 獨立建置各個專案。
+        <target state="new">  -isolateProjects[:True|MessageUponIsolationViolation|False]
+                     Causes MSBuild to build each project in isolation.
 
-                     這是限制度較高的 MSBuild 模式，因為
-                     專案圖形會需要在評估階段可供靜態探索，
-                     但能在建置一組大量專案時改善排程
-                     及降低記憶體額外負荷。
-                     (簡短形式: -isolate)
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
 
-                     這是實驗性的旗標，運作情形可能不如預期。
+                     This is a more restrictive mode of MSBuild as it requires
+                     that the project graph be statically discoverable at
+                     evaluation time, but can improve scheduling and reduce
+                     memory overhead when building a large set of projects.
+                     (Short form: -isolate)
+
+                     This flag is experimental and may not work as intended.
     </target>
         <note>
       LOCALIZATION: "MSBuild" should not be localized.
@@ -265,8 +339,7 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_40_WarnNotAsErrorSwitch">
-        <source>
-      -warnNotAsError[:code[;code2]]
+        <source>  -warnNotAsError[:code[;code2]]
                      List of warning codes to treats not treat as errors.
                      Use a semicolon or a comma to separate
                      multiple warning codes. Has no effect if the -warnaserror
@@ -275,14 +348,13 @@
                      Example:
                        -warnNotAsError:MSB3026
     </source>
-        <target state="translated">
-      -warnNotAsError[:code[;code2]]
-                     要視為不視為錯誤的警告碼清單。
-                     使用分號或逗號分隔
-                     多個警告碼。如果 -warnaserror 沒有作用
-                     未設定切換參數。
+        <target state="new">  -warnNotAsError[:code[;code2]]
+                     List of warning codes to treats not treat as errors.
+                     Use a semicolon or a comma to separate
+                     multiple warning codes. Has no effect if the -warnaserror
+                     switch is not set.
 
-範例:
+                     Example:
                        -warnNotAsError:MSB3026
     </target>
         <note>
@@ -656,11 +728,10 @@
                      will read build results from. If -isolateProjects is set
                      to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="needs-review-translation">  -inputResultsCaches:&lt;快取檔案&gt;...
-                     以分號分隔的輸入快取檔案
-                      (MSBuild 將會從此檔案讀取建置結果) 清單。
-                     設定此項目也會開啟隔離式建置 (-isolate)。
-                     (簡短形式: -irc)
+        <target state="new">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     Semicolon separated list of input cache files that MSBuild
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -674,11 +745,11 @@
                      If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
-                     MSBuild 要在組建結束時寫入
-                     其組建結果快取內容的目標輸出快取檔案。
-                     設定此項也會開啟隔離組建 (-isolate)。
-                     (簡短格式: -orc)
+        <target state="new">  -outputResultsCache:[cacheFile]
+                     Output cache file where MSBuild will write the contents of
+                     its build result caches at the end of the build.
+                     If -isolateProjects is set to False, this sets it to True.
+                     (short form: -orc)
    </target>
         <note>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -774,8 +845,8 @@
    </source>
         <target state="translated">  -toolsversion:&lt;版本&gt;
                      建置期間所使用的 MSBuild 工具組 (工作、目標等)
-                      版本。此版本將會覆寫
-                     個別專案所指定的版本。(簡短形式:
+                      版本。此版本將會覆寫 
+                     個別專案所指定的版本。(簡短形式: 
                      -tv)
                      範例:
                        -toolsVersion:3.5
@@ -1032,7 +1103,7 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="needs-review-translation">MSBUILD : error MSB1056: 獨立式專案值無效。{0}</target>
+        <target state="translated">MSBUILD : error MSB1056: 獨立式專案值無效。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1299,6 +1370,60 @@
         <target state="translated">流程 = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectBuilding_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project building.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectBuilding_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project building including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: target
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="new">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="new"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="new">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: 專案檔不存在。</target>
@@ -1344,6 +1469,22 @@
         <target state="translated">'{0}' 來自 '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="new">Restore complete ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="new">Restore {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
@@ -1405,6 +1546,11 @@
         <target state="translated">MSBUILD : error MSB1015: MSBuild 不會在此版本的作業系統上執行。只有在 Windows 7 及更新版本才受支援。</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="UnsupportedSwitchForSolutionFiles">
+        <source>The '{0}' switch is not supported for solution files.</source>
+        <target state="new">The '{0}' switch is not supported for solution files.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Using35Engine">
         <source>Forcing load of Microsoft.Build.Engine because MSBUILDOLDOM=1...</source>
         <target state="translated">正在強制載入 Microsoft.Build.Engine，因為 MSBUILDOLDOM=1...</target>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 30526f4edfd..91e97d0a5d6 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -34,6 +34,7 @@
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
+using LiveLogger = Microsoft.Build.Logging.LiveLogger.LiveLogger;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Experimental;
@@ -709,6 +710,7 @@ public static ExitType Execute(
                 bool lowPriority = false;
                 string[] inputResultsCaches = null;
                 string outputResultsCache = null;
+                bool question = false;
 
                 GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile, out _);
                 bool buildCanBeInvoked = ProcessCommandLineSwitches(
@@ -744,6 +746,7 @@ public static ExitType Execute(
                                             ref inputResultsCaches,
                                             ref outputResultsCache,
                                             ref lowPriority,
+                                            ref question,
                                             recursing: false,
 #if FEATURE_GET_COMMANDLINE
                                             commandLine);
@@ -761,10 +764,13 @@ public static ExitType Execute(
                     // Only display the message if /m isn't provided
                     if (cpuCount == 1 && FileUtilities.IsSolutionFilename(projectFile) && verbosity > LoggerVerbosity.Minimal
                         && switchesNotFromAutoResponseFile[CommandLineSwitches.ParameterizedSwitch.MaxCPUCount].Length == 0
-                        && switchesFromAutoResponseFile[CommandLineSwitches.ParameterizedSwitch.MaxCPUCount].Length == 0)
+                        && switchesFromAutoResponseFile[CommandLineSwitches.ParameterizedSwitch.MaxCPUCount].Length == 0
+                        && preprocessWriter != null
+                        && targetsWriter != null)
                     {
                         Console.WriteLine(ResourceUtilities.GetResourceString("PossiblyOmittedMaxCPUSwitch"));
                     }
+
                     if (preprocessWriter != null && !BuildEnvironmentHelper.Instance.RunningTests)
                     {
                         // Indicate to the engine that it can NOT toss extraneous file content: we want to
@@ -811,6 +817,7 @@ public static ExitType Execute(
                                     isolateProjects,
                                     graphBuildOptions,
                                     lowPriority,
+                                    question,
                                     inputResultsCaches,
                                     outputResultsCache,
                                     commandLine))
@@ -964,6 +971,8 @@ public static ExitType Execute(
                 // Wait for any pending cancel, so that we get any remaining messages
                 s_cancelComplete.WaitOne();
 
+                NativeMethodsShared.RestoreConsoleMode(s_originalConsoleMode);
+
 #if FEATURE_GET_COMMANDLINE
                 MSBuildEventSource.Log.MSBuildExeStop(commandLine);
 #else
@@ -1089,7 +1098,12 @@ private static void ResetGatheringSwitchesState()
         /// <summary>
         /// List of messages to be sent to the logger when it is attached
         /// </summary>
-        private static List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
+        private static readonly List<BuildManager.DeferredBuildMessage> s_globalMessagesToLogInBuildLoggers = new();
+
+        /// <summary>
+        /// The original console output mode if we changed it as part of initialization.
+        /// </summary>
+        private static uint? s_originalConsoleMode = null;
 
         /// <summary>
         /// Initializes the build engine, and starts the project building.
@@ -1124,6 +1138,7 @@ internal static bool BuildProject(
             ProjectIsolationMode isolateProjects,
             GraphBuildOptions graphBuildOptions,
             bool lowPriority,
+            bool question,
             string[] inputResultsCaches,
             string outputResultsCache,
 #if FEATURE_GET_COMMANDLINE
@@ -1210,8 +1225,8 @@ internal static bool BuildProject(
 
                 ToolsetDefinitionLocations toolsetDefinitionLocations = ToolsetDefinitionLocations.Default;
 
-                bool preprocessOnly = preprocessWriter != null && !FileUtilities.IsSolutionFilename(projectFile);
-                bool targetsOnly = targetsWriter != null && !FileUtilities.IsSolutionFilename(projectFile);
+                bool isPreprocess = preprocessWriter != null;
+                bool isTargets = targetsWriter != null;
 
                 projectCollection = new ProjectCollection(
                     globalProperties,
@@ -1220,7 +1235,7 @@ internal static bool BuildProject(
                     toolsetDefinitionLocations,
                     cpuCount,
                     onlyLogCriticalEvents,
-                    loadProjectsReadOnly: !preprocessOnly,
+                    loadProjectsReadOnly: !isPreprocess,
                     useAsynchronousLogging: true,
                     reuseProjectRootElementCache: s_isServerNode);
 
@@ -1229,9 +1244,11 @@ internal static bool BuildProject(
                     ThrowInvalidToolsVersionInitializationException(projectCollection.Toolsets, toolsVersion);
                 }
 
+                bool isSolution = FileUtilities.IsSolutionFilename(projectFile);
+
 #if FEATURE_XML_SCHEMA_VALIDATION
                 // If the user has requested that the schema be validated, do that here.
-                if (needToValidateProject && !FileUtilities.IsSolutionFilename(projectFile))
+                if (needToValidateProject && !isSolution)
                 {
                     Microsoft.Build.Evaluation.Project project = projectCollection.LoadProject(projectFile, globalProperties, toolsVersion);
                     Microsoft.Build.Evaluation.Toolset toolset = projectCollection.GetToolset(toolsVersion ?? project.ToolsVersion);
@@ -1249,22 +1266,41 @@ internal static bool BuildProject(
                 }
 #endif
 
-                if (preprocessOnly)
+                if (isPreprocess)
                 {
-                    Project project = projectCollection.LoadProject(projectFile, globalProperties, toolsVersion);
+                    // TODO: Support /preprocess for solution files. https://github.com/dotnet/msbuild/issues/7697
+                    if (isSolution)
+                    {
+                        Console.WriteLine(ResourceUtilities.GetResourceString("UnsupportedSwitchForSolutionFiles"), CommandLineSwitches.ParameterizedSwitch.Preprocess);
+                        success = false;
+                    }
+                    else
+                    {
+                        Project project = projectCollection.LoadProject(projectFile, globalProperties, toolsVersion);
 
-                    project.SaveLogicalProject(preprocessWriter);
+                        project.SaveLogicalProject(preprocessWriter);
 
-                    projectCollection.UnloadProject(project);
-                    success = true;
+                        projectCollection.UnloadProject(project);
+
+                        success = true;
+                    }
                 }
 
-                if (targetsOnly)
+                if (isTargets)
                 {
-                    success = PrintTargets(projectFile, toolsVersion, globalProperties, targetsWriter, projectCollection);
+                    // TODO: Support /targets for solution files. https://github.com/dotnet/msbuild/issues/7697
+                    if (isSolution)
+                    {
+                        Console.WriteLine(ResourceUtilities.GetResourceString("UnsupportedSwitchForSolutionFiles"), CommandLineSwitches.ParameterizedSwitch.Targets);
+                        success = false;
+                    }
+                    else
+                    {
+                        success = PrintTargets(projectFile, toolsVersion, globalProperties, targetsWriter, projectCollection);
+                    }
                 }
 
-                if (!preprocessOnly && !targetsOnly)
+                if (!isPreprocess && !isTargets)
                 {
                     BuildParameters parameters = new BuildParameters(projectCollection);
 
@@ -1295,6 +1331,7 @@ internal static bool BuildProject(
                     parameters.ProjectIsolationMode = isolateProjects;
                     parameters.InputResultsCacheFiles = inputResultsCaches;
                     parameters.OutputResultsCacheFile = outputResultsCache;
+                    parameters.Question = question;
 
                     // Propagate the profiler flag into the project load settings so the evaluator
                     // can pick it up
@@ -1322,7 +1359,7 @@ internal static bool BuildProject(
                         }
                     }
 
-                    // List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = null;
+                    List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
 
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
 
@@ -1343,8 +1380,10 @@ internal static bool BuildProject(
                         {
                             messagesToLogInBuildLoggers.Add(
                                 new BuildManager.DeferredBuildMessage(
-                                    String.Format("Included response file: {0}", responseFilePath),
-                                    MessageImportance.Normal,
+                                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                                        "PickedUpSwitchesFromAutoResponse",
+                                        responseFilePath),
+                                    MessageImportance.Low,
                                     responseFilePath));
                         }
                     }
@@ -1503,7 +1542,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
 
         private static List<BuildManager.DeferredBuildMessage> GetMessagesToLogInBuildLoggers(string commandLineString)
         {
-            List<BuildManager.DeferredBuildMessage> messages = new()
+            List<BuildManager.DeferredBuildMessage> messages = new(s_globalMessagesToLogInBuildLoggers)
             {
                 new BuildManager.DeferredBuildMessage(
                     ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
@@ -2307,6 +2346,7 @@ private static bool ProcessCommandLineSwitches(
             ref string[] inputResultsCaches,
             ref string outputResultsCache,
             ref bool lowPriority,
+            ref bool question,
             bool recursing,
             string commandLine)
         {
@@ -2422,6 +2462,7 @@ private static bool ProcessCommandLineSwitches(
                                                            ref inputResultsCaches,
                                                            ref outputResultsCache,
                                                            ref lowPriority,
+                                                           ref question,
                                                            recursing: true,
                                                            commandLine);
                     }
@@ -2485,10 +2526,14 @@ private static bool ProcessCommandLineSwitches(
                         graphBuild = ProcessGraphBuildSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GraphBuild]);
                     }
 
+                    question = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Question);
+
                     inputResultsCaches = ProcessInputResultsCaches(commandLineSwitches);
 
                     outputResultsCache = ProcessOutputResultsCache(commandLineSwitches);
 
+                    bool liveLogger = ProcessLiveLoggerConfiguration(commandLineSwitches);
+
                     // figure out which loggers are going to listen to build events
                     string[][] groupedFileLoggerParameters = commandLineSwitches.GetFileLoggerParameters();
 
@@ -2498,7 +2543,7 @@ private static bool ProcessCommandLineSwitches(
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],
-                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.LiveLogger],
+                        liveLogger,
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],
@@ -2526,16 +2571,6 @@ private static bool ProcessCommandLineSwitches(
                         detailedSummary = true;
                     }
 
-                    // If we picked up switches from the autoresponse file, let the user know. This could be a useful
-                    // hint to a user that does not know that we are picking up the file automatically.
-                    // Since this is going to happen often in normal use, only log it in high verbosity mode.
-                    // Also, only log it to the console; logging to loggers would involve increasing the public API of
-                    // the Engine, and we don't want to do that.
-                    if (usingSwitchesFromAutoResponseFile && LoggerVerbosity.Diagnostic == verbosity)
-                    {
-                        Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("PickedUpSwitchesFromAutoResponse", autoResponseFileName));
-                    }
-
                     if (originalVerbosity == LoggerVerbosity.Diagnostic)
                     {
                         string equivalentCommandLine = commandLineSwitches.GetEquivalentCommandLineExceptProjectFile();
@@ -2565,6 +2600,75 @@ private static bool ProcessCommandLineSwitches(
             return invokeBuild;
         }
 
+        private static bool ProcessLiveLoggerConfiguration(CommandLineSwitches commandLineSwitches)
+        {
+            string liveLoggerArg;
+
+            // Command line wins, so check it first
+            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.LiveLogger))
+            {
+                // There's a switch set, but there might be more than one
+                string[] switches = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LiveLogger];
+
+                liveLoggerArg = switches[switches.Length - 1];
+
+                // if the switch was set but not to an explicit value, the value is "auto"
+                if (string.IsNullOrEmpty(liveLoggerArg))
+                {
+                    liveLoggerArg = "auto";
+                }
+            }
+            else
+            {
+                liveLoggerArg = Environment.GetEnvironmentVariable("MSBUILDLIVELOGGER");
+
+                if (string.IsNullOrWhiteSpace(liveLoggerArg))
+                {
+                    return false;
+                }
+                else
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage($"The environment variable MSBUILDLIVELOGGER was set to {liveLoggerArg}.", MessageImportance.Low));
+                }
+            }
+
+            // We now have a string. It can be "true" or "false" which means just that:
+            if (bool.TryParse(liveLoggerArg, out bool result))
+            {
+                return result;
+            }
+
+            // or it can be "auto", meaning "enable if we can"
+            if (!liveLoggerArg.Equals("auto", StringComparison.OrdinalIgnoreCase))
+            {
+                CommandLineSwitchException.Throw("InvalidLiveLoggerValue", liveLoggerArg);
+            }
+
+            return DoesEnvironmentSupportLiveLogger();
+
+            static bool DoesEnvironmentSupportLiveLogger()
+            {
+                (var acceptAnsiColorCodes, var outputIsScreen, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
+
+                if (!outputIsScreen)
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is being redirected to a file.", MessageImportance.Low));
+                    return false;
+                }
+
+                // LiveLogger is not used if the terminal does not support ANSI/VT100 escape sequences.
+                if (!acceptAnsiColorCodes)
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is not supported.", MessageImportance.Low));
+                    return false;
+                }
+                return true;
+            }
+        }
+
         private static CommandLineSwitches CombineSwitchesRespectingPriority(CommandLineSwitches switchesFromAutoResponseFile, CommandLineSwitches switchesNotFromAutoResponseFile, string commandLine)
         {
             // combine the auto-response file switches with the command line switches in a left-to-right manner, where the
@@ -3312,7 +3416,7 @@ private static ILogger[] ProcessLoggingSwitches(
             string[] verbositySwitchParameters,
             bool noConsoleLogger,
             bool distributedFileLogger,
-            bool liveLoggerCommandLineOptIn,
+            bool liveLoggerOptIn,
             string[] fileLoggerParameters,
             string[] consoleLoggerParameters,
             string[] binaryLoggerParameters,
@@ -3346,9 +3450,7 @@ private static ILogger[] ProcessLoggingSwitches(
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
 
             // Choose default console logger
-            if (
-                (liveLoggerCommandLineOptIn || Environment.GetEnvironmentVariable("MSBUILDFANCYLOGGER") == "true" || Environment.GetEnvironmentVariable("MSBUILDLIVELOGGER") == "true")
-                && DoesEnvironmentSupportLiveLogger())
+            if (liveLoggerOptIn)
             {
                 ProcessLiveLogger(noConsoleLogger, distributedLoggerRecords, cpuCount, loggers);
             }
@@ -3361,9 +3463,6 @@ private static ILogger[] ProcessLoggingSwitches(
 
             ProcessFileLoggers(groupedFileLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
 
-            // TOOD: Review
-            // ProcessLiveLogger(noConsoleLogger, loggers);
-
             verbosity = outVerbosity;
 
             profilerLogger = ProcessProfileEvaluationSwitch(profileEvaluationParameters, loggers, out enableProfiler);
@@ -3529,27 +3628,6 @@ internal static void ProcessConsoleLoggerSwitch(
             }
         }
 
-        private static bool DoesEnvironmentSupportLiveLogger()
-        {
-            // If output is redirected
-            if (Console.IsOutputRedirected)
-            {
-                messagesToLogInBuildLoggers.Add(
-                    new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is being redirected to a file.", MessageImportance.Low));
-                return false;
-            }
-            // If terminal is dumb
-            if (
-                (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && string.IsNullOrEmpty(Environment.GetEnvironmentVariable("WT_SESSION")))
-                || Environment.GetEnvironmentVariable("TERM") == "dumb")
-            {
-                messagesToLogInBuildLoggers.Add(
-                    new BuildManager.DeferredBuildMessage("LiveLogger was not used because the output is not supported.", MessageImportance.Low));
-                return false;
-            }
-            return true;
-        }
-
         private static void ProcessLiveLogger(
             bool noConsoleLogger,
             List<DistributedLoggerRecord> distributedLoggerRecords,
@@ -4137,6 +4215,7 @@ private static void ShowHelpMessage()
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_OutputCacheFile"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_36_GraphBuildSwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_39_LowPrioritySwitch"));
+            Console.WriteLine(AssemblyResources.GetString("HelpMessage_41_QuestionSwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_7_ResponseFile"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_8_NoAutoResponseSwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_5_NoLogoSwitch"));
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index a4c00b30b76..b2f5106d38d 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -599,7 +599,13 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA
 
                 MSBuildToolsDirectory32 = MSBuildToolsDirectoryRoot;
                 MSBuildToolsDirectory64 = existsCheck(potentialAmd64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "amd64") : CurrentMSBuildToolsDirectory;
+#if RUNTIME_TYPE_NETCORE
+                // Fall back to "current" for any architecture since .NET SDK doesn't
+                // support cross-arch task invocations.
+                MSBuildToolsDirectoryArm64 = existsCheck(potentialARM64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "arm64") : CurrentMSBuildToolsDirectory;
+#else
                 MSBuildToolsDirectoryArm64 = existsCheck(potentialARM64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "arm64") : null;
+#endif
             }
 
             MSBuildExtensionsPath = mode == BuildEnvironmentMode.VisualStudio
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 36613d4cd52..0da65b8a868 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -796,7 +796,7 @@ private struct RecursionState
             /// <summary>
             /// True if a SearchData.DirectoryPattern is specified but we have not descended into a matching directory.
             /// </summary>
-            public bool IsLookingForMatchingDirectory => (SearchData.DirectoryPattern != null && !IsInsideMatchingDirectory);
+            public readonly bool IsLookingForMatchingDirectory => (SearchData.DirectoryPattern != null && !IsInsideMatchingDirectory);
         }
 
         /// <summary>
diff --git a/src/Shared/FileSystem/WindowsNative.cs b/src/Shared/FileSystem/WindowsNative.cs
index 63640a185be..8df4a0b2a2c 100644
--- a/src/Shared/FileSystem/WindowsNative.cs
+++ b/src/Shared/FileSystem/WindowsNative.cs
@@ -141,7 +141,7 @@ public EnumerateDirectoryResult(string directory, EnumerateDirectoryStatus statu
             /// <summary>
             /// Indicates if enumeration succeeded.
             /// </summary>
-            public bool Succeeded
+            public readonly bool Succeeded
             {
                 get { return Status == EnumerateDirectoryStatus.Success; }
             }
@@ -153,7 +153,7 @@ public bool Succeeded
             /// <remarks>
             /// This is a good <c>default:</c> case when switching on every possible <see cref="EnumerateDirectoryStatus"/>
             /// </remarks>
-            public NativeWin32Exception ThrowForUnknownError()
+            public readonly NativeWin32Exception ThrowForUnknownError()
             {
                 Debug.Assert(Status == EnumerateDirectoryStatus.UnknownError);
                 throw CreateExceptionForError();
@@ -173,7 +173,7 @@ public NativeWin32Exception ThrowForKnownError()
             /// <summary>
             /// Creates (but does not throw) an exception for this result. The result must not be successful.
             /// </summary>
-            public NativeWin32Exception CreateExceptionForError()
+            public readonly NativeWin32Exception CreateExceptionForError()
             {
                 Debug.Assert(Status != EnumerateDirectoryStatus.Success);
                 if (Status == EnumerateDirectoryStatus.UnknownError)
diff --git a/src/Shared/LoadedType.cs b/src/Shared/LoadedType.cs
index 1ff1e5b762b..6b2f8aed5c8 100644
--- a/src/Shared/LoadedType.cs
+++ b/src/Shared/LoadedType.cs
@@ -42,8 +42,10 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade
             LoadedAssembly = loadedAssembly;
 
 #if !NET35
-            // Properties set in this block aren't used by TaskHosts. Properties below are only used on the NodeProvider side to get information about the
+            // This block is reflection only loaded type implementation. Net35 does not support it, and fall backs to former implementation in #else
+            // Property `Properties` set in this block aren't used by TaskHosts. Properties below are only used on the NodeProvider side to get information about the
             // properties and reflect over them without needing them to be fully loaded, so it also isn't need for TaskHosts.
+
             // MetadataLoadContext-loaded Type objects don't support testing for inherited attributes, so we manually walk the BaseType chain.
             Type t = type;
             while (t is not null)
@@ -104,6 +106,11 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loade
                     PropertyAssemblyQualifiedNames[i] = Properties[i].PropertyType.AssemblyQualifiedName;
                 }
             }
+#else
+            // For v3.5 fallback to old full type approach, as oppose to reflection only
+            HasLoadInSeparateAppDomainAttribute = this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */);
+            HasSTAThreadAttribute = this.Type.GetTypeInfo().IsDefined(typeof(RunInSTAAttribute), true /* inherited */);
+            IsMarshalByRef = this.Type.IsMarshalByRef;
 #endif
         }
 
diff --git a/src/Shared/Pair.cs b/src/Shared/Pair.cs
index 85e688acb50..ef5073b4835 100644
--- a/src/Shared/Pair.cs
+++ b/src/Shared/Pair.cs
@@ -44,7 +44,7 @@ public Pair(TKey key, TValue value)
         /// <summary>
         /// Key
         /// </summary>
-        internal TKey Key
+        internal readonly TKey Key
         {
             get { return _key; }
         }
@@ -52,7 +52,7 @@ internal TKey Key
         /// <summary>
         /// Value
         /// </summary>
-        internal TValue Value
+        internal readonly TValue Value
         {
             get { return _value; }
         }
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index 4a3faba5c34..226a7780017 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -19,7 +19,7 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal static class PlatformNegotiation
     {
-        internal static string GetNearestPlatform(string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, string platformLookupTable, string projectPath, string currentProjectPlatform, TaskLoggingHelper? log = null)
+        internal static string GetNearestPlatform(string overridePlatformValue, string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, string platformLookupTable, string projectPath, string currentProjectPlatform, TaskLoggingHelper? log = null)
         {
             Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(platformLookupTable, log);
 
@@ -41,9 +41,14 @@ internal static string GetNearestPlatform(string referencedProjectPlatform, stri
 
             string buildProjectReferenceAs = string.Empty;
 
+            // If an override value is set define that as the platform value as the top priority
+            if (!string.IsNullOrEmpty(overridePlatformValue))
+            {
+                buildProjectReferenceAs = overridePlatformValue;
+            }
             // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
             // Don't set `buildProjectReferenceAs` and the `_GetProjectReferencePlatformProperties` target will handle the rest.
-            if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(currentProjectPlatform, StringComparison.OrdinalIgnoreCase))
+            else if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(currentProjectPlatform, StringComparison.OrdinalIgnoreCase))
             {
                 log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", projectPath, referencedProjectPlatform);
             }
diff --git a/src/Shared/SolutionConfiguration.cs b/src/Shared/SolutionConfiguration.cs
new file mode 100644
index 00000000000..a271f2645f4
--- /dev/null
+++ b/src/Shared/SolutionConfiguration.cs
@@ -0,0 +1,137 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
+using System.IO;
+using System.Xml;
+
+namespace Microsoft.Build.Shared
+{
+    internal sealed class SolutionConfiguration
+    {
+        public const string ProjectAttribute = "Project";
+
+        public const string AbsolutePathAttribute = "AbsolutePath";
+
+        public const string BuildProjectInSolutionAttribute = "BuildProjectInSolution";
+
+        public static readonly char[] ConfigPlatformSeparator = { '|' };
+
+        // This field stores pre-cached project elements for project guids for quicker access by project guid
+        private readonly Dictionary<string, XmlElement> _cachedProjectElements = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
+
+        // This field stores pre-cached project elements for project guids for quicker access by project absolute path
+        private readonly Dictionary<string, XmlElement> _cachedProjectElementsByAbsolutePath = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
+
+        // This field stores the project absolute path for quicker access by project guid
+        private readonly Dictionary<string, string> _cachedProjectAbsolutePathsByGuid = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+
+        // This field stores the project guid for quicker access by project absolute path
+        private readonly Dictionary<string, string> _cachedProjectGuidsByAbsolutePath = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+
+        // This field stores the list of dependency project guids by depending project guid
+        private readonly Dictionary<string, List<string>> _cachedDependencyProjectGuidsByDependingProjectGuid = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
+
+        public SolutionConfiguration(string xmlString)
+        {
+            // Example:
+            //
+            // <SolutionConfiguration>
+            //  <ProjectConfiguration Project="{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}" AbsolutePath="c:foo\Project1\A.csproj" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
+            //  <ProjectConfiguration Project="{881C1674-4ECA-451D-85B6-D7C59B7F16FA}" AbsolutePath="c:foo\Project2\B.csproj" BuildProjectInSolution="True">Debug|AnyCPU<ProjectDependency Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" /></ProjectConfiguration>
+            //  <ProjectConfiguration Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" AbsolutePath="c:foo\Project3\C.csproj" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
+            // </SolutionConfiguration>
+            //
+            XmlNodeList? projectConfigurationElements = GetProjectConfigurations(xmlString);
+            if (projectConfigurationElements != null)
+            {
+                foreach (XmlElement xmlElement in projectConfigurationElements)
+                {
+                    string projectGuid = xmlElement.GetAttribute(ProjectAttribute);
+                    string projectAbsolutePath = xmlElement.GetAttribute(AbsolutePathAttribute);
+
+                    // What we really want here is the normalized path, like we'd get with an item's "FullPath" metadata.  However, 
+                    // if there's some bogus full path in the solution configuration (e.g. a website with a "full path" of c:\solutiondirectory\http://localhost) 
+                    // we do NOT want to throw -- chances are extremely high that that's information that will never actually be used.  So resolve the full path 
+                    // but just swallow any IO-related exceptions that result.  If the path is bogus, the method will return null, so we'll just quietly fail 
+                    // to cache it below. 
+                    projectAbsolutePath = FileUtilities.GetFullPathNoThrow(projectAbsolutePath);
+
+                    if (!string.IsNullOrEmpty(projectGuid))
+                    {
+                        _cachedProjectElements[projectGuid] = xmlElement;
+                        if (!string.IsNullOrEmpty(projectAbsolutePath))
+                        {
+                            _cachedProjectElementsByAbsolutePath[projectAbsolutePath] = xmlElement;
+                            _cachedProjectAbsolutePathsByGuid[projectGuid] = projectAbsolutePath;
+                            _cachedProjectGuidsByAbsolutePath[projectAbsolutePath] = projectGuid;
+                        }
+
+                        foreach (XmlNode dependencyNode in xmlElement.ChildNodes)
+                        {
+                            if (dependencyNode.NodeType != XmlNodeType.Element)
+                            {
+                                continue;
+                            }
+
+                            XmlElement dependencyElement = ((XmlElement)dependencyNode);
+
+                            if (!String.Equals(dependencyElement.Name, "ProjectDependency", StringComparison.Ordinal))
+                            {
+                                continue;
+                            }
+
+                            string dependencyGuid = dependencyElement.GetAttribute("Project");
+
+                            if (dependencyGuid.Length == 0)
+                            {
+                                continue;
+                            }
+
+                            if (!_cachedDependencyProjectGuidsByDependingProjectGuid.TryGetValue(projectGuid, out List<string>? list))
+                            {
+                                list = new List<string>();
+                                _cachedDependencyProjectGuidsByDependingProjectGuid.Add(projectGuid, list);
+                            }
+
+                            list.Add(dependencyGuid);
+                        }
+                    }
+                }
+            }
+        }
+
+        public static SolutionConfiguration Empty { get; } = new SolutionConfiguration(string.Empty);
+
+        public ICollection<XmlElement> ProjectConfigurations => _cachedProjectElements.Values;
+
+        public static XmlNodeList? GetProjectConfigurations(string xmlString)
+        {
+            XmlDocument? doc = null;
+
+            if (!string.IsNullOrEmpty(xmlString))
+            {
+                doc = new XmlDocument();
+                var settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+                using (XmlReader reader = XmlReader.Create(new StringReader(xmlString), settings))
+                {
+                    doc.Load(reader);
+                }
+            }
+
+            return doc?.DocumentElement?.ChildNodes;
+        }
+
+        public bool TryGetProjectByGuid(string projectGuid, [NotNullWhen(true)] out XmlElement? projectElement) => _cachedProjectElements.TryGetValue(projectGuid, out projectElement);
+
+        public bool TryGetProjectByAbsolutePath(string projectFullPath, [NotNullWhen(true)] out XmlElement? projectElement) => _cachedProjectElementsByAbsolutePath.TryGetValue(projectFullPath, out projectElement);
+
+        public bool TryGetProjectGuidByAbsolutePath(string projectFullPath, [NotNullWhen(true)] out string? projectGuid) => _cachedProjectGuidsByAbsolutePath.TryGetValue(projectFullPath, out projectGuid);
+
+        public bool TryGetProjectDependencies(string projectGuid, [NotNullWhen(true)] out List<string>? dependencyProjectGuids) => _cachedDependencyProjectGuidsByDependingProjectGuid.TryGetValue(projectGuid, out dependencyProjectGuids);
+
+        public bool TryGetProjectPathByGuid(string projectGuid, [NotNullWhen(true)] out string? projectPath) => _cachedProjectAbsolutePathsByGuid.TryGetValue(projectGuid, out projectPath);
+    }
+}
diff --git a/src/Shared/StringExtensions.cs b/src/Shared/StringExtensions.cs
index 40485f659b3..4fcf361bac8 100644
--- a/src/Shared/StringExtensions.cs
+++ b/src/Shared/StringExtensions.cs
@@ -2,6 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NETFRAMEWORK
+using System.IO;
+#endif
 using System.Text;
 
 #nullable disable
@@ -48,5 +51,46 @@ public static string Replace(this string aString, string oldValue, string newVal
 
             return builder.ToString();
         }
+
+#if NETFRAMEWORK
+        /// <summary>
+        /// Trivial implementation of CommonPrefixLength on spans of characters.
+        /// </summary>
+        public static int CommonPrefixLength(this ReadOnlySpan<char> span, ReadOnlySpan<char> other)
+        {
+            int commonPrefixLength = 0;
+            int length = Math.Min(span.Length, other.Length);
+
+            while (commonPrefixLength < length && span[commonPrefixLength] == other[commonPrefixLength])
+            {
+                commonPrefixLength++;
+            }
+            return commonPrefixLength;
+        }
+
+        /// <summary>
+        /// Adds the missing span-taking overload to .NET Framework version of <see cref="StringBuilder"/>.
+        /// </summary>
+        public static StringBuilder Append(this StringBuilder sb, ReadOnlySpan<char> value)
+        {
+            return sb.Append(value.ToString());
+        }
+
+        /// <summary>
+        /// Adds the missing span-taking overload to .NET Framework version of <see cref="TextWriter"/>.
+        /// </summary>
+        public static void Write(this TextWriter writer, ReadOnlySpan<char> buffer)
+        {
+            writer.Write(buffer.ToString());
+        }
+
+        /// <summary>
+        /// Adds the missing span-taking overload to .NET Framework version of <see cref="TextWriter"/>.
+        /// </summary>
+        public static void WriteLine(this TextWriter writer, ReadOnlySpan<char> buffer)
+        {
+            writer.WriteLine(buffer.ToString());
+        }
+#endif
     }
 }
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index 9a9bec6d5c9..c52765ccd49 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -282,8 +282,13 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
                             bool logMessage = !(eventArgs is BuildFinishedEventArgs) || LogBuildFinished;
                             if (logMessage)
                             {
-                                _fullLog.AppendLine(eventArgs.Message);
-                                _testOutputHelper?.WriteLine(eventArgs.Message);
+                                string msg = eventArgs.Message;
+                                if (eventArgs is BuildMessageEventArgs m && m.LineNumber != 0)
+                                {
+                                    msg = $"{m.File}({m.LineNumber},{m.ColumnNumber}): {msg}";
+                                }
+                                _fullLog.AppendLine(msg);
+                                _testOutputHelper?.WriteLine(msg);
                             }
                             break;
                         }
@@ -496,9 +501,9 @@ internal void AssertLogDoesntContain(string contains)
         /// </summary>
         internal void AssertNoWarnings() => Assert.Equal(0, WarningCount);
 
-        internal void AssertMessageCount(string message, int expectedCount)
+        internal void AssertMessageCount(string message, int expectedCount, bool regexSearch = true)
         {
-            var matches = Regex.Matches(FullLog, message);
+            var matches = Regex.Matches(FullLog, regexSearch ? message : Regex.Escape(message));
             matches.Count.ShouldBe(expectedCount);
         }
     }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 31ce5b63c29..b5b4ad1b610 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1155,6 +1155,11 @@ internal static string GetOSPlatformAsString()
         /// </summary>
         internal static int Count(IEnumerable enumerable)
         {
+            if (enumerable is ICollection c)
+            {
+                return c.Count;
+            }
+
             int i = 0;
             foreach (object _ in enumerable)
             {
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index e37749e172c..27e32d603cb 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -32,9 +32,8 @@ internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation o
                 return oldElement;
             }
 
-            XmlElementWithLocation newElement = (xmlNamespace == null)
-                ? (XmlElementWithLocation)oldElement.OwnerDocument.CreateElement(newElementName)
-                : (XmlElementWithLocation)oldElement.OwnerDocument.CreateElement(newElementName, xmlNamespace);
+            XmlElementWithLocation newElement =
+                (XmlElementWithLocation)((XmlDocumentWithLocation)oldElement.OwnerDocument).CreateElement(newElementName, xmlNamespace ?? string.Empty, oldElement.Location);
 
             // Copy over all the attributes.
             foreach (XmlAttribute oldAttribute in oldElement.Attributes)
diff --git a/src/StringTools/InternableString.Simple.cs b/src/StringTools/InternableString.Simple.cs
index 57789ab0700..4328bbc084e 100644
--- a/src/StringTools/InternableString.Simple.cs
+++ b/src/StringTools/InternableString.Simple.cs
@@ -57,7 +57,7 @@ public Enumerator(InternableString spanBuilder)
             /// <summary>
             /// Returns the current character.
             /// </summary>
-            public char Current => (_string._builder == null ? _string.FirstString[_charIndex] : _string._builder[_charIndex]);
+            public readonly char Current => (_string._builder == null ? _string.FirstString[_charIndex] : _string._builder[_charIndex]);
 
             /// <summary>
             /// Moves to the next character.
@@ -88,7 +88,7 @@ public bool MoveNext()
         /// <summary>
         /// A convenience getter to ensure that we always operate on a non-null string.
         /// </summary>
-        private string FirstString => _firstString ?? string.Empty;
+        private readonly string FirstString => _firstString ?? string.Empty;
 
         /// <summary>
         /// Constructs a new InternableString wrapping the given string.
@@ -116,13 +116,13 @@ internal InternableString(SpanBasedStringBuilder builder)
         /// <summary>
         /// Gets the length of the string.
         /// </summary>
-        public int Length => (_builder == null ? FirstString.Length : _builder.Length);
+        public readonly int Length => (_builder == null ? FirstString.Length : _builder.Length);
 
         /// <summary>
         /// Creates a new enumerator for enumerating characters in this string. Does not allocate.
         /// </summary>
         /// <returns>The enumerator.</returns>
-        public Enumerator GetEnumerator()
+        public readonly Enumerator GetEnumerator()
         {
             return new Enumerator(this);
         }
@@ -132,7 +132,7 @@ public Enumerator GetEnumerator()
         /// </summary>
         /// <param name="other">Another string.</param>
         /// <returns>True if this string is equal to <paramref name="other"/>.</returns>
-        public bool Equals(string other)
+        public readonly bool Equals(string other)
         {
             if (other.Length != Length)
             {
@@ -163,7 +163,7 @@ public bool Equals(string other)
         /// System.String in which case the original string is returned.
         /// </summary>
         /// <returns>The string.</returns>
-        public string ExpensiveConvertToString()
+        public readonly string ExpensiveConvertToString()
         {
             // Special case: if we hold just one string, we can directly return it.
             if (_firstString != null)
@@ -178,9 +178,9 @@ public string ExpensiveConvertToString()
         /// </summary>
         /// <param name="str">The string to compare to.</param>
         /// <returns>True is this instance wraps the given string.</returns>
-        public bool ReferenceEquals(string str)
+        public readonly bool ReferenceEquals(string str)
         {
-            return Object.ReferenceEquals(str, _firstString);
+            return ReferenceEquals(str, _firstString);
         }
 
         /// <summary>
@@ -198,7 +198,7 @@ public override unsafe string ToString()
         /// Implements the simple yet very decently performing djb2 hash function (xor version).
         /// </summary>
         /// <returns>A stable hashcode of the string represented by this instance.</returns>
-        public override int GetHashCode()
+        public override readonly int GetHashCode()
         {
             uint hash = (5381 << 16) + 5381;
             bool isOddIndex = false;
diff --git a/src/StringTools/InternableString.cs b/src/StringTools/InternableString.cs
index 413aad9fb88..7e657d56cdb 100644
--- a/src/StringTools/InternableString.cs
+++ b/src/StringTools/InternableString.cs
@@ -43,7 +43,7 @@ internal Enumerator(scoped ref InternableString str)
             /// <summary>
             /// Returns the current character.
             /// </summary>
-            public ref readonly char Current
+            public readonly ref readonly char Current
             {
                 get
                 {
@@ -178,7 +178,7 @@ public Enumerator GetEnumerator()
         /// </summary>
         /// <param name="other">Another string.</param>
         /// <returns>True if this string is equal to <paramref name="other"/>.</returns>
-        public bool Equals(string other)
+        public readonly bool Equals(string other)
         {
             if (other.Length != Length)
             {
@@ -210,7 +210,7 @@ public bool Equals(string other)
         /// System.String in which case the original string is returned.
         /// </summary>
         /// <returns>The string.</returns>
-        public unsafe string ExpensiveConvertToString()
+        public readonly unsafe string ExpensiveConvertToString()
         {
             if (Length == 0)
             {
@@ -268,7 +268,7 @@ public unsafe string ExpensiveConvertToString()
 
                 // The invariant that Length is the sum of span lengths is critical in this unsafe method.
                 // Violating it may lead to memory corruption and, since this code tends to run under a lock,
-                // to hangs caused by the lock getting orphaned. Attempt to detect that and throw now, 
+                // to hangs caused by the lock getting orphaned. Attempt to detect that and throw now,
                 // before the corruption causes further problems.
                 if (destPtr != resultPtr + Length)
                 {
@@ -283,7 +283,7 @@ public unsafe string ExpensiveConvertToString()
         /// </summary>
         /// <param name="str">The string to compare to.</param>
         /// <returns>True is this instance wraps the given string.</returns>
-        public bool ReferenceEquals(string str)
+        public readonly bool ReferenceEquals(string str)
         {
             if (_inlineSpan.Length == Length)
             {
@@ -317,7 +317,7 @@ public override string ToString()
         /// characters that feed into the same operation but straddle multiple spans. Note that it must return the same value for
         /// a given string regardless of how it's split into spans (e.g. { "AB" } and { "A", "B" } have the same hash code).
         /// </remarks>
-        public override unsafe int GetHashCode()
+        public override readonly unsafe int GetHashCode()
         {
             uint hash = (5381 << 16) + 5381;
             bool hashedOddNumberOfCharacters = false;
diff --git a/src/StringTools/SpanBasedStringBuilder.Simple.cs b/src/StringTools/SpanBasedStringBuilder.Simple.cs
index 6090363a24f..a9c88b590c9 100644
--- a/src/StringTools/SpanBasedStringBuilder.Simple.cs
+++ b/src/StringTools/SpanBasedStringBuilder.Simple.cs
@@ -35,7 +35,7 @@ public Enumerator(StringBuilder builder)
             /// <summary>
             /// Returns the current character.
             /// </summary>
-            public char Current => _builder[_charIndex];
+            public readonly char Current => _builder[_charIndex];
 
             /// <summary>
             /// Moves to the next character.
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 8bdddb235b8..9ca06387a18 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -128,6 +128,165 @@ public void DontCopyOverSameFile()
             }
         }
 
+        /// <summary>
+        /// Question should not copy any files.
+        /// </summary>
+        [Fact]
+        public void QuestionCopyFile()
+        {
+            string source = FileUtilities.GetTemporaryFile();
+            string destination = FileUtilities.GetTemporaryFile(null, ".tmp", false);
+            string content = "This is a source file.";
+
+            try
+            {
+                using (StreamWriter sw = FileUtilities.OpenWrite(source, true))
+                {
+                    sw.Write(content);
+                }
+
+                ITaskItem sourceItem = new TaskItem(source);
+                ITaskItem destinationItem = new TaskItem(destination);
+                ITaskItem[] sourceFiles = { sourceItem };
+                ITaskItem[] destinationFiles = { destinationItem };
+
+                CopyMonitor m = new CopyMonitor();
+                Copy t = new Copy
+                {
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(_testOutputHelper),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    UseHardlinksIfPossible = UseHardLinks,
+                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    FailIfNotIncremental = true,
+                };
+
+                Assert.False(t.Execute(m.CopyFile, _parallelismThreadCount));
+
+                // Expect for there to have been no copies.
+                Assert.Equal(0, m.copyCount);
+
+                Assert.False(FileUtilities.FileExistsNoThrow(destination));
+            }
+            finally
+            {
+                File.Delete(source);
+            }
+        }
+
+        /// <summary>
+        /// Question copy should not error if copy did no work.
+        /// </summary>
+        [Fact]
+        public void QuestionCopyFileSameContent()
+        {
+            string source = FileUtilities.GetTemporaryFile();
+            string destination = FileUtilities.GetTemporaryFile();
+            string content = "This is a source file.";
+            DateTime testTime = DateTime.Now;
+
+            try
+            {
+                using (StreamWriter sw = FileUtilities.OpenWrite(source, true))
+                {
+                    sw.Write(content);
+                }
+
+                using (StreamWriter sw = FileUtilities.OpenWrite(destination, true))
+                {
+                    sw.Write(content);
+                }
+
+                FileInfo sourcefi = new FileInfo(source);
+                sourcefi.LastWriteTimeUtc = testTime;
+
+                FileInfo destinationfi = new FileInfo(destination);
+                destinationfi.LastWriteTimeUtc = testTime;
+
+                ITaskItem sourceItem = new TaskItem(source);
+                ITaskItem destinationItem = new TaskItem(destination);
+                ITaskItem[] sourceFiles = { sourceItem };
+                ITaskItem[] destinationFiles = { destinationItem };
+
+                CopyMonitor m = new CopyMonitor();
+                Copy t = new Copy
+                {
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(_testOutputHelper),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    UseHardlinksIfPossible = UseHardLinks,
+                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    SkipUnchangedFiles = true,
+                    FailIfNotIncremental = true,
+                };
+                Assert.True(t.Execute(m.CopyFile, _parallelismThreadCount));
+
+                // Expect for there to have been no copies.
+                Assert.Equal(0, m.copyCount);
+
+                ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
+            }
+            finally
+            {
+                File.Delete(source);
+                File.Delete(destination);
+            }
+        }
+
+        /// <summary>
+        /// Question copy should error if a copy will occur.
+        /// </summary>
+        [Fact]
+        public void QuestionCopyFileNotSameContent()
+        {
+            string source = FileUtilities.GetTemporaryFile();
+            string destination = FileUtilities.GetTemporaryFile();
+            try
+            {
+                using (StreamWriter sw = FileUtilities.OpenWrite(source, true))
+                {
+                    sw.Write("This is a source file.");
+                }
+
+                using (StreamWriter sw = FileUtilities.OpenWrite(destination, true))
+                {
+                    sw.Write("This is a destination file.");
+                }
+
+                ITaskItem sourceItem = new TaskItem(source);
+                ITaskItem destinationItem = new TaskItem(destination);
+                ITaskItem[] sourceFiles = { sourceItem };
+                ITaskItem[] destinationFiles = { destinationItem };
+
+                CopyMonitor m = new CopyMonitor();
+                Copy t = new Copy
+                {
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = new MockEngine(_testOutputHelper),
+                    SourceFiles = sourceFiles,
+                    DestinationFiles = destinationFiles,
+                    UseHardlinksIfPossible = UseHardLinks,
+                    UseSymboliclinksIfPossible = UseSymbolicLinks,
+                    SkipUnchangedFiles = true,
+                    FailIfNotIncremental = true,
+                };
+
+                Assert.False(t.Execute(m.CopyFile, _parallelismThreadCount));
+
+                // Expect for there to have been no copies.
+                Assert.Equal(0, m.copyCount);
+
+                ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
+            }
+            finally
+            {
+                File.Delete(source);
+                File.Delete(destination);
+            }
+        }
+
         /// <summary>
         /// Unless ignore readonly attributes is set, we should not copy over readonly files.
         /// </summary>
diff --git a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
index 927348ec7e1..f80107870cf 100644
--- a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
+++ b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
@@ -289,10 +289,9 @@ public void AppConfigFileNotSavedWhenIdentical()
             // Verify it ran correctly and that it's still old
             redirectResults2.ExecuteResult.ShouldBeTrue();
             redirectResults2.TargetAppConfigContent.ShouldContain("<assemblyIdentity name=\"System\" publicKeyToken=\"b77a5c561934e089\" culture=\"neutral\" />");
-            redirectResults.TargetAppConfigContent.ShouldContain("newVersion=\"40.0.0.0\"");
+            redirectResults2.TargetAppConfigContent.ShouldContain("newVersion=\"40.0.0.0\"");
 
-            File.GetCreationTime(outputAppConfigFile).ShouldBe(oldTimestamp, TimeSpan.FromSeconds(5));
-            File.GetLastWriteTime(outputAppConfigFile).ShouldBe(oldTimestamp, TimeSpan.FromSeconds(5));
+            File.GetLastWriteTime(outputAppConfigFile).ShouldBeGreaterThan(oldTimestamp);
         }
 
         private BindingRedirectsExecutionResult GenerateBindingRedirects(string appConfigFile, string targetAppConfigFile,
diff --git a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
index 6c3861314bd..d9359ef1a6c 100644
--- a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
+++ b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
@@ -40,6 +40,29 @@ public void ResolvesViaPlatformLookupTable()
             task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("x64");
         }
 
+
+        [Fact]
+        public void ResolvesViaOverride()
+        {
+            // OverridePlatformNegotiationValue always takes priority over everything. It is typically user-defined.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;x86;AnyCPU");
+            projectReference.SetMetadata("platform", "x86");
+            projectReference.SetMetadata("OverridePlatformNegotiationValue", "x86");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x64",
+                PlatformLookupTable = "win32=x64",
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("");
+        }
+
         [Fact]
         public void ResolvesViaProjectReferencesPlatformLookupTable()
         {
diff --git a/src/Tasks.UnitTests/MakeDir_Tests.cs b/src/Tasks.UnitTests/MakeDir_Tests.cs
index fd390661eb3..8a50acbd4c3 100644
--- a/src/Tasks.UnitTests/MakeDir_Tests.cs
+++ b/src/Tasks.UnitTests/MakeDir_Tests.cs
@@ -166,6 +166,63 @@ public void CreateNewDirectory()
             }
         }
 
+        /// <summary>
+        /// Question Create Directory when a directory is needed to be created should return false.
+        /// </summary>
+        [Fact]
+        public void QuestionCreateNewDirectory()
+        {
+            string temp = Path.GetTempPath();
+            string dir = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A38C");
+
+            try
+            {
+                var dirList = new ITaskItem[]
+                {
+                    new TaskItem(dir)
+                };
+                MakeDir t = new MakeDir();
+                MockEngine engine = new MockEngine();
+                t.BuildEngine = engine;
+                t.FailIfNotIncremental = true;
+                t.Directories = dirList;
+
+                bool success = t.Execute();
+
+                Assert.False(success);
+                Assert.Single(t.DirectoriesCreated);
+                Assert.Contains(
+                    String.Format(AssemblyResources.GetString("MakeDir.Comment"), dir),
+                    engine.Log);
+
+                // Actually create the directory
+                // Note: Need a new task to reset the Log.HasLoggedErrors
+                engine.Log = "";
+                t = new MakeDir();
+                t.BuildEngine = engine;
+                t.Directories = dirList;
+                success = t.Execute();
+                Assert.True(success);
+
+                // Question an existing directory should return true.
+                engine.Log = "";
+                t.FailIfNotIncremental = true;
+                success = t.Execute();
+                Assert.True(success);
+
+                // should still return directory even though it didn't need to be created
+                Assert.Single(t.DirectoriesCreated);
+                Assert.Equal(dir, t.DirectoriesCreated[0].ItemSpec);
+                Assert.DoesNotContain(
+                    String.Format(AssemblyResources.GetString("MakeDir.Comment"), dir),
+                    engine.Log);
+            }
+            finally
+            {
+                FileUtilities.DeleteWithoutTrailingBackslash(dir);
+            }
+        }
+
         /*
         * Method:   FileAlreadyExists
         *
diff --git a/src/Tasks.UnitTests/RegressionTests.cs b/src/Tasks.UnitTests/RegressionTests.cs
index a92f5e148dc..ef1b944e160 100644
--- a/src/Tasks.UnitTests/RegressionTests.cs
+++ b/src/Tasks.UnitTests/RegressionTests.cs
@@ -80,5 +80,29 @@ public void AssemblyAttributesLocation()
             bool result = project.Build(logger);
             Assert.True(result, "Output:" + Environment.NewLine + logger.FullLog);
         }
+
+        /// <summary>
+        /// Test for https://github.com/dotnet/msbuild/issues/8153
+        /// </summary>
+        [Fact]
+        public void IsWellKnownAttributeValuePreserved()
+        {
+            ObjectModelHelpers.DeleteTempProjectDirectory();
+
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("Myapp.proj", @"
+                <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                  <Target Name =`Repro`>
+                    <CreateItem Include=`*.txt` AdditionalMetadata=`MyProperty=Identity`>
+                      <Output TaskParameter=`Include` ItemName=`TestItem`/>
+                    </CreateItem>
+                    <Error Text=`@(TestItem)` Condition=""'%(MyProperty)' != 'Identity' ""/>
+                  </Target>
+                </Project>
+                ");
+
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("Foo.txt", "foo");
+            MockLogger logger = new MockLogger(_output);
+            ObjectModelHelpers.BuildTempProjectFileExpectSuccess("Myapp.proj", logger);
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/RemoveDir_Tests.cs b/src/Tasks.UnitTests/RemoveDir_Tests.cs
index 08a081023ea..c0dd5b24cc2 100644
--- a/src/Tasks.UnitTests/RemoveDir_Tests.cs
+++ b/src/Tasks.UnitTests/RemoveDir_Tests.cs
@@ -47,7 +47,6 @@ public void AttributeForwarding()
         [Fact]
         public void SimpleDelete()
         {
-
             using (TestEnvironment env = TestEnvironment.Create(_output))
             {
                 List<TaskItem> list = new List<TaskItem>();
@@ -57,19 +56,36 @@ public void SimpleDelete()
                     list.Add(new TaskItem(env.CreateFolder().Path));
                 }
 
-                RemoveDir t = new RemoveDir();
-
-                t.Directories = list.ToArray();
-                t.BuildEngine = new MockEngine(_output);
-
-                t.Execute().ShouldBeTrue();
+                // Question RemoveDir when files exists.
+                RemoveDir t = new RemoveDir()
+                {
+                    Directories = list.ToArray(),
+                    BuildEngine = new MockEngine(_output),
+                    FailIfNotIncremental = true,
+                };
+                t.Execute().ShouldBeFalse();
 
-                t.RemovedDirectories.Length.ShouldBe(list.Count);
+                RemoveDir t2 = new RemoveDir()
+                {
+                    Directories = list.ToArray(),
+                    BuildEngine = new MockEngine(_output),
+                };
+                t2.Execute().ShouldBeTrue();
+                t2.RemovedDirectories.Length.ShouldBe(list.Count);
 
                 for (int i = 0; i < 20; i++)
                 {
                     Directory.Exists(list[i].ItemSpec).ShouldBeFalse();
                 }
+
+                // Question again to make sure all files were deleted.
+                RemoveDir t3 = new RemoveDir()
+                {
+                    Directories = list.ToArray(),
+                    BuildEngine = new MockEngine(_output),
+                    FailIfNotIncremental = true,
+                };
+                t3.Execute().ShouldBeTrue();
             }
         }
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 94131f1e4b6..f704ef169a1 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -1940,6 +1940,48 @@ public void InvalidStateFile()
             }
         }
 
+        [Fact]
+        public void GenerateResourceWarnsWhenUsingBinaryFormatter()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile resource = env.CreateFile(".resx", @"<?xml version=""1.0"" encoding=""utf-8""?>
+<root>
+  <data name=""$this.Icon"" type=""System.Drawing.Icon, System.Drawing"" mimetype=""application/x-microsoft.net.object.binary.base64"">
+    <value>
+        AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAAAAAA
+        AAD///8BoqKiDaKiotmioqL5oqKiK////wH///8B////Af///wH///8B////AaKioiGioqLxoqKi5aKi
+        ohn///8B////AbS0tBW0tLTz29vb/7Ozsu18Wi+Be1gswXtYLO17WCzte1gswXtYLIGzs7Lz2dnZ/7S0
+        tPu0tLQj////Af///wH///8BxsbGQdPT0//Cv739nGs7/6ZsNf+ubzf/rm83/6ZsNf+hdkr/xcTD/8bG
+        xf/GxsY/////Af///wH///8B////AYxlNmejiGn1r3hE/7uMXv/Ck3H/xJF0/8OPcf+/kGz/uIpd/7SG
+        Wf+hhWT1jGU2Z////wH///8B////AZZtOzWWbTvVs31G/8KZcf/Yqon/79/P//r28//69fP/79/R/9en
+        hf++lGz/s31G/5ZtO9WWbTs1////Af///wGhdUGBsIBK/8abb//Zqoj///7r///67v///fL///7y///8
+        7////ev/2aN6/8KZbP+wgEr/oXVBgf///wH///8BrH5Iwb+PWP/No4H/8NvB///35v/68uP/xcC2//Ht
+        3v///Oj///Xf/+/Ur//ImXL/v49Y/6x+SMH///8B////AbeHTu3JnGb/z5+A//rz4v/99un/8vDj/42M
+        hP+Bf3f/0s/C///76//67Mz/x5Bt/8mcZv+3h07t////Af///wHCkFTtzqZx/9Glif/69un//fju////
+        +f+BgHn/sa6k/4F/d//Jxrr/+vDT/8mWcv/OpnH/wpBU7f///wH///8BzZlbwdOsdf/Zt5j/8ePW//77
+        9f/19fP/n56V//Dw6f/4+PL/vrmt//Dawv/Sqof/06x1/82ZW8H///8B////AbOddIvTrXf/38Sa/969
+        qv//////8PDu/+fl2v////f////3///+8//ctJj/28CW/8Kqfv/Gn2qF////AQCZ3T0KmtjZLpzF9d6/
+        iv/iyaf/37+u//Hj3P/z8ez/9PHr//Hi2f/cuqP/38Oe/4yxqf84ptH5DprWzwCZ3ScAoON9fNHy7WHD
+        6O86pMb74seS/+bRqf/gwqb/1a6W/9Wrkv/evaD/5M+m/7/Bnv9Hstf9q+P2/Smw6NkAoOMnAKfpe13J
+        8eW16Pn/Ycfr7zqqzPPsxIj/6cuU/+fQnf/n0J3/6cuU/97Cjv8yqtD1gdPw9XPQ8+sAp+nNAKfpBQCu
+        7wUAru+LW8v05b/s+v9cy/HpTbLJxfq8dMH6vHTt+rx07fq8dMFRssjDac/y7XzW9u0Aru/JAK7vHf//
+        /wH///8BALX0AwC19IEAtfTRALX0ywC19Af///8B////Af///wH///8BALX0FwC19NEAtfTJALX0J///
+        /wH///8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA
+        //8AAP//AAD//w==
+</value>
+  </data>
+</root>
+");
+
+            GenerateResource gr = Utilities.CreateTask(_output, usePreserialized: true, env: env);
+            gr.Sources = new ITaskItem[] { new TaskItem(resource.Path) };
+            gr.WarnOnBinaryFormatterUse = true;
+
+            gr.Execute().ShouldBeTrue();
+
+            Utilities.AssertLogContainsResource(gr, "GenerateResource.BinaryFormatterUse", "$this.Icon", "System.Drawing.Icon, System.Drawing");
+        }
+
         /// <summary>
         ///  Cause failures in ResourceReader
         /// </summary>
diff --git a/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
index d1c0b84fdc0..c161b862071 100644
--- a/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
@@ -32,7 +32,7 @@ public void ParsesSingleStringAsString()
                     @"<data name=""StringResource"" xml:space=""preserve"">
     <value>StringValue</value>
     <comment>Comment</comment>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", "StringValue");
         }
@@ -45,7 +45,7 @@ public void ParsesSingleStringWithoutPreserveAsString()
                     @"<data name=""StringResource"">
     <value> StringValue </value>
     <comment>Comment</comment>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", " StringValue ");
         }
@@ -58,7 +58,7 @@ public void ParsesSingleWhitespaceStringAsString()
                     @"<data name=""StringResource"" xml:space=""preserve"">
     <value> </value>
     <comment>Comment</comment>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", " ");
         }
@@ -71,7 +71,7 @@ public void ParsesSingleWhitespaceStringWithNoPreserveAsEmptyString()
                     @"<data name=""StringResource"">
     <value> </value>
     <comment>Comment</comment>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", "");
         }
@@ -83,7 +83,7 @@ public void ParsesSingleStringWithPartialTypeName()
                 ResXHelper.SurroundWithBoilerplate(
                     @"<data name=""StringResource"" type=""System.String"">
     <value>StringValue</value>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithSingleString, "StringResource", "StringValue");
         }
@@ -100,7 +100,7 @@ public void LoadsMultipleStringsPreservingOrder()
   </data>
   <data name=""2StringResource2"" xml:space=""preserve"">
     <value>2StringValue2</value>
-  </data>"));
+  </data>"), null, false);
 
             resxWithTwoStrings.Count.ShouldBe(2);
 
@@ -121,7 +121,7 @@ public void ResXNullRefProducesNullLiveObject()
 @"  <assembly alias=""System.Windows.Forms"" name=""System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"" />
   <data name=""$this.AccessibleDescription"" type=""System.Resources.ResXNullRef, System.Windows.Forms, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"">
     <value />
-  </data>"));
+  </data>"), null, false);
 
             resxWithNullRef.ShouldHaveSingleItem();
 
@@ -143,7 +143,7 @@ public void LoadsStringFromFileRefAsString(string stringType)
 $@"  <assembly alias=""System.Windows.Forms"" name=""System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"" />
   <data name=""TextFile1"" type=""System.Resources.ResXFileRef, System.Windows.Forms"">
     <value>ResourceHandling\TextFile1.txt;{stringType};utf-8</value>
-  </data>"));
+  </data>"), null, false);
 
             AssertSingleStringResource(resxWithLinkedString, "TextFile1", "Contents of TextFile1");
         }
@@ -174,6 +174,8 @@ public void LoadsStringFromFileRefAsStringWithShiftJISEncoding()
   <data name=""TextFile1"" type=""System.Resources.ResXFileRef, System.Windows.Forms"">
     <value>ResourceHandling\TextFileInShiftJIS.txt;System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089;shift_jis</value>
   </data>"),
+                    null,
+                    false,
                     Path.Combine(baseDir.Path, nameof(LoadsStringFromFileRefAsStringWithShiftJISEncoding) + ".resx"),
                     useRelativePath: true);
 
@@ -210,7 +212,7 @@ public void PassesThroughBitmapInResx()
         b7eblRw4yy8Ta2GCpaZp1sIzz2LfCMS+EYh9401iw/gG1gYfvzjQIXcAAAAASUVORK5CYII=
 </value>
   </data>
-"));
+"), null, false);
             resxWithEmbeddedBitmap.ShouldHaveSingleItem();
             resxWithEmbeddedBitmap[0].ShouldBeOfType(typeof(TypeConverterByteArrayResource));
 
@@ -228,7 +230,7 @@ public void TypeConverterStringWellFormatted()
     <data name=""color"" type=""System.Drawing.Color, System.Drawing"">
       <value>Blue</value>
     </data>
-"));
+"), null, false);
             resxWithEmbeddedBitmap.ShouldHaveSingleItem();
             resxWithEmbeddedBitmap[0].ShouldBeOfType(typeof(TypeConverterStringResource));
 
@@ -252,7 +254,7 @@ public void TypeConverterStringDirectValue()
                 ResXHelper.SurroundWithBoilerplate(
 @"  <assembly alias=""System.Drawing"" name=""System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"" />
     <data name=""Color1"" type=""System.Drawing.Color, System.Drawing"">Blue</data>
-"));
+"), null, false);
             resxWithEmbeddedBitmap.ShouldHaveSingleItem();
             resxWithEmbeddedBitmap[0].ShouldBeOfType(typeof(TypeConverterStringResource));
 
@@ -272,7 +274,7 @@ public void ResXFileRefToBitmap()
 $@"  <data name='Image1' type='System.Resources.ResXFileRef, System.Windows.Forms'>
     <value>{bitmapPath};System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
   </data>
-"));
+"), null, false);
             resxWithLinkedBitmap.ShouldHaveSingleItem();
             resxWithLinkedBitmap[0].ShouldBeOfType(typeof(FileStreamResource));
 
@@ -301,7 +303,7 @@ public void ResXFileRefToMemoryStream(string typeNameInResx)
 $@"  <data name='Image1' type='System.Resources.ResXFileRef, System.Windows.Forms'>
     <value>{linkedTextFile.Path};{typeNameInResx}</value>
   </data>
-"));
+"), null, false);
 
             var resource = resources.ShouldHaveSingleItem()
                 .ShouldBeOfType<LiveObjectResource>();
@@ -321,7 +323,7 @@ public void AssemblyElementWithNoAliasInfersSimpleName()
                 ResXHelper.SurroundWithBoilerplate(
 @"  <assembly name=""System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"" />
     <data name=""Color1"" type=""System.Drawing.Color, System.Drawing""><value>Blue</value></data>
-"));
+"), null, false);
             resxWithEmbeddedBitmap.ShouldHaveSingleItem();
             resxWithEmbeddedBitmap[0].ShouldBeOfType(typeof(TypeConverterStringResource));
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
index d8462b8017b..6538fef25df 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
@@ -40,7 +40,7 @@ public void DirtyCleanScenario(bool useMSBuildResXReader)
                 cache.IsDirty.ShouldBeFalse();
 
                 // Getting a file that wasn't in the cache is a write operation.
-                cache.GetResXFileInfo(resx, useMSBuildResXReader);
+                cache.GetResXFileInfo(resx, useMSBuildResXReader, null, false);
                 cache.IsDirty.ShouldBeTrue();
 
                 // Add linkedFiles to further test serialization and deserialization.
@@ -72,7 +72,7 @@ public void DirtyCleanScenario(bool useMSBuildResXReader)
                 resX2.linkedFiles[1].ShouldBe(resX.linkedFiles[1]);
 
                 // Asking for a file that's in the cache should not dirty the cache.
-                cache2.GetResXFileInfo(resx, useMSBuildResXReader);
+                cache2.GetResXFileInfo(resx, useMSBuildResXReader, null, false);
                 cache2.IsDirty.ShouldBeFalse();
 
                 // Changing UseSourcePath to false should dirty the cache.
diff --git a/src/Tasks.UnitTests/Touch_Tests.cs b/src/Tasks.UnitTests/Touch_Tests.cs
index d87d2e5a65d..72117637d4a 100644
--- a/src/Tasks.UnitTests/Touch_Tests.cs
+++ b/src/Tasks.UnitTests/Touch_Tests.cs
@@ -332,5 +332,80 @@ public void TouchNonExistingDirectoryDoesntExist()
             Assert.Contains("MSB3371", engine.Log);
             Assert.Contains(nonexisting_txt, engine.Log);
         }
+
+        /// <summary>
+        /// Question touch on non-existing file should return false.
+        /// </summary>
+        [Fact]
+        public void QuestionTouchNonExisting()
+        {
+            Touch t = new Touch();
+            MockEngine engine = new MockEngine();
+            t.BuildEngine = engine;
+            t.FailIfNotIncremental = true;
+
+            t.Files = new ITaskItem[]
+            {
+                new TaskItem(mynonexisting_txt)
+            };
+
+            bool success = Execute(t);
+
+            // Not success because the file doesn't exist
+            Assert.False(success);
+
+            Assert.Contains(
+                String.Format(AssemblyResources.GetString("Touch.FileDoesNotExist"), mynonexisting_txt),
+                engine.Log);
+        }
+
+        /// <summary>
+        /// Question touch on a non-existing file with AlwaysCreate property should return false.
+        /// </summary>
+        [Fact]
+        public void QuestionTouchNonExistingAlwaysCreate()
+        {
+            Touch t = new Touch();
+            MockEngine engine = new MockEngine();
+            t.BuildEngine = engine;
+            t.FailIfNotIncremental = true;
+            t.AlwaysCreate = true;
+            t.Files = new ITaskItem[]
+            {
+                new TaskItem(mynonexisting_txt)
+            };
+
+            bool success = Execute(t);
+
+            Assert.False(success);
+
+            Assert.Contains(
+                String.Format(AssemblyResources.GetString("Touch.CreatingFile"), mynonexisting_txt, "AlwaysCreate"),
+                engine.Log);
+        }
+
+        /// <summary>
+        /// Question touch should return true and the file is not touched.
+        /// </summary>
+        [Fact]
+        public void QuestionTouchExisting()
+        {
+            Touch t = new Touch();
+            MockEngine engine = new MockEngine();
+            t.BuildEngine = engine;
+            t.FailIfNotIncremental = true;
+            t.Files = new ITaskItem[]
+            {
+                new TaskItem(myexisting_txt)
+            };
+
+            bool success = Execute(t);
+
+            Assert.False(success);
+
+            Assert.Contains(
+                String.Format(AssemblyResources.GetString("Touch.Touching"), myexisting_txt),
+                engine.Log);
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/Unzip_Tests.cs b/src/Tasks.UnitTests/Unzip_Tests.cs
index 26de13ddc87..eb2dc83d338 100644
--- a/src/Tasks.UnitTests/Unzip_Tests.cs
+++ b/src/Tasks.UnitTests/Unzip_Tests.cs
@@ -60,19 +60,45 @@ public void CanUnzip()
 
                 TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
 
+                // Question new task, should be false.
                 Unzip unzip = new Unzip
                 {
                     BuildEngine = _mockEngine,
                     DestinationFolder = new TaskItem(destination.Path),
                     OverwriteReadOnlyFiles = true,
                     SkipUnchangedFiles = false,
-                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) }
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    FailIfNotIncremental = true,
                 };
+                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+                _mockEngine.Log = string.Empty;
 
-                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+                // Run the task.
+                Unzip unzip2 = new Unzip
+                {
+                    BuildEngine = _mockEngine,
+                    DestinationFolder = new TaskItem(destination.Path),
+                    OverwriteReadOnlyFiles = true,
+                    SkipUnchangedFiles = false,
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    FailIfNotIncremental = false,
+                };
+                unzip2.Execute().ShouldBeTrue(() => _mockEngine.Log);
 
                 _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), () => _mockEngine.Log);
                 _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), () => _mockEngine.Log);
+
+                // Question ran task, should be true
+                Unzip unzip3 = new Unzip
+                {
+                    BuildEngine = _mockEngine,
+                    DestinationFolder = new TaskItem(destination.Path),
+                    OverwriteReadOnlyFiles = true,
+                    SkipUnchangedFiles = true,
+                    SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                    FailIfNotIncremental = true,
+                };
+                unzip3.Execute().ShouldBeTrue(() => _mockEngine.Log);
             }
         }
 
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index a538b371cf3..e4ce0c64991 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -90,6 +90,51 @@ public void CombineFileDirectory()
             string file = Path.Combine(Path.GetTempPath(), "CombineFileDirectory.tmp");
             Assert.Equal(file, task.OutputFile.ItemSpec);
             Assert.True(File.Exists(file));
+
+            File.Delete(task.OutputFile.ItemSpec);
+        }
+
+        /// <summary>
+        /// Combine file and directory where the directory does not already exist
+        /// </summary>
+        [Fact]
+        public void CombineFileDirectoryAndDirectoryDoesNotExist()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+
+            TaskItem folder = new TaskItem(env.CreateFolder(folderPath: null, createFolder: false).Path);
+
+            TaskItem file = new TaskItem("CombineFileDirectory.tmp");
+
+            string expectedFile = Path.Combine(folder.ItemSpec, file.ItemSpec);
+            WriteCodeFragment task = CreateTask("c#", folder, file, new TaskItem[] { new TaskItem("aa") });
+            MockEngine engine = new MockEngine(true);
+            task.BuildEngine = engine;
+            bool result = task.Execute();
+
+            Assert.True(result);
+            Assert.Equal(expectedFile, task.OutputFile.ItemSpec);
+            Assert.True(File.Exists(expectedFile));
+        }
+
+        /// <summary>
+        /// Combine file and directory where the directory does not already exist
+        /// </summary>
+        [Fact]
+        public void FileWithPathAndDirectoryDoesNotExist()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+
+            TaskItem file = new TaskItem(Path.Combine(env.CreateFolder(folderPath: null, createFolder: false).Path, "File.tmp"));
+
+            WriteCodeFragment task = CreateTask("c#", null, file, new TaskItem[] { new TaskItem("aa") });
+            MockEngine engine = new MockEngine(true);
+            task.BuildEngine = engine;
+            bool result = task.Execute();
+
+            Assert.True(result);
+            Assert.Equal(file.ItemSpec, task.OutputFile.ItemSpec);
+            Assert.True(File.Exists(task.OutputFile.ItemSpec));
         }
 
         /// <summary>
@@ -176,7 +221,7 @@ public void NoAttributesShouldEmitNoFile2()
         /// <summary>
         /// Bad file path
         /// </summary>
-        [Fact]
+        [WindowsOnlyFact(additionalMessage: "No invalid characters on Unix.")]
         public void InvalidFilePath()
         {
             WriteCodeFragment task = new WriteCodeFragment();
@@ -317,6 +362,27 @@ public void ToDirectory()
             File.Delete(task.OutputFile.ItemSpec);
         }
 
+        /// <summary>
+        /// Specify directory where the directory does not already exist
+        /// </summary>
+        [Fact]
+        public void ToDirectoryAndDirectoryDoesNotExist()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+
+            TaskItem folder = new TaskItem(env.CreateFolder(folderPath: null, createFolder: false).Path);
+
+            WriteCodeFragment task = CreateTask("c#", folder, null, new TaskItem[] { new TaskItem("System.AssemblyTrademarkAttribute") });
+            MockEngine engine = new MockEngine(true);
+            task.BuildEngine = engine;
+            bool result = task.Execute();
+
+            Assert.True(result);
+            Assert.True(File.Exists(task.OutputFile.ItemSpec));
+            Assert.Equal(folder.ItemSpec, task.OutputFile.ItemSpec.Substring(0, folder.ItemSpec.Length));
+            Assert.Equal(".cs", task.OutputFile.ItemSpec.Substring(task.OutputFile.ItemSpec.Length - 3));
+        }
+
         /// <summary>
         /// Regular case
         /// </summary>
@@ -874,7 +940,7 @@ public void InferredTypeForNamedParameter()
         }
 
         /// <summary>
-        /// For backward-compatibility, if multiple constructors are found with the same number 
+        /// For backward-compatibility, if multiple constructors are found with the same number
         /// of position arguments that was specified in the metadata, then the constructor that
         /// has strings for every parameter should be used.
         /// </summary>
@@ -985,11 +1051,18 @@ public void UsingInferredDeclaredTypesAndLiteralsInSameAttribute()
 
         private WriteCodeFragment CreateTask(string language, params TaskItem[] attributes)
         {
-            WriteCodeFragment task = new();
-            task.Language = language;
-            task.OutputDirectory = new TaskItem(Path.GetTempPath());
-            task.AssemblyAttributes = attributes;
-            return task;
+            return CreateTask(language, new TaskItem(Path.GetTempPath()), null, attributes);
+        }
+
+        private WriteCodeFragment CreateTask(string language, TaskItem outputDirectory, TaskItem outputFile, params TaskItem[] attributes)
+        {
+            return new WriteCodeFragment()
+            {
+                Language = language,
+                OutputDirectory = outputDirectory,
+                OutputFile = outputFile,
+                AssemblyAttributes = attributes
+            };
         }
 
         private void ExecuteAndVerifySuccess(WriteCodeFragment task, params string[] expectedAttributes)
diff --git a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
index fa30f5f0f26..0b3d12f099e 100644
--- a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
+++ b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
@@ -154,6 +154,90 @@ public void WriteLinesWriteOnlyWhenDifferentTest()
             }
         }
 
+        [Fact]
+        public void RedundantParametersAreLogged()
+        {
+            using TestEnvironment testEnv = TestEnvironment.Create(_output);
+
+            MockEngine engine = new(_output);
+
+            string file = testEnv.ExpectFile().Path;
+
+            WriteLinesToFile task = new()
+            {
+                BuildEngine = engine,
+                File = new TaskItem(file),
+                Lines = new ITaskItem[] { new TaskItem($"{nameof(RedundantParametersAreLogged)} Test") },
+                WriteOnlyWhenDifferent = true,
+                Overwrite = false,
+            };
+
+            task.Execute().ShouldBeTrue();
+            engine.AssertLogContainsMessageFromResource(AssemblyResources.GetString, "WriteLinesToFile.UnusedWriteOnlyWhenDifferent", file);
+        }
+
+        /// <summary>
+        /// Question WriteLines to return false when a write will be required.
+        /// </summary>
+        [Fact]
+        public void QuestionWriteLinesWriteOnlyWhenDifferentTest()
+        {
+            var file = FileUtilities.GetTemporaryFile();
+            try
+            {
+                // Write an initial file.
+                var a = new WriteLinesToFile
+                {
+                    Overwrite = true,
+                    BuildEngine = new MockEngine(_output),
+                    File = new TaskItem(file),
+                    WriteOnlyWhenDifferent = true,
+                    Lines = new ITaskItem[] { new TaskItem("File contents1") }
+                };
+
+                a.Execute().ShouldBeTrue();
+
+                // Verify contents
+                var r = new ReadLinesFromFile { File = new TaskItem(file) };
+                r.Execute().ShouldBeTrue();
+                r.Lines[0].ItemSpec.ShouldBe("File contents1");
+
+                var writeTime = DateTime.Now.AddHours(-1);
+
+                File.SetLastWriteTime(file, writeTime);
+
+                // Write the same contents to the file, timestamps should match.
+                var a2 = new WriteLinesToFile
+                {
+                    Overwrite = true,
+                    BuildEngine = new MockEngine(_output),
+                    File = new TaskItem(file),
+                    WriteOnlyWhenDifferent = true,
+                    Lines = new ITaskItem[] { new TaskItem("File contents1") },
+                    FailIfNotIncremental = true,
+                };
+                a2.Execute().ShouldBeTrue();
+                File.GetLastWriteTime(file).ShouldBe(writeTime, tolerance: TimeSpan.FromSeconds(1));
+
+                // Write different contents to the file, last write time should differ.
+                var a3 = new WriteLinesToFile
+                {
+                    Overwrite = true,
+                    BuildEngine = new MockEngine(_output),
+                    File = new TaskItem(file),
+                    WriteOnlyWhenDifferent = true,
+                    Lines = new ITaskItem[] { new TaskItem("File contents2") },
+                    FailIfNotIncremental = true,
+                };
+                a3.Execute().ShouldBeFalse();
+                File.GetLastWriteTime(file).ShouldBe(writeTime, tolerance: TimeSpan.FromSeconds(1));
+            }
+            finally
+            {
+                File.Delete(file);
+            }
+        }
+
         /// <summary>
         /// Should create directory structure when target <see cref="WriteLinesToFile.File"/> does not exist.
         /// </summary>
diff --git a/src/Tasks/AssemblyDependency/AssemblyNameReference.cs b/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
index 91f87bd654e..818a00a7fe4 100644
--- a/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyNameReference.cs
@@ -19,7 +19,7 @@ internal struct AssemblyNameReference : IComparable<AssemblyNameReference>
         /// <summary>
         /// Display as string.
         /// </summary>
-        public override string ToString()
+        public override readonly string ToString()
         {
             return assemblyName + ", " + reference;
         }
@@ -27,7 +27,7 @@ public override string ToString()
         /// <summary>
         /// Compare by assembly name.
         /// </summary>
-        public int CompareTo(AssemblyNameReference other)
+        public readonly int CompareTo(AssemblyNameReference other)
         {
             return assemblyName.CompareTo(other.assemblyName);
         }
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index fbb3c2470cb..19aab4b83e6 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using System.IO;
 
 #nullable disable
 
@@ -103,8 +104,9 @@ public override bool Execute()
             runtimeNode.Add(redirectNodes);
 
             var writeOutput = true;
+            var outputExists = FileSystems.Default.FileExists(OutputAppConfigFile.ItemSpec);
 
-            if (FileSystems.Default.FileExists(OutputAppConfigFile.ItemSpec))
+            if (outputExists)
             {
                 try
                 {
@@ -131,11 +133,19 @@ public override bool Execute()
 
             if (writeOutput)
             {
+                Log.LogMessageFromResources(MessageImportance.Low, "GenerateBindingRedirects.CreatingBindingRedirectionFile", OutputAppConfigFile.ItemSpec);
                 using (var stream = FileUtilities.OpenWrite(OutputAppConfigFile.ItemSpec, false))
                 {
                     doc.Save(stream);
                 }
             }
+            else if (outputExists)
+            {
+                // if the file exists and the content is up to date, then touch the output file.
+                var now = DateTime.Now;
+                File.SetLastAccessTime(OutputAppConfigFile.ItemSpec, now);
+                File.SetLastWriteTime(OutputAppConfigFile.ItemSpec, now);
+            }
 
             return !Log.HasLoggedErrors;
         }
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 00e9c2c6103..4272a5e149e 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -1331,9 +1331,10 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                 }
 
                 // Go through each of the references, we go through this table because in general it will be considerably smaller than the blacklist. (10's of references vs 100's of black list items)
-                foreach (AssemblyNameExtension assemblyName in References.Keys)
+                foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
                 {
-                    Reference assemblyReference = References[assemblyName];
+                    AssemblyNameExtension assemblyName = assembly.Key;
+                    Reference assemblyReference = assembly.Value;
 
                     AddToDependencyGraph(dependencyGraph, assemblyName, assemblyReference);
 
@@ -1495,12 +1496,12 @@ private static void RemovePrimaryReferenceMarkedForExclusion(LogExclusionReason
         /// </summary>
         internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec)
         {
-            foreach (AssemblyNameExtension assemblyName in References.Keys)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
             {
-                Reference assemblyReference = References[assemblyName];
+                Reference assemblyReference = assembly.Value;
                 if (assemblyReference.IsPrimary && assemblyReference.PrimarySourceItem.ItemSpec.Equals(itemSpec, StringComparison.OrdinalIgnoreCase))
                 {
-                    return assemblyName;
+                    return assembly.Key;
                 }
             }
 
@@ -1731,14 +1732,14 @@ private bool FindAssociatedFiles()
         /// </summary>
         private void ResolveAssemblyFilenames()
         {
-            foreach (AssemblyNameExtension assemblyName in References.Keys)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
             {
-                Reference reference = GetReference(assemblyName);
+                Reference reference = assembly.Value;
 
                 // Has this reference been resolved to a file name?
                 if (!reference.IsResolved && !reference.IsUnresolvable)
                 {
-                    ResolveReference(assemblyName, null, reference);
+                    ResolveReference(assembly.Key, null, reference);
                 }
             }
         }
@@ -2153,16 +2154,19 @@ private Dictionary<string, List<AssemblyNameReference>> BuildSimpleNameTable()
         private static void RemoveReferencesWithoutConflicts(
             Dictionary<string, List<AssemblyNameReference>> baseNameToReferences)
         {
-            string[] baseNames = new string[baseNameToReferences.Count];
-            baseNameToReferences.Keys.CopyTo(baseNames, 0);
-
-            foreach (string baseName in baseNames)
+            List<string> toRemove = new(baseNameToReferences.Count);
+            foreach (KeyValuePair<string, List<AssemblyNameReference>> kvp in baseNameToReferences)
             {
-                if (baseNameToReferences[baseName].Count == 1)
+                if (kvp.Value.Count == 1)
                 {
-                    baseNameToReferences.Remove(baseName);
+                    toRemove.Add(kvp.Key);
                 }
             }
+
+            foreach (string key in toRemove)
+            {
+                baseNameToReferences.Remove(key);
+            }
         }
 
         // TODO: Verify correctness of this implementation and extend to more cases.
@@ -3095,10 +3099,11 @@ internal bool MarkReferencesForExclusion(Dictionary<string, string> exclusionLis
             bool anyMarkedReference = false;
             ListOfExcludedAssemblies = new List<string>();
 
-            foreach (AssemblyNameExtension assemblyName in References.Keys)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in References)
             {
+                AssemblyNameExtension assemblyName = assembly.Key;
+                Reference reference = assembly.Value;
                 string assemblyFullName = assemblyName.FullName;
-                Reference reference = GetReference(assemblyName);
                 reference.ReferenceVersion = assemblyName.Version;
 
                 MarkReferenceWithHighestVersionInCurrentRedistList(assemblyName, reference);
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 9e21604d2d6..afdde42ef14 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -29,7 +29,7 @@ namespace Microsoft.Build.Tasks
     /// Given a list of assemblyFiles, determine the closure of all assemblyFiles that
     /// depend on those assemblyFiles including second and nth-order dependencies too.
     /// </summary>
-    public class ResolveAssemblyReference : TaskExtension
+    public class ResolveAssemblyReference : TaskExtension, IIncrementalTask
     {
         /// <summary>
         /// key assembly used to trigger inclusion of facade references.
@@ -888,6 +888,8 @@ public string[] FullFrameworkFolders
             }
         }
 
+        public bool FailIfNotIncremental { get; set; }
+
         /// <summary>
         /// This is a list of all primary references resolved to full paths.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
@@ -1067,10 +1069,11 @@ quiet at the engine level.
                 if (!Silent)
                 {
                     // First, loop over primaries and display information.
-                    foreach (AssemblyNameExtension assemblyName in dependencyTable.References.Keys)
+                    foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in dependencyTable.References)
                     {
+                        AssemblyNameExtension assemblyName = assembly.Key;
                         string fusionName = assemblyName.FullName;
-                        Reference primaryCandidate = dependencyTable.GetReference(assemblyName);
+                        Reference primaryCandidate = assembly.Value;
 
                         if (primaryCandidate.IsPrimary && !(primaryCandidate.IsConflictVictim && primaryCandidate.IsCopyLocal))
                         {
@@ -1079,10 +1082,11 @@ quiet at the engine level.
                     }
 
                     // Second, loop over dependencies and display information.
-                    foreach (AssemblyNameExtension assemblyName in dependencyTable.References.Keys)
+                    foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in dependencyTable.References)
                     {
+                        AssemblyNameExtension assemblyName = assembly.Key;
                         string fusionName = assemblyName.FullName;
-                        Reference dependencyCandidate = dependencyTable.GetReference(assemblyName);
+                        Reference dependencyCandidate = assembly.Value;
 
                         if (!dependencyCandidate.IsPrimary && !(dependencyCandidate.IsConflictVictim && dependencyCandidate.IsCopyLocal))
                         {
@@ -1091,10 +1095,11 @@ quiet at the engine level.
                     }
 
                     // Third, show conflicts and their resolution.
-                    foreach (AssemblyNameExtension assemblyName in dependencyTable.References.Keys)
+                    foreach (KeyValuePair<AssemblyNameExtension, Reference> assembly in dependencyTable.References)
                     {
+                        AssemblyNameExtension assemblyName = assembly.Key;
                         string fusionName = assemblyName.FullName;
-                        Reference conflictCandidate = dependencyTable.GetReference(assemblyName);
+                        Reference conflictCandidate = assembly.Value;
 
                         if (conflictCandidate.IsConflictVictim)
                         {
@@ -2051,6 +2056,12 @@ internal void WriteStateFile()
             }
             else if (!String.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
             {
+                if (FailIfNotIncremental)
+                {
+                    Log.LogErrorFromResources("ResolveAssemblyReference.WritingCacheFile", _stateFile);
+                    return;
+                }
+
                 _cache.SerializeCache(_stateFile, Log);
             }
         }
diff --git a/src/Tasks/AssignProjectConfiguration.cs b/src/Tasks/AssignProjectConfiguration.cs
index 287ddf6fa41..74894b3aa5e 100644
--- a/src/Tasks/AssignProjectConfiguration.cs
+++ b/src/Tasks/AssignProjectConfiguration.cs
@@ -152,14 +152,11 @@ public string VcxToDefaultPlatformMapping
         private const string attrFullConfiguration = "FullConfiguration";
         private const string buildReferenceMetadataName = "BuildReference";
         private const string referenceOutputAssemblyMetadataName = "ReferenceOutputAssembly";
-        private const string buildProjectInSolutionAttribute = "BuildProjectInSolution";
         private const string attrConfiguration = "Configuration";
         private const string attrPlatform = "Platform";
         private const string attrSetConfiguration = "SetConfiguration";
         private const string attrSetPlatform = "SetPlatform";
 
-        private static readonly char[] s_configPlatformSeparator = { '|' };
-
         private IDictionary<string, string> _vcxToDefaultMap;
         private IDictionary<string, string> _defaultToVcxMap;
         private bool _mappingsPopulated;
@@ -288,14 +285,14 @@ internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedProject
                 {
                     if (_defaultToVcxMap.TryGetValue(CurrentProjectPlatform, out transformedPlatform))
                     {
-                        projectConfiguration = CurrentProjectConfiguration + s_configPlatformSeparator[0] + transformedPlatform;
+                        projectConfiguration = CurrentProjectConfiguration + SolutionConfiguration.ConfigPlatformSeparator[0] + transformedPlatform;
                     }
                 }
                 else
                 {
                     if (_vcxToDefaultMap.TryGetValue(CurrentProjectPlatform, out transformedPlatform))
                     {
-                        projectConfiguration = CurrentProjectConfiguration + s_configPlatformSeparator[0] + transformedPlatform;
+                        projectConfiguration = CurrentProjectConfiguration + SolutionConfiguration.ConfigPlatformSeparator[0] + transformedPlatform;
                     }
                 }
             }
@@ -307,7 +304,7 @@ internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedProject
                 resolvedProjectWithConfiguration = projectRef;
                 resolvedProjectWithConfiguration.SetMetadata(attrFullConfiguration, projectConfiguration);
 
-                string[] configurationPlatformParts = projectConfiguration.Split(s_configPlatformSeparator);
+                string[] configurationPlatformParts = projectConfiguration.Split(SolutionConfiguration.ConfigPlatformSeparator);
                 resolvedProjectWithConfiguration.SetMetadata(attrSetConfiguration, "Configuration=" + configurationPlatformParts[0]);
                 resolvedProjectWithConfiguration.SetMetadata(attrConfiguration, configurationPlatformParts[0]);
 
@@ -337,7 +334,7 @@ internal static void SetBuildInProjectAndReferenceOutputAssemblyMetadata(bool on
             if (projectConfigurationElement != null && resolvedProjectWithConfiguration != null && onlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)
             {
                 // The value of the specified attribute. An empty string is returned if a matching attribute is not found or if the attribute does not have a specified or default value. 
-                string buildProjectInSolution = projectConfigurationElement.GetAttribute(buildProjectInSolutionAttribute);
+                string buildProjectInSolution = projectConfigurationElement.GetAttribute(SolutionConfiguration.BuildProjectInSolutionAttribute);
 
                 // We could not parse out what was in the attribute, act as if it was not set in the first place. 
                 if (bool.TryParse(buildProjectInSolution, out bool buildProject))
diff --git a/src/Tasks/ComDependencyWalker.cs b/src/Tasks/ComDependencyWalker.cs
index 9de8725cd65..f998d3be668 100644
--- a/src/Tasks/ComDependencyWalker.cs
+++ b/src/Tasks/ComDependencyWalker.cs
@@ -66,7 +66,7 @@ public AnalyzedTypesInfoKey(Guid guid, short major, short minor, int lcid, int i
                 this.index = index;
             }
 
-            public override string ToString()
+            public override readonly string ToString()
             {
                 return string.Format(CultureInfo.InvariantCulture, "{0}.{1}.{2}.{3}:{4}",
                     this.guid, this.wMajorVerNum,
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 36fd9b90a26..24921740b27 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -21,7 +21,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// A task that copies files.
     /// </summary>
-    public class Copy : TaskExtension, ICancelableTask
+    public class Copy : TaskExtension, IIncrementalTask, ICancelableTask
     {
         internal const string AlwaysRetryEnvVar = "MSBUILDALWAYSRETRY";
         internal const string AlwaysOverwriteReadOnlyFilesEnvVar = "MSBUILDALWAYSOVERWRITEREADONLYFILES";
@@ -153,6 +153,8 @@ public Copy()
         /// </summary>
         public bool OverwriteReadOnlyFiles { get; set; }
 
+        public bool FailIfNotIncremental { get; set; }
+
         #endregion
 
         /// <summary>
@@ -256,8 +258,16 @@ private void LogDiagnostic(string message, params object[] messageArgs)
             {
                 if (!FileSystems.Default.DirectoryExists(destinationFolder))
                 {
-                    Log.LogMessage(MessageImportance.Normal, CreatesDirectory, destinationFolder);
-                    Directory.CreateDirectory(destinationFolder);
+                    if (FailIfNotIncremental)
+                    {
+                        Log.LogError(CreatesDirectory, destinationFolder);
+                        return false;
+                    }
+                    else
+                    {
+                        Log.LogMessage(MessageImportance.Normal, CreatesDirectory, destinationFolder);
+                        Directory.CreateDirectory(destinationFolder);
+                    }
                 }
 
                 // It's very common for a lot of files to be copied to the same folder. 
@@ -266,6 +276,14 @@ private void LogDiagnostic(string message, params object[] messageArgs)
                 _directoriesKnownToExist.TryAdd(destinationFolder, true);
             }
 
+            if (FailIfNotIncremental)
+            {
+                string sourceFilePath = FileUtilities.GetFullPathNoThrow(sourceFileState.Name);
+                string destinationFilePath = FileUtilities.GetFullPathNoThrow(destinationFileState.Name);
+                Log.LogError(FileComment, sourceFilePath, destinationFilePath);
+                return false;
+            }
+
             if (OverwriteReadOnlyFiles)
             {
                 MakeFileWriteable(destinationFileState, true);
@@ -740,6 +758,7 @@ private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationF
                         "true");
                     MSBuildEventSource.Log.CopyUpToDateStop(destinationFileState.Name, true);
                 }
+
                 // We only do the cheap check for identicalness here, we try the more expensive check
                 // of comparing the fullpaths of source and destination to see if they are identical,
                 // in the exception handler lower down.
@@ -749,7 +768,16 @@ private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationF
                              StringComparison.OrdinalIgnoreCase))
                 {
                     MSBuildEventSource.Log.CopyUpToDateStop(destinationFileState.Name, false);
-                    success = DoCopyWithRetries(sourceFileState, destinationFileState, copyFile);
+
+                    if (FailIfNotIncremental)
+                    {
+                        Log.LogError(FileComment, sourceFileState.Name, destinationFileState.Name);
+                        success = false;
+                    }
+                    else
+                    {
+                        success = DoCopyWithRetries(sourceFileState, destinationFileState, copyFile);
+                    }
                 }
                 else
                 {
diff --git a/src/Tasks/Delete.cs b/src/Tasks/Delete.cs
index bd782dd8bae..0dbe2f78609 100644
--- a/src/Tasks/Delete.cs
+++ b/src/Tasks/Delete.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Delete files from disk.
     /// </summary>
-    public class Delete : TaskExtension, ICancelableTask
+    public class Delete : TaskExtension, ICancelableTask, IIncrementalTask
     {
         #region Properties
 
@@ -57,6 +57,12 @@ public ITaskItem[] Files
 
         #endregion
 
+        /// <summary>
+        /// Set question parameter to verify if this is incremental.
+        /// </summary>
+        /// <remarks></remarks>
+        public bool FailIfNotIncremental { get; set; }
+
         /// <summary>
         /// Verify that the inputs are correct.
         /// </summary>
@@ -115,10 +121,17 @@ public override bool Execute()
                     {
                         if (FileSystems.Default.FileExists(file.ItemSpec))
                         {
-                            // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
-                            Log.LogMessageFromResources(MessageImportance.Normal, "Delete.DeletingFile", file.ItemSpec);
-
-                            File.Delete(file.ItemSpec);
+                            if (FailIfNotIncremental)
+                            {
+                                Log.LogErrorFromResources("Delete.DeletingFile", file.ItemSpec);
+                            }
+                            else
+                            {
+                                // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
+                                Log.LogMessageFromResources(MessageImportance.Normal, "Delete.DeletingFile", file.ItemSpec);
+
+                                File.Delete(file.ItemSpec);
+                            }
                         }
                         else
                         {
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index 3f9c6d5bc8e..8119588a35f 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -5,6 +5,7 @@
 using System.IO;
 using System.Net;
 using System.Net.Http;
+using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
@@ -18,7 +19,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Represents a task that can download a file.
     /// </summary>
-    public sealed class DownloadFile : TaskExtension, ICancelableTask
+    public sealed class DownloadFile : TaskExtension, ICancelableTask, IIncrementalTask
     {
         private readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
 
@@ -65,6 +66,8 @@ public sealed class DownloadFile : TaskExtension, ICancelableTask
         /// </summary>
         public int Timeout { get; set; } = 100_000;
 
+        public bool FailIfNotIncremental { get; set; }
+
         /// <summary>
         /// Gets or sets a <see cref="HttpMessageHandler"/> to use.  This is used by unit tests to mock a connection to a remote server.
         /// </summary>
@@ -125,7 +128,15 @@ private async Task<bool> ExecuteAsync()
                     }
                     else
                     {
-                        Log.LogErrorWithCodeFromResources("DownloadFile.ErrorDownloading", SourceUrl, actualException.ToString());
+                        StringBuilder flattenedMessage = new StringBuilder(actualException.Message);
+                        Exception excep = actualException;
+                        while (excep.InnerException != null)
+                        {
+                            excep = excep.InnerException;
+                            flattenedMessage.Append(" ---> ").Append(excep.Message);
+                        }
+                        Log.LogErrorWithCodeFromResources("DownloadFile.ErrorDownloading", SourceUrl, flattenedMessage.ToString());
+                        Log.LogMessage(MessageImportance.Low, actualException.ToString());
                         break;
                     }
                 }
@@ -183,6 +194,11 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
 
                         return;
                     }
+                    else if (FailIfNotIncremental)
+                    {
+                        Log.LogErrorFromResources("DownloadFile.Downloading", SourceUrl, destinationFile.FullName, response.Content.Headers.ContentLength);
+                        return;
+                    }
 
                     try
                     {
diff --git a/src/Tasks/FileIO/WriteLinesToFile.cs b/src/Tasks/FileIO/WriteLinesToFile.cs
index 3d9208e599e..7ae0228c8e5 100644
--- a/src/Tasks/FileIO/WriteLinesToFile.cs
+++ b/src/Tasks/FileIO/WriteLinesToFile.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Appends a list of items to a file. One item per line with carriage returns in-between.
     /// </summary>
-    public class WriteLinesToFile : TaskExtension
+    public class WriteLinesToFile : TaskExtension, IIncrementalTask
     {
         // Default encoding taken from System.IO.WriteAllText()
         private static readonly Encoding s_defaultEncoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true);
@@ -48,6 +48,14 @@ public class WriteLinesToFile : TaskExtension
         /// </summary>
         public bool WriteOnlyWhenDifferent { get; set; }
 
+        /// <summary>
+        /// Question whether this task is incremental.
+        /// </summary>
+        /// <remarks>When question is true, then this task would not write to disk.  If CanBeIncremental is true, then error out.</remarks>
+        public bool FailIfNotIncremental { get; set; }
+
+        public bool CanBeIncremental => WriteOnlyWhenDifferent;
+
         /// <summary>
         /// Execute the task.
         /// </summary>
@@ -61,7 +69,7 @@ public override bool Execute()
                 // do not return if Lines is null, because we may
                 // want to delete the file in that case
                 StringBuilder buffer = new StringBuilder();
-                if (Lines != null)
+                if (Lines != null && (!FailIfNotIncremental || WriteOnlyWhenDifferent))
                 {
                     foreach (ITaskItem line in Lines)
                     {
@@ -108,6 +116,11 @@ public override bool Execute()
                                             MSBuildEventSource.Log.WriteLinesToFileUpToDateStop(File.ItemSpec, true);
                                             return true;
                                         }
+                                        else if (FailIfNotIncremental)
+                                        {
+                                            Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorReadingFile", File.ItemSpec);
+                                            return false;
+                                        }
                                     }
                                 }
                             }
@@ -118,16 +131,33 @@ public override bool Execute()
                             MSBuildEventSource.Log.WriteLinesToFileUpToDateStop(File.ItemSpec, false);
                         }
 
-                        System.IO.File.WriteAllText(File.ItemSpec, contentsAsString, encoding);
+                        if (FailIfNotIncremental)
+                        {
+                            Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorReadingFile", File.ItemSpec);
+                            return false;
+                        }
+                        else
+                        {
+                            System.IO.File.WriteAllText(File.ItemSpec, contentsAsString, encoding);
+                        }
                     }
                     else
                     {
-                        if (WriteOnlyWhenDifferent && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+                        if (FailIfNotIncremental)
                         {
-                            Log.LogWarningWithCodeFromResources("WriteLinesToFile.UnusedWriteOnlyWhenDifferent", File.ItemSpec);
+                            Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorOrWarning", File.ItemSpec, string.Empty);
+                            return false;
+                        }
+                        else
+                        {
+                            if (WriteOnlyWhenDifferent)
+                            {
+                                Log.LogMessageFromResources(MessageImportance.Normal, "WriteLinesToFile.UnusedWriteOnlyWhenDifferent", File.ItemSpec);
+                            }
+
+                            Directory.CreateDirectory(directoryPath);
+                            System.IO.File.AppendAllText(File.ItemSpec, buffer.ToString(), encoding);
                         }
-                        Directory.CreateDirectory(directoryPath);
-                        System.IO.File.AppendAllText(File.ItemSpec, buffer.ToString(), encoding);
                     }
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index fe22b568293..6ff6c0a5dff 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -53,7 +53,7 @@ namespace Microsoft.Build.Tasks
     /// to transform resource files.
     /// </summary>
     [RequiredRuntime("v2.0")]
-    public sealed partial class GenerateResource : TaskExtension
+    public sealed partial class GenerateResource : TaskExtension, IIncrementalTask
     {
 
         #region Fields
@@ -274,6 +274,12 @@ public string StronglyTypedLanguage
             }
         }
 
+        // Indicates whether any BinaryFormatter use should lead to a warning.
+        public bool WarnOnBinaryFormatterUse
+        {
+            get; set;
+        }
+
         /// <summary>
         /// Specifies the namespace to use for the generated class source for the
         /// strongly typed resource. If left blank, no namespace is used.
@@ -546,6 +552,8 @@ public GenerateResource()
             // do nothing
         }
 
+        public bool FailIfNotIncremental { get; set; }
+
         /// <summary>
         /// Logs a Resgen.exe command line that indicates what parameters were
         /// passed to this task. Since this task is replacing Resgen, and we used
@@ -715,6 +723,10 @@ public override bool Execute()
 
                     Log.LogMessageFromResources("GenerateResource.NothingOutOfDate");
                 }
+                else if (FailIfNotIncremental)
+                {
+                    Log.LogErrorFromResources("GenerateResource.OutOfDate");
+                }
                 else
                 {
                     if (!ComputePathToResGen())
@@ -808,7 +820,8 @@ public override bool Execute()
                                         StronglyTypedClassName,
                                         PublicClass,
                                         ExtractResWFiles,
-                                        OutputDirectory);
+                                        OutputDirectory,
+                                        WarnOnBinaryFormatterUse);
 
                             this.StronglyTypedClassName = process.StronglyTypedClassName; // in case a default was chosen
                             this.StronglyTypedFileName = process.StronglyTypedFilename;   // in case a default was chosen
@@ -1510,7 +1523,7 @@ private bool ShouldRebuildResgenOutputFile(string sourceFilePath, string outputF
             ResGenDependencies.ResXFile resxFileInfo;
             try
             {
-                resxFileInfo = _cache.GetResXFileInfo(sourceFilePath, UsePreserializedResources);
+                resxFileInfo = _cache.GetResXFileInfo(sourceFilePath, UsePreserializedResources, Log, WarnOnBinaryFormatterUse);
             }
             catch (Exception e) when (!ExceptionHandling.NotExpectedIoOrXmlException(e) || e is MSBuildResXException)
             {
@@ -1971,7 +1984,7 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
         {
             byte[] serializedData = ByteArrayFromBase64WrappedString(data);
 
-            BinaryFormatter binaryFormatter = new BinaryFormatter();
+            BinaryFormatter binaryFormatter = new();
 
             using (MemoryStream memoryStream = new MemoryStream(serializedData))
             {
@@ -2337,6 +2350,8 @@ internal bool StronglyTypedResourceSuccessfullyCreated
         /// </summary>
         private bool _useSourcePath = false;
 
+        private bool _logWarningForBinaryFormatter = false;
+
         #endregion
 
         /// <summary>
@@ -2357,7 +2372,8 @@ internal void Run(
             string classname,
             bool publicClass,
             bool extractingResWFiles,
-            string resWOutputDirectory)
+            string resWOutputDirectory,
+            bool logWarningForBinaryFormatter)
         {
             _logger = log;
             _assemblyFiles = assemblyFilesList;
@@ -2376,6 +2392,7 @@ internal void Run(
             _resWOutputDirectory = resWOutputDirectory;
             _portableLibraryCacheInfo = new List<ResGenDependencies.PortableLibraryFile>();
             _usePreserializedResources = usePreserializedResources;
+            _logWarningForBinaryFormatter = logWarningForBinaryFormatter;
 
 #if !FEATURE_ASSEMBLYLOADCONTEXT
             // If references were passed in, we will have to give the ResxResourceReader an object
@@ -2980,7 +2997,7 @@ private void ReadResources(String filename, bool shouldUseSourcePath, String out
                             }
                             else
                             {
-                                foreach (IResource resource in MSBuildResXReader.GetResourcesFromFile(filename, shouldUseSourcePath))
+                                foreach (IResource resource in MSBuildResXReader.GetResourcesFromFile(filename, shouldUseSourcePath, _logger, _logWarningForBinaryFormatter))
                                 {
                                     AddResource(reader, resource, filename, 0, 0);
                                 }
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
index 2b81a9dca99..daec24f865d 100644
--- a/src/Tasks/GetCompatiblePlatform.cs
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -59,8 +59,9 @@ public override bool Execute()
                 string referencedProjectPlatform = AssignedProjectsWithPlatform[i].GetMetadata("Platform");
                 string projectReferencePlatformsMetadata = AssignedProjectsWithPlatform[i].GetMetadata("Platforms");
                 string projectReferenceLookupTableMetadata = AssignedProjectsWithPlatform[i].GetMetadata("PlatformLookupTable");
+                string projectReferenceOverridePlatformNegotiationMetadata = AssignedProjectsWithPlatform[i].GetMetadata("OverridePlatformNegotiationValue");
 
-                string? buildProjectReferenceAs = PlatformNegotiation.GetNearestPlatform(referencedProjectPlatform, projectReferencePlatformsMetadata, projectReferenceLookupTableMetadata, PlatformLookupTable, AssignedProjectsWithPlatform[i].ItemSpec, CurrentProjectPlatform, Log);
+                string? buildProjectReferenceAs = PlatformNegotiation.GetNearestPlatform(projectReferenceOverridePlatformNegotiationMetadata, referencedProjectPlatform, projectReferencePlatformsMetadata, projectReferenceLookupTableMetadata, PlatformLookupTable, AssignedProjectsWithPlatform[i].ItemSpec, CurrentProjectPlatform, Log);
 
                 AssignedProjectsWithPlatform[i].SetMetadata("NearestPlatform", buildProjectReferenceAs);
                 Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.DisplayChosenPlatform", AssignedProjectsWithPlatform[i].ItemSpec, buildProjectReferenceAs);
diff --git a/src/Tasks/MakeDir.cs b/src/Tasks/MakeDir.cs
index 4b5412534b0..eb7d2ef3281 100644
--- a/src/Tasks/MakeDir.cs
+++ b/src/Tasks/MakeDir.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// A task that creates a directory
     /// </summary>
-    public class MakeDir : TaskExtension
+    public class MakeDir : TaskExtension, IIncrementalTask
     {
         [Required]
         public ITaskItem[] Directories
@@ -31,6 +31,8 @@ public ITaskItem[] Directories
         [Output]
         public ITaskItem[] DirectoriesCreated { get; private set; }
 
+        public bool FailIfNotIncremental { get; set; }
+
         private ITaskItem[] _directories;
 
         #region ITask Members
@@ -59,10 +61,17 @@ public override bool Execute()
                             // Only log a message if we actually need to create the folder
                             if (!FileUtilities.DirectoryExistsNoThrow(directory.ItemSpec))
                             {
-                                // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
-                                Log.LogMessageFromResources(MessageImportance.Normal, "MakeDir.Comment", directory.ItemSpec);
+                                if (FailIfNotIncremental)
+                                {
+                                    Log.LogErrorFromResources("MakeDir.Comment", directory.ItemSpec);
+                                }
+                                else
+                                {
+                                    // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
+                                    Log.LogMessageFromResources(MessageImportance.Normal, "MakeDir.Comment", directory.ItemSpec);
 
-                                Directory.CreateDirectory(FileUtilities.FixFilePath(directory.ItemSpec));
+                                    Directory.CreateDirectory(FileUtilities.FixFilePath(directory.ItemSpec));
+                                }
                             }
 
                             items.Add(directory);
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index f3ff18c2862..a7ab39b6a7e 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -102,6 +102,9 @@
     <Compile Include="..\Shared\StrongNameHelpers.cs">
       <Link>StrongNameHelpers.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\SolutionConfiguration.cs">
+      <Link>SolutionConfiguration.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\TaskLoggingHelperExtension.cs">
       <Link>TaskLoggingHelperExtension.cs</Link>
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
@@ -147,9 +150,6 @@
     <Compile Include="..\Shared\AssemblyNameExtension.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\EncodingUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\ErrorUtilities.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 69b7c661777..3c88dc06d8b 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1232,7 +1232,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         RootPath="$(TargetFrameworkRootPath)"
         TargetFrameworkFallbackSearchPaths="$(TargetFrameworkFallbackSearchPaths)"
         BypassFrameworkInstallChecks="$(BypassFrameworkInstallChecks)"
-        >
+        ContinueOnError="!$(BuildingProject)">
       <Output TaskParameter="ReferenceAssemblyPaths" PropertyName="_TargetFrameworkDirectories"/>
       <Output TaskParameter="FullFrameworkReferenceAssemblyPaths" PropertyName="_FullFrameworkReferenceAssemblyPaths"/>
       <Output TaskParameter="TargetFrameworkMonikerDisplayName" PropertyName="TargetFrameworkMonikerDisplayName" Condition="'$(TargetFrameworkMonikerDisplayName)' == ''"/>
@@ -1471,6 +1471,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       ResolveNativeReferences;
       ResolveAssemblyReferences;
       GenerateBindingRedirects;
+      GenerateBindingRedirectsUpdateAppConfig;
       ResolveComReferences;
       AfterResolveReferences
     </ResolveReferencesDependsOn>
@@ -1631,11 +1632,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <UseDefaultPlatformLookupTables Condition="'$(UseDefaultPlatformLookupTables)' == ''">true</UseDefaultPlatformLookupTables>
   </PropertyGroup>
 
-  <!-- This target skips VS builds because they already supply Platform and
-       Configuration information. -->
+  <!-- This target skips sln-based builds because they already supply Platform and
+       Configuration information. See AssignProjectConfiguration -->
   <Target Name="_GetProjectReferencePlatformProperties"
           Condition="'$(EnableDynamicPlatformResolution)' == 'true'
-                     and '$(BuildingInsideVisualStudio)' != 'true'
+                     and '$(CurrentSolutionConfigurationContents)' == ''
                      and '@(_MSBuildProjectReferenceExistent)' != ''">
 
     <!-- Allow preset SetPlatform to override this operation -->
@@ -2464,20 +2465,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ====================================================================================================
   -->
   <Target Name="GenerateBindingRedirects"
-    Inputs="$(MSBuildAllProjects);@(AppConfigFile);$(ResolveAssemblyReferencesStateFile);$(SuggestedBindingRedirectsCacheFile)"
+    Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath);$(ResolveAssemblyReferencesStateFile);$(SuggestedBindingRedirectsCacheFile)"
     Outputs="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true'"
+    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and '@(SuggestedBindingRedirects)' != ''"
     DependsOnTargets="_GenerateSuggestedBindingRedirectsCache">
 
     <GenerateBindingRedirects
       AppConfigFile="@(AppConfigWithTargetPath)"
       TargetName="$(TargetFileName).config"
       OutputAppConfigFile="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-      SuggestedRedirects="@(SuggestedBindingRedirects)"
-      >
-      <Output TaskParameter="OutputAppConfigFile" ItemName="FileWrites" />
-    </GenerateBindingRedirects>
+      SuggestedRedirects="@(SuggestedBindingRedirects)" />
 
+    <ItemGroup>
+      <FileWrites Include="$(_GenerateBindingRedirectsIntermediateAppConfig)" />
+    </ItemGroup>
   </Target>
 
   <!--
@@ -2489,20 +2490,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ====================================================================================================
   -->
   <Target Name="GenerateBindingRedirectsUpdateAppConfig"
-    AfterTargets="GenerateBindingRedirects"
-    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')">
+    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true'">
 
     <PropertyGroup>
-      <AppConfig>$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
+      <_NewGenerateBindingRedirectsIntermediateAppConfig Condition="Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')">true</_NewGenerateBindingRedirectsIntermediateAppConfig>
+      <AppConfig Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
     </PropertyGroup>
-
-    <ItemGroup>
+    
+    <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
       <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
       <AppConfigWithTargetPath Include="$(AppConfig)">
         <TargetPath>$(TargetFileName).config</TargetPath>
       </AppConfigWithTargetPath>
     </ItemGroup>
-
   </Target>
 
   <!--
@@ -3328,8 +3328,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         SdkToolsPath="$(ResgenToolPath)"
         ExecuteAsTool="$(ResGenExecuteAsTool)"
         EnvironmentVariables="$(ResGenEnvironment)"
+        WarnOnBinaryFormatterUse="$(GenerateResourceWarnOnBinaryFormatterUse)"
         MSBuildRuntime="$(GenerateResourceMSBuildRuntime)"
-        MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)">
+        MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)"
+        >
 
       <Output TaskParameter="FilesWritten" ItemName="FileWrites"/>
       <Output TaskParameter="StronglyTypedFileName" ItemName="Compile"/>
@@ -3581,7 +3583,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           DependsOnTargets="PrepareForBuild;GetReferenceAssemblyPaths"
           Inputs="$(MSBuildToolsPath)\Microsoft.Common.targets"
           Outputs="$(TargetFrameworkMonikerAssemblyAttributesPath)"
-          Condition="'$(GenerateTargetFrameworkAttribute)' == 'true'">
+          Condition="'@(Compile)' != '' and '$(GenerateTargetFrameworkAttribute)' == 'true'">
 
     <!-- This is a file shared between projects so we have to take care to handle simultaneous writes (by ContinueOnError)
              and a race between clean from one project and build from another (by not adding to FilesWritten so it doesn't clean) -->
@@ -5671,7 +5673,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <MakeDir Directories="$(IntermediateOutputPath)"/>
 
     <!-- Write new list of current files back to disk. -->
-    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWrites)" Overwrite="true" />
+    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWrites)" WriteOnlyWhenDifferent="true" Overwrite="true" />
 
   </Target>
 
@@ -5703,7 +5705,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <WriteLinesToFile
         File="$(IntermediateOutputPath)$(CleanFile)"
         Lines="@(_CleanUniqueFileWrites)"
-        Overwrite="true" />
+        Overwrite="true"
+        WriteOnlyWhenDifferent="true" />
 
   </Target>
 
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index d91e88e9861..beab1878e60 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -16,9 +16,9 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.AssignTargetPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CallTarget"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CombinePath"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.ConvertToAbsolutePath"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties"  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CombineXmlElements"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ConvertToAbsolutePath"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Copy"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CreateCSharpManifestResourceName"      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.CreateItem"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -32,7 +32,6 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.FindAppConfigFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.FindInList"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.FindInvalidProjectReferences"          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-
   <UsingTask TaskName="Microsoft.Build.Tasks.FindUnderPath"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.FormatUrl"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.FormatVersion"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -53,8 +52,9 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFileHash"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetInstalledSDKLocations"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.GetReferenceAssemblyPaths"             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.SetRidAgnosticValueForProjects"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.GetSDKReferenceFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Hash"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.LC"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.MakeDir"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -72,15 +72,13 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.RequiresFramework35SP1Assembly"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveAssemblyReference"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet"            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.GetInstalledSDKLocations"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.GetSDKReferenceFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveComReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveKeySource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveManifestFiles"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveNativeReference"                AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.ResolveSDKReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.SetRidAgnosticValueForProjects"        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.SGen"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.SignFile"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Telemetry"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
@@ -90,21 +88,21 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
   <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Unzip"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.VerifyFileHash"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Warning"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.WinMDExp"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.WriteCodeFragment"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.WriteLinesToFile"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.XmlPeek"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.XmlPoke"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.XslTransformation"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
-  <UsingTask TaskName="Microsoft.Build.Tasks.WinMDExp"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ZipDirectory"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
   <!-- Roslyn tasks are now in an assembly owned and shipped by Roslyn -->
+  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Csc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
-  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
 
 </Project>
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
index 68a7e8d274d..88d7d0b07df 100644
--- a/src/Tasks/Microsoft.Managed.After.targets
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -36,17 +36,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       Properties for extension of ProjectReferenceTargets.
       Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.
   -->
-  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
-    <!-- Empty case is for outer builds which do not import the target files that set BuildProjectReferences -->
+  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' != 'true'">
+    <!-- Empty case is for builds which do not import the target files that set BuildProjectReferences -->
     <_MainReferenceTargetForBuild Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>
     <_MainReferenceTargetForBuild Condition="'$(_MainReferenceTargetForBuild)' == ''">GetTargetPath</_MainReferenceTargetForBuild>
 
     <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
 
-    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
-
-    <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
-
     <!-- Publish has the same logic as Build for the main reference target except it also takes $(NoBuild) into account. -->
     <_MainReferenceTargetForPublish Condition="'$(NoBuild)' == 'true'">GetTargetPath</_MainReferenceTargetForPublish>
     <_MainReferenceTargetForPublish Condition="'$(NoBuild)' != 'true'">$(_MainReferenceTargetForBuild)</_MainReferenceTargetForPublish>
@@ -58,23 +54,30 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)</ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' == 'true'">
+    <ProjectReferenceTargetsForBuild>.default;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
+    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
+    <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
+  </PropertyGroup>
 
   <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true" />
-    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" />
+    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
 
     <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true" />
-    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" />
+    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
     <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForClean)" Condition=" '$(ProjectReferenceTargetsForClean)' != '' " />
 
     <!--
      Note: SkipNonexistentTargets="true" on the following three items means that an outer build node's call to its existent GetTargetFrameworks target will fail if its inner build nodes don't define GetTargetFrameworksWithPlatformForSingleTargetFrameworks.
      This is necessary since the P2P protocol cannot express the targets called from the outer build to the inner build.
      -->
-    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" />
-    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" />
-    <ProjectReferenceTargets Include="Rebuild" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" />
+    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
+    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
+    <ProjectReferenceTargets Include="Rebuild" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
 
     <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuild)" Condition=" '$(ProjectReferenceTargetsForRebuild)' != '' " />
 
@@ -83,4 +86,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ProjectReferenceTargets Include="GetCopyToPublishDirectoryItems" Targets="$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)" Condition=" '$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)' != '' " />
   </ItemGroup>
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/Tasks/Move.cs b/src/Tasks/Move.cs
index 42f0e20b968..746ce275be7 100644
--- a/src/Tasks/Move.cs
+++ b/src/Tasks/Move.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.Tasks
     /// but this could restriction could be lifted as MoveFileEx,
     /// which is used here, supports it.
     /// </remarks>
-    public class Move : TaskExtension, ICancelableTask
+    public class Move : TaskExtension, ICancelableTask, IIncrementalTask
     {
         /// <summary>
         /// Flags for MoveFileEx.
@@ -62,11 +62,19 @@ public class Move : TaskExtension, ICancelableTask
         public ITaskItem[] DestinationFiles { get; set; }
 
         /// <summary>
-        /// Subset that were successfully moved 
+        /// Subset that were successfully moved.
         /// </summary>
         [Output]
         public ITaskItem[] MovedFiles { get; private set; }
 
+        /// <summary>
+        /// Set question parameter for Move task.
+        /// </summary>
+        /// <remarks>Move can be chained A->B->C with location C as the final location.
+        /// Incrementally, it is hard to question A->B if both files are gone.
+        /// In short, question will always return false and author should use target inputs/outputs.</remarks>
+        public bool FailIfNotIncremental { get; set; }
+
         /// <summary>
         /// Stop and return (in an undefined state) as soon as possible.
         /// </summary>
@@ -149,7 +157,7 @@ public override bool Execute()
 
                 try
                 {
-                    if (MoveFileWithLogging(sourceFile, destinationFile))
+                    if (!FailIfNotIncremental && MoveFileWithLogging(sourceFile, destinationFile))
                     {
                         SourceFiles[i].CopyMetadataTo(DestinationFiles[i]);
                         destinationFilesSuccessfullyMoved.Add(DestinationFiles[i]);
@@ -175,7 +183,7 @@ public override bool Execute()
         }
 
         /// <summary>
-        /// Makes the provided file writeable if necessary
+        /// Makes the provided file writeable if necessary.
         /// </summary>
         private static void MakeWriteableIfReadOnly(string file)
         {
@@ -189,7 +197,7 @@ private static void MakeWriteableIfReadOnly(string file)
         /// <summary>
         /// Move one file from source to destination. Create the target directory if necessary.
         /// </summary>
-        /// <throws>IO related exceptions</throws>
+        /// <throws>IO related exceptions.</throws>
         private bool MoveFileWithLogging(
             string sourceFile,
             string destinationFile)
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index a55f04aa68c..c173abab5b9 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -809,7 +809,7 @@ internal static bool MakeHardLink(string newFileName, string exitingFileName, re
             else
             {
                 hardLinkCreated = link(exitingFileName, newFileName) == 0;
-                errorMessage = hardLinkCreated ? null : log.FormatResourceString("Copy.LinklibraryFailedPrefix", "link()", Marshal.GetLastWin32Error());
+                errorMessage = hardLinkCreated ? null : log.FormatResourceString("Copy.NonWindowsLinkErrorMessage", "link()", Marshal.GetLastWin32Error());
             }
 
             return hardLinkCreated;
diff --git a/src/Tasks/RemoveDir.cs b/src/Tasks/RemoveDir.cs
index da78951a376..3e43ca69a80 100644
--- a/src/Tasks/RemoveDir.cs
+++ b/src/Tasks/RemoveDir.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Remove the specified directories.
     /// </summary>
-    public class RemoveDir : TaskExtension
+    public class RemoveDir : TaskExtension, IIncrementalTask
     {
         //-----------------------------------------------------------------------------------
         // Property:  directory to remove
@@ -41,6 +41,8 @@ public ITaskItem[] Directories
         [Output]
         public ITaskItem[] RemovedDirectories { get; set; }
 
+        public bool FailIfNotIncremental { get; set; }
+
         //-----------------------------------------------------------------------------------
         // Execute -- this runs the task
         //-----------------------------------------------------------------------------------
@@ -61,6 +63,12 @@ public override bool Execute()
 
                 if (FileSystems.Default.DirectoryExists(directory.ItemSpec))
                 {
+                    if (FailIfNotIncremental)
+                    {
+                        Log.LogErrorFromResources("RemoveDir.Removing", directory.ItemSpec);
+                        continue;
+                    }
+
                     // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
                     Log.LogMessageFromResources(MessageImportance.Normal, "RemoveDir.Removing", directory.ItemSpec);
 
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index ea0be01f3fa..2a3c042cff0 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -125,13 +125,13 @@ public override void Translate(ITranslator translator)
             translator.Translate(ref baseLinkedFileDirectory);
         }
 
-        internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader)
+        internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
         {
             // First, try to retrieve the resx information from our hashtable.
             if (!resXFiles.TryGetValue(resxFile, out ResXFile retVal))
             {
                 // Ok, the file wasn't there.  Add it to our cache and return it to the caller.  
-                retVal = AddResxFile(resxFile, useMSBuildResXReader);
+                retVal = AddResxFile(resxFile, useMSBuildResXReader, log, logWarningForBinaryFormatter);
             }
             else
             {
@@ -141,19 +141,19 @@ internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader)
                 {
                     resXFiles.Remove(resxFile);
                     _isDirty = true;
-                    retVal = AddResxFile(resxFile, useMSBuildResXReader);
+                    retVal = AddResxFile(resxFile, useMSBuildResXReader, log, logWarningForBinaryFormatter);
                 }
             }
 
             return retVal;
         }
 
-        private ResXFile AddResxFile(string file, bool useMSBuildResXReader)
+        private ResXFile AddResxFile(string file, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
         {
             // This method adds a .resx file "file" to our .resx cache.  The method causes the file
             // to be cracked for contained files.
 
-            var resxFile = new ResXFile(file, BaseLinkedFileDirectory, useMSBuildResXReader);
+            var resxFile = new ResXFile(file, BaseLinkedFileDirectory, useMSBuildResXReader, log, logWarningForBinaryFormatter);
             resXFiles.Add(file, resxFile);
             _isDirty = true;
             return resxFile;
@@ -230,7 +230,7 @@ internal sealed class ResXFile : DependencyFile, ITranslatable
 
             internal string[] LinkedFiles => linkedFiles;
 
-            internal ResXFile(string filename, string baseLinkedFileDirectory, bool useMSBuildResXReader) : base(filename)
+            internal ResXFile(string filename, string baseLinkedFileDirectory, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter) : base(filename)
             {
                 // Creates a new ResXFile object and populates the class member variables
                 // by computing a list of linked files within the .resx that was passed in.
@@ -239,7 +239,7 @@ internal ResXFile(string filename, string baseLinkedFileDirectory, bool useMSBui
 
                 if (FileSystems.Default.FileExists(FileName))
                 {
-                    linkedFiles = GetLinkedFiles(filename, baseLinkedFileDirectory, useMSBuildResXReader);
+                    linkedFiles = GetLinkedFiles(filename, baseLinkedFileDirectory, useMSBuildResXReader, log, logWarningForBinaryFormatter);
                 }
             }
 
@@ -260,7 +260,7 @@ public void Translate(ITranslator translator)
             /// </summary>
             /// <exception cref="ArgumentException">May be thrown if Resx is invalid. May contain XmlException.</exception>
             /// <exception cref="XmlException">May be thrown if Resx is invalid</exception>
-            private static string[] GetLinkedFiles(string filename, string baseLinkedFileDirectory, bool useMSBuildResXReader)
+            private static string[] GetLinkedFiles(string filename, string baseLinkedFileDirectory, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
             {
                 // This method finds all linked .resx files for the .resx file that is passed in.
                 // filename is the filename of the .resx file that is to be examined.
@@ -270,7 +270,7 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir
 
                 if (useMSBuildResXReader)
                 {
-                    foreach (IResource resource in MSBuildResXReader.GetResourcesFromFile(filename, pathsRelativeToBasePath: baseLinkedFileDirectory == null))
+                    foreach (IResource resource in MSBuildResXReader.GetResourcesFromFile(filename, pathsRelativeToBasePath: baseLinkedFileDirectory == null, log, logWarningForBinaryFormatter))
                     {
                         if (resource is FileStreamResource linkedResource)
                         {
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index be85bca1a5f..deade89479b 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -158,7 +158,7 @@ private bool ResolveAssemblyKey()
                             fs?.Close();
                         }
 #else
-                        Log.LogError("PFX signing not supported on .NET Core");
+                        Log.LogErrorWithCodeFromResources("ResolveKeySource.PfxUnsupported");
                         pfxSuccess = false;
 #endif
                     }
@@ -266,7 +266,7 @@ private bool ResolveManifestKey()
                     }
                 }
 #else
-                Log.LogError("Certificate signing not supported on .NET Core");
+                Log.LogErrorWithCodeFromResources("ResolveKeySource.PfxUnsupported");
 #endif
             }
             else if (!certInStore && !string.IsNullOrEmpty(CertificateFile) && !string.IsNullOrEmpty(CertificateThumbprint))
diff --git a/src/Tasks/ResolveProjectBase.cs b/src/Tasks/ResolveProjectBase.cs
index 7be78aa7458..d70b7805f11 100644
--- a/src/Tasks/ResolveProjectBase.cs
+++ b/src/Tasks/ResolveProjectBase.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
-using System.IO;
 using System.Xml;
 
 using Microsoft.Build.Framework;
@@ -42,25 +41,10 @@ public ITaskItem[] ProjectReferences
         // This field stores all the distinct project references by project absolute path
         private readonly HashSet<string> _cachedProjectReferencesByAbsolutePath = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
-        // This field stores pre-cached project elements for project guids for quicker access by project guid
-        private readonly Dictionary<string, XmlElement> _cachedProjectElements = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
-
-        // This field stores pre-cached project elements for project guids for quicker access by project absolute path
-        private readonly Dictionary<string, XmlElement> _cachedProjectElementsByAbsolutePath = new Dictionary<string, XmlElement>(StringComparer.OrdinalIgnoreCase);
-
-        // This field stores the project absolute path for quicker access by project guid
-        private readonly Dictionary<string, string> _cachedProjectAbsolutePathsByGuid = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-
-        // This field stores the project guid for quicker access by project absolute path
-        private readonly Dictionary<string, string> _cachedProjectGuidsByAbsolutePath = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-
-        // This field stores the list of dependency project guids by depending project guid
-        private readonly Dictionary<string, List<string>> _cachedDependencyProjectGuidsByDependingProjectGuid = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase);
+        private SolutionConfiguration _solutionConfiguration = SolutionConfiguration.Empty;
 
         private const string attributeProject = "Project";
 
-        private const string attributeAbsolutePath = "AbsolutePath";
-
         #endregion
 
         #region Methods
@@ -121,86 +105,7 @@ internal bool VerifyProjectReferenceItems(ITaskItem[] references, bool treatAsEr
         /// <summary>
         /// Pre-cache individual project elements from the XML string in a hashtable for quicker access.
         /// </summary>
-        internal void CacheProjectElementsFromXml(string xmlString)
-        {
-            // TODO: fix code clone for parsing CurrentSolutionConfiguration xml: https://github.com/dotnet/msbuild/issues/6751
-            XmlDocument doc = null;
-
-            if (!string.IsNullOrEmpty(xmlString))
-            {
-                doc = new XmlDocument();
-                var settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
-                using (XmlReader reader = XmlReader.Create(new StringReader(xmlString), settings))
-                {
-                    doc.Load(reader);
-                }
-            }
-
-            // Example:
-            //
-            // <SolutionConfiguration>
-            //  <ProjectConfiguration Project="{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}" AbsolutePath="c:foo\Project1\A.csproj" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
-            //  <ProjectConfiguration Project="{881C1674-4ECA-451D-85B6-D7C59B7F16FA}" AbsolutePath="c:foo\Project2\B.csproj" BuildProjectInSolution="True">Debug|AnyCPU<ProjectDependency Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" /></ProjectConfiguration>
-            //  <ProjectConfiguration Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" AbsolutePath="c:foo\Project3\C.csproj" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
-            // </SolutionConfiguration>
-            //
-            if (doc?.DocumentElement != null)
-            {
-                foreach (XmlElement xmlElement in doc.DocumentElement.ChildNodes)
-                {
-                    string projectGuid = xmlElement.GetAttribute(attributeProject);
-                    string projectAbsolutePath = xmlElement.GetAttribute(attributeAbsolutePath);
-
-                    // What we really want here is the normalized path, like we'd get with an item's "FullPath" metadata.  However, 
-                    // if there's some bogus full path in the solution configuration (e.g. a website with a "full path" of c:\solutiondirectory\http://localhost) 
-                    // we do NOT want to throw -- chances are extremely high that that's information that will never actually be used.  So resolve the full path 
-                    // but just swallow any IO-related exceptions that result.  If the path is bogus, the method will return null, so we'll just quietly fail 
-                    // to cache it below. 
-                    projectAbsolutePath = FileUtilities.GetFullPathNoThrow(projectAbsolutePath);
-
-                    if (!string.IsNullOrEmpty(projectGuid))
-                    {
-                        _cachedProjectElements[projectGuid] = xmlElement;
-                        if (!string.IsNullOrEmpty(projectAbsolutePath))
-                        {
-                            _cachedProjectElementsByAbsolutePath[projectAbsolutePath] = xmlElement;
-                            _cachedProjectAbsolutePathsByGuid[projectGuid] = projectAbsolutePath;
-                            _cachedProjectGuidsByAbsolutePath[projectAbsolutePath] = projectGuid;
-                        }
-
-                        foreach (XmlNode dependencyNode in xmlElement.ChildNodes)
-                        {
-                            if (dependencyNode.NodeType != XmlNodeType.Element)
-                            {
-                                continue;
-                            }
-
-                            XmlElement dependencyElement = ((XmlElement)dependencyNode);
-
-                            if (!String.Equals(dependencyElement.Name, "ProjectDependency", StringComparison.Ordinal))
-                            {
-                                continue;
-                            }
-
-                            string dependencyGuid = dependencyElement.GetAttribute("Project");
-
-                            if (dependencyGuid.Length == 0)
-                            {
-                                continue;
-                            }
-
-                            if (!_cachedDependencyProjectGuidsByDependingProjectGuid.TryGetValue(projectGuid, out List<string> list))
-                            {
-                                list = new List<string>();
-                                _cachedDependencyProjectGuidsByDependingProjectGuid.Add(projectGuid, list);
-                            }
-
-                            list.Add(dependencyGuid);
-                        }
-                    }
-                }
-            }
-        }
+        internal void CacheProjectElementsFromXml(string xmlString) => _solutionConfiguration = new SolutionConfiguration(xmlString);
 
         /// <summary>
         /// Helper method for retrieving whatever was stored in the XML string for the given project
@@ -219,7 +124,7 @@ protected XmlElement GetProjectElement(ITaskItem projectRef)
         {
             string projectGuid = projectRef.GetMetadata(attributeProject);
 
-            if ((_cachedProjectElements.TryGetValue(projectGuid, out XmlElement projectElement)) && (projectElement != null))
+            if (_solutionConfiguration.TryGetProjectByGuid(projectGuid, out XmlElement projectElement))
             {
                 return projectElement;
             }
@@ -228,7 +133,7 @@ protected XmlElement GetProjectElement(ITaskItem projectRef)
             // next we'll try a lookup by the absolute path of the project
             string projectFullPath = projectRef.GetMetadata("FullPath"); // reserved metadata "FullPath" is used at it will cache the value
 
-            if ((_cachedProjectElementsByAbsolutePath.TryGetValue(projectFullPath, out projectElement)) && (projectElement != null))
+            if (_solutionConfiguration.TryGetProjectByAbsolutePath(projectFullPath, out projectElement))
             {
                 return projectElement;
             }
@@ -243,14 +148,14 @@ protected XmlElement GetProjectElement(ITaskItem projectRef)
         protected void AddSyntheticProjectReferences(string currentProjectAbsolutePath)
         {
             // Get the guid for this project
-            if (!_cachedProjectGuidsByAbsolutePath.TryGetValue(currentProjectAbsolutePath, out string projectGuid))
+            if (!_solutionConfiguration.TryGetProjectGuidByAbsolutePath(currentProjectAbsolutePath, out string projectGuid))
             {
                 // We were passed a blob, but we weren't listed in it. Odd. Return.
                 return;
             }
 
             // Use the guid to look up the dependencies for it
-            if (!_cachedDependencyProjectGuidsByDependingProjectGuid.TryGetValue(projectGuid, out List<string> guids))
+            if (!_solutionConfiguration.TryGetProjectDependencies(projectGuid, out List<string> guids))
             {
                 // We didn't have dependencies listed in the blob
                 return;
@@ -262,7 +167,7 @@ protected void AddSyntheticProjectReferences(string currentProjectAbsolutePath)
             foreach (string guid in guids)
             {
                 // Get the absolute path of the dependency, using the blob
-                if (!_cachedProjectAbsolutePathsByGuid.TryGetValue(guid, out string path))
+                if (!_solutionConfiguration.TryGetProjectPathByGuid(guid, out string path))
                 {
                     // We had a dependency listed in the blob that wasn't itself in the blob. Odd. Return.
                     continue;
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index e8ea34b2e30..d279d8fd9e2 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -1037,11 +1037,11 @@ private void GetSDKManifestAttributes()
                 {
                     if (_sdkManifest.FrameworkIdentities != null)
                     {
-                        foreach (string key in _sdkManifest.FrameworkIdentities.Keys)
+                        foreach (KeyValuePair<string, string> kvp in _sdkManifest.FrameworkIdentities)
                         {
-                            if (!FrameworkIdentitiesFromManifest.ContainsKey(key))
+                            if (!FrameworkIdentitiesFromManifest.ContainsKey(kvp.Key))
                             {
-                                FrameworkIdentitiesFromManifest.Add(key, _sdkManifest.FrameworkIdentities[key]);
+                                FrameworkIdentitiesFromManifest.Add(kvp.Key, kvp.Value);
                             }
                         }
                     }
@@ -1054,11 +1054,11 @@ private void GetSDKManifestAttributes()
                 {
                     if (_sdkManifest.AppxLocations != null)
                     {
-                        foreach (string key in _sdkManifest.AppxLocations.Keys)
+                        foreach (KeyValuePair<string, string> kvp in _sdkManifest.AppxLocations)
                         {
-                            if (!AppxLocationsFromManifest.ContainsKey(key))
+                            if (!AppxLocationsFromManifest.ContainsKey(kvp.Key))
                             {
-                                AppxLocationsFromManifest.Add(key, _sdkManifest.AppxLocations[key]);
+                                AppxLocationsFromManifest.Add(kvp.Key, kvp.Value);
                             }
                         }
                     }
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 765a023a102..664927523f3 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -9,6 +9,7 @@
 using System.Xml;
 using System.Xml.Linq;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -16,7 +17,7 @@ namespace Microsoft.Build.Tasks.ResourceHandling
 {
     internal class MSBuildResXReader
     {
-        public static IReadOnlyList<IResource> ReadResources(Stream s, string filename, bool pathsRelativeToBasePath)
+        public static IReadOnlyList<IResource> ReadResources(Stream s, string filename, bool pathsRelativeToBasePath, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
         {
             var resources = new List<IResource>();
             var aliases = new Dictionary<string, string>();
@@ -38,7 +39,7 @@ public static IReadOnlyList<IResource> ReadResources(Stream s, string filename,
                             case "resheader":
                                 break;
                             case "data":
-                                ParseData(filename, pathsRelativeToBasePath, resources, aliases, elem);
+                                ParseData(filename, pathsRelativeToBasePath, resources, aliases, elem, log, logWarningForBinaryFormatter);
                                 break;
                         }
                     }
@@ -101,7 +102,14 @@ private static string GetFullTypeNameFromAlias(string aliasedTypeName, Dictionar
             return aliasedTypeName;
         }
 
-        private static void ParseData(string resxFilename, bool pathsRelativeToBasePath, List<IResource> resources, Dictionary<string, string> aliases, XElement elem)
+        private static void ParseData(
+            string resxFilename,
+            bool pathsRelativeToBasePath,
+            List<IResource> resources,
+            Dictionary<string, string> aliases,
+            XElement elem,
+            TaskLoggingHelper log,
+            bool logWarningForBinaryFormatter)
         {
             string name = elem.Attribute("name").Value;
             string value;
@@ -186,6 +194,12 @@ private static void ParseData(string resxFilename, bool pathsRelativeToBasePath,
                     case BinSerializedObjectMimeType:
                     case Beta2CompatSerializedObjectMimeType:
                     case CompatBinSerializedObjectMimeType:
+                        // Warn of BinaryFormatter exposure (SDK should turn this on by default in .NET 8+)
+                        if (logWarningForBinaryFormatter)
+                        {
+                            log?.LogWarningWithCodeFromResources(null, resxFilename, ((IXmlLineInfo)elem).LineNumber, ((IXmlLineInfo)elem).LinePosition, 0, 0, "GenerateResource.BinaryFormatterUse", name, typename);
+                        }
+
                         // BinaryFormatter from byte array
                         byte[] binaryFormatterBytes = Convert.FromBase64String(value);
 
@@ -284,19 +298,19 @@ internal static bool IsMemoryStream(string fileRefType)
         /// <summary>
         /// Extract <see cref="IResource"/>s from a given file on disk.
         /// </summary>
-        public static IReadOnlyList<IResource> GetResourcesFromFile(string filename, bool pathsRelativeToBasePath)
+        public static IReadOnlyList<IResource> GetResourcesFromFile(string filename, bool pathsRelativeToBasePath, TaskLoggingHelper log, bool logWarningForBinaryFormatter)
         {
             using (var x = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read))
             {
-                return ReadResources(x, filename, pathsRelativeToBasePath);
+                return ReadResources(x, filename, pathsRelativeToBasePath, log, logWarningForBinaryFormatter);
             }
         }
 
-        public static IReadOnlyList<IResource> GetResourcesFromString(string resxContent, string basePath = null, bool? useRelativePath = null)
+        public static IReadOnlyList<IResource> GetResourcesFromString(string resxContent, TaskLoggingHelper log, bool logWarningForBinaryFormatter, string basePath = null, bool? useRelativePath = null)
         {
             using (var x = new MemoryStream(Encoding.UTF8.GetBytes(resxContent)))
             {
-                return ReadResources(x, basePath, useRelativePath.GetValueOrDefault(basePath != null));
+                return ReadResources(x, basePath, useRelativePath.GetValueOrDefault(basePath != null), log, logWarningForBinaryFormatter);
             }
         }
 
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 51638cae838..c9326aeb55c 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -625,6 +625,9 @@
   <data name="GenerateBindingRedirects.ProcessingSuggestedRedirect">
     <value>Processing suggested binding redirect on "{0}" with MaxVersion "{1}".</value>
   </data>
+  <data name="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+    <value>Creating binding redirection file "{0}".</value>
+  </data>
   <!--
         The GenerateBootstrapper message bucket is: MSB3141 - MSB3170
 
@@ -1161,6 +1164,11 @@
     <value>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</value>
     <comment>{StrBegin="MSB3824: "}</comment>
   </data>
+  <data name="GenerateResource.BinaryFormatterUse">
+    <value>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</value>
+    <comment>{StrBegin="MSB3825: "}</comment>
+  </data>
 
 
   <!--
@@ -1760,6 +1768,10 @@
     <value>Assembly file '{0}' could not be opened -- PE image doesn't contain managed metadata.</value>
     <comment></comment>
   </data>
+  <data name="ResolveAssemblyReference.WritingCacheFile">
+    <value>Updating assembly cache file "{0}".</value>
+    <comment></comment>
+  </data>
   <!--
         The ResolveComReference message bucket is: MSB3281 - MSB3320
 
@@ -2963,6 +2975,9 @@
   <data name="GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform">
     <value>Platform property of referenced project '{0}' matches current project's platform: '{1}'. Referenced project will be built without a global Platform property.</value>
   </data>
+  <data name="ResolveKeySource.PfxUnsupported" xml:space="preserve">
+    <value>PFX signing not supported on .NET Core.</value>
+  </data>
   <!--
         The tasks message bucket is: MSB3001 - MSB3999
 
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 600be081bc6..bca774edb0c 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: Položka {2} odkazuje na {0} položek a položka {3} odkazuje na {1} položek. Musí mít stejný počet položek.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: Konfigurační soubor aplikace musí mít kořenový element konfigurace.</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: Funkce ClickOnce nepodporuje požadovanou úroveň provedení {0}.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Aby bylo možné provést sestavení pomocí .NET Core, musí být vstupy prostředků ve formátu .txt nebo .resx.</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">Název redistribučního balíčku v elementu FileList v souboru seznamu redistribučního balíčku {0} je null nebo prázdný. Název redistribučního balíčku nesmí být null ani prázdný.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Odkaz modelu COM {0} je definiční sestavení ovládacího prvku ActiveX {1}, ale kompilátor ho označil příznakem /link. S tímto odkazem modelu COM se bude zacházet jako s odkazem a nebude propojen.</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: Následující soubor klíčů nelze importovat: {0}. Soubor klíčů může být chráněn heslem. Chcete-li problém vyřešit, naimportujte certifikát znovu nebo certifikát naimportujte ručně do osobního úložiště certifikátů aktuálního uživatele.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: V úložišti certifikátů Windows aktuálního uživatele se nedá najít certifikát pro podpis kódu. Pokud chcete tento problém opravit, zakažte podepisování manifestu ClickOnce, nebo do úložiště certifikátů nainstalujte certifikát.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 8bd9ec1e77a..02fc298ff4d 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: "{2}" verweist auf {0} Element(e), und "{3}" verweist auf {1} Element(e). Die Anzahl von Elementen muss identisch sein.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: Die Anwendungskonfigurationsdatei muss über ein Stammkonfigurationselement verfügen.</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: Die Anforderungsausführungsebene "{0}" wird von ClickOnce nicht unterstützt.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Für die Kompilierung mit .NET Core müssen Ressourceneingaben im TXT- oder RESX-Format vorliegen.</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">Der Redist-Name im FileList-Element der Redistributable-Listendatei "{0}" ist NULL oder leer. Vergewissern Sie sich, dass der Redist-Name nicht NULL oder leer ist.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Der COM-Verweis "{0}" ist die Interopassembly für das ActiveX-Steuerelement "{1}". Entsprechend der Markierung ist der Verweis jedoch durch den Compiler mit dem /link-Flag verknüpft. Der COM-Verweis wird als Verweis behandelt und nicht verknüpft.</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: Die folgende Schlüsseldatei kann nicht importiert werden: {0}. Die Schlüsseldatei ist möglicherweise kennwortgeschützt. Importieren Sie das Zertifikat erneut, oder importieren Sie das Zertifikat manuell in den persönlichen Zertifikatspeicher des aktuellen Benutzers, um das Problem zu beheben.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: Das Codesignaturzertifikat wurde im Windows-Zertifikatspeicher des aktuellen Benutzers nicht gefunden. Deaktivieren Sie entweder das Signieren des ClickOnce-Manifests, oder installieren Sie das Zertifikat im Zertifikatspeicher, um das Problem zu beheben.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index c6bb9026203..e1d93e25454 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: "{2}" hace referencia a {0} elementos y "{3}" hace referencia a {1} elementos. Deben tener el mismo número de elementos.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: El archivo de configuración de la aplicación debe tener un elemento de configuración raíz.</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce no admite el nivel de ejecución de solicitudes '{0}'.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Para compilar con .NET Core, las entradas de recursos deben estar en formato .txt o .resx.</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">El archivo de lista de paquetes redistribuibles "{0}" tiene un nombre Redist NULL o vacío en el elemento FileList. Asegúrese de que el nombre Redist no sea NULL ni esté vacío.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">La referencia COM '{0}' es el ensamblado de interoperabilidad del control ActiveX '{1}' pero estaba marcada para su vinculación por el compilador con la marca /link. Esta referencia COM se tratará como una referencia y no se vinculará.</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: No se puede importar el archivo de clave siguiente: {0}. Puede que esté protegido mediante contraseña. Para solucionar este problema, intente importar de nuevo el certificado o impórtelo manualmente en el almacén de certificados personales del usuario.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: No se puede encontrar el certificado de firma de código en el almacén de certificados de Windows del usuario actual. Para solucionarlo, deshabilite la firma del manifiesto de ClickOnce o instale el certificado en el almacén de certificados.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 4bc23acf0d2..3d90e34c124 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: "{2}" fait référence à {0} élément(s) et "{3}", à {1} élément(s). Ils doivent avoir le même nombre d'éléments.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: le fichier de configuration d'application doit avoir un élément de configuration racine.</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce ne prend pas en charge le niveau d'exécution de la requête '{0}'.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Pour pouvoir générer avec .NET Core, les entrées de ressource doivent être au format .txt ou .resx.</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">Le fichier de liste de packages redistribuables "{0}" a un nom Redist vide ou ayant une valeur null dans l'élément FileList. Vérifiez que le nom Redist n'est pas vide ou qu'il n'a pas une valeur null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">La référence COM '{0}' est l'assembly d'interopérabilité pour le contrôle ActiveX '{1}', mais elle a été marquée comme étant liée au compilateur avec l'indicateur /link. Cette référence COM sera traitée comme une référence, mais ne sera pas liée.</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: Impossible d'importer le fichier de clé suivant : {0}. Le fichier de clé est peut-être protégé par mot de passe. Pour corriger ce problème, essayez de réimporter le certificat, ou importez manuellement le certificat dans le magasin de certificats personnel de l'utilisateur actuel.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: Le certificat de signature de code est introuvable dans le magasin de certificats Windows de l'utilisateur actuel. Pour corriger ce problème, désactivez la signature du manifeste ClickOnce ou installez le certificat dans le magasin de certificats.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index c1e7e1b0bcc..6f5a9844c92 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: "{2}" fa riferimento a {0} elemento/i, mentre "{3}" fa riferimento a {1} elemento/i. Devono avere lo stesso numero di elementi.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: il file di configurazione dell'applicazione deve avere un elemento di configurazione radice.</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce non supporta il livello di esecuzione richieste '{0}'.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: per compilare con .NET Core, gli input delle risorse devono essere in formato. txt o. resx.</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">Il file di elenco di pacchetti ridistribuibili "{0}" include un nome di Redist Null o vuoto nell'elemento FileList. Verificare che il nome di Redist non sia Null o vuoto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Il riferimento COM '{0}' è l'assembly di interoperabilità per il controllo ActiveX '{1}', tuttavia è stato contrassegnato dal compilatore con il flag /link per il collegamento. Il riferimento COM verrà trattato come riferimento e non verrà collegato.</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: non è possibile importare il seguente file di chiave: {0}. Il file di chiave potrebbe essere protetto da password. Per risolvere il problema, provare a importare di nuovo il certificato oppure importarlo manualmente nell'archivio certificati personale dell'utente corrente.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: il certificato di firma del codice non è stato trovato nell'archivio certificati Windows dell'utente corrente. Per risolvere il problema, disabilitare la firma del manifesto ClickOnce o installare il certificato nell'archivio certificati.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 72d4d318962..c6e45115596 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: "{2}" は {0} 項目を参照し、"{3}" は {1} 項目を参照します。これらは同じ項目数を持たなければなりません。</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: アプリケーション構成ファイルにはルート構成要素が必要です。</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce では、要求の実行レベル '{0}' はサポートされていません。</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: .NET Core を使用してビルドするには、リソースの入力を .txt 形式または .resx 形式にする必要があります。</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">再頒布可能パッケージ リスト ファイル "{0}" の FileList 要素に null または空の再頒布可能パッケージ名があります。再頒布可能パッケージ名が null または空でないことを確認してください。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM 参照 '{0}' は ActiveX コントロール '{1}' の相互運用アセンブリですが、コンパイラによって /link フラグでリンクされるように設定されています。この COM 参照は参照として処理され、リンクされません。</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: 次のキー ファイルをインポートできません: {0}。キー ファイルはパスワードで保護されている可能性があります。この状況を解決するには、証明書をもう一度インポートするか、現在のユーザーの個人証明書ストアに証明書を手動でインポートしてください。</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: 現在のユーザーの Windows 証明書ストアにコード署名証明書が見つかりません。これを修正するには、ClickOnce マニフェストの署名を無効にするか、証明書ストアに証明書をインストールしてください。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 16b7125d40b..247e0bd0d38 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: "{2}"은(는) 항목을 {0}개 참조하고 "{3}"은(는) 항목을 {1}개 참조합니다. 참조하는 항목 수는 같아야 합니다.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: 애플리케이션 구성 파일은 루트 구성 요소를 포함해야 합니다.</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce는 요청 실행 수준 '{0}'을(를) 지원하지 않습니다.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: .NET Core로 빌드하려면 리소스 입력이 .txt 또는 .resx 형식이어야 합니다.</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">재배포 가능 패키지 목록 파일 "{0}"의 FileList 요소에 null이거나 비어 있는 재배포 가능 패키지 이름이 있습니다. 재배포 가능 패키지 이름이 null이거나 비어 있지 않도록 하세요.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM 참조 '{0}'은(는) ActiveX 컨트롤 '{1}'에 대한 interop 어셈블리이지만 /link 플래그로 컴파일러에 의해 링크되도록 표시되어 있습니다. 이 COM 참조는 참조로 간주되지만 링크되지 않습니다.</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: 키 파일 {0}을(를) 가져올 수 없습니다. 해당 키 파일이 암호로 보호되어 있을 수 있습니다. 이 문제를 해결하려면 인증서를 다시 가져오거나 현재 사용자의 개인 인증서 저장소로 인증서를 직접 가져오세요.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: 현재 사용자의 Windows 인증서 저장소에서 코드 서명 인증서를 찾을 수 없습니다. 이 문제를 해결하려면 ClickOnce 매니페스트를 사용하지 않도록 설정하거나 인증서를 인증서 저장소에 설치하세요.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 664689a99a2..556b24e7acc 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: „{2}” odwołuje się do następującej liczby elementów: {0}, a „{3}” odwołuje się do następującej liczby elementów: {1}. Liczba tych elementów musi być taka sama.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: Plik konfiguracji aplikacji musi mieć główny element konfiguracyjny.</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: Funkcja ClickOnce nie obsługuje poziomu wykonania żądania „{0}”.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Aby kompilować przy użyciu platformy .NET Core, dane wejściowe zasobów muszą być w formacie txt lub resx.</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">Plik z listą pakietów redystrybucyjnych „{0}” ma nazwę Redist równą null lub pustą w elemencie FileList. Upewnij się, że nazwa Redist nie ma wartości null ani nie jest pusta.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Odwołanie COM „{0}” jest zestawem międzyoperacyjnym dla kontrolki ActiveX „{1}”, ale zostało wybrane do połączenia przez kompilator przy użyciu flagi /link. To odwołanie COM jest traktowane jako odwołanie i nie zostanie połączone.</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: Nie można zaimportować następującego pliku klucza: {0}. Plik klucza może być chroniony hasłem. Aby rozwiązać ten problem, spróbuj ponownie zaimportować certyfikat lub zaimportuj certyfikat ręcznie do osobistego magazynu certyfikatów bieżącego użytkownika.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: Nie można znaleźć certyfikatu podpisywania kodu w magazynie certyfikatów bieżącego użytkownika systemu Windows. Aby naprawić ten błąd, wyłącz podpisywanie manifestu ClickOnce lub zainstaluj certyfikat w magazynie certyfikatów.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 5cf5c3f3274..ff5f0631ac6 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: "{2}" refere-se ao(s) item(ns) {0} e "{3}" refere-se ao(s) item(ns) {1}. Eles devem ter o mesmo número de itens.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: o arquivo de configuração do aplicativo deve ter um elemento de configuração raiz.</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: O ClickOnce não dá suporte ao nível de execução de solicitação "{0}".</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: Para compilar com o .NET Core, as entradas de recurso devem estar em formato .txt ou .resx.</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">O arquivo da lista de pacote redistribuível "{0}" tem um nome de Pacote Redistribuível nulo ou vazio no elemento FileList. Verifique se o Nome do Pacote Redistribuível não é nulo nem está vazio.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">A Referência COM "{0}" é o assembly de interoperabilidade para o controle ActiveX "{1}", mas foi marcada para ser vinculada pelo compilador com o sinalizador /link. Essa referência COM será tratada como uma referência e não será vinculada.</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: Não é possível importar o seguinte arquivo de chave: {0}. Talvez esse arquivo de chave esteja protegido por senha. Para corrigir isso, tente importar o certificado de novo ou importe-o manualmente para o repositório de certificados pessoal do usuário atual.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: Não foi possível encontrar o certificado de assinatura de código no repositório de certificados do Windows do usuário atual. Para corrigir isso, desabilite a assinatura do manifesto ClickOnce ou instale o certificado no repositório de certificados.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index ca2259ae631..b5f6f6d6e45 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: "{2}" ссылается на следующее число элементов: {0}, а "{3}" — на {1}. Число элементов должно быть одинаковым.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: Файл конфигурации приложения должен содержать корневой элемент конфигурации.</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce не поддерживает уровень выполнения запроса "{0}".</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: для сборки с использованием .NET Core входные данные ресурсов должны быть в формате TXT или RESX.</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">В файле списка распространяемых пакетов "{0}" имя распространяемого пакета в элементе FileList имеет пустое значение или значение NULL. Убедитесь, что имя распространяемого пакета (Redist Name) не пусто и не равно NULL.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM-ссылка "{0}" является сборкой взаимодействия для элемента ActiveX "{1}", но была помечена на компоновку компилятором флагом /link. Эта COM-ссылка будет считаться ссылкой и не будет скомпонована.</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: невозможно импортировать следующий файл ключа: {0}. Возможно, файл ключа защищен паролем. Чтобы устранить эту ошибку, повторите попытку импорта сертификата или вручную импортируйте сертификат в личное хранилище сертификатов текущего пользователя.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: не удается найти сертификат подписи кода в хранилище сертификатов Windows текущего пользователя. Чтобы исправить это, отключите подписывание манифеста ClickOnce или установите сертификат в хранилище сертификатов.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 8176b354433..a3895944b7c 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: "{2}", {0} öğeye; "{3}", {1} öğeye başvuruyor. Aynı sayıda öğeye sahip olmaları gerekir.</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: Uygulama yapılandırma dosyasının kök yapılandırma öğesi olmalıdır.</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce, '{0}' istek yürütme düzeyini desteklemiyor.</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: .NET Core ile derlemek için kaynak girişleri .txt veya .resx biçiminde olmalıdır.</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">"{0}" yeniden dağıtım liste dosyasının FileList öğesindeki Redist adı null veya boş. Redist adının null veya boş olmadığından emin olun.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">'{0}' COM Başvurusu, '{1}' ActiveX denetiminin birlikte çalışma bütünleştirilmiş kodu, ancak /link bayrağıyla derleyici tarafından bağlanmak üzere işaretlenmiş. Bu COM başvurusu, başvuru olarak değerlendirilecek ve bağlanmayacak.</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: Şu anahtar dosyası içeri aktarılamıyor: {0}. Anahtar dosyası parola korumalı olabilir. Bunu düzeltmek için, sertifikayı yeniden içeri aktarmayı deneyin veya sertifikayı el ile geçerli kullanıcının kişisel sertifika deposuna aktarın.</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: Geçerli kullanıcının Windows sertifika deposunda kod imzalama sertifikası bulunamadı. Bunu düzeltmek için, ClickOnce bildiriminin imzalanmasını devre dışı bırakın veya sertifikayı sertifika deposuna yükleyin.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 579aad28fae..90455729587 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: “{2}”引用 {0} 个项，而“{3}”引用 {1} 个项。它们必须具有相同的项数。</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: 应用程序配置文件必须具有根配置元素。</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce 不支持请求执行级别“{0}”。</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: 要使用 .NET Core 进行生成，资源输入必须为 .txt 或 .resx 格式。</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">可再发行程序包列表文件“{0}”在 FileList 元素中具有 null 或空的可再发行程序包名称。请确保可再发行程序包名称不为 null 或空值。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM 引用“{0}”是 ActiveX 控件“{1}”的互操作程序集，但含有 /link 标志的编译器已将其标为已链接。系统会将此 COM 引用视为引用，并且不会链接该引用。</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: 无法导入以下密钥文件: {0}。该密钥文件可能受密码保护。若要更正此问题，请尝试再次导入证书，或手动将证书导入当前用户的个人证书存储中。</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: 无法在当前用户的 Windows 证书存储中找到代码签名证书。若要更正此问题，请禁用 ClickOnce 清单的签名或将证书安装到证书存储中。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 18ca3779377..7b9058dccae 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -624,6 +624,11 @@
         <target state="translated">MSB3094: "{2}" 參考 {0} 個項目，"{3}" 則參考 {1} 個項目。兩者參考的項目數目必須相同。</target>
         <note>{StrBegin="MSB3094: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateBindingRedirects.CreatingBindingRedirectionFile">
+        <source>Creating binding redirection file "{0}".</source>
+        <target state="new">Creating binding redirection file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GenerateBindingRedirects.MissingConfigurationNode">
         <source>MSB3831: The application configuration file must have root configuration element.</source>
         <target state="translated">MSB3831: 應用程式組態檔必須有根組態項目。</target>
@@ -1039,6 +1044,13 @@
         <target state="translated">MSB3190: ClickOnce 不支援要求執行層級 '{0}'。</target>
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateResource.BinaryFormatterUse">
+        <source>MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</source>
+        <target state="new">MSB3825: Resource "{0}" of type "{1}" is deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to possible security risks and will be removed with .NET 9. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+           More information: https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide</target>
+        <note>{StrBegin="MSB3825: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
         <source>MSB3824: In order to build with .NET Core, resource inputs must be in .txt or .resx format.</source>
         <target state="translated">MSB3824: 若要使用 .NET Core 建置，資源輸入必須採用 .txt 或 .resx 格式。</target>
@@ -2133,6 +2145,11 @@
         <target state="translated">可轉散發套件清單檔 "{0}" 在 FileList 項目中的 Redist 名稱為 null 或空白。請確認 Redist 名稱不為 null 或空白。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
+        <source>Updating assembly cache file "{0}".</source>
+        <target state="new">Updating assembly cache file "{0}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM 參考 '{0}' 是 ActiveX 控制項 '{1}' 的 Interop 組件，但是標記為要由編譯器以 /link 旗標連結。這個 COM 參考將被視為參考，不會進行連結。</target>
@@ -2353,6 +2370,11 @@
         <target state="translated">MSB3326: 無法匯入下列金鑰檔: {0}。此金鑰檔可能有密碼保護。若要改正這種情況，請嘗試再次匯入憑證，或手動將憑證匯入到目前使用者的個人憑證存放區。</target>
         <note>{StrBegin="MSB3326: "}</note>
       </trans-unit>
+      <trans-unit id="ResolveKeySource.PfxUnsupported">
+        <source>PFX signing not supported on .NET Core.</source>
+        <target state="new">PFX signing not supported on .NET Core.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ResolveKeySource.ResolvedThumbprintEmpty">
         <source>MSB3327: Unable to find code signing certificate in the current user’s Windows certificate store. To correct this, either disable signing of the ClickOnce manifest or install the certificate into the certificate store.</source>
         <target state="translated">MSB3327: 在目前使用者的 Windows 憑證存放區中，找不到程式碼簽署憑證。若要更正此問題，請停用 ClickOnce 資訊清單的簽署，或將憑證安裝到憑證存放區。</target>
diff --git a/src/Tasks/Touch.cs b/src/Tasks/Touch.cs
index 08da8b86dc8..75d00478679 100644
--- a/src/Tasks/Touch.cs
+++ b/src/Tasks/Touch.cs
@@ -16,8 +16,10 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// This class defines the touch task.
     /// </summary>
-    public class Touch : TaskExtension
+    public class Touch : TaskExtension, IIncrementalTask
     {
+        private MessageImportance messageImportance;
+
         /// <summary>
         /// Forces a touch even if the file to be touched is read-only.
         /// </summary>
@@ -45,6 +47,18 @@ public class Touch : TaskExtension
         [Output]
         public ITaskItem[] TouchedFiles { get; set; }
 
+        /// <summary>
+        /// Importance: high, normal, low (default normal)
+        /// </summary>
+        public string Importance { get; set; }
+
+        /// <summary>
+        /// Question the incremental nature of this task.
+        /// </summary>
+        /// <remarks>When Question is true, skip touching the disk to avoid causing incremental issue.
+        /// Unless the file doesn't exists, in which case, error out.</remarks>
+        public bool FailIfNotIncremental { get; set; }
+
         /// <summary>
         /// Implementation of the execute method.
         /// </summary>
@@ -120,6 +134,19 @@ internal bool ExecuteImpl(
         /// <returns></returns>
         public override bool Execute()
         {
+            if (string.IsNullOrEmpty(Importance))
+            {
+                messageImportance = MessageImportance.Normal;
+            }
+            else
+            {
+                if (!Enum.TryParse(Importance, ignoreCase: true, out messageImportance))
+                {
+                    Log.LogErrorWithCodeFromResources("Message.InvalidImportance", Importance);
+                    return false;
+                }
+            }
+
             return ExecuteImpl(
                 File.Exists,
                 File.Create,
@@ -173,7 +200,16 @@ private bool TouchFile(
                 // If the file does not exist then we check if we need to create it.
                 if (AlwaysCreate)
                 {
-                    Log.LogMessageFromResources(MessageImportance.Normal, "Touch.CreatingFile", file, "AlwaysCreate");
+                    if (FailIfNotIncremental)
+                    {
+                        Log.LogErrorFromResources("Touch.CreatingFile", file, "AlwaysCreate");
+                        return false;
+                    }
+                    else
+                    {
+                        Log.LogMessageFromResources(messageImportance, "Touch.CreatingFile", file, "AlwaysCreate");
+                    }
+
                     if (!CreateFile(file, fileCreate))
                     {
                         return false;
@@ -185,9 +221,16 @@ private bool TouchFile(
                     return false;
                 }
             }
+
+            // Ignore touching the disk when FailIfNotIncremental.
+            if (FailIfNotIncremental)
+            {
+                Log.LogErrorFromResources("Touch.Touching", file);
+                return false;
+            }
             else
             {
-                Log.LogMessageFromResources(MessageImportance.Normal, "Touch.Touching", file);
+                Log.LogMessageFromResources(messageImportance, "Touch.Touching", file);
             }
 
             // If the file is read only then we must either issue an error, or, if the user so 
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index df5e28463e7..53ad3198125 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -19,7 +19,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Represents a task that can extract a .zip archive.
     /// </summary>
-    public sealed class Unzip : TaskExtension, ICancelableTask
+    public sealed class Unzip : TaskExtension, ICancelableTask, IIncrementalTask
     {
         // We pick a value that is the largest multiple of 4096 that is still smaller than the large object heap threshold (85K).
         // The CopyTo/CopyToAsync buffer is short-lived and is likely to be collected at Gen0, and it offers a significant
@@ -73,6 +73,8 @@ public sealed class Unzip : TaskExtension, ICancelableTask
         /// </summary>
         public string Exclude { get; set; }
 
+        public bool FailIfNotIncremental { get; set; }
+
         /// <inheritdoc cref="ICancelableTask.Cancel"/>
         public void Cancel()
         {
@@ -193,6 +195,11 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector
                     Log.LogMessageFromResources(MessageImportance.Low, "Unzip.DidNotUnzipBecauseOfFileMatch", zipArchiveEntry.FullName, destinationPath.FullName, nameof(SkipUnchangedFiles), "true");
                     continue;
                 }
+                else if (FailIfNotIncremental)
+                {
+                    Log.LogErrorFromResources("Unzip.FileComment", zipArchiveEntry.FullName, destinationPath.FullName);
+                    continue;
+                }
 
                 try
                 {
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 6f53fd01eba..77128537b7a 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -67,7 +67,7 @@ public class WriteCodeFragment : TaskExtension
         /// The path to the file that was generated.
         /// If this is set, and a file name, the destination folder will be prepended.
         /// If this is set, and is rooted, the destination folder will be ignored.
-        /// If this is not set, the destination folder will be used, an arbitrary file name will be used, and 
+        /// If this is not set, the destination folder will be used, an arbitrary file name will be used, and
         /// the default extension for the language selected.
         /// </summary>
         [Output]
@@ -113,6 +113,8 @@ public override bool Execute()
 
                 OutputFile ??= new TaskItem(FileUtilities.GetTemporaryFile(OutputDirectory.ItemSpec, null, extension));
 
+                FileUtilities.EnsureDirectoryExists(Path.GetDirectoryName(OutputFile.ItemSpec));
+
                 File.WriteAllText(OutputFile.ItemSpec, code); // Overwrites file if it already exists (and can be overwritten)
             }
             catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
@@ -481,7 +483,7 @@ private Type[] FindPositionalParameterTypes(Type attributeType, IReadOnlyList<At
                     Log.LogMessageFromResources("WriteCodeFragment.MultipleConstructorsFound");
 
                     // Before parameter types could be specified, all parameter values were
-                    // treated as strings. To be backward-compatible, we need to prefer 
+                    // treated as strings. To be backward-compatible, we need to prefer
                     // the constructor that has all string parameters, if it exists.
                     var allStringParameters = candidates.FirstOrDefault(c => c.All(t => t == typeof(string)));
 
@@ -551,7 +553,7 @@ private bool TryConvertParameterValue(string typeName, string rawValue, out Code
         /// </summary>
         private CodeExpression ConvertParameterValueToInferredType(Type inferredType, string rawValue, string parameterName)
         {
-            // If we don't know what type the parameter should be, then we 
+            // If we don't know what type the parameter should be, then we
             // can't convert the type. We'll just treat is as a string.
             if (inferredType is null)
             {
diff --git a/src/Tasks/ZipDirectory.cs b/src/Tasks/ZipDirectory.cs
index 89ea647e786..96544d528a9 100644
--- a/src/Tasks/ZipDirectory.cs
+++ b/src/Tasks/ZipDirectory.cs
@@ -10,7 +10,7 @@
 
 namespace Microsoft.Build.Tasks
 {
-    public sealed class ZipDirectory : TaskExtension
+    public sealed class ZipDirectory : TaskExtension, IIncrementalTask
     {
         /// <summary>
         /// Gets or sets a <see cref="ITaskItem"/> containing the full path to the destination file to create.
@@ -29,6 +29,12 @@ public sealed class ZipDirectory : TaskExtension
         [Required]
         public ITaskItem SourceDirectory { get; set; }
 
+        /// <summary>
+        /// Question the incremental nature of this task.
+        /// </summary>
+        /// <remarks>This task does not support incremental build and will error out instead.</remarks>
+        public bool FailIfNotIncremental { get; set; }
+
         public override bool Execute()
         {
             DirectoryInfo sourceDirectory = new DirectoryInfo(SourceDirectory.ItemSpec);
@@ -47,7 +53,7 @@ public override bool Execute()
             {
                 if (destinationFile.Exists)
                 {
-                    if (!Overwrite)
+                    if (!Overwrite || FailIfNotIncremental)
                     {
                         Log.LogErrorWithCodeFromResources("ZipDirectory.ErrorFileExists", destinationFile.FullName);
 
@@ -68,8 +74,15 @@ public override bool Execute()
 
                 try
                 {
-                    Log.LogMessageFromResources(MessageImportance.High, "ZipDirectory.Comment", sourceDirectory.FullName, destinationFile.FullName);
-                    ZipFile.CreateFromDirectory(sourceDirectory.FullName, destinationFile.FullName);
+                    if (FailIfNotIncremental)
+                    {
+                        Log.LogErrorFromResources("ZipDirectory.Comment", sourceDirectory.FullName, destinationFile.FullName);
+                    }
+                    else
+                    {
+                        Log.LogMessageFromResources(MessageImportance.High, "ZipDirectory.Comment", sourceDirectory.FullName, destinationFile.FullName);
+                        ZipFile.CreateFromDirectory(sourceDirectory.FullName, destinationFile.FullName);
+                    }
                 }
                 catch (Exception e)
                 {
diff --git a/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs b/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs
index 4e53459f155..8f98ab38e0a 100644
--- a/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs
+++ b/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs
@@ -27,7 +27,7 @@ public RequiresSymbolicLinksFactAttribute()
             // In Windows, a process can create symlinks only if it has sufficient permissions.
             // We simply try to create one and if it fails we skip the test.
             string sourceFile = FileUtilities.GetTemporaryFile();
-            string destinationFile = FileUtilities.GetTemporaryFile();
+            string destinationFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.Create(sourceFile).Dispose();
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index f1d08123d54..76d4dd912fb 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -117,7 +117,7 @@ protected override int ExecuteTool(string pathToTool, string responseFileCommand
                 StartInfo = GetProcessStartInfo(GenerateFullPathToTool(), NativeMethodsShared.IsWindows ? "/x" : string.Empty, null);
                 return result;
             }
-        };
+        }
 
         [Fact]
         public void Regress_Mutation_UserSuppliedToolPathIsLogged()
@@ -825,5 +825,140 @@ protected override string GenerateCommandLineCommands()
                 return $"echo łoł > {OutputPath}";
             }
         }
+
+        /// <summary>
+        /// Verifies that a ToolTask instance can return correct results when executed multiple times with timeout.
+        /// </summary>
+        /// <param name="repeats">Specifies the number of repeats for external command execution.</param>
+        /// <param name="initialDelay">Delay to generate on the first execution in milliseconds.</param>
+        /// <param name="followupDelay">Delay to generate on follow-up execution in milliseconds.</param>
+        /// <param name="timeout">Task timeout in milliseconds.</param>
+        /// <remarks>
+        /// These tests execute the same task instance multiple times, which will in turn run a shell command to sleep
+        /// predefined amount of time. The first execution may time out, but all following ones won't. It is expected
+        /// that all following executions return success.
+        /// </remarks>
+        [Theory]
+        [InlineData(1, 1, 1, -1)] // Normal case, no repeat.
+        [InlineData(3, 1, 1, -1)] // Repeat without timeout.
+        [InlineData(3, 10000, 1, 1000)] // Repeat with timeout.
+        public void ToolTaskThatTimeoutAndRetry(int repeats, int initialDelay, int followupDelay, int timeout)
+        {
+            using var env = TestEnvironment.Create(_output);
+
+            MockEngine engine = new();
+
+            // Task under test:
+            var task = new ToolTaskThatSleeps
+            {
+                BuildEngine = engine,
+                InitialDelay = initialDelay,
+                FollowupDelay = followupDelay,
+                Timeout = timeout
+            };
+
+            // Execute the same task instance multiple times. The index is one-based.
+            bool result;
+            for (int i = 1; i <= repeats; i++)
+            {
+                // Execute the task:
+                result = task.Execute();
+
+                _output.WriteLine(engine.Log);
+
+                task.RepeatCount.ShouldBe(i);
+
+                // The first execution may fail (timeout), but all following ones should succeed:
+                if (i > 1)
+                {
+                    result.ShouldBeTrue();
+                    task.ExitCode.ShouldBe(0);
+                }
+            }
+        }
+
+        /// <summary>
+        /// A simple implementation of <see cref="ToolTask"/> to sleep for a while.
+        /// </summary>
+        /// <remarks>
+        /// This task runs shell command to sleep for predefined, variable amount of time based on how many times the
+        /// instance has been executed.
+        /// </remarks>
+        private sealed class ToolTaskThatSleeps : ToolTask
+        {
+            // PowerShell command to sleep:
+            private readonly string _powerShellSleep = "-NoProfile -ExecutionPolicy RemoteSigned -Command \"Start-Sleep -Milliseconds {0}\"";
+
+            // UNIX command to sleep:
+            private readonly string _unixSleep = "-c \"sleep {0}\"";
+
+            // Full path to shell:
+            private readonly string _pathToShell;
+
+            public ToolTaskThatSleeps()
+                : base()
+            {
+                // Determines shell to use: PowerShell for Windows, sh for UNIX-like systems:
+                _pathToShell = NativeMethodsShared.IsUnixLike ? "/bin/sh" : FindOnPath("PowerShell.exe");
+            }
+
+            /// <summary>
+            /// Gets or sets the delay for the first execution.
+            /// </summary>
+            /// <remarks>
+            /// Defaults to 10 seconds.
+            /// </remarks>
+            public Int32 InitialDelay { get; set; } = 10000;
+
+            /// <summary>
+            /// Gets or sets the delay for the follow-up executions.
+            /// </summary>
+            /// <remarks>
+            /// Defaults to 1 milliseconds.
+            /// </remarks>
+            public Int32 FollowupDelay { get; set; } = 1;
+
+            /// <summary>
+            /// Int32 output parameter for the repeat counter for test purpose.
+            /// </summary>
+            [Output]
+            public Int32 RepeatCount { get; private set; } = 0;
+
+            /// <summary>
+            /// Gets the tool name (shell).
+            /// </summary>
+            protected override string ToolName => Path.GetFileName(_pathToShell);
+
+            /// <summary>
+            /// Gets the full path to shell.
+            /// </summary>
+            protected override string GenerateFullPathToTool() => _pathToShell;
+
+            /// <summary>
+            /// Generates a shell command to sleep different amount of time based on repeat counter.
+            /// </summary>
+            protected override string GenerateCommandLineCommands() =>
+                NativeMethodsShared.IsUnixLike ?
+                string.Format(_unixSleep, RepeatCount < 2 ? InitialDelay / 1000.0 : FollowupDelay / 1000.0) :
+                string.Format(_powerShellSleep, RepeatCount < 2 ? InitialDelay : FollowupDelay);
+
+            /// <summary>
+            /// Ensures that test parameters make sense.
+            /// </summary>
+            protected internal override bool ValidateParameters() =>
+                (InitialDelay > 0) && (FollowupDelay > 0) && base.ValidateParameters();
+
+            /// <summary>
+            /// Runs shell command to sleep for a while.
+            /// </summary>
+            /// <returns>
+            /// true if the task runs successfully; false otherwise.
+            /// </returns>
+            public override bool Execute()
+            {
+                RepeatCount++;
+                return base.Execute();
+            }
+        }
     }
 }
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 64fa68b16e5..d06b02ad782 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -72,9 +72,6 @@
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
       <Link>Shared\CopyOnWriteDictionary.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\EncodingUtilities.cs">
-      <Link>Shared\EncodingUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\ErrorUtilities.cs">
       <Link>Shared\ErrorUtilities.cs</Link>
     </Compile>
diff --git a/src/Utilities/Resources/Strings.resx b/src/Utilities/Resources/Strings.resx
index 452897f1deb..2bb02c80dcf 100644
--- a/src/Utilities/Resources/Strings.resx
+++ b/src/Utilities/Resources/Strings.resx
@@ -176,6 +176,9 @@
     <value>MSB6011: Invalid parameters passed to the {0} task.</value>
     <comment>{StrBegin="MSB6011: "}</comment>
   </data>
+  <data name="ToolTask.NotUpToDate">
+    <value>Unable to skip task because it is not up-to-date.</value>
+  </data>
   <!-- FileTracker strings -->
   <data name="Tracking_LogFilesNotAvailable">
     <value xml:space="preserve">Tracking logs are not available, minimal rebuild will be disabled.</value>
diff --git a/src/Utilities/Resources/xlf/Strings.cs.xlf b/src/Utilities/Resources/xlf/Strings.cs.xlf
index a8bfb9f8d72..57b8c235b02 100644
--- a/src/Utilities/Resources/xlf/Strings.cs.xlf
+++ b/src/Utilities/Resources/xlf/Strings.cs.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: Nepodařilo se spustit spustitelný soubor zadané úlohy {0}. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: Příkaz {0} byl ukončen s kódem {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.de.xlf b/src/Utilities/Resources/xlf/Strings.de.xlf
index df6e3dfda00..ac2253af2ef 100644
--- a/src/Utilities/Resources/xlf/Strings.de.xlf
+++ b/src/Utilities/Resources/xlf/Strings.de.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: Die angegebene ausführbare Datei der Aufgabe "{0}" konnte nicht ausgeführt werden. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" wurde mit dem Code {1} beendet.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.es.xlf b/src/Utilities/Resources/xlf/Strings.es.xlf
index 71a0cc32f88..85a458060bd 100644
--- a/src/Utilities/Resources/xlf/Strings.es.xlf
+++ b/src/Utilities/Resources/xlf/Strings.es.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: No se pudo ejecutar la tarea ejecutable especificada "{0}". {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" salió con el código {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.fr.xlf b/src/Utilities/Resources/xlf/Strings.fr.xlf
index 2924d87cb1a..4b4e3e2ce99 100644
--- a/src/Utilities/Resources/xlf/Strings.fr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.fr.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: Impossible d'exécuter la tâche exécutable spécifiée "{0}". {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: Arrêt de "{0}" avec le code {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.it.xlf b/src/Utilities/Resources/xlf/Strings.it.xlf
index ea4e723c61a..e3adf9c22fb 100644
--- a/src/Utilities/Resources/xlf/Strings.it.xlf
+++ b/src/Utilities/Resources/xlf/Strings.it.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: non è stato possibile eseguire il file eseguibile "{0}" dell'attività. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" terminato con il codice {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ja.xlf b/src/Utilities/Resources/xlf/Strings.ja.xlf
index 77b2163cf7a..c7e01f40257 100644
--- a/src/Utilities/Resources/xlf/Strings.ja.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ja.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: 指定されたタスク実行可能ファイル "{0}" を実行できませんでした。{1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" はコード {1} を伴って終了しました。</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ko.xlf b/src/Utilities/Resources/xlf/Strings.ko.xlf
index 937d12bd39a..cbc95195c50 100644
--- a/src/Utilities/Resources/xlf/Strings.ko.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ko.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: 지정한 작업 실행 파일 "{0}"을(를) 실행할 수 없습니다. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}"이(가) 종료되었습니다(코드: {1}).</target>
diff --git a/src/Utilities/Resources/xlf/Strings.pl.xlf b/src/Utilities/Resources/xlf/Strings.pl.xlf
index 9cb15be1f03..62554d2c96d 100644
--- a/src/Utilities/Resources/xlf/Strings.pl.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pl.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: Nie można uruchomić określonego pliku wykonywalnego zadania „{0}”. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: Polecenie „{0}” zakończone przez kod {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
index 19e23f9ecdd..b5a62e5a024 100644
--- a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: Não foi possível executar a tarefa executável "{0}" especificada. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" foi encerrado com o código {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ru.xlf b/src/Utilities/Resources/xlf/Strings.ru.xlf
index c11d3a50afd..d3f5b246605 100644
--- a/src/Utilities/Resources/xlf/Strings.ru.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ru.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: Не удалось запустить указанный исполняемый файл задачи "{0}". {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" завершилась с кодом {1}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.tr.xlf b/src/Utilities/Resources/xlf/Strings.tr.xlf
index faf2fbb9512..cf7f608206d 100644
--- a/src/Utilities/Resources/xlf/Strings.tr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.tr.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: Belirtilen "{0}" görev yürütülebilir dosyası çalıştırılamadı. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" öğesinden {1} koduyla çıkıldı.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
index 65e9de502ba..e4a7a1f5090 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: 指定的任务可执行文件“{0}”未能运行。{1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: “{0}”已退出，代码为 {1}。</target>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
index 6d773c29ed9..6f1465f1627 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
@@ -62,6 +62,11 @@
         <target state="translated">MSB6003: 無法執行指定的工作可執行檔 "{0}"。{1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.NotUpToDate">
+        <source>Unable to skip task because it is not up-to-date.</source>
+        <target state="new">Unable to skip task because it is not up-to-date.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.ToolCommandFailed">
         <source>MSB6006: "{0}" exited with code {1}.</source>
         <target state="translated">MSB6006: "{0}" 以返回碼 {1} 結束。</target>
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 2243faedfca..09ef2296248 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -58,7 +58,7 @@ public enum HostObjectInitializationStatus
     /// </summary>
     // INTERNAL WARNING: DO NOT USE the Log property in this class! Log points to resources in the task assembly itself, and
     // we want to use resources from Utilities. Use LogPrivate (for private Utilities resources) and LogShared (for shared MSBuild resources)
-    public abstract class ToolTask : Task, ICancelableTask
+    public abstract class ToolTask : Task, IIncrementalTask, ICancelableTask
     {
         private static readonly bool s_preserveTempFiles = string.Equals(Environment.GetEnvironmentVariable("MSBUILDPRESERVETOOLTEMPFILES"), "1", StringComparison.Ordinal);
 
@@ -351,7 +351,14 @@ protected virtual void ProcessStarted() { }
         /// Returns true if task execution is not necessary. Executed after ValidateParameters
         /// </summary>
         /// <returns></returns>
-        protected virtual bool SkipTaskExecution() => false;
+        protected virtual bool SkipTaskExecution() { canBeIncremental = false; return false; }
+
+        /// <summary>
+        /// ToolTask is not incremental by default. When a derived class overrides SkipTaskExecution, then Question feature can take into effect.
+        /// </summary>
+        protected bool canBeIncremental { get; set; } = true;
+
+        public bool FailIfNotIncremental { get; set; }
 
         /// <summary>
         /// Returns a string with those switches and other information that can go into a response file.
@@ -670,6 +677,7 @@ protected virtual int ExecuteTool(
             _standardOutputDataAvailable = new ManualResetEvent(false);
 
             _toolExited = new ManualResetEvent(false);
+            _terminatedTool = false;
             _toolTimeoutExpired = new ManualResetEvent(false);
 
             _eventsDisposed = false;
@@ -1324,6 +1332,11 @@ public override bool Execute()
                     // doing any actual work).
                     return true;
                 }
+                else if (canBeIncremental && FailIfNotIncremental)
+                {
+                    LogPrivate.LogErrorWithCodeFromResources("ToolTask.NotUpToDate");
+                    return false;
+                }
 
                 string commandLineCommands = GenerateCommandLineCommands();
                 // If there are response file commands, then we need a response file later.
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index 82ed1626244..f687076fbfb 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -884,11 +884,12 @@ public void SaveTlog(DependencyFilter includeInTLog)
                 {
                     if (!_maintainCompositeRootingMarkers)
                     {
-                        foreach (string primaryFile in DependencyTable.Keys)
+                        foreach (KeyValuePair<string, Dictionary<string, string>> dependency in DependencyTable)
                         {
+                            string primaryFile = dependency.Key;
                             if (!primaryFile.Contains("|")) // composite roots are not needed
                             {
-                                Dictionary<string, string> dependencies = DependencyTable[primaryFile];
+                                Dictionary<string, string> dependencies = dependency.Value;
                                 inputs.WriteLine("^" + primaryFile);
                                 foreach (string file in dependencies.Keys)
                                 {
@@ -906,10 +907,10 @@ public void SaveTlog(DependencyFilter includeInTLog)
                     {
                         // Just output the rooting markers and their dependencies -- we don't want to
                         // compact out the composite ones.
-                        foreach (string rootingMarker in DependencyTable.Keys)
+                        foreach (KeyValuePair<string, Dictionary<string, string>> dependency in DependencyTable)
                         {
-                            Dictionary<string, string> dependencies = DependencyTable[rootingMarker];
-                            inputs.WriteLine("^" + rootingMarker);
+                            Dictionary<string, string> dependencies = dependency.Value;
+                            inputs.WriteLine("^" + dependency.Key);
                             foreach (string file in dependencies.Keys)
                             {
                                 // Give the task a chance to filter dependencies out of the written TLog
@@ -1060,8 +1061,9 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
                 var dependenciesWithoutMissingFiles = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 int keyIndex = 0;
 
-                foreach (string file in dependencies.Keys)
+                foreach (KeyValuePair<string, string> kvp in dependencies)
                 {
+                    string file = kvp.Key;
                     if (keyIndex++ > 0)
                     {
                         // Record whether or not each file exists and cache it.
@@ -1078,7 +1080,7 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
                         // Does the cached file exist?
                         if (fileExists)
                         {
-                            dependenciesWithoutMissingFiles.Add(file, dependencies[file]);
+                            dependenciesWithoutMissingFiles.Add(file, kvp.Value);
                         }
                     }
                     else
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 1c19b7868df..ef1ad5bfa5e 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -594,9 +594,10 @@ public void SaveTlog(DependencyFilter includeInTLog)
                 // Write out the dependency information as a new tlog
                 using (StreamWriter outputs = FileUtilities.OpenWrite(firstTlog, false, System.Text.Encoding.Unicode))
                 {
-                    foreach (string rootingMarker in DependencyTable.Keys)
+                    foreach (KeyValuePair<string, Dictionary<string, DateTime>> kvp in DependencyTable)
                     {
-                        Dictionary<string, DateTime> dependencies = DependencyTable[rootingMarker];
+                        string rootingMarker = kvp.Key;
+                        Dictionary<string, DateTime> dependencies = kvp.Value;
                         outputs.WriteLine("^" + rootingMarker);
                         foreach (string file in dependencies.Keys)
                         {
@@ -754,8 +755,9 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
                 var dependenciesWithoutMissingFiles = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);
                 int keyIndex = 0;
 
-                foreach (string file in dependencies.Keys)
+                foreach (KeyValuePair<string, DateTime> kvp in dependencies)
                 {
+                    string file = kvp.Key;
                     if (keyIndex++ > 0)
                     {
                         // Record whether or not each file exists and cache it.
@@ -772,7 +774,7 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictiona
                         // Does the cached file exist?
                         if (fileExists)
                         {
-                            dependenciesWithoutMissingFiles.Add(file, dependencies[file]);
+                            dependenciesWithoutMissingFiles.Add(file, kvp.Value);
                         }
                     }
                     else
