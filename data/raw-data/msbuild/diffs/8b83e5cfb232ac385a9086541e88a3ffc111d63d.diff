diff --git a/documentation/fancylogger/Opt-In-Mechanism.md b/documentation/fancylogger/Opt-In-Mechanism.md
new file mode 100644
index 00000000000..d0df44b69dd
--- /dev/null
+++ b/documentation/fancylogger/Opt-In-Mechanism.md
@@ -0,0 +1,21 @@
+# When should we use FancyLogger
+
+The FancyLogger presents the user with the build's most relevant information at the time, automatically hiding all the information that is no longer relevant (as to prevent huge log outputs). However, many users might find this not very useful (or even counterproductive) such as those using a terminal without proper ANSI support or when redirecting the output to a file. For that reason, the users must be able to turn this feature on/off at will.
+
+# Proposal
+Using the `/fancylogger` or `/flg` command line switches, users are able to opt-in and use the FancyLogger, EXCEPT when:
+- The terminal does not support ANSI codes or color
+    - [ ] Detect if terminal does not support ANSI codes or color
+ - Output is redirected to a file or pipe
+    - [x] Detect if terminal output is redirected
+
+For early development stages, an environment variable `$MSBUILDFANCYLOGGER` should be enabled to prevent accidental access to an unfinished feature. 
+
+In cases where the FancyLogger should not be enabled, the default ConsoleLogger should be used instead.
+
+# Considerations
+## Should FancyLogger be used with other loggers (eg, BinaryLogger, FileLogger, custom loggers)?
+FancyLogger should only replace the current ConsoleLogger for the aforementioned cases. Additionally, other loggers can be used in conjunction. 
+
+## Should output be ignored with the `/noconsolelogger` flag enabled?
+FancyLogger serves as a replacement for ConsoleLogger, so it should behave similarly. When attaching the `/noconsolelogger` flag, it should not output anything.
\ No newline at end of file
diff --git a/src/Build/Logging/FancyLogger/ANSIBuilder.cs b/src/Build/Logging/FancyLogger/ANSIBuilder.cs
new file mode 100644
index 00000000000..2a161bd6667
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/ANSIBuilder.cs
@@ -0,0 +1,386 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    internal static class ANSIBuilder
+    {
+        public static string ANSIRemove(string text)
+        {
+            return Regex.Replace(text, "\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])", "");
+        }
+
+        public static class Alignment
+        {
+            public static string Center(string text)
+            {
+                string result = String.Empty;
+                string noFormatString = ANSIRemove(text);
+                if (noFormatString.Length > Console.BufferWidth) return text;
+                int space = (Console.BufferWidth - noFormatString.Length) / 2;
+                result += new string(' ', space);
+                result += text;
+                result += new string(' ', space);
+                return result;
+            }
+
+            public static string Right(string text)
+            {
+                string result = String.Empty;
+                string noFormatString = ANSIRemove(text);
+                if (noFormatString.Length > Console.BufferWidth) return text;
+                int space = Console.BufferWidth - noFormatString.Length;
+                result += new string(' ', space);
+                result += text;
+                return result;
+            }
+
+            public static string Left(string text)
+            {
+                string result = String.Empty;
+                string noFormatString = ANSIRemove(text);
+                if (noFormatString.Length > Console.BufferWidth) return text;
+                int space = Console.BufferWidth - noFormatString.Length;
+                result += text;
+                result += new string(' ', space);
+                return result;
+            }
+
+            public static string SpaceBetween(string leftText, string rightText, int width)
+            {
+                string result = String.Empty;
+                string leftNoFormatString = ANSIRemove(leftText);
+                string rightNoFormatString = ANSIRemove(rightText);
+                if (leftNoFormatString.Length + rightNoFormatString.Length > Console.BufferWidth) return leftText + rightText;
+                int space = Console.BufferWidth - (leftNoFormatString.Length + rightNoFormatString.Length) - 1;
+                result += leftText;
+                result += new string(' ', space);
+                result += rightText;
+                return result;
+            }
+        }
+
+        public static class Formatting
+        {
+            public enum ForegroundColor
+            {
+                Black = 30,
+                Red = 31,
+                Green = 32,
+                Yellow = 33,
+                Blue = 34,
+                Magenta = 35,
+                Cyan = 36,
+                White = 37,
+                Default = 39
+            };
+
+            public enum BackgroundColor
+            {
+                Black = 40,
+                Red = 41,
+                Green = 42,
+                Yellow = 43,
+                Blue = 44,
+                Magenta = 45,
+                Cyan = 46,
+                White = 47,
+                Default = 49
+            }
+
+            public static string Color(string text, ForegroundColor color)
+            {
+                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
+            }
+
+            public static string Color(string text, BackgroundColor color)
+            {
+                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
+            }
+
+            public static string Color(string text, BackgroundColor backgrdoundColor, ForegroundColor foregroundColor)
+            {
+                return String.Format("\x1b[{0};{1}m{2}\x1b[0m", (int)backgrdoundColor, (int)foregroundColor, text);
+            }
+
+            public static string Bold(string text)
+            {
+                return String.Format("\x1b[1m{0}\x1b[22m", text);
+            }
+
+            public static string Dim(string text)
+            {
+                return String.Format("\x1b[2m{0}\x1b[22m", text);
+            }
+
+            public static string Italic(string text)
+            {
+                return String.Format("\x1b[3m{0}\x1b[23m", text);
+            }
+
+            public static string Underlined(string text)
+            {
+                return String.Format("\x1b[4m{0}\x1b[24m", text);
+            }
+
+            public static string DoubleUnderlined(string text)
+            {
+                return String.Format("\x1b[21m{0}\x1b[24m", text);
+            }
+
+            public static string Blinking(string text)
+            {
+                return String.Format("\x1b[5m{0}\x1b[25m", text);
+            }
+
+            public static string Inverse(string text)
+            {
+                return String.Format("\x1b[7m{0}\x1b[27m", text);
+            }
+
+            public static string Invisible(string text)
+            {
+                return String.Format("\x1b[8m{0}\x1b[28m", text);
+            }
+
+            public static string CrossedOut(string text)
+            {
+                return String.Format("\x1b[9m{0}\x1b[29m", text);
+            }
+
+            public static string Overlined(string text)
+            {
+                return String.Format("\x1b[53m{0}\x1b[55m", text);
+            }
+
+            // TODO: Right now only replaces \ with /. Needs review to make sure it works on all or most terminal emulators.
+            public static string Hyperlink(string text, string url)
+            {
+                // return String.Format("\x1b[]8;;{0}\x1b\\{1}\x1b[]8;\x1b\\", text, url);
+                return url.Replace("\\", "/");
+            }
+
+            public static string DECLineDrawing(string text)
+            {
+                return String.Format("\x1b(0{0}\x1b(B", text);
+            }
+        }
+
+        public static class Cursor
+        {
+            public enum CursorStyle
+            {
+                Default = 0,
+                BlockBlinking = 1,
+                BlockSteady = 2,
+                UnderlineBlinking = 3,
+                UnderlineSteady = 4,
+                BarBlinking = 5,
+                BarSteady = 6,
+            }
+
+            public static string Style(CursorStyle style)
+            {
+                return String.Format("\x1b[{0} q", (int)style);
+            }
+
+            public static string Up(int n = 1)
+            {
+                return String.Format("\x1b[{0}A", n);
+            }
+
+            public static string UpAndScroll(int n)
+            {
+                string result = "";
+                for (int i = 0; i < n; i++) {
+                    result += "\x1bM";
+                }
+                return result;
+            }
+
+            public static string Down(int n = 1)
+            {
+                return String.Format("\x1b[{0}B", n);
+            }
+
+            public static string Forward(int n = 1)
+            {
+                return String.Format("\x1b[{0}C", n);
+            }
+
+            public static string Backward(int n = 1)
+            {
+                return String.Format("\x1b[{0}D", n);
+            }
+
+            public static string Home()
+            {
+                return String.Format("\x1b[H");
+            }
+
+            public static string Position(int row, int column)
+            {
+                return String.Format("\x1b[{0};{1}H", row, column);
+            }
+
+            public static string SavePosition()
+            {
+                return String.Format("\x1b[s");
+            }
+
+            public static string RestorePosition() {
+                return String.Format("\x1b[u");
+            }
+        }
+
+        public static class Tabulator
+        {
+            public static string SetStop()
+            {
+                return String.Format("\x1bH");
+            }
+
+            public static string ForwardTab(int n)
+            {
+                if (n == 0) return "";
+                return String.Format("\x1b[{0}I", n);
+            }
+
+            public static string BackwardTab(int n)
+            {
+                return String.Format("\x1b[{0}Z", n);
+            }
+
+            public static string UnsetStop()
+            {
+                return String.Format("\x1b[0g");
+            }
+
+            public static string UnserAlStops()
+            {
+                return String.Format("\x1b[3g");
+            }
+        }
+
+        public static class Viewport
+        {
+            public static string ScrollDown(int n)
+            {
+                return String.Format("\x1b[{0}T", n);
+            }
+
+            public static string ScrollUp(int n)
+            {
+                return String.Format("\x1b[{0}S", n);
+            }
+
+            public static string SetScrollingRegion(int start, int end)
+            {
+                return String.Format("\x1b[{0};{1}r", start, end);
+            }
+
+            public static string PrependLines(int n)
+            {
+                return String.Format("\x1b[{0}L", n);
+            }
+
+            public static string DeleteLines(int n)
+            {
+                return String.Format("\x1b[{0}M", n);
+            }
+        }
+
+        public static class Eraser
+        {
+            public static string DisplayCursorToEnd()
+            {
+                return String.Format("\x1b[0J");
+            }
+
+            public static string DisplayStartToCursor()
+            {
+                return String.Format("\x1b[1J");
+            }
+
+            public static string Display()
+            {
+                return String.Format("\x1b[2J");
+            }
+
+            public static string LineCursorToEnd()
+            {
+                return String.Format("\x1b[0K");
+            }
+
+            public static string LineStartToCursor()
+            {
+                return String.Format("\x1b[1K");
+            }
+
+            public static string Line()
+            {
+                return String.Format("\x1b[2k");
+            }
+        }
+
+        public static class Graphics
+        {
+            private static int spinnerCounter = 0;
+            public static string Spinner()
+            {
+                return Spinner(spinnerCounter++);
+            }
+
+            public static string Spinner(int n)
+            {
+                char[] chars = { '\\', '|', '/', '-'};
+                return chars[n % (chars.Length - 1)].ToString();
+            }
+
+            public static string ProgressBar(float percentage, int width = 10, char completedChar = '█', char remainingChar = '░')
+            {
+                string result = String.Empty;
+                for (int i = 0; i < (int)Math.Floor(width * percentage); i++)
+                {
+                    result += completedChar;
+                }
+                for (int i = (int)Math.Floor(width * percentage); i < width; i++)
+                {
+                    result += remainingChar;
+                }
+                return result;
+            }
+
+            public static string Bell()
+            {
+                return String.Format("\x07");
+            }
+        }
+
+        public static class Buffer
+        {
+            public static string Fill()
+            {
+                return String.Format("\x1b#8");
+            }
+
+            public static string UseAlternateBuffer()
+            {
+                return "\x1b[?1049h";
+            }
+
+            public static string UseMainBuffer()
+            {
+                return "\x1b[?1049l";
+            }
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLogger.cs b/src/Build/Logging/FancyLogger/FancyLogger.cs
new file mode 100644
index 00000000000..2eb3d10200e
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLogger.cs
@@ -0,0 +1,144 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+
+using Microsoft.Build.Framework;
+using System.Runtime.InteropServices;
+using System.Threading;
+using System.Threading.Tasks;
+using System.IO;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    public class FancyLogger : ILogger
+    {
+        // TODO: Move somewhere else
+        public string GetUnambiguousPath(string path)
+        {
+            // Get last part of path
+            return Path.GetFileName(path);
+        }
+
+        public FancyLoggerNode root = new FancyLoggerNode(-1, FancyLoggerNodeType.None);
+
+        public Dictionary<int, FancyLoggerBufferLine> projectConsoleLines = new Dictionary<int, FancyLoggerBufferLine>();
+
+        private float existingTasks = 1;
+        private float completedTasks = 0;
+
+        public string Parameters {  get; set; }
+
+        public LoggerVerbosity Verbosity { get; set; }
+
+        public FancyLogger()
+        {
+            Parameters = "";
+        }
+
+        public void Initialize(IEventSource eventSource)
+        {
+            // Register for different events
+            // Started
+            eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);
+            eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);
+            // eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);
+            // eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);
+            // Finished
+            eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);
+            eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);
+            // eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);
+            // eventSource.TaskFinished += new TaskFinishedEventHandler(eventSource_TaskFinished);
+            // Raised
+            eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);
+            eventSource.WarningRaised += new BuildWarningEventHandler(eventSource_WarningRaised);
+            eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);
+            // Initialize FancyLoggerBuffer
+            FancyLoggerBuffer.Initialize();
+        }
+
+        // Build
+        void eventSource_BuildStarted(object sender, BuildStartedEventArgs e)
+        {
+        }
+        void eventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
+        {
+            // Console.WriteLine(LoggerFormatting.Bold("[Build]") + "\t Finished");
+        }
+
+        // Project
+        void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            // If id already exists...
+            if (projectConsoleLines.ContainsKey(id)) return;
+            // Create line
+            FancyLoggerBufferLine line = FancyLoggerBuffer.WriteNewLine(
+                ANSIBuilder.Alignment.SpaceBetween(
+                    $"{ANSIBuilder.Graphics.Spinner()} {ANSIBuilder.Formatting.Dim("Project - ")} {GetUnambiguousPath(e.ProjectFile!)}",
+                    "(5 targets completed)",
+                    Console.WindowWidth
+                )
+            );
+
+            projectConsoleLines.Add(id, line);
+        }
+        void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if(!projectConsoleLines.TryGetValue(id, out FancyLoggerBufferLine? line)) return;
+            // Update line
+            FancyLoggerBuffer.UpdateLine(line.Id,
+                ANSIBuilder.Alignment.SpaceBetween(
+                    $"{ANSIBuilder.Formatting.Color("✓", ANSIBuilder.Formatting.ForegroundColor.Green)} {ANSIBuilder.Formatting.Dim("Project - ")} {ANSIBuilder.Formatting.Color(GetUnambiguousPath(e.ProjectFile!), ANSIBuilder.Formatting.ForegroundColor.Green)}",
+                    "(5 targets completed)",
+                    Console.WindowWidth
+                )
+            );
+        }
+        // Target
+        void eventSource_TargetStarted(object sender, TargetStartedEventArgs e)
+        {
+        }
+        void eventSource_TargetFinished(object sender, TargetFinishedEventArgs e)
+        {
+        }
+
+        // Task
+        void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
+        {
+            existingTasks++;
+        }
+
+        void eventSource_TaskFinished(object sender, TaskFinishedEventArgs e)
+        {
+            completedTasks++;
+        }
+
+        void eventSource_MessageRaised(object sender, BuildMessageEventArgs e)
+        {
+        }
+        void eventSource_WarningRaised(object sender, BuildWarningEventArgs e)
+        {
+            FancyLoggerBuffer.WriteNewLine("Warning");
+        }
+        void eventSource_ErrorRaised(object sender, BuildErrorEventArgs e)
+        {
+            // TODO: Try to redirect to stderr
+            FancyLoggerBuffer.WriteNewLine("Error");
+        }
+
+
+        public void Shutdown() {
+            // Keep open if autoscroll disabled (the user is reading info)
+            while (FancyLoggerBuffer.AutoScrollEnabled || !FancyLoggerBuffer.IsTerminated)
+            {
+            }
+            FancyLoggerBuffer.Terminate();
+            Console.WriteLine("Build status, warnings and errors will be shown here after the build has ended and the interactive logger has closed");
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs b/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
new file mode 100644
index 00000000000..cac4aafd7ef
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
@@ -0,0 +1,265 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    /// <summary>
+    /// Represents an identifiable line inside the fancylogger buffer.
+    /// </summary>
+    public class FancyLoggerBufferLine
+    {
+        private static int counter = 0;
+        public int Id;
+        public string Text;
+        public bool IsHidden;
+        public int IdentationLevel = -1;
+        public FancyLoggerBufferLine()
+        {
+            Id = counter++;
+            Text = String.Empty;
+        }
+        public FancyLoggerBufferLine(string text)
+        {
+            Id = counter++;
+            Text = text;
+        }
+        public FancyLoggerBufferLine(string text, int identationLevel) : this(text)
+        {
+            IdentationLevel = identationLevel;
+        }
+        public void Hide()
+        {
+            IsHidden = true;
+        }
+        public void Unhide()
+        {
+            IsHidden = false;
+        }
+        public int GetIndex()
+        {
+            return FancyLoggerBuffer.GetLineIndexById(Id);
+        }
+    }
+
+    /// <summary>
+    /// Buffer manager for FancyLogger
+    /// </summary>
+    internal static class FancyLoggerBuffer
+    {
+        // Status
+        public static bool AutoScrollEnabled { get; private set; }
+        public static bool IsTerminated { get; private set; }
+        public static int CurrentTopLineIndex { get; private set; }
+        public static int Height { get { return Console.WindowHeight; } }
+        // Lines to be presented by the buffer
+        private static List<FancyLoggerBufferLine> lines = new();
+        public static void Initialize()
+        {
+            // Setup event listeners
+            Task.Run(() =>
+            {
+                while (true)
+                {
+                    if (IsTerminated) return;
+                    switch (Console.ReadKey().Key)
+                    {
+                        case ConsoleKey.Q:
+                            IsTerminated = true;
+                        break;
+                        case ConsoleKey.UpArrow:
+                            ScrollToLine(CurrentTopLineIndex - 1);
+                            break;
+                        case ConsoleKey.DownArrow:
+                            ScrollToLine(CurrentTopLineIndex + 1);
+                            break;
+                        case ConsoleKey.Home:
+                            ScrollToLine(0);
+                            break;
+                        case ConsoleKey.End:
+                            ScrollToEnd();
+                            break;
+                        case ConsoleKey.Spacebar:
+                        case ConsoleKey.Escape:
+                            ToggleAutoScroll();
+                            break;
+                    }
+                }
+            });
+            // Switch to alternate
+            Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
+            Console.Write(ANSIBuilder.Buffer.UseAlternateBuffer());
+            // Settings
+            AutoScrollEnabled = true;
+            // Render contents
+            WriteTitleBar();
+            WriteFooter("~~~~~~~~~~~~~~~~~~~~~~~~~~~");
+            ScrollToEnd();
+        }
+        public static void Terminate()
+        {
+            // Switch to main buffer
+            Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
+            // Dispose event listeners
+            IsTerminated = true;
+            // Delete lines
+            lines = new();
+        }
+
+        #region Scrolling
+        private static void ScrollToLine(int firstLineIndex)
+        {
+            if (firstLineIndex < 0 || firstLineIndex >= lines.Count) return;
+            CurrentTopLineIndex = firstLineIndex;
+            int i = 0;
+            while (i < Height - 4)
+            {
+                int lineIndex = i + firstLineIndex;
+                Console.Write(""
+                    + ANSIBuilder.Cursor.Position(i + 2, 0)
+                    + ANSIBuilder.Eraser.LineCursorToEnd()
+                    // + ((lineIndex < lines.Count && lines[lineIndex].IsHidden) ? " Hidden" : "")
+                    + ((lineIndex < lines.Count) ? ANSIBuilder.Tabulator.ForwardTab(lines[lineIndex].IdentationLevel) + lines[lineIndex].Text : "")
+                );
+                i++;
+            }
+
+            Console.Write(ANSIBuilder.Cursor.Position(Height, 0));
+        }
+        private static void ScrollToEnd()
+        { 
+            // If number of lines is smaller than height
+            if (lines.Count < Height - 2)
+            {
+                ScrollToLine(0);
+            }
+            else
+            {
+                ScrollToLine(lines.Count - Height + 4);
+            }
+            // Go to end
+            Console.Write(ANSIBuilder.Cursor.Position(Height, 0));
+        }
+        private static void ToggleAutoScroll()
+        {
+            AutoScrollEnabled = !AutoScrollEnabled;
+        }
+        #endregion
+        #region Line Referencing
+        public static int GetLineIndexById(int lineId)
+        {
+            for (int i = 0; i < lines.Count; i++)
+            {
+                if (lines[i].Id == lineId) return i;
+            }
+            return -1;
+        }
+        public static FancyLoggerBufferLine? GetLineById(int lineId)
+        {
+            int i = GetLineIndexById(lineId);
+            if (i == -1) return null;
+            return lines[i];
+        }
+        #endregion
+        #region Writing
+        public static void WriteTitleBar()
+        {
+            Console.Write(""
+                + ANSIBuilder.Cursor.Home()
+                + ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center("MSBuild - Build in progress"))
+            );
+        }
+        public static void WriteFooter(string text)
+        {
+            Console.Write(""
+                + ANSIBuilder.Cursor.Position(Height - 2, 0) // Position at bottom
+                + new string('-', Console.BufferWidth) + "\n"
+                + ANSIBuilder.Eraser.LineCursorToEnd()
+                + text
+            );
+        }
+        public static FancyLoggerBufferLine WriteNewLine(string text)
+        {
+            // Create line
+            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text);
+            return WriteNewLine(line);
+        }
+        public static FancyLoggerBufferLine WriteNewLine(FancyLoggerBufferLine line)
+        {
+            // Add line
+            lines.Add(line);
+            // Update contents
+            if (AutoScrollEnabled) ScrollToEnd();
+            else ScrollToLine(CurrentTopLineIndex);
+            return line;
+        }
+        public static FancyLoggerBufferLine? WriteNewLineAfter(string text, int lineId)
+        {
+            // get line
+            int lineIndex = GetLineIndexById(lineId);
+            if (lineIndex == -1) return null;
+
+            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text);
+            return WriteNewLineAfterIndex(line, lineIndex);
+        }
+
+        public static FancyLoggerBufferLine? WriteNewLineAfter(FancyLoggerBufferLine line, int lineId)
+        {
+            // get line
+            int lineIndex = GetLineIndexById(lineId);
+            if (lineIndex == -1) return null;
+
+            return WriteNewLineAfterIndex(line, lineIndex);
+        }
+
+        public static FancyLoggerBufferLine? WriteNewLineAfterIndex(FancyLoggerBufferLine line, int lineIndex)
+        {
+            if (lineIndex == -1) return null;
+            lines.Insert(lineIndex + 1, line);
+            // Scroll to end if lineIndex >= lines
+            // if (lineIndex >= lines.Count -2 && AutoScrollEnabled) ScrollToEnd();
+            // else ScrollToLine(CurrentTopLineIndex);
+            ScrollToEnd();
+            return line;
+        }
+
+        public static void DeleteLine(int lineId)
+        {
+            int lineIndex = GetLineIndexById(lineId);
+            if (lineIndex == -1) return;
+            lines.RemoveAt(lineIndex);
+            ScrollToLine(CurrentTopLineIndex);
+        }
+
+        public static FancyLoggerBufferLine? UpdateLine(int lineId, string text)
+        {
+            FancyLoggerBufferLine? line = GetLineById(lineId);
+            if (line == null) return null;
+
+            line.Text = text;
+            ScrollToLine(CurrentTopLineIndex);
+            return line;
+        }
+        #endregion
+
+        public static void HideLine(int lineId)
+        {
+            FancyLoggerBufferLine? line = GetLineById(lineId);
+            if (line == null) return;
+            line.Hide();
+            ScrollToLine(CurrentTopLineIndex);
+        }
+        public static void UnhideLine(int lineId)
+        {
+            FancyLoggerBufferLine? line = GetLineById(lineId);
+            if (line == null) return;
+            line.Unhide();
+            ScrollToLine(CurrentTopLineIndex);
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerNode.cs
new file mode 100644
index 00000000000..b3021f042eb
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerNode.cs
@@ -0,0 +1,151 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+    // TODO: Maybe remove
+    public enum FancyLoggerNodeType
+    {
+        None,
+        Build,
+        Project,
+        Target,
+        Task,
+        Message,
+        Warning,
+        Error
+    }
+
+    public class FancyLoggerNode
+    {
+        public string Id;
+        public Dictionary<string, FancyLoggerNode> Children = new Dictionary<string, FancyLoggerNode>();
+        public FancyLoggerNode? Parent;
+        public FancyLoggerBufferLine? Line;
+        public int Depth = 0;
+        public FancyLoggerNode(string id)
+        {
+            Id = id;
+        }
+        public FancyLoggerNode(int id, FancyLoggerNodeType type)
+        {
+            switch (type)
+            {
+                case FancyLoggerNodeType.Build:
+                    Id = $"build-{id}";
+                    break;
+                case FancyLoggerNodeType.Project:
+                    Id = $"project-{id}";
+                    break;
+                case FancyLoggerNodeType.Target:
+                    Id = $"target-{id}";
+                    break;
+                case FancyLoggerNodeType.Task:
+                    Id = $"task-{id}";
+                    break;
+                case FancyLoggerNodeType.Message:
+                    Id = $"message-{id}";
+                    break;
+                case FancyLoggerNodeType.Warning:
+                    Id = $"warning-{id}";
+                    break;
+                case FancyLoggerNodeType.Error:
+                    Id = $"error-{id}";
+                    break;
+                default:
+                    Id = id.ToString(); break;
+            }
+        }
+        public FancyLoggerNode? Find(string id)
+        {
+            // If self
+            if(Id == id) return this;
+            // If no children
+            if(Children.Count == 0) return null;
+            // Iterate
+            foreach (var child in Children)
+            {
+                FancyLoggerNode? node = child.Value.Find(id);
+                if (node != null) return node;
+            }
+            return null;
+        }
+
+        public void Add(FancyLoggerNode node)
+        {
+            if (Children.ContainsKey(node.Id)) return;
+            Children.Add(node.Id, node);
+            node.Depth = Depth + 1;
+            node.Parent = this;
+        }
+
+        public int GetLastLineIndex()
+        {
+            // If no line, return -1
+            if (Line == null) return -1;
+            // Get line index and id
+            int lastLineIndex = FancyLoggerBuffer.GetLineIndexById(Line.Id);
+            int lastLineId = Line.Id;
+            if (lastLineIndex == -1) return -1;
+            // Get max of children
+            foreach (var child in Children)
+            {
+                int childLastLineIndex = child.Value.GetLastLineIndex();
+                if (childLastLineIndex > lastLineIndex)
+                {
+                    lastLineIndex = childLastLineIndex;
+                    lastLineId = child.Value.Line!.Id;
+                }
+            }
+            return lastLineIndex;
+        }
+
+        public void Write()
+        {
+            if (Line == null) { return; }
+            // Adjust identation
+            Line.IdentationLevel = Depth - 1;
+            // If line not in the buffer, add
+            if (FancyLoggerBuffer.GetLineIndexById(Line.Id) == -1)
+            {
+                // Get parent last line index
+                if (Parent != null)
+                {
+                    int parentLastLineId = Parent.GetLastLineIndex();
+                    // if (parentLastLineId == -1) throw new Exception("Oops something went wrong");
+                    if (parentLastLineId == -1) return;
+                    // FancyLoggerBuffer.WriteNewLineAfter(Line, parentLastLineId);
+                    FancyLoggerBuffer.WriteNewLineAfterIndex(Line, parentLastLineId);
+                }
+            }
+        }
+
+        public void Collapse()
+        {
+            foreach (var child in Children)
+            {
+                if (child.Value.Line == null) continue;
+                FancyLoggerBuffer.HideLine(child.Value.Line.Id);
+                child.Value.Collapse();
+            }
+        }
+
+        public void Expand()
+        {
+            foreach (var child in Children)
+            {
+                if (child.Value.Line == null) continue;
+                FancyLoggerBuffer.UnhideLine(child.Value.Line.Id);
+                child.Value.Expand();
+            }
+        }
+    }
+}
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 6e13af19356..a0bc0207854 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -160,6 +160,7 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
+    <Compile Include="Logging\FancyLogger\*.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index e99faefea4b..4ec352da9a3 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -47,6 +47,7 @@ internal enum ParameterlessSwitch
             FileLogger8,
             FileLogger9,
             DistributedFileLogger,
+            FancyLogger,
 #if DEBUG
             WaitForDebugger,
 #endif
@@ -220,6 +221,7 @@ bool emptyParametersAllowed
             new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },            ParameterlessSwitch.FileLogger8,           null),
             new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },            ParameterlessSwitch.FileLogger9,           null),
             new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },  ParameterlessSwitch.DistributedFileLogger, null),
+            new ParameterlessSwitchInfo(  new string[] { "fancylogger", "flg" },            ParameterlessSwitch.FancyLogger,           null),
 #if DEBUG
             new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },        ParameterlessSwitch.WaitForDebugger,       null),
 #endif
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 6e58e6fd84b..cf6ba40db6a 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -38,6 +38,8 @@
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Internal;
+using Microsoft.Build.Logging.FancyLogger;
+using System.Runtime.InteropServices;
 
 #nullable disable
 
@@ -126,7 +128,7 @@ public enum ExitType
         private static readonly CancellationTokenSource s_buildCancellationSource = new CancellationTokenSource();
 
         private static readonly char[] s_commaSemicolon = { ',', ';' };
-
+ 
         /// <summary>
         /// Static constructor
         /// </summary>
@@ -1082,6 +1084,11 @@ private static void ResetGatheringSwitchesState()
         /// </summary>
         private const string msbuildLogFileName = "msbuild.log";
 
+        /// <summary>
+        /// List of messages to be sent to the logger when it is attached
+        /// </summary>
+        private static List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
+
         /// <summary>
         /// Initializes the build engine, and starts the project building.
         /// </summary>
@@ -1319,7 +1326,7 @@ string[] commandLine
                         }
                     }
 
-                    List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = null;
+                    // List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = null;
 
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
 
@@ -1333,7 +1340,7 @@ string[] commandLine
 #else
                             string.Join(" ", commandLine);
 #endif
-                        messagesToLogInBuildLoggers = GetMessagesToLogInBuildLoggers(commandLineString);
+                        messagesToLogInBuildLoggers.AddRange(GetMessagesToLogInBuildLoggers(commandLineString));
 
                         // Log a message for every response file and include it in log
                         foreach (var responseFilePath in s_includedResponseFiles)
@@ -2417,6 +2424,7 @@ string commandLine
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],
+                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.FancyLogger], 
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],
@@ -3201,6 +3209,7 @@ private static ILogger[] ProcessLoggingSwitches
             string[] verbositySwitchParameters,
             bool noConsoleLogger,
             bool distributedFileLogger,
+            bool fancyLoggerCommandLineOptIn, 
             string[] fileLoggerParameters,
             string[] consoleLoggerParameters,
             string[] binaryLoggerParameters,
@@ -3230,7 +3239,15 @@ out bool enableProfiler
             // Add any loggers which have been specified on the commandline
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
 
-            ProcessConsoleLoggerSwitch(noConsoleLogger, consoleLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
+            // Choose default console logger
+            if ((fancyLoggerCommandLineOptIn || Environment.GetEnvironmentVariable("MSBUILDFANCYLOGGER") == "true") && DoesEnvironmentSupportFancyLogger())
+            {
+                ProcessFancyLogger(noConsoleLogger, loggers);
+            }
+            else
+            {
+                ProcessConsoleLoggerSwitch(noConsoleLogger, consoleLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
+            }
 
             ProcessDistributedFileLogger(distributedFileLogger, fileLoggerParameters, distributedLoggerRecords, loggers, cpuCount);
 
@@ -3238,6 +3255,9 @@ out bool enableProfiler
 
             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref verbosity);
 
+            // TOOD: Review
+            // ProcessFancyLogger(noConsoleLogger, loggers);
+
             profilerLogger = ProcessProfileEvaluationSwitch(profileEvaluationParameters, loggers, out enableProfiler);
 
             return loggers.ToArray();
@@ -3400,6 +3420,43 @@ List<ILogger> loggers
             }
         }
 
+        private static bool DoesEnvironmentSupportFancyLogger()
+        {
+            // If output is redirected
+            if (Console.IsOutputRedirected)
+            {
+                messagesToLogInBuildLoggers.Add(
+                    new BuildManager.DeferredBuildMessage("FancyLogger was not used because the output is being redirected to a file.", MessageImportance.Low)
+                );
+                return false;
+            }
+            // If terminal is dumb
+            if (
+                (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && Environment.GetEnvironmentVariable("WT_SESSION") == "")
+                || Environment.GetEnvironmentVariable("TERM") == "dumb"
+            )
+            {
+                messagesToLogInBuildLoggers.Add(
+                    new BuildManager.DeferredBuildMessage("FancyLogger was not used because the output is not supported.", MessageImportance.Low)
+                );
+                return false;
+            }
+            return true;
+        }
+
+        private static void ProcessFancyLogger(
+            bool noConsoleLogger,
+            List<ILogger> loggers
+        )
+        {
+            // Check for flags and env variables
+            if (!noConsoleLogger)
+            {
+                FancyLogger l = new FancyLogger();
+                loggers.Add(l);
+            }
+        }
+
         /// <summary>
         /// Returns a DistributedLoggerRecord containing this logger and a ConfigurableForwardingLogger.
         /// Looks at the logger's parameters for any verbosity parameter in order to make sure it is setting up the ConfigurableForwardingLogger
