diff --git a/.gitignore b/.gitignore
index e902f62318d..d64a943952c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -221,4 +221,5 @@ stage1/
 .tools
 
 # ETL traces    
-*.etl.zip
\ No newline at end of file
+*.etl.zip
+*.etl
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 260f46914b1..81b331862cc 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -1,5 +1,5 @@
 trigger:
-- master
+- main
 - exp/*
 - vs*
 
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index eefef30630a..cb827f778a0 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -1,5 +1,5 @@
 trigger:
-- master
+- main
 - vs*
 - exp/*
 
@@ -15,7 +15,7 @@ variables:
     value: $(IbcSourceBranchName)
   - ${{ if startsWith(variables['Build.SourceBranch'], 'refs/heads/exp/') }}:
     - name: SourceBranch
-      value: master
+      value: main
   - name: _DotNetArtifactsCategory
     value: .NETCore
   - name: _DotNetValidationArtifactsCategory
diff --git a/CompatBaseline.txt b/CompatBaseline.txt
deleted file mode 100644
index a15e37c83dd..00000000000
--- a/CompatBaseline.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-# This API is marked obsolete and has been removed from the reference assembly
-MembersMustExist : Member 'Microsoft.Build.Utilities.ToolTask.EnvironmentOverride.get()' does not exist in the implementation but it does exist in the contract.
-#These changes will appear in Update 1; They represent added support for Framework 4.6.1 SDK.
-MembersMustExist : Member 'Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion461Path.get()' does not exist in the implementation but it does exist in the contract.
-MembersMustExist : Member 'Microsoft.Build.Utilities.TargetDotNetFrameworkVersion Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version461' does not exist in the implementation but it does exist in the contract.
-EnumValuesMustMatch : Enum value 'Microsoft.Build.Utilities.TargetDotNetFrameworkVersion Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.VersionLatest' is (System.Int32)7 in the implementation but (System.Int32)8 in the contract.
-MembersMustExist : Member 'Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk()' does not exist in the implementation but it does exist in the contract.
-MembersMustExist : Member 'Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(System.String)' does not exist in the implementation but it does exist in the contract.
diff --git a/README.md b/README.md
index 631504a1702..0ca7629c10a 100644
--- a/README.md
+++ b/README.md
@@ -6,9 +6,9 @@ For more information on MSBuild, see the [MSBuild documentation](https://docs.mi
 
 ### Build Status
 
-The current development branch is `master`. Changes in `master` will go into a future update of MSBuild, which will release with Visual Studio 16.10 and a corresponding version of the .NET Core SDK.
+The current development branch is `main`. Changes in `main` will go into a future update of MSBuild, which will release with Visual Studio 16.10 and a corresponding version of the .NET Core SDK.
 
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=master)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=master)
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=main)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=main)
 
 We have forked for MSBuild 16.9 in the branch [`vs16.9`](https://github.com/Microsoft/msbuild/tree/vs16.9). Changes to that branch need special approval.
 
diff --git a/RunApiPort.bat b/RunApiPort.bat
deleted file mode 100644
index 4c147cc6cf0..00000000000
--- a/RunApiPort.bat
+++ /dev/null
@@ -1,7 +0,0 @@
-@echo off
-setlocal
-
-msbuild %~dp0src\MSBuild.sln /p:Configuration=Port-Progress
-
-set ANALYSIS_PATH=%~dp0bin\Windows_NT\Port-Progress
-%~dp0ApiPort\ApiPort.exe analyze -f %ANALYSIS_PATH%\Microsoft.Build.dll -f %ANALYSIS_PATH%\Microsoft.Build.Framework.dll -f %ANALYSIS_PATH%\Microsoft.Build.Tasks.Core.dll -f %ANALYSIS_PATH%\Microsoft.Build.Utilities.Core.dll -f %ANALYSIS_PATH%\MSBuild.exe --target "ASP.NET 5, Version=1.0"
\ No newline at end of file
diff --git a/documentation/specs/rar-as-service.md b/documentation/specs/rar-as-service.md
index f04cfed6b41..83d2a0d1b2f 100644
--- a/documentation/specs/rar-as-service.md
+++ b/documentation/specs/rar-as-service.md
@@ -40,7 +40,18 @@ If the connection is successful, we can use this connection for execution of RAR
 
 This step will create new process which will act as RAR node. It will also pass necessary information to the node to know what its settings are (reusable, ...). Node will be another instance of the MSBuild.exe which will have set parameter **nodeMode** to some specific value (it should be `/nodeMode:3`). 
 
-We will use Mutex (as in [Roslyn](https://github.com/dotnet/roslyn/blob/838874b1b817db84ce146bef690cc95a39c213a5/src/Compilers/Server/VBCSCompiler/BuildServerController.cs#L143)) to ensure we don't create two RAR nodes at once. Its name must encode whether it is the user's only RAR node, including user name, administrator privileges, and some initial settings for the node. Such a name could be: `MSBuild.RAR.ostorc.7`, where **MSBuild.RAR** is its prefix, **ostorc** is the user who called MSBuild, and **7** represents encoded settings (flag enum).
+We will use named-pipe exclusivity to ensure we don't create multiple RAR nodes at once. Its name must encode whether it is the user's only RAR node, including user name, administrator privileges, and some initial settings for the node. Such a name could be: `MSBuild.RAR.ostorc.7`, where **MSBuild.RAR** is its prefix, **ostorc** is the user who called MSBuild, and **7** represents encoded settings (flag enum).
+
+RAR Node will adopt existing MSBuild infrastructure code, NodeProviderOutOfProcTaskHost and related, used for invoking tasks out of process.
+
+This code already solved many aspect of 'Out of process task invocation':
+- serialization of task inputs and outputs
+- distributed logging
+- environmental variables
+- current directory path
+- current culture
+- cancellation
+- etc...
 
 ### Execute RAR task
 
@@ -48,8 +59,19 @@ Execution should be the same as it is now.
 
 There is already some layer of separation between Task interface and actual execution method. We will leverage this, and put the decision logic if to run locally or not into the "wrapper" method and so we will not have to modify this and in server-side execution we will directly call the internal execution method.
 
+#### RAR Concurrency
+
 There is one big concern and that is how to handle multiple requests at once. As right now, RAR task is not prepared for multi-thread use.
 
+One of the biggest challenges with RAR as service, is to make execution and caching of RAR task thread-safe, since in most cases there will be multiple clients requesting data from it at once.
+
+So far, we have identified following areas that have to be addressed to allow concurrent execution of RAR tasks:
+
+- thread safety (static variables, shared data structures, caching, ...)
+- environmental variables virtualization
+- current directory virtualization
+- current culture isolation
+
 ### Shutdown RAR node
 
 If the user does not want the node to be reused, we have the ensure that node will be killed after the build ends. This should be done after the main MSBuild node finishes building.
@@ -70,145 +92,18 @@ __NOTE:__ The behavior described above depend on fact that the feature is opt-ou
 
 ## Communication
 
-The communication between nodes should be done over [StreamJsonRpc](https://github.com/microsoft/vs-streamjsonrpc/). The API over which two node will transfer data has to reflect inputs and outputs of RAR task as described in [docs](https://docs.microsoft.com/visualstudio/msbuild/resolveassemblyreference-task?view=vs-2019).
-
-Note that, the following snippets are probably not final version of the API and are here to give rough idea, what must be transferred.
-
-### RAR Input
-
-This is direct representation of all RAR inputs.
-
-```csharp
-public sealed partial class ResolveAssemblyReferenceInput
-{
-
-    public ResolveAssemblyReferenceInput() { }
-
-    public string[] AllowedAssemblyExtensions { get { throw null; } set { } }
-
-    public string[] AllowedRelatedFileExtensions { get { throw null; } set { } }
-
-    public string AppConfigFile { get { throw null; } set { } }
-
-    public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
-
-    public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
-
-    public bool AutoUnify { get { throw null; } set { } }
-
-    public string[] CandidateAssemblyFiles { get { throw null; } set { } }
-
-    public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
-
-    public bool DoNotCopyLocalIfInGac { get { throw null; } set { } }
-
-    public bool FindDependencies { get { throw null; } set { } }
-
-    public bool FindDependenciesOfExternallyResolvedReferences { get { throw null; } set { } }
-
-    public bool FindRelatedFiles { get { throw null; } set { } }
-
-    public bool FindSatellites { get { throw null; } set { } }
-
-    public bool FindSerializationAssemblies { get { throw null; } set { } }
-
-    public Microsoft.Build.Framework.ITaskItem[] FullFrameworkAssemblyTables { get { throw null; } set { } }
-
-    public string[] FullFrameworkFolders { get { throw null; } set { } }
-
-    public string[] FullTargetFrameworkSubsetNames { get { throw null; } set { } }
-
-    public bool IgnoreDefaultInstalledAssemblySubsetTables { get { throw null; } set { } }
-
-    public bool IgnoreDefaultInstalledAssemblyTables { get { throw null; } set { } }
-
-    public bool IgnoreTargetFrameworkAttributeVersionMismatch { get { throw null; } set { } }
-
-    public bool IgnoreVersionForFrameworkReferences { get { throw null; } set { } }
-
-    public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
-
-    public Microsoft.Build.Framework.ITaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
-
-    public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
-
-    public string ProfileName { get { throw null; } set { } }
-
-    public Microsoft.Build.Framework.ITaskItem[] ResolvedSDKReferences { get { throw null; } set { } }
-
-    public string[] SearchPaths { get { throw null; } set { } }
-
-    public bool Silent { get { throw null; } set { } }
-
-    public string StateFile { get { throw null; } set { } }
-
-    public bool SupportsBindingRedirectGeneration { get { throw null; } set { } }
-
-    public string TargetedRuntimeVersion { get { throw null; } set { } }
-
-    public string[] TargetFrameworkDirectories { get { throw null; } set { } }
-
-    public string TargetFrameworkMoniker { get { throw null; } set { } }
-
-    public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }
-
-    public string[] TargetFrameworkSubsets { get { throw null; } set { } }
-
-    public string TargetFrameworkVersion { get { throw null; } set { } }
-
-    public string TargetProcessorArchitecture { get { throw null; } set { } }
-
-    public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
-
-    public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
-}
-```
-
-### RAR Output
-
-Output of RAR node has to also reflect RAR task.
-```csharp
-public sealed partial class ResolveAssemblyReferenceOutput
-{
-    public ResolveAssemblyReferenceOutput() { }
-
-    public Microsoft.Build.Framework.ITaskItem[] CopyLocalFiles { get { throw null; } }
-
-    public string DependsOnNETStandard { get { throw null; } }
-
-    public string DependsOnSystemRuntime { get { throw null; } }
-
-    public Microsoft.Build.Framework.ITaskItem[] FilesWritten { get { throw null; } }
-
-    public Microsoft.Build.Framework.ITaskItem[] RelatedFiles { get { throw null; } }
-
-    public Microsoft.Build.Framework.ITaskItem[] ResolvedDependencyFiles { get { throw null; } }
-
-    public Microsoft.Build.Framework.ITaskItem[] ResolvedFiles { get { throw null; } }
-
-    public Microsoft.Build.Framework.ITaskItem[] SatelliteFiles { get { throw null; } }
-
-    public Microsoft.Build.Framework.ITaskItem[] ScatterFiles { get { throw null; } }
-
-    public Microsoft.Build.Framework.ITaskItem[] SerializationAssemblyFiles { get { throw null; } }
-
-    public Microsoft.Build.Framework.ITaskItem[] SuggestedRedirects { get { throw null; }
-}
-```
-### Logging response
-
-Node also has to return logged data, preferably in stream which will be transferred during the RAR task execution to the client node. This should by done by using IProgress\<T> support in StreamJsonRPC. There is also support for async enumerable, but they must be pulled and are not pushed to the client (comparison can be found [here](https://github.com/microsoft/vs-streamjsonrpc/blob/master/doc/asyncenumerable.md#comparison-with-iprogresst)).
+The communication between nodes should be same as current cross node communication. RAR service will allow multiple net-pipe clients, each client session handled in separate thread.
 
-### Concurrency
+## RAR service instrumentation
 
-One of the biggest challenges with RAR as service, is to make execution and caching of RAR task thread-safe, since in most cases there will be multiple clients request data from it at once.
+RAR will use same instrumentation infrastructure leveraged by standard MSBuild nodes. We will make sure we log all important events needed to measure, maintain and troubleshoot RAR service.
 
-In the first phase of implementation the concurrency will be solved by serializing requests, but this will be replaced by optimal variant with no serializing.
+Instrumentation of RAR task execution will not change and will be handled by Out of process task infrastructure.
 
 # Non-Goals
 
 - File watchers: using them would decrease required IO operations when checking disc changes
-- Aggressive precomputation of results
+- Aggressive pre-computation of results
 - Improved caching of requests
 - Providing verbosity to RAR task:
     As mentioned in original [PR](https://github.com/dotnet/msbuild/pull/3914), there should be some way to determine what thing we should log (by severity), and pass back to the original node.
diff --git a/documentation/specs/resource-management.md b/documentation/specs/resource-management.md
new file mode 100644
index 00000000000..92343be73a4
--- /dev/null
+++ b/documentation/specs/resource-management.md
@@ -0,0 +1,41 @@
+# Managing tools with their own parallelism in MSBuild
+
+MSBuild supports building projects in parallel using multiple processes. Most users opt into `Environment.ProcessorCount` parallelism at the MSBuild layer.
+
+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.
+
+When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.
+
+As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.
+
+## Design
+
+`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`RequestCores`). These will be advisory only — a task can still do as much work as it desires with as many threads and processes as it desires.
+
+A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.
+
+`RequestCores(int requestedCores)` will always return a positive value, possibly less than the parameter if that many cores are not available. If no cores are available at the moment, the call blocks until at least one becomes available. The first `RequestCores` call made by a task is guaranteed to be non-blocking, though, as at minimum it will return the "implicit" core allocated to the task itself. This leads to two conceptual ways of adopting the API. Either the task calls `RequestCores` once, passing the desired number of cores, and then limiting its parallelism to whatever the call returns. Or the task makes additional calls throughout its execution, perhaps as it discovers more work to do. In this second scenario the task must be OK with waiting for additional cores for a long time or even forever if the sum of allocated cores has exceeded the limit defined by the policy.
+
+All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`. Additionally, all resources will be returned when the task calls `Reacquire` as this call is a signal to the scheduler that external tools have finished their work and the task can continue running. It does not matter when the resources where allocated - whether it was before or after calling `Yield` - they will all be released. Depending on the scheduling policy, freeing resources on `Reacquire` may prevent deadlocks.
+
+The exact core reservation policy and its interaction with task execution scheduling is still TBD. The pool of resources explicitly allocated by tasks may be completely separate, i.e. MSBuild will not wait until a resource is freed before starting execution of new tasks. Or it may be partially or fully shared to prevent oversubscribing the machine. In general, `ReleaseCores` may cause a transition of a waiting task to a Ready state. And vice-versa, completing a task or calling `Yield` may unblock a pending `RequestCores` call issued by a task.
+
+## Example 1
+
+In a 16-process build of a solution with 30 projects, 16 worker nodes are launched and begin executing work. Most block on dependencies to projects `A`, `B`, `C`, `D`, and `E`, so they don't have tasks running holding resources.
+
+Task `Work` is called in project `A` with 25 inputs. It would like to run as many as possible in parallel. It calls
+
+```C#
+int allowedParallelism = BuildEngine8.RequestCores(Inputs.Count); // Inputs.Count == 25
+```
+
+and gets up to `16`--the number of cores available to the build overall.
+
+While `A` runs `Work`, projects `B` and `C` run another task `Work2` that also calls `RequestCores` with a high value. Since `Work` in `A` has reserved all cores, the calls in `B` and `C` may return only 1, indicating that the task should not be doing parallel work. Subsequent `RequestCores` may block, waiting on `Work` to release cores (or return).
+
+When `Work` returns, MSBuild automatically returns all resources reserved by the task to the pool. At that time blocked `RequestCores` calls in `Work2` may unblock.
+
+## Implementation
+
+The `RequestCores` and `ReleaseCores` calls are marshaled back to the scheduler via newly introduced `INodePacket` implementations. The scheduler, having full view of the state of the system - i.e. number of build requests running, waiting, yielding, ..., number of cores explicitly allocated by individual tasks using the new API - is free to implement an arbitrary core allocation policy. In the initial implementation the policy will be controlled by a couple of environment variables to make it easy to test different settings.
diff --git a/documentation/wiki/Providing-Binary-Logs.md b/documentation/wiki/Providing-Binary-Logs.md
index b9423d5b271..dd7838e4c66 100644
--- a/documentation/wiki/Providing-Binary-Logs.md
+++ b/documentation/wiki/Providing-Binary-Logs.md
@@ -6,9 +6,9 @@ However, you should be aware what type of information is captured in the binary
 
 ⚠ NOTE: some build environments make secrets available using environment variables. Before sharing a binary log, make sure it does not expose API tokens or other important secrets.
 
-You can create a binary log by passing the `-bl` parameter to MSBuild.  You can explore the contents of the generated .binlog file using [MSBuild Structured Log Viewer](http://msbuildlog.com/).
+You can create a binary log by passing the `-bl` parameter to MSBuild. You can explore the contents of the generated .binlog file using [MSBuild Structured Log Viewer](http://msbuildlog.com/) or in your browser using [Live Structured Log Viewer](https://live.msbuildlog.com). Note: We don't capture any data from binary logs viewed on your browser.
 
 [More details about binary logs](Binary-Log.md)
 
 ## Capturing Binary Logs Through Visual Studio
-See [this guide](https://github.com/dotnet/project-system-tools) in the Project System Tools repo for capturing binlogs through Visual Studio.
+See [this guide](https://github.com/dotnet/project-system-tools) in the Project System Tools repo for capturing binlogs through Visual Studio.
\ No newline at end of file
diff --git a/documentation/wiki/UnGAC.md b/documentation/wiki/UnGAC.md
new file mode 100644
index 00000000000..79f7a3ddc77
--- /dev/null
+++ b/documentation/wiki/UnGAC.md
@@ -0,0 +1,34 @@
+# MSBuild, the Global Assembly Cache (GAC), and You
+
+## What is the GAC?
+
+See the [public documentation](https://docs.microsoft.com/dotnet/framework/app-domains/gac). The GAC is a folder where different installations of VS on the same machine look for assemblies that are commonly used. If an assembly is in the GAC, it will be prioritized over any other assembly.
+
+The only MSBuild assemblies you may see in the GAC are version 4.8. There is no reason any modern (15.1+) MSBuild assembly should be in the GAC today.
+
+## What MSBuild Assemblies are installed on my Machine?
+Run the [EnumerateMSBuild powershell script](https://github.com/Microsoft/msbuild/blob/master/scripts/EnumerateMSBuild.ps1) from our repo. It will output a `msbuild_versions.txt` file that lists MSBuild assemblies in their common folders along with their versions.
+
+## How to Remove MSBuild Assemblies from the GAC
+1. If on Visual Studio 16.8 or higher, repair your installation.
+2. Run these commands on a developer command prompt with admin privileges. Match the versions as necessary.
+    ```
+    gacutil /u "MSBuild, Version=15.1.0.0"
+    gacutil /u "Microsoft.Build.Conversion.Core, Version=15.1.0.0"
+    gacutil /u "Microsoft.Build, Version=15.1.0.0"
+    gacutil /u "Microsoft.Build.Engine, Version=15.1.0.0"
+    gacutil /u "Microsoft.Build.Tasks.Core, Version=15.1.0.0"
+    gacutil /u "Microsoft.Build.Utilities.Core, Version=15.1.0.0"
+    gacutil /u "Microsoft.Build.Framework, Version=15.1.0.0"
+    ```
+3. If you want to do this 'safely', move the folder out of the GAC and return it if it doesn't resolve the issue.
+
+## Related GAC issues
+https://developercommunity.visualstudio.com/content/problem/311136/update-to-1580-projects-wont-load.html
+
+https://developercommunity.visualstudio.com/content/problem/953754/after-update-to-1650-no-longer-able-to-loadcreate.html
+
+https://developercommunity.visualstudio.com/content/problem/208631/unable-to-create-or-open-solution.html
+
+## Other assemblies
+We have an issue [tracking other assemblies](https://github.com/dotnet/msbuild/issues/5955) that can cause problems when in the GAC. If one of these assemblies is causing issues for you, refer to [How to Remove MSBuild Assemblies from the GAC](#how-to-remove-msbuild-assemblies-from-the-gac) while changing the assembly name and version.
diff --git a/eng/Packages.props b/eng/Packages.props
index c4ae1af44ed..97f340790f5 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -18,6 +18,7 @@
     <PackageReference Update="SourceLink.Create.CommandLine" Version="2.1.2" />
     <PackageReference Update="System.CodeDom" Version="4.4.0" />
     <PackageReference Update="System.Collections.Immutable" Version="5.0.0" />
+    <PackageReference Update="System.Configuration.ConfigurationManager" Version="4.7.0" />
     <PackageReference Update="System.Memory" Version="4.5.4" />
     <PackageReference Update="System.Reflection.Metadata" Version="1.6.0" />
     <PackageReference Update="System.Resources.Extensions" Version="4.6.0" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index caf93915568..b1cd6f1c918 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,13 +1,13 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="5.0.0-beta.21112.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="5.0.0-beta.21160.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>d8c68c834bcca3f721ad1550404807e301ba7afe</Sha>
+      <Sha>670382be6a978ba401c21c57ba44311199d2682a</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="5.9.0-rc.7097">
+    <Dependency Name="NuGet.Build.Tasks" Version="5.9.0-rc.7122">
       <Uri>https://dev.azure.com/devdiv/DevDiv/_git/NuGet-NuGet.Client-Trusted</Uri>
-      <Sha>ed9af679b4425c1ff4d41d2302d73f6e580a2839</Sha>
+      <Sha>abf0ba0638070af16427cea69bd47a9945fd5d7a</Sha>
     </Dependency>
     <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="3.9.0-2.20574.26">
       <Uri>https://github.com/dotnet/roslyn</Uri>
diff --git a/eng/Versions.props b/eng/Versions.props
index 3916d33cc6a..d6b6d8beda1 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -27,7 +27,7 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>5.0.102</DotNetCliVersion>
     <MicrosoftNetCompilersToolsetVersion>3.9.0-2.20574.26</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>5.9.0-rc.7097</NuGetBuildTasksVersion>
+    <NuGetBuildTasksVersion>5.9.0-rc.7122</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/common/post-build/publish-using-darc.ps1 b/eng/common/post-build/publish-using-darc.ps1
index 650b13b089b..a40ee827a43 100644
--- a/eng/common/post-build/publish-using-darc.ps1
+++ b/eng/common/post-build/publish-using-darc.ps1
@@ -54,7 +54,7 @@ try {
   --id $buildId `
   --publishing-infra-version $PublishingInfraVersion `
   --default-channels `
-  --source-branch master `
+  --source-branch main `
   --azdev-pat $AzdoToken `
   --bar-uri $MaestroApiEndPoint `
   --password $MaestroToken `
diff --git a/eng/config/OptProf.json b/eng/config/OptProf.json
index 9f2887b156e..53061450ff8 100644
--- a/eng/config/OptProf.json
+++ b/eng/config/OptProf.json
@@ -14,13 +14,13 @@
           "container": "MSBuild",
           "testCases": [
             "MSBuild.Managed.vs_perf_designtime_commandline_msbuild_cs_mstv_fullbuild",
-            "MSBuild.Managed.vs_perf_designtime_commandline_msbuild_cs_mstv_fullbuild_4proc"
+            "MSBuild.Managed.vs_perf_designtime_commandline_msbuild_cs_mstv_fullbuild_4proc",
           ]
         },
         {
           "container": "ManagedLangs",
           "testCases": [
-            "VSPE.OptProfTests.DDRIT_RPS_ManagedLangs_Debug"
+            "ManagedLangs.OptProfTests.DDRIT_RPS_ManagedLangs"
           ]
         }  
       ]
diff --git a/global.json b/global.json
index 4d0b3b44e05..5aff70ee07d 100644
--- a/global.json
+++ b/global.json
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "5.0.0-beta.21112.3"
+    "Microsoft.DotNet.Arcade.Sdk": "5.0.0-beta.21160.3"
   }
 }
diff --git a/netci.groovy b/netci.groovy
deleted file mode 100644
index b74d67b95a4..00000000000
--- a/netci.groovy
+++ /dev/null
@@ -1,89 +0,0 @@
-// Import the utility functionality.
-import jobs.generation.*;
-
-// The input project name
-project = GithubProject
-
-// The input branch name (e.g. master)
-branch = GithubBranchName
-
-// What this repo is using for its machine images at the current time
-imageVersionMap = ['RHEL7.2' : 'latest']
-
-def CreateJob(script, runtime, osName, isPR, machineAffinityOverride = null, shouldSkipTestsWhenResultsNotFound = false, isSourceBuild = false) {
-    def newJobName = Utilities.getFullJobName("innerloop_${osName}_${runtime}${isSourceBuild ? '_SourceBuild_' : ''}", isPR)
-
-    // Create a new job with the specified name.  The brace opens a new closure
-    // and calls made within that closure apply to the newly created job.
-    def newJob = job(newJobName) {
-        description('')
-    }
-
-    newJob.with{
-        steps{
-            if(osName.contains("Windows") || osName.contains("windows")) {
-                batchFile(script)
-            } else {
-                shell(script)
-            }
-        }
-
-        skipTestsWhenResultsNotFound = shouldSkipTestsWhenResultsNotFound
-    }
-
-    // Add xunit result archiving. Skip if no results found.
-    Utilities.addXUnitDotNETResults(newJob, 'artifacts/**/TestResults/*.xml', skipTestsWhenResultsNotFound)
-
-    if (machineAffinityOverride == null) {
-        def imageVersion = imageVersionMap[osName];
-        Utilities.setMachineAffinity(newJob, osName, imageVersion)
-    }
-    else {
-        Utilities.setMachineAffinity(newJob, machineAffinityOverride)
-    }
-
-    Utilities.standardJobSetup(newJob, project, isPR, "*/${branch}")
-    // Add archiving of logs (even if the build failed)
-    Utilities.addArchival(newJob,
-                        'artifacts/**/log/*.binlog,artifacts/**/log/*.log,artifacts/**/TestResults/*,artifacts/**/MSBuild_*.failure.txt', /* filesToArchive */
-                        '', /* filesToExclude */
-                        false, /* doNotFailIfNothingArchived */
-                        false, /* archiveOnlyIfSuccessful */)
-    // Add trigger
-    if (isPR) {
-        TriggerBuilder prTrigger = TriggerBuilder.triggerOnPullRequest()
-
-        if (runtime == "MonoTest") {
-            // Until they're passing reliably, require opt in
-            // for Mono tests
-            prTrigger.setCustomTriggerPhrase("(?i).*test\\W+mono.*")
-            prTrigger.triggerOnlyOnComment()
-        }
-
-        prTrigger.triggerForBranch(branch)
-        // Set up what shows up in Github:
-        prTrigger.setGithubContext("${osName} Build for ${runtime}")
-        prTrigger.emitTrigger(newJob)
-    } else {
-        if (runtime != "Mono") {
-            Utilities.addGithubPushTrigger(newJob)
-        }
-    }
-}
-
-// sourcebuild simulation
-CreateJob(
-    "./build/build.sh build -dotnetBuildFromSource -skiptests -pack -configuration Release",
-    "CoreCLR",
-    "RHEL7.2",
-    true,
-    null,
-    true,
-    true)
-
-JobReport.Report.generateJobReport(out)
-
-// Make the call to generate the help job
-Utilities.createHelperJob(this, project, branch,
-    "Welcome to the ${project} Repository",  // This is prepended to the help message
-    "Have a nice day!")  // This is appended to the help message.  You might put known issues here.
diff --git a/ref/Microsoft.Build.Engine/net/Microsoft.Build.Engine.cs b/ref/Microsoft.Build.Engine/net/Microsoft.Build.Engine.cs
index 88478e05b32..0f848bbe337 100644
--- a/ref/Microsoft.Build.Engine/net/Microsoft.Build.Engine.cs
+++ b/ref/Microsoft.Build.Engine/net/Microsoft.Build.Engine.cs
@@ -93,8 +93,8 @@ public void CopyTo(System.Array array, int index) { }
     [System.FlagsAttribute]
     public enum BuildSettings
     {
-        DoNotResetPreviouslyBuiltTargets = 1,
         None = 0,
+        DoNotResetPreviouslyBuiltTargets = 1,
     }
     public partial class BuildTask
     {
@@ -367,13 +367,13 @@ public void SetProperty(string propertyName, string propertyValue, string condit
     [System.FlagsAttribute]
     public enum ProjectLoadSettings
     {
-        IgnoreMissingImports = 1,
         None = 0,
+        IgnoreMissingImports = 1,
     }
     public enum PropertyPosition
     {
-        UseExistingOrCreateAfterLastImport = 1,
         UseExistingOrCreateAfterLastPropertyGroup = 0,
+        UseExistingOrCreateAfterLastImport = 1,
     }
     public sealed partial class RemoteErrorException : System.Exception
     {
@@ -439,8 +439,8 @@ public void CopyTo(Microsoft.Build.BuildEngine.Toolset[] array, int arrayIndex)
     [System.FlagsAttribute]
     public enum ToolsetDefinitionLocations
     {
-        ConfigurationFile = 1,
         None = 0,
+        ConfigurationFile = 1,
         Registry = 2,
     }
     public partial class UsingTask
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index 7b06c3e66aa..887de160539 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -6,7 +6,9 @@ namespace Microsoft.Build.Framework
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct BuildEngineResult
     {
-        public BuildEngineResult(bool result, System.Collections.Generic.List<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> targetOutputsPerProject) { throw null;}
+        private object _dummy;
+        private int _dummyPrimitive;
+        public BuildEngineResult(bool result, System.Collections.Generic.List<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> targetOutputsPerProject) { throw null; }
         public bool Result { get { throw null; } }
         public System.Collections.Generic.IList<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> TargetOutputsPerProject { get { throw null; } }
     }
@@ -36,6 +38,7 @@ protected BuildEventArgs(string message, string helpKeyword, string senderName,
         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } }
         public virtual string Message { get { throw null; } protected set { } }
+        protected System.DateTime RawTimestamp { get { throw null; } set { } }
         public string SenderName { get { throw null; } }
         public int ThreadId { get { throw null; } }
         public System.DateTime Timestamp { get { throw null; } }
@@ -150,7 +153,7 @@ protected CustomBuildEventArgs(string message, string helpKeyword, string sender
     public partial class EnvironmentVariableReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public EnvironmentVariableReadEventArgs() { }
-        public EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
         public string EnvironmentVariableName { get { throw null; } set { } }
     }
     public partial class ExternalProjectFinishedEventArgs : Microsoft.Build.Framework.CustomBuildEventArgs
@@ -211,23 +214,23 @@ public partial interface IBuildEngine7 : Microsoft.Build.Framework.IBuildEngine,
     {
         bool AllowFailureWithoutError { get; set; }
     }
-    public partial interface ICancelableTask : Microsoft.Build.Framework.ITask
+    public partial interface IBuildEngine8 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7
     {
-        void Cancel();
+        bool ShouldTreatWarningAsError(string warningCode);
     }
-    public partial class TaskExecutionContext
+    public partial interface IBuildEngine9 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7, Microsoft.Build.Framework.IBuildEngine8
     {
-        public TaskExecutionContext(string startupDirectory, Dictionary<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture) { throw null; }
-
-        public string StartupDirectory { get; }
-        public Dictionary<string, string> BuildProcessEnvironment { get; }
-        public CultureInfo Culture { get; }
-        public CultureInfo UICulture { get; }
+        void ReleaseCores(int coresToRelease);
+        int RequestCores(int requestedCores);
+    }
+    public partial interface ICancelableTask : Microsoft.Build.Framework.ITask
+    {
+        void Cancel();
     }
     public partial interface IConcurrentTask
     {
-        void ConfigureForConcurrentExecution(TaskExecutionContext executionContext);
-    }     
+        void ConfigureForConcurrentExecution(Microsoft.Build.Framework.TaskExecutionContext executionContext);
+    }
     public partial interface IEventRedirector
     {
         void ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent);
@@ -309,7 +312,7 @@ public partial interface ITaskFactory2 : Microsoft.Build.Framework.ITaskFactory
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("9049A481-D0E9-414f-8F92-D4F67A0359A6")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface ITaskHost
     {
     }
@@ -342,7 +345,7 @@ public LazyFormattedBuildEventArgs(string message, string helpKeyword, string se
         public LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
         public override string Message { get { throw null; } }
     }
-    [System.AttributeUsageAttribute((System.AttributeTargets)(4), AllowMultiple=false, Inherited=true)]
+    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
     public sealed partial class LoadInSeparateAppDomainAttribute : System.Attribute
     {
         public LoadInSeparateAppDomainAttribute() { }
@@ -362,24 +365,24 @@ public override void GetObjectData(System.Runtime.Serialization.SerializationInf
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     public enum LoggerVerbosity
     {
-        Detailed = 3,
-        Diagnostic = 4,
+        Quiet = 0,
         Minimal = 1,
         Normal = 2,
-        Quiet = 0,
+        Detailed = 3,
+        Diagnostic = 4,
     }
     public enum MessageImportance
     {
         High = 0,
-        Low = 2,
         Normal = 1,
+        Low = 2,
     }
     public partial class MetaprojectGeneratedEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public string metaprojectXml;
         public MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPath, string message) { }
     }
-    [System.AttributeUsageAttribute((System.AttributeTargets)(128), AllowMultiple=false, Inherited=false)]
+    [System.AttributeUsageAttribute(System.AttributeTargets.Property, AllowMultiple=false, Inherited=false)]
     public sealed partial class OutputAttribute : System.Attribute
     {
         public OutputAttribute() { }
@@ -388,7 +391,7 @@ public sealed partial class ProjectEvaluationFinishedEventArgs : Microsoft.Build
     {
         public ProjectEvaluationFinishedEventArgs() { }
         public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) { }
-        public System.Nullable<Microsoft.Build.Framework.Profiler.ProfilerResult> ProfilerResult { get { throw null; } set { } }
+        public Microsoft.Build.Framework.Profiler.ProfilerResult? ProfilerResult { get { throw null; } set { } }
         public string ProjectFile { get { throw null; } set { } }
     }
     public partial class ProjectEvaluationStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
@@ -436,7 +439,7 @@ public ProjectStartedEventArgs(string message, string helpKeyword, string projec
     public partial class PropertyInitialValueSetEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public PropertyInitialValueSetEventArgs() { }
-        public PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
         public string PropertyName { get { throw null; } set { } }
         public string PropertySource { get { throw null; } set { } }
         public string PropertyValue { get { throw null; } set { } }
@@ -444,7 +447,7 @@ public PropertyInitialValueSetEventArgs(string propertyName, string propertyValu
     public partial class PropertyReassignmentEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public PropertyReassignmentEventArgs() { }
-        public PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
         public string Location { get { throw null; } set { } }
         public string NewValue { get { throw null; } set { } }
         public string PreviousValue { get { throw null; } set { } }
@@ -452,26 +455,26 @@ public PropertyReassignmentEventArgs(string propertyName, string previousValue,
     }
     public enum RegisteredTaskObjectLifetime
     {
-        AppDomain = 1,
         Build = 0,
+        AppDomain = 1,
     }
-    [System.AttributeUsageAttribute((System.AttributeTargets)(128), AllowMultiple=false, Inherited=false)]
+    [System.AttributeUsageAttribute(System.AttributeTargets.Property, AllowMultiple=false, Inherited=false)]
     public sealed partial class RequiredAttribute : System.Attribute
     {
         public RequiredAttribute() { }
     }
-    [System.AttributeUsageAttribute((System.AttributeTargets)(4), AllowMultiple=false, Inherited=false)]
+    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
     public sealed partial class RequiredRuntimeAttribute : System.Attribute
     {
         public RequiredRuntimeAttribute(string runtimeVersion) { }
         public string RuntimeVersion { get { throw null; } }
     }
-    [System.AttributeUsageAttribute((System.AttributeTargets)(4), AllowMultiple=false, Inherited=false)]
+    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
     public sealed partial class RunInMTAAttribute : System.Attribute
     {
         public RunInMTAAttribute() { }
     }
-    [System.AttributeUsageAttribute((System.AttributeTargets)(4), AllowMultiple=false, Inherited=false)]
+    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
     public sealed partial class RunInSTAAttribute : System.Attribute
     {
         public RunInSTAAttribute() { }
@@ -479,7 +482,7 @@ public RunInSTAAttribute() { }
     public abstract partial class SdkLogger
     {
         protected SdkLogger() { }
-        public abstract void LogMessage(string message, Microsoft.Build.Framework.MessageImportance messageImportance=(Microsoft.Build.Framework.MessageImportance)(2));
+        public abstract void LogMessage(string message, Microsoft.Build.Framework.MessageImportance messageImportance = Microsoft.Build.Framework.MessageImportance.Low);
     }
     public sealed partial class SdkReference : System.IEquatable<Microsoft.Build.Framework.SdkReference>
     {
@@ -491,7 +494,7 @@ public SdkReference(string name, string version, string minimumVersion) { }
         public override bool Equals(object obj) { throw null; }
         public override int GetHashCode() { throw null; }
         public override string ToString() { throw null; }
-        public static bool TryParse(string sdk, out Microsoft.Build.Framework.SdkReference sdkReference) { sdkReference = default(Microsoft.Build.Framework.SdkReference); throw null; }
+        public static bool TryParse(string sdk, out Microsoft.Build.Framework.SdkReference sdkReference) { throw null; }
     }
     public abstract partial class SdkResolver
     {
@@ -525,10 +528,10 @@ protected SdkResult() { }
     public abstract partial class SdkResultFactory
     {
         protected SdkResultFactory() { }
-        public abstract Microsoft.Build.Framework.SdkResult IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings=null);
-        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd=null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd=null, System.Collections.Generic.IEnumerable<string> warnings=null) { throw null; }
-        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings=null) { throw null; }
-        public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings=null);
+        public abstract Microsoft.Build.Framework.SdkResult IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings = null);
+        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd = null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd = null, System.Collections.Generic.IEnumerable<string> warnings = null) { throw null; }
+        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings = null) { throw null; }
+        public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings = null);
     }
     public partial class SdkResultItem
     {
@@ -541,10 +544,10 @@ public SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<stri
     }
     public enum TargetBuiltReason
     {
-        AfterTargets = 3,
+        None = 0,
         BeforeTargets = 1,
         DependsOn = 2,
-        None = 0,
+        AfterTargets = 3,
     }
     public partial class TargetFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
@@ -589,6 +592,14 @@ public TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.B
         public string CommandLine { get { throw null; } }
         public string TaskName { get { throw null; } }
     }
+    public partial class TaskExecutionContext
+    {
+        public TaskExecutionContext(string startupDirectory, System.Collections.Generic.Dictionary<string, string> buildProcessEnvironment, System.Globalization.CultureInfo culture, System.Globalization.CultureInfo uiCulture) { }
+        public System.Collections.Generic.Dictionary<string, string> BuildProcessEnvironment { get { throw null; } }
+        public System.Globalization.CultureInfo Culture { get { throw null; } }
+        public string StartupDirectory { get { throw null; } }
+        public System.Globalization.CultureInfo UICulture { get { throw null; } }
+    }
     public partial class TaskFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
         protected TaskFinishedEventArgs() { }
@@ -600,6 +611,22 @@ public TaskFinishedEventArgs(string message, string helpKeyword, string projectF
         public string TaskName { get { throw null; } }
     }
     public delegate void TaskFinishedEventHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e);
+    public partial class TaskParameterEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemType, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) { }
+        public System.Collections.IList Items { get { throw null; } }
+        public string ItemType { get { throw null; } }
+        public Microsoft.Build.Framework.TaskParameterMessageKind Kind { get { throw null; } }
+        public bool LogItemMetadata { get { throw null; } }
+        public override string Message { get { throw null; } }
+    }
+    public enum TaskParameterMessageKind
+    {
+        TaskInput = 0,
+        TaskOutput = 1,
+        AddItem = 2,
+        RemoveItem = 3,
+    }
     public partial class TaskPropertyInfo
     {
         public TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) { }
@@ -630,7 +657,7 @@ public TelemetryEventArgs() { }
     public partial class UninitializedPropertyReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public UninitializedPropertyReadEventArgs() { }
-        public UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
         public string PropertyName { get { throw null; } set { } }
     }
 }
@@ -639,9 +666,11 @@ namespace Microsoft.Build.Framework.Profiler
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct EvaluationLocation
     {
-        public EvaluationLocation(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, System.Nullable<int> line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null;}
-        public EvaluationLocation(long id, System.Nullable<long> parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, System.Nullable<int> line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null;}
-        public EvaluationLocation(System.Nullable<long> parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, System.Nullable<int> line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null;}
+        private object _dummy;
+        private int _dummyPrimitive;
+        public EvaluationLocation(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null; }
+        public EvaluationLocation(long id, long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null; }
+        public EvaluationLocation(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null; }
         public string ElementDescription { get { throw null; } }
         public string ElementName { get { throw null; } }
         public static Microsoft.Build.Framework.Profiler.EvaluationLocation EmptyLocation { get { throw null; } }
@@ -651,44 +680,45 @@ public partial struct EvaluationLocation
         public long Id { get { throw null; } }
         public bool IsEvaluationPass { get { throw null; } }
         public Microsoft.Build.Framework.Profiler.EvaluationLocationKind Kind { get { throw null; } }
-        public System.Nullable<int> Line { get { throw null; } }
-        public System.Nullable<long> ParentId { get { throw null; } }
+        public int? Line { get { throw null; } }
+        public long? ParentId { get { throw null; } }
         public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForAggregatedGlob() { throw null; }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForCondition(System.Nullable<long> parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, System.Nullable<int> line, string condition) { throw null; }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForGlob(System.Nullable<long> parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, System.Nullable<int> line, string globDescription) { throw null; }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForProject(System.Nullable<long> parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, System.Nullable<int> line, Microsoft.Build.Framework.IProjectElement element) { throw null; }
+        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForCondition(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string condition) { throw null; }
+        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForGlob(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string globDescription) { throw null; }
+        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForProject(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, Microsoft.Build.Framework.IProjectElement element) { throw null; }
         public override bool Equals(object obj) { throw null; }
         public override int GetHashCode() { throw null; }
         public override string ToString() { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithEvaluationPass(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string passDescription=null) { throw null; }
+        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithEvaluationPass(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string passDescription = null) { throw null; }
         public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFile(string file) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFileLineAndCondition(string file, System.Nullable<int> line, string condition) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFileLineAndElement(string file, System.Nullable<int> line, Microsoft.Build.Framework.IProjectElement element) { throw null; }
+        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFileLineAndCondition(string file, int? line, string condition) { throw null; }
+        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFileLineAndElement(string file, int? line, Microsoft.Build.Framework.IProjectElement element) { throw null; }
         public Microsoft.Build.Framework.Profiler.EvaluationLocation WithGlob(string globDescription) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithParentId(System.Nullable<long> parentId) { throw null; }
+        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithParentId(long? parentId) { throw null; }
     }
     public enum EvaluationLocationKind : byte
     {
-        Condition = (byte)1,
         Element = (byte)0,
+        Condition = (byte)1,
         Glob = (byte)2,
     }
     public enum EvaluationPass : byte
     {
+        TotalEvaluation = (byte)0,
+        TotalGlobbing = (byte)1,
         InitialProperties = (byte)2,
+        Properties = (byte)3,
         ItemDefinitionGroups = (byte)4,
         Items = (byte)5,
         LazyItems = (byte)6,
-        Properties = (byte)3,
-        Targets = (byte)8,
-        TotalEvaluation = (byte)0,
-        TotalGlobbing = (byte)1,
         UsingTasks = (byte)7,
+        Targets = (byte)8,
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct ProfiledLocation
     {
-        public ProfiledLocation(System.TimeSpan inclusiveTime, System.TimeSpan exclusiveTime, int numberOfHits) { throw null;}
+        private int _dummyPrimitive;
+        public ProfiledLocation(System.TimeSpan inclusiveTime, System.TimeSpan exclusiveTime, int numberOfHits) { throw null; }
         public System.TimeSpan ExclusiveTime { get { throw null; } }
         public System.TimeSpan InclusiveTime { get { throw null; } }
         public int NumberOfHits { get { throw null; } }
@@ -699,7 +729,8 @@ public partial struct ProfiledLocation
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct ProfilerResult
     {
-        public ProfilerResult(System.Collections.Generic.IDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> profiledLocations) { throw null;}
+        private object _dummy;
+        public ProfilerResult(System.Collections.Generic.IDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> profiledLocations) { throw null; }
         public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> ProfiledLocations { get { throw null; } }
         public override bool Equals(object obj) { throw null; }
         public override int GetHashCode() { throw null; }
@@ -810,8 +841,8 @@ public void EndInit() { }
     }
     public enum DefaultValueSourceLocation
     {
-        AfterContext = 1,
         BeforeContext = 0,
+        AfterContext = 1,
     }
     public sealed partial class DynamicEnumProperty : Microsoft.Build.Framework.XamlTypes.BaseProperty
     {
@@ -854,8 +885,8 @@ public FileExtension() { }
     public sealed partial class IntProperty : Microsoft.Build.Framework.XamlTypes.BaseProperty
     {
         public IntProperty() { }
-        public System.Nullable<int> MaxValue { get { throw null; } set { } }
-        public System.Nullable<int> MinValue { get { throw null; } set { } }
+        public int? MaxValue { get { throw null; } set { } }
+        public int? MinValue { get { throw null; } set { } }
         public override void EndInit() { }
     }
     public partial interface IProjectSchemaNode
@@ -941,8 +972,8 @@ public void EndInit() { }
     }
     public enum RuleOverrideMode
     {
-        Extend = 1,
         Replace = 0,
+        Extend = 1,
     }
     public abstract partial class RuleSchema
     {
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index 6f74604e62f..fa36f414395 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -6,7 +6,9 @@ namespace Microsoft.Build.Framework
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct BuildEngineResult
     {
-        public BuildEngineResult(bool result, System.Collections.Generic.List<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> targetOutputsPerProject) { throw null;}
+        private object _dummy;
+        private int _dummyPrimitive;
+        public BuildEngineResult(bool result, System.Collections.Generic.List<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> targetOutputsPerProject) { throw null; }
         public bool Result { get { throw null; } }
         public System.Collections.Generic.IList<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> TargetOutputsPerProject { get { throw null; } }
     }
@@ -36,6 +38,7 @@ protected BuildEventArgs(string message, string helpKeyword, string senderName,
         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } }
         public virtual string Message { get { throw null; } protected set { } }
+        protected System.DateTime RawTimestamp { get { throw null; } set { } }
         public string SenderName { get { throw null; } }
         public int ThreadId { get { throw null; } }
         public System.DateTime Timestamp { get { throw null; } }
@@ -150,7 +153,7 @@ protected CustomBuildEventArgs(string message, string helpKeyword, string sender
     public partial class EnvironmentVariableReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public EnvironmentVariableReadEventArgs() { }
-        public EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
         public string EnvironmentVariableName { get { throw null; } set { } }
     }
     public partial class ExternalProjectFinishedEventArgs : Microsoft.Build.Framework.CustomBuildEventArgs
@@ -211,23 +214,23 @@ public partial interface IBuildEngine7 : Microsoft.Build.Framework.IBuildEngine,
     {
         bool AllowFailureWithoutError { get; set; }
     }
-    public partial interface ICancelableTask : Microsoft.Build.Framework.ITask
+    public partial interface IBuildEngine8 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7
     {
-        void Cancel();
+        bool ShouldTreatWarningAsError(string warningCode);
     }
-    public partial class TaskExecutionContext
+    public partial interface IBuildEngine9 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7, Microsoft.Build.Framework.IBuildEngine8
+    {
+        void ReleaseCores(int coresToRelease);
+        int RequestCores(int requestedCores);
+    }
+    public partial interface ICancelableTask : Microsoft.Build.Framework.ITask
     {
-        public TaskExecutionContext(string startupDirectory, Dictionary<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture) { throw null; }
-
-        public string StartupDirectory { get; }
-        public Dictionary<string, string> BuildProcessEnvironment { get; }
-        public CultureInfo Culture { get; }
-        public CultureInfo UICulture { get; }
+        void Cancel();
     }
     public partial interface IConcurrentTask
     {
-        void ConfigureForConcurrentExecution(TaskExecutionContext executionContext);
-    }    
+        void ConfigureForConcurrentExecution(Microsoft.Build.Framework.TaskExecutionContext executionContext);
+    }
     public partial interface IEventRedirector
     {
         void ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent);
@@ -309,7 +312,7 @@ public partial interface ITaskFactory2 : Microsoft.Build.Framework.ITaskFactory
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("9049A481-D0E9-414f-8F92-D4F67A0359A6")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface ITaskHost
     {
     }
@@ -342,7 +345,7 @@ public LazyFormattedBuildEventArgs(string message, string helpKeyword, string se
         public LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
         public override string Message { get { throw null; } }
     }
-    [System.AttributeUsageAttribute((System.AttributeTargets)(4), AllowMultiple=false, Inherited=true)]
+    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
     public sealed partial class LoadInSeparateAppDomainAttribute : System.Attribute
     {
         public LoadInSeparateAppDomainAttribute() { }
@@ -361,24 +364,24 @@ public override void GetObjectData(System.Runtime.Serialization.SerializationInf
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     public enum LoggerVerbosity
     {
-        Detailed = 3,
-        Diagnostic = 4,
+        Quiet = 0,
         Minimal = 1,
         Normal = 2,
-        Quiet = 0,
+        Detailed = 3,
+        Diagnostic = 4,
     }
     public enum MessageImportance
     {
         High = 0,
-        Low = 2,
         Normal = 1,
+        Low = 2,
     }
     public partial class MetaprojectGeneratedEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public string metaprojectXml;
         public MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPath, string message) { }
     }
-    [System.AttributeUsageAttribute((System.AttributeTargets)(128), AllowMultiple=false, Inherited=false)]
+    [System.AttributeUsageAttribute(System.AttributeTargets.Property, AllowMultiple=false, Inherited=false)]
     public sealed partial class OutputAttribute : System.Attribute
     {
         public OutputAttribute() { }
@@ -387,7 +390,7 @@ public sealed partial class ProjectEvaluationFinishedEventArgs : Microsoft.Build
     {
         public ProjectEvaluationFinishedEventArgs() { }
         public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) { }
-        public System.Nullable<Microsoft.Build.Framework.Profiler.ProfilerResult> ProfilerResult { get { throw null; } set { } }
+        public Microsoft.Build.Framework.Profiler.ProfilerResult? ProfilerResult { get { throw null; } set { } }
         public string ProjectFile { get { throw null; } set { } }
     }
     public partial class ProjectEvaluationStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
@@ -435,7 +438,7 @@ public ProjectStartedEventArgs(string message, string helpKeyword, string projec
     public partial class PropertyInitialValueSetEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public PropertyInitialValueSetEventArgs() { }
-        public PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
         public string PropertyName { get { throw null; } set { } }
         public string PropertySource { get { throw null; } set { } }
         public string PropertyValue { get { throw null; } set { } }
@@ -443,7 +446,7 @@ public PropertyInitialValueSetEventArgs(string propertyName, string propertyValu
     public partial class PropertyReassignmentEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public PropertyReassignmentEventArgs() { }
-        public PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
         public string Location { get { throw null; } set { } }
         public string NewValue { get { throw null; } set { } }
         public string PreviousValue { get { throw null; } set { } }
@@ -451,26 +454,26 @@ public PropertyReassignmentEventArgs(string propertyName, string previousValue,
     }
     public enum RegisteredTaskObjectLifetime
     {
-        AppDomain = 1,
         Build = 0,
+        AppDomain = 1,
     }
-    [System.AttributeUsageAttribute((System.AttributeTargets)(128), AllowMultiple=false, Inherited=false)]
+    [System.AttributeUsageAttribute(System.AttributeTargets.Property, AllowMultiple=false, Inherited=false)]
     public sealed partial class RequiredAttribute : System.Attribute
     {
         public RequiredAttribute() { }
     }
-    [System.AttributeUsageAttribute((System.AttributeTargets)(4), AllowMultiple=false, Inherited=false)]
+    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
     public sealed partial class RequiredRuntimeAttribute : System.Attribute
     {
         public RequiredRuntimeAttribute(string runtimeVersion) { }
         public string RuntimeVersion { get { throw null; } }
     }
-    [System.AttributeUsageAttribute((System.AttributeTargets)(4), AllowMultiple=false, Inherited=false)]
+    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
     public sealed partial class RunInMTAAttribute : System.Attribute
     {
         public RunInMTAAttribute() { }
     }
-    [System.AttributeUsageAttribute((System.AttributeTargets)(4), AllowMultiple=false, Inherited=false)]
+    [System.AttributeUsageAttribute(System.AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
     public sealed partial class RunInSTAAttribute : System.Attribute
     {
         public RunInSTAAttribute() { }
@@ -478,7 +481,7 @@ public RunInSTAAttribute() { }
     public abstract partial class SdkLogger
     {
         protected SdkLogger() { }
-        public abstract void LogMessage(string message, Microsoft.Build.Framework.MessageImportance messageImportance=(Microsoft.Build.Framework.MessageImportance)(2));
+        public abstract void LogMessage(string message, Microsoft.Build.Framework.MessageImportance messageImportance = Microsoft.Build.Framework.MessageImportance.Low);
     }
     public sealed partial class SdkReference : System.IEquatable<Microsoft.Build.Framework.SdkReference>
     {
@@ -490,7 +493,7 @@ public SdkReference(string name, string version, string minimumVersion) { }
         public override bool Equals(object obj) { throw null; }
         public override int GetHashCode() { throw null; }
         public override string ToString() { throw null; }
-        public static bool TryParse(string sdk, out Microsoft.Build.Framework.SdkReference sdkReference) { sdkReference = default(Microsoft.Build.Framework.SdkReference); throw null; }
+        public static bool TryParse(string sdk, out Microsoft.Build.Framework.SdkReference sdkReference) { throw null; }
     }
     public abstract partial class SdkResolver
     {
@@ -524,10 +527,10 @@ protected SdkResult() { }
     public abstract partial class SdkResultFactory
     {
         protected SdkResultFactory() { }
-        public abstract Microsoft.Build.Framework.SdkResult IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings=null);
-        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd=null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd=null, System.Collections.Generic.IEnumerable<string> warnings=null) { throw null; }
-        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings=null) { throw null; }
-        public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings=null);
+        public abstract Microsoft.Build.Framework.SdkResult IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings = null);
+        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd = null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd = null, System.Collections.Generic.IEnumerable<string> warnings = null) { throw null; }
+        public virtual Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings = null) { throw null; }
+        public abstract Microsoft.Build.Framework.SdkResult IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings = null);
     }
     public partial class SdkResultItem
     {
@@ -540,10 +543,10 @@ public SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<stri
     }
     public enum TargetBuiltReason
     {
-        AfterTargets = 3,
+        None = 0,
         BeforeTargets = 1,
         DependsOn = 2,
-        None = 0,
+        AfterTargets = 3,
     }
     public partial class TargetFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
@@ -588,6 +591,14 @@ public TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.B
         public string CommandLine { get { throw null; } }
         public string TaskName { get { throw null; } }
     }
+    public partial class TaskExecutionContext
+    {
+        public TaskExecutionContext(string startupDirectory, System.Collections.Generic.Dictionary<string, string> buildProcessEnvironment, System.Globalization.CultureInfo culture, System.Globalization.CultureInfo uiCulture) { }
+        public System.Collections.Generic.Dictionary<string, string> BuildProcessEnvironment { get { throw null; } }
+        public System.Globalization.CultureInfo Culture { get { throw null; } }
+        public string StartupDirectory { get { throw null; } }
+        public System.Globalization.CultureInfo UICulture { get { throw null; } }
+    }
     public partial class TaskFinishedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
         protected TaskFinishedEventArgs() { }
@@ -599,6 +610,22 @@ public TaskFinishedEventArgs(string message, string helpKeyword, string projectF
         public string TaskName { get { throw null; } }
     }
     public delegate void TaskFinishedEventHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e);
+    public partial class TaskParameterEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemType, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) { }
+        public System.Collections.IList Items { get { throw null; } }
+        public string ItemType { get { throw null; } }
+        public Microsoft.Build.Framework.TaskParameterMessageKind Kind { get { throw null; } }
+        public bool LogItemMetadata { get { throw null; } }
+        public override string Message { get { throw null; } }
+    }
+    public enum TaskParameterMessageKind
+    {
+        TaskInput = 0,
+        TaskOutput = 1,
+        AddItem = 2,
+        RemoveItem = 3,
+    }
     public partial class TaskPropertyInfo
     {
         public TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) { }
@@ -629,7 +656,7 @@ public TelemetryEventArgs() { }
     public partial class UninitializedPropertyReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public UninitializedPropertyReadEventArgs() { }
-        public UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) { }
         public string PropertyName { get { throw null; } set { } }
     }
 }
@@ -638,9 +665,11 @@ namespace Microsoft.Build.Framework.Profiler
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct EvaluationLocation
     {
-        public EvaluationLocation(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, System.Nullable<int> line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null;}
-        public EvaluationLocation(long id, System.Nullable<long> parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, System.Nullable<int> line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null;}
-        public EvaluationLocation(System.Nullable<long> parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, System.Nullable<int> line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null;}
+        private object _dummy;
+        private int _dummyPrimitive;
+        public EvaluationLocation(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null; }
+        public EvaluationLocation(long id, long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null; }
+        public EvaluationLocation(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) { throw null; }
         public string ElementDescription { get { throw null; } }
         public string ElementName { get { throw null; } }
         public static Microsoft.Build.Framework.Profiler.EvaluationLocation EmptyLocation { get { throw null; } }
@@ -650,44 +679,45 @@ public partial struct EvaluationLocation
         public long Id { get { throw null; } }
         public bool IsEvaluationPass { get { throw null; } }
         public Microsoft.Build.Framework.Profiler.EvaluationLocationKind Kind { get { throw null; } }
-        public System.Nullable<int> Line { get { throw null; } }
-        public System.Nullable<long> ParentId { get { throw null; } }
+        public int? Line { get { throw null; } }
+        public long? ParentId { get { throw null; } }
         public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForAggregatedGlob() { throw null; }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForCondition(System.Nullable<long> parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, System.Nullable<int> line, string condition) { throw null; }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForGlob(System.Nullable<long> parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, System.Nullable<int> line, string globDescription) { throw null; }
-        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForProject(System.Nullable<long> parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, System.Nullable<int> line, Microsoft.Build.Framework.IProjectElement element) { throw null; }
+        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForCondition(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string condition) { throw null; }
+        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForGlob(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string globDescription) { throw null; }
+        public static Microsoft.Build.Framework.Profiler.EvaluationLocation CreateLocationForProject(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, Microsoft.Build.Framework.IProjectElement element) { throw null; }
         public override bool Equals(object obj) { throw null; }
         public override int GetHashCode() { throw null; }
         public override string ToString() { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithEvaluationPass(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string passDescription=null) { throw null; }
+        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithEvaluationPass(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string passDescription = null) { throw null; }
         public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFile(string file) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFileLineAndCondition(string file, System.Nullable<int> line, string condition) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFileLineAndElement(string file, System.Nullable<int> line, Microsoft.Build.Framework.IProjectElement element) { throw null; }
+        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFileLineAndCondition(string file, int? line, string condition) { throw null; }
+        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithFileLineAndElement(string file, int? line, Microsoft.Build.Framework.IProjectElement element) { throw null; }
         public Microsoft.Build.Framework.Profiler.EvaluationLocation WithGlob(string globDescription) { throw null; }
-        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithParentId(System.Nullable<long> parentId) { throw null; }
+        public Microsoft.Build.Framework.Profiler.EvaluationLocation WithParentId(long? parentId) { throw null; }
     }
     public enum EvaluationLocationKind : byte
     {
-        Condition = (byte)1,
         Element = (byte)0,
+        Condition = (byte)1,
         Glob = (byte)2,
     }
     public enum EvaluationPass : byte
     {
+        TotalEvaluation = (byte)0,
+        TotalGlobbing = (byte)1,
         InitialProperties = (byte)2,
+        Properties = (byte)3,
         ItemDefinitionGroups = (byte)4,
         Items = (byte)5,
         LazyItems = (byte)6,
-        Properties = (byte)3,
-        Targets = (byte)8,
-        TotalEvaluation = (byte)0,
-        TotalGlobbing = (byte)1,
         UsingTasks = (byte)7,
+        Targets = (byte)8,
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct ProfiledLocation
     {
-        public ProfiledLocation(System.TimeSpan inclusiveTime, System.TimeSpan exclusiveTime, int numberOfHits) { throw null;}
+        private int _dummyPrimitive;
+        public ProfiledLocation(System.TimeSpan inclusiveTime, System.TimeSpan exclusiveTime, int numberOfHits) { throw null; }
         public System.TimeSpan ExclusiveTime { get { throw null; } }
         public System.TimeSpan InclusiveTime { get { throw null; } }
         public int NumberOfHits { get { throw null; } }
@@ -698,7 +728,8 @@ public partial struct ProfiledLocation
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct ProfilerResult
     {
-        public ProfilerResult(System.Collections.Generic.IDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> profiledLocations) { throw null;}
+        private object _dummy;
+        public ProfilerResult(System.Collections.Generic.IDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> profiledLocations) { throw null; }
         public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> ProfiledLocations { get { throw null; } }
         public override bool Equals(object obj) { throw null; }
         public override int GetHashCode() { throw null; }
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index 719440bead7..319ce95d300 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -333,7 +333,6 @@ public Exec() { }
         [Microsoft.Build.Framework.OutputAttribute]
         public string StdOutEncoding { get { throw null; } set { } }
         protected override string ToolName { get { throw null; } }
-        public string UseUtf8Encoding { get { throw null; } set { } }
         public string WorkingDirectory { get { throw null; } set { } }
         protected internal override void AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
         protected override int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) { throw null; }
@@ -348,6 +347,8 @@ protected override void LogToolCommand(string message) { }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct ExtractedClassName
     {
+        private object _dummy;
+        private int _dummyPrimitive;
         public bool IsInsideConditionalBlock { get { throw null; } set { } }
         public string Name { get { throw null; } set { } }
     }
@@ -749,7 +750,7 @@ public Hash() { }
         public override bool Execute() { throw null; }
     }
     [System.Runtime.InteropServices.GuidAttribute("00020401-0000-0000-C000-000000000046")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IFixedTypeInfo
     {
         void AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, out System.IntPtr ppv);
@@ -907,7 +908,7 @@ public RequiresFramework35SP1Assembly() { }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
-    public partial class ResolveAssemblyReference : Microsoft.Build.Tasks.TaskExtension
+    public partial class ResolveAssemblyReference : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.IConcurrentTask
     {
         public ResolveAssemblyReference() { }
         public string[] AllowedAssemblyExtensions { get { throw null; } set { } }
@@ -978,6 +979,7 @@ public ResolveAssemblyReference() { }
         public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
         public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
         public override bool Execute() { throw null; }
+        void Microsoft.Build.Framework.IConcurrentTask.ConfigureForConcurrentExecution(Microsoft.Build.Framework.TaskExecutionContext executionContext) { }
     }
     public sealed partial class ResolveCodeAnalysisRuleSet : Microsoft.Build.Tasks.TaskExtension
     {
@@ -1390,7 +1392,7 @@ public ZipDirectory() { }
 }
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
 {
-    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("1D9FE38A-0226-4b95-9C6B-6DFFA2236270")]
     public partial class BootstrapperBuilder : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder
@@ -1415,11 +1417,11 @@ internal BuildMessage() { }
     [System.Runtime.InteropServices.GuidAttribute("936D32F9-1A68-4d5e-98EA-044AC9A1AADA")]
     public enum BuildMessageSeverity
     {
-        Error = 2,
         Info = 0,
         Warning = 1,
+        Error = 2,
     }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("FAD7BA7C-CA00-41e0-A5EF-2DA9A74E58E6")]
     public partial class BuildResults : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults
@@ -1430,7 +1432,7 @@ internal BuildResults() { }
         public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[] Messages { get { throw null; } }
         public bool Succeeded { get { throw null; } }
     }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("5D13802C-C830-4b41-8E7A-F69D9DD6A095")]
     public partial class BuildSettings : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
@@ -1454,13 +1456,13 @@ public BuildSettings() { }
     [System.Runtime.InteropServices.GuidAttribute("12F49949-7B60-49CD-B6A0-2B5E4A638AAF")]
     public enum ComponentsLocation
     {
-        Absolute = 2,
         HomeSite = 0,
         Relative = 1,
+        Absolute = 2,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("1D202366-5EEA-4379-9255-6F8CDB8587C9")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IBootstrapperBuilder
     {
         [System.Runtime.InteropServices.DispIdAttribute(1)]
@@ -1472,7 +1474,7 @@ public partial interface IBootstrapperBuilder
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("E3C981EA-99E6-4f48-8955-1AAFDFB5ACE4")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IBuildMessage
     {
         [System.Runtime.InteropServices.DispIdAttribute(4)]
@@ -1486,7 +1488,7 @@ public partial interface IBuildMessage
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("586B842C-D9C7-43b8-84E4-9CFC3AF9F13B")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IBuildResults
     {
         [System.Runtime.InteropServices.DispIdAttribute(3)]
@@ -1500,7 +1502,7 @@ public partial interface IBuildResults
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("87EEBC69-0948-4ce6-A2DE-819162B87CC6")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IBuildSettings
     {
         [System.Runtime.InteropServices.DispIdAttribute(2)]
@@ -1532,7 +1534,7 @@ public partial interface IBuildSettings
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("9E81BE3D-530F-4a10-8349-5D5947BA59AD")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IProduct
     {
         [System.Runtime.InteropServices.DispIdAttribute(4)]
@@ -1546,7 +1548,7 @@ public partial interface IProduct
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("0777432F-A60D-48b3-83DB-90326FE8C96E")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IProductBuilder
     {
         [System.Runtime.InteropServices.DispIdAttribute(1)]
@@ -1554,7 +1556,7 @@ public partial interface IProductBuilder
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("0D593FC0-E3F1-4dad-A674-7EA4D327F79B")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IProductBuilderCollection
     {
         [System.Runtime.InteropServices.DispIdAttribute(2)]
@@ -1562,7 +1564,7 @@ public partial interface IProductBuilderCollection
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("63F63663-8503-4875-814C-09168E595367")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IProductCollection
     {
         [System.Runtime.InteropServices.DispIdAttribute(1)]
@@ -1572,7 +1574,7 @@ public partial interface IProductCollection
         [System.Runtime.InteropServices.DispIdAttribute(3)]
         Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product(string productCode);
     }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("532BF563-A85D-4088-8048-41F51AC5239F")]
     public partial class Product : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
@@ -1588,7 +1590,7 @@ public partial class ProductBuilder : Microsoft.Build.Tasks.Deployment.Bootstrap
         internal ProductBuilder() { }
         public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product { get { throw null; } }
     }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("D25C0741-99CA-49f7-9460-95E5F25EEF43")]
     public partial class ProductBuilderCollection : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection, System.Collections.IEnumerable
@@ -1597,7 +1599,7 @@ internal ProductBuilderCollection() { }
         public void Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) { }
         public System.Collections.IEnumerator GetEnumerator() { throw null; }
     }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("EFFA164B-3E87-4195-88DB-8AC004DDFE2A")]
     public partial class ProductCollection : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection, System.Collections.IEnumerable
@@ -1661,83 +1663,83 @@ public ApplicationManifest(string targetFrameworkVersion) { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public bool UseApplicationTrust { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("ConfigFile")]
         public string XmlConfigFile { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlElementAttribute("EntryPointIdentity")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlEntryPointIdentity { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("EntryPointParameters")]
         public string XmlEntryPointParameters { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("EntryPointPath")]
         public string XmlEntryPointPath { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("ErrorReportUrl")]
         public string XmlErrorReportUrl { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("FileAssociations")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[] XmlFileAssociations { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("HostInBrowser")]
         public string XmlHostInBrowser { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("IconFile")]
         public string XmlIconFile { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("IsClickOnceManifest")]
         public string XmlIsClickOnceManifest { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("OSBuild")]
         public string XmlOSBuild { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("OSDescription")]
         public string XmlOSDescription { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("OSMajor")]
         public string XmlOSMajor { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("OSMinor")]
         public string XmlOSMinor { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("OSRevision")]
         public string XmlOSRevision { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("OSSupportUrl")]
         public string XmlOSSupportUrl { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Product")]
         public string XmlProduct { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Publisher")]
         public string XmlPublisher { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("SuiteName")]
         public string XmlSuiteName { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("SupportUrl")]
         public string XmlSupportUrl { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("UseApplicationTrust")]
         public string XmlUseApplicationTrust { get { throw null; } set { } }
         public override void Validate() { }
@@ -1772,27 +1774,27 @@ public AssemblyIdentity(string name, string version, string publicKeyToken, stri
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string Version { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Culture")]
         public string XmlCulture { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Name")]
         public string XmlName { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("ProcessorArchitecture")]
         public string XmlProcessorArchitecture { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("PublicKeyToken")]
         public string XmlPublicKeyToken { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Type")]
         public string XmlType { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Version")]
         public string XmlVersion { get { throw null; } set { } }
         public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromAssemblyName(string assemblyName) { throw null; }
@@ -1806,10 +1808,10 @@ public AssemblyIdentity(string name, string version, string publicKeyToken, stri
         [System.FlagsAttribute]
         public enum FullNameFlags
         {
-            All = 3,
             Default = 0,
             ProcessorArchitecture = 1,
             Type = 2,
+            All = 3,
         }
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
@@ -1820,7 +1822,7 @@ public AssemblyManifest() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] ExternalProxyStubs { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("ExternalProxyStubs")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] XmlExternalProxyStubs { get { throw null; } set { } }
     }
@@ -1837,15 +1839,15 @@ public AssemblyReference(string path) { }
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType ReferenceType { get { throw null; } set { } }
         protected internal override string SortName { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlElementAttribute("AssemblyIdentity")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlAssemblyIdentity { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("IsNative")]
         public string XmlIsNative { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("IsPrerequisite")]
         public string XmlIsPrerequisite { get { throw null; } set { } }
         public override string ToString() { throw null; }
@@ -1867,10 +1869,10 @@ public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyRe
     }
     public enum AssemblyReferenceType
     {
+        Unspecified = 0,
         ClickOnceManifest = 1,
         ManagedAssembly = 2,
         NativeAssembly = 3,
-        Unspecified = 0,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public abstract partial class BaseReference
@@ -1893,27 +1895,27 @@ protected internal BaseReference(string path) { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string TargetPath { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Group")]
         public string XmlGroup { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Hash")]
         public string XmlHash { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("HashAlg")]
         public string XmlHashAlgorithm { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("IsOptional")]
         public string XmlIsOptional { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Path")]
         public string XmlPath { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Size")]
         public string XmlSize { get { throw null; } set { } }
         public override string ToString() { throw null; }
@@ -1933,23 +1935,23 @@ public ComClass() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string TlbId { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Clsid")]
         public string XmlClsId { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Description")]
         public string XmlDescription { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Progid")]
         public string XmlProgId { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("ThreadingModel")]
         public string XmlThreadingModel { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
         public string XmlTlbId { get { throw null; } set { } }
     }
@@ -1964,15 +1966,15 @@ public CompatibleFramework() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string Version { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Profile")]
         public string XmlProfile { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("SupportedRuntime")]
         public string XmlSupportedRuntime { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Version")]
         public string XmlVersion { get { throw null; } set { } }
     }
@@ -2031,71 +2033,71 @@ public DeployManifest(string targetFrameworkMoniker) { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit UpdateUnit { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("CompatibleFrameworks")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework[] XmlCompatibleFrameworks { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("CreateDesktopShortcut")]
         public string XmlCreateDesktopShortcut { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("DeploymentUrl")]
         public string XmlDeploymentUrl { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("DisallowUrlActivation")]
         public string XmlDisallowUrlActivation { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("ErrorReportUrl")]
         public string XmlErrorReportUrl { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Install")]
         public string XmlInstall { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("MapFileExtensions")]
         public string XmlMapFileExtensions { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("MinimumRequiredVersion")]
         public string XmlMinimumRequiredVersion { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Product")]
         public string XmlProduct { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Publisher")]
         public string XmlPublisher { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("SuiteName")]
         public string XmlSuiteName { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("SupportUrl")]
         public string XmlSupportUrl { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("TrustUrlParameters")]
         public string XmlTrustUrlParameters { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("UpdateEnabled")]
         public string XmlUpdateEnabled { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("UpdateInterval")]
         public string XmlUpdateInterval { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("UpdateMode")]
         public string XmlUpdateMode { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("UpdateUnit")]
         public string XmlUpdateUnit { get { throw null; } set { } }
         public override void Validate() { }
@@ -2113,19 +2115,19 @@ public FileAssociation() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string ProgId { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("DefaultIcon")]
         public string XmlDefaultIcon { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Description")]
         public string XmlDescription { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Extension")]
         public string XmlExtension { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Progid")]
         public string XmlProgId { get { throw null; } set { } }
     }
@@ -2154,19 +2156,19 @@ public FileReference(string path) { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[] TypeLibs { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("ComClasses")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[] XmlComClasses { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("ProxyStubs")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] XmlProxyStubs { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("TypeLibs")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[] XmlTypeLibs { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("WriteableType")]
         public string XmlWriteableType { get { throw null; } set { } }
     }
@@ -2216,23 +2218,23 @@ protected internal Manifest() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string SourcePath { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlElementAttribute("AssemblyIdentity")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlAssemblyIdentity { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("AssemblyReferences")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference[] XmlAssemblyReferences { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Description")]
         public string XmlDescription { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("FileReferences")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference[] XmlFileReferences { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Schema")]
         public string XmlSchema { get { throw null; } set { } }
         public void ResolveFiles() { }
@@ -2281,9 +2283,9 @@ public void Clear() { }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public enum OutputMessageType
     {
-        Error = 2,
         Info = 0,
         Warning = 1,
+        Error = 2,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public partial class ProxyStub
@@ -2300,23 +2302,23 @@ public ProxyStub() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string TlbId { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("BaseInterface")]
         public string XmlBaseInterface { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Iid")]
         public string XmlIID { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Name")]
         public string XmlName { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("NumMethods")]
         public string XmlNumMethods { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
         public string XmlTlbId { get { throw null; } set { } }
     }
@@ -2369,23 +2371,23 @@ public TypeLib() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string Version { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Flags")]
         public string XmlFlags { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("HelpDir")]
         public string XmlHelpDirectory { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("ResourceId")]
         public string XmlResourceId { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
         public string XmlTlbId { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Version")]
         public string XmlVersion { get { throw null; } set { } }
     }
@@ -2398,8 +2400,8 @@ public enum UpdateMode
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public enum UpdateUnit
     {
-        Days = 1,
         Hours = 0,
+        Days = 1,
         Weeks = 2,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
@@ -2412,11 +2414,11 @@ public WindowClass(string name, bool versioned) { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public bool Versioned { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Name")]
         public string XmlName { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Versioned")]
         public string XmlVersioned { get { throw null; } set { } }
     }
@@ -2425,7 +2427,7 @@ namespace Microsoft.Build.Tasks.Hosting
 {
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("B5A95716-2053-4B70-9FBF-E4148EBA96BC")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IAnalyzerHostObject
     {
         bool SetAdditionalFiles(Microsoft.Build.Framework.ITaskItem[] additionalFiles);
@@ -2434,7 +2436,7 @@ public partial interface IAnalyzerHostObject
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("8520CC4D-64DC-4855-BE3F-4C28CCE048EE")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface ICscHostObject : Microsoft.Build.Framework.ITaskHost
     {
         void BeginInitialization();
@@ -2483,21 +2485,21 @@ public partial interface ICscHostObject : Microsoft.Build.Framework.ITaskHost
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("D6D4E228-259A-4076-B5D0-0627338BCC10")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface ICscHostObject2 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.ICscHostObject
     {
         bool SetWin32Manifest(string win32Manifest);
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("F9353662-F1ED-4a23-A323-5F5047E85F5D")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface ICscHostObject3 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.ICscHostObject, Microsoft.Build.Tasks.Hosting.ICscHostObject2
     {
         bool SetApplicationConfiguration(string applicationConfiguration);
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("0DDB496F-C93C-492C-87F1-90B6FDBAA833")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface ICscHostObject4 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.ICscHostObject, Microsoft.Build.Tasks.Hosting.ICscHostObject2, Microsoft.Build.Tasks.Hosting.ICscHostObject3
     {
         bool SetHighEntropyVA(bool highEntropyVA);
@@ -2506,7 +2508,7 @@ public partial interface ICscHostObject4 : Microsoft.Build.Framework.ITaskHost,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("7D7AC3BE-253A-40e8-A3FF-357D0DA7C47A")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IVbcHostObject : Microsoft.Build.Framework.ITaskHost
     {
         void BeginInitialization();
@@ -2558,7 +2560,7 @@ public partial interface IVbcHostObject : Microsoft.Build.Framework.ITaskHost
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("f59afc84-d102-48b1-a090-1b90c79d3e09")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IVbcHostObject2 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject
     {
         bool SetModuleAssemblyName(string moduleAssemblyName);
@@ -2567,21 +2569,21 @@ public partial interface IVbcHostObject2 : Microsoft.Build.Framework.ITaskHost,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("1186fe8f-8aba-48d6-8ce3-32ca42f53728")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IVbcHostObject3 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject, Microsoft.Build.Tasks.Hosting.IVbcHostObject2
     {
         bool SetLanguageVersion(string languageVersion);
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("2AE3233C-8AB3-48A0-9ED9-6E3545B3C566")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IVbcHostObject4 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject, Microsoft.Build.Tasks.Hosting.IVbcHostObject2, Microsoft.Build.Tasks.Hosting.IVbcHostObject3
     {
         bool SetVBRuntime(string VBRuntime);
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("5ACF41FF-6F2B-4623-8146-740C89212B21")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IVbcHostObject5 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject, Microsoft.Build.Tasks.Hosting.IVbcHostObject2, Microsoft.Build.Tasks.Hosting.IVbcHostObject3, Microsoft.Build.Tasks.Hosting.IVbcHostObject4
     {
         [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.PreserveSig)]int CompileAsync(out System.IntPtr buildSucceededEvent, out System.IntPtr buildFailedEvent);
@@ -2593,7 +2595,7 @@ public partial interface IVbcHostObject5 : Microsoft.Build.Framework.ITaskHost,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("ECCF972F-8C2D-4F51-9746-9288661DE2CB")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IVbcHostObjectFreeThreaded
     {
         bool Compile();
@@ -2647,9 +2649,9 @@ public enum CommandLineToolSwitchType
     {
         Boolean = 0,
         Integer = 1,
-        ITaskItemArray = 4,
         String = 2,
         StringArray = 3,
+        ITaskItemArray = 4,
     }
     public partial class PropertyRelation
     {
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 5bd884463da..7ca8c3be56c 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -263,7 +263,6 @@ public Exec() { }
         [Microsoft.Build.Framework.OutputAttribute]
         public string StdOutEncoding { get { throw null; } set { } }
         protected override string ToolName { get { throw null; } }
-        public string UseUtf8Encoding { get { throw null; } set { } }
         public string WorkingDirectory { get { throw null; } set { } }
         protected internal override void AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
         protected override int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) { throw null; }
@@ -278,6 +277,8 @@ protected override void LogToolCommand(string message) { }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct ExtractedClassName
     {
+        private object _dummy;
+        private int _dummyPrimitive;
         public bool IsInsideConditionalBlock { get { throw null; } set { } }
         public string Name { get { throw null; } set { } }
     }
@@ -652,7 +653,7 @@ public RemoveDuplicates() { }
         public Microsoft.Build.Framework.ITaskItem[] Inputs { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
-    public partial class ResolveAssemblyReference : Microsoft.Build.Tasks.TaskExtension
+    public partial class ResolveAssemblyReference : Microsoft.Build.Tasks.TaskExtension, Microsoft.Build.Framework.IConcurrentTask
     {
         public ResolveAssemblyReference() { }
         public string[] AllowedAssemblyExtensions { get { throw null; } set { } }
@@ -723,6 +724,7 @@ public ResolveAssemblyReference() { }
         public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
         public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
         public override bool Execute() { throw null; }
+        void Microsoft.Build.Framework.IConcurrentTask.ConfigureForConcurrentExecution(Microsoft.Build.Framework.TaskExecutionContext executionContext) { }
     }
     public sealed partial class ResolveCodeAnalysisRuleSet : Microsoft.Build.Tasks.TaskExtension
     {
@@ -1024,7 +1026,7 @@ public ZipDirectory() { }
 }
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
 {
-    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("1D9FE38A-0226-4b95-9C6B-6DFFA2236270")]
     public partial class BootstrapperBuilder : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder
@@ -1049,11 +1051,11 @@ internal BuildMessage() { }
     [System.Runtime.InteropServices.GuidAttribute("936D32F9-1A68-4d5e-98EA-044AC9A1AADA")]
     public enum BuildMessageSeverity
     {
-        Error = 2,
         Info = 0,
         Warning = 1,
+        Error = 2,
     }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("FAD7BA7C-CA00-41e0-A5EF-2DA9A74E58E6")]
     public partial class BuildResults : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults
@@ -1064,7 +1066,7 @@ internal BuildResults() { }
         public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[] Messages { get { throw null; } }
         public bool Succeeded { get { throw null; } }
     }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("5D13802C-C830-4b41-8E7A-F69D9DD6A095")]
     public partial class BuildSettings : Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
@@ -1088,13 +1090,13 @@ public BuildSettings() { }
     [System.Runtime.InteropServices.GuidAttribute("12F49949-7B60-49CD-B6A0-2B5E4A638AAF")]
     public enum ComponentsLocation
     {
-        Absolute = 2,
         HomeSite = 0,
         Relative = 1,
+        Absolute = 2,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("1D202366-5EEA-4379-9255-6F8CDB8587C9")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IBootstrapperBuilder
     {
         [System.Runtime.InteropServices.DispIdAttribute(1)]
@@ -1106,7 +1108,7 @@ public partial interface IBootstrapperBuilder
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("E3C981EA-99E6-4f48-8955-1AAFDFB5ACE4")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IBuildMessage
     {
         [System.Runtime.InteropServices.DispIdAttribute(4)]
@@ -1120,7 +1122,7 @@ public partial interface IBuildMessage
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("586B842C-D9C7-43b8-84E4-9CFC3AF9F13B")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IBuildResults
     {
         [System.Runtime.InteropServices.DispIdAttribute(3)]
@@ -1134,7 +1136,7 @@ public partial interface IBuildResults
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("87EEBC69-0948-4ce6-A2DE-819162B87CC6")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IBuildSettings
     {
         [System.Runtime.InteropServices.DispIdAttribute(2)]
@@ -1166,7 +1168,7 @@ public partial interface IBuildSettings
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("9E81BE3D-530F-4a10-8349-5D5947BA59AD")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IProduct
     {
         [System.Runtime.InteropServices.DispIdAttribute(4)]
@@ -1180,7 +1182,7 @@ public partial interface IProduct
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("0777432F-A60D-48b3-83DB-90326FE8C96E")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IProductBuilder
     {
         [System.Runtime.InteropServices.DispIdAttribute(1)]
@@ -1188,7 +1190,7 @@ public partial interface IProductBuilder
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("0D593FC0-E3F1-4dad-A674-7EA4D327F79B")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IProductBuilderCollection
     {
         [System.Runtime.InteropServices.DispIdAttribute(2)]
@@ -1196,7 +1198,7 @@ public partial interface IProductBuilderCollection
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("63F63663-8503-4875-814C-09168E595367")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(0))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
     public partial interface IProductCollection
     {
         [System.Runtime.InteropServices.DispIdAttribute(1)]
@@ -1206,7 +1208,7 @@ public partial interface IProductCollection
         [System.Runtime.InteropServices.DispIdAttribute(3)]
         Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product(string productCode);
     }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("532BF563-A85D-4088-8048-41F51AC5239F")]
     public partial class Product : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
@@ -1222,7 +1224,7 @@ public partial class ProductBuilder : Microsoft.Build.Tasks.Deployment.Bootstrap
         internal ProductBuilder() { }
         public Microsoft.Build.Tasks.Deployment.Bootstrapper.Product Product { get { throw null; } }
     }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("D25C0741-99CA-49f7-9460-95E5F25EEF43")]
     public partial class ProductBuilderCollection : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection, System.Collections.IEnumerable
@@ -1231,7 +1233,7 @@ internal ProductBuilderCollection() { }
         public void Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) { }
         public System.Collections.IEnumerator GetEnumerator() { throw null; }
     }
-    [System.Runtime.InteropServices.ClassInterfaceAttribute((System.Runtime.InteropServices.ClassInterfaceType)(0))]
+    [System.Runtime.InteropServices.ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType.None)]
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("EFFA164B-3E87-4195-88DB-8AC004DDFE2A")]
     public partial class ProductCollection : Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection, System.Collections.IEnumerable
@@ -1295,83 +1297,83 @@ public ApplicationManifest(string targetFrameworkVersion) { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public bool UseApplicationTrust { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("ConfigFile")]
         public string XmlConfigFile { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlElementAttribute("EntryPointIdentity")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlEntryPointIdentity { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("EntryPointParameters")]
         public string XmlEntryPointParameters { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("EntryPointPath")]
         public string XmlEntryPointPath { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("ErrorReportUrl")]
         public string XmlErrorReportUrl { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("FileAssociations")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[] XmlFileAssociations { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("HostInBrowser")]
         public string XmlHostInBrowser { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("IconFile")]
         public string XmlIconFile { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("IsClickOnceManifest")]
         public string XmlIsClickOnceManifest { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("OSBuild")]
         public string XmlOSBuild { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("OSDescription")]
         public string XmlOSDescription { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("OSMajor")]
         public string XmlOSMajor { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("OSMinor")]
         public string XmlOSMinor { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("OSRevision")]
         public string XmlOSRevision { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("OSSupportUrl")]
         public string XmlOSSupportUrl { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Product")]
         public string XmlProduct { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Publisher")]
         public string XmlPublisher { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("SuiteName")]
         public string XmlSuiteName { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("SupportUrl")]
         public string XmlSupportUrl { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("UseApplicationTrust")]
         public string XmlUseApplicationTrust { get { throw null; } set { } }
         public override void Validate() { }
@@ -1406,27 +1408,27 @@ public AssemblyIdentity(string name, string version, string publicKeyToken, stri
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string Version { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Culture")]
         public string XmlCulture { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Name")]
         public string XmlName { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("ProcessorArchitecture")]
         public string XmlProcessorArchitecture { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("PublicKeyToken")]
         public string XmlPublicKeyToken { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Type")]
         public string XmlType { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Version")]
         public string XmlVersion { get { throw null; } set { } }
         public static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity FromAssemblyName(string assemblyName) { throw null; }
@@ -1440,10 +1442,10 @@ public AssemblyIdentity(string name, string version, string publicKeyToken, stri
         [System.FlagsAttribute]
         public enum FullNameFlags
         {
-            All = 3,
             Default = 0,
             ProcessorArchitecture = 1,
             Type = 2,
+            All = 3,
         }
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
@@ -1454,7 +1456,7 @@ public AssemblyManifest() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] ExternalProxyStubs { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("ExternalProxyStubs")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] XmlExternalProxyStubs { get { throw null; } set { } }
     }
@@ -1471,15 +1473,15 @@ public AssemblyReference(string path) { }
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType ReferenceType { get { throw null; } set { } }
         protected internal override string SortName { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlElementAttribute("AssemblyIdentity")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlAssemblyIdentity { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("IsNative")]
         public string XmlIsNative { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("IsPrerequisite")]
         public string XmlIsPrerequisite { get { throw null; } set { } }
         public override string ToString() { throw null; }
@@ -1501,10 +1503,10 @@ public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyRe
     }
     public enum AssemblyReferenceType
     {
+        Unspecified = 0,
         ClickOnceManifest = 1,
         ManagedAssembly = 2,
         NativeAssembly = 3,
-        Unspecified = 0,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public abstract partial class BaseReference
@@ -1527,27 +1529,27 @@ protected internal BaseReference(string path) { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string TargetPath { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Group")]
         public string XmlGroup { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Hash")]
         public string XmlHash { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("HashAlg")]
         public string XmlHashAlgorithm { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("IsOptional")]
         public string XmlIsOptional { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Path")]
         public string XmlPath { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Size")]
         public string XmlSize { get { throw null; } set { } }
         public override string ToString() { throw null; }
@@ -1567,23 +1569,23 @@ public ComClass() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string TlbId { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Clsid")]
         public string XmlClsId { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Description")]
         public string XmlDescription { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Progid")]
         public string XmlProgId { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("ThreadingModel")]
         public string XmlThreadingModel { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
         public string XmlTlbId { get { throw null; } set { } }
     }
@@ -1598,15 +1600,15 @@ public CompatibleFramework() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string Version { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Profile")]
         public string XmlProfile { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("SupportedRuntime")]
         public string XmlSupportedRuntime { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Version")]
         public string XmlVersion { get { throw null; } set { } }
     }
@@ -1665,71 +1667,71 @@ public DeployManifest(string targetFrameworkMoniker) { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit UpdateUnit { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("CompatibleFrameworks")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework[] XmlCompatibleFrameworks { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("CreateDesktopShortcut")]
         public string XmlCreateDesktopShortcut { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("DeploymentUrl")]
         public string XmlDeploymentUrl { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("DisallowUrlActivation")]
         public string XmlDisallowUrlActivation { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("ErrorReportUrl")]
         public string XmlErrorReportUrl { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Install")]
         public string XmlInstall { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("MapFileExtensions")]
         public string XmlMapFileExtensions { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("MinimumRequiredVersion")]
         public string XmlMinimumRequiredVersion { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Product")]
         public string XmlProduct { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Publisher")]
         public string XmlPublisher { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("SuiteName")]
         public string XmlSuiteName { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("SupportUrl")]
         public string XmlSupportUrl { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("TrustUrlParameters")]
         public string XmlTrustUrlParameters { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("UpdateEnabled")]
         public string XmlUpdateEnabled { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("UpdateInterval")]
         public string XmlUpdateInterval { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("UpdateMode")]
         public string XmlUpdateMode { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("UpdateUnit")]
         public string XmlUpdateUnit { get { throw null; } set { } }
         public override void Validate() { }
@@ -1747,19 +1749,19 @@ public FileAssociation() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string ProgId { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("DefaultIcon")]
         public string XmlDefaultIcon { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Description")]
         public string XmlDescription { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Extension")]
         public string XmlExtension { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Progid")]
         public string XmlProgId { get { throw null; } set { } }
     }
@@ -1788,19 +1790,19 @@ public FileReference(string path) { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[] TypeLibs { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("ComClasses")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[] XmlComClasses { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("ProxyStubs")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[] XmlProxyStubs { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("TypeLibs")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[] XmlTypeLibs { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("WriteableType")]
         public string XmlWriteableType { get { throw null; } set { } }
     }
@@ -1850,23 +1852,23 @@ protected internal Manifest() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string SourcePath { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlElementAttribute("AssemblyIdentity")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity XmlAssemblyIdentity { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("AssemblyReferences")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference[] XmlAssemblyReferences { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Description")]
         public string XmlDescription { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlArrayAttribute("FileReferences")]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference[] XmlFileReferences { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Schema")]
         public string XmlSchema { get { throw null; } set { } }
         public void ResolveFiles() { }
@@ -1915,9 +1917,9 @@ public void Clear() { }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public enum OutputMessageType
     {
-        Error = 2,
         Info = 0,
         Warning = 1,
+        Error = 2,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public partial class ProxyStub
@@ -1934,23 +1936,23 @@ public ProxyStub() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string TlbId { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("BaseInterface")]
         public string XmlBaseInterface { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Iid")]
         public string XmlIID { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Name")]
         public string XmlName { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("NumMethods")]
         public string XmlNumMethods { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
         public string XmlTlbId { get { throw null; } set { } }
     }
@@ -1998,23 +2000,23 @@ public TypeLib() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string Version { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Flags")]
         public string XmlFlags { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("HelpDir")]
         public string XmlHelpDirectory { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("ResourceId")]
         public string XmlResourceId { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Tlbid")]
         public string XmlTlbId { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Version")]
         public string XmlVersion { get { throw null; } set { } }
     }
@@ -2027,8 +2029,8 @@ public enum UpdateMode
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public enum UpdateUnit
     {
-        Days = 1,
         Hours = 0,
+        Days = 1,
         Weeks = 2,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
@@ -2041,11 +2043,11 @@ public WindowClass(string name, bool versioned) { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public bool Versioned { get { throw null; } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Name")]
         public string XmlName { get { throw null; } set { } }
         [System.ComponentModel.BrowsableAttribute(false)]
-        [System.ComponentModel.EditorBrowsableAttribute((System.ComponentModel.EditorBrowsableState)(1))]
+        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.Xml.Serialization.XmlAttributeAttribute("Versioned")]
         public string XmlVersioned { get { throw null; } set { } }
     }
@@ -2054,7 +2056,7 @@ namespace Microsoft.Build.Tasks.Hosting
 {
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("B5A95716-2053-4B70-9FBF-E4148EBA96BC")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IAnalyzerHostObject
     {
         bool SetAdditionalFiles(Microsoft.Build.Framework.ITaskItem[] additionalFiles);
@@ -2063,7 +2065,7 @@ public partial interface IAnalyzerHostObject
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("8520CC4D-64DC-4855-BE3F-4C28CCE048EE")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface ICscHostObject : Microsoft.Build.Framework.ITaskHost
     {
         void BeginInitialization();
@@ -2112,21 +2114,21 @@ public partial interface ICscHostObject : Microsoft.Build.Framework.ITaskHost
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("D6D4E228-259A-4076-B5D0-0627338BCC10")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface ICscHostObject2 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.ICscHostObject
     {
         bool SetWin32Manifest(string win32Manifest);
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("F9353662-F1ED-4a23-A323-5F5047E85F5D")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface ICscHostObject3 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.ICscHostObject, Microsoft.Build.Tasks.Hosting.ICscHostObject2
     {
         bool SetApplicationConfiguration(string applicationConfiguration);
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("0DDB496F-C93C-492C-87F1-90B6FDBAA833")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface ICscHostObject4 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.ICscHostObject, Microsoft.Build.Tasks.Hosting.ICscHostObject2, Microsoft.Build.Tasks.Hosting.ICscHostObject3
     {
         bool SetHighEntropyVA(bool highEntropyVA);
@@ -2135,7 +2137,7 @@ public partial interface ICscHostObject4 : Microsoft.Build.Framework.ITaskHost,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("7D7AC3BE-253A-40e8-A3FF-357D0DA7C47A")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IVbcHostObject : Microsoft.Build.Framework.ITaskHost
     {
         void BeginInitialization();
@@ -2187,7 +2189,7 @@ public partial interface IVbcHostObject : Microsoft.Build.Framework.ITaskHost
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("f59afc84-d102-48b1-a090-1b90c79d3e09")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IVbcHostObject2 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject
     {
         bool SetModuleAssemblyName(string moduleAssemblyName);
@@ -2196,21 +2198,21 @@ public partial interface IVbcHostObject2 : Microsoft.Build.Framework.ITaskHost,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("1186fe8f-8aba-48d6-8ce3-32ca42f53728")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IVbcHostObject3 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject, Microsoft.Build.Tasks.Hosting.IVbcHostObject2
     {
         bool SetLanguageVersion(string languageVersion);
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("2AE3233C-8AB3-48A0-9ED9-6E3545B3C566")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IVbcHostObject4 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject, Microsoft.Build.Tasks.Hosting.IVbcHostObject2, Microsoft.Build.Tasks.Hosting.IVbcHostObject3
     {
         bool SetVBRuntime(string VBRuntime);
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("5ACF41FF-6F2B-4623-8146-740C89212B21")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IVbcHostObject5 : Microsoft.Build.Framework.ITaskHost, Microsoft.Build.Tasks.Hosting.IVbcHostObject, Microsoft.Build.Tasks.Hosting.IVbcHostObject2, Microsoft.Build.Tasks.Hosting.IVbcHostObject3, Microsoft.Build.Tasks.Hosting.IVbcHostObject4
     {
         [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.PreserveSig)]int CompileAsync(out System.IntPtr buildSucceededEvent, out System.IntPtr buildFailedEvent);
@@ -2222,7 +2224,7 @@ public partial interface IVbcHostObject5 : Microsoft.Build.Framework.ITaskHost,
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(true)]
     [System.Runtime.InteropServices.GuidAttribute("ECCF972F-8C2D-4F51-9746-9288661DE2CB")]
-    [System.Runtime.InteropServices.InterfaceTypeAttribute((System.Runtime.InteropServices.ComInterfaceType)(1))]
+    [System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
     public partial interface IVbcHostObjectFreeThreaded
     {
         bool Compile();
diff --git a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
index 40abd53b294..4491f300e5c 100644
--- a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
@@ -114,17 +114,17 @@ protected virtual void VerifyThrowNoEmbeddedDoubleQuotes(string switchName, stri
     public delegate bool DependencyFilter(string fullPath);
     public enum DotNetFrameworkArchitecture
     {
+        Current = 0,
         Bitness32 = 1,
         Bitness64 = 2,
-        Current = 0,
     }
     public enum ExecutableType
     {
-        Managed32Bit = 3,
-        Managed64Bit = 4,
-        ManagedIL = 2,
         Native32Bit = 0,
         Native64Bit = 1,
+        ManagedIL = 2,
+        Managed32Bit = 3,
+        Managed64Bit = 4,
         SameAsCurrentProcess = 5,
     }
     public static partial class FileTracker
@@ -200,10 +200,10 @@ public void UpdateFileEntryDetails() { }
     }
     public enum HostObjectInitializationStatus
     {
-        NoActionReturnFailure = 3,
-        NoActionReturnSuccess = 2,
-        UseAlternateToolToExecute = 1,
         UseHostObjectToExecute = 0,
+        UseAlternateToolToExecute = 1,
+        NoActionReturnSuccess = 2,
+        NoActionReturnFailure = 3,
     }
     public abstract partial class Logger : Microsoft.Build.Framework.ILogger
     {
@@ -219,8 +219,8 @@ public virtual void Shutdown() { }
     public enum MultipleVersionSupport
     {
         Allow = 0,
-        Error = 2,
         Warning = 1,
+        Error = 2,
     }
     public partial class MuxLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
     {
@@ -302,14 +302,13 @@ public static partial class Attributes
     }
     public enum SDKType
     {
+        Unspecified = 0,
         External = 1,
-        Framework = 3,
         Platform = 2,
-        Unspecified = 0,
+        Framework = 3,
     }
     public enum TargetDotNetFrameworkVersion
     {
-        Latest = 9999,
         Version11 = 0,
         Version20 = 1,
         Version30 = 2,
@@ -317,15 +316,16 @@ public enum TargetDotNetFrameworkVersion
         Version40 = 4,
         Version45 = 5,
         Version451 = 6,
-        Version452 = 9,
         Version46 = 7,
         Version461 = 8,
+        Version452 = 9,
         Version462 = 10,
+        VersionLatest = 10,
         Version47 = 11,
         Version471 = 12,
         Version472 = 13,
         Version48 = 14,
-        VersionLatest = 10,
+        Latest = 9999,
     }
     public partial class TargetPlatformSDK : System.IEquatable<Microsoft.Build.Utilities.TargetPlatformSDK>
     {
@@ -353,6 +353,8 @@ protected Task(System.Resources.ResourceManager taskResources, string helpKeywor
         public Microsoft.Build.Framework.IBuildEngine5 BuildEngine5 { get { throw null; } }
         public Microsoft.Build.Framework.IBuildEngine6 BuildEngine6 { get { throw null; } }
         public Microsoft.Build.Framework.IBuildEngine7 BuildEngine7 { get { throw null; } }
+        public Microsoft.Build.Framework.IBuildEngine8 BuildEngine8 { get { throw null; } }
+        public Microsoft.Build.Framework.IBuildEngine9 BuildEngine9 { get { throw null; } }
         protected string HelpKeywordPrefix { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskHost HostObject { get { throw null; } set { } }
         public Microsoft.Build.Utilities.TaskLoggingHelper Log { get { throw null; } }
@@ -391,7 +393,7 @@ public TaskLoggingHelper(Microsoft.Build.Framework.ITask taskInstance) { }
         public string HelpKeywordPrefix { get { throw null; } set { } }
         protected string TaskName { get { throw null; } }
         public System.Resources.ResourceManager TaskResources { get { throw null; } set { } }
-        public string ExtractMessageCode(string message, out string messageWithoutCodePrefix) { messageWithoutCodePrefix = default(string); throw null; }
+        public string ExtractMessageCode(string message, out string messageWithoutCodePrefix) { throw null; }
         public virtual string FormatResourceString(string resourceName, params object[] args) { throw null; }
         public virtual string FormatString(string unformatted, params object[] args) { throw null; }
         public virtual string GetResourceMessage(string resourceName) { throw null; }
@@ -449,8 +451,8 @@ public static void ClearSDKStaticCache() { }
         public static string GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
         public static string GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
         public static string GetDotNetFrameworkVersionFolderPrefix(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static System.Collections.Generic.IEnumerable<string> GetFoldersInVSInstalls(System.Version minVersion=null, System.Version maxVersion=null, string subFolder=null) { throw null; }
-        public static string GetFoldersInVSInstallsAsString(string minVersionString=null, string maxVersionString=null, string subFolder=null) { throw null; }
+        public static System.Collections.Generic.IEnumerable<string> GetFoldersInVSInstalls(System.Version minVersion = null, System.Version maxVersion = null, string subFolder = null) { throw null; }
+        public static string GetFoldersInVSInstallsAsString(string minVersionString = null, string maxVersionString = null, string subFolder = null) { throw null; }
         public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion) { throw null; }
         public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion, string[] sdkRoots) { throw null; }
         public static string GetPathToBuildTools(string toolsVersion) { throw null; }
@@ -512,7 +514,7 @@ public static void ClearSDKStaticCache() { }
         public static System.Collections.Generic.IEnumerable<string> GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion) { throw null; }
         public static System.Collections.Generic.IEnumerable<string> GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion, string[] diskRoots, string registryRoot) { throw null; }
         public static string GetProgramFilesReferenceAssemblyRoot() { throw null; }
-        public static string GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot=null) { throw null; }
+        public static string GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot = null) { throw null; }
         public static System.Collections.Generic.IList<string> GetSDKDesignTimeFolders(string sdkRoot) { throw null; }
         public static System.Collections.Generic.IList<string> GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) { throw null; }
         public static System.Collections.Generic.IList<string> GetSDKRedistFolders(string sdkRoot) { throw null; }
@@ -555,6 +557,7 @@ protected ToolTask(System.Resources.ResourceManager taskResources, string helpKe
         protected abstract string ToolName { get; }
         public string ToolPath { get { throw null; } set { } }
         public bool UseCommandProcessor { get { throw null; } set { } }
+        public string UseUtf8Encoding { get { throw null; } set { } }
         public bool YieldDuringToolExecution { get { throw null; } set { } }
         protected virtual string AdjustCommandsForOperatingSystem(string input) { throw null; }
         protected virtual bool CallHostObjectToExecute() { throw null; }
@@ -585,8 +588,8 @@ public static partial class TrackedDependencies
     public enum UpToDateCheckType
     {
         InputNewerThanOutput = 0,
-        InputNewerThanTracking = 2,
         InputOrOutputNewerThanTracking = 1,
+        InputNewerThanTracking = 2,
     }
     public enum VisualStudioVersion
     {
diff --git a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
index e6cc6f3fa50..f0ad18e1545 100644
--- a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
@@ -39,16 +39,16 @@ protected virtual void VerifyThrowNoEmbeddedDoubleQuotes(string switchName, stri
     }
     public enum DotNetFrameworkArchitecture
     {
+        Current = 0,
         Bitness32 = 1,
         Bitness64 = 2,
-        Current = 0,
     }
     public enum HostObjectInitializationStatus
     {
-        NoActionReturnFailure = 3,
-        NoActionReturnSuccess = 2,
-        UseAlternateToolToExecute = 1,
         UseHostObjectToExecute = 0,
+        UseAlternateToolToExecute = 1,
+        NoActionReturnSuccess = 2,
+        NoActionReturnFailure = 3,
     }
     public abstract partial class Logger : Microsoft.Build.Framework.ILogger
     {
@@ -64,8 +64,8 @@ public virtual void Shutdown() { }
     public enum MultipleVersionSupport
     {
         Allow = 0,
-        Error = 2,
         Warning = 1,
+        Error = 2,
     }
     public partial class MuxLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
     {
@@ -147,14 +147,13 @@ public static partial class Attributes
     }
     public enum SDKType
     {
+        Unspecified = 0,
         External = 1,
-        Framework = 3,
         Platform = 2,
-        Unspecified = 0,
+        Framework = 3,
     }
     public enum TargetDotNetFrameworkVersion
     {
-        Latest = 9999,
         Version11 = 0,
         Version20 = 1,
         Version30 = 2,
@@ -162,15 +161,16 @@ public enum TargetDotNetFrameworkVersion
         Version40 = 4,
         Version45 = 5,
         Version451 = 6,
-        Version452 = 9,
         Version46 = 7,
         Version461 = 8,
+        Version452 = 9,
         Version462 = 10,
+        VersionLatest = 10,
         Version47 = 11,
         Version471 = 12,
         Version472 = 13,
         Version48 = 14,
-        VersionLatest = 10,
+        Latest = 9999,
     }
     public partial class TargetPlatformSDK : System.IEquatable<Microsoft.Build.Utilities.TargetPlatformSDK>
     {
@@ -198,6 +198,8 @@ protected Task(System.Resources.ResourceManager taskResources, string helpKeywor
         public Microsoft.Build.Framework.IBuildEngine5 BuildEngine5 { get { throw null; } }
         public Microsoft.Build.Framework.IBuildEngine6 BuildEngine6 { get { throw null; } }
         public Microsoft.Build.Framework.IBuildEngine7 BuildEngine7 { get { throw null; } }
+        public Microsoft.Build.Framework.IBuildEngine8 BuildEngine8 { get { throw null; } }
+        public Microsoft.Build.Framework.IBuildEngine9 BuildEngine9 { get { throw null; } }
         protected string HelpKeywordPrefix { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskHost HostObject { get { throw null; } set { } }
         public Microsoft.Build.Utilities.TaskLoggingHelper Log { get { throw null; } }
@@ -234,7 +236,7 @@ public TaskLoggingHelper(Microsoft.Build.Framework.ITask taskInstance) { }
         public string HelpKeywordPrefix { get { throw null; } set { } }
         protected string TaskName { get { throw null; } }
         public System.Resources.ResourceManager TaskResources { get { throw null; } set { } }
-        public string ExtractMessageCode(string message, out string messageWithoutCodePrefix) { messageWithoutCodePrefix = default(string); throw null; }
+        public string ExtractMessageCode(string message, out string messageWithoutCodePrefix) { throw null; }
         public virtual string FormatResourceString(string resourceName, params object[] args) { throw null; }
         public virtual string FormatString(string unformatted, params object[] args) { throw null; }
         public virtual string GetResourceMessage(string resourceName) { throw null; }
@@ -289,8 +291,8 @@ public static void ClearSDKStaticCache() { }
         public static string GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
         public static string GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) { throw null; }
         public static string GetDotNetFrameworkVersionFolderPrefix(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) { throw null; }
-        public static System.Collections.Generic.IEnumerable<string> GetFoldersInVSInstalls(System.Version minVersion=null, System.Version maxVersion=null, string subFolder=null) { throw null; }
-        public static string GetFoldersInVSInstallsAsString(string minVersionString=null, string maxVersionString=null, string subFolder=null) { throw null; }
+        public static System.Collections.Generic.IEnumerable<string> GetFoldersInVSInstalls(System.Version minVersion = null, System.Version maxVersion = null, string subFolder = null) { throw null; }
+        public static string GetFoldersInVSInstallsAsString(string minVersionString = null, string maxVersionString = null, string subFolder = null) { throw null; }
         public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion) { throw null; }
         public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion, string[] sdkRoots) { throw null; }
         public static string GetPathToBuildTools(string toolsVersion) { throw null; }
@@ -352,7 +354,7 @@ public static void ClearSDKStaticCache() { }
         public static System.Collections.Generic.IEnumerable<string> GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion) { throw null; }
         public static System.Collections.Generic.IEnumerable<string> GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion, string[] diskRoots, string registryRoot) { throw null; }
         public static string GetProgramFilesReferenceAssemblyRoot() { throw null; }
-        public static string GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot=null) { throw null; }
+        public static string GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot = null) { throw null; }
         public static System.Collections.Generic.IList<string> GetSDKDesignTimeFolders(string sdkRoot) { throw null; }
         public static System.Collections.Generic.IList<string> GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) { throw null; }
         public static System.Collections.Generic.IList<string> GetSDKRedistFolders(string sdkRoot) { throw null; }
@@ -395,6 +397,7 @@ protected ToolTask(System.Resources.ResourceManager taskResources, string helpKe
         protected abstract string ToolName { get; }
         public string ToolPath { get { throw null; } set { } }
         public bool UseCommandProcessor { get { throw null; } set { } }
+        public string UseUtf8Encoding { get { throw null; } set { } }
         public bool YieldDuringToolExecution { get { throw null; } set { } }
         protected virtual string AdjustCommandsForOperatingSystem(string input) { throw null; }
         protected virtual bool CallHostObjectToExecute() { throw null; }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 3619a7a0852..df63aa205be 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -15,9 +15,9 @@ protected ElementLocation() { }
     }
     public enum ImplicitImportLocation
     {
-        Bottom = 2,
         None = 0,
         Top = 1,
+        Bottom = 2,
     }
     public partial class ProjectChooseElement : Microsoft.Build.Construction.ProjectElementContainer
     {
@@ -319,10 +319,10 @@ internal ProjectRootElement() { }
         public Microsoft.Build.Construction.ProjectRootElement DeepClone() { throw null; }
         public static Microsoft.Build.Construction.ProjectRootElement Open(string path) { throw null; }
         public static Microsoft.Build.Construction.ProjectRootElement Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, System.Nullable<bool> preserveFormatting) { throw null; }
-        public void Reload(bool throwIfUnsavedChanges=true, System.Nullable<bool> preserveFormatting=default(System.Nullable<bool>)) { }
-        public void ReloadFrom(string path, bool throwIfUnsavedChanges=true, System.Nullable<bool> preserveFormatting=default(System.Nullable<bool>)) { }
-        public void ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges=true, System.Nullable<bool> preserveFormatting=default(System.Nullable<bool>)) { }
+        public static Microsoft.Build.Construction.ProjectRootElement Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) { throw null; }
+        public void Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = default(bool?)) { }
+        public void ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = default(bool?)) { }
+        public void ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges = true, bool? preserveFormatting = default(bool?)) { }
         public void Save() { }
         public void Save(System.IO.TextWriter writer) { }
         public void Save(string path) { }
@@ -330,7 +330,7 @@ public void Save(string path, System.Text.Encoding encoding) { }
         public void Save(System.Text.Encoding saveEncoding) { }
         public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path) { throw null; }
         public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, System.Nullable<bool> preserveFormatting) { throw null; }
+        public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) { throw null; }
     }
     public partial class ProjectSdkElement : Microsoft.Build.Construction.ProjectElementContainer
     {
@@ -465,13 +465,13 @@ internal SolutionFile() { }
     }
     public enum SolutionProjectType
     {
-        EtpSubProject = 5,
+        Unknown = 0,
         KnownToBeMSBuildFormat = 1,
-        SharedProject = 6,
         SolutionFolder = 2,
-        Unknown = 0,
-        WebDeploymentProject = 4,
         WebProject = 3,
+        WebDeploymentProject = 4,
+        EtpSubProject = 5,
+        SharedProject = 6,
     }
     public partial class UsingTaskParameterGroupElement : Microsoft.Build.Construction.ProjectElementContainer
     {
@@ -514,25 +514,25 @@ public static partial class MatchOnMetadataConstants
     }
     public enum MatchOnMetadataOptions
     {
-        CaseInsensitive = 1,
         CaseSensitive = 0,
+        CaseInsensitive = 1,
         PathLike = 2,
     }
     [System.FlagsAttribute]
     public enum NewProjectFileOptions
     {
         IncludeAllOptions = -1,
-        IncludeToolsVersion = 2,
+        None = 0,
         IncludeXmlDeclaration = 1,
+        IncludeToolsVersion = 2,
         IncludeXmlNamespace = 4,
-        None = 0,
     }
     public enum Operation
     {
-        Exclude = 1,
         Include = 0,
-        Remove = 3,
+        Exclude = 1,
         Update = 2,
+        Remove = 3,
     }
     public partial class Project
     {
@@ -719,14 +719,14 @@ internal ProjectCollectionChangedEventArgs() { }
     public enum ProjectCollectionChangedState
     {
         DefaultToolsVersion = 0,
-        DisableMarkDirty = 7,
+        Toolsets = 1,
+        Loggers = 2,
         GlobalProperties = 3,
-        HostServices = 6,
         IsBuildEnabled = 4,
-        Loggers = 2,
         OnlyLogCriticalEvents = 5,
+        HostServices = 6,
+        DisableMarkDirty = 7,
         SkipEvaluation = 8,
-        Toolsets = 1,
     }
     public partial class ProjectItem
     {
@@ -764,14 +764,14 @@ internal ProjectItemDefinition() { }
     public enum ProjectLoadSettings
     {
         Default = 0,
-        DoNotEvaluateElementsWithFalseCondition = 32,
-        IgnoreEmptyImports = 16,
-        IgnoreInvalidImports = 64,
         IgnoreMissingImports = 1,
-        ProfileEvaluation = 128,
         RecordDuplicateButNotCircularImports = 2,
-        RecordEvaluatedItemElements = 8,
         RejectCircularImports = 4,
+        RecordEvaluatedItemElements = 8,
+        IgnoreEmptyImports = 16,
+        DoNotEvaluateElementsWithFalseCondition = 32,
+        IgnoreInvalidImports = 64,
+        ProfileEvaluation = 128,
     }
     public partial class ProjectMetadata : System.IEquatable<Microsoft.Build.Evaluation.ProjectMetadata>
     {
@@ -812,10 +812,10 @@ internal ProjectXmlChangedEventArgs() { }
     [System.FlagsAttribute]
     public enum Provenance
     {
+        Undefined = 0,
+        StringLiteral = 1,
         Glob = 2,
         Inconclusive = 4,
-        StringLiteral = 1,
-        Undefined = 0,
     }
     public partial class ProvenanceResult
     {
@@ -828,6 +828,8 @@ public ProvenanceResult(Microsoft.Build.Construction.ProjectItemElement itemElem
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct ResolvedImport
     {
+        private object _dummy;
+        private int _dummyPrimitive;
         public Microsoft.Build.Construction.ProjectRootElement ImportedProject { get { throw null; } }
         public Microsoft.Build.Construction.ProjectImportElement ImportingElement { get { throw null; } }
         public bool IsImported { get { throw null; } }
@@ -856,11 +858,11 @@ public Toolset(string toolsVersion, string toolsPath, System.Collections.Generic
     [System.FlagsAttribute]
     public enum ToolsetDefinitionLocations
     {
+        None = 0,
         ConfigurationFile = 1,
+        Registry = 2,
         Default = 3,
         Local = 4,
-        None = 0,
-        Registry = 2,
     }
 }
 namespace Microsoft.Build.Evaluation.Context
@@ -872,8 +874,8 @@ internal EvaluationContext() { }
         public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) { throw null; }
         public enum SharingPolicy
         {
-            Isolated = 1,
             Shared = 0,
+            Isolated = 1,
         }
     }
 }
@@ -961,9 +963,11 @@ public void EndBuild() { }
         public void ResetCaches() { }
         public void ShutdownAllNodes() { }
         [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-        public partial struct DeferredBuildMessage
+        public readonly partial struct DeferredBuildMessage
         {
-            public DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) { throw null;}
+            private readonly object _dummy;
+            private readonly int _dummyPrimitive;
+            public DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) { throw null; }
             public Microsoft.Build.Framework.MessageImportance Importance { get { throw null; } }
             public string Text { get { throw null; } }
         }
@@ -1035,14 +1039,14 @@ public BuildRequestData(string projectFullPath, System.Collections.Generic.IDict
     [System.FlagsAttribute]
     public enum BuildRequestDataFlags
     {
-        ClearCachesAfterBuild = 8,
-        IgnoreExistingProjectState = 4,
-        IgnoreMissingEmptyAndInvalidImports = 64,
         None = 0,
-        ProvideProjectStateAfterBuild = 2,
-        ProvideSubsetOfStateAfterBuild = 32,
         ReplaceExistingProjectInstance = 1,
+        ProvideProjectStateAfterBuild = 2,
+        IgnoreExistingProjectState = 4,
+        ClearCachesAfterBuild = 8,
         SkipNonexistentTargets = 16,
+        ProvideSubsetOfStateAfterBuild = 32,
+        IgnoreMissingEmptyAndInvalidImports = 64,
     }
     public partial class BuildResult
     {
@@ -1064,8 +1068,8 @@ public void MergeResults(Microsoft.Build.Execution.BuildResult results) { }
     }
     public enum BuildResultCode
     {
-        Failure = 1,
         Success = 0,
+        Failure = 1,
     }
     public partial class BuildSubmission
     {
@@ -1099,9 +1103,9 @@ public partial interface ITargetResult
     }
     public enum NodeAffinity
     {
-        Any = 2,
         InProc = 0,
         OutOfProc = 1,
+        Any = 2,
     }
     public enum NodeEngineShutdownReason
     {
@@ -1113,15 +1117,16 @@ public enum NodeEngineShutdownReason
     public partial class OutOfProcNode
     {
         public OutOfProcNode() { }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) { shutdownException = default(System.Exception); throw null; }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, out System.Exception shutdownException) { shutdownException = default(System.Exception); throw null; }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(out System.Exception shutdownException) { shutdownException = default(System.Exception); throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) { throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, out System.Exception shutdownException) { throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(out System.Exception shutdownException) { throw null; }
     }
     public partial class ProjectInstance
     {
         public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml) { }
         public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
         public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
+        public ProjectInstance(Microsoft.Build.Evaluation.Project project, Microsoft.Build.Execution.ProjectInstanceSettings settings) { }
         public ProjectInstance(string projectFile) { }
         public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
         public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
@@ -1152,9 +1157,9 @@ public ProjectInstance(string projectFile, System.Collections.Generic.IDictionar
         public bool Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
         public bool Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
         public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) { targetOutputs = default(System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult>); throw null; }
+        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) { throw null; }
         public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) { targetOutputs = default(System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult>); throw null; }
+        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) { throw null; }
         public Microsoft.Build.Execution.ProjectInstance DeepCopy() { throw null; }
         public Microsoft.Build.Execution.ProjectInstance DeepCopy(bool isImmutable) { throw null; }
         public bool EvaluateCondition(string condition) { throw null; }
@@ -1181,9 +1186,9 @@ public void UpdateStateFrom(Microsoft.Build.Execution.ProjectInstance projectSta
     [System.FlagsAttribute]
     public enum ProjectInstanceSettings
     {
+        None = 0,
         Immutable = 1,
         ImmutableWithFastItemLookup = 3,
-        None = 0,
     }
     public partial class ProjectItemDefinitionInstance
     {
@@ -1403,16 +1408,16 @@ internal TargetResult() { }
     }
     public enum TargetResultCode : byte
     {
-        Failure = (byte)2,
         Skipped = (byte)0,
         Success = (byte)1,
+        Failure = (byte)2,
     }
 }
 namespace Microsoft.Build.Experimental.ProjectCache
 {
     public partial class CacheContext
     {
-        public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph=null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints=null) { }
+        public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph = null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints = null) { }
         public Microsoft.Build.FileSystem.MSBuildFileSystemBase FileSystem { get { throw null; } }
         public Microsoft.Build.Graph.ProjectGraph Graph { get { throw null; } }
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> GraphEntryPoints { get { throw null; } }
@@ -1422,6 +1427,9 @@ public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, strin
     public partial class CacheResult
     {
         internal CacheResult() { }
+        public Microsoft.Build.Execution.BuildResult BuildResult { get { throw null; } }
+        public Microsoft.Build.Experimental.ProjectCache.ProxyTargets ProxyTargets { get { throw null; } }
+        public Microsoft.Build.Experimental.ProjectCache.CacheResultType ResultType { get { throw null; } }
         public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) { throw null; }
         public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) { throw null; }
         public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) { throw null; }
@@ -1429,23 +1437,25 @@ internal CacheResult() { }
     }
     public enum CacheResultType
     {
+        None = 0,
         CacheHit = 1,
         CacheMiss = 2,
         CacheNotApplicable = 3,
-        None = 0,
     }
     public abstract partial class PluginLoggerBase
     {
         protected PluginLoggerBase(Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
         public abstract bool HasLoggedErrors { get; protected set; }
         public abstract void LogError(string error);
-        public abstract void LogMessage(string message, System.Nullable<Microsoft.Build.Framework.MessageImportance> messageImportance=default(System.Nullable<Microsoft.Build.Framework.MessageImportance>));
+        public abstract void LogMessage(string message, Microsoft.Build.Framework.MessageImportance? messageImportance = default(Microsoft.Build.Framework.MessageImportance?));
         public abstract void LogWarning(string warning);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct PluginTargetResult
+    public readonly partial struct PluginTargetResult
     {
-        public PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) { throw null;}
+        private readonly object _dummy;
+        private readonly int _dummyPrimitive;
+        public PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) { throw null; }
         public Microsoft.Build.Execution.BuildResultCode ResultCode { get { throw null; } }
         public string TargetName { get { throw null; } }
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> TaskItems { get { throw null; } }
@@ -1458,8 +1468,8 @@ internal ProjectCacheDescriptor() { }
         public Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase PluginInstance { get { throw null; } }
         public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
         public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
-        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings=null) { throw null; }
-        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings=null) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) { throw null; }
         public string GetDetailedDescription() { throw null; }
     }
     public abstract partial class ProjectCachePluginBase
@@ -1481,9 +1491,9 @@ public abstract partial class MSBuildFileSystemBase
     {
         protected MSBuildFileSystemBase() { }
         public abstract bool DirectoryExists(string path);
-        public abstract System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
-        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
-        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly);
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly);
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly);
         public abstract bool FileExists(string path);
         public abstract bool FileOrDirectoryExists(string path);
         public abstract System.IO.FileAttributes GetAttributes(string path);
@@ -1521,6 +1531,8 @@ internal MSBuildGlob() { }
         [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
         public partial struct MatchInfoResult
         {
+            private object _dummy;
+            private int _dummyPrimitive;
             public string FilenamePartMatchGroup { get { throw null; } }
             public string FixedDirectoryPartMatchGroup { get { throw null; } }
             public bool IsMatch { get { throw null; } }
@@ -1628,9 +1640,10 @@ public ProjectGraph(string entryProjectFile, System.Collections.Generic.IDiction
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ProjectNodesTopologicallySorted { get { throw null; } }
         public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>> GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) { throw null; }
         [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-        public partial struct GraphConstructionMetrics
+        public readonly partial struct GraphConstructionMetrics
         {
-            public GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) { throw null;}
+            private readonly int _dummyPrimitive;
+            public GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) { throw null; }
             public System.TimeSpan ConstructionTime { get { throw null; } }
             public int EdgeCount { get { throw null; } }
             public int NodeCount { get { throw null; } }
@@ -1640,8 +1653,9 @@ public partial struct GraphConstructionMetrics
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct ProjectGraphEntryPoint
     {
-        public ProjectGraphEntryPoint(string projectFile) { throw null;}
-        public ProjectGraphEntryPoint(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) { throw null;}
+        private object _dummy;
+        public ProjectGraphEntryPoint(string projectFile) { throw null; }
+        public ProjectGraphEntryPoint(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) { throw null; }
         public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
         public string ProjectFile { get { throw null; } }
     }
@@ -1665,8 +1679,8 @@ public void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
         public void Shutdown() { }
         public enum ProjectImportsCollectionMode
         {
-            Embed = 1,
             None = 0,
+            Embed = 1,
             ZipFile = 2,
         }
     }
@@ -1806,19 +1820,19 @@ internal LinkedObjectsFactory() { }
         public Microsoft.Build.Construction.ProjectImportGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectItemDefinitionElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectItemDefinitionGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectItemDefinition Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink link, Microsoft.Build.Evaluation.Project project=null) { throw null; }
+        public Microsoft.Build.Evaluation.ProjectItemDefinition Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink link, Microsoft.Build.Evaluation.Project project = null) { throw null; }
         public Microsoft.Build.Construction.ProjectItemElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectItemGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectItem Create(Microsoft.Build.ObjectModelRemoting.ProjectItemLink link, Microsoft.Build.Evaluation.Project project=null, Microsoft.Build.Construction.ProjectItemElement xml=null) { throw null; }
+        public Microsoft.Build.Evaluation.ProjectItem Create(Microsoft.Build.ObjectModelRemoting.ProjectItemLink link, Microsoft.Build.Evaluation.Project project = null, Microsoft.Build.Construction.ProjectItemElement xml = null) { throw null; }
         public Microsoft.Build.Evaluation.Project Create(Microsoft.Build.ObjectModelRemoting.ProjectLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectMetadataElement Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectMetadata Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink link, object parent=null) { throw null; }
+        public Microsoft.Build.Evaluation.ProjectMetadata Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink link, object parent = null) { throw null; }
         public Microsoft.Build.Construction.ProjectOnErrorElement Create(Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectOtherwiseElement Create(Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectOutputElement Create(Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectPropertyElement Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectPropertyGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectProperty Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink link, Microsoft.Build.Evaluation.Project project=null) { throw null; }
+        public Microsoft.Build.Evaluation.ProjectProperty Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink link, Microsoft.Build.Evaluation.Project project = null) { throw null; }
         public Microsoft.Build.Construction.ProjectRootElement Create(Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectSdkElement Create(Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectTargetElement Create(Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink link) { throw null; }
@@ -1830,7 +1844,7 @@ internal LinkedObjectsFactory() { }
         public Microsoft.Build.Construction.UsingTaskParameterGroupElement Create(Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink link) { throw null; }
         public static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory Get(Microsoft.Build.Evaluation.ProjectCollection collection) { throw null; }
         public static object GetLink(object obj) { throw null; }
-        public static System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Evaluation.Project> GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection collection, string projectFile=null) { throw null; }
+        public static System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Evaluation.Project> GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection collection, string projectFile = null) { throw null; }
         public static bool IsLocal(object obj) { throw null; }
     }
     public abstract partial class ProjectChooseElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
@@ -2132,7 +2146,8 @@ protected UsingTaskParameterGroupElementLink() { }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct XmlAttributeLink
     {
-        public XmlAttributeLink(string localName, string value, string namespaceUri) { throw null;}
+        private object _dummy;
+        public XmlAttributeLink(string localName, string value, string namespaceUri) { throw null; }
         public string LocalName { get { throw null; } }
         public string NamespaceURI { get { throw null; } }
         public string Value { get { throw null; } }
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index 2d5246af021..2e945e6c024 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -15,9 +15,9 @@ protected ElementLocation() { }
     }
     public enum ImplicitImportLocation
     {
-        Bottom = 2,
         None = 0,
         Top = 1,
+        Bottom = 2,
     }
     public partial class ProjectChooseElement : Microsoft.Build.Construction.ProjectElementContainer
     {
@@ -319,10 +319,10 @@ internal ProjectRootElement() { }
         public Microsoft.Build.Construction.ProjectRootElement DeepClone() { throw null; }
         public static Microsoft.Build.Construction.ProjectRootElement Open(string path) { throw null; }
         public static Microsoft.Build.Construction.ProjectRootElement Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, System.Nullable<bool> preserveFormatting) { throw null; }
-        public void Reload(bool throwIfUnsavedChanges=true, System.Nullable<bool> preserveFormatting=default(System.Nullable<bool>)) { }
-        public void ReloadFrom(string path, bool throwIfUnsavedChanges=true, System.Nullable<bool> preserveFormatting=default(System.Nullable<bool>)) { }
-        public void ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges=true, System.Nullable<bool> preserveFormatting=default(System.Nullable<bool>)) { }
+        public static Microsoft.Build.Construction.ProjectRootElement Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) { throw null; }
+        public void Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = default(bool?)) { }
+        public void ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = default(bool?)) { }
+        public void ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges = true, bool? preserveFormatting = default(bool?)) { }
         public void Save() { }
         public void Save(System.IO.TextWriter writer) { }
         public void Save(string path) { }
@@ -330,7 +330,7 @@ public void Save(string path, System.Text.Encoding encoding) { }
         public void Save(System.Text.Encoding saveEncoding) { }
         public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path) { throw null; }
         public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { throw null; }
-        public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, System.Nullable<bool> preserveFormatting) { throw null; }
+        public static Microsoft.Build.Construction.ProjectRootElement TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) { throw null; }
     }
     public partial class ProjectSdkElement : Microsoft.Build.Construction.ProjectElementContainer
     {
@@ -465,13 +465,13 @@ internal SolutionFile() { }
     }
     public enum SolutionProjectType
     {
-        EtpSubProject = 5,
+        Unknown = 0,
         KnownToBeMSBuildFormat = 1,
-        SharedProject = 6,
         SolutionFolder = 2,
-        Unknown = 0,
-        WebDeploymentProject = 4,
         WebProject = 3,
+        WebDeploymentProject = 4,
+        EtpSubProject = 5,
+        SharedProject = 6,
     }
     public partial class UsingTaskParameterGroupElement : Microsoft.Build.Construction.ProjectElementContainer
     {
@@ -514,25 +514,25 @@ public static partial class MatchOnMetadataConstants
     }
     public enum MatchOnMetadataOptions
     {
-        CaseInsensitive = 1,
         CaseSensitive = 0,
+        CaseInsensitive = 1,
         PathLike = 2,
     }
     [System.FlagsAttribute]
     public enum NewProjectFileOptions
     {
         IncludeAllOptions = -1,
-        IncludeToolsVersion = 2,
+        None = 0,
         IncludeXmlDeclaration = 1,
+        IncludeToolsVersion = 2,
         IncludeXmlNamespace = 4,
-        None = 0,
     }
     public enum Operation
     {
-        Exclude = 1,
         Include = 0,
-        Remove = 3,
+        Exclude = 1,
         Update = 2,
+        Remove = 3,
     }
     public partial class Project
     {
@@ -719,14 +719,14 @@ internal ProjectCollectionChangedEventArgs() { }
     public enum ProjectCollectionChangedState
     {
         DefaultToolsVersion = 0,
-        DisableMarkDirty = 7,
+        Toolsets = 1,
+        Loggers = 2,
         GlobalProperties = 3,
-        HostServices = 6,
         IsBuildEnabled = 4,
-        Loggers = 2,
         OnlyLogCriticalEvents = 5,
+        HostServices = 6,
+        DisableMarkDirty = 7,
         SkipEvaluation = 8,
-        Toolsets = 1,
     }
     public partial class ProjectItem
     {
@@ -764,14 +764,14 @@ internal ProjectItemDefinition() { }
     public enum ProjectLoadSettings
     {
         Default = 0,
-        DoNotEvaluateElementsWithFalseCondition = 32,
-        IgnoreEmptyImports = 16,
-        IgnoreInvalidImports = 64,
         IgnoreMissingImports = 1,
-        ProfileEvaluation = 128,
         RecordDuplicateButNotCircularImports = 2,
-        RecordEvaluatedItemElements = 8,
         RejectCircularImports = 4,
+        RecordEvaluatedItemElements = 8,
+        IgnoreEmptyImports = 16,
+        DoNotEvaluateElementsWithFalseCondition = 32,
+        IgnoreInvalidImports = 64,
+        ProfileEvaluation = 128,
     }
     public partial class ProjectMetadata : System.IEquatable<Microsoft.Build.Evaluation.ProjectMetadata>
     {
@@ -812,10 +812,10 @@ internal ProjectXmlChangedEventArgs() { }
     [System.FlagsAttribute]
     public enum Provenance
     {
+        Undefined = 0,
+        StringLiteral = 1,
         Glob = 2,
         Inconclusive = 4,
-        StringLiteral = 1,
-        Undefined = 0,
     }
     public partial class ProvenanceResult
     {
@@ -828,6 +828,8 @@ public ProvenanceResult(Microsoft.Build.Construction.ProjectItemElement itemElem
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct ResolvedImport
     {
+        private object _dummy;
+        private int _dummyPrimitive;
         public Microsoft.Build.Construction.ProjectRootElement ImportedProject { get { throw null; } }
         public Microsoft.Build.Construction.ProjectImportElement ImportingElement { get { throw null; } }
         public bool IsImported { get { throw null; } }
@@ -856,11 +858,11 @@ public Toolset(string toolsVersion, string toolsPath, System.Collections.Generic
     [System.FlagsAttribute]
     public enum ToolsetDefinitionLocations
     {
+        None = 0,
         ConfigurationFile = 1,
+        Registry = 2,
         Default = 4,
         Local = 4,
-        None = 0,
-        Registry = 2,
     }
 }
 namespace Microsoft.Build.Evaluation.Context
@@ -872,8 +874,8 @@ internal EvaluationContext() { }
         public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) { throw null; }
         public enum SharingPolicy
         {
-            Isolated = 1,
             Shared = 0,
+            Isolated = 1,
         }
     }
 }
@@ -957,9 +959,11 @@ public void EndBuild() { }
         public void ResetCaches() { }
         public void ShutdownAllNodes() { }
         [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-        public partial struct DeferredBuildMessage
+        public readonly partial struct DeferredBuildMessage
         {
-            public DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) { throw null;}
+            private readonly object _dummy;
+            private readonly int _dummyPrimitive;
+            public DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) { throw null; }
             public Microsoft.Build.Framework.MessageImportance Importance { get { throw null; } }
             public string Text { get { throw null; } }
         }
@@ -1030,14 +1034,14 @@ public BuildRequestData(string projectFullPath, System.Collections.Generic.IDict
     [System.FlagsAttribute]
     public enum BuildRequestDataFlags
     {
-        ClearCachesAfterBuild = 8,
-        IgnoreExistingProjectState = 4,
-        IgnoreMissingEmptyAndInvalidImports = 64,
         None = 0,
-        ProvideProjectStateAfterBuild = 2,
-        ProvideSubsetOfStateAfterBuild = 32,
         ReplaceExistingProjectInstance = 1,
+        ProvideProjectStateAfterBuild = 2,
+        IgnoreExistingProjectState = 4,
+        ClearCachesAfterBuild = 8,
         SkipNonexistentTargets = 16,
+        ProvideSubsetOfStateAfterBuild = 32,
+        IgnoreMissingEmptyAndInvalidImports = 64,
     }
     public partial class BuildResult
     {
@@ -1059,8 +1063,8 @@ public void MergeResults(Microsoft.Build.Execution.BuildResult results) { }
     }
     public enum BuildResultCode
     {
-        Failure = 1,
         Success = 0,
+        Failure = 1,
     }
     public partial class BuildSubmission
     {
@@ -1093,9 +1097,9 @@ public partial interface ITargetResult
     }
     public enum NodeAffinity
     {
-        Any = 2,
         InProc = 0,
         OutOfProc = 1,
+        Any = 2,
     }
     public enum NodeEngineShutdownReason
     {
@@ -1107,15 +1111,16 @@ public enum NodeEngineShutdownReason
     public partial class OutOfProcNode
     {
         public OutOfProcNode() { }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) { shutdownException = default(System.Exception); throw null; }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, out System.Exception shutdownException) { shutdownException = default(System.Exception); throw null; }
-        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(out System.Exception shutdownException) { shutdownException = default(System.Exception); throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) { throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, out System.Exception shutdownException) { throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(out System.Exception shutdownException) { throw null; }
     }
     public partial class ProjectInstance
     {
         public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml) { }
         public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
         public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
+        public ProjectInstance(Microsoft.Build.Evaluation.Project project, Microsoft.Build.Execution.ProjectInstanceSettings settings) { }
         public ProjectInstance(string projectFile) { }
         public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
         public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
@@ -1146,9 +1151,9 @@ public ProjectInstance(string projectFile, System.Collections.Generic.IDictionar
         public bool Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
         public bool Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
         public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) { targetOutputs = default(System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult>); throw null; }
+        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) { throw null; }
         public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) { throw null; }
-        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) { targetOutputs = default(System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult>); throw null; }
+        public bool Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) { throw null; }
         public Microsoft.Build.Execution.ProjectInstance DeepCopy() { throw null; }
         public Microsoft.Build.Execution.ProjectInstance DeepCopy(bool isImmutable) { throw null; }
         public bool EvaluateCondition(string condition) { throw null; }
@@ -1175,9 +1180,9 @@ public void UpdateStateFrom(Microsoft.Build.Execution.ProjectInstance projectSta
     [System.FlagsAttribute]
     public enum ProjectInstanceSettings
     {
+        None = 0,
         Immutable = 1,
         ImmutableWithFastItemLookup = 3,
-        None = 0,
     }
     public partial class ProjectItemDefinitionInstance
     {
@@ -1397,16 +1402,16 @@ internal TargetResult() { }
     }
     public enum TargetResultCode : byte
     {
-        Failure = (byte)2,
         Skipped = (byte)0,
         Success = (byte)1,
+        Failure = (byte)2,
     }
 }
 namespace Microsoft.Build.Experimental.ProjectCache
 {
     public partial class CacheContext
     {
-        public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph=null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints=null) { }
+        public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph = null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints = null) { }
         public Microsoft.Build.FileSystem.MSBuildFileSystemBase FileSystem { get { throw null; } }
         public Microsoft.Build.Graph.ProjectGraph Graph { get { throw null; } }
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> GraphEntryPoints { get { throw null; } }
@@ -1416,6 +1421,9 @@ public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, strin
     public partial class CacheResult
     {
         internal CacheResult() { }
+        public Microsoft.Build.Execution.BuildResult BuildResult { get { throw null; } }
+        public Microsoft.Build.Experimental.ProjectCache.ProxyTargets ProxyTargets { get { throw null; } }
+        public Microsoft.Build.Experimental.ProjectCache.CacheResultType ResultType { get { throw null; } }
         public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) { throw null; }
         public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) { throw null; }
         public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) { throw null; }
@@ -1423,23 +1431,25 @@ internal CacheResult() { }
     }
     public enum CacheResultType
     {
+        None = 0,
         CacheHit = 1,
         CacheMiss = 2,
         CacheNotApplicable = 3,
-        None = 0,
     }
     public abstract partial class PluginLoggerBase
     {
         protected PluginLoggerBase(Microsoft.Build.Framework.LoggerVerbosity verbosity) { }
         public abstract bool HasLoggedErrors { get; protected set; }
         public abstract void LogError(string error);
-        public abstract void LogMessage(string message, System.Nullable<Microsoft.Build.Framework.MessageImportance> messageImportance=default(System.Nullable<Microsoft.Build.Framework.MessageImportance>));
+        public abstract void LogMessage(string message, Microsoft.Build.Framework.MessageImportance? messageImportance = default(Microsoft.Build.Framework.MessageImportance?));
         public abstract void LogWarning(string warning);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-    public partial struct PluginTargetResult
+    public readonly partial struct PluginTargetResult
     {
-        public PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) { throw null;}
+        private readonly object _dummy;
+        private readonly int _dummyPrimitive;
+        public PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) { throw null; }
         public Microsoft.Build.Execution.BuildResultCode ResultCode { get { throw null; } }
         public string TargetName { get { throw null; } }
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> TaskItems { get { throw null; } }
@@ -1452,8 +1462,8 @@ internal ProjectCacheDescriptor() { }
         public Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase PluginInstance { get { throw null; } }
         public System.Collections.Generic.IReadOnlyDictionary<string, string> PluginSettings { get { throw null; } }
         public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
-        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings=null) { throw null; }
-        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings=null) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) { throw null; }
+        public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) { throw null; }
         public string GetDetailedDescription() { throw null; }
     }
     public abstract partial class ProjectCachePluginBase
@@ -1475,9 +1485,9 @@ public abstract partial class MSBuildFileSystemBase
     {
         protected MSBuildFileSystemBase() { }
         public abstract bool DirectoryExists(string path);
-        public abstract System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
-        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
-        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly);
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly);
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly);
         public abstract bool FileExists(string path);
         public abstract bool FileOrDirectoryExists(string path);
         public abstract System.IO.FileAttributes GetAttributes(string path);
@@ -1515,6 +1525,8 @@ internal MSBuildGlob() { }
         [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
         public partial struct MatchInfoResult
         {
+            private object _dummy;
+            private int _dummyPrimitive;
             public string FilenamePartMatchGroup { get { throw null; } }
             public string FixedDirectoryPartMatchGroup { get { throw null; } }
             public bool IsMatch { get { throw null; } }
@@ -1622,9 +1634,10 @@ public ProjectGraph(string entryProjectFile, System.Collections.Generic.IDiction
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ProjectNodesTopologicallySorted { get { throw null; } }
         public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>> GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) { throw null; }
         [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-        public partial struct GraphConstructionMetrics
+        public readonly partial struct GraphConstructionMetrics
         {
-            public GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) { throw null;}
+            private readonly int _dummyPrimitive;
+            public GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) { throw null; }
             public System.TimeSpan ConstructionTime { get { throw null; } }
             public int EdgeCount { get { throw null; } }
             public int NodeCount { get { throw null; } }
@@ -1634,8 +1647,9 @@ public partial struct GraphConstructionMetrics
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct ProjectGraphEntryPoint
     {
-        public ProjectGraphEntryPoint(string projectFile) { throw null;}
-        public ProjectGraphEntryPoint(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) { throw null;}
+        private object _dummy;
+        public ProjectGraphEntryPoint(string projectFile) { throw null; }
+        public ProjectGraphEntryPoint(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) { throw null; }
         public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
         public string ProjectFile { get { throw null; } }
     }
@@ -1659,8 +1673,8 @@ public void Initialize(Microsoft.Build.Framework.IEventSource eventSource) { }
         public void Shutdown() { }
         public enum ProjectImportsCollectionMode
         {
-            Embed = 1,
             None = 0,
+            Embed = 1,
             ZipFile = 2,
         }
     }
@@ -1800,19 +1814,19 @@ internal LinkedObjectsFactory() { }
         public Microsoft.Build.Construction.ProjectImportGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectItemDefinitionElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectItemDefinitionGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectItemDefinition Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink link, Microsoft.Build.Evaluation.Project project=null) { throw null; }
+        public Microsoft.Build.Evaluation.ProjectItemDefinition Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink link, Microsoft.Build.Evaluation.Project project = null) { throw null; }
         public Microsoft.Build.Construction.ProjectItemElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectItemGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectItem Create(Microsoft.Build.ObjectModelRemoting.ProjectItemLink link, Microsoft.Build.Evaluation.Project project=null, Microsoft.Build.Construction.ProjectItemElement xml=null) { throw null; }
+        public Microsoft.Build.Evaluation.ProjectItem Create(Microsoft.Build.ObjectModelRemoting.ProjectItemLink link, Microsoft.Build.Evaluation.Project project = null, Microsoft.Build.Construction.ProjectItemElement xml = null) { throw null; }
         public Microsoft.Build.Evaluation.Project Create(Microsoft.Build.ObjectModelRemoting.ProjectLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectMetadataElement Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectMetadata Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink link, object parent=null) { throw null; }
+        public Microsoft.Build.Evaluation.ProjectMetadata Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink link, object parent = null) { throw null; }
         public Microsoft.Build.Construction.ProjectOnErrorElement Create(Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectOtherwiseElement Create(Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectOutputElement Create(Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectPropertyElement Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectPropertyGroupElement Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink link) { throw null; }
-        public Microsoft.Build.Evaluation.ProjectProperty Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink link, Microsoft.Build.Evaluation.Project project=null) { throw null; }
+        public Microsoft.Build.Evaluation.ProjectProperty Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink link, Microsoft.Build.Evaluation.Project project = null) { throw null; }
         public Microsoft.Build.Construction.ProjectRootElement Create(Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectSdkElement Create(Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink link) { throw null; }
         public Microsoft.Build.Construction.ProjectTargetElement Create(Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink link) { throw null; }
@@ -1824,7 +1838,7 @@ internal LinkedObjectsFactory() { }
         public Microsoft.Build.Construction.UsingTaskParameterGroupElement Create(Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink link) { throw null; }
         public static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory Get(Microsoft.Build.Evaluation.ProjectCollection collection) { throw null; }
         public static object GetLink(object obj) { throw null; }
-        public static System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Evaluation.Project> GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection collection, string projectFile=null) { throw null; }
+        public static System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Evaluation.Project> GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection collection, string projectFile = null) { throw null; }
         public static bool IsLocal(object obj) { throw null; }
     }
     public abstract partial class ProjectChooseElementLink : Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
@@ -2126,7 +2140,8 @@ protected UsingTaskParameterGroupElementLink() { }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public partial struct XmlAttributeLink
     {
-        public XmlAttributeLink(string localName, string value, string namespaceUri) { throw null;}
+        private object _dummy;
+        public XmlAttributeLink(string localName, string value, string namespaceUri) { throw null; }
         public string LocalName { get { throw null; } }
         public string NamespaceURI { get { throw null; } }
         public string Value { get { throw null; } }
diff --git a/runApiCompat.bat b/runApiCompat.bat
deleted file mode 100644
index 34ad60930c5..00000000000
--- a/runApiCompat.bat
+++ /dev/null
@@ -1,14 +0,0 @@
-@echo off
-setlocal
-
-set MSBUILD_ROOT=%~dp0
-
-REM Copy .NET 4.6 reference assemblies to the same folder as the MSBuild reference assemblies so ApiCompat can resolve their framework references
-mkdir "%MSBUILD_ROOT%ref"
-RoboCopy "C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6" "%MSBUILD_ROOT%ref"
-RoboCopy "C:\Program Files (x86)\Reference Assemblies\Microsoft\MSBuild\v14.0" "%MSBUILD_ROOT%ref"
-
-REM Run ApiCompat
-\\fxcore\tools\bin\ApiCompat.exe "%MSBUILD_ROOT%\bin\Windows_NT\Debug-NetCore\Microsoft.Build.Framework.dll,%MSBUILD_ROOT%\bin\Windows_NT\Debug-NetCore\Microsoft.Build.Utilities.Core.dll,%MSBUILD_ROOT%\bin\Windows_NT\Debug-NetCore\Microsoft.Build.Tasks.Core.dll" -implDirs:"%MSBUILD_ROOT%ref" -contractDepends:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6,C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6\Facades" -out:Differences.txt -baseline:CompatBaseline.txt
-
-endlocal
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index b7bf08ced01..c9bc90217fe 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -74,11 +74,11 @@ $filesToCopyToBin = @(
     FileToCopy "$bootstrapBinDirectory\Microsoft.Managed.targets"
     FileToCopy "$bootstrapBinDirectory\Microsoft.Managed.Before.targets"
     FileToCopy "$bootstrapBinDirectory\Microsoft.Managed.After.targets"
-    FileToCopy "$bootstrapBinDirectory\Microsoft.Net.props"
-    FileToCopy "$bootstrapBinDirectory\Microsoft.NetFramework.CurrentVersion.props"
-    FileToCopy "$bootstrapBinDirectory\Microsoft.NetFramework.CurrentVersion.targets"
-    FileToCopy "$bootstrapBinDirectory\Microsoft.NetFramework.props"
-    FileToCopy "$bootstrapBinDirectory\Microsoft.NetFramework.targets"
+    FileToCopy "$bootstrapBinDirectory\Microsoft.NET.props"
+    FileToCopy "$bootstrapBinDirectory\Microsoft.NETFramework.CurrentVersion.props"
+    FileToCopy "$bootstrapBinDirectory\Microsoft.NETFramework.CurrentVersion.targets"
+    FileToCopy "$bootstrapBinDirectory\Microsoft.NETFramework.props"
+    FileToCopy "$bootstrapBinDirectory\Microsoft.NETFramework.targets"
     FileToCopy "$bootstrapBinDirectory\Microsoft.VisualBasic.CrossTargeting.targets"
     FileToCopy "$bootstrapBinDirectory\Microsoft.VisualBasic.CurrentVersion.targets"
     FileToCopy "$bootstrapBinDirectory\Microsoft.VisualBasic.targets"
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 8d9406a91cb..ec4dd997eb7 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -2231,7 +2231,7 @@ public void RemoveWithItemReferenceOnFilePathMatchingMetadata()
                 <I1 Include='c1' M1='foo/bar.vb' M2='y'/>
                 <I1 Include='d1' M1='foo\foo\foo' M2='b'/>
                 <I1 Include='e1' M1='a/b/../c/./d' M2='1'/>
-                <I1 Include='f1' M1='{ ObjectModelHelpers.TempProjectDir }\b\c' M2='6'/>
+                <I1 Include='f1' M1='{ Environment.CurrentDirectory }\b\c' M2='6'/>
 
                 <I2 Include='a2' M1='FOO.TXT' m2='c'/>
                 <I2 Include='b2' M1='foo/bar.txt' m2='x'/>
@@ -2403,7 +2403,7 @@ public void KeepWithItemReferenceOnNonmatchingMetadata()
         }
 
         [Fact]
-        public void FailWithMatchingMultipleMetadata()
+        public void RemoveMatchingMultipleMetadata()
         {
             string content = ObjectModelHelpers.FormatProjectContentsWithItemGroupFragment(
                 @"<I1 Include='a1' M1='1' M2='a'/>
@@ -2418,12 +2418,16 @@ public void FailWithMatchingMultipleMetadata()
 
                 <I2 Remove='@(I1)' MatchOnMetadata='M1;M2'/>");
 
-            Should.Throw<InvalidProjectFileException>(() => ObjectModelHelpers.CreateInMemoryProject(content))
-                .HelpKeyword.ShouldBe("MSBuild.OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem");
+            Project project = ObjectModelHelpers.CreateInMemoryProject(content);
+            IEnumerable<ProjectItem> items = project.ItemsIgnoringCondition.Where(i => i.ItemType.Equals("I2"));
+            items.Count().ShouldBe(3);
+            items.ElementAt(0).EvaluatedInclude.ShouldBe("a2");
+            items.ElementAt(1).EvaluatedInclude.ShouldBe("c2");
+            items.ElementAt(2).EvaluatedInclude.ShouldBe("d2");
         }
 
         [Fact]
-        public void FailWithMultipleItemReferenceOnMatchingMetadata()
+        public void RemoveMultipleItemReferenceOnMatchingMetadata()
         {
             string content = ObjectModelHelpers.FormatProjectContentsWithItemGroupFragment(
                 @"<I1 Include='a1' M1='1' M2='a'/>
@@ -2443,8 +2447,9 @@ public void FailWithMultipleItemReferenceOnMatchingMetadata()
 
                 <I3 Remove='@(I1);@(I2)' MatchOnMetadata='M1' />");
 
-            Should.Throw<InvalidProjectFileException>(() => ObjectModelHelpers.CreateInMemoryProject(content))
-                .HelpKeyword.ShouldBe("MSBuild.OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem");
+            Project project = ObjectModelHelpers.CreateInMemoryProject(content);
+            IEnumerable<ProjectItem> items = project.ItemsIgnoringCondition.Where(i => i.ItemType.Equals("I3"));
+            items.ShouldBeEmpty();
         }
 
         [Fact]
@@ -2462,9 +2467,8 @@ public void FailWithMetadataItemReferenceOnMatchingMetadata()
                 <I2 Include='d2' M1='y' m2='d'/>
 
                 <I2 Remove='%(I1.M1)' MatchOnMetadata='M1' />");
-
             Should.Throw<InvalidProjectFileException>(() => ObjectModelHelpers.CreateInMemoryProject(content))
-                .HelpKeyword.ShouldBe("MSBuild.OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem");
+                .HelpKeyword.ShouldBe("MSBuild.OM_MatchOnMetadataIsRestrictedToReferencedItems");
         }
 
         [Fact]
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index 6dcaa45e84e..a7be71e809a 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -60,7 +60,7 @@ public Project_Tests(ITestOutputHelper output)
         public void Dispose()
         {
             ProjectCollection.GlobalProjectCollection.UnloadAllProjects();
-            Assert.Equal(0, ProjectCollection.GlobalProjectCollection.Count);
+            ProjectCollection.GlobalProjectCollection.Count.ShouldBe(0);
 
             IDictionary<string, string> globalProperties = ProjectCollection.GlobalProjectCollection.GlobalProperties;
             foreach (string propertyName in globalProperties.Keys)
@@ -68,7 +68,7 @@ public void Dispose()
                 ProjectCollection.GlobalProjectCollection.RemoveGlobalProperty(propertyName);
             }
 
-            Assert.Empty(ProjectCollection.GlobalProjectCollection.GlobalProperties);
+            ProjectCollection.GlobalProjectCollection.GlobalProperties.ShouldBeEmpty();
         }
 
         private static readonly string ProjectWithItemGroup =
@@ -108,7 +108,7 @@ public void VerifyNewLinesAndTabsEvaluateToEmpty()
             ProjectRootElement xml = ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)));
             Project project = new Project(xml);
             bool result = project.Build(new ILogger[] { mockLogger });
-            Assert.True(result);
+            result.ShouldBeTrue();
             mockLogger.AssertLogContains("NewLineEvalAsEmpty");
             mockLogger.AssertLogContains("TabEvalAsEmpty");
             mockLogger.AssertLogContains("CarriageReturnEvalAsEmpty");
@@ -136,7 +136,7 @@ public void LogWithLoggersOnProjectCollection()
             Project project = new Project(xml, null, null, collection);
 
             bool result = project.Build();
-            Assert.True(result);
+            result.ShouldBeTrue();
             mockLogger.AssertLogContains("IHaveBeenLogged");
         }
 
@@ -163,7 +163,7 @@ public void LogWithLoggersOnProjectCollectionCustomOneUsed()
             Project project = new Project(xml, null, null, collection);
 
             bool result = project.Build(mockLogger);
-            Assert.True(result);
+            result.ShouldBeTrue();
             mockLogger.AssertLogContains("IHaveBeenLogged");
             mockLogger2.AssertLogDoesntContain("IHaveBeenLogged");
         }
@@ -238,7 +238,7 @@ public void FailedEvaluationClearsXmlCache()
         [Fact]
         public void ReadFromEmptyReader1()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 XmlReader reader = XmlReader.Create(new StringReader(String.Empty));
                 ProjectRootElement.Create(reader);
@@ -252,7 +252,7 @@ public void ReadFromEmptyReader1()
         [Fact]
         public void ReadFromEmptyReader2()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 XmlReader reader = XmlReader.Create(new StringReader(String.Empty));
                 Project project = new Project(reader);
@@ -266,7 +266,7 @@ public void ReadFromEmptyReader2()
         [Fact]
         public void ReadFromEmptyReader3()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 // Variation, we have a reader but it's already read
                 XmlReader reader = XmlReader.Create(new StringReader(ProjectRootElement.Create().RawXml));
@@ -287,7 +287,7 @@ public void ReadFromEmptyReader3()
         [Fact]
         public void ReadFromClosedReader()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 XmlReader reader = XmlReader.Create(new StringReader(String.Empty));
                 reader.Dispose();
@@ -311,7 +311,7 @@ public void ReadFromReaderTwoDocs()
 
             Project project2 = new Project(reader);
 
-            Assert.False(reader.Read());
+            reader.Read().ShouldBeFalse();
         }
 
         /// <summary>
@@ -320,7 +320,7 @@ public void ReadFromReaderTwoDocs()
         [Fact]
         public void ImportDoesNotExistDefaultSettings()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 ProjectRootElement xml = ProjectRootElement.Create();
                 xml.AddImport("__nonexistent__");
@@ -335,7 +335,7 @@ public void ImportDoesNotExistDefaultSettings()
         [Fact]
         public void ImportInvalidUriFormat()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 ProjectRootElement xml = ProjectRootElement.Create();
                 xml.AddImport(@"//MSBuildExtensionsPath32)\4.0\Microsoft.VisualStudioVersion.v11.Common.props");
@@ -375,7 +375,7 @@ public void ImportDoesNotExistIgnoreMissingImports()
             Project project = new Project(xml, null, null, new ProjectCollection(), ProjectLoadSettings.IgnoreMissingImports);
 
             // Make sure some evaluation did occur
-            Assert.Equal("1", project.GetPropertyValue("q"));
+            project.GetPropertyValue("q").ShouldBe("1");
         }
 
         /// <summary>
@@ -385,12 +385,12 @@ public void ImportDoesNotExistIgnoreMissingImports()
         [Fact]
         public void TryImportsIncludingDuplicatesExpectException()
         {
-            Assert.Throws<InvalidOperationException>(() =>
+            Should.Throw<InvalidOperationException>(() =>
             {
                 ProjectRootElement xml = ProjectRootElement.Create();
                 Project project = new Project(xml, null, null, new ProjectCollection(), ProjectLoadSettings.IgnoreMissingImports);
                 IList<ResolvedImport> imports = project.ImportsIncludingDuplicates;
-                Assert.Empty(imports);
+                imports.ShouldBeEmpty();
             }
            );
         }
@@ -600,27 +600,27 @@ public void BasicFromXmlFollowImport()
             ProjectRootElement xml = ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)));
             Project project = new Project(xml);
 
-            Assert.Equal("v3", project.GetPropertyValue("p2"));
+            project.GetPropertyValue("p2").ShouldBe("v3");
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItems("i"));
-            Assert.Equal(4, items.Count);
-            Assert.Equal("i1", items[0].EvaluatedInclude);
-            Assert.Equal("v2X", items[1].EvaluatedInclude);
-            Assert.Equal("i3", items[2].EvaluatedInclude);
-            Assert.Equal("i4", items[3].EvaluatedInclude);
+            items.Count.ShouldBe(4);
+            items[0].EvaluatedInclude.ShouldBe("i1");
+            items[1].EvaluatedInclude.ShouldBe("v2X");
+            items[2].EvaluatedInclude.ShouldBe("i3");
+            items[3].EvaluatedInclude.ShouldBe("i4");
 
             IList<ResolvedImport> imports = project.Imports;
-            Assert.Single(imports);
-            Assert.True(object.ReferenceEquals(imports.First().ImportingElement, xml.Imports.ElementAt(0)));
+            imports.ShouldHaveSingleItem();
+            object.ReferenceEquals(imports.First().ImportingElement, xml.Imports.ElementAt(0)).ShouldBeTrue();
 
             // We can take advantage of the fact that we will get the same ProjectRootElement from the cache if we try to
             // open it with a path; get that and then compare it to what project.Imports gave us.
-            Assert.True(object.ReferenceEquals(imports.First().ImportedProject, ProjectRootElement.Open(importPath)));
+            object.ReferenceEquals(imports.First().ImportedProject, ProjectRootElement.Open(importPath)).ShouldBeTrue();
 
             // Test the logical project iterator
             List<ProjectElement> logicalElements = new List<ProjectElement>(project.GetLogicalProject());
 
-            Assert.Equal(18, logicalElements.Count);
+            logicalElements.Count.ShouldBe(18);
 
             ObjectModelHelpers.DeleteTempProjectDirectory();
         }
@@ -651,11 +651,10 @@ public void TransformsUseCorrectDirectory_Basic()
                 project.Save(file);
                 project.ReevaluateIfNecessary();
 
-                Assert.Equal(
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(
                     NativeMethodsShared.IsWindows
                         ? Path.Combine(Path.GetTempPath(), @"obj\i386\foo.dll")
-                        : Path.Combine(Path.GetTempPath(), @"obj/i386/foo.dll"),
-                    project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
+                        : Path.Combine(Path.GetTempPath(), @"obj/i386/foo.dll"));
             }
             finally
             {
@@ -685,21 +684,13 @@ public void TransformsUseCorrectDirectory_Basic_NotSaved()
 
             if (NativeMethodsShared.IsWindows)
             {
-                Assert.Equal(
-                    Path.Combine(Directory.GetCurrentDirectory(), @"obj\i386\foo.dll"),
-                    project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
-                Assert.Equal(
-                    Path.Combine(Directory.GetCurrentDirectory(), @"obj\i386\foo.dll"),
-                    projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), @"obj\i386\foo.dll"));
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), @"obj\i386\foo.dll"));
             }
             else
             {
-                Assert.Equal(
-                    Path.Combine(Directory.GetCurrentDirectory(), @"obj/i386/foo.dll"),
-                    project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
-                Assert.Equal(
-                   Path.Combine(Directory.GetCurrentDirectory(), @"obj/i386/foo.dll"),
-                    projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), @"obj/i386/foo.dll"));
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), @"obj/i386/foo.dll"));
             }
         }
 
@@ -728,12 +719,8 @@ public void TransformsUseCorrectDirectory_DirectoryTransform()
                 Project project = new Project(xml);
                 ProjectInstance projectInstance = new ProjectInstance(xml);
 
-                Assert.Equal(
-                        Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar,
-                        project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
-                Assert.Equal(
-                        Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar,
-                        projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
             }
             finally
             {
@@ -767,12 +754,8 @@ public void TransformsUseCorrectDirectory_DirectoryItemFunction()
                 Project project = new Project(xml);
                 ProjectInstance projectInstance = new ProjectInstance(xml);
 
-                Assert.Equal(
-                        Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar,
-                        project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
-                Assert.Equal(
-                        Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar,
-                        projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
             }
             finally
             {
@@ -809,12 +792,8 @@ public void TransformsUseCorrectDirectory_DirectoryNameItemFunction()
                 ProjectInstance projectInstance = new ProjectInstance(xml);
 
                 // Should be the full path to the directory
-                Assert.Equal(
-                    Path.Combine(Path.GetTempPath() /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"),
-                    project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
-                Assert.Equal(
-                    Path.Combine(Path.GetTempPath() /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"),
-                    projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath() /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"));
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath() /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"));
             }
             finally
             {
@@ -834,8 +813,8 @@ public void GetGlobalProperties()
             globalProperties.Add("g2", "v2");
             Project project = new Project(xml, globalProperties, null);
 
-            Assert.Equal("v1", project.GlobalProperties["g1"]);
-            Assert.Equal("v2", project.GlobalProperties["g2"]);
+            project.GlobalProperties["g1"].ShouldBe("v1");
+            project.GlobalProperties["g2"].ShouldBe("v2");
         }
 
         /// <summary>
@@ -852,8 +831,8 @@ public void GlobalPropertiesCloned()
 
             globalProperties.Add("g2", "v2");
 
-            Assert.Equal("v1", project.GlobalProperties["g1"]);
-            Assert.False(project.GlobalProperties.ContainsKey("g2"));
+            project.GlobalProperties["g1"].ShouldBe("v1");
+            project.GlobalProperties.ContainsKey("g2").ShouldBeFalse();
         }
 
         /// <summary>
@@ -865,7 +844,7 @@ public void GetGlobalPropertiesNone()
             ProjectRootElement xml = GetSampleProjectRootElement();
             Project project = new Project(xml);
 
-            Assert.Empty(project.GlobalProperties);
+            project.GlobalProperties.ShouldBeEmpty();
         }
 
         /// <summary>
@@ -879,13 +858,13 @@ public void ChangeGlobalProperties()
             ProjectPropertyElement propertyElement = project.Xml.AddProperty("p", "v0");
             propertyElement.Condition = "'$(g)'=='v1'";
             project.ReevaluateIfNecessary();
-            Assert.Equal(string.Empty, project.GetPropertyValue("p"));
+            project.GetPropertyValue("p").ShouldBe(string.Empty);
 
-            Assert.True(project.SetGlobalProperty("g", "v1"));
-            Assert.True(project.IsDirty);
+            project.SetGlobalProperty("g", "v1").ShouldBeTrue();
+            project.IsDirty.ShouldBeTrue();
             project.ReevaluateIfNecessary();
-            Assert.Equal("v0", project.GetPropertyValue("p"));
-            Assert.Equal("v1", project.GlobalProperties["g"]);
+            project.GetPropertyValue("p").ShouldBe("v0");
+            project.GlobalProperties["g"].ShouldBe("v1");
         }
 
         /// <summary>
@@ -899,8 +878,8 @@ public void ChangeGlobalPropertyAfterReevaluation()
             project.ReevaluateIfNecessary();
             project.SetGlobalProperty("p", "v2");
 
-            Assert.Equal("v2", project.GetPropertyValue("p"));
-            Assert.True(project.GetProperty("p").IsGlobalProperty);
+            project.GetPropertyValue("p").ShouldBe("v2");
+            project.GetProperty("p").IsGlobalProperty.ShouldBeTrue();
         }
 
         /// <summary>
@@ -912,19 +891,19 @@ public void SkipEvaluation()
             Project project = new Project();
             project.SetGlobalProperty("p", "v1");
             project.ReevaluateIfNecessary();
-            Assert.Equal("v1", project.GetPropertyValue("p"));
+            project.GetPropertyValue("p").ShouldBe("v1");
 
             project.SkipEvaluation = true;
             ProjectPropertyElement propertyElement = project.Xml.AddProperty("p1", "v0");
             propertyElement.Condition = "'$(g)'=='v1'";
             project.SetGlobalProperty("g", "v1");
             project.ReevaluateIfNecessary();
-            Assert.Equal(string.Empty, project.GetPropertyValue("p1"));
+            project.GetPropertyValue("p1").ShouldBe(string.Empty);
 
             project.SkipEvaluation = false;
             project.SetGlobalProperty("g", "v1");
             project.ReevaluateIfNecessary();
-            Assert.Equal("v0", project.GetPropertyValue("p1"));
+            project.GetPropertyValue("p1").ShouldBe("v0");
         }
 
         /// <summary>
@@ -934,7 +913,7 @@ public void SkipEvaluation()
         [Fact]
         public void ChangeGlobalPropertyAfterReevaluation2()
         {
-            Assert.Throws<InvalidOperationException>(() =>
+            Should.Throw<InvalidOperationException>(() =>
             {
                 Project project = new Project();
                 project.SetGlobalProperty("p", "v1");
@@ -952,12 +931,12 @@ public void ChangeEnvironmentProperty()
             Project project = new Project();
             project.SetProperty("computername", "v1");
 
-            Assert.Equal("v1", project.GetPropertyValue("computername"));
-            Assert.True(project.IsDirty);
+            project.GetPropertyValue("computername").ShouldBe("v1");
+            project.IsDirty.ShouldBeTrue();
 
             project.ReevaluateIfNecessary();
 
-            Assert.Equal("v1", project.GetPropertyValue("computername"));
+            project.GetPropertyValue("computername").ShouldBe("v1");
         }
 
         /// <summary>
@@ -966,7 +945,7 @@ public void ChangeEnvironmentProperty()
         [Fact]
         public void SetReservedPropertyThroughProject()
         {
-            Assert.Throws<InvalidOperationException>(() =>
+            Should.Throw<InvalidOperationException>(() =>
             {
                 Project project = new Project();
                 project.SetProperty("msbuildprojectdirectory", "v1");
@@ -986,14 +965,14 @@ public void ChangeGlobalPropertiesPreexisting()
             ProjectPropertyElement propertyElement = project.Xml.AddProperty("pp", "vv");
             propertyElement.Condition = "'$(p0)'=='v0' and '$(p1)'=='v1b'";
             project.ReevaluateIfNecessary();
-            Assert.Equal(string.Empty, project.GetPropertyValue("pp"));
+            project.GetPropertyValue("pp").ShouldBe(string.Empty);
 
             project.SetGlobalProperty("p1", "v1b");
-            Assert.True(project.IsDirty);
+            project.IsDirty.ShouldBeTrue();
             project.ReevaluateIfNecessary();
-            Assert.Equal("vv", project.GetPropertyValue("pp"));
-            Assert.Equal("v0", project.GlobalProperties["p0"]);
-            Assert.Equal("v1b", project.GlobalProperties["p1"]);
+            project.GetPropertyValue("pp").ShouldBe("vv");
+            project.GlobalProperties["p0"].ShouldBe("v0");
+            project.GlobalProperties["p1"].ShouldBe("v1b");
         }
 
         /// <summary>
@@ -1016,14 +995,14 @@ public void ChangeGlobalPropertiesInitiallyFromProjectCollection()
             ProjectPropertyElement propertyElement = project.Xml.AddProperty("pp", "vv");
             propertyElement.Condition = "'$(p0)'=='v0' and '$(p1)'=='v1b'";
             project.ReevaluateIfNecessary();
-            Assert.Equal(string.Empty, project.GetPropertyValue("pp"));
+            project.GetPropertyValue("pp").ShouldBe(string.Empty);
 
             project.SetGlobalProperty("p1", "v1b");
-            Assert.True(project.IsDirty);
+            project.IsDirty.ShouldBeTrue();
             project.ReevaluateIfNecessary();
-            Assert.Equal("vv", project.GetPropertyValue("pp"));
-            Assert.Equal("v0", collection.GlobalProperties["p0"]);
-            Assert.Equal("v1", collection.GlobalProperties["p1"]);
+            project.GetPropertyValue("pp").ShouldBe("vv");
+            collection.GlobalProperties["p0"].ShouldBe("v0");
+            collection.GlobalProperties["p1"].ShouldBe("v1");
         }
 
         /// <summary>
@@ -1034,11 +1013,11 @@ public void ChangeGlobalPropertiesSameValue()
         {
             Project project = new Project();
             project.SetGlobalProperty("g", "v1");
-            Assert.True(project.IsDirty);
+            project.IsDirty.ShouldBeTrue();
             project.ReevaluateIfNecessary();
 
-            Assert.False(project.SetGlobalProperty("g", "v1"));
-            Assert.False(project.IsDirty);
+            project.SetGlobalProperty("g", "v1").ShouldBeFalse();
+            project.IsDirty.ShouldBeFalse();
         }
 
         /// <summary>
@@ -1053,14 +1032,14 @@ public void RemoveGlobalProperties()
             propertyElement.Condition = "'$(g)'==''";
             project.SetGlobalProperty("g", "v1");
             project.ReevaluateIfNecessary();
-            Assert.Equal(string.Empty, project.GetPropertyValue("p"));
+            project.GetPropertyValue("p").ShouldBe(string.Empty);
 
             bool existed = project.RemoveGlobalProperty("g");
-            Assert.True(existed);
-            Assert.True(project.IsDirty);
+            existed.ShouldBeTrue();
+            project.IsDirty.ShouldBeTrue();
             project.ReevaluateIfNecessary();
-            Assert.Equal("v0", project.GetPropertyValue("p"));
-            Assert.False(project.GlobalProperties.ContainsKey("g"));
+            project.GetPropertyValue("p").ShouldBe("v0");
+            project.GlobalProperties.ContainsKey("g").ShouldBeFalse();
         }
 
         /// <summary>
@@ -1072,8 +1051,8 @@ public void RemoveNonExistentGlobalProperties()
             Project project = new Project();
             bool existed = project.RemoveGlobalProperty("x");
 
-            Assert.False(existed);
-            Assert.False(project.IsDirty);
+            existed.ShouldBeFalse();
+            project.IsDirty.ShouldBeFalse();
         }
 
         /// <summary>
@@ -1094,7 +1073,7 @@ public void GetToolsVersionExplicitlySpecified()
                 new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase),
                 ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.ToolsVersion);
+            project.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         /// <summary>
@@ -1110,7 +1089,7 @@ public void GetToolsVersionNoneExplicitlySpecified()
 
             Project project = new Project(xml);
 
-            Assert.Equal(string.Empty, project.Xml.ToolsVersion);
+            project.Xml.ToolsVersion.ShouldBe(string.Empty);
 
             ObjectModelHelpers.DeleteTempProjectDirectory();
         }
@@ -1123,7 +1102,7 @@ public void GetToolsVersionFromProject()
         {
             Project project = new Project();
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.ToolsVersion);
+            project.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         /// <summary>
@@ -1147,12 +1126,12 @@ public void ProjectToolsVersion20Present()
             // to turn this behavior (new in Dev12) off, but it requires setting an environment variable and
             // clearing some internal state to make sure that the update environment variable is picked up, so
             // there's not a good way of doing it from these deliberately public OM only tests.
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.ToolsVersion);
+            project.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
             project.Xml.ToolsVersion = "4.0";
 
             // Still defaulting to the current ToolsVersion
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.ToolsVersion);
+            project.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         /// <summary>
@@ -1172,11 +1151,11 @@ public void ProjectToolsVersion20NotPresent()
             project.Xml.ToolsVersion = "2.0";
             project.ReevaluateIfNecessary();
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.ToolsVersion);
+            project.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
             project.Xml.ToolsVersion = ObjectModelHelpers.MSBuildDefaultToolsVersion;
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.ToolsVersion);
+            project.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         /// <summary>
@@ -1200,17 +1179,17 @@ public void MSBuildToolsVersionProperty()
             // to turn this behavior (new in Dev12) off, but it requires setting an environment variable and
             // clearing some internal state to make sure that the update environment variable is picked up, so
             // there's not a good way of doing it from these deliberately public OM only tests.
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.GetPropertyValue("msbuildtoolsversion"));
+            project.GetPropertyValue("msbuildtoolsversion").ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
             project.Xml.ToolsVersion = "4.0";
 
             // Still current
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.GetPropertyValue("msbuildtoolsversion"));
+            project.GetPropertyValue("msbuildtoolsversion").ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
             project.ReevaluateIfNecessary();
 
             // Still current
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.GetPropertyValue("msbuildtoolsversion"));
+            project.GetPropertyValue("msbuildtoolsversion").ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         /// <summary>
@@ -1222,7 +1201,7 @@ public void MSBuildToolsVersionProperty40()
         {
             Project project = new Project();
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.GetPropertyValue("msbuildtoolsversion"));
+            project.GetPropertyValue("msbuildtoolsversion").ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         /// <summary>
@@ -1237,7 +1216,7 @@ public void ChangingToolsVersionAttributeToUnrecognizedValue()
 
             project.Xml.ToolsVersion = "bogus";
 
-            Assert.Equal("bogus", project.Xml.ToolsVersion);
+            project.Xml.ToolsVersion.ShouldBe("bogus");
         }
 
         /// <summary>
@@ -1254,13 +1233,13 @@ public void GetSubToolsetVersion()
 
                 Project p = new Project(GetSampleProjectRootElement(), null, ObjectModelHelpers.MSBuildDefaultToolsVersion, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.ToolsVersion);
+                p.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
                 Toolset t = p.ProjectCollection.GetToolset(ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
-                Assert.Equal(t.DefaultSubToolsetVersion, p.SubToolsetVersion);
+                p.SubToolsetVersion.ShouldBe(t.DefaultSubToolsetVersion);
 
-                Assert.Equal(t.DefaultSubToolsetVersion ?? MSBuildConstants.CurrentVisualStudioVersion, p.GetPropertyValue("VisualStudioVersion"));
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe(t.DefaultSubToolsetVersion ?? MSBuildConstants.CurrentVisualStudioVersion);
             }
             finally
             {
@@ -1284,9 +1263,9 @@ public void GetSubToolsetVersion_FromEnvironment()
 
                 Project p = new Project(GetSampleProjectRootElement(), null, ObjectModelHelpers.MSBuildDefaultToolsVersion, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.ToolsVersion);
-                Assert.Equal("ABCD", p.SubToolsetVersion);
-                Assert.Equal("ABCD", p.GetPropertyValue("VisualStudioVersion"));
+                p.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCD");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCD");
             }
             finally
             {
@@ -1311,9 +1290,9 @@ public void GetSubToolsetVersion_FromProjectGlobalProperties()
 
                 Project p = new Project(GetSampleProjectRootElement(), globalProperties, ObjectModelHelpers.MSBuildDefaultToolsVersion, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.ToolsVersion);
-                Assert.Equal("ABCDE", p.SubToolsetVersion);
-                Assert.Equal("ABCDE", p.GetPropertyValue("VisualStudioVersion"));
+                p.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCDE");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCDE");
             }
             finally
             {
@@ -1342,9 +1321,9 @@ public void GetSubToolsetVersion_FromConstructor()
 
                 Project p = new Project(GetSampleProjectRootElement(), globalProperties, ObjectModelHelpers.MSBuildDefaultToolsVersion, "ABCDEF", new ProjectCollection(projectCollectionGlobalProperties), ProjectLoadSettings.Default);
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.ToolsVersion);
-                Assert.Equal("ABCDEF", p.SubToolsetVersion);
-                Assert.Equal("ABCDEF", p.GetPropertyValue("VisualStudioVersion"));
+                p.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCDEF");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCDEF");
             }
             finally
             {
@@ -1362,12 +1341,12 @@ public void LastEvaluationId()
             int last = project.LastEvaluationId;
 
             project.ReevaluateIfNecessary();
-            Assert.Equal(project.LastEvaluationId, last);
+            last.ShouldBe(project.LastEvaluationId);
             last = project.LastEvaluationId;
 
             project.SetProperty("p", "v");
             project.ReevaluateIfNecessary();
-            Assert.NotEqual(project.LastEvaluationId, last);
+            project.LastEvaluationId.ShouldNotBe(last);
         }
 
         /// <summary>
@@ -1389,7 +1368,7 @@ public void LastEvaluationIdAndUnload()
                 project.ProjectCollection.UnloadAllProjects();
 
                 project = new Project(path);
-                Assert.NotEqual(project.LastEvaluationId, last);
+                project.LastEvaluationId.ShouldNotBe(last);
             }
             finally
             {
@@ -1417,21 +1396,21 @@ public void ImportedXmlModified()
 
                 project.Xml.AddImport(path);
                 project.ReevaluateIfNecessary();
-                Assert.NotEqual(project.LastEvaluationId, last);
+                project.LastEvaluationId.ShouldNotBe(last);
                 last = project.LastEvaluationId;
 
                 project.ReevaluateIfNecessary();
-                Assert.Equal(project.LastEvaluationId, last);
+                last.ShouldBe(project.LastEvaluationId);
 
                 import.AddProperty("p", "v");
-                Assert.True(project.IsDirty);
+                project.IsDirty.ShouldBeTrue();
                 project.ReevaluateIfNecessary();
-                Assert.NotEqual(project.LastEvaluationId, last);
+                project.LastEvaluationId.ShouldNotBe(last);
                 last = project.LastEvaluationId;
-                Assert.Equal("v", project.GetPropertyValue("p"));
+                project.GetPropertyValue("p").ShouldBe("v");
 
                 project.ReevaluateIfNecessary();
-                Assert.Equal(project.LastEvaluationId, last);
+                last.ShouldBe(project.LastEvaluationId);
             }
             finally
             {
@@ -1474,13 +1453,12 @@ public void ImportingExistingPREObjectShouldPreserveTheObject()
 
                 // puts the import in the PRE cache
                 import.Save(importFile);
-                Assert.False(import.HasUnsavedChanges);
+                import.HasUnsavedChanges.ShouldBeFalse();
 
                 Project project = new Project(projectCollection);
                 project.Xml.AddImport(importFile);
                 project.ReevaluateIfNecessary();
-
-                Assert.Same(import, project.Imports.First().ImportedProject);
+                project.Imports.First().ImportedProject.ShouldBeSameAs(import);
             }
         }
 
@@ -1519,10 +1497,10 @@ public void ReloadedImportsMarkProjectAsDirty()
 
             Action<string, string, string, Project> assertContents = (p, i, m, project) =>
             {
-                Assert.Equal(p, project.GetPropertyValue("P"));
-                Assert.Single(project.GetItems("I"));
-                Assert.Equal(i, project.GetItems("I").First().EvaluatedInclude);
-                Assert.Equal(m, project.GetItems("I").First().GetMetadataValue("M"));
+                project.GetPropertyValue("P").ShouldBe(p);
+                project.GetItems("I").ShouldHaveSingleItem();
+                project.GetItems("I").First().EvaluatedInclude.ShouldBe(i);
+                project.GetItems("I").First().GetMetadataValue("M").ShouldBe(m);
             };
 
             using (var env = TestEnvironment.Create())
@@ -1539,23 +1517,23 @@ public void ReloadedImportsMarkProjectAsDirty()
 
                 // add to cache by saving
                 import.Save(importFile);
-                Assert.False(import.HasUnsavedChanges);
+                import.HasUnsavedChanges.ShouldBeFalse();
 
                 var project = new Project(projectCollection);
                 project.Xml.AddImport(importFile);
                 project.ReevaluateIfNecessary();
 
                 assertContents("p1", "i1", "m1", project);
-                Assert.False(project.IsDirty);
+                project.IsDirty.ShouldBeFalse();
 
                 import.ReloadFrom(XmlReader.Create(new StringReader(changedImportContents)));
-                Assert.True(import.HasUnsavedChanges);
+                import.HasUnsavedChanges.ShouldBeTrue();
 
-                Assert.True(project.IsDirty);
+                project.IsDirty.ShouldBeTrue();
                 assertContents("p1", "i1", "m1", project);
 
                 project.ReevaluateIfNecessary();
-                Assert.False(project.IsDirty);
+                project.IsDirty.ShouldBeFalse();
                 assertContents("p2", "i2", "m2", project);
 
                 var newProject = new Project(projectCollection);
@@ -1563,8 +1541,8 @@ public void ReloadedImportsMarkProjectAsDirty()
                 newProject.ReevaluateIfNecessary();
                 assertContents("p2", "i2", "m2", newProject);
 
-                Assert.Same(import, project.Imports.First().ImportedProject);
-                Assert.Same(import, newProject.Imports.First().ImportedProject);
+                project.Imports.First().ImportedProject.ShouldBeSameAs(import);
+                newProject.Imports.First().ImportedProject.ShouldBeSameAs(import);
             }
         }
 
@@ -1603,10 +1581,10 @@ public void ReloadedProjectRootElementMarksProjectAsDirty()
 
             Action<string, string, string, Project> assertContents = (p, i, m, project) =>
             {
-                Assert.Equal(p, project.GetPropertyValue("P"));
-                Assert.Single(project.GetItems("I"));
-                Assert.Equal(i, project.GetItems("I").First().EvaluatedInclude);
-                Assert.Equal(m, project.GetItems("I").First().GetMetadataValue("M"));
+                project.GetPropertyValue("P").ShouldBe(p);
+                project.GetItems("I").ShouldHaveSingleItem();
+                project.GetItems("I").First().EvaluatedInclude.ShouldBe(i);
+                project.GetItems("I").First().GetMetadataValue("M").ShouldBe(m);
             };
 
             using (var env = TestEnvironment.Create())
@@ -1623,22 +1601,22 @@ public void ReloadedProjectRootElementMarksProjectAsDirty()
 
                 // add to cache by saving
                 projectRootElement.Save(projectFile);
-                Assert.False(projectRootElement.HasUnsavedChanges);
+                projectRootElement.HasUnsavedChanges.ShouldBeFalse();
 
                 var project = new Project(projectRootElement, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion, projectCollection);
                 project.ReevaluateIfNecessary();
 
                 assertContents("p1", "i1", "m1", project);
-                Assert.False(project.IsDirty);
+                project.IsDirty.ShouldBeFalse();
 
                 projectRootElement.ReloadFrom(XmlReader.Create(new StringReader(changedProjectContents)));
-                Assert.True(projectRootElement.HasUnsavedChanges);
+                projectRootElement.HasUnsavedChanges.ShouldBeTrue();
 
-                Assert.True(project.IsDirty);
+                project.IsDirty.ShouldBeTrue();
                 assertContents("p1", "i1", "m1", project);
 
                 project.ReevaluateIfNecessary();
-                Assert.False(project.IsDirty);
+                project.IsDirty.ShouldBeFalse();
                 assertContents("p2", "i2", "m2", project);
             }
         }
@@ -1654,21 +1632,21 @@ public void ExternallyMarkDirty()
             project.SetProperty("p", "v");
             project.ReevaluateIfNecessary();
 
-            Assert.False(project.IsDirty);
+            project.IsDirty.ShouldBeFalse();
 
             ProjectProperty property1 = project.GetProperty("p");
 
             project.MarkDirty();
 
-            Assert.True(project.IsDirty);
+            project.IsDirty.ShouldBeTrue();
 
             project.ReevaluateIfNecessary();
 
-            Assert.False(project.IsDirty);
+            project.IsDirty.ShouldBeFalse();
 
             ProjectProperty property2 = project.GetProperty("p");
 
-            Assert.False(object.ReferenceEquals(property1, property2)); // different object indicates reevaluation occurred
+            object.ReferenceEquals(property1, property2).ShouldBeFalse(); // different object indicates reevaluation occurred
         }
 
         /// <summary>
@@ -1687,10 +1665,10 @@ public void ItemsByEvaluatedInclude()
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i1"));
 
-            Assert.Equal(3, items.Count);
+            items.Count.ShouldBe(3);
             foreach (ProjectItem item in items)
             {
-                Assert.Equal("i1", item.EvaluatedInclude);
+                item.EvaluatedInclude.ShouldBe("i1");
             }
         }
 
@@ -1710,13 +1688,12 @@ public void ItemsByEvaluatedInclude_EvaluatedIncludeNeedsEscaping()
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i&1"));
 
-            Assert.Equal(2, items.Count);
+            items.Count.ShouldBe(2);
             foreach (ProjectItem item in items)
             {
-                Assert.Equal("i&1", item.EvaluatedInclude);
-                Assert.True(
-                    string.Equals(item.ItemType, "i", StringComparison.OrdinalIgnoreCase)
-                    || string.Equals(item.ItemType, "l", StringComparison.OrdinalIgnoreCase));
+                item.EvaluatedInclude.ShouldBe("i&1");
+                (string.Equals(item.ItemType, "i", StringComparison.OrdinalIgnoreCase)
+                 || string.Equals(item.ItemType, "l", StringComparison.OrdinalIgnoreCase)).ShouldBeTrue();
             }
         }
 
@@ -1733,7 +1710,7 @@ public void ItemsByEvaluatedIncludeNone()
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i2"));
 
-            Assert.Empty(items);
+            items.ShouldBeEmpty();
         }
 
         /// <summary>
@@ -1762,12 +1739,12 @@ public void ItemsByEvaluatedIncludeAndExpansion()
                 projectConstruction.AddItem("foo", Path.Combine(testFileRoot, "*.foo"));
 
                 count = Helpers.Count(projectConstruction.Items);
-                Assert.Equal(1, count); // "Construction Model"
+                count.ShouldBe(1); // "Construction Model"
 
                 Project project = new Project(projectConstruction);
 
                 count = Helpers.Count(project.GetItems("foo"));
-                Assert.Equal(2, count); // "Evaluation Model, Before Removal"
+                count.ShouldBe(2); // "Evaluation Model, Before Removal"
 
                 ProjectItem itemToRemove = null;
 
@@ -1780,15 +1757,15 @@ public void ItemsByEvaluatedIncludeAndExpansion()
 
                 project.RemoveItem(itemToRemove);
                 count = Helpers.Count(project.GetItems("foo"));
-                Assert.Equal(1, count); // "Evaluation Model, After Removal"
+                count.ShouldBe(1); // "Evaluation Model, After Removal"
 
                 ProjectInstance projectInstance = project.CreateProjectInstance();
                 count = Helpers.Count(projectInstance.Items);
-                Assert.Equal(1, count); // "Instance Model"
+                count.ShouldBe(1); // "Instance Model"
 
                 // Ensure XML has been updated accordingly on the Evaluation model (projectInstance doesn't back onto XML)
-                Assert.DoesNotContain(itemToRemove.Xml.Include, project.Xml.RawXml);
-                Assert.DoesNotContain("*.foo", project.Xml.RawXml);
+                project.Xml.RawXml.ShouldNotContain(itemToRemove.Xml.Include);
+                project.Xml.RawXml.ShouldNotContain("*.foo");
             }
             finally
             {
@@ -1812,13 +1789,13 @@ public void ItemsByEvaluatedIncludeReevaluation()
             project.ReevaluateIfNecessary();
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i1"));
-            Assert.Single(items);
+            items.ShouldHaveSingleItem();
 
             project.Xml.AddItem("j", "i1");
             project.ReevaluateIfNecessary();
 
             items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i1"));
-            Assert.Equal(2, items.Count);
+            items.Count.ShouldBe(2);
         }
 
         /// <summary>
@@ -1832,7 +1809,7 @@ public void ItemsByEvaluatedIncludeDirectAdd()
             project.AddItem("i", "i1");
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i1"));
-            Assert.Single(items);
+            items.ShouldHaveSingleItem();
         }
 
         /// <summary>
@@ -1847,7 +1824,7 @@ public void ItemsByEvaluatedIncludeDirectRemove()
             project.RemoveItem(item1);
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i1"));
-            Assert.Empty(items);
+            items.ShouldBeEmpty();
         }
 
         /// <summary>
@@ -1873,8 +1850,8 @@ public void ChooseWhenTrue()
 
             Project project = new Project(XmlReader.Create(new StringReader(content)));
 
-            Assert.Equal("v1", project.GetPropertyValue("p"));
-            Assert.Equal("i1", Helpers.MakeList(project.GetItems("i"))[0].EvaluatedInclude);
+            project.GetPropertyValue("p").ShouldBe("v1");
+            Helpers.MakeList(project.GetItems("i"))[0].EvaluatedInclude.ShouldBe("i1");
         }
 
         /// <summary>
@@ -1908,8 +1885,8 @@ public void ChooseSecondWhenTrue()
 
             Project project = new Project(XmlReader.Create(new StringReader(content)));
 
-            Assert.Equal("v2", project.GetPropertyValue("p"));
-            Assert.Equal("i2", Helpers.MakeList(project.GetItems("i"))[0].EvaluatedInclude);
+            project.GetPropertyValue("p").ShouldBe("v2");
+            Helpers.MakeList(project.GetItems("i"))[0].EvaluatedInclude.ShouldBe("i2");
         }
 
         /// <summary>
@@ -1943,8 +1920,8 @@ public void ChooseOtherwise()
 
             Project project = new Project(XmlReader.Create(new StringReader(content)));
 
-            Assert.Equal("v2", project.GetPropertyValue("p"));
-            Assert.Equal("i2", Helpers.MakeList(project.GetItems("i"))[0].EvaluatedInclude);
+            project.GetPropertyValue("p").ShouldBe("v2");
+            Helpers.MakeList(project.GetItems("i"))[0].EvaluatedInclude.ShouldBe("i2");
         }
 
         /// <summary>
@@ -1991,12 +1968,12 @@ public void ChooseTwoPasses()
 
             Project project = new Project(XmlReader.Create(new StringReader(content)));
 
-            Assert.Equal("@(i);v1", project.GetPropertyValue("p"));
-            Assert.Equal("@(j);v1", project.GetPropertyValue("q"));
-            Assert.Equal("v1_v2", project.GetItems("i").ElementAt(0).EvaluatedInclude);
-            Assert.Single(project.GetItems("i"));
-            Assert.Equal("v1_v2", project.GetItems("j").ElementAt(0).EvaluatedInclude);
-            Assert.Single(project.GetItems("j"));
+            project.GetPropertyValue("p").ShouldBe("@(i);v1");
+            project.GetPropertyValue("q").ShouldBe("@(j);v1");
+            project.GetItems("i").ElementAt(0).EvaluatedInclude.ShouldBe("v1_v2");
+            project.GetItems("i").ShouldHaveSingleItem();
+            project.GetItems("j").ElementAt(0).EvaluatedInclude.ShouldBe("v1_v2");
+            project.GetItems("j").ShouldHaveSingleItem();
         }
 
         /// <summary>
@@ -2024,7 +2001,7 @@ public void ChooseEvaluateConditionOnlyOnce()
 
             Project project = new Project(XmlReader.Create(new StringReader(content)));
 
-            Assert.Empty(project.GetItems("i"));
+            project.GetItems("i").ShouldBeEmpty();
         }
 
         /// <summary>
@@ -2056,7 +2033,7 @@ public void ChooseSeesItemDefinitions()
 
             Project project = new Project(XmlReader.Create(new StringReader(content)));
 
-            Assert.Equal("m0;m1", project.GetItems("i").ElementAt(0).GetMetadataValue("m"));
+            project.GetItems("i").ElementAt(0).GetMetadataValue("m").ShouldBe("m0;m1");
         }
 
         /// <summary>
@@ -2073,9 +2050,9 @@ public void BuildDisabled()
 
             bool result = project.Build();
 
-            Assert.False(result);
+            result.ShouldBeFalse();
 
-            Assert.Equal("MSB4112", mockLogger.Errors[0].Code); //                 "Security message about disabled targets need to have code MSB4112, because code in the VS Core project system depends on this.  See DesignTimeBuildFeedback.cpp."
+            mockLogger.Errors[0].Code.ShouldBe("MSB4112"); //                 "Security message about disabled targets need to have code MSB4112, because code in the VS Core project system depends on this.  See DesignTimeBuildFeedback.cpp."
         }
 
         /// <summary>
@@ -2088,8 +2065,8 @@ public void BuildNonExistentTarget()
             Project project = new Project();
             MockLogger logger = new MockLogger();
             bool result = project.Build(new string[] { "nonexistent" }, new List<ILogger>() { logger });
-            Assert.False(result);
-            Assert.Equal(1, logger.ErrorCount);
+            result.ShouldBeFalse();
+            logger.ErrorCount.ShouldBe(1);
         }
 
         /// <summary>
@@ -2139,11 +2116,11 @@ public void BuildEvaluationUsesCustomLoggers()
                 project.ProjectCollection.UnregisterAllLoggers();
             }
 
-            Assert.True(result);
+            result.ShouldBeTrue();
 
-            Assert.Equal(0, mockLogger.WarningCount); //                 "Log should not contain MSB4011 because the build logger will not receive evaluation messages."
+            mockLogger.WarningCount.ShouldBe(0); //                 "Log should not contain MSB4011 because the build logger will not receive evaluation messages."
 
-            Assert.Equal("MSB4011", collectionLogger.Warnings[0].Code); //                 "Log should contain MSB4011 because the project collection logger should have been used for evaluation."
+            collectionLogger.Warnings[0].Code.ShouldBe("MSB4011"); //                 "Log should contain MSB4011 because the project collection logger should have been used for evaluation."
         }
 
         /// <summary>
@@ -2153,7 +2130,7 @@ public void BuildEvaluationUsesCustomLoggers()
         [Fact]
         public void UsingTaskExpansion1()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 ProjectRootElement xml = ProjectRootElement.Create();
                 xml.AddUsingTask("x", "@(x->'%(x)')", null);
@@ -2168,7 +2145,7 @@ public void UsingTaskExpansion1()
         [Fact]
         public void UsingTaskExpansion2()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 ProjectRootElement xml = ProjectRootElement.Create();
                 xml.AddUsingTask("@(x->'%(x)')", "y", null);
@@ -2183,7 +2160,7 @@ public void UsingTaskExpansion2()
         [Fact]
         public void UsingTaskExpansion3()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 ProjectRootElement xml = ProjectRootElement.Create();
                 xml.AddUsingTask("x", null, "@(x->'%(x)')");
@@ -2201,8 +2178,8 @@ public void SavingProjectClearsDirtyBit()
             string contents = ObjectModelHelpers.CleanupFileContents(@"<Project xmlns='msbuildnamespace'/>");
             Project project = new Project(XmlReader.Create(new StringReader(contents)));
 
-            Assert.True(project.Xml.HasUnsavedChanges); // Not dirty for saving
-            Assert.False(project.IsDirty); // "1" // was evaluated on load
+            project.Xml.HasUnsavedChanges.ShouldBeTrue(); // Not dirty for saving
+            project.IsDirty.ShouldBeFalse(); // "1" // was evaluated on load
 
             string file = null;
             try
@@ -2218,8 +2195,8 @@ public void SavingProjectClearsDirtyBit()
                 }
             }
 
-            Assert.False(project.Xml.HasUnsavedChanges); // Not dirty for saving
-            Assert.True(project.IsDirty); // "2" // Dirty for reevaluation, because the project now has gotten a new file name
+            project.Xml.HasUnsavedChanges.ShouldBeFalse(); // Not dirty for saving
+            project.IsDirty.ShouldBeTrue(); // "2" // Dirty for reevaluation, because the project now has gotten a new file name
         }
 
         /// <summary>
@@ -2240,7 +2217,7 @@ public void RemoveItemTwiceEvaluationProject()
             project.RemoveItem(itemToRemove);
             project.RemoveItem(itemToRemove); // should not throw
 
-            Assert.Empty(Helpers.MakeList(project.Items));
+            Helpers.MakeList(project.Items).ShouldBeEmpty();
         }
 
         /// <summary>
@@ -2261,7 +2238,7 @@ public void RemoveItemOutdatedByUpdate()
             itemToRemove.UnevaluatedInclude = "b.cs";
             project.RemoveItem(itemToRemove); // should not throw
 
-            Assert.Empty(Helpers.MakeList(project.Items));
+            Helpers.MakeList(project.Items).ShouldBeEmpty();
         }
 
         /// <summary>
@@ -2282,7 +2259,7 @@ public void RemoveSeveralItems()
 
             project.RemoveItems(project.GetItems("i"));
 
-            Assert.Empty(project.Items);
+            project.Items.ShouldBeEmpty();
         }
 
         /// <summary>
@@ -2307,7 +2284,7 @@ public void RemoveSeveralItemsOfVariousTypes()
 
             project.RemoveItems(list);
 
-            Assert.Equal(2, project.Items.Count());
+            project.Items.Count().ShouldBe(2);
         }
 
         /// <summary>
@@ -2327,7 +2304,7 @@ public void RemoveSeveralItemsExpandExpression()
             Project project = new Project(XmlReader.Create(new StringReader(projectOriginalContents)));
 
             project.RemoveItems(project.GetItems("j").Take(2));
-            Assert.Equal(3, project.Items.Count());
+            project.Items.Count().ShouldBe(3);
 
             StringWriter writer = new EncodingStringWriter();
             project.Save(writer);
@@ -2362,7 +2339,7 @@ public void RemoveSeveralItemsFirstZombiesSecond()
 
             project.RemoveItems(project.GetItems("i"));
 
-            Assert.Empty(project.Items);
+            project.Items.ShouldBeEmpty();
         }
 
         /// <summary>
@@ -2371,7 +2348,7 @@ public void RemoveSeveralItemsFirstZombiesSecond()
         [Fact]
         public void RemoveItemsOneNull()
         {
-            Assert.Throws<ArgumentNullException>(() =>
+            Should.Throw<ArgumentNullException>(() =>
             {
                 Project project = new Project();
                 project.RemoveItems(new List<ProjectItem>() { null });
@@ -2385,7 +2362,7 @@ public void RemoveItemsOneNull()
         [Fact]
         public void RemoveItemWrongProject()
         {
-            Assert.Throws<ArgumentException>(() =>
+            Should.Throw<ArgumentException>(() =>
             {
                 ProjectRootElement root1 = ProjectRootElement.Create();
                 root1.AddItem("i", "i1");
@@ -2418,7 +2395,7 @@ public void RemoveZombiedItem()
             project.RemoveItems(new List<ProjectItem>() { item });
             project.RemoveItems(new List<ProjectItem>() { item });
 
-            Assert.Empty(project.Items);
+            project.Items.ShouldBeEmpty();
         }
 
         /// <summary>
@@ -2427,7 +2404,7 @@ public void RemoveZombiedItem()
         [Fact]
         public void ReservedPropertyProjectConstructor()
         {
-            Assert.Throws<ArgumentException>(() =>
+            Should.Throw<ArgumentException>(() =>
             {
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 globalProperties.Add("msbuildprojectdirectory", "x");
@@ -2442,7 +2419,7 @@ public void ReservedPropertyProjectConstructor()
         [Fact]
         public void ReservedPropertyProjectCollectionConstructor()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 globalProperties.Add("msbuildprojectdirectory", "x");
@@ -2467,7 +2444,7 @@ public void ReservedPropertyProjectCollectionConstructor()
         [Fact]
         public void ReservedPropertyProjectCollectionConstructor2()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 globalProperties.Add("Target", "x");
@@ -2523,8 +2500,8 @@ public void RelativePathsInItemsInTargetsFilesAreRelativeToProjectFile()
                 Project project = new Project(projectPath);
 
                 IEnumerable<ProjectItem> items = project.GetItems("i");
-                Assert.Equal(unevaluatedInclude, Helpers.GetFirst(items).UnevaluatedInclude);
-                Assert.Equal(evaluatedInclude, Helpers.GetFirst(items).EvaluatedInclude);
+                Helpers.GetFirst(items).UnevaluatedInclude.ShouldBe(unevaluatedInclude);
+                Helpers.GetFirst(items).EvaluatedInclude.ShouldBe(evaluatedInclude);
             }
             finally
             {
@@ -2538,7 +2515,7 @@ public void RelativePathsInItemsInTargetsFilesAreRelativeToProjectFile()
         [Fact]
         public void ReservedPropertyProjectCollectionConstructor3()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 globalProperties.Add("Target", "x");
@@ -2588,15 +2565,15 @@ public void VariousImports()
 
             List<ProjectElement> logicalProject = new List<ProjectElement>(project.GetLogicalProject());
 
-            Assert.Equal(8, logicalProject.Count); // 4 properties + 4 property groups
-            Assert.True(object.ReferenceEquals(zero, logicalProject[0].ContainingProject));
-            Assert.True(object.ReferenceEquals(zero, logicalProject[1].ContainingProject));
-            Assert.True(object.ReferenceEquals(one, logicalProject[2].ContainingProject));
-            Assert.True(object.ReferenceEquals(one, logicalProject[3].ContainingProject));
-            Assert.True(object.ReferenceEquals(three, logicalProject[4].ContainingProject));
-            Assert.True(object.ReferenceEquals(three, logicalProject[5].ContainingProject));
-            Assert.True(object.ReferenceEquals(two, logicalProject[6].ContainingProject));
-            Assert.True(object.ReferenceEquals(two, logicalProject[7].ContainingProject));
+            logicalProject.Count.ShouldBe(8); // 4 properties + 4 property groups
+            object.ReferenceEquals(zero, logicalProject[0].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(zero, logicalProject[1].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(one, logicalProject[2].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(one, logicalProject[3].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(three, logicalProject[4].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(three, logicalProject[5].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(two, logicalProject[6].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(two, logicalProject[7].ContainingProject).ShouldBeTrue();
 
             // Clear the cache
             project.ProjectCollection.UnloadAllProjects();
@@ -2634,13 +2611,13 @@ public void LogicalProjectWithWildcardImport()
 
                 List<ProjectElement> logicalProject = new List<ProjectElement>(project.GetLogicalProject());
 
-                Assert.Equal(6, logicalProject.Count); // 3 properties + 3 property groups
-                Assert.True(object.ReferenceEquals(zero, logicalProject[0].ContainingProject)); // PropertyGroup
-                Assert.True(object.ReferenceEquals(zero, logicalProject[1].ContainingProject)); // p = 0
-                Assert.True(object.ReferenceEquals(one, logicalProject[2].ContainingProject));  // PropertyGroup
-                Assert.True(object.ReferenceEquals(one, logicalProject[3].ContainingProject));  // p = 1
-                Assert.True(object.ReferenceEquals(two, logicalProject[4].ContainingProject));  // PropertyGroup
-                Assert.True(object.ReferenceEquals(two, logicalProject[5].ContainingProject));  // p = 2
+                logicalProject.Count.ShouldBe(6); // 3 properties + 3 property groups
+                object.ReferenceEquals(zero, logicalProject[0].ContainingProject).ShouldBeTrue(); // PropertyGroup
+                object.ReferenceEquals(zero, logicalProject[1].ContainingProject).ShouldBeTrue(); // p = 0
+                object.ReferenceEquals(one, logicalProject[2].ContainingProject).ShouldBeTrue();  // PropertyGroup
+                object.ReferenceEquals(one, logicalProject[3].ContainingProject).ShouldBeTrue();  // p = 1
+                object.ReferenceEquals(two, logicalProject[4].ContainingProject).ShouldBeTrue();  // PropertyGroup
+                object.ReferenceEquals(two, logicalProject[5].ContainingProject).ShouldBeTrue();  // p = 2
 
                 // Clear the cache
                 project.ProjectCollection.UnloadAllProjects();
@@ -2661,7 +2638,7 @@ public void LogicalProjectWithWildcardImport()
         [Fact]
         public void ImportPropertyEvaluatingToEmpty()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 string projectOriginalContents = ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
@@ -2707,7 +2684,7 @@ public void GetItemProvenanceShouldReturnNothingWhenCalledWithEmptyOrNullArgs()
         [Fact]
         public void ImportPropertyEvaluatingToInvalidPath()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 string projectOriginalContents = ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
@@ -3760,12 +3737,12 @@ public void GetAllGlobsShouldProduceGlobThatMatches(string itemContents, string[
 
             foreach (var matchingString in stringsThatShouldMatch)
             {
-                Assert.True(uberGlob.IsMatch(matchingString));
+                uberGlob.IsMatch(matchingString).ShouldBeTrue();
             }
 
             foreach (var nonMatchingString in stringsThatShouldNotMatch)
             {
-                Assert.False(uberGlob.IsMatch(nonMatchingString));
+                uberGlob.IsMatch(nonMatchingString).ShouldBeFalse();
             }
         }
 
@@ -3886,18 +3863,18 @@ public void ProjectInstanceShouldInitiallyHaveSameEvaluationIdAsTheProjectItCame
 
                 var projectInstance = project.CreateProjectInstance();
 
-                Assert.NotEqual(BuildEventContext.InvalidEvaluationId, initialEvaluationId);
-                Assert.Equal(initialEvaluationId, projectInstance.EvaluationId);
+                initialEvaluationId.ShouldNotBe(BuildEventContext.InvalidEvaluationId);
+                projectInstance.EvaluationId.ShouldBe(initialEvaluationId);
 
                 // trigger a new evaluation which increments the evaluation ID in the Project
                 project.AddItem("foo", "bar");
                 project.ReevaluateIfNecessary();
 
-                Assert.NotEqual(initialEvaluationId, project.LastEvaluationId);
-                Assert.Equal(initialEvaluationId, projectInstance.EvaluationId);
+                project.LastEvaluationId.ShouldNotBe(initialEvaluationId);
+                projectInstance.EvaluationId.ShouldBe(initialEvaluationId);
 
                 var newProjectInstance = project.CreateProjectInstance();
-                Assert.Equal(project.LastEvaluationId, newProjectInstance.EvaluationId);
+                newProjectInstance.EvaluationId.ShouldBe(project.LastEvaluationId);
             }
         }
 
@@ -3930,16 +3907,16 @@ public void ProjectImportedEventFalseCondition()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
+                    eventArgs.ShouldNotBeNull();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Null(eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBeNull();
 
-                    Assert.Equal(pre.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
 
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to false condition; ( \'$(Something)\' == \'nothing\' ) was evaluated as ( \'\' == \'nothing\' )."); 
                 }
@@ -3973,16 +3950,16 @@ public void ProjectImportedEventNoMatchingFiles()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
+                    eventArgs.ShouldNotBeNull();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Null(eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBeNull();
 
-                    Assert.Equal(pre.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
 
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to no matching files.");
                 }
@@ -4017,17 +3994,17 @@ public void ProjectImportedEventEmptyFile()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
-                    Assert.True(eventArgs.ImportIgnored);
+                    eventArgs.ShouldNotBeNull();
+                    eventArgs.ImportIgnored.ShouldBeTrue();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Equal(importFile.Path, eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBe(importFile.Path);
 
-                    Assert.Equal(pre.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
 
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to the file being empty.");
                 }
@@ -4064,23 +4041,63 @@ public void ProjectImportedEventInvalidFile()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
-                    Assert.True(eventArgs.ImportIgnored);
+                    eventArgs.ShouldNotBeNull();
+                    eventArgs.ImportIgnored.ShouldBeTrue();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Equal(importFile.Path, eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBe(importFile.Path);
 
-                    Assert.Equal(pre.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
 
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to the file being invalid.");
                 }
             }
         }
 
+        [Fact]
+        public void ProjectImportedEventInvalidFileWhenExpressionEvaluatesToEmpty()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                env.SetEnvironmentVariable("MSBUILDLOGIMPORTS", "1");
+
+                ProjectRootElement pre = ProjectRootElement.Create(env.CreateFile(".proj").Path);
+
+                var import = pre.AddImport("$(SomethingThatEvaluatesToEmpty)");
+
+                pre.Save();
+                pre.Reload();
+
+                using (ProjectCollection collection = new ProjectCollection())
+                {
+                    MockLogger logger = new MockLogger();
+                    collection.RegisterLogger(logger);
+
+                    Project unused = new Project(pre, null, null, collection, ProjectLoadSettings.IgnoreInvalidImports);
+
+                    ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
+
+                    eventArgs.ShouldNotBeNull();
+                    eventArgs.ImportIgnored.ShouldBeTrue();
+
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
+
+                    eventArgs.ImportedProjectFile.ShouldBe(string.Empty);
+
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
+
+                    eventArgs.LineNumber.ShouldBe(3);
+                    eventArgs.ColumnNumber.ShouldBe(3);
+
+                    logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to the expression evaluating to an empty string.");
+                }
+            }
+        }
+
         [Fact]
         public void ProjectImportedEventMissingFile()
         {
@@ -4107,17 +4124,17 @@ public void ProjectImportedEventMissingFile()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
-                    Assert.True(eventArgs.ImportIgnored);
+                    eventArgs.ShouldNotBeNull();
+                    eventArgs.ImportIgnored.ShouldBeTrue();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Equal(importPath, eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBe(importPath);
 
-                    Assert.Equal(pre.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
 
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to the file not existing.");
                 }
@@ -4150,17 +4167,17 @@ public void ProjectImportedEventMissingFileNoGlobMatch()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
-                    Assert.False(eventArgs.ImportIgnored);
+                    eventArgs.ShouldNotBeNull();
+                    eventArgs.ImportIgnored.ShouldBeFalse();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Null(eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBeNull();
 
-                    Assert.Equal(pre.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
 
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to no matching files.");
                 }
@@ -4198,17 +4215,17 @@ public void ProjectImportEvent()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
+                    eventArgs.ShouldNotBeNull();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Equal(pre1.FullPath, eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBe(pre1.FullPath);
 
-                    Assert.Equal(pre2.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre2.FullPath);
 
-                    Assert.False(eventArgs.ImportIgnored);
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.ImportIgnored.ShouldBeFalse();
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Importing project \"{pre1.FullPath}\" into project \"{pre2.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}).");
                 }
@@ -4244,14 +4261,14 @@ private static void AssertGlobResult(GlobResultList expected, string project, st
 
         private static void AssertGlobResultsEqual(GlobResultList expected, List<GlobResult> globs)
         {
-            Assert.Equal(expected.Count, globs.Count);
+            globs.Count.ShouldBe(expected.Count);
 
             for (var i = 0; i < expected.Count; i++)
             {
-                Assert.Equal(expected[i].Item1, globs[i].ItemElement.ItemType);
-                Assert.Equal(expected[i].Item2, globs[i].IncludeGlobs);
-                Assert.Equal(expected[i].Item3, globs[i].Excludes);
-                Assert.Equal(expected[i].Item4, globs[i].Removes);
+                globs[i].ItemElement.ItemType.ShouldBe(expected[i].Item1);
+                globs[i].IncludeGlobs.ShouldBe(expected[i].Item2);
+                globs[i].Excludes.ShouldBe(expected[i].Item3);
+                globs[i].Removes.ShouldBe(expected[i].Item4);
             }
         }
 
@@ -4291,17 +4308,17 @@ private static void GetProjectAndItemAtPosition(string project, string itemValue
 
         private static void AssertProvenanceResult(ProvenanceResultTupleList expected, List<ProvenanceResult> actual)
         {
-            Assert.Equal(expected.Count, actual.Count);
+            actual.Count.ShouldBe(expected.Count);
 
             for (var i = 0; i < expected.Count; i++)
             {
                 var expectedProvenance = expected[i];
                 var actualProvenance = actual[i];
 
-                Assert.Equal(expectedProvenance.Item1, actualProvenance.ItemElement.ItemType);
-                Assert.Equal(expectedProvenance.Item2, actualProvenance.Operation);
-                Assert.Equal(expectedProvenance.Item3, actualProvenance.Provenance);
-                Assert.Equal(expectedProvenance.Item4, actualProvenance.Occurrences);
+                actualProvenance.ItemElement.ItemType.ShouldBe(expectedProvenance.Item1);
+                actualProvenance.Operation.ShouldBe(expectedProvenance.Item2);
+                actualProvenance.Provenance.ShouldBe(expectedProvenance.Item3);
+                actualProvenance.Occurrences.ShouldBe(expectedProvenance.Item4);
             }
         }
 
@@ -4353,16 +4370,16 @@ private string GetSampleProjectContent()
         /// </summary>
         private void VerifyContentOfSampleProject(Project project)
         {
-            Assert.Equal("v2", project.GetProperty("p").UnevaluatedValue);
-            Assert.Equal("Xv2", project.GetProperty("p2").EvaluatedValue);
-            Assert.Equal("X$(p)", project.GetProperty("p2").UnevaluatedValue);
+            project.GetProperty("p").UnevaluatedValue.ShouldBe("v2");
+            project.GetProperty("p2").EvaluatedValue.ShouldBe("Xv2");
+            project.GetProperty("p2").UnevaluatedValue.ShouldBe("X$(p)");
 
             IList<ProjectItem> items = Helpers.MakeList(project.GetItems("i"));
-            Assert.Equal(3, items.Count);
-            Assert.Equal("i1", items[0].EvaluatedInclude);
-            Assert.Equal("v2X", items[1].EvaluatedInclude);
-            Assert.Equal("$(p)X;i3", items[1].UnevaluatedInclude);
-            Assert.Equal("i3", items[2].EvaluatedInclude);
+            items.Count.ShouldBe(3);
+            items[0].EvaluatedInclude.ShouldBe("i1");
+            items[1].EvaluatedInclude.ShouldBe("v2X");
+            items[1].UnevaluatedInclude.ShouldBe("$(p)X;i3");
+            items[2].EvaluatedInclude.ShouldBe("i3");
         }
     }
 }
diff --git a/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
index d032033dd27..dc1e3cfdc23 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
@@ -449,6 +449,48 @@ public void CreateProjectInstanceWithItemsContainingProjects()
             Assert.Equal(projAInstanceItem.MetadataCount, projAInstanceItem.MetadataNames.Count);
         }
 
+        /// <summary>
+        /// Constructs a new ProjectInstances from Project.
+        /// </summary>
+        [Fact]
+        public void CreateProjectInstanceFromProject()
+        {
+            const string CapturedMetadataName = "DefiningProjectFullPath";
+            var pc = new ProjectCollection();
+            var projA = ProjectRootElement.Create(pc);
+            var projB = ProjectRootElement.Create(pc);
+            projA.FullPath = Path.Combine(Path.GetTempPath(), "a.proj");
+            projB.FullPath = Path.Combine(Path.GetTempPath(), "b.proj");
+            projB.AddImport("a.proj");
+            projA.AddItem("Compile", "aItem.cs");
+            projB.AddItem("Compile", "bItem.cs");
+
+            var loadSettings = ProjectLoadSettings.RecordDuplicateButNotCircularImports
+                | ProjectLoadSettings.RejectCircularImports
+                | ProjectLoadSettings.IgnoreEmptyImports
+                | ProjectLoadSettings.IgnoreMissingImports
+                | ProjectLoadSettings.IgnoreInvalidImports;
+
+            var projBEval = new Project(projB, null, null, pc, loadSettings);
+            var projBInstance = new ProjectInstance(projBEval, ProjectInstanceSettings.ImmutableWithFastItemLookup);
+            var projBInstanceItem = projBInstance.GetItemsByItemTypeAndEvaluatedInclude("Compile", "bItem.cs").Single();
+            var projAInstanceItem = projBInstance.GetItemsByItemTypeAndEvaluatedInclude("Compile", "aItem.cs").Single();
+            Assert.Equal(projB.FullPath, projBInstanceItem.GetMetadataValue(CapturedMetadataName));
+            Assert.Equal(projA.FullPath, projAInstanceItem.GetMetadataValue(CapturedMetadataName));
+
+            // Although GetMetadataValue returns non-null, GetMetadata returns null...
+            Assert.Null(projAInstanceItem.GetMetadata(CapturedMetadataName));
+
+            // .. Just like built-in metadata does: (this segment just demonstrates similar functionality -- it's not meant to test built-in metadata)
+            Assert.NotNull(projAInstanceItem.GetMetadataValue("Identity"));
+            Assert.Null(projAInstanceItem.GetMetadata("Identity"));
+
+            Assert.True(projAInstanceItem.HasMetadata(CapturedMetadataName));
+            Assert.False(projAInstanceItem.Metadata.Any());
+            Assert.Contains(CapturedMetadataName, projAInstanceItem.MetadataNames);
+            Assert.Equal(projAInstanceItem.MetadataCount, projAInstanceItem.MetadataNames.Count);
+        }
+
         /// <summary>
         /// Verifies that the built-in metadata for specialized ProjectInstances is present when items are based on wildcards in the construction model.
         /// </summary>
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
index 253ceac7972..324dcb6eb3f 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
@@ -187,7 +187,6 @@ public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnum
 
         public override string ExpandString(string unexpandedValue) => this.Proxy.ExpandString(unexpandedValue);
 
-// TODO: Glob is not needed for the CSproj, but we might want to test it at least 
         public override List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext)
         {
             throw new NotImplementedException();
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index 87c18c4b5b9..e6ac8089ea8 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -3,8 +3,12 @@
 
 using System;
 using System.Collections.Generic;
+using System.Configuration.Assemblies;
+using System.Globalization;
 using Microsoft.Build.BackEnd;
 using System.IO;
+using System.Reflection;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.BackEnd
@@ -431,6 +435,163 @@ public void TestSerializeDictionaryStringTNoComparerNull()
             Assert.Equal(value, deserializedValue);
         }
 
+        [Theory]
+        [InlineData("en")]
+        [InlineData("en-US")]
+        [InlineData("en-CA")]
+        [InlineData("zh-HK")]
+        [InlineData("sr-Cyrl-CS")]
+        public void CultureInfo(string name)
+        {
+            CultureInfo value = new CultureInfo(name);
+            TranslationHelpers.GetWriteTranslator().Translate(ref value);
+
+            CultureInfo deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);
+
+            deserializedValue.ShouldBe(value);
+        }
+
+        [Fact]
+        public void CultureInfoAsNull()
+        {
+            CultureInfo value = null;
+            TranslationHelpers.GetWriteTranslator().Translate(ref value);
+
+            CultureInfo deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);
+
+            deserializedValue.ShouldBeNull();
+        }
+
+        [Theory]
+        [InlineData("1.2")]
+        [InlineData("1.2.3")]
+        [InlineData("1.2.3.4")]
+        public void Version(string version)
+        {
+            Version value = new Version(version);
+            TranslationHelpers.GetWriteTranslator().Translate(ref value);
+
+            Version deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);
+
+            deserializedValue.ShouldBe(value);
+        }
+
+        [Fact]
+        public void VersionAsNull()
+        {
+            Version value = null;
+            TranslationHelpers.GetWriteTranslator().Translate(ref value);
+
+            Version deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);
+
+            deserializedValue.ShouldBeNull();
+        }
+
+        [Fact]
+        public void HashSetOfT()
+        {
+            HashSet<BaseClass> values = new()
+            {
+                new BaseClass(1),
+                new BaseClass(2),
+                null
+            };
+            TranslationHelpers.GetWriteTranslator().TranslateHashSet(ref values, BaseClass.FactoryForDeserialization, capacity => new());
+
+            HashSet<BaseClass> deserializedValues = null;
+            TranslationHelpers.GetReadTranslator().TranslateHashSet(ref deserializedValues, BaseClass.FactoryForDeserialization, capacity => new());
+
+            deserializedValues.ShouldBe(values, ignoreOrder: true);
+        }
+
+        [Fact]
+        public void HashSetOfTAsNull()
+        {
+            HashSet<BaseClass> value = null;
+            TranslationHelpers.GetWriteTranslator().TranslateHashSet(ref value, BaseClass.FactoryForDeserialization, capacity => new());
+
+            HashSet<BaseClass> deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateHashSet(ref deserializedValue, BaseClass.FactoryForDeserialization, capacity => new());
+
+            deserializedValue.ShouldBeNull();
+        }
+
+        [Fact]
+        public void AssemblyNameAsNull()
+        {
+            AssemblyName value = null;
+            TranslationHelpers.GetWriteTranslator().Translate(ref value);
+
+            AssemblyName deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);
+
+            deserializedValue.ShouldBeNull();
+        }
+
+        [Fact]
+        public void AssemblyNameWithAllFields()
+        {
+            AssemblyName value = new()
+            {
+                Name = "a",
+                Version = new Version(1, 2, 3),
+                Flags = AssemblyNameFlags.PublicKey,
+                ProcessorArchitecture = ProcessorArchitecture.X86,
+                CultureInfo = new CultureInfo("zh-HK"),
+                HashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA256,
+                VersionCompatibility = AssemblyVersionCompatibility.SameMachine,
+                CodeBase = "C:\\src",
+                KeyPair = new StrongNameKeyPair(new byte[] { 4, 3, 2, 1 }),
+                ContentType = AssemblyContentType.WindowsRuntime,
+                CultureName = "zh-HK",
+            };
+            value.SetPublicKey(new byte[]{ 3, 2, 1});
+            value.SetPublicKeyToken(new byte[] { 8, 7, 6, 5, 4, 3, 2, 1 });
+
+            TranslationHelpers.GetWriteTranslator().Translate(ref value);
+
+            AssemblyName deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);
+
+            HelperAssertAssemblyNameEqual(value, deserializedValue);
+        }
+
+        [Fact]
+        public void AssemblyNameWithMinimalFields()
+        {
+            AssemblyName value = new();
+
+            TranslationHelpers.GetWriteTranslator().Translate(ref value);
+
+            AssemblyName deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().Translate(ref deserializedValue);
+
+            HelperAssertAssemblyNameEqual(value, deserializedValue);
+        }
+
+        /// <summary>
+        /// Assert two AssemblyName objects values are same.
+        /// Ignoring KeyPair, ContentType, CultureName as those are not serialized
+        /// </summary>
+        private static void HelperAssertAssemblyNameEqual(AssemblyName expected, AssemblyName actual)
+        {
+            actual.Name.ShouldBe(expected.Name);
+            actual.Version.ShouldBe(expected.Version);
+            actual.Flags.ShouldBe(expected.Flags);
+            actual.ProcessorArchitecture.ShouldBe(expected.ProcessorArchitecture);
+            actual.CultureInfo.ShouldBe(expected.CultureInfo);
+            actual.HashAlgorithm.ShouldBe(expected.HashAlgorithm);
+            actual.VersionCompatibility.ShouldBe(expected.VersionCompatibility);
+            actual.CodeBase.ShouldBe(expected.CodeBase);
+
+            actual.GetPublicKey().ShouldBe(expected.GetPublicKey());
+            actual.GetPublicKeyToken().ShouldBe(expected.GetPublicKeyToken());
+        }
+
         /// <summary>
         /// Helper for bool serialization.
         /// </summary>
@@ -610,6 +771,24 @@ protected BaseClass()
             {
             }
 
+            protected bool Equals(BaseClass other)
+            {
+                return _baseValue == other._baseValue;
+            }
+
+            public override bool Equals(object obj)
+            {
+                if (ReferenceEquals(null, obj)) return false;
+                if (ReferenceEquals(this, obj)) return true;
+                if (obj.GetType() != this.GetType()) return false;
+                return Equals((BaseClass) obj);
+            }
+
+            public override int GetHashCode()
+            {
+                return _baseValue;
+            }
+
             /// <summary>
             /// Gets a comparer.
             /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
index 185e828aae6..bd2e1172fe5 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
@@ -74,6 +74,8 @@ public MockRequestBuilder()
 
             public event BuildRequestBlockedDelegate OnBuildRequestBlocked;
 
+            public event ResourceRequestDelegate OnResourceRequest;
+
             public void BuildRequest(NodeLoggingContext context, BuildRequestEntry entry)
             {
                 Assert.Null(_builderThread); // "Received BuildRequest while one was in progress"
@@ -171,6 +173,11 @@ public void RaiseRequestBlocked(BuildRequestEntry entry, int blockingId, string
                 OnBuildRequestBlocked?.Invoke(entry, blockingId, blockingTarget, null);
             }
 
+            public void RaiseResourceRequest(ResourceRequest request)
+            {
+                OnResourceRequest?.Invoke(request);
+            }
+
             public void ContinueRequest()
             {
                 if (ThrowExceptionOnContinue)
@@ -180,6 +187,10 @@ public void ContinueRequest()
                 _continueEvent.Set();
             }
 
+            public void ContinueRequestWithResources(ResourceResponse response)
+            {
+            }
+
             public void CancelRequest()
             {
                 this.BeginCancel();
@@ -256,6 +267,9 @@ private ProjectInstance CreateStandinProject()
         private AutoResetEvent _engineExceptionEvent;
         private Exception _engineException_Exception;
 
+        private AutoResetEvent _engineResourceRequestEvent;
+        private ResourceRequest _engineResourceRequest_Request;
+
         private IBuildRequestEngine _engine;
         private IConfigCache _cache;
         private int _nodeRequestId;
@@ -272,6 +286,7 @@ public BuildRequestEngine_Tests()
             _newRequestEvent = new AutoResetEvent(false);
             _newConfigurationEvent = new AutoResetEvent(false);
             _engineExceptionEvent = new AutoResetEvent(false);
+            _engineResourceRequestEvent = new AutoResetEvent(false);
 
             _engine = (IBuildRequestEngine)_host.GetComponent(BuildComponentType.RequestEngine);
             _cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
@@ -293,6 +308,7 @@ public void Dispose()
             _newRequestEvent.Dispose();
             _newConfigurationEvent.Dispose();
             _engineExceptionEvent.Dispose();
+            _engineResourceRequestEvent.Dispose();
 
             _host = null;
         }
@@ -305,6 +321,7 @@ private void ConfigureEngine(IBuildRequestEngine engine)
             engine.OnRequestResumed += this.Engine_RequestResumed;
             engine.OnStatusChanged += this.Engine_EngineStatusChanged;
             engine.OnEngineException += this.Engine_Exception;
+            engine.OnResourceRequest += this.Engine_ResourceRequest;
         }
 
         /// <summary>
@@ -579,5 +596,15 @@ private void Engine_Exception(Exception e)
             _engineException_Exception = e;
             _engineExceptionEvent.Set();
         }
+
+        /// <summary>
+        /// Callback for event raised when resources are requested.
+        /// </summary>
+        /// <param name="request">The resource request</param>
+        private void Engine_ResourceRequest(ResourceRequest request)
+        {
+            _engineResourceRequest_Request = request;
+            _engineResourceRequestEvent.Set();
+        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/CustomLogAndReturnTask.cs b/src/Build.UnitTests/BackEnd/CustomLogAndReturnTask.cs
new file mode 100644
index 00000000000..e6f05dff154
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/CustomLogAndReturnTask.cs
@@ -0,0 +1,39 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+namespace Microsoft.Build.UnitTests
+{
+    public class CustomLogAndReturnTask : Task
+    {
+        public string WarningCode { get; set; }
+
+        public string ErrorCode { get; set; }
+
+        public bool ReturnHasLoggedErrors { get; set; }
+
+        [Required]
+        public bool Return { get; set; }
+
+        // Unused for now, created for task batching.
+        public ITaskItem[] Sources { get; set; }
+
+        /// <summary>
+        /// This task returns and logs what you want based on the running test.
+        /// </summary>
+        public override bool Execute()
+        {
+            if(!string.IsNullOrEmpty(WarningCode))
+            {
+                Log.LogWarning(null, WarningCode, null, null, 0, 0, 0, 0, "Warning Logged!", null);
+            }
+
+            if(!string.IsNullOrEmpty(ErrorCode))
+            {
+                Log.LogError(null, ErrorCode, null, null, 0, 0, 0, 0, "Error Logged!", null);
+            }
+            return ReturnHasLoggedErrors ? !Log.HasLoggedErrors : Return;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs b/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
index 3798326b7e2..8dc2e82dbdd 100644
--- a/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
@@ -68,6 +68,7 @@ public void ConsumeEventsGoodEventsNoHandlers()
             eventHelper.RaiseBuildEvent(RaiseEventHelper.NormalMessage);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.TaskFinished);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.CommandLine);
+            eventHelper.RaiseBuildEvent(RaiseEventHelper.TaskParameter);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.Warning);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.Error);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.TargetStarted);
@@ -99,6 +100,7 @@ public void LoggerExceptionInEventHandler()
                 RaiseExceptionInEventHandler(RaiseEventHelper.NormalMessage, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.TaskFinished, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.CommandLine, exception);
+                RaiseExceptionInEventHandler(RaiseEventHelper.TaskParameter, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.Warning, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.Error, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.TargetStarted, exception);
@@ -733,6 +735,11 @@ internal class RaiseEventHelper
             /// </summary>
             private static TaskCommandLineEventArgs s_taskCommandLine = new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low);
 
+            /// <summary>
+            /// Task Parameter Event
+            /// </summary>
+            private static TaskParameterEventArgs s_taskParameter = new TaskParameterEventArgs(TaskParameterMessageKind.TaskInput, "ItemName", null, true, DateTime.MinValue);
+
             /// <summary>
             /// Build Warning Event
             /// </summary>
@@ -883,6 +890,11 @@ internal static TaskCommandLineEventArgs CommandLine
                 }
             }
 
+            /// <summary>
+            /// Event which can be raised in multiple tests.
+            /// </summary>
+            internal static TaskParameterEventArgs TaskParameter => s_taskParameter;
+
             /// <summary>
             /// Event which can be raised in multiple tests.
             /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
index 0914d530708..a52b53f97f5 100644
--- a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
@@ -1989,7 +1989,7 @@ public void KeepWithItemReferenceOnNonmatchingMetadata()
         }
 
         [Fact]
-        public void FailWithMatchingMultipleMetadata()
+        public void RemoveWithMatchingMultipleMetadata()
         {
             string content = ObjectModelHelpers.CleanupFileContents(
                 @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
@@ -2010,12 +2010,16 @@ public void FailWithMatchingMultipleMetadata()
                     </Target></Project>");
             IntrinsicTask task = CreateIntrinsicTask(content);
             Lookup lookup = LookupHelpers.CreateEmptyLookup();
-            Assert.ThrowsAny<InvalidProjectFileException>(() => ExecuteTask(task, lookup))
-                .HelpKeyword.ShouldBe("MSBuild.OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem");
+            ExecuteTask(task, lookup);
+            ICollection<ProjectItemInstance> items = lookup.GetItems("I2");
+            items.Count().ShouldBe(3);
+            items.ElementAt(0).EvaluatedInclude.ShouldBe("a2");
+            items.ElementAt(1).EvaluatedInclude.ShouldBe("c2");
+            items.ElementAt(2).EvaluatedInclude.ShouldBe("d2");
         }
 
         [Fact]
-        public void FailWithMultipleItemReferenceOnMatchingMetadata()
+        public void RemoveWithMultipleItemReferenceOnMatchingMetadata()
         {
             string content = ObjectModelHelpers.CleanupFileContents(
                 @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
@@ -2041,8 +2045,9 @@ public void FailWithMultipleItemReferenceOnMatchingMetadata()
                     </Target></Project>");
             IntrinsicTask task = CreateIntrinsicTask(content);
             Lookup lookup = LookupHelpers.CreateEmptyLookup();
-            Assert.ThrowsAny<InvalidProjectFileException>(() => ExecuteTask(task, lookup))
-                .HelpKeyword.ShouldBe("MSBuild.OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem");
+            ExecuteTask(task, lookup);
+            ICollection<ProjectItemInstance> items = lookup.GetItems("I3");
+            items.ShouldBeEmpty();
         }
 
         [Fact]
@@ -2068,7 +2073,7 @@ public void FailWithMetadataItemReferenceOnMatchingMetadata()
             IntrinsicTask task = CreateIntrinsicTask(content);
             Lookup lookup = LookupHelpers.CreateEmptyLookup();
             Assert.ThrowsAny<InvalidProjectFileException>(() => ExecuteTask(task, lookup))
-                .HelpKeyword.ShouldBe("MSBuild.OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem");
+                .HelpKeyword.ShouldBe("MSBuild.OM_MatchOnMetadataIsRestrictedToReferencedItems");
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index 8c7c480a220..5409a6f3822 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -557,6 +557,16 @@ public bool HasBuildSubmissionLoggedErrors(int submissionId)
             return false;
         }
 
+        public ICollection<string> GetWarningsAsErrors(BuildEventContext context)
+        {
+            throw new NotImplementedException();
+        }
+
+        public ICollection<string> GetWarningsAsMessages(BuildEventContext context)
+        {
+            throw new NotImplementedException();
+        }
+
         #endregion
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 459d835bd25..3e860fc7d5f 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
@@ -44,6 +45,7 @@ public void VerifyEventType()
             TaskStartedEventArgs taskStarted = new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName");
             TaskFinishedEventArgs taskFinished = new TaskFinishedEventArgs("message", "help", "projectFile", "taskFile", "taskName", true);
             TaskCommandLineEventArgs commandLine = new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low);
+            TaskParameterEventArgs taskParameter = CreateTaskParameter();
             BuildWarningEventArgs warning = new BuildWarningEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
             BuildErrorEventArgs error = new BuildErrorEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
             TargetStartedEventArgs targetStarted = new TargetStartedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile");
@@ -58,6 +60,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(taskStarted, LoggingEventType.TaskStartedEvent);
             VerifyLoggingPacket(taskFinished, LoggingEventType.TaskFinishedEvent);
             VerifyLoggingPacket(commandLine, LoggingEventType.TaskCommandLineEvent);
+            VerifyLoggingPacket(taskParameter, LoggingEventType.TaskParameterEvent);
             VerifyLoggingPacket(warning, LoggingEventType.BuildWarningEvent);
             VerifyLoggingPacket(error, LoggingEventType.BuildErrorEvent);
             VerifyLoggingPacket(targetStarted, LoggingEventType.TargetStartedEvent);
@@ -67,12 +70,41 @@ public void VerifyEventType()
             VerifyLoggingPacket(externalStartedEvent, LoggingEventType.CustomEvent);
         }
 
+        private static TaskParameterEventArgs CreateTaskParameter()
+        {
+            var items = new TaskItemData[]
+            {
+                new TaskItemData("ItemSpec1", null),
+                new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
+            };
+            var result = new TaskParameterEventArgs(
+                TaskParameterMessageKind.TaskInput,
+                "ItemName",
+                items,
+                logItemMetadata: true,
+                DateTime.MinValue);
+
+            // normalize line endings as we can't rely on the line endings of NodePackets_Tests.cs
+            Assert.Equal(@"Task Parameter:
+    ItemName=
+        ItemSpec1
+        ItemSpec2
+                1=1value
+                2=2value
+                3=3value".Replace("\r\n", "\n"), result.Message);
+
+            return result;
+        }
+
         /// <summary>
         /// Tests serialization of LogMessagePacket with each kind of event type.
         /// </summary>
         [Fact]
         public void TestTranslation()
         {
+            // need to touch the type so that the static constructor runs
+            _ = ItemGroupLoggingHelper.OutputItemParameterMessagePrefix;
+
             TaskItem item = new TaskItem("Hello", "my.proj");
             List<TaskItem> targetOutputs = new List<TaskItem>();
             targetOutputs.Add(item);
@@ -88,6 +120,7 @@ public void TestTranslation()
                     new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName"),
                     new TaskFinishedEventArgs("message", "help", "projectFile", "taskFile", "taskName", true),
                     new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low),
+                    CreateTaskParameter(),
                     new BuildWarningEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender"),
                     new BuildErrorEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender"),
                     new TargetStartedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile"),
@@ -281,6 +314,19 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftCommand.TaskName, rightCommand.TaskName);
                     break;
 
+                case LoggingEventType.TaskParameterEvent:
+                    var leftTaskParameter = left.NodeBuildEvent.Value.Value as TaskParameterEventArgs;
+                    var rightTaskParameter = right.NodeBuildEvent.Value.Value as TaskParameterEventArgs;
+                    Assert.NotNull(leftTaskParameter);
+                    Assert.NotNull(rightTaskParameter);
+                    Assert.Equal(leftTaskParameter.Kind, rightTaskParameter.Kind);
+                    Assert.Equal(leftTaskParameter.ItemType, rightTaskParameter.ItemType);
+                    Assert.Equal(leftTaskParameter.Items.Count, rightTaskParameter.Items.Count);
+                    Assert.Equal(leftTaskParameter.Message, rightTaskParameter.Message);
+                    Assert.Equal(leftTaskParameter.BuildEventContext, rightTaskParameter.BuildEventContext);
+                    Assert.Equal(leftTaskParameter.Timestamp, rightTaskParameter.Timestamp);
+                    break;
+
                 case LoggingEventType.TaskFinishedEvent:
                     TaskFinishedEventArgs leftTaskFinished = left.NodeBuildEvent.Value.Value as TaskFinishedEventArgs;
                     TaskFinishedEventArgs rightTaskFinished = right.NodeBuildEvent.Value.Value as TaskFinishedEventArgs;
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index 9d8db26b192..fe416e2e901 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -1417,6 +1417,21 @@ void IRequestBuilderCallback.ExitMSBuildCallbackState()
         {
         }
 
+        /// <summary>
+        /// Empty impl
+        /// </summary>
+        int IRequestBuilderCallback.RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)
+        {
+            return 0;
+        }
+
+        /// <summary>
+        /// Empty impl
+        /// </summary>
+        void IRequestBuilderCallback.ReleaseCores(int coresToRelease)
+        {
+        }
+
         #endregion
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index 54c1888e2dd..faa5e75e688 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -978,6 +978,21 @@ void IRequestBuilderCallback.ExitMSBuildCallbackState()
         {
         }
 
+        /// <summary>
+        /// Empty impl
+        /// </summary>
+        int IRequestBuilderCallback.RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)
+        {
+            return 0;
+        }
+
+        /// <summary>
+        /// Empty impl
+        /// </summary>
+        void IRequestBuilderCallback.ReleaseCores(int coresToRelease)
+        {
+        }
+
         #endregion
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index ed6ff1db561..6e1556b5712 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -755,6 +755,21 @@ void IRequestBuilderCallback.ExitMSBuildCallbackState()
         {
         }
 
+        /// <summary>
+        /// Empty impl
+        /// </summary>
+        int IRequestBuilderCallback.RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)
+        {
+            return 0;
+        }
+
+        /// <summary>
+        /// Empty impl
+        /// </summary>
+        void IRequestBuilderCallback.ReleaseCores(int coresToRelease)
+        {
+        }
+
         #endregion
 
         #region IRequestBuilderCallback Members
diff --git a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
index 62a6e1a3d56..144f30bea1a 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Threading;
 
 
@@ -12,7 +13,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
-
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.BackEnd
@@ -36,22 +37,28 @@ public void ConstructorWithNullName()
             Assert.Throws<InternalErrorException>(() =>
             {
                 TaskHostConfiguration config = new TaskHostConfiguration(
-                    1,
-                    Directory.GetCurrentDirectory(),
-                    null,
-                    Thread.CurrentThread.CurrentCulture,
-                    Thread.CurrentThread.CurrentUICulture,
+                    nodeId: 1,
+                    startupDirectory: Directory.GetCurrentDirectory(),
+                    buildProcessEnvironment: null,
+                    culture: Thread.CurrentThread.CurrentCulture,
+                    uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                    appDomainSetup:
 #if FEATURE_APPDOMAIN
                     null,
+#endif
+                    lineNumberOfTask:
 #endif
                     1,
-                    1,
-                    @"c:\my project\myproj.proj",
-                    _continueOnErrorDefault,
-                    null,
-                    @"c:\my tasks\mytask.dll",
-                    null,
-                    null);
+                    columnNumberOfTask: 1,
+                    projectFileOfTask: @"c:\my project\myproj.proj",
+                    continueOnError: _continueOnErrorDefault,
+                    taskName: null,
+                    taskLocation: @"c:\my tasks\mytask.dll",
+                    taskParameters: null,
+                    globalParameters: null,
+                    warningsAsErrors: null,
+                    warningsAsMessages: null);
             }
            );
         }
@@ -64,22 +71,28 @@ public void ConstructorWithEmptyName()
             Assert.Throws<InternalErrorException>(() =>
             {
                 TaskHostConfiguration config = new TaskHostConfiguration(
-                    1,
-                    Directory.GetCurrentDirectory(),
-                    null,
-                    Thread.CurrentThread.CurrentCulture,
-                    Thread.CurrentThread.CurrentUICulture,
+                    nodeId: 1,
+                    startupDirectory: Directory.GetCurrentDirectory(),
+                    buildProcessEnvironment: null,
+                    culture: Thread.CurrentThread.CurrentCulture,
+                    uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                    appDomainSetup:
 #if FEATURE_APPDOMAIN
                     null,
+#endif
+                    lineNumberOfTask:
 #endif
                     1,
-                    1,
-                    @"c:\my project\myproj.proj",
-                    _continueOnErrorDefault,
-                    String.Empty,
-                    @"c:\my tasks\mytask.dll",
-                    null,
-                    null);
+                    columnNumberOfTask: 1,
+                    projectFileOfTask: @"c:\my project\myproj.proj",
+                    continueOnError: _continueOnErrorDefault,
+                    taskName: String.Empty,
+                    taskLocation: @"c:\my tasks\mytask.dll",
+                    taskParameters: null,
+                    globalParameters: null,
+                    warningsAsErrors: null,
+                    warningsAsMessages: null);
             }
            );
         }
@@ -92,22 +105,28 @@ public void ConstructorWithNullLocation()
             Assert.Throws<InternalErrorException>(() =>
             {
                 TaskHostConfiguration config = new TaskHostConfiguration(
-                    1,
-                    Directory.GetCurrentDirectory(),
-                    null,
-                    Thread.CurrentThread.CurrentCulture,
-                    Thread.CurrentThread.CurrentUICulture,
+                    nodeId: 1,
+                    startupDirectory: Directory.GetCurrentDirectory(),
+                    buildProcessEnvironment: null,
+                    culture: Thread.CurrentThread.CurrentCulture,
+                    uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                    appDomainSetup:
 #if FEATURE_APPDOMAIN
                     null,
+#endif
+                    lineNumberOfTask:
 #endif
                     1,
-                    1,
-                    @"c:\my project\myproj.proj",
-                    _continueOnErrorDefault,
-                    "TaskName",
-                    null,
-                    null,
-                    null);
+                    columnNumberOfTask: 1,
+                    projectFileOfTask: @"c:\my project\myproj.proj",
+                    continueOnError: _continueOnErrorDefault,
+                    taskName: "TaskName",
+                    taskLocation: null,
+                    taskParameters: null,
+                    globalParameters: null,
+                    warningsAsErrors: null,
+                    warningsAsMessages: null);
             }
            );
         }
@@ -122,22 +141,28 @@ public void ConstructorWithEmptyLocation()
             Assert.Throws<InternalErrorException>(() =>
             {
                 TaskHostConfiguration config = new TaskHostConfiguration(
-                    1,
-                    Directory.GetCurrentDirectory(),
-                    null,
-                    Thread.CurrentThread.CurrentCulture,
-                    Thread.CurrentThread.CurrentUICulture,
+                    nodeId: 1,
+                    startupDirectory: Directory.GetCurrentDirectory(),
+                    buildProcessEnvironment: null,
+                    culture: Thread.CurrentThread.CurrentCulture,
+                    uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                    appDomainSetup:
 #if FEATURE_APPDOMAIN
                     null,
+#endif
+                    lineNumberOfTask:
 #endif
                     1,
-                    1,
-                    @"c:\my project\myproj.proj",
-                    _continueOnErrorDefault,
-                    "TaskName",
-                    String.Empty,
-                    null,
-                    null);
+                    columnNumberOfTask: 1,
+                    projectFileOfTask: @"c:\my project\myproj.proj",
+                    continueOnError: _continueOnErrorDefault,
+                    taskName: "TaskName",
+                    taskLocation: String.Empty,
+                    taskParameters: null,
+                    globalParameters: null,
+                    warningsAsErrors: null,
+                    warningsAsMessages: null);
             }
            );
         }
@@ -150,59 +175,77 @@ public void ConstructorWithEmptyLocation()
         public void TestValidConstructors()
         {
             TaskHostConfiguration config = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                null,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: null,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             TaskHostConfiguration config2 = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                null,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: null,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             TaskHostConfiguration config3 = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                parameters,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: parameters,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             IDictionary<string, object> parameters2 = new Dictionary<string, object>();
             parameters2.Add("Text", "Hello!");
@@ -211,22 +254,58 @@ public void TestValidConstructors()
             parameters2.Add("ItemArray", new ITaskItem[] { new TaskItem("DEF"), new TaskItem("GHI"), new TaskItem("JKL") });
 
             TaskHostConfiguration config4 = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: parameters2,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
+
+            HashSet<string> WarningsAsErrors = new HashSet<string>();
+            WarningsAsErrors.Add("MSB1234");
+            WarningsAsErrors.Add("MSB1235");
+            WarningsAsErrors.Add("MSB1236");
+            WarningsAsErrors.Add("MSB1237");
+
+            TaskHostConfiguration config5 = new TaskHostConfiguration(
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
+#if FEATURE_APPDOMAIN
+                null,
+#endif
+                lineNumberOfTask:
+#endif
                 1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                parameters2,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: parameters2,
+                globalParameters: null,
+                warningsAsErrors: WarningsAsErrors,
+                warningsAsMessages: null);
         }
 
         /// <summary>
@@ -242,22 +321,28 @@ public void TestTranslationWithNullDictionary()
             };
 
             TaskHostConfiguration config = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                null,
-                expectedGlobalProperties);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: null,
+                globalParameters: expectedGlobalProperties,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -280,22 +365,28 @@ public void TestTranslationWithNullDictionary()
         public void TestTranslationWithEmptyDictionary()
         {
             TaskHostConfiguration config = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                new Dictionary<string, object>(),
-                new Dictionary<string, string>());
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: new Dictionary<string, object>(),
+                globalParameters: new Dictionary<string, string>(),
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -323,22 +414,28 @@ public void TestTranslationWithValueTypesInDictionary()
             parameters.Add("Text", "Foo");
             parameters.Add("BoolValue", false);
             TaskHostConfiguration config = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                parameters,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: parameters,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -364,22 +461,28 @@ public void TestTranslationWithITaskItemInDictionary()
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemValue", new TaskItem("Foo"));
             TaskHostConfiguration config = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                parameters,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: parameters,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -404,22 +507,28 @@ public void TestTranslationWithITaskItemArrayInDictionary()
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemArrayValue", new ITaskItem[] { new TaskItem("Foo"), new TaskItem("Baz") });
             TaskHostConfiguration config = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                parameters,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: parameters,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -439,6 +548,99 @@ public void TestTranslationWithITaskItemArrayInDictionary()
             TaskHostPacketHelpers.AreEqual(itemArray, deserializedItemArray);
         }
 
+        /// <summary>
+        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array. 
+        /// </summary>
+        [Fact]
+        public void TestTranslationWithWarningsAsErrors()
+        {
+            HashSet<string> WarningsAsErrors = new HashSet<string>();
+            WarningsAsErrors.Add("MSB1234");
+            WarningsAsErrors.Add("MSB1235");
+            WarningsAsErrors.Add("MSB1236");
+            WarningsAsErrors.Add("MSB1237");
+            TaskHostConfiguration config = new TaskHostConfiguration(
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
+#if FEATURE_APPDOMAIN
+                null,
+#endif
+                lineNumberOfTask:
+#endif
+                1,
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: null,
+                globalParameters: null,
+                warningsAsErrors: WarningsAsErrors,
+                warningsAsMessages: null);
+
+            ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
+            INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            TaskHostConfiguration deserializedConfig = packet as TaskHostConfiguration;
+
+            Assert.Equal(config.TaskName, deserializedConfig.TaskName);
+#if !FEATURE_ASSEMBLYLOADCONTEXT
+            Assert.Equal(config.TaskLocation, deserializedConfig.TaskLocation);
+#endif
+            Assert.NotNull(deserializedConfig.WarningsAsErrors);
+            config.WarningsAsErrors.SequenceEqual(deserializedConfig.WarningsAsErrors, StringComparer.Ordinal).ShouldBeTrue();
+
+        }
+
+        /// <summary>
+        /// Test serialization / deserialization when the parameter dictionary contains warningsasmessages
+        /// </summary>
+        [Fact]
+        public void TestTranslationWithWarningsAsMessages()
+        {
+            HashSet<string> WarningsAsMessages = new HashSet<string>();
+            WarningsAsMessages.Add("MSB1234");
+            WarningsAsMessages.Add("MSB1235");
+            WarningsAsMessages.Add("MSB1236");
+            WarningsAsMessages.Add("MSB1237");
+            TaskHostConfiguration config = new TaskHostConfiguration(
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
+#if FEATURE_APPDOMAIN
+                null,
+#endif
+                lineNumberOfTask:
+#endif
+                1,
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: null,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: WarningsAsMessages);
+
+            ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
+            INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            TaskHostConfiguration deserializedConfig = packet as TaskHostConfiguration;
+
+            Assert.NotNull(deserializedConfig.WarningsAsMessages);
+            config.WarningsAsMessages.SequenceEqual(deserializedConfig.WarningsAsMessages, StringComparer.Ordinal).ShouldBeTrue();
+        }
+
         /// <summary>
         /// Helper methods for testing the task host-related packets. 
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
index 3996c7221e8..1db0b3935b2 100644
--- a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
@@ -15,6 +15,7 @@
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using System.Threading.Tasks;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -705,6 +706,90 @@ public void TasksGetNoGlobalPropertiesIfNoneSpecified()
             mockLogger.AssertLogContains("Global property count: 0");
         }
 
+        [Fact]
+        public void RequestCoresThrowsOnInvalidInput()
+        {
+            Assert.Throws<ArgumentOutOfRangeException>(() =>
+            {
+                _taskHost.RequestCores(0);
+            });
+
+            Assert.Throws<ArgumentOutOfRangeException>(() =>
+            {
+                _taskHost.RequestCores(-1);
+            });
+        }
+
+        [Fact]
+        public void RequestCoresUsesImplicitCore()
+        {
+            // If the request callback has no cores to grant, we still get 1 for the implicit core.
+            _mockRequestCallback.CoresToGrant = 0;
+            _taskHost.RequestCores(3).ShouldBe(1);
+            _mockRequestCallback.LastRequestedCores.ShouldBe(2);
+            _mockRequestCallback.LastWaitForCores.ShouldBeFalse();
+        }
+
+        [Fact]
+        public void RequestCoresUsesCoresFromRequestCallback()
+        {
+            // The request callback has 1 core to grant, we should see it returned from RequestCores.
+            _mockRequestCallback.CoresToGrant = 1;
+            _taskHost.RequestCores(3).ShouldBe(2);
+            _mockRequestCallback.LastRequestedCores.ShouldBe(2);
+            _mockRequestCallback.LastWaitForCores.ShouldBeFalse();
+
+            // Since we've used the implicit core, the second call will return only what the request callback gives us and may block.
+            _mockRequestCallback.CoresToGrant = 1;
+            _taskHost.RequestCores(3).ShouldBe(1);
+            _mockRequestCallback.LastRequestedCores.ShouldBe(3);
+            _mockRequestCallback.LastWaitForCores.ShouldBeTrue();
+        }
+
+        [Fact]
+        public void ReleaseCoresThrowsOnInvalidInput()
+        {
+            Assert.Throws<ArgumentOutOfRangeException>(() =>
+            {
+                _taskHost.ReleaseCores(0);
+            });
+
+            Assert.Throws<ArgumentOutOfRangeException>(() =>
+            {
+                _taskHost.ReleaseCores(-1);
+            });
+        }
+
+        [Fact]
+        public void ReleaseCoresReturnsCoresToRequestCallback()
+        {
+            _mockRequestCallback.CoresToGrant = 1;
+            _taskHost.RequestCores(3).ShouldBe(2);
+
+            // We return one of two granted cores, the call passes through to the request callback.
+            _taskHost.ReleaseCores(1);
+            _mockRequestCallback.LastCoresToRelease.ShouldBe(1);
+
+            // The implicit core is still allocated so a subsequent RequestCores call may block.
+            _taskHost.RequestCores(1);
+            _mockRequestCallback.LastWaitForCores.ShouldBeTrue();
+        }
+
+        [Fact]
+        public void ReleaseCoresReturnsImplicitCore()
+        {
+            _mockRequestCallback.CoresToGrant = 1;
+            _taskHost.RequestCores(3).ShouldBe(2);
+
+            // We return both granted cores, one of them is returned to the request callback.
+            _taskHost.ReleaseCores(2);
+            _mockRequestCallback.LastCoresToRelease.ShouldBe(1);
+
+            // The implicit core is not allocated anymore so a subsequent RequestCores call won't block.
+            _taskHost.RequestCores(1);
+            _mockRequestCallback.LastWaitForCores.ShouldBeFalse();
+        }
+
         #region Helper Classes
 
         /// <summary>
@@ -1221,6 +1306,26 @@ internal class MockIRequestBuilderCallback : IRequestBuilderCallback, IRequestBu
             /// </summary>
             private BuildResult[] _buildResultsToReturn;
 
+            /// <summary>
+            /// The requestedCores argument passed to the last RequestCores call.
+            /// </summary>
+            public int LastRequestedCores { get; private set; }
+
+            /// <summary>
+            /// The waitForCores argument passed to the last RequestCores call.
+            /// </summary>
+            public bool LastWaitForCores { get; private set; }
+
+            /// <summary>
+            /// The value to be returned from the RequestCores call.
+            /// </summary>
+            public int CoresToGrant { get; set; }
+
+            /// <summary>
+            /// The coresToRelease argument passed to the last ReleaseCores call.
+            /// </summary>
+            public int LastCoresToRelease { get; private set; }
+
             /// <summary>
             /// Constructor which takes an array of build results to return from the BuildProjects method when it is called.
             /// </summary>
@@ -1247,6 +1352,11 @@ internal MockIRequestBuilderCallback(BuildResult[] buildResultsToReturn)
             /// Not Implemented
             /// </summary>
             public event BuildRequestBlockedDelegate OnBuildRequestBlocked;
+
+            /// <summary>
+            /// Not Implemented
+            /// </summary>
+            public event ResourceRequestDelegate OnResourceRequest;
 #pragma warning restore
 
             /// <summary>
@@ -1294,6 +1404,24 @@ public void ExitMSBuildCallbackState()
             {
             }
 
+            /// <summary>
+            /// Mock
+            /// </summary>
+            public int RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)
+            {
+                LastRequestedCores = requestedCores;
+                LastWaitForCores = waitForCores;
+                return CoresToGrant;
+            }
+
+            /// <summary>
+            /// Mock
+            /// </summary>
+            public void ReleaseCores(int coresToRelease)
+            {
+                LastCoresToRelease = coresToRelease;
+            }
+
             /// <summary>
             /// Mock of the Block on target in progress.
             /// </summary>
@@ -1318,6 +1446,14 @@ public void ContinueRequest()
                 throw new NotImplementedException();
             }
 
+            /// <summary>
+            /// Not Implemented
+            /// </summary>
+            public void ContinueRequestWithResources(ResourceResponse response)
+            {
+                throw new NotImplementedException();
+            }
+
             /// <summary>
             /// Not Implemented
             /// </summary>
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index ec95009bec1..8deb4db94b7 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -7,7 +7,7 @@ namespace Microsoft.Build.UnitTests
 {
     public class BinaryLoggerTests : IDisposable
     {
-        private static string s_testProject = @"
+        private const string s_testProject = @"
          <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
             <PropertyGroup>
                <TestProperty>Test</TestProperty>
@@ -22,6 +22,38 @@ public class BinaryLoggerTests : IDisposable
                <Exec Command='echo a'/>
             </Target>
          </Project>";
+
+        private const string s_testProject2 = @"
+        <Project>
+            <ItemGroup>
+            <Compile Include=""0.cs"" />
+            </ItemGroup>
+            <ItemDefinitionGroup>
+            <Compile>
+                <MetadataFromItemDefinition>fromItemDefinition%61%62%63&lt;&gt;</MetadataFromItemDefinition>
+            </Compile>
+            </ItemDefinitionGroup>
+            <Target Name=""Build"" Outputs=""@(CombinedOutput)"">
+            <ItemGroup>
+                <Compile Include=""1.cs"">
+                <MetadataName>MetadataValue1%61%62%63&lt;&gt;</MetadataName>
+                </Compile>
+                <Compile Remove=""1.cs"" />
+                <Compile Include=""2.cs"" />
+                <Compile Include=""3.cs"">
+                <CustomMetadata>custom%61%62%63&lt;&gt;</CustomMetadata>
+                </Compile>
+            </ItemGroup>
+            <Message Importance=""High"" Condition=""$(Test) != true"" Text=""Hello"" />
+            <CombinePath BasePath=""base"" Paths=""@(Compile)"">
+                <Output TaskParameter=""CombinedPaths"" ItemName=""CombinedOutput""/>
+            </CombinePath>
+            <ItemGroup>
+                <Compile Remove=""2.cs"" />
+            </ItemGroup>
+            </Target>
+        </Project>";
+
         private readonly TestEnvironment _env;
         private string _logFile;
 
@@ -35,8 +67,10 @@ public BinaryLoggerTests(ITestOutputHelper output)
             _logFile = _env.ExpectFile(".binlog").Path;
         }
 
-        [Fact]
-        public void TestBinaryLoggerRoundtrip()
+        [Theory]
+        [InlineData(s_testProject)]
+        [InlineData(s_testProject2)]
+        public void TestBinaryLoggerRoundtrip(string projectText)
         {
             var binaryLogger = new BinaryLogger();
 
@@ -45,14 +79,14 @@ public void TestBinaryLoggerRoundtrip()
             var mockLogFromBuild = new MockLogger();
 
             // build and log into binary logger and mockLogger1
-            ObjectModelHelpers.BuildProjectExpectSuccess(s_testProject, binaryLogger, mockLogFromBuild);
+            ObjectModelHelpers.BuildProjectExpectSuccess(projectText, binaryLogger, mockLogFromBuild);
 
             var mockLogFromPlayback = new MockLogger();
 
             var binaryLogReader = new BinaryLogReplayEventSource();
             mockLogFromPlayback.Initialize(binaryLogReader);
 
-            // read the binary log and replay into mockLogger2testassembly
+            // read the binary log and replay into mockLogger2
             binaryLogReader.Replay(_logFile);
 
             // the binlog will have more information than recorded by the text log
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index afd56aea915..a2874d96c06 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -1,9 +1,10 @@
-﻿using System;
+using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
 using System.Text;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Logging;
@@ -70,21 +71,39 @@ public void RoundtripProjectStartedEventArgs()
                 toolsVersion: "Current");
             args.BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6);
 
-            Roundtrip(args,
+            Roundtrip<ProjectStartedEventArgs>(args,
                 e => ToString(e.BuildEventContext),
                 e => ToString(e.GlobalProperties),
-                e => ToString(e.Items.OfType<DictionaryEntry>().ToDictionary(d => d.Key.ToString(), d => ((ITaskItem)d.Value).ItemSpec)),
+                e => GetItemsString(e.Items),
                 e => e.Message,
                 e => ToString(e.ParentProjectBuildEventContext),
                 e => e.ProjectFile,
                 e => e.ProjectId.ToString(),
-                e => ToString(e.Properties.OfType<DictionaryEntry>().ToDictionary(d => d.Key.ToString(), d => d.Value.ToString())),
+                e => ToString(e.Properties.OfType<DictionaryEntry>().ToDictionary((Func<DictionaryEntry, string>)(d => d.Key.ToString()), (Func<DictionaryEntry, string>)(d => d.Value.ToString()))),
                 e => e.TargetNames,
                 e => e.ThreadId.ToString(),
                 e => e.Timestamp.ToString(),
                 e => e.ToolsVersion);
         }
 
+        private string GetItemsString(IEnumerable items)
+        {
+            return ToString(items.OfType<DictionaryEntry>().ToDictionary(d => d.Key.ToString(), d => GetTaskItemString((ITaskItem)d.Value)));
+        }
+
+        private string GetTaskItemString(ITaskItem taskItem)
+        {
+            var sb = new StringBuilder();
+            sb.Append(taskItem.ItemSpec);
+            foreach (string name in taskItem.MetadataNames)
+            {
+                var value = taskItem.GetMetadata(name);
+                sb.Append($";{name}={value}");
+            }
+
+            return sb.ToString();
+        }
+
         [Fact]
         public void RoundtripProjectFinishedEventArgs()
         {
@@ -309,6 +328,23 @@ public void RoundtripTaskCommandLineEventArgs()
                 e => e.Subcategory);
         }
 
+        [Fact]
+        public void RoundtripTaskParameterEventArgs()
+        {
+            var items = new TaskItemData[]
+            {
+                new TaskItemData("ItemSpec1", null),
+                new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
+            };
+            var args = new TaskParameterEventArgs(TaskParameterMessageKind.TaskOutput, "ItemName", items, true, DateTime.MinValue);
+
+            Roundtrip(args,
+                e => e.Kind.ToString(),
+                e => e.ItemType,
+                e => e.LogItemMetadata.ToString(),
+                e => GetItemsString(e.Items));
+        }
+
         [Fact]
         public void RoundtripProjectEvaluationStartedEventArgs()
         {
diff --git a/src/Build.UnitTests/ConfigureableForwardingLogger_Tests.cs b/src/Build.UnitTests/ConfigureableForwardingLogger_Tests.cs
index f584072937b..3698f90ed5d 100644
--- a/src/Build.UnitTests/ConfigureableForwardingLogger_Tests.cs
+++ b/src/Build.UnitTests/ConfigureableForwardingLogger_Tests.cs
@@ -1,6 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
@@ -20,6 +21,7 @@ public class ConfigureableForwardingLogger_Tests
         private readonly TaskStartedEventArgs _taskStarted = new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName");
         private readonly TaskFinishedEventArgs _taskFinished = new TaskFinishedEventArgs("message", "help", "projectFile", "taskFile", "taskName", true);
         private readonly TaskCommandLineEventArgs _commandLine = new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low);
+        private readonly TaskParameterEventArgs _taskParameter = new TaskParameterEventArgs(TaskParameterMessageKind.TaskInput, "ItemName", null, true, DateTime.MinValue);
         private readonly BuildWarningEventArgs _warning = new BuildWarningEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
         private readonly BuildErrorEventArgs _error = new BuildErrorEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
         private readonly TargetStartedEventArgs _targetStarted = new TargetStartedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile");
@@ -131,6 +133,7 @@ public void ForwardingLoggingEventsBasedOnVerbosity(LoggerVerbosity? loggerVerbo
                         _normalMessage,
                         _highMessage,
                         _commandLine,
+                        _taskParameter,
                         _warning,
                         _error,
                         _taskFinished,
@@ -150,6 +153,7 @@ public void ForwardingLoggingEventsBasedOnVerbosity(LoggerVerbosity? loggerVerbo
                         _normalMessage,
                         _highMessage,
                         _commandLine,
+                        _taskParameter,
                         _externalStartedEvent,
                         _warning,
                         _error,
@@ -266,6 +270,7 @@ private void RaiseEvents(EventSourceSink source)
             source.Consume(_normalMessage);
             source.Consume(_highMessage);
             source.Consume(_commandLine);
+            source.Consume(_taskParameter);
             source.Consume(_externalStartedEvent);
             source.Consume(_warning);
             source.Consume(_error);
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index ad133c08db8..38ee432877a 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -28,6 +28,7 @@
 using Xunit;
 using Xunit.Abstractions;
 using Shouldly;
+using Microsoft.Build.UnitTests.Shared;
 
 namespace Microsoft.Build.UnitTests.Construction
 {
@@ -749,6 +750,37 @@ public void SolutionConfigurationWithDependencies()
             Helpers.VerifyAssertLineByLine(expected, solutionConfigurationContents);
         }
 
+        /// <summary>
+        /// This test forces a metaproj to be generated as part of the build. Since metaproj files are not written to disk, it will fail if its cached form does not align
+        /// with the version that is being built as when a property is part of the version added to the cache, but that version is not passed to the BuildManager.
+        /// </summary>
+        [Fact]
+        public void SolutionGeneratingMetaproj()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile proj1 = env.CreateFile("A.csproj", @"<Project><Target Name=""Printer""><Message Importance=""high"" Text=""print string"" /></Target></Project>");
+                TransientTestFile proj2 = env.CreateFile("B.csproj", @"<Project><Target Name=""Printer""><Message Importance=""high"" Text=""print string"" /></Target></Project>");
+                TransientTestFile proj3 = env.CreateFile("C.csproj", @"<Project><Target Name=""Printer""><Message Importance=""high"" Text=""print string"" /></Target></Project>");
+                TransientTestFile proj = env.CreateFile("mysln.sln",
+                @$"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 11
+Project(`{"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"}`) = `A`, `{proj1.Path}`, `{"{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}"}`
+EndProject
+Project(`{"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"}`) = `B`, `{proj2.Path}`, `{"{881C1674-4ECA-451D-85B6-D7C59B7F16FA}"}`
+    ProjectSection(ProjectDependencies) = postProject
+        {"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"} = {"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"}
+    EndProjectSection
+EndProject
+Project(`{"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"}`) = `C`, `{proj3.Path}`, `{"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"}`
+EndProject
+".Replace("`", "\""));
+                RunnerUtilities.ExecMSBuild("\"" + proj.Path + "\"", out bool successfulExit);
+                successfulExit.ShouldBeTrue();
+            }
+        }
+
         /// <summary>
         /// Generated project metaproj should declare its outputs for relay.
         /// Here B depends on C (via solution dep only) and D (via ProjectReference only)
@@ -2477,6 +2509,30 @@ public void DirectorySolutionPropsTest(string projectName, bool enable)
             }
         }
 
+        /// <summary>
+        /// Regression test for https://github.com/dotnet/msbuild/issues/6236
+        /// </summary>
+        [Theory]
+        [InlineData("http://localhost:8080")]
+        [InlineData("a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-")]
+        public void AbsolutePathWorksForUnsupportedPaths(string relativePath)
+        {
+            string solutionFileContents =
+                $@"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 16
+VisualStudioVersion = 16.0.31025.194
+MinimumVisualStudioVersion = 10.0.40219.1
+Project(""{{E24C65DC-7377-472B-9ABA-BC803B73C61A}}"") = ""WebSite1"", ""{relativePath}"", ""{{{{96E0707C-2E9C-4704-946F-FA583147737F}}}}""
+EndProject";
+
+            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+
+            ProjectInSolution projectInSolution = solution.ProjectsInOrder.ShouldHaveSingleItem();
+
+            projectInSolution.AbsolutePath.ShouldBe(Path.Combine(solution.SolutionFileDirectory, projectInSolution.RelativePath));
+        }
+
         #region Helper Functions
 
         /// <summary>
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index b9329dad3ba..00dc1bb6f61 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -471,6 +471,14 @@ public void ContextDisambiguatesSameRelativeGlobsPointingOutsideDifferentProject
         [MemberData(nameof(ContextDisambiguatesRelativeGlobsData))]
         public void ContextDisambiguatesAFullyQualifiedGlobPointingInAnotherRelativeGlobsCone(EvaluationContext.SharingPolicy policy, string[][] expectedGlobExpansions)
         {
+            if (policy == EvaluationContext.SharingPolicy.Shared)
+            {
+                // This test case has a dependency on our glob expansion caching policy. If the evaluation context is reused
+                // between evaluations and files are added to the filesystem between evaluations, the cache may be returning
+                // stale results. Run only the Isolated variant.
+                return;
+            }
+
             var project1Directory = _env.DefaultTestDirectory.CreateDirectory("Project1");
             var project1GlobDirectory = project1Directory.CreateDirectory("Glob").CreateDirectory("1").Path;
 
diff --git a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
index db0593111e7..6babb127ce7 100644
--- a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
@@ -1,10 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#if FEATURE_SYSTEM_CONFIGURATION
-
 using System.Configuration;
-using Microsoft.Win32;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -683,4 +680,3 @@ private ToolsetConfigurationReader GetStandardConfigurationReader()
 
     }
 }
-#endif
diff --git a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
index 2e44a4239a9..c90b546da38 100644
--- a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
@@ -3,9 +3,7 @@
 
 using System;
 using System.Collections.Generic;
-#if FEATURE_SYSTEM_CONFIGURATION
 using System.Configuration;
-#endif
 using System.IO;
 
 using Microsoft.Build.Collections;
diff --git a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
index da2f1fc518e..bfcf5685dc2 100644
--- a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
@@ -1,10 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#if FEATURE_SYSTEM_CONFIGURATION
-
-using System.Configuration;
-using Microsoft.Win32;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
@@ -15,7 +11,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.UnitTests;
 
 namespace Microsoft.Build.UnitTests.Evaluation
 {
@@ -48,11 +43,13 @@ public void ImportFromExtensionsPathNotFound()
             string extnDir1 = null;
             string mainProjectPath = null;
 
-            try {
+            try
+            {
                 extnDir1 = GetNewExtensionsPathAndCreateFile("extensions1", Path.Combine("foo", "extn.proj"), GetExtensionTargetsFileContent1());
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
-                var projColln = new ProjectCollection();
+                var projColln = GetProjectCollection();
+
                 projColln.ResetToolsetsForTests(WriteConfigFileAndGetReader("MSBuildExtensionsPath", extnDir1, Path.Combine("tmp", "nonexistent")));
                 var logger = new MockLogger();
                 projColln.RegisterLogger(logger);
@@ -60,7 +57,9 @@ public void ImportFromExtensionsPathNotFound()
                 Assert.Throws<InvalidProjectFileException>(() => projColln.LoadProject(mainProjectPath));
 
                 logger.AssertLogContains("MSB4226");
-            } finally {
+            }
+            finally
+            {
                 if (mainProjectPath != null)
                 {
                     FileUtilities.DeleteNoThrow(mainProjectPath);
@@ -91,7 +90,7 @@ public void ConditionalImportFromExtensionsPathNotFound()
             string extnDir1 = GetNewExtensionsPathAndCreateFile("extensions1", Path.Combine("foo", "extn.proj"), extnTargetsFileContentWithCondition);
             string mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
-            CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath", new string[] {extnDir1, Path.Combine("tmp", "nonexistent")},
+            CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath", new string[] { extnDir1, Path.Combine("tmp", "nonexistent") },
                                                             null,
                                                             (p, l) => {
                                                                 Assert.True(p.Build());
@@ -128,7 +127,7 @@ public void ImportFromExtensionsPathCircularImportError()
                                                             String.Format(extnTargetsFileContent2, mainProjectPath));
 
             CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath",
-                                                        new string[] {extnDir2, Path.Combine("tmp", "nonexistent"), extnDir1},
+                                                        new string[] { extnDir2, Path.Combine("tmp", "nonexistent"), extnDir1 },
                                                         null,
                                                         (p, l) => l.AssertLogContains("MSB4210"));
         }
@@ -199,7 +198,7 @@ public void ImportFromExtensionsPathWithWildCard()
             string mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", mainTargetsFileContent);
 
             CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath",
-                new[] {extnDir1, Path.Combine("tmp", "nonexistent"), extnDir2},
+                new[] { extnDir1, Path.Combine("tmp", "nonexistent"), extnDir2 },
                 null,
                 (project, logger) =>
                 {
@@ -281,7 +280,7 @@ public void ImportFromExtensionsPathWithWildCardNothingFound()
             string extnDir1 = GetNewExtensionsPathAndCreateFile("extensions1", Path.Combine("foo", "extn.proj"), extnTargetsFileContent);
             string mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
-            CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath", new string[] {Path.Combine("tmp", "nonexistent"), extnDir1},
+            CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath", new string[] { Path.Combine("tmp", "nonexistent"), extnDir1 },
                                                     null, (p, l) => Assert.True(p.Build()));
         }
 
@@ -293,11 +292,12 @@ public void ImportFromExtensionsPathInvalidFile()
             string extnDir1 = null;
             string mainProjectPath = null;
 
-            try {
+            try
+            {
                 extnDir1 = GetNewExtensionsPathAndCreateFile("extensions1", Path.Combine("foo", "extn.proj"), extnTargetsFileContent);
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
-                var projColln = new ProjectCollection();
+                var projColln = GetProjectCollection();
                 projColln.ResetToolsetsForTests(WriteConfigFileAndGetReader("MSBuildExtensionsPath", extnDir1,
                                                                                 Path.Combine("tmp", "nonexistent")));
                 var logger = new MockLogger();
@@ -305,7 +305,9 @@ public void ImportFromExtensionsPathInvalidFile()
 
                 Assert.Throws<InvalidProjectFileException>(() => projColln.LoadProject(mainProjectPath));
                 logger.AssertLogContains("MSB4024");
-            } finally {
+            }
+            finally
+            {
                 if (mainProjectPath != null)
                 {
                     FileUtilities.DeleteNoThrow(mainProjectPath);
@@ -351,7 +353,7 @@ public void ImportFromExtensionsPathSearchOrder()
             string extnDir2 = GetNewExtensionsPathAndCreateFile("extensions2", Path.Combine("foo", "extn.proj"), extnTargetsFileContent2);
             string mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
-            CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath", new string[] {extnDir2, Path.Combine("tmp", "nonexistent"), extnDir1},
+            CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath", new string[] { extnDir2, Path.Combine("tmp", "nonexistent"), extnDir1 },
                                                             null,
                                                             (p, l) => {
                                                                 Assert.True(p.Build());
@@ -395,8 +397,9 @@ public void ImportFromExtensionsPathSearchOrder2()
             string mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
             // MSBuildExtensionsPath* property value has highest priority for the lookups
-            try {
-                var projColln = new ProjectCollection();
+            try
+            {
+                var projColln = GetProjectCollection();
                 projColln.ResetToolsetsForTests(WriteConfigFileAndGetReader("MSBuildExtensionsPath", Path.Combine("tmp", "non-existent"), extnDir1));
                 var logger = new MockLogger();
                 projColln.RegisterLogger(logger);
@@ -408,7 +411,9 @@ public void ImportFromExtensionsPathSearchOrder2()
 
                 logger.AssertLogContains("Running FromExtn");
                 logger.AssertLogContains("PropertyFromExtn1: FromSecondFile");
-            } finally {
+            }
+            finally
+            {
                 if (mainProjectPath != null)
                 {
                     FileUtilities.DeleteNoThrow(mainProjectPath);
@@ -472,7 +477,8 @@ public void ImportFromExtensionsPathAnd32And64()
             string extnDir1 = null, extnDir2 = null, extnDir3 = null;
             string mainProjectPath = null;
 
-            try {
+            try
+            {
                 extnDir1 = GetNewExtensionsPathAndCreateFile("extensions1", Path.Combine("foo", "extn.proj"),
                                 String.Format(extnTargetsFileContentTemplate, String.Empty, "FromExtn2", "<Import Project='$(MSBuildExtensionsPath32)\\bar\\extn2.proj' />"));
                 extnDir2 = GetNewExtensionsPathAndCreateFile("extensions2", Path.Combine("bar", "extn2.proj"),
@@ -483,9 +489,10 @@ public void ImportFromExtensionsPathAnd32And64()
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
                 ToolsetConfigurationReaderTestHelper.WriteConfigFile(String.Format(configFileContents, extnDir1, extnDir2, extnDir3));
+
                 var reader = GetStandardConfigurationReader();
+                var projColln = GetProjectCollection();
 
-                var projColln = new ProjectCollection();
                 projColln.ResetToolsetsForTests(reader);
                 var logger = new MockLogger();
                 projColln.RegisterLogger(logger);
@@ -495,7 +502,9 @@ public void ImportFromExtensionsPathAnd32And64()
                 logger.AssertLogContains("Running FromExtn3");
                 logger.AssertLogContains("Running FromExtn2");
                 logger.AssertLogContains("Running FromExtn");
-            } finally {
+            }
+            finally
+            {
                 if (mainProjectPath != null)
                 {
                     FileUtilities.DeleteNoThrow(mainProjectPath);
@@ -557,9 +566,9 @@ public void ExpandExtensionsPathFallback()
                     GetMainTargetFileContent());
 
                 ToolsetConfigurationReaderTestHelper.WriteConfigFile(configFileContents);
-                var reader = GetStandardConfigurationReader();
 
-                var projectCollection = new ProjectCollection(new Dictionary<string, string> {["FallbackExpandDir1"] = extnDir1});
+                var reader = GetStandardConfigurationReader();
+                var projectCollection = GetProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
 
                 projectCollection.ResetToolsetsForTests(reader);
                 var logger = new MockLogger();
@@ -618,9 +627,9 @@ public void ExpandExtensionsPathFallbackInErrorMessage()
                     GetMainTargetFileContent());
 
                 ToolsetConfigurationReaderTestHelper.WriteConfigFile(configFileContents);
-                var reader = GetStandardConfigurationReader();
 
-                var projectCollection = new ProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
+                var reader = GetStandardConfigurationReader();
+                var projectCollection = GetProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
 
                 projectCollection.ResetToolsetsForTests(reader);
                 var logger = new MockLogger();
@@ -688,9 +697,9 @@ public void FallbackImportWithIndirectReference()
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", mainTargetsFileContent);
 
                 ToolsetConfigurationReaderTestHelper.WriteConfigFile(configFileContents);
-                var reader = GetStandardConfigurationReader();
 
-                var projectCollection = new ProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
+                var reader = GetStandardConfigurationReader();
+                var projectCollection = GetProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
 
                 projectCollection.ResetToolsetsForTests(reader);
                 var logger = new MockLogger();
@@ -753,9 +762,9 @@ public void FallbackImportWithUndefinedProperty()
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", mainTargetsFileContent);
 
                 ToolsetConfigurationReaderTestHelper.WriteConfigFile(configFileContents);
-                var reader = GetStandardConfigurationReader();
 
-                var projectCollection = new ProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
+                var reader = GetStandardConfigurationReader();
+                var projectCollection = GetProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
 
                 projectCollection.ResetToolsetsForTests(reader);
                 var logger = new MockLogger();
@@ -812,9 +821,9 @@ public void FallbackImportWithFileNotFoundWhenPropertyNotDefined()
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", mainTargetsFileContent);
 
                 ToolsetConfigurationReaderTestHelper.WriteConfigFile(configFileContents);
-                var reader = GetStandardConfigurationReader();
 
-                var projectCollection = new ProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
+                var reader = GetStandardConfigurationReader();
+                var projectCollection = GetProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
 
                 projectCollection.ResetToolsetsForTests(reader);
                 var logger = new MockLogger();
@@ -834,7 +843,8 @@ public void FallbackImportWithFileNotFoundWhenPropertyNotDefined()
         void CreateAndBuildProjectForImportFromExtensionsPath(string extnPathPropertyName, Action<Project, MockLogger> action)
         {
             string extnDir1 = null, extnDir2 = null, mainProjectPath = null;
-            try {
+            try
+            {
                 extnDir1 = GetNewExtensionsPathAndCreateFile("extensions1", Path.Combine("foo", "extn.proj"),
                                     GetExtensionTargetsFileContent1(extnPathPropertyName));
                 extnDir2 = GetNewExtensionsPathAndCreateFile("extensions2", Path.Combine("bar", "extn2.proj"),
@@ -842,10 +852,12 @@ void CreateAndBuildProjectForImportFromExtensionsPath(string extnPathPropertyNam
 
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent(extnPathPropertyName));
 
-                CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, extnPathPropertyName, new string[] {extnDir1, extnDir2},
+                CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, extnPathPropertyName, new string[] { extnDir1, extnDir2 },
                                                                 null,
                                                                 action);
-            } finally {
+            }
+            finally
+            {
                 if (extnDir1 != null)
                 {
                     FileUtilities.DeleteDirectoryNoThrow(extnDir1, recursive: true);
@@ -864,15 +876,19 @@ void CreateAndBuildProjectForImportFromExtensionsPath(string extnPathPropertyNam
         void CreateAndBuildProjectForImportFromExtensionsPath(string mainProjectPath, string extnPathPropertyName, string[] extnDirs, Action<string[]> setExtensionsPath,
                 Action<Project, MockLogger> action)
         {
-            try {
-                var projColln = new ProjectCollection();
+            try
+            {
+                var projColln = GetProjectCollection();
+
                 projColln.ResetToolsetsForTests(WriteConfigFileAndGetReader(extnPathPropertyName, extnDirs));
                 var logger = new MockLogger();
                 projColln.RegisterLogger(logger);
                 var project = projColln.LoadProject(mainProjectPath);
 
                 action(project, logger);
-            } finally {
+            }
+            finally
+            {
                 if (mainProjectPath != null)
                 {
                     FileUtilities.DeleteNoThrow(mainProjectPath);
@@ -913,6 +929,30 @@ private ToolsetConfigurationReader WriteConfigFileAndGetReader(string extnPathPr
             return GetStandardConfigurationReader();
         }
 
+        private ProjectCollection GetProjectCollection(IDictionary<string, string> globalProperties = null)
+        {
+            ProjectCollection projColln;
+
+            if (globalProperties == null)
+            {
+#if FEATURE_SYSTEM_CONFIGURATION
+                projColln = new ProjectCollection();
+#else
+                projColln = new ProjectCollection(ToolsetDefinitionLocations.ConfigurationFile);
+#endif
+            }
+            else
+            {
+#if FEATURE_SYSTEM_CONFIGURATION
+                projColln = new ProjectCollection(globalProperties);
+#else
+                projColln = new ProjectCollection(globalProperties, loggers: null, ToolsetDefinitionLocations.ConfigurationFile);
+#endif
+            }
+
+            return projColln;
+        }
+
         string GetNewExtensionsPathAndCreateFile(string extnDirName, string relativeFilePath, string fileContents)
         {
             var extnDir = Path.Combine(ObjectModelHelpers.TempProjectDir, extnDirName);
@@ -922,7 +962,7 @@ string GetNewExtensionsPathAndCreateFile(string extnDirName, string relativeFile
             return extnDir;
         }
 
-        string GetMainTargetFileContent(string extensionsPathPropertyName="MSBuildExtensionsPath")
+        string GetMainTargetFileContent(string extensionsPathPropertyName = "MSBuildExtensionsPath")
         {
             string mainTargetsFileContent = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003' >
@@ -936,7 +976,7 @@ string GetMainTargetFileContent(string extensionsPathPropertyName="MSBuildExtens
             return String.Format(mainTargetsFileContent, extensionsPathPropertyName);
         }
 
-        string GetExtensionTargetsFileContent1(string extensionsPathPropertyName="MSBuildExtensionsPath")
+        string GetExtensionTargetsFileContent1(string extensionsPathPropertyName = "MSBuildExtensionsPath")
         {
             string extnTargetsFileContent1 = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003' >
@@ -954,7 +994,7 @@ string GetExtensionTargetsFileContent1(string extensionsPathPropertyName="MSBuil
             return String.Format(extnTargetsFileContent1, extensionsPathPropertyName);
         }
 
-        string GetExtensionTargetsFileContent2(string extensionsPathPropertyName="MSBuildExtensionsPath")
+        string GetExtensionTargetsFileContent2(string extensionsPathPropertyName = "MSBuildExtensionsPath")
         {
             string extnTargetsFileContent2 = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003' >
@@ -977,4 +1017,3 @@ private ToolsetConfigurationReader GetStandardConfigurationReader()
         }
     }
 }
-#endif
diff --git a/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs b/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
new file mode 100644
index 00000000000..298cf5ff37f
--- /dev/null
+++ b/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
@@ -0,0 +1,80 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#if !FEATURE_SYSTEM_CONFIGURATION
+/*  This test is designed especially to test Configuration parsing in net5.0
+ *  which means it WON'T work in net472 and thus we don't run it in net472 */
+
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+
+using Xunit;
+using System.Collections.Generic;
+using Shouldly;
+
+namespace Microsoft.Build.UnitTests.Evaluation
+{
+    /// <summary>
+    /// Unit tests for MSBuild Net5.0 Configuration Parsing
+    /// </summary>
+    public class ToolsetConfigurationNet5Test
+    {
+        [Fact]
+        // The default ToolsetDefintionLocations is None, which results in only the local which results in only the several included
+        // paths such as SDK path and RoslynTargetPath and nothing else. This behavior is expected and the exact same as before.
+        public void ToolsetDefinitionLocationsIsDefault()
+        {
+            var projectCollection = new ProjectCollection();
+            IDictionary<string, string> toolsetProperties
+                = new Dictionary<string, string>();
+
+            foreach (Toolset toolset in projectCollection.Toolsets)
+            {
+                foreach (KeyValuePair<string, ProjectPropertyInstance> properties in toolset.Properties)
+                {
+                    toolsetProperties[properties.Value.Name] = properties.Value.EvaluatedValue;
+                }
+            }
+
+            toolsetProperties.ShouldContainKey("MSBuildSDKsPath");
+            toolsetProperties.ShouldContainKey("RoslynTargetsPath");
+            toolsetProperties["MSBuildSDKsPath"].ShouldNotBeNullOrEmpty();
+            toolsetProperties["RoslynTargetsPath"].ShouldNotBeNullOrEmpty();
+
+            toolsetProperties.ShouldNotContainKey("VCTargetsPath");
+            toolsetProperties.ShouldNotContainKey("MSBuildToolsRoot");
+            toolsetProperties.ShouldNotContainKey("MSBuildExtensionsPath");
+        }
+
+        [Fact]
+        // With ToolsetDefintionLocations set to ConfigurationFile (Which would only happen in net5.0 if the user decides to set it). 
+        // Most toolsets are available and the MsBuildTools and SDK paths are all in the net5.0 runtime.
+        public void ToolsetDefinitionLocationsIsConfiguration()
+        {
+            var projectCollection = new ProjectCollection(ToolsetDefinitionLocations.ConfigurationFile);
+            IDictionary<string, string> toolsetProperties
+                = new Dictionary<string, string>();
+
+            foreach (Toolset toolset in projectCollection.Toolsets)
+            {
+                foreach (KeyValuePair<string, ProjectPropertyInstance> properties in toolset.Properties)
+                {
+                    toolsetProperties[properties.Value.Name] = properties.Value.EvaluatedValue;
+                }
+            }
+
+            toolsetProperties.ShouldContainKey("MSBuildSDKsPath");
+            toolsetProperties.ShouldContainKey("RoslynTargetsPath");
+            toolsetProperties["MSBuildSDKsPath"].ShouldNotBeNullOrEmpty();
+            toolsetProperties["RoslynTargetsPath"].ShouldNotBeNullOrEmpty();
+
+            toolsetProperties.ShouldContainKey("VCTargetsPath");
+            toolsetProperties.ShouldContainKey("MSBuildToolsRoot");
+            toolsetProperties.ShouldContainKey("MSBuildExtensionsPath");
+            toolsetProperties["VCTargetsPath"].ShouldNotBeNullOrEmpty();
+            toolsetProperties["MSBuildToolsRoot"].ShouldNotBeNullOrEmpty();
+            toolsetProperties["MSBuildExtensionsPath"].ShouldNotBeNullOrEmpty();
+        }
+    }
+}
+#endif
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 756dffdbd0e..52f699668fb 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -16,6 +16,7 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
     <PackageReference Include="NuGet.Frameworks" >
@@ -44,17 +45,12 @@
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' == 'true'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=net5.0</SetTargetFramework>
     </ProjectReference>
-
-    <Reference Include="System.Configuration" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
   <ItemGroup>
     <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    
-    <Compile Remove="Definition\ToolsetConfigurationReaderTestHelper.cs" />
-    <Compile Include="Definition\ToolsetConfigurationReaderTestHelper.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
 
     <Compile Include="..\Shared\UnitTests\BuildEventArgsExtension.cs">
       <!-- Extension methods -->
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index f7d7eca1c2c..df36e0dfd2e 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -818,16 +818,7 @@ public void EngineShouldHandleExceptionsFromCachePlugin(ExceptionLocations excep
                         </Target>
                     </Project>".Cleanup());
 
-            foreach (var enumValue in Enum.GetValues(typeof(ExceptionLocations)))
-            {
-                var typedValue = (ExceptionLocations) enumValue;
-                if (exceptionLocations.HasFlag(typedValue))
-                {
-                    var exceptionLocation = typedValue.ToString();
-                    _env.SetEnvironmentVariable(exceptionLocation, "1");
-                    _output.WriteLine($"Set exception location: {exceptionLocation}");
-                }
-            }
+            SetEnvironmentForExceptionLocations(exceptionLocations);
 
             using var buildSession = new Helpers.BuildManagerSession(
                 _env,
@@ -880,5 +871,62 @@ public void EngineShouldHandleExceptionsFromCachePlugin(ExceptionLocations excep
                 logger.FullLog.ShouldContain($"{AssemblyMockCache}: EndBuildAsync");
             }
         }
+
+        [Fact]
+        public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
+        {
+            _env.DoNotLaunchDebugger();
+
+            var project = _env.CreateFile(
+                "1.proj",
+                @$"
+                    <Project>
+                        <ItemGroup>
+                            <{ItemTypeNames.ProjectCachePlugin} Include=`{SamplePluginAssemblyPath.Value}` />
+                        </ItemGroup>
+                        <Target Name=`Build`>
+                            <Message Text=`Hello EngineShouldHandleExceptionsFromCachePlugin` Importance=`High` />
+                        </Target>
+                    </Project>".Cleanup());
+
+            SetEnvironmentForExceptionLocations(ExceptionLocations.EndBuildAsync);
+
+            using var buildSession = new Helpers.BuildManagerSession(
+                _env,
+                new BuildParameters
+                {
+                    UseSynchronousLogging = true
+                });
+
+            var logger = buildSession.Logger;
+
+            GraphBuildResult? buildResult = null;
+            Should.NotThrow(
+                () =>
+                {
+                    buildResult = buildSession.BuildGraph(new ProjectGraph(project.Path));
+                });
+
+            buildResult!.OverallResult.ShouldBe(BuildResultCode.Failure);
+            buildResult.Exception.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+
+            buildSession.Dispose();
+
+            Regex.Matches(logger.FullLog, $"{nameof(AssemblyMockCache)}: EndBuildAsync").Count.ShouldBe(1);
+        }
+
+        private void SetEnvironmentForExceptionLocations(ExceptionLocations exceptionLocations)
+        {
+            foreach (var enumValue in Enum.GetValues(typeof(ExceptionLocations)))
+            {
+                var typedValue = (ExceptionLocations) enumValue;
+                if (exceptionLocations.HasFlag(typedValue))
+                {
+                    var exceptionLocation = typedValue.ToString();
+                    _env.SetEnvironmentVariable(exceptionLocation, "1");
+                    _output.WriteLine($"Set exception location: {exceptionLocation}");
+                }
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index eb56df3a007..15344781043 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -272,6 +272,132 @@ private string GetTestProject(bool? treatAllWarningsAsErrors = null, string warn
             </Project>";
         }
 
+        [Theory]
+        
+        [InlineData("MSB1235", "MSB1234", "MSB1234", "MSB1234", false)] // Log MSB1234, treat as error via MSBuildWarningsAsErrors
+        [InlineData("MSB1235", "", "MSB1234", "MSB1234", true)] // Log MSB1234, expect MSB1234 as error via MSBuildTreatWarningsAsErrors
+        [InlineData("MSB1234", "MSB1234", "MSB1234", "MSB4181", true)]// Log MSB1234, MSBuildWarningsAsMessages takes priority
+        public void WarningsAsErrorsAndMessages_Tests(string WarningsAsMessages,
+                                                      string WarningsAsErrors,
+                                                      string WarningToLog,
+                                                      string LogShouldContain,
+                                                      bool allWarningsAreErrors = false)
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <UsingTask TaskName = ""CustomLogAndReturnTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <PropertyGroup>
+                        <MSBuildTreatWarningsAsErrors>{allWarningsAreErrors}</MSBuildTreatWarningsAsErrors>
+                        <MSBuildWarningsAsMessages>{WarningsAsMessages}</MSBuildWarningsAsMessages>
+                        <MSBuildWarningsAsErrors>{WarningsAsErrors}</MSBuildWarningsAsErrors>
+                    </PropertyGroup>
+                    <Target Name='Build'>
+                        <CustomLogAndReturnTask Return=""true"" ReturnHasLoggedErrors=""true"" WarningCode=""{WarningToLog}""/>
+                        <ReturnFailureWithoutLoggingErrorTask/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.WarningCount.ShouldBe(0);
+                logger.ErrorCount.ShouldBe(1);
+
+                logger.AssertLogContains(LogShouldContain);
+            }
+        }
+
+        /// <summary>
+        /// Item1 and Item2 log warnings and continue, item 3 logs a warn-> error and prevents item 4 from running in the batched build.
+        /// </summary>
+        [Fact]
+        public void TaskLogsWarningAsError_BatchedBuild()
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <UsingTask TaskName = ""CustomLogAndReturnTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <PropertyGroup>
+                        <MSBuildWarningsAsErrors>MSB1234</MSBuildWarningsAsErrors>
+                    </PropertyGroup>
+                    <ItemGroup>
+                        <SomeItem Include=""Item1"">
+                            <Return>true</Return>
+                            <ReturnHasLoggedErrors>true</ReturnHasLoggedErrors>
+                            <WarningCode>MSB1235</WarningCode>
+                        </SomeItem>
+                        <SomeItem Include=""Item2"">
+                            <Return>true</Return>
+                            <ReturnHasLoggedErrors>true</ReturnHasLoggedErrors>
+                            <WarningCode>MSB1236</WarningCode>
+                        </SomeItem>
+                        <SomeItem Include=""Item3"">
+                            <Return>true</Return>
+                            <ReturnHasLoggedErrors>true</ReturnHasLoggedErrors>
+                            <WarningCode>MSB1234</WarningCode>
+                        </SomeItem>
+                        <SomeItem Include=""Item4"">
+                            <Return>true</Return>
+                            <ReturnHasLoggedErrors>true</ReturnHasLoggedErrors>
+                            <WarningCode>MSB1237</WarningCode>
+                        </SomeItem>
+                    </ItemGroup>
+                    <Target Name='Build'>
+                        <CustomLogAndReturnTask Sources=""@(SomeItem)"" Return=""true"" ReturnHasLoggedErrors=""true"" WarningCode=""%(WarningCode)""/>
+                        <ReturnFailureWithoutLoggingErrorTask/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.WarningCount.ShouldBe(2);
+                logger.ErrorCount.ShouldBe(1);
+
+                // The build should STOP when a task logs an error, make sure ReturnFailureWithoutLoggingErrorTask doesn't run. 
+                logger.AssertLogDoesntContain("MSB1237");
+            }
+        }
+
+        /// <summary>
+        /// Task logs MSB1234 as a warning and returns true.
+        /// Test behavior with MSBuildWarningsAsErrors & MSBuildTreatWarningsAsErrors
+        /// Both builds should continue despite logging errors.
+        /// </summary>
+        [Theory]
+        [InlineData("MSB1234", false, 1, 1)]
+        [InlineData("MSB0000", true, 0, 2)]
+        public void TaskReturnsTrue_Tests(string warningsAsErrors, bool treatAllWarningsAsErrors, int warningCountShouldBe, int errorCountShouldBe)
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <UsingTask TaskName = ""CustomLogAndReturnTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <PropertyGroup>
+                        <MSBuildTreatWarningsAsErrors>{treatAllWarningsAsErrors}</MSBuildTreatWarningsAsErrors>
+                        <MSBuildWarningsAsErrors>{warningsAsErrors}</MSBuildWarningsAsErrors>
+                    </PropertyGroup>
+                    <Target Name='Build'>
+                        <CustomLogAndReturnTask Return=""true"" WarningCode=""MSB1234""/>
+                        <CustomLogAndReturnTask Return=""true"" WarningCode=""MSB1235""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.WarningCount.ShouldBe(warningCountShouldBe);
+                logger.ErrorCount.ShouldBe(errorCountShouldBe);
+
+                // The build will continue so we should see the warning MSB1235
+                logger.AssertLogContains("MSB1235");
+            }
+        }
+
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
         {
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index e071160c912..559d426e357 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -462,6 +462,7 @@ public void BeginBuild(BuildParameters parameters)
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildResult, BuildResult.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.NodeShutdown, NodeShutdown.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.ResolveSdkRequest, SdkResolverRequest.FactoryForDeserialization, SdkResolverService as INodePacketHandler);
+                _nodeManager.RegisterPacketHandler(NodePacketType.ResourceRequest, ResourceRequest.FactoryForDeserialization, this);
 
                 if (_threadException != null)
                 {
@@ -629,7 +630,7 @@ void Callback(object state)
                         }
                     }
 
-                    ShutdownConnectedNodesAsync(true /* abort */);
+                    ShutdownConnectedNodes(true /* abort */);
                     CheckForActiveNodesAndCleanUpSubmissions();
                 }
             }
@@ -774,7 +775,7 @@ public void EndBuild()
             try
             {
                 _noActiveSubmissionsEvent.WaitOne();
-                ShutdownConnectedNodesAsync(false /* normal termination */);
+                ShutdownConnectedNodes(false /* normal termination */);
                 _noNodesActiveEvent.WaitOne();
 
                 // Wait for all of the actions in the work queue to drain.  Wait() could throw here if there was an unhandled exception
@@ -1537,6 +1538,11 @@ private void ProcessPacket(int node, INodePacket packet)
                         HandleResult(node, result);
                         break;
 
+                    case NodePacketType.ResourceRequest:
+                        ResourceRequest request = ExpectPacketType<ResourceRequest>(packet, NodePacketType.ResourceRequest);
+                        HandleResourceRequest(node, request);
+                        break;
+
                     case NodePacketType.NodeShutdown:
                         // Remove the node from the list of active nodes.  When they are all done, we have shut down fully
                         NodeShutdown shutdownPacket = ExpectPacketType<NodeShutdown>(packet, NodePacketType.NodeShutdown);
@@ -1945,8 +1951,14 @@ public void Dispose()
 
                 lock (_buildManager._syncLock)
                 {
-                    _buildManager._projectCacheService?.Result.ShutDown().GetAwaiter().GetResult();
-                    _buildManager._projectCacheService = null;
+                    try
+                    {
+                        _buildManager._projectCacheService?.Result.ShutDown().GetAwaiter().GetResult();
+                    }
+                    finally
+                    {
+                        _buildManager._projectCacheService = null;
+                    }
                 }
             }
         }
@@ -1955,7 +1967,7 @@ public void Dispose()
         /// Asks the nodeManager to tell the currently connected nodes to shut down and sets a flag preventing all non-shutdown-related packets from
         /// being processed.
         /// </summary>
-        private void ShutdownConnectedNodesAsync(bool abort)
+        private void ShutdownConnectedNodes(bool abort)
         {
             _shuttingDown = true;
 
@@ -2168,6 +2180,30 @@ private void HandleNewRequest(int node, BuildRequestBlocker blocker)
             PerformSchedulingActions(response);
         }
 
+        /// <summary>
+        /// Handles a resource request coming from a node.
+        /// </summary>
+        private void HandleResourceRequest(int node, ResourceRequest request)
+        {
+            if (request.IsResourceAcquire)
+            {
+                // Resource request requires a response and may be blocking. Our continuation is effectively a callback
+                // to be called once at least one core becomes available.
+                _scheduler.RequestCores(request.GlobalRequestId, request.NumCores, request.IsBlocking).ContinueWith((Task<int> task) =>
+                {
+                    var response = new ResourceResponse(request.GlobalRequestId, task.Result);
+                    _nodeManager.SendData(node, response);
+                }, TaskContinuationOptions.ExecuteSynchronously);
+            }
+            else
+            {
+                // Resource release is a one-way call, no response is expected. We release the cores as instructed
+                // and kick the scheduler because there may be work waiting for cores to become available.
+                IEnumerable<ScheduleResponse> response = _scheduler.ReleaseCores(request.GlobalRequestId, request.NumCores);
+                PerformSchedulingActions(response);
+            }
+        }
+
         /// <summary>
         /// Handles a configuration request coming from a node.
         /// </summary>
@@ -2417,10 +2453,8 @@ private void ReportResultsToSubmission(BuildResult result)
             lock (_syncLock)
             {
                 // The build submission has not already been completed.
-                if (_buildSubmissions.ContainsKey(result.SubmissionId))
+                if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission submission))
                 {
-                    BuildSubmission submission = _buildSubmissions[result.SubmissionId];
-
                     /* If the request failed because we caught an exception from the loggers, we can assume we will receive no more logging messages for
                      * this submission, therefore set the logging as complete. InternalLoggerExceptions are unhandled exceptions from the logger. If the logger author does
                      * not handle an exception the eventsource wraps all exceptions (except a logging exception) into an internal logging exception.
@@ -2453,9 +2487,8 @@ private void ReportResultsToSubmission(GraphBuildResult result)
             lock (_syncLock)
             {
                 // The build submission has not already been completed.
-                if (_graphBuildSubmissions.ContainsKey(result.SubmissionId))
+                if (_graphBuildSubmissions.TryGetValue(result.SubmissionId, out GraphBuildSubmission submission))
                 {
-                    GraphBuildSubmission submission = _graphBuildSubmissions[result.SubmissionId];
                     submission.CompleteResults(result);
 
                     _overallBuildSuccess &= submission.BuildResult.OverallResult == BuildResultCode.Success;
diff --git a/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs b/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
index b53e331f9b0..34b563ae053 100644
--- a/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
+++ b/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
@@ -104,10 +104,7 @@ internal void UnregisterSubmissionForLegacyThread(int submissionId)
             {
                 ErrorUtilities.VerifyThrow(_legacyThreadingEventsById.ContainsKey(submissionId), "Submission {0} should have been previously registered with LegacyThreadingData", submissionId);
 
-                if (_legacyThreadingEventsById.ContainsKey(submissionId))
-                {
-                    _legacyThreadingEventsById.Remove(submissionId);
-                }
+                _legacyThreadingEventsById.Remove(submissionId);
             }
         }
 
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 05e6671a6d6..1038643d11f 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -164,6 +164,11 @@ internal BuildRequestEngine()
         /// </summary>
         public event EngineExceptionDelegate OnEngineException;
 
+        /// <summary>
+        /// Raised when resources are requested.
+        /// </summary>
+        public event ResourceRequestDelegate OnResourceRequest;
+
         /// <summary>
         /// Returns the current engine status.
         /// </summary>
@@ -454,6 +459,21 @@ public void UnblockBuildRequest(BuildRequestUnblocker unblocker)
                 isLastTask: false);
         }
 
+        /// <summary>
+        /// Notifies the engine of a resource response granting the node resources.
+        /// </summary>
+        /// <param name="response">The resource response.</param>
+        public void GrantResources(ResourceResponse response)
+        {
+            QueueAction(
+                () =>
+                {
+                    BuildRequestEntry entry = _requestsByGlobalRequestId[response.GlobalRequestId];
+                    entry.Builder.ContinueRequestWithResources(response);
+                },
+                isLastTask: false);
+        }
+
         /// <summary>
         /// Reports a configuration response to the request, allowing it to satisfy outstanding requests.
         /// <seealso cref="BuildRequestConfigurationResponse"/>
@@ -773,6 +793,7 @@ private void EvaluateRequestStates()
                 // Shut it down because we already have enough in reserve.
                 completedEntry.Builder.OnNewBuildRequests -= Builder_OnNewBuildRequests;
                 completedEntry.Builder.OnBuildRequestBlocked -= Builder_OnBlockedRequest;
+                completedEntry.Builder.OnResourceRequest -= Builder_OnResourceRequest;
                 ((IBuildComponent)completedEntry.Builder).ShutdownComponent();
 
                 BuildRequestConfiguration configuration = _configCache[completedEntry.Request.ConfigurationId];
@@ -914,6 +935,7 @@ private IRequestBuilder GetRequestBuilder()
             // state changes.
             builder.OnNewBuildRequests += Builder_OnNewBuildRequests;
             builder.OnBuildRequestBlocked += Builder_OnBlockedRequest;
+            builder.OnResourceRequest += Builder_OnResourceRequest;
 
             return builder;
         }
@@ -979,6 +1001,14 @@ private void Builder_OnBlockedRequest(BuildRequestEntry issuingEntry, int blocki
                 isLastTask: false);
         }
 
+        /// <summary>
+        /// Called when the request builder needs to request resources.
+        /// </summary>
+        private void Builder_OnResourceRequest(ResourceRequest request)
+        {
+            OnResourceRequest?.Invoke(request);
+        }
+
         #endregion
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index c8301762adc..fec15006b64 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -230,12 +230,12 @@ public bool ResolveConfigurationRequest(int unresolvedConfigId, int configId)
         {
             lock (GlobalLock)
             {
-                if (_unresolvedConfigurations?.ContainsKey(unresolvedConfigId) != true)
+                List<BuildRequest> requests = null;
+                if (_unresolvedConfigurations?.TryGetValue(unresolvedConfigId, out requests) != true)
                 {
                     return false;
                 }
 
-                List<BuildRequest> requests = _unresolvedConfigurations[unresolvedConfigId];
                 _unresolvedConfigurations.Remove(unresolvedConfigId);
 
                 if (_unresolvedConfigurations.Count == 0)
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs
index 75cc6ef4dc9..13d40bd7c19 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs
@@ -39,6 +39,12 @@ namespace Microsoft.Build.BackEnd
     /// <param name="config">The configuration needing an ID</param>
     internal delegate void NewConfigurationRequestDelegate(BuildRequestConfiguration config);
 
+    /// <summary>
+    /// Callback for event raised when a resource is requested.
+    /// </summary>
+    /// <param name="request">The resources being requested</param>
+    internal delegate void ResourceRequestDelegate(ResourceRequest request);
+
     /// <summary>
     /// Callback for event raised when there is an unhandled exception in the engine.
     /// </summary>
@@ -110,6 +116,11 @@ internal interface IBuildRequestEngine
         /// </summary>
         event NewConfigurationRequestDelegate OnNewConfigurationRequest;
 
+        /// <summary>
+        /// Raised when resources are requested.
+        /// </summary>
+        event ResourceRequestDelegate OnResourceRequest;
+
         /// <summary>
         /// Raised when an unhandled exception occurs in the engine.
         /// </summary>
@@ -154,6 +165,12 @@ internal interface IBuildRequestEngine
         /// <param name="unblocker">The unblocking information</param>
         void UnblockBuildRequest(BuildRequestUnblocker unblocker);
 
+        /// <summary>
+        /// Notifies the engine of a resource response granting the node resources.
+        /// </summary>
+        /// <param name="response">The resource response.</param>
+        void GrantResources(ResourceResponse response);
+
         /// <summary>
         /// Notifies the engine of a configuration response packet, typically generated by the Build Request Manager.  This packet is used to set
         /// the global configuration ID for a specific configuration.
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 0cf24b8aa14..ee236fac998 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -55,15 +55,15 @@ public void AddResult(BuildResult result)
         {
             lock (_resultsByConfiguration)
             {
-                if (_resultsByConfiguration.ContainsKey(result.ConfigurationId))
+                if (_resultsByConfiguration.TryGetValue(result.ConfigurationId, out BuildResult buildResult))
                 {
-                    if (Object.ReferenceEquals(_resultsByConfiguration[result.ConfigurationId], result))
+                    if (Object.ReferenceEquals(buildResult, result))
                     {
                         // Merging results would be meaningless as we would be merging the object with itself.
                         return;
                     }
 
-                    _resultsByConfiguration[result.ConfigurationId].MergeResults(result);
+                    buildResult.MergeResults(result);
                 }
                 else
                 {
@@ -105,9 +105,8 @@ public BuildResult GetResultForRequest(BuildRequest request)
 
             lock (_resultsByConfiguration)
             {
-                if (_resultsByConfiguration.ContainsKey(request.ConfigurationId))
+                if (_resultsByConfiguration.TryGetValue(request.ConfigurationId, out BuildResult result))
                 {
-                    BuildResult result = _resultsByConfiguration[request.ConfigurationId];
                     foreach (string target in request.Targets)
                     {
                         ErrorUtilities.VerifyThrow(result.HasResultsForTarget(target), "No results in cache for target " + target);
@@ -159,10 +158,8 @@ public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> co
 
             lock (_resultsByConfiguration)
             {
-                if (_resultsByConfiguration.ContainsKey(request.ConfigurationId))
+                if (_resultsByConfiguration.TryGetValue(request.ConfigurationId, out BuildResult allResults))
                 {
-                    BuildResult allResults = _resultsByConfiguration[request.ConfigurationId];
-
                     // Check for targets explicitly specified.
                     bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, response.ExplicitTargetsToBuild, skippedResultsDoNotCauseCacheMiss);
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 4bb6b3363de..18861fc8596 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Buffers.Binary;
 using System.Collections.Generic;
 using System.Collections.Concurrent;
 using System.Globalization;
@@ -25,6 +26,10 @@
 using Microsoft.Build.Utilities;
 
 using BackendNativeMethods = Microsoft.Build.BackEnd.NativeMethods;
+using Task = System.Threading.Tasks.Task;
+using DotNetFrameworkArchitecture = Microsoft.Build.Shared.DotNetFrameworkArchitecture;
+using Microsoft.Build.Framework;
+using Microsoft.Build.BackEnd.Logging;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -49,6 +54,11 @@ internal abstract class NodeProviderOutOfProcBase
         /// </summary>
         private const int TimeoutForNewNodeCreation = 30000;
 
+        /// <summary>
+        /// The amount of time to wait for an out-of-proc node to exit.
+        /// </summary>
+        private const int TimeoutForWaitForExit = 30000;
+
         /// <summary>
         /// The build component host.
         /// </summary>
@@ -95,9 +105,30 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool
             // Send the build completion message to the nodes, causing them to shutdown or reset.
             _processesToIgnore.Clear();
 
+            // We wait for child nodes to exit to avoid them changing the terminal
+            // after this process terminates.
+            bool waitForExit =  !enableReuse &&
+                                !Console.IsInputRedirected &&
+                                Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout;
+
+            Task[] waitForExitTasks = waitForExit && contextsToShutDown.Count > 0 ? new Task[contextsToShutDown.Count] : null;
+            int i = 0;
+            var loggingService = _componentHost.LoggingService;
             foreach (NodeContext nodeContext in contextsToShutDown)
             {
-                nodeContext?.SendData(new NodeBuildComplete(enableReuse));
+                if (nodeContext is null)
+                {
+                    continue;
+                }
+                nodeContext.SendData(new NodeBuildComplete(enableReuse));
+                if (waitForExit)
+                {
+                    waitForExitTasks[i++] = nodeContext.WaitForExitAsync(loggingService);
+                }
+            }
+            if (waitForExitTasks != null)
+            {
+                Task.WaitAll(waitForExitTasks);
             }
         }
 
@@ -138,7 +169,7 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
                 {
                     // If we're able to connect to such a process, send a packet requesting its termination
                     CommunicationsUtilities.Trace("Shutting down node with pid = {0}", nodeProcess.Id);
-                    NodeContext nodeContext = new NodeContext(0, nodeProcess.Id, nodeStream, factory, terminateNode);
+                    NodeContext nodeContext = new NodeContext(0, nodeProcess, nodeStream, factory, terminateNode);
                     nodeContext.SendData(new NodeBuildComplete(false /* no node reuse */));
                     nodeStream.Dispose();
                 }
@@ -206,7 +237,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                     {
                         // Connection successful, use this node.
                         CommunicationsUtilities.Trace("Successfully connected to existed node {0} which is PID {1}", nodeId, nodeProcess.Id);
-                        return new NodeContext(nodeId, nodeProcess.Id, nodeStream, factory, terminateNode);
+                        return new NodeContext(nodeId, nodeProcess, nodeStream, factory, terminateNode);
                     }
                 }
             }
@@ -249,20 +280,20 @@ protected NodeContext LaunchNodeProcess(string msbuildLocation, string commandLi
 #endif
 
                 // Create the node process
-                int msbuildProcessId = LaunchNode(msbuildLocation, commandLineArgs);
-                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcessId));
+                Process msbuildProcess = LaunchNode(msbuildLocation, commandLineArgs);
+                _processesToIgnore.Add(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id));
 
                 // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
                 // gotten back from CreateProcess is that of the debugger, which causes this to try to connect
                 // to the debugger process. Instead, use MSBUILDDEBUGONSTART=1
 
                 // Now try to connect to it.
-                Stream nodeStream = TryConnectToProcess(PipeNameByProcessId(msbuildProcessId, pipeName), TimeoutForNewNodeCreation, hostHandshake);
+                Stream nodeStream = TryConnectToProcess(PipeNameByProcessId(msbuildProcess.Id, pipeName), TimeoutForNewNodeCreation, hostHandshake);
                 if (nodeStream != null)
                 {
                     // Connection successful, use this node.
-                    CommunicationsUtilities.Trace("Successfully connected to created node {0} which is PID {1}", nodeId, msbuildProcessId);
-                    return new NodeContext(nodeId, msbuildProcessId, nodeStream, factory, terminateNode);
+                    CommunicationsUtilities.Trace("Successfully connected to created node {0} which is PID {1}", nodeId, msbuildProcess.Id);
+                    return new NodeContext(nodeId, msbuildProcess, nodeStream, factory, terminateNode);
                 }
             }
 
@@ -404,7 +435,7 @@ protected Stream TryConnectToProcess(string pipeName, int timeout, Handshake han
         /// <summary>
         /// Creates a new MSBuild process
         /// </summary>
-        private int LaunchNode(string msbuildLocation, string commandLineArgs)
+        private Process LaunchNode(string msbuildLocation, string commandLineArgs)
         {
             // Should always have been set already.
             ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
@@ -503,7 +534,7 @@ private int LaunchNode(string msbuildLocation, string commandLineArgs)
                 }
 
                 CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", process.Id, exeName);
-                return process.Id;
+                return process;
             }
             else
             {
@@ -561,7 +592,7 @@ out processInfo
                 }
 
                 CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", childProcessId, exeName);
-                return childProcessId;
+                return Process.GetProcessById(childProcessId);
             }
         }
 
@@ -595,6 +626,13 @@ private static string GetCurrentHost()
         /// </summary>
         internal class NodeContext
         {
+            enum ExitPacketState
+            {
+                None,
+                ExitPacketQueued,
+                ExitPacketSent
+            }
+
             // The pipe(s) used to communicate with the node.
             private Stream _clientToServerStream;
             private Stream _serverToClientStream;
@@ -610,9 +648,9 @@ internal class NodeContext
             private int _nodeId;
 
             /// <summary>
-            /// The process id
+            /// The node process.
             /// </summary>
-            private int _processId;
+            private readonly Process _process;
 
             /// <summary>
             /// An array used to store the header byte for each packet when read.
@@ -644,14 +682,14 @@ internal class NodeContext
             private Task _packetWriteDrainTask = Task.CompletedTask;
 
             /// <summary>
-            /// Event indicating the node has terminated.
+            /// Delegate called when the context terminates.
             /// </summary>
-            private ManualResetEvent _nodeTerminated;
+            private NodeContextTerminateDelegate _terminateDelegate;
 
             /// <summary>
-            /// Delegate called when the context terminates.
+            /// Tracks the state of the packet sent to terminate the node.
             /// </summary>
-            private NodeContextTerminateDelegate _terminateDelegate;
+            private ExitPacketState _exitPacketState;
 
             /// <summary>
             /// Per node read buffers
@@ -661,20 +699,18 @@ internal class NodeContext
             /// <summary>
             /// Constructor.
             /// </summary>
-            public NodeContext(int nodeId, int processId,
+            public NodeContext(int nodeId, Process process,
                 Stream nodePipe,
                 INodePacketFactory factory, NodeContextTerminateDelegate terminateDelegate)
             {
                 _nodeId = nodeId;
-                _processId = processId;
+                _process = process;
                 _clientToServerStream = nodePipe;
                 _serverToClientStream = nodePipe;
                 _packetFactory = factory;
                 _headerByte = new byte[5]; // 1 for the packet type, 4 for the body length
-
                 _readBufferMemoryStream = new MemoryStream();
                 _writeBufferMemoryStream = new MemoryStream();
-                _nodeTerminated = new ManualResetEvent(false);
                 _terminateDelegate = terminateDelegate;
                 _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
             }
@@ -716,7 +752,7 @@ public async Task RunPacketReadLoopAsync()
                     }
 
                     NodePacketType packetType = (NodePacketType)_headerByte[0];
-                    int packetLength = BitConverter.ToInt32(_headerByte, 1);
+                    int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(_headerByte, 1, 4));
 
                     _readBufferMemoryStream.SetLength(packetLength);
                     byte[] packetData = _readBufferMemoryStream.GetBuffer();
@@ -762,6 +798,10 @@ public async Task RunPacketReadLoopAsync()
             /// <param name="packet">The packet to send.</param>
             public void SendData(INodePacket packet)
             {
+                if (IsExitPacket(packet))
+                {
+                    _exitPacketState = ExitPacketState.ExitPacketQueued;
+                }
                 _packetWriteQueue.Add(packet);
                 DrainPacketQueue();
             }
@@ -829,6 +869,10 @@ private void SendDataCore(INodePacket packet)
                         int lengthToWrite = Math.Min(writeStreamLength - i, MaxPacketWriteSize);
                         _serverToClientStream.Write(writeStreamBuffer, i, lengthToWrite);
                     }
+                    if (IsExitPacket(packet))
+                    {
+                        _exitPacketState = ExitPacketState.ExitPacketSent;
+                    }
                 }
                 catch (IOException e)
                 {
@@ -841,6 +885,11 @@ private void SendDataCore(INodePacket packet)
                 }
             }
 
+            private static bool IsExitPacket(INodePacket packet)
+            {
+                return packet is NodeBuildComplete buildCompletePacket && !buildCompletePacket.PrepareForReuse;
+            }
+
             /// <summary>
             /// Avoid having a BinaryWriter just to write a 4-byte int
             /// </summary>
@@ -855,7 +904,7 @@ private void WriteInt32(MemoryStream stream, int value)
             /// <summary>
             /// Closes the node's context, disconnecting it from the node.
             /// </summary>
-            public void Close()
+            private void Close()
             {
                 _clientToServerStream.Dispose();
                 if (!object.ReferenceEquals(_clientToServerStream, _serverToClientStream))
@@ -865,6 +914,52 @@ public void Close()
                 _terminateDelegate(_nodeId);
             }
 
+            /// <summary>
+            /// Waits for the child node process to exit.
+            /// </summary>
+            public async Task WaitForExitAsync(ILoggingService loggingService)
+            {
+                if (_exitPacketState == ExitPacketState.ExitPacketQueued)
+                {
+                    // Wait up to 100ms until all remaining packets are sent.
+                    // We don't need to wait long, just long enough for the Task to start running on the ThreadPool.
+                    await Task.WhenAny(_packetWriteDrainTask, Task.Delay(100));
+                }
+                if (_exitPacketState == ExitPacketState.ExitPacketSent)
+                {
+                    CommunicationsUtilities.Trace("Waiting for node with pid = {0} to exit", _process.Id);
+
+                    // .NET 5 introduces a real WaitForExitAsyc.
+                    // This is a poor man's implementation that uses polling.
+                    int timeout = TimeoutForWaitForExit;
+                    int delay = 5;
+                    while (timeout > 0)
+                    {
+                        bool exited = _process.WaitForExit(milliseconds: 0);
+                        if (exited)
+                        {
+                            return;
+                        }
+                        timeout -= delay;
+                        await Task.Delay(delay).ConfigureAwait(false);
+
+                        // Double delay up to 500ms.
+                        delay = Math.Min(delay * 2, 500);
+                    }
+                }
+
+                // Kill the child and do a blocking wait.
+                loggingService?.LogWarning(
+                    BuildEventContext.Invalid,
+                    null,
+                    BuildEventFileInfo.Empty,
+                    "KillingProcessWithPid",
+                    _process.Id);
+                CommunicationsUtilities.Trace("Killing node with pid = {0}", _process.Id);
+
+                _process.KillTree(timeout: 5000);
+            }
+
 #if FEATURE_APM
             /// <summary>
             /// Completes the asynchronous packet write to the node.
@@ -886,17 +981,16 @@ private bool ProcessHeaderBytesRead(int bytesRead)
             {
                 if (bytesRead != _headerByte.Length)
                 {
-                    CommunicationsUtilities.Trace(_nodeId, "COMMUNICATIONS ERROR (HRC) Node: {0} Process: {1} Bytes Read: {2} Expected: {3}", _nodeId, _processId, bytesRead, _headerByte.Length);
+                    CommunicationsUtilities.Trace(_nodeId, "COMMUNICATIONS ERROR (HRC) Node: {0} Process: {1} Bytes Read: {2} Expected: {3}", _nodeId, _process.Id, bytesRead, _headerByte.Length);
                     try
                     {
-                        Process childProcess = Process.GetProcessById(_processId);
-                        if (childProcess?.HasExited != false)
+                        if (_process.HasExited)
                         {
-                            CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} has exited.", _processId);
+                            CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} has exited.", _process.Id);
                         }
                         else
                         {
-                            CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} is still running.", _processId);
+                            CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} is still running.", _process.Id);
                         }
                     }
                     catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
@@ -947,7 +1041,7 @@ private void HeaderReadComplete(IAsyncResult result)
                     return;
                 }
 
-                int packetLength = BitConverter.ToInt32(_headerByte, 1);
+                int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(_headerByte, 1, 4));
                 MSBuildEventSource.Log.PacketReadSize(packetLength);
 
                 // Ensures the buffer is at least this length.
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index fea29ad18e7..6d789077cb6 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -261,9 +261,9 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
         public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
         {
-            if (_nodeIdToPacketFactory.ContainsKey(nodeId))
+            if (_nodeIdToPacketFactory.TryGetValue(nodeId, out INodePacketFactory nodePacketFactory))
             {
-                _nodeIdToPacketFactory[nodeId].DeserializeAndRoutePacket(nodeId, packetType, translator);
+                nodePacketFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
             }
             else
             {
@@ -278,9 +278,9 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
         /// <param name="packet">The packet to route.</param>
         public void RoutePacket(int nodeId, INodePacket packet)
         {
-            if (_nodeIdToPacketFactory.ContainsKey(nodeId))
+            if (_nodeIdToPacketFactory.TryGetValue(nodeId, out INodePacketFactory nodePacketFactory))
             {
-                _nodeIdToPacketFactory[nodeId].RoutePacket(nodeId, packet);
+                nodePacketFactory.RoutePacket(nodeId, packet);
             }
             else
             {
@@ -300,9 +300,9 @@ public void RoutePacket(int nodeId, INodePacket packet)
         /// <param name="packet">The packet.</param>
         public void PacketReceived(int nodeId, INodePacket packet)
         {
-            if (_nodeIdToPacketHandler.ContainsKey(nodeId))
+            if (_nodeIdToPacketHandler.TryGetValue(nodeId, out INodePacketHandler packetHandler))
             {
-                _nodeIdToPacketHandler[nodeId].PacketReceived(nodeId, packet);
+                packetHandler.PacketReceived(nodeId, packet);
             }
             else
             {
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 42feb90220b..eebb06bea2a 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -219,6 +219,20 @@ bool IncludeTaskInputs
         /// <returns><code>true</code> if the build submission logged an errors, otherwise <code>false</code>.</returns>
         bool HasBuildSubmissionLoggedErrors(int submissionId);
 
+        /// <summary>
+        /// Returns a hashset of warnings to be logged as errors for the specified project instance ID.
+        /// </summary>
+        /// <param name="context">The build context through which warnings will be logged as errors.</param>
+        /// <returns>A Hashset containing warning codes that should be treated as errors.</returns>
+        ICollection<string> GetWarningsAsErrors(BuildEventContext context);
+
+        /// <summary>
+        /// Returns a hashset of warnings to be logged as messages for the specified project instance ID.
+        /// </summary>
+        /// <param name="context">The build context through which warnings will be logged as errors.</param>
+        /// <returns>A Hashset containing warning codes that should be treated as messages.</returns>
+        ICollection<string> GetWarningsAsMessages(BuildEventContext context);
+
         #region Register
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 85c95d728d1..c86ac786792 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -285,6 +285,10 @@ protected LoggingService(LoggerMode loggerMode, int nodeId)
                 CreateLoggingEventQueue();
             }
 
+            // Ensure the static constructor of ItemGroupLoggingHelper runs.
+            // It is important to ensure the Message delegate on TaskParameterEventArgs is set.
+            _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
+
             _serviceState = LoggingServiceState.Instantiated;
         }
 
@@ -515,6 +519,50 @@ public bool HasBuildSubmissionLoggedErrors(int submissionId)
             return _buildSubmissionIdsThatHaveLoggedErrors?.Contains(submissionId) == true;
         }
 
+        /// <summary>
+        /// Returns a hashset of warnings to be logged as errors for the specified build context.
+        /// </summary>
+        /// <param name="context">The build context through which warnings will be logged as errors.</param>
+        /// <returns>
+        /// </returns>
+        public ICollection<string> GetWarningsAsErrors(BuildEventContext context)
+        {
+            int key = GetWarningsAsErrorOrMessageKey(context);
+
+            if (_warningsAsErrorsByProject != null && _warningsAsErrorsByProject.TryGetValue(key, out ISet<string> warningsAsErrors))
+            {
+                if (WarningsAsErrors != null)
+                {
+                    warningsAsErrors.UnionWith(WarningsAsErrors);
+                }
+
+                return warningsAsErrors;
+            }
+            else
+            {
+                return WarningsAsErrors;
+            }
+        }
+
+        public ICollection<string> GetWarningsAsMessages(BuildEventContext context)
+        {
+            int key = GetWarningsAsErrorOrMessageKey(context);
+
+            if (_warningsAsMessagesByProject != null && _warningsAsMessagesByProject.TryGetValue(key, out ISet<string> warningsAsMessages))
+            {
+                if (WarningsAsMessages != null)
+                {
+                    warningsAsMessages.UnionWith(WarningsAsMessages);
+                }
+
+                return warningsAsMessages;
+            }
+            else
+            {
+                return WarningsAsMessages;
+            }
+        }
+
         public void AddWarningsAsErrors(BuildEventContext buildEventContext, ISet<string> codes)
         {
             lock (_lockObject)
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index b4fb5ad461c..d7c7cf13ad6 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -626,12 +626,10 @@ public void LogProjectFinished(BuildEventContext projectBuildEventContext, strin
                 ProcessLoggingEvent(buildEvent);
 
                 // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
-                if (!_projectFileMap.ContainsKey(projectBuildEventContext.ProjectContextId))
+                if (!_projectFileMap.Remove(projectBuildEventContext.ProjectContextId))
                 {
                     ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should be in the ID-to-file mapping!", projectBuildEventContext.ProjectContextId, projectFile);
                 }
-
-                _projectFileMap.Remove(projectBuildEventContext.ProjectContextId);
             }
         }
 
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index 6daf7608f20..efde35dd8af 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -138,6 +138,11 @@ internal TargetOutputItemsInstanceEnumeratorProxy(IEnumerable<TaskItem> backingI
                 _backingItems = backingItems;
             }
 
+            // For performance reasons we need to expose the raw items to BinaryLogger
+            // as we know we're not going to mutate anything. This allows us to bypass DeepClone
+            // for each item
+            internal IEnumerable<TaskItem> BackingItems => _backingItems;
+
             /// <summary>
             /// Returns an enumerator that provides copies of the items
             /// in the backing store.
diff --git a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
index c953ec6f226..6dc62c389ce 100644
--- a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
@@ -1,10 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
+using System;
+using System.Collections.Generic;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
@@ -144,5 +145,15 @@ internal void LogTaskWarningFromException(Exception exception, BuildEventFileInf
             ErrorUtilities.VerifyThrow(IsValid, "must be valid");
             LoggingService.LogTaskWarningFromException(BuildEventContext, exception, file, taskName);
         }
+
+        internal ICollection<string> GetWarningsAsErrors()
+        {
+            return LoggingService.GetWarningsAsErrors(BuildEventContext);
+        }
+
+        internal ICollection<string> GetWarningsAsMessages()
+        {
+            return LoggingService.GetWarningsAsMessages(BuildEventContext);
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
index af194e45728..7f8a69ecbbd 100644
--- a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
@@ -63,9 +63,9 @@ private CacheResult(
             ProxyTargets = proxyTargets;
         }
 
-        internal CacheResultType ResultType { get; }
-        internal BuildResult? BuildResult { get; }
-        internal ProxyTargets? ProxyTargets { get; }
+        public CacheResultType ResultType { get; }
+        public BuildResult? BuildResult { get; }
+        public ProxyTargets? ProxyTargets { get; }
 
         public static CacheResult IndicateCacheHit(BuildResult buildResult)
         {
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
index 2fe895fe150..5cf28808582 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
@@ -10,6 +10,7 @@ namespace Microsoft.Build.Experimental.ProjectCache
 {
     /// <summary>
     ///     Only one plugin instance can exist for a given BuildManager BeginBuild / EndBuild session.
+    ///     Any exceptions thrown by the plugin will cause MSBuild to fail the build.
     /// </summary>
     public abstract class ProjectCachePluginBase
     {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
index a0de5afca83..5db9a001e46 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
@@ -48,6 +48,11 @@ internal interface IRequestBuilder
         /// </summary>
         event BuildRequestBlockedDelegate OnBuildRequestBlocked;
 
+        /// <summary>
+        /// Raised when resources are requested.
+        /// </summary>
+        event ResourceRequestDelegate OnResourceRequest;
+
         /// <summary>
         /// Builds the request contained in the specified entry.
         /// </summary>
@@ -60,6 +65,11 @@ internal interface IRequestBuilder
         /// </summary>
         void ContinueRequest();
 
+        /// <summary>
+        /// Continues building a request which was previously waiting for a resource grant.
+        /// </summary>
+        void ContinueRequestWithResources(ResourceResponse response);
+
         /// <summary>
         /// Cancels an existing request.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilderCallback.cs b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilderCallback.cs
index 63b77897dd5..386db137259 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilderCallback.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilderCallback.cs
@@ -55,5 +55,21 @@ internal interface IRequestBuilderCallback
         /// Exits the previous MSBuild callback state.
         /// </summary>
         void ExitMSBuildCallbackState();
+
+        /// <summary>
+        /// Requests CPU resources from the scheduler.
+        /// </summary>
+        /// <param name="monitorLockObject">The object used by the caller for synchronization. The lock on this object must be taken when calling this method.</param>
+        /// <param name="requestedCores">Number of logical cores being requested.</param>
+        /// <param name="waitForCores">True to make the request block and wait for at least one core.</param>
+        /// <returns>Number of logical cores actually granted. If <paramref name="waitForCores"/> is false, the call can return
+        /// zero. Otherwise the return value is positive.</returns>
+        int RequestCores(object monitorLockObject, int requestedCores, bool waitForCores);
+
+        /// <summary>
+        /// Returns CPU resources to the scheduler.
+        /// </summary>
+        /// <param name="coresToRelease">Number of logical cores being returned.</param>
+        void ReleaseCores(int coresToRelease);
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index dd1e5009679..66195775b22 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -213,12 +213,12 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
 
             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd?.Count > 0)
             {
-                var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
-                    ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix,
+                ItemGroupLoggingHelper.LogTaskParameter(
+                    LoggingContext,
+                    TaskParameterMessageKind.AddItem,
                     child.ItemType,
                     itemsToAdd,
                     logItemMetadata: true);
-                LoggingContext.LogCommentFromText(MessageImportance.Low, itemGroupText);
             }
 
             // Now add the items we created to the lookup.
@@ -249,48 +249,25 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
             }
             else
             {
-                itemsToRemove = FindItemsUsingMatchOnMetadata(group, child, bucket, matchOnMetadata, matchingOptions);
+                itemsToRemove = FindItemsMatchingMetadataSpecification(group, child, bucket.Expander, matchOnMetadata, matchingOptions);
             }
 
             if (itemsToRemove != null)
             {
                 if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToRemove.Count > 0)
                 {
-                    var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
-                        ItemGroupLoggingHelper.ItemGroupRemoveLogMessage,
+                    ItemGroupLoggingHelper.LogTaskParameter(
+                        LoggingContext,
+                        TaskParameterMessageKind.RemoveItem,
                         child.ItemType,
                         itemsToRemove,
                         logItemMetadata: true);
-                    LoggingContext.LogCommentFromText(MessageImportance.Low, itemGroupText);
                 }
 
                 bucket.Lookup.RemoveItems(itemsToRemove);
             }
         }
 
-        private List<ProjectItemInstance> FindItemsUsingMatchOnMetadata(
-            ICollection<ProjectItemInstance> items,
-            ProjectItemGroupTaskItemInstance child,
-            ItemBucket bucket,
-            HashSet<string> matchOnMetadata,
-            MatchOnMetadataOptions options)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(matchOnMetadata, nameof(matchOnMetadata));
-
-            var itemSpec = new ItemSpec<ProjectPropertyInstance, ProjectItemInstance>(child.Remove, bucket.Expander, child.RemoveLocation, Project.Directory, true);
-
-            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
-                itemSpec.Fragments.Count == 1
-                && itemSpec.Fragments.First() is ItemSpec<ProjectPropertyInstance, ProjectItemInstance>.ItemExpressionFragment
-                && matchOnMetadata.Count == 1,
-                new BuildEventFileInfo(string.Empty),
-                "OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem",
-                child.RemoveLocation,
-                child.Remove);
-
-            return items.Where(item => itemSpec.MatchesItemOnMetadata(item, matchOnMetadata, options)).ToList();
-        }
-
         /// <summary>
         /// Modifies items in the world - specifically, changes their metadata. Changes to items that are part of the project manifest are backed up, so 
         /// they can be reverted when the project is reset after the end of the build.
@@ -597,6 +574,24 @@ Expander<ProjectPropertyInstance, ProjectItemInstance> expander
             return itemsRemoved;
         }
 
+        private List<ProjectItemInstance> FindItemsMatchingMetadataSpecification(
+            ICollection<ProjectItemInstance> group,
+            ProjectItemGroupTaskItemInstance child,
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
+            HashSet<string> matchOnMetadata,
+            MatchOnMetadataOptions matchingOptions)
+        {
+            ItemSpec<ProjectPropertyInstance, ProjectItemInstance> itemSpec = new ItemSpec<ProjectPropertyInstance, ProjectItemInstance>(child.Remove, expander, child.RemoveLocation, Project.Directory, true);
+            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
+                itemSpec.Fragments.All(f => f is ItemSpec<ProjectPropertyInstance, ProjectItemInstance>.ItemExpressionFragment),
+                new BuildEventFileInfo(string.Empty),
+                "OM_MatchOnMetadataIsRestrictedToReferencedItems",
+                child.RemoveLocation,
+                child.Remove);
+            MetadataTrie<ProjectPropertyInstance, ProjectItemInstance> metadataSet = new MetadataTrie<ProjectPropertyInstance, ProjectItemInstance>(matchingOptions, matchOnMetadata, itemSpec);
+            return group.Where(item => metadataSet.Contains(matchOnMetadata.Select(m => item.GetMetadataValue(m)))).ToList();
+        }
+
         /// <summary>
         /// This class is used during ItemGroup intrinsic tasks to resolve metadata references.  It consists of three tables:
         /// 1. The metadata added during evaluation.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index 9aa0bfd4fce..2b8d80d306c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -5,6 +5,8 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Globalization;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
@@ -31,6 +33,17 @@ internal static class ItemGroupLoggingHelper
         internal static string OutputItemParameterMessagePrefix = ResourceUtilities.GetResourceString("OutputItemParameterMessagePrefix");
         internal static string TaskParameterPrefix = ResourceUtilities.GetResourceString("TaskParameterPrefix");
 
+        /// <summary>
+        /// <see cref="TaskParameterEventArgs"/> by itself doesn't have the implementation
+        /// to materialize the Message as that's a declaration assembly. We inject the logic
+        /// here.
+        /// </summary>
+        static ItemGroupLoggingHelper()
+        {
+            TaskParameterEventArgs.MessageGetter = GetTaskParameterText;
+            TaskParameterEventArgs.DictionaryFactory = ArrayDictionary<string, string>.Create;
+        }
+
         /// <summary>
         /// Gets a text serialized value of a parameter for logging.
         /// </summary>
@@ -203,5 +216,62 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob
                 ErrorUtilities.ThrowInternalErrorUnreachable();
             }
         }
+
+        internal static void LogTaskParameter(
+            LoggingContext loggingContext,
+            TaskParameterMessageKind messageKind,
+            string itemType,
+            IList items,
+            bool logItemMetadata)
+        {
+            var args = CreateTaskParameterEventArgs(
+                loggingContext.BuildEventContext,
+                messageKind,
+                itemType,
+                items,
+                logItemMetadata,
+                DateTime.UtcNow);
+            loggingContext.LogBuildEvent(args);
+        }
+
+        internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
+            BuildEventContext buildEventContext,
+            TaskParameterMessageKind messageKind,
+            string itemType,
+            IList items,
+            bool logItemMetadata,
+            DateTime timestamp)
+        {
+            var args = new TaskParameterEventArgs(
+                messageKind,
+                itemType,
+                items,
+                logItemMetadata,
+                timestamp);
+            args.BuildEventContext = buildEventContext;
+            return args;
+        }
+
+        internal static string GetTaskParameterText(TaskParameterEventArgs args)
+            => GetTaskParameterText(args.Kind, args.ItemType, args.Items, args.LogItemMetadata);
+
+        internal static string GetTaskParameterText(TaskParameterMessageKind messageKind, string itemType, IList items, bool logItemMetadata)
+        {
+            var resourceText = messageKind switch
+            {
+                TaskParameterMessageKind.AddItem => ItemGroupIncludeLogMessagePrefix,
+                TaskParameterMessageKind.RemoveItem => ItemGroupRemoveLogMessage,
+                TaskParameterMessageKind.TaskInput => TaskParameterPrefix,
+                TaskParameterMessageKind.TaskOutput => OutputItemParameterMessagePrefix,
+                _ => throw new NotImplementedException($"Unsupported {nameof(TaskParameterMessageKind)} value: {messageKind}")
+            };
+
+            var itemGroupText = GetParameterText(
+                resourceText,
+                itemType,
+                items,
+                logItemMetadata);
+            return itemGroupText;
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index bbe8db85caf..6e0ba6a0d5f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -661,10 +661,8 @@ internal static async Task<bool> ExecuteTargets(
 
                         foreach (string targetName in nonNullTargetList)
                         {
-                            if (targetOutputsPerProject[i].ContainsKey(targetName))
+                            if (targetOutputsPerProject[i].TryGetValue(targetName, out ITaskItem[] outputItemsFromTarget))
                             {
-                                ITaskItem[] outputItemsFromTarget = targetOutputsPerProject[i][targetName];
-
                                 foreach (ITaskItem outputItemFromTarget in outputItemsFromTarget)
                                 {
                                     // No need to rebase if the calling project is the same as the callee project 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index 4d0e7f95812..71141924280 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -210,13 +210,13 @@ internal List<string> GetPropertyOverrideMessages(Dictionary<string, string> loo
 
                     string propertyName = property.Name;
                     // If the hash contains the property name, output a messages that displays the previous property value and the new property value
-                    if (lookupHash.ContainsKey(propertyName))
+                    if (lookupHash.TryGetValue(propertyName, out string propertyValue))
                     {
                         if (errorMessages == null)
                         {
                             errorMessages = new List<string>();
                         }
-                        errorMessages.Add(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("PropertyOutputOverridden", propertyName, EscapingUtilities.UnescapeAll(lookupHash[propertyName]), property.EvaluatedValue));
+                        errorMessages.Add(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("PropertyOutputOverridden", propertyName, EscapingUtilities.UnescapeAll(propertyValue), property.EvaluatedValue));
                     }
 
                     // Set the value of the hash to the new property value
@@ -945,10 +945,10 @@ private void MustNotBeInTable(ItemDictionary<ProjectItemInstance> table, Project
         /// </summary>
         private void MustNotBeInTable(ItemTypeToItemsMetadataUpdateDictionary table, ProjectItemInstance item)
         {
-            if (table?.ContainsKey(item.ItemType) == true)
+            ItemsMetadataUpdateDictionary tableOfItemsOfSameType = null;
+            if (table?.TryGetValue(item.ItemType, out tableOfItemsOfSameType) == true)
             {
-                ItemsMetadataUpdateDictionary tableOfItemsOfSameType = table[item.ItemType];
-                if (tableOfItemsOfSameType != null)
+                if (tableOfItemsOfSameType is not null)
                 {
                     ErrorUtilities.VerifyThrow(!tableOfItemsOfSameType.ContainsKey(item), "Item should not be in table");
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index d5b83a1566c..7b7f60f06cc 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
@@ -19,7 +18,6 @@
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
-using Microsoft.Build.Experimental.ProjectCache;
 using NodeLoggingContext = Microsoft.Build.BackEnd.Logging.NodeLoggingContext;
 using ProjectLoggingContext = Microsoft.Build.BackEnd.Logging.ProjectLoggingContext;
 
@@ -50,6 +48,11 @@ internal class RequestBuilder : IRequestBuilder, IRequestBuilderCallback, IBuild
         /// </summary>
         private IDictionary<int, BuildResult> _continueResults;
 
+        /// <summary>
+        /// Queue of actions to call when a resource request is responded to.
+        /// </summary>
+        private ConcurrentQueue<Action<ResourceResponse>> _pendingResourceRequests;
+
         /// <summary>
         /// The task representing the currently-executing build request.
         /// </summary>
@@ -107,6 +110,7 @@ internal RequestBuilder()
         {
             _terminateEvent = new ManualResetEvent(false);
             _continueEvent = new AutoResetEvent(false);
+            _pendingResourceRequests = new ConcurrentQueue<Action<ResourceResponse>>();
         }
 
         /// <summary>
@@ -124,6 +128,11 @@ internal RequestBuilder()
         /// </summary>
         public event BuildRequestBlockedDelegate OnBuildRequestBlocked;
 
+        /// <summary>
+        /// The event raised when resources are requested.
+        /// </summary>
+        public event ResourceRequestDelegate OnResourceRequest;
+
         /// <summary>
         /// The current block type
         /// </summary>
@@ -220,6 +229,19 @@ public void ContinueRequest()
             _continueEvent.Set();
         }
 
+        /// <summary>
+        /// Continues a build request after receiving a resource response.
+        /// </summary>
+        public void ContinueRequestWithResources(ResourceResponse response)
+        {
+            ErrorUtilities.VerifyThrow(HasActiveBuildRequest, "Request not building");
+            ErrorUtilities.VerifyThrow(!_terminateEvent.WaitOne(0), "Request already terminated");
+            ErrorUtilities.VerifyThrow(!_pendingResourceRequests.IsEmpty, "No pending resource requests");
+            VerifyEntryInActiveOrWaitingState();
+
+            _pendingResourceRequests.Dequeue()(response);
+        }
+
         /// <summary>
         /// Terminates the build request
         /// </summary>
@@ -460,6 +482,61 @@ public void ExitMSBuildCallbackState()
             _inMSBuildCallback = false;
         }
 
+        /// <summary>
+        /// Requests CPU resources from the scheduler.
+        /// </summary>
+        public int RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)
+        {
+            ErrorUtilities.VerifyThrow(Monitor.IsEntered(monitorLockObject), "Not running under the given lock");
+            VerifyIsNotZombie();
+
+            // The task may be calling RequestCores from multiple threads and the call may be blocking, so in general, we have to maintain
+            // a queue of pending requests.
+            ResourceResponse responseObject = null;
+            using AutoResetEvent responseEvent = new AutoResetEvent(false);
+            _pendingResourceRequests.Enqueue((ResourceResponse response) =>
+            {
+                responseObject = response;
+                responseEvent.Set();
+            });
+
+            RaiseResourceRequest(ResourceRequest.CreateAcquireRequest(_requestEntry.Request.GlobalRequestId, requestedCores, waitForCores));
+
+            // Wait for one of two events to be signaled: 1) The build was canceled, 2) The response to our request was received.
+            WaitHandle[] waitHandles = new WaitHandle[] { _terminateEvent, responseEvent };
+            int waitResult;
+
+            // Drop the lock so that the same task can call ReleaseCores from other threads to unblock itself.
+            Monitor.Exit(monitorLockObject);
+            try
+            {
+                waitResult = WaitHandle.WaitAny(waitHandles);
+            }
+            finally
+            {
+                // Now re-take the lock before continuing.
+                Monitor.Enter(monitorLockObject);
+            }
+
+            if (waitResult == 0)
+            {
+                // We've been aborted.
+                throw new BuildAbortedException();
+            }
+
+            VerifyEntryInActiveOrWaitingState();
+            return responseObject.NumCores;
+        }
+
+        /// <summary>
+        /// Returns CPU resources to the scheduler.
+        /// </summary>
+        public void ReleaseCores(int coresToRelease)
+        {
+            VerifyIsNotZombie();
+            RaiseResourceRequest(ResourceRequest.CreateReleaseRequest(_requestEntry.Request.GlobalRequestId, coresToRelease));
+        }
+
         #endregion
 
         #region IBuildComponent Members
@@ -676,6 +753,15 @@ private void VerifyEntryInActiveState()
             ErrorUtilities.VerifyThrow(_requestEntry.State == BuildRequestEntryState.Active, "Entry is not in the Active state, it is in the {0} state.", _requestEntry.State);
         }
 
+        /// <summary>
+        /// Asserts that the entry is in the active or waiting state.
+        /// </summary>
+        private void VerifyEntryInActiveOrWaitingState()
+        {
+            ErrorUtilities.VerifyThrow(_requestEntry.State == BuildRequestEntryState.Active || _requestEntry.State == BuildRequestEntryState.Waiting,
+                "Entry is not in the Active or Waiting state, it is in the {0} state.", _requestEntry.State);
+        }
+
         /// <summary>
         /// The entry point for the request builder thread.
         /// </summary>
@@ -986,6 +1072,15 @@ private void RaiseOnBlockedRequest(int blockingGlobalRequestId, string blockingT
             OnBuildRequestBlocked?.Invoke(_requestEntry, blockingGlobalRequestId, blockingTarget, partialBuildResult);
         }
 
+        /// <summary>
+        /// Invokes the OnResourceRequest event
+        /// </summary>
+        /// <param name="request"></param>
+        private void RaiseResourceRequest(ResourceRequest request)
+        {
+            OnResourceRequest?.Invoke(request);
+        }
+
         /// <summary>
         /// This method is called to reset the current directory to the one appropriate for this project.  It should be called any time
         /// the project is resumed.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index d79147775b7..79142963436 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -142,16 +142,16 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
 
             foreach (string targetName in targetNames)
             {
-                var targetExists = _projectInstance.Targets.ContainsKey(targetName);
+                var targetExists = _projectInstance.Targets.TryGetValue(targetName, out ProjectTargetInstance targetInstance);
                 if (!targetExists && entry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.SkipNonexistentTargets))
                 {
                     _projectLoggingContext.LogComment(Framework.MessageImportance.Low,
                         "TargetSkippedWhenSkipNonexistentTargets", targetName);
-
-                    continue;
                 }
-
-                targets.Add(new TargetSpecification(targetName, targetExists ? _projectInstance.Targets[targetName].Location : _projectInstance.ProjectFileLocation));
+                else
+                {
+                    targets.Add(new TargetSpecification(targetName, targetExists ? targetInstance.Location : _projectInstance.ProjectFileLocation));
+                }
             }
 
             // Push targets onto the stack.  This method will reverse their push order so that they
@@ -363,6 +363,24 @@ void IRequestBuilderCallback.ExitMSBuildCallbackState()
             _requestBuilderCallback.ExitMSBuildCallbackState();
         }
 
+        /// <summary>
+        /// Requests CPU resources from the scheduler.
+        /// </summary>
+        /// <remarks>This method is called from the <see cref="TaskHost"/>.</remarks>
+        int IRequestBuilderCallback.RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)
+        {
+            return _requestBuilderCallback.RequestCores(monitorLockObject, requestedCores, waitForCores);
+        }
+
+        /// <summary>
+        /// Returns CPU resources to the scheduler.
+        /// </summary>
+        /// <remarks>This method is called from the <see cref="TaskHost"/>.</remarks>
+        void IRequestBuilderCallback.ReleaseCores(int coresToRelease)
+        {
+            _requestBuilderCallback.ReleaseCores(coresToRelease);
+        }
+
         #endregion
 
         /// <summary>
@@ -484,13 +502,7 @@ await PushTargets(errorTargets, currentTargetEntry, currentTargetEntry.Lookup, t
                             }
                             catch
                             {
-                                if (_requestEntry.RequestConfiguration.ActivelyBuildingTargets.ContainsKey(
-                                    currentTargetEntry.Name))
-                                {
-                                    _requestEntry.RequestConfiguration.ActivelyBuildingTargets.Remove(currentTargetEntry
-                                        .Name);
-                                }
-
+                                _requestEntry.RequestConfiguration.ActivelyBuildingTargets.Remove(currentTargetEntry.Name);
                                 throw;
                             }
                         }
@@ -764,7 +776,7 @@ private void ComputeAfterTargetFailures(string[] targetNames)
         {
             foreach (string targetName in targetNames)
             {
-                if (_buildResult.ResultsByTarget.ContainsKey(targetName))
+                if (_buildResult.ResultsByTarget.TryGetValue(targetName, out TargetResult targetBuildResult))
                 {
                     // Queue of targets waiting to be processed, seeded with the specific target for which we're computing AfterTargetsHaveFailed.
                     var targetsToCheckForAfterTargets = new Queue<string>();
@@ -785,7 +797,7 @@ private void ComputeAfterTargetFailures(string[] targetNames)
                             if (result?.ResultCode == TargetResultCode.Failure && !result.TargetFailureDoesntCauseBuildFailure)
                             {
                                 // Mark the target as having an after target failed, and break the loop to move to the next target.
-                                _buildResult.ResultsByTarget[targetName].AfterTargetsHaveFailed = true;
+                                targetBuildResult.AfterTargetsHaveFailed = true;
                                 targetsToCheckForAfterTargets = null;
                                 break;
                             }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 58a0e6931bc..5390d169443 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -338,9 +338,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
             {
                 _taskExecutionHost.CleanupForTask();
 
-#if FEATURE_APPDOMAIN
                 taskHost?.MarkAsInactive();
-#endif
 
                 // Now all task batches are done, apply all item adds to the outer 
                 // target batch; we do this even if the task wasn't found (in that case,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 8d830c38a0b..9222e6e9baf 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -33,7 +33,7 @@ internal class TaskHost :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        IBuildEngine7
+        IBuildEngine9
     {
         /// <summary>
         /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set.
@@ -361,6 +361,10 @@ public void Yield()
         /// </summary>
         public void Reacquire()
         {
+            // Release all cores on reacquire. The assumption here is that the task is done with CPU intensive work at this point and forgetting
+            // to release explicitly granted cores when reacquiring the node may lead to deadlocks.
+            ReleaseAllCores();
+
             lock (_callbackMonitor)
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
@@ -670,10 +674,198 @@ public IReadOnlyDictionary<string, string> GetGlobalProperties()
         #endregion
 
         #region IBuildEngine7 Members
+
         /// <summary>
         /// Enables or disables emitting a default error when a task fails without logging errors
         /// </summary>
         public bool AllowFailureWithoutError { get; set; } = false;
+
+        #endregion
+
+        #region IBuildEngine8 Members
+
+        private ICollection<string> _warningsAsErrors;
+
+        /// <summary>
+        /// Contains all warnings that should be logged as errors.
+        /// Non-null empty set when all warnings should be treated as errors.
+        /// </summary>
+        private ICollection<string> WarningsAsErrors
+        {
+            get
+            {
+                // Test compatibility
+                if(_taskLoggingContext == null)
+                {
+                    return null;
+                }
+
+                return _warningsAsErrors ??= _taskLoggingContext.GetWarningsAsErrors();
+            }
+        }
+
+        private ICollection<string> _warningsAsMessages;
+
+        /// <summary>
+        /// Contains all warnings that should be logged as errors.
+        /// Non-null empty set when all warnings should be treated as errors.
+        /// </summary>
+        private ICollection<string> WarningsAsMessages
+        {
+            get
+            {
+                // Test compatibility
+                if (_taskLoggingContext == null)
+                {
+                    return null;
+                }
+
+                return _warningsAsMessages ??= _taskLoggingContext.GetWarningsAsMessages();
+            }
+        }
+
+        /// <summary>
+        /// Determines if the given warning should be treated as an error.
+        /// </summary>
+        /// <param name="warningCode"></param>
+        /// <returns>True if the warning should not be treated as a message and WarningsAsErrors is an empty set or contains the given warning code.</returns>
+        public bool ShouldTreatWarningAsError(string warningCode)
+        {
+            // Warnings as messages overrides warnings as errors.
+            if (WarningsAsErrors == null || WarningsAsMessages?.Contains(warningCode) == true)
+            {
+                return false;
+            }
+
+            // An empty set means all warnings are errors.
+            return WarningsAsErrors.Count == 0 || WarningsAsErrors.Contains(warningCode);
+        }
+
+        #endregion
+
+        #region IBuildEngine9 Members
+
+        /// <summary>
+        /// Additional cores granted to the task by the scheduler. Does not include the one implicit core automatically granted to all tasks.
+        /// </summary>
+        private int _additionalAcquiredCores = 0;
+
+        /// <summary>
+        /// True if the one implicit core has been allocated by <see cref="RequestCores"/>, false otherwise.
+        /// </summary>
+        private bool _isImplicitCoreUsed = false;
+
+        /// <summary>
+        /// Total number of cores granted to the task, including the one implicit core.
+        /// </summary>
+        private int TotalAcquiredCores => _additionalAcquiredCores + (_isImplicitCoreUsed ? 1 : 0);
+
+        /// <summary>
+        /// Allocates shared CPU resources. Called by a task when it's about to do potentially multi-threaded/multi-process work.
+        /// </summary>
+        /// <param name="requestedCores">The number of cores the task wants to use.</param>
+        /// <returns>The number of cores the task is allowed to use given the current state of the build. This number is always between
+        /// 1 and <paramref name="requestedCores"/>. If the task has allocated its one implicit core, this call may block, waiting for
+        /// at least one core to become available.</returns>
+        public int RequestCores(int requestedCores)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(requestedCores > 0, nameof(requestedCores));
+
+            lock (_callbackMonitor)
+            {
+                IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
+
+                int coresAcquired = 0;
+                bool allocatingImplicitCore = false;
+                if (_isImplicitCoreUsed)
+                {
+                    coresAcquired = builderCallback.RequestCores(_callbackMonitor, requestedCores, waitForCores: true);
+                }
+                else
+                {
+                    _isImplicitCoreUsed = true;
+                    allocatingImplicitCore = true;
+                    if (requestedCores > 1)
+                    {
+                        coresAcquired = builderCallback.RequestCores(_callbackMonitor, requestedCores - 1, waitForCores: false);
+                    }
+                }
+                _additionalAcquiredCores += coresAcquired;
+
+                if (allocatingImplicitCore)
+                {
+                    // Pad the result with the one implicit core if it was still available.
+                    // This ensures that first call never blocks and always returns >= 1.
+                    coresAcquired++;
+                }
+
+                Debug.Assert(coresAcquired >= 1);
+                if (LoggingContext.IsValid)
+                {
+                    LoggingContext.LogComment(MessageImportance.Low, "TaskAcquiredCores", _taskLoggingContext.TaskName,
+                        requestedCores, coresAcquired, TotalAcquiredCores);
+                }
+                return coresAcquired;
+            }
+        }
+
+        /// <summary>
+        /// Frees shared CPU resources. Called by a task when it's finished doing multi-threaded/multi-process work.
+        /// </summary>
+        /// <param name="coresToRelease">The number of cores the task wants to return. This number must be between 0 and the number of cores
+        /// granted and not yet released.</param>
+        public void ReleaseCores(int coresToRelease)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(coresToRelease > 0, nameof(coresToRelease));
+
+            lock (_callbackMonitor)
+            {
+                int coresBeingReleased = coresToRelease;
+                int previousTotalAcquiredCores = TotalAcquiredCores;
+
+                if (_isImplicitCoreUsed && coresBeingReleased > _additionalAcquiredCores)
+                {
+                    // Release the implicit core last, i.e. only if we're asked to release everything.
+                    coresBeingReleased -= 1;
+                    _isImplicitCoreUsed = false;
+                }
+
+                coresBeingReleased = Math.Min(coresBeingReleased, _additionalAcquiredCores);
+                if (coresBeingReleased >= 1)
+                {
+                    IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
+                    builderCallback.ReleaseCores(coresBeingReleased);
+                    _additionalAcquiredCores -= coresBeingReleased;
+                }
+
+                if (LoggingContext.IsValid)
+                {
+                    if (TotalAcquiredCores == previousTotalAcquiredCores - coresToRelease)
+                    {
+                        LoggingContext.LogComment(MessageImportance.Low, "TaskReleasedCores", _taskLoggingContext.TaskName,
+                            coresToRelease, TotalAcquiredCores);
+                    }
+                    else
+                    {
+                        LoggingContext.LogComment(MessageImportance.Low, "TaskReleasedCoresWarning", _taskLoggingContext.TaskName,
+                            coresToRelease, previousTotalAcquiredCores, TotalAcquiredCores);
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Frees all CPU resources granted so far.
+        /// </summary>
+        internal void ReleaseAllCores()
+        {
+            int coresToRelease = TotalAcquiredCores;
+            if (coresToRelease > 0)
+            {
+                ReleaseCores(coresToRelease);
+            }
+        }
+
         #endregion
 
         /// <summary>
@@ -783,6 +975,7 @@ public override object InitializeLifetimeService()
                 return lease;
             }
         }
+#endif
 
         /// <summary>
         /// Indicates to the TaskHost that it is no longer needed.
@@ -795,6 +988,8 @@ internal void MarkAsInactive()
                 VerifyActiveProxy();
                 _activeProxy = false;
 
+                ReleaseAllCores();
+
                 // Since the task has a pointer to this class it may store it in a static field. Null out
                 // internal data so the leak of this object doesn't lead to a major memory leak.            
                 _host = null;
@@ -804,6 +999,7 @@ internal void MarkAsInactive()
                 _taskLoggingContext = null;
                 _targetBuilderCallback = null;
 
+#if FEATURE_APPDOMAIN
                 // Clear out the sponsor (who is responsible for keeping the EngineProxy remoting lease alive until the task is done)
                 // this will be null if the engine proxy was never sent across an AppDomain boundary.
                 if (_sponsor != null)
@@ -815,9 +1011,9 @@ internal void MarkAsInactive()
                     _sponsor.Close();
                     _sponsor = null;
                 }
+#endif
             }
         }
-#endif
 
         /// <summary>
         /// Determine if the event is serializable. If we are running with multiple nodes we need to make sure the logging events are serializable. If not
diff --git a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
index eb30122e633..de90369fabb 100644
--- a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections.Generic;
+using System.Threading.Tasks;
 using Microsoft.Build.Execution;
 
 namespace Microsoft.Build.BackEnd
@@ -68,5 +69,15 @@ internal interface IScheduler : IBuildComponent
         /// Writes a detailed summary of the build state which includes informaiton about the scheduling plan.
         /// </summary>
         void WriteDetailedSummary(int submissionId);
+
+        /// <summary>
+        /// Requests CPU resources.
+        /// </summary>
+        Task<int> RequestCores(int requestId, int requestedCores, bool waitForCores);
+
+        /// <summary>
+        /// Returns CPU resources.
+        /// </summary>
+        List<ScheduleResponse> ReleaseCores(int requestId, int coresToRelease);
     }
 }
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index 590cc2c74a9..9305abe7c66 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -290,6 +290,11 @@ public DateTime EndTime
             }
         }
 
+        /// <summary>
+        /// Number of cores granted as part of running the build request.
+        /// </summary>
+        public int GrantedCores { get; set; }
+
         /// <summary>
         /// Gets the amount of time we spent in the specified state.
         /// </summary>
@@ -629,9 +634,7 @@ private void CleanupForCircularDependencyAndThrow(SchedulableRequest requestCaus
         /// </summary>
         internal void DisconnectRequestWeAreBlockedBy(BlockingRequestKey blockingRequestKey)
         {
-            ErrorUtilities.VerifyThrow(_requestsWeAreBlockedBy.ContainsKey(blockingRequestKey), "We are not blocked by the specified request.");
-
-            SchedulableRequest unblockingRequest = _requestsWeAreBlockedBy[blockingRequestKey];
+            ErrorUtilities.VerifyThrow(_requestsWeAreBlockedBy.TryGetValue(blockingRequestKey, out SchedulableRequest unblockingRequest), "We are not blocked by the specified request.");
             ErrorUtilities.VerifyThrow(unblockingRequest._requestsWeAreBlocking.Contains(this), "The request unblocking us doesn't think it is blocking us.");
 
             _requestsWeAreBlockedBy.Remove(blockingRequestKey);
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 0ce340f4828..1e335cedb85 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -9,6 +9,7 @@
 using System.Linq;
 using System.Text;
 using System.Threading;
+using System.Threading.Tasks;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -70,6 +71,16 @@ internal class Scheduler : IScheduler
         /// </summary>
         private int _nodeLimitOffset;
 
+        /// <summary>
+        /// The result of calling NativeMethodsShared.GetLogicalCoreCount() unless overriden with MSBUILDCORELIMIT.
+        /// </summary>
+        private int _coreLimit;
+
+        /// <summary>
+        /// The weight of busy nodes in GetAvailableCoresForExplicitRequests().
+        /// </summary>
+        private int _nodeCoreAllocationWeight;
+
         /// <summary>
         /// { nodeId -> NodeInfo }
         /// A list of nodes we know about.  For the non-distributed case, there will be no more nodes than the
@@ -94,6 +105,11 @@ internal class Scheduler : IScheduler
         /// </summary>
         private SchedulingData _schedulingData;
 
+        /// <summary>
+        /// A queue of RequestCores requests waiting for at least one core to become available.
+        /// </summary>
+        private Queue<TaskCompletionSource<int>> _pendingRequestCoresCallbacks;
+
         #endregion
 
         /// <summary>
@@ -181,6 +197,23 @@ public Scheduler()
                 }
             }
 
+            // Resource management tuning knobs:
+            // 1) MSBUILDCORELIMIT is the maximum number of cores we hand out via IBuildEngine9.RequestCores.
+            //    Note that it is independent of build parallelism as given by /m on the command line.
+            if (!int.TryParse(Environment.GetEnvironmentVariable("MSBUILDCORELIMIT"), out _coreLimit) || _coreLimit <= 0)
+            {
+                _coreLimit = NativeMethodsShared.GetLogicalCoreCount();
+            }
+            // 1) MSBUILDNODECOREALLOCATIONWEIGHT is the weight with which executing nodes reduce the number of available cores.
+            //    Example: If the weight is 50, _coreLimit is 8, and there are 4 nodes that are busy executing build requests,
+            //    then the number of cores available via IBuildEngine9.RequestCores is 8 - (0.5 * 4) = 6.
+            if (!int.TryParse(Environment.GetEnvironmentVariable("MSBUILDNODECOREALLOCATIONWEIGHT"), out _nodeCoreAllocationWeight)
+                || _nodeCoreAllocationWeight <= 0
+                || _nodeCoreAllocationWeight > 100)
+            {
+                _nodeCoreAllocationWeight = 0;
+            }
+
             if (String.IsNullOrEmpty(_debugDumpPath))
             {
                 _debugDumpPath = Path.GetTempPath();
@@ -487,6 +520,7 @@ public void Reset()
             _schedulingPlan = null;
             _schedulingData = new SchedulingData();
             _availableNodes = new Dictionary<int, NodeInfo>(8);
+            _pendingRequestCoresCallbacks = new Queue<TaskCompletionSource<int>>();
             _currentInProcNodeCount = 0;
             _currentOutOfProcNodeCount = 0;
 
@@ -516,6 +550,53 @@ public void WriteDetailedSummary(int submissionId)
             WriteNodeUtilizationGraph(loggingService, context, false /* useConfigurations */);
         }
 
+        /// <summary>
+        /// Requests CPU resources.
+        /// </summary>
+        public Task<int> RequestCores(int requestId, int requestedCores, bool waitForCores)
+        {
+            if (requestedCores == 0)
+            {
+                return Task.FromResult(0);
+            }
+
+            Func<int, int> grantCores = (int availableCores) =>
+            {
+                int grantedCores = Math.Min(requestedCores, availableCores);
+                if (grantedCores > 0)
+                {
+                    _schedulingData.GrantCoresToRequest(requestId, grantedCores);
+                }
+                return grantedCores;
+            };
+
+            int grantedCores = grantCores(GetAvailableCoresForExplicitRequests());
+            if (grantedCores > 0 || !waitForCores)
+            {
+                return Task.FromResult(grantedCores);
+            }
+            else
+            {
+                // We have no cores to grant at the moment, queue up the request.
+                TaskCompletionSource<int> completionSource = new TaskCompletionSource<int>();
+                _pendingRequestCoresCallbacks.Enqueue(completionSource);
+                return completionSource.Task.ContinueWith((Task<int> task) => grantCores(task.Result), TaskContinuationOptions.ExecuteSynchronously);
+            }
+        }
+
+        /// <summary>
+        /// Returns CPU resources.
+        /// </summary>
+        public List<ScheduleResponse> ReleaseCores(int requestId, int coresToRelease)
+        {
+            _schedulingData.RemoveCoresFromRequest(requestId, coresToRelease);
+
+            // Releasing cores means that we may be able to schedule more work.
+            List<ScheduleResponse> responses = new List<ScheduleResponse>();
+            ScheduleUnassignedRequests(responses);
+            return responses;
+        }
+
         #endregion
 
         #region IBuildComponent Members
@@ -588,7 +669,8 @@ private void ScheduleUnassignedRequests(List<ScheduleResponse> responses)
                 }
                 else
                 {
-                    // Nodes still have work, but we have no requests.  Let them proceed.
+                    // Nodes still have work, but we have no requests.  Let them proceed and only handle resource requests.
+                    HandlePendingResourceRequests();
                     TraceScheduler("{0}: Waiting for existing work to proceed.", schedulingTime);
                 }
 
@@ -1269,6 +1351,21 @@ private void AssignUnscheduledRequestToNode(SchedulableRequest request, int node
             request.ResumeExecution(nodeId);
         }
 
+        /// <summary>
+        /// Returns the maximum number of cores that can be returned from a RequestCores() call at the moment.
+        /// </summary>
+        private int GetAvailableCoresForExplicitRequests()
+        {
+            // At least one core is always implicitly granted to the node making the request.
+            // If _nodeCoreAllocationWeight is more than zero, it can increase this value by the specified fraction of executing nodes.
+            int implicitlyGrantedCores = Math.Max(1, (_schedulingData.ExecutingRequestsCount * _nodeCoreAllocationWeight) / 100);
+
+            // The number of explicitly granted cores is a sum of everything we've granted via RequestCores() so far across all nodes.
+            int explicitlyGrantedCores = _schedulingData.ExplicitlyGrantedCores;
+
+            return Math.Max(0, _coreLimit - (implicitlyGrantedCores + explicitlyGrantedCores));
+        }
+
         /// <summary>
         /// Returns true if we are at the limit of work we can schedule.
         /// </summary>
@@ -1279,6 +1376,15 @@ private bool AtSchedulingLimit()
                 return false;
             }
 
+            // We're at our limit of schedulable requests if: 
+            // (1) MaxNodeCount requests are currently executing
+            if (_schedulingData.ExecutingRequestsCount >= _componentHost.BuildParameters.MaxNodeCount)
+            {
+                return true;
+            }
+
+            // (2) Fewer than MaxNodeCount requests are currently executing but the sum of executing request,
+            //     yielding requests, and explicitly granted cores exceeds the limit set out below.
             int limit = _componentHost.BuildParameters.MaxNodeCount switch
             {
                 1 => 1,
@@ -1286,12 +1392,9 @@ private bool AtSchedulingLimit()
                 _ => _componentHost.BuildParameters.MaxNodeCount + 2 + _nodeLimitOffset,
             };
 
-            // We're at our limit of schedulable requests if: 
-            // (1) MaxNodeCount requests are currently executing
-            // (2) Fewer than MaxNodeCount requests are currently executing but the sum of executing 
-            //     and yielding requests exceeds the limit set out above.  
-            return _schedulingData.ExecutingRequestsCount + _schedulingData.YieldingRequestsCount >= limit ||
-                   _schedulingData.ExecutingRequestsCount >= _componentHost.BuildParameters.MaxNodeCount;
+            return _schedulingData.ExecutingRequestsCount +
+                   _schedulingData.YieldingRequestsCount +
+                   _schedulingData.ExplicitlyGrantedCores >= limit;
         }
 
         /// <summary>
@@ -1716,6 +1819,25 @@ private void ResolveRequestFromCacheAndResumeIfPossible(SchedulableRequest reque
             }
         }
 
+        /// <summary>
+        /// Satisfies pending resource requests. Requests are pulled from the queue in FIFO fashion and granted as many cores
+        /// as possible, optimizing for maximum number of cores granted to a single request, not for maximum number of satisfied
+        /// requests.
+        /// </summary>
+        private void HandlePendingResourceRequests()
+        {
+            while (_pendingRequestCoresCallbacks.Count > 0)
+            {
+                int availableCores = GetAvailableCoresForExplicitRequests();
+                if (availableCores == 0)
+                {
+                    return;
+                }
+                TaskCompletionSource<int> completionSource = _pendingRequestCoresCallbacks.Dequeue();
+                completionSource.SetResult(availableCores);
+            }
+        }
+
         /// <summary>
         /// Determines which work is available which must be assigned to the nodes.  This includes:
         /// 1. Ready requests - those requests which can immediately resume executing.
@@ -1723,6 +1845,9 @@ private void ResolveRequestFromCacheAndResumeIfPossible(SchedulableRequest reque
         /// </summary>
         private void ResumeRequiredWork(List<ScheduleResponse> responses)
         {
+            // If we have pending RequestCore calls, satisfy those first.
+            HandlePendingResourceRequests();
+
             // Resume any ready requests on the existing nodes.
             foreach (int nodeId in _availableNodes.Keys)
             {
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
index 804ac117b8a..0edc83f296e 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
@@ -86,6 +87,15 @@ internal class SchedulingData
 
         #endregion
 
+        #region Resource management
+
+        /// <summary>
+        /// The sum of number of cores explicitly granted to all build requests.
+        /// </summary>
+        private int _grantedCores;
+
+        #endregion
+
         #region Diagnostic Information
 
         /// <summary>
@@ -152,6 +162,14 @@ public int ReadyRequestsCount
             get { return _readyRequests.Count; }
         }
 
+        /// <summary>
+        /// Gets the total number of cores granted to executing and yielding build requests.
+        /// </summary>
+        public int ExplicitlyGrantedCores
+        {
+            get { return _grantedCores; }
+        }
+
         /// <summary>
         /// Retrieves all of the blocked requests.
         /// </summary>
@@ -360,9 +378,9 @@ public void UpdateFromState(SchedulableRequest request, SchedulableRequestState
                     ErrorUtilities.VerifyThrow(_configurationToRequests.ContainsKey(request.BuildRequest.ConfigurationId), "Configuration {0} never had requests assigned to it.", request.BuildRequest.ConfigurationId);
                     ErrorUtilities.VerifyThrow(_configurationToRequests[request.BuildRequest.ConfigurationId].Count > 0, "Configuration {0} has no requests assigned to it.", request.BuildRequest.ConfigurationId);
                     _configurationToRequests[request.BuildRequest.ConfigurationId].Remove(request);
-                    if (_scheduledRequestsByNode.ContainsKey(request.AssignedNode))
+                    if (_scheduledRequestsByNode.TryGetValue(request.AssignedNode, out var requests))
                     {
-                        _scheduledRequestsByNode[request.AssignedNode].Remove(request);
+                        requests.Remove(request);
                     }
 
                     request.EndTime = EventTime;
@@ -477,7 +495,7 @@ public SchedulableRequest GetReadyRequest(int globalRequestId)
         }
 
         /// <summary>
-        /// Retrieves a request which has been assigned to a node and is in the executing, blocked or ready states.
+        /// Retrieves a request which has been assigned to a node and is in the executing, yielding, blocked, or ready states.
         /// </summary>
         public SchedulableRequest GetScheduledRequest(int globalRequestId)
         {
@@ -633,6 +651,33 @@ public bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId)
             return requiredNodeId == Scheduler.InvalidNodeId || requiredNodeId == nodeId;
         }
 
+        /// <summary>
+        /// Explicitly grants CPU cores to a request.
+        /// </summary>
+        public void GrantCoresToRequest(int globalRequestId, int coresToGrant)
+        {
+            // Update per-request state.
+            SchedulableRequest request = GetScheduledRequest(globalRequestId);
+            request.GrantedCores += coresToGrant;
+
+            // Update global state.
+            _grantedCores += coresToGrant;
+        }
+
+        /// <summary>
+        /// Explicitly removes previously granted CPU cores from a request.
+        /// </summary>
+        public void RemoveCoresFromRequest(int globalRequestId, int coresToRemove)
+        {
+            // Update per-request state.
+            SchedulableRequest request = GetScheduledRequest(globalRequestId);
+            coresToRemove = Math.Min(request.GrantedCores, coresToRemove);
+            request.GrantedCores -= coresToRemove;
+
+            // Update global state.
+            _grantedCores -= coresToRemove;
+        }
+
         /// <summary>
         /// Unassigns the node associated with a particular configuration.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index e0d472eea6e..97b4e83a02c 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -22,7 +22,15 @@ internal class SdkResolverLoader
 
         private readonly string IncludeDefaultResolver = Environment.GetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER");
 
-        private readonly string AdditionalResolversFolder = Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
+        //  Test hook for loading SDK Resolvers from additional folders.  Support runtime-specific test hook environment variables,
+        //  as an SDK resolver built for .NET Framework probably won't work on .NET Core, and vice versa.
+        private readonly string AdditionalResolversFolder = Environment.GetEnvironmentVariable(
+#if NETFRAMEWORK
+            "MSBUILDADDITIONALSDKRESOLVERSFOLDER_NETFRAMEWORK"
+#elif NET
+            "MSBUILDADDITIONALSDKRESOLVERSFOLDER_NET"
+#endif
+            ) ?? Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
 
         internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
             ElementLocation location)
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index 0a5db6abbb2..81b4ab63279 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -17,7 +17,7 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// This class represents an implementation of INode for out-of-proc nodes.
+    /// This class represents an implementation of INode for in-proc nodes.
     /// </summary>
     internal class InProcNode : INode, INodePacketFactory
     {
@@ -96,6 +96,11 @@ internal class InProcNode : INode, INodePacketFactory
         /// </summary>
         private readonly RequestCompleteDelegate _requestCompleteEventHandler;
 
+        /// <summary>
+        /// Handler for resource request events.
+        /// </summary>
+        private readonly ResourceRequestDelegate _resourceRequestHandler;
+
         /// <summary>
         /// Constructor.
         /// </summary>
@@ -113,6 +118,7 @@ public InProcNode(IBuildComponentHost componentHost, INodeEndpoint inProcNodeEnd
             _newConfigurationRequestEventHandler = OnNewConfigurationRequest;
             _requestBlockedEventHandler = OnNewRequest;
             _requestCompleteEventHandler = OnRequestComplete;
+            _resourceRequestHandler = OnResourceRequest;
         }
 
         #region INode Members
@@ -260,6 +266,17 @@ private void OnNewConfigurationRequest(BuildRequestConfiguration config)
             }
         }
 
+        /// <summary>
+        /// Event handler for the BuildEngine's OnResourceRequest event.
+        /// </summary>
+        private void OnResourceRequest(ResourceRequest request)
+        {
+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
+            {
+                _nodeEndpoint.SendData(request);
+            }
+        }
+
         /// <summary>
         /// Event handler for the LoggingService's OnLoggingThreadException event.
         /// </summary>
@@ -354,6 +371,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             _buildRequestEngine.OnNewConfigurationRequest -= _newConfigurationRequestEventHandler;
             _buildRequestEngine.OnRequestBlocked -= _requestBlockedEventHandler;
             _buildRequestEngine.OnRequestComplete -= _requestCompleteEventHandler;
+            _buildRequestEngine.OnResourceRequest -= _resourceRequestHandler;
 
             return _shutdownReason;
         }
@@ -388,6 +406,10 @@ private void HandlePacket(INodePacket packet)
                 case NodePacketType.NodeBuildComplete:
                     HandleNodeBuildComplete(packet as NodeBuildComplete);
                     break;
+
+                case NodePacketType.ResourceResponse:
+                    HandleResourceResponse(packet as ResourceResponse);
+                    break;
             }
         }
 
@@ -482,6 +504,7 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
             _buildRequestEngine.OnNewConfigurationRequest += _newConfigurationRequestEventHandler;
             _buildRequestEngine.OnRequestBlocked += _requestBlockedEventHandler;
             _buildRequestEngine.OnRequestComplete += _requestCompleteEventHandler;
+            _buildRequestEngine.OnResourceRequest += _resourceRequestHandler;
 
             if (_shutdownException != null)
             {
@@ -500,5 +523,13 @@ private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
             _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;
             _shutdownEvent.Set();
         }
+
+        /// <summary>
+        /// Handles the ResourceResponse packet.
+        /// </summary>
+        private void HandleResourceResponse(ResourceResponse response)
+        {
+            _buildRequestEngine.GrantResources(response);
+        }
     }
 }
diff --git a/src/Build/BackEnd/Node/NodeConfiguration.cs b/src/Build/BackEnd/Node/NodeConfiguration.cs
index 5cb25db468c..029b1814605 100644
--- a/src/Build/BackEnd/Node/NodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/NodeConfiguration.cs
@@ -40,7 +40,7 @@ internal class NodeConfiguration : INodePacket
         /// </summary>
         private LoggingNodeConfiguration _loggingNodeConfiguration;
 
-#if FEATURE_APPDOMAIN
+#pragma warning disable 1572 // appDomainSetup not always there
         /// <summary>
         /// Constructor
         /// </summary>
@@ -54,38 +54,21 @@ public NodeConfiguration
             int nodeId,
             BuildParameters buildParameters,
             LoggerDescription[] forwardingLoggers,
+#if FEATURE_APPDOMAIN
             AppDomainSetup appDomainSetup,
+#endif
             LoggingNodeConfiguration loggingNodeConfiguration
             )
         {
             _nodeId = nodeId;
             _buildParameters = buildParameters;
             _forwardingLoggers = forwardingLoggers;
+#if FEATURE_APPDOMAIN
             _appDomainSetup = appDomainSetup;
+#endif
             _loggingNodeConfiguration = loggingNodeConfiguration;
         }
-#else
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        /// <param name="nodeId">The node id.</param>
-        /// <param name="buildParameters">The build parameters</param>
-        /// <param name="forwardingLoggers">The forwarding loggers.</param>
-        /// <param name="loggingNodeConfiguration">The logging configuration for the node.</param>
-        public NodeConfiguration
-            (
-            int nodeId,
-            BuildParameters buildParameters,
-            LoggerDescription[] forwardingLoggers,
-            LoggingNodeConfiguration loggingNodeConfiguration
-            )
-        {
-            _nodeId = nodeId;
-            _buildParameters = buildParameters;
-            _forwardingLoggers = forwardingLoggers;
-            _loggingNodeConfiguration = loggingNodeConfiguration;
-        }
-#endif
+#pragma warning restore
 
         /// <summary>
         /// Private constructor for deserialization
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 0ae529953d0..d70930c1493 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -171,6 +171,7 @@ public OutOfProcNode()
             _buildRequestEngine.OnNewConfigurationRequest += OnNewConfigurationRequest;
             _buildRequestEngine.OnRequestBlocked += OnNewRequest;
             _buildRequestEngine.OnRequestComplete += OnRequestComplete;
+            _buildRequestEngine.OnResourceRequest += OnResourceRequest;
 
             (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.BuildRequest, BuildRequest.FactoryForDeserialization, this);
             (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.BuildRequestConfiguration, BuildRequestConfiguration.FactoryForDeserialization, this);
@@ -178,6 +179,7 @@ public OutOfProcNode()
             (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.BuildRequestUnblocker, BuildRequestUnblocker.FactoryForDeserialization, this);
             (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeConfiguration, NodeConfiguration.FactoryForDeserialization, this);
             (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);
+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ResourceResponse, ResourceResponse.FactoryForDeserialization, this);
             (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ResolveSdkResponse, SdkResult.FactoryForDeserialization, _sdkResolverService as INodePacketHandler);
         }
 
@@ -398,6 +400,17 @@ private void OnNewConfigurationRequest(BuildRequestConfiguration config)
             }
         }
 
+        /// <summary>
+        /// Event handler for the BuildEngine's OnResourceRequest event.
+        /// </summary>
+        private void OnResourceRequest(ResourceRequest request)
+        {
+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
+            {
+                _nodeEndpoint.SendData(request);
+            }
+        }
+
         /// <summary>
         /// Event handler for the LoggingService's OnLoggingThreadException event.
         /// </summary>
@@ -594,6 +607,10 @@ private void HandlePacket(INodePacket packet)
                     HandleBuildRequestUnblocker(packet as BuildRequestUnblocker);
                     break;
 
+                case NodePacketType.ResourceResponse:
+                    HandleResourceResponse(packet as ResourceResponse);
+                    break;
+
                 case NodePacketType.NodeConfiguration:
                     HandleNodeConfiguration(packet as NodeConfiguration);
                     break;
@@ -636,6 +653,15 @@ private void HandleBuildRequestUnblocker(BuildRequestUnblocker unblocker)
             _buildRequestEngine.UnblockBuildRequest(unblocker);
         }
 
+        /// <summary>
+        /// Handles the ResourceResponse packet.
+        /// </summary>
+        /// <param name="response"></param>
+        private void HandleResourceResponse(ResourceResponse response)
+        {
+            _buildRequestEngine.GrantResources(response);
+        }
+
         /// <summary>
         /// Handles the NodeConfiguration packet.
         /// </summary>
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index ec989c4e92d..67138103af8 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -470,9 +470,9 @@ public void AddResultsForTarget(string target, TargetResult result)
                 _resultsByTarget ??= CreateTargetResultDictionary(1);
             }
 
-            if (_resultsByTarget.ContainsKey(target))
+            if (_resultsByTarget.TryGetValue(target, out TargetResult targetResult))
             {
-                ErrorUtilities.VerifyThrow(_resultsByTarget[target].ResultCode == TargetResultCode.Skipped, "Items already exist for target {0}.", target);
+                ErrorUtilities.VerifyThrow(targetResult.ResultCode == TargetResultCode.Skipped, "Items already exist for target {0}.", target);
             }
 
             _resultsByTarget[target] = result;
diff --git a/src/Build/BackEnd/Shared/ResourceRequest.cs b/src/Build/BackEnd/Shared/ResourceRequest.cs
new file mode 100644
index 00000000000..815eedb9200
--- /dev/null
+++ b/src/Build/BackEnd/Shared/ResourceRequest.cs
@@ -0,0 +1,111 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// This packet is sent by a node to request or release resources from/to the scheduler.
+    /// </summary>
+    internal sealed class ResourceRequest : INodePacket
+    {
+        /// <summary>
+        /// The global request id of the request which is asking for resources.
+        /// </summary>
+        private int _globalRequestId;
+
+        /// <summary>
+        /// True if this is a request to acquire resources, false if this is a request to release resources.
+        /// </summary>
+        private bool _isResourceAcquire;
+
+        /// <summary>
+        /// True if the request should be blocking until the resources become available. False if the request should
+        /// be responded to immediately even if the desired resources are not available.
+        /// </summary>
+        private bool _isBlocking;
+
+        /// <summary>
+        /// Number of CPU cores being requested or released.
+        /// </summary>
+        private int _numCores;
+
+        /// <summary>
+        /// Constructor for deserialization.
+        /// </summary>
+        internal ResourceRequest(ITranslator translator)
+        {
+            Translate(translator);
+        }
+
+        /// <summary>
+        /// Private constructor, use CreateAcquireRequest or CreateReleaseRequest to make instances.
+        /// </summary>
+        private ResourceRequest(bool isResourceAcquire, int globalRequestId, int numCores, bool isBlocking)
+        {
+            _isResourceAcquire = isResourceAcquire;
+            _isBlocking = isBlocking;
+            _globalRequestId = globalRequestId;
+            _numCores = numCores;
+        }
+
+        /// <summary>
+        /// Factory method for acquiring.
+        /// </summary>
+        public static ResourceRequest CreateAcquireRequest(int globalRequestId, int numCores, bool isBlocking)
+            => new ResourceRequest(isResourceAcquire: true, globalRequestId, numCores, isBlocking);
+
+        /// <summary>
+        /// Factory method for releasing.
+        /// </summary>
+        public static ResourceRequest CreateReleaseRequest(int globalRequestId, int numCores)
+            => new ResourceRequest(isResourceAcquire: false, globalRequestId, numCores, isBlocking: false);
+
+        /// <summary>
+        /// Returns the type of packet.
+        /// </summary>
+        public NodePacketType Type => NodePacketType.ResourceRequest;
+
+        /// <summary>
+        /// Accessor for the global request id.
+        /// </summary>
+        public int GlobalRequestId => _globalRequestId;
+
+        /// <summary>
+        /// Accessor for _isResourceAcquire.
+        /// </summary>
+        public bool IsResourceAcquire => _isResourceAcquire;
+
+        /// <summary>
+        /// Accessor fro _isBlocking.
+        /// </summary>
+        public bool IsBlocking => _isBlocking;
+
+        /// <summary>
+        /// Accessor for _numCores.
+        /// </summary>
+        public int NumCores => _numCores;
+
+        #region INodePacketTranslatable Members
+
+        /// <summary>
+        /// Serialization method.
+        /// </summary>
+        public void Translate(ITranslator translator)
+        {
+            translator.Translate(ref _globalRequestId);
+            translator.Translate(ref _isResourceAcquire);
+            translator.Translate(ref _isBlocking);
+            translator.Translate(ref _numCores);
+        }
+
+        #endregion
+
+        /// <summary>
+        /// Factory for serialization.
+        /// </summary>
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            return new ResourceRequest(translator);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Shared/ResourceResponse.cs b/src/Build/BackEnd/Shared/ResourceResponse.cs
new file mode 100644
index 00000000000..22fcefef30f
--- /dev/null
+++ b/src/Build/BackEnd/Shared/ResourceResponse.cs
@@ -0,0 +1,74 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// This packet is sent by the scheduler in response to <see cref="ResourceRequest"/> to grant resources to a node.
+    /// </summary>
+    internal sealed class ResourceResponse : INodePacket
+    {
+        /// <summary>
+        /// The global request id of the request which is being responded to.
+        /// </summary>
+        private int _globalRequestId;
+
+        /// <summary>
+        /// Number of CPU cores being granted.
+        /// </summary>
+        private int _numCores;
+
+        /// <summary>
+        /// Constructor for deserialization.
+        /// </summary>
+        internal ResourceResponse(ITranslator translator)
+        {
+            Translate(translator);
+        }
+
+        /// <summary>
+        /// Constructor for granting cores.
+        /// </summary>
+        internal ResourceResponse(int globalRequestId, int numCores)
+        {
+            _globalRequestId = globalRequestId;
+            _numCores = numCores;
+        }
+
+        /// <summary>
+        /// Returns the type of packet.
+        /// </summary>
+        public NodePacketType Type => NodePacketType.ResourceResponse;
+
+        /// <summary>
+        /// Accessor for the global request id.
+        /// </summary>
+        public int GlobalRequestId => _globalRequestId;
+
+        /// <summary>
+        /// Accessor for _numCores.
+        /// </summary>
+        public int NumCores => _numCores;
+
+        #region INodePacketTranslatable Members
+
+        /// <summary>
+        /// Serialization method.
+        /// </summary>
+        public void Translate(ITranslator translator)
+        {
+            translator.Translate(ref _globalRequestId);
+            translator.Translate(ref _numCores);
+        }
+
+        #endregion
+
+        /// <summary>
+        /// Factory for serialization.
+        /// </summary>
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            return new ResourceResponse(translator);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 9a329a707b5..dc75cd9496e 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -24,6 +24,7 @@
 using Microsoft.Build.Utilities;
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
+using Task = System.Threading.Tasks.Task;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -1332,12 +1333,12 @@ private bool InternalSetTaskParameter(TaskPropertyInfo parameter, IList paramete
                 parameterValue.Count > 0 &&
                 parameter.Log)
             {
-                string parameterText = ItemGroupLoggingHelper.GetParameterText(
-                    ItemGroupLoggingHelper.TaskParameterPrefix,
+                ItemGroupLoggingHelper.LogTaskParameter(
+                    _taskLoggingContext,
+                    TaskParameterMessageKind.TaskInput,
                     parameter.Name,
                     parameterValue,
                     parameter.LogItemMetadata);
-                _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
             }
 
             return InternalSetTaskParameter(parameter, (object)parameterValue);
@@ -1425,11 +1426,16 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
             {
                 if (outputTargetIsItem)
                 {
+                    // Only count non-null elements. We sometimes have a single-element array where the element is null
+                    bool hasElements = false;
+
                     foreach (ITaskItem output in outputs)
                     {
                         // if individual items in the array are null, ignore them
                         if (output != null)
                         {
+                            hasElements = true;
+
                             ProjectItemInstance newItem;
 
                             TaskItem outputAsProjectItem = output as TaskItem;
@@ -1473,15 +1479,14 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                         }
                     }
 
-                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0 && parameter.Log)
+                    if (hasElements && LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && parameter.Log)
                     {
-                        string parameterText = ItemGroupLoggingHelper.GetParameterText(
-                            ItemGroupLoggingHelper.OutputItemParameterMessagePrefix,
+                        ItemGroupLoggingHelper.LogTaskParameter(
+                            _taskLoggingContext,
+                            TaskParameterMessageKind.TaskOutput,
                             outputTargetName,
                             outputs,
                             parameter.LogItemMetadata);
-
-                        _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
                     }
                 }
                 else
@@ -1552,12 +1557,12 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
 
                     if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0 && parameter.Log)
                     {
-                        string parameterText = ItemGroupLoggingHelper.GetParameterText(
-                            ItemGroupLoggingHelper.OutputItemParameterMessagePrefix,
+                        ItemGroupLoggingHelper.LogTaskParameter(
+                            _taskLoggingContext,
+                            TaskParameterMessageKind.TaskOutput,
                             outputTargetName,
                             outputs,
                             parameter.LogItemMetadata);
-                        _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
                     }
                 }
                 else
diff --git a/src/Build/Collections/ArrayDictionary.cs b/src/Build/Collections/ArrayDictionary.cs
new file mode 100644
index 00000000000..9cdf1d7a0e1
--- /dev/null
+++ b/src/Build/Collections/ArrayDictionary.cs
@@ -0,0 +1,261 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Lightweight, read-only IDictionary implementation using two arrays
+    /// and O(n) lookup.
+    /// Requires specifying capacity at construction and does not
+    /// support reallocation to increase capacity.
+    /// </summary>
+    /// <typeparam name="TKey">Type of keys</typeparam>
+    /// <typeparam name="TValue">Type of values</typeparam>
+    internal class ArrayDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary
+    {
+        private TKey[] keys;
+        private TValue[] values;
+
+        private int count;
+
+        public ArrayDictionary(int capacity)
+        {
+            keys = new TKey[capacity];
+            values = new TValue[capacity];
+        }
+
+        public static IDictionary<TKey, TValue> Create(int capacity)
+        {
+            return new ArrayDictionary<TKey, TValue>(capacity);
+        }
+
+        public TValue this[TKey key]
+        {
+            get
+            {
+                TryGetValue(key, out var value);
+                return value;
+            }
+
+            set
+            {
+                var comparer = KeyComparer;
+                for (int i = 0; i < count; i++)
+                {
+                    if (comparer.Equals(key, keys[i]))
+                    {
+                        values[i] = value;
+                        return;
+                    }
+                }
+
+                Add(key, value);
+            }
+        }
+
+        object IDictionary.this[object key]
+        {
+            get => this[(TKey)key];
+            set => this[(TKey)key] = (TValue)value;
+        }
+
+        public ICollection<TKey> Keys => keys;
+
+        ICollection IDictionary.Keys => keys;
+
+        public ICollection<TValue> Values => values;
+
+        ICollection IDictionary.Values => values;
+
+        private IEqualityComparer<TKey> KeyComparer => EqualityComparer<TKey>.Default;
+
+        private IEqualityComparer<TValue> ValueComparer => EqualityComparer<TValue>.Default;
+
+        public int Count => count;
+
+        public bool IsReadOnly => true;
+
+        bool IDictionary.IsFixedSize => true;
+
+        object ICollection.SyncRoot => this;
+
+        bool ICollection.IsSynchronized => false;
+
+        public void Add(TKey key, TValue value)
+        {
+            if (count < keys.Length)
+            {
+                keys[count] = key;
+                values[count] = value;
+                count += 1;
+            }
+            else
+            {
+                throw new InvalidOperationException($"ArrayDictionary is at capacity {keys.Length}");
+            }
+        }
+
+        public void Add(KeyValuePair<TKey, TValue> item)
+        {
+            Add(item.Key, item.Value);
+        }
+
+        public void Clear()
+        {
+            throw new System.NotImplementedException();
+        }
+
+        public bool Contains(KeyValuePair<TKey, TValue> item)
+        {
+            var keyComparer = KeyComparer;
+            var valueComparer = ValueComparer;
+            for (int i = 0; i < count; i++)
+            {
+                if (keyComparer.Equals(item.Key, keys[i]) && valueComparer.Equals(item.Value, values[i]))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        public bool ContainsKey(TKey key)
+        {
+            var comparer = KeyComparer;
+            for (int i = 0; i < count; i++)
+            {
+                if (comparer.Equals(key, keys[i]))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
+        {
+            for (int i = 0; i < count; i++)
+            {
+                array[arrayIndex + i] = new KeyValuePair<TKey, TValue>(keys[i], values[i]);
+            }
+        }
+
+        void ICollection.CopyTo(Array array, int index)
+        {
+            throw new NotImplementedException();
+        }
+
+        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
+        {
+            return new Enumerator(this);
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
+
+        IDictionaryEnumerator IDictionary.GetEnumerator()
+        {
+            return new Enumerator(this, emitDictionaryEntries: true);
+        }
+
+        public bool Remove(TKey key)
+        {
+            throw new System.NotImplementedException();
+        }
+
+        public bool Remove(KeyValuePair<TKey, TValue> item)
+        {
+            throw new System.NotImplementedException();
+        }
+
+        public bool TryGetValue(TKey key, out TValue value)
+        {
+            var comparer = KeyComparer;
+            for (int i = 0; i < count; i++)
+            {
+                if (comparer.Equals(key, keys[i]))
+                {
+                    value = values[i];
+                    return true;
+                }
+            }
+
+            value = default;
+            return false;
+        }
+
+        bool IDictionary.Contains(object key)
+        {
+            if (key is not TKey typedKey)
+            {
+                return false;
+            }
+
+            return ContainsKey(typedKey);
+        }
+
+        void IDictionary.Add(object key, object value)
+        {
+            if (key is TKey typedKey && value is TValue typedValue)
+            {
+                Add(typedKey, typedValue);
+            }
+
+            throw new NotSupportedException();
+        }
+
+        void IDictionary.Remove(object key)
+        {
+            throw new NotImplementedException();
+        }
+
+        private struct Enumerator : IEnumerator<KeyValuePair<TKey, TValue>>, IDictionaryEnumerator
+        {
+            private readonly ArrayDictionary<TKey, TValue> _dictionary;
+            private readonly bool _emitDictionaryEntries;
+            private int _position;
+
+            public Enumerator(ArrayDictionary<TKey, TValue> dictionary, bool emitDictionaryEntries = false)
+            {
+                this._dictionary = dictionary;
+                this._position = -1;
+                this._emitDictionaryEntries = emitDictionaryEntries;
+            }
+
+            public KeyValuePair<TKey, TValue> Current =>
+                new KeyValuePair<TKey, TValue>(
+                    _dictionary.keys[_position],
+                    _dictionary.values[_position]);
+
+            private DictionaryEntry CurrentDictionaryEntry => new DictionaryEntry(_dictionary.keys[_position], _dictionary.values[_position]);
+
+            object IEnumerator.Current => _emitDictionaryEntries ? CurrentDictionaryEntry : Current;
+
+            object IDictionaryEnumerator.Key => _dictionary.keys[_position];
+
+            object IDictionaryEnumerator.Value => _dictionary.values[_position];
+
+            DictionaryEntry IDictionaryEnumerator.Entry => CurrentDictionaryEntry;
+
+            public void Dispose()
+            {
+            }
+
+            public bool MoveNext()
+            {
+                _position += 1;
+                return _position < _dictionary.Count;
+            }
+
+            public void Reset()
+            {
+                throw new NotImplementedException();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 08a7def219e..80d7bdaad22 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -168,11 +168,26 @@ public string AbsolutePath
             {
                 if (_absolutePath == null)
                 {
+                    _absolutePath = Path.Combine(ParentSolution.SolutionFileDirectory, _relativePath);
+
+                    // For web site projects, Visual Studio stores the URL of the site as the relative path so it cannot be normalized.
+                    // Legacy behavior dictates that we must just return the result of Path.Combine()
+                    if (!Uri.TryCreate(_relativePath, UriKind.Absolute, out Uri _))
+                    {
+                        try
+                        {
 #if NETFRAMEWORK && !MONO
-                    _absolutePath = Path.GetFullPath(Path.Combine(ParentSolution.SolutionFileDirectory, _relativePath));
+                            _absolutePath = Path.GetFullPath(_absolutePath);
 #else
-                    _absolutePath = FileUtilities.NormalizePath(Path.Combine(ParentSolution.SolutionFileDirectory, _relativePath));
+                            _absolutePath = FileUtilities.NormalizePath(_absolutePath);
 #endif
+                        }
+                        catch (Exception)
+                        {
+                            // The call to GetFullPath() can throw if the relative path is some unsupported value or the paths are too long for the current file system
+                            // This falls back to previous behavior of returning a path that may not be correct but at least returns some value
+                        }
+                    }
                 }
 
                 return _absolutePath;
@@ -229,9 +244,9 @@ public IReadOnlyDictionary<string, ProjectConfigurationInSolution> ProjectConfig
 
         internal string TargetFrameworkMoniker { get; set; }
 
-#endregion
+        #endregion
 
-#region Methods
+        #region Methods
 
         private bool _checkedIfCanBeMSBuildProjectFile;
         private bool _canBeMSBuildProjectFile;
@@ -529,13 +544,13 @@ private static bool ElementContainsInvalidNamespaceDefitions(XmlElement mainProj
             return false;
         }
 
-#endregion
+        #endregion
 
-#region Constants
+        #region Constants
 
         internal const int DependencyLevelUnknown = -1;
         internal const int DependencyLevelBeingDetermined = -2;
 
-#endregion
+        #endregion
     }
 }
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index c365c1ee730..7de69fea0c3 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -189,6 +189,11 @@ internal int VisualStudioVersion
         /// </summary>
         public IReadOnlyDictionary<string, ProjectInSolution> ProjectsByGuid => new ReadOnlyDictionary<string, ProjectInSolution>(_projects);
 
+        /// <summary>
+        /// This is the read accessor for the solution filter file, if present. Set through FullPath.
+        /// </summary>
+        internal string SolutionFilterFilePath { get => _solutionFilterFile; }
+
         /// <summary>
         /// This is the read/write accessor for the solution file which we will parse.  This
         /// must be set before calling any other methods on this class.
@@ -612,7 +617,7 @@ internal void ParseSolution()
                 }
 
                 // Detect collision caused by unique name's normalization
-                if (projectsByUniqueName.ContainsKey(uniqueName))
+                if (projectsByUniqueName.TryGetValue(uniqueName, out ProjectInSolution project))
                 {
                     // Did normalization occur in the current project?
                     if (uniqueName != proj.ProjectName)
@@ -623,16 +628,14 @@ internal void ParseSolution()
                         uniqueName = tempUniqueName;
                     }
                     // Did normalization occur in a previous project?
-                    else if (uniqueName != projectsByUniqueName[uniqueName].ProjectName)
+                    else if (uniqueName != project.ProjectName)
                     {
-                        var projTemp = projectsByUniqueName[uniqueName];
-
                         // Generates a new unique name
-                        string tempUniqueName = $"{uniqueName}_{projTemp.GetProjectGuidWithoutCurlyBrackets()}";
-                        projTemp.UpdateUniqueProjectName(tempUniqueName);
+                        string tempUniqueName = $"{uniqueName}_{project.GetProjectGuidWithoutCurlyBrackets()}";
+                        project.UpdateUniqueProjectName(tempUniqueName);
 
                         projectsByUniqueName.Remove(uniqueName);
-                        projectsByUniqueName.Add(tempUniqueName, projTemp);
+                        projectsByUniqueName.Add(tempUniqueName, project);
                     }
                 }
 
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index d26fca3b0d3..d291d172bde 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -52,7 +52,7 @@ internal class SolutionProjectGenerator
         /// <summary>
         /// The set of properties all projects in the solution should be built with
         /// </summary>
-        private const string SolutionProperties = "BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)";
+        private const string SolutionProperties = "BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionFilterName=$(SolutionFilterName); SolutionPath=$(SolutionPath)";
 
         /// <summary>
         /// The set of properties which identify the configuration and platform to build a project with
@@ -94,6 +94,7 @@ internal class SolutionProjectGenerator
             new Tuple<string, string>("SolutionExt", null),
             new Tuple<string, string>("SolutionFileName", null),
             new Tuple<string, string>("SolutionName", null),
+            new Tuple<string, string>("SolutionFilterName", null),
             new Tuple<string, string>(SolutionPathPropertyName, null)
         };
 
@@ -499,7 +500,7 @@ bool specifyProjectToolsVersion
 
             string additionalProperties = string.Format(
                 CultureInfo.InvariantCulture,
-                "Configuration={0}; Platform={1}; BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)",
+                "Configuration={0}; Platform={1}; BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionFilterName=$(SolutionFilterName); SolutionPath=$(SolutionPath)",
                 EscapingUtilities.Escape(configurationName),
                 EscapingUtilities.Escape(platformName)
             );
@@ -782,7 +783,7 @@ private void EvaluateAndAddProjects(List<ProjectInSolution> projectsInOrder, Lis
                 AddTraversalTargetForProject(traversalInstance, project, projectConfiguration, "Publish", null, canBuildDirectly);
 
                 // Add any other targets specified by the user that were not already added
-                foreach (string targetName in _targetNames.Where(i => !traversalInstance.Targets.ContainsKey(i)))
+                foreach (string targetName in _targetNames.Except(traversalInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
                 {
                     AddTraversalTargetForProject(traversalInstance, project, projectConfiguration, targetName, null, canBuildDirectly);
                 }
@@ -796,7 +797,7 @@ private void EvaluateAndAddProjects(List<ProjectInSolution> projectsInOrder, Lis
             }
 
             // Add any other targets specified by the user that were not already added
-            foreach (string targetName in _targetNames.Where(i => !traversalInstance.Targets.ContainsKey(i)))
+            foreach (string targetName in _targetNames.Except(traversalInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
             {
                 AddTraversalReferencesTarget(traversalInstance, targetName, null);
             }
@@ -1201,7 +1202,7 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
                 AddMetaprojectTargetForWebProject(traversalProject, metaprojectInstance, project, "Rebuild");
                 AddMetaprojectTargetForWebProject(traversalProject, metaprojectInstance, project, "Publish");
 
-                foreach (string targetName in _targetNames.Where(i => !metaprojectInstance.Targets.ContainsKey(i)))
+                foreach (string targetName in _targetNames.Except(metaprojectInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
                 {
                     AddMetaprojectTargetForWebProject(traversalProject, metaprojectInstance, project, targetName);
                 }
@@ -1221,7 +1222,7 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
                 AddMetaprojectTargetForManagedProject(traversalProject, metaprojectInstance, project, projectConfiguration, "Rebuild", targetOutputItemName);
                 AddMetaprojectTargetForManagedProject(traversalProject, metaprojectInstance, project, projectConfiguration, "Publish", null);
 
-                foreach (string targetName in _targetNames.Where(i => !metaprojectInstance.Targets.ContainsKey(i)))
+                foreach (string targetName in _targetNames.Except(metaprojectInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
                 {
                     AddMetaprojectTargetForManagedProject(traversalProject, metaprojectInstance, project, projectConfiguration, targetName, null);
                 }
@@ -1233,7 +1234,7 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
                 AddMetaprojectTargetForUnknownProjectType(traversalProject, metaprojectInstance, project, "Rebuild", unknownProjectTypeErrorMessage);
                 AddMetaprojectTargetForUnknownProjectType(traversalProject, metaprojectInstance, project, "Publish", unknownProjectTypeErrorMessage);
 
-                foreach (string targetName in _targetNames.Where(i => !metaprojectInstance.Targets.ContainsKey(i)))
+                foreach (string targetName in _targetNames.Except(metaprojectInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
                 {
                     AddMetaprojectTargetForUnknownProjectType(traversalProject, metaprojectInstance, project, targetName, unknownProjectTypeErrorMessage);
                 }
@@ -2291,6 +2292,7 @@ private void AddGlobalProperties(ProjectRootElement traversalProject)
             globalProperties.AddProperty("SolutionExt", EscapingUtilities.Escape(Path.GetExtension(_solutionFile.FullPath)));
             globalProperties.AddProperty("SolutionFileName", EscapingUtilities.Escape(Path.GetFileName(_solutionFile.FullPath)));
             globalProperties.AddProperty("SolutionName", EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(_solutionFile.FullPath)));
+            globalProperties.AddProperty("SolutionFilterName", EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(_solutionFile.SolutionFilterFilePath ?? string.Empty)));
 
             globalProperties.AddProperty(SolutionPathPropertyName, EscapingUtilities.Escape(Path.Combine(_solutionFile.SolutionFileDirectory, Path.GetFileName(_solutionFile.FullPath))));
 
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 285c4cc592a..f158ca5a2bb 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2564,10 +2564,10 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                 IEnumerable<string> removeFragmentStrings = Enumerable.Empty<string>();
                 IMSBuildGlob removeGlob = null;
 
-                if (removeElementCache.ContainsKey(itemElement.ItemType))
+                if (removeElementCache.TryGetValue(itemElement.ItemType, out CumulativeRemoveElementData removeItemElement))
                 {
-                    removeFragmentStrings = removeElementCache[itemElement.ItemType].FragmentStrings;
-                    removeGlob = new CompositeGlob(removeElementCache[itemElement.ItemType].Globs);
+                    removeFragmentStrings = removeItemElement.FragmentStrings;
+                    removeGlob = new CompositeGlob(removeItemElement.Globs);
                 }
 
                 var includeGlobWithGaps = CreateIncludeGlobWithGaps(includeGlob, excludeGlob, removeGlob);
@@ -2577,27 +2577,17 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
 
             private static IMSBuildGlob CreateIncludeGlobWithGaps(IMSBuildGlob includeGlob, IMSBuildGlob excludeGlob, IMSBuildGlob removeGlob)
             {
-                if (excludeGlob != null && removeGlob != null)
+                if (excludeGlob == null)
                 {
-                    return new MSBuildGlobWithGaps(
-                        includeGlob,
-                        new CompositeGlob(
-                            excludeGlob,
-                            removeGlob
-                        ));
+                    return removeGlob == null ? includeGlob :
+                        new MSBuildGlobWithGaps(includeGlob, removeGlob);
                 }
-
-                if (excludeGlob != null || removeGlob != null)
+                else
                 {
-                    var gapGlob = excludeGlob ?? removeGlob;
-
-                    return new MSBuildGlobWithGaps(
-                        includeGlob,
-                        gapGlob
-                    );
+                    return new MSBuildGlobWithGaps(includeGlob,
+                        removeGlob == null ? excludeGlob :
+                        new CompositeGlob(excludeGlob, removeGlob));
                 }
-
-                return includeGlob;
             }
 
             private void CacheInformationFromRemoveItem(ProjectItemElement itemElement, Dictionary<string, CumulativeRemoveElementData> removeElementCache)
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index ec52f815e3d..451a26ef506 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -1615,12 +1615,11 @@ private bool RemoveToolsetInternal(string toolsVersion)
         {
             Debug.Assert(_locker.IsWriteLockHeld);
 
-            if (!_toolsets.ContainsKey(toolsVersion))
+            if (!_toolsets.Remove(toolsVersion))
             {
                 return false;
             }
 
-            _toolsets.Remove(toolsVersion);
             _toolsetsVersion++;
             return true;
         }
@@ -1729,7 +1728,6 @@ private void CreateLoggingService(int maxCPUCount, bool onlyLogCriticalEvents)
             _loggingService.OnlyLogCriticalEvents = onlyLogCriticalEvents;
         }
 
-#if FEATURE_SYSTEM_CONFIGURATION
         /// <summary>
         /// Reset the toolsets using the provided toolset reader, used by unit tests
         /// </summary>
@@ -1737,7 +1735,6 @@ internal void ResetToolsetsForTests(ToolsetConfigurationReader configurationRead
         {
             InitializeToolsetCollection(configReader:configurationReaderForTestsOnly);
         }
-#endif
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
@@ -1757,9 +1754,7 @@ private void InitializeToolsetCollection(
 #if FEATURE_WIN32_REGISTRY
                 ToolsetRegistryReader registryReader = null,
 #endif
-#if FEATURE_SYSTEM_CONFIGURATION
                 ToolsetConfigurationReader configReader = null
-#endif
                 )
         {
             _toolsets = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
@@ -1769,9 +1764,7 @@ private void InitializeToolsetCollection(
 #if FEATURE_WIN32_REGISTRY
                     registryReader,
 #endif
-#if FEATURE_SYSTEM_CONFIGURATION
                     configReader,
-#endif
                     EnvironmentProperties, _globalProperties, ToolsetLocations);
 
             _toolsetsVersion++;
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 52128c04fa6..5665b1aaf09 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -253,7 +253,11 @@ private static Configuration ReadApplicationConfiguration()
         {
             // When running from the command-line or from VS, use the msbuild.exe.config file.
             if (BuildEnvironmentHelper.Instance.Mode != BuildEnvironmentMode.None &&
+ // This FEATURE_SYSTEM_CONFIGURATION is needed as OpenExeConfiguration for net5.0 works differently, without this condition unit tests won't pass.
+ // ConfigurationManager.OpenExeConfiguration in net5.0 will find testhost.exe instead which does not contain any configuration and therefore fail.
+#if FEATURE_SYSTEM_CONFIGURATION
                 !BuildEnvironmentHelper.Instance.RunningTests &&
+#endif
                 FileSystems.Default.FileExists(BuildEnvironmentHelper.Instance.CurrentMSBuildConfigurationFile))
             {
                 var configFile = new ExeConfigurationFileMap { ExeConfigFilename = BuildEnvironmentHelper.Instance.CurrentMSBuildConfigurationFile };
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 3bcf77e90aa..869b3318ea4 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -76,7 +76,6 @@ protected abstract string DefaultOverrideToolsVersion
             get;
         }
 
-#if FEATURE_WIN32_REGISTRY || FEATURE_SYSTEM_CONFIGURATION
         /// <summary>
         /// Gathers toolset data from the registry and configuration file, if any:
         /// allows you to specify which of the registry and configuration file to
@@ -88,12 +87,9 @@ internal static string ReadAllToolsets(Dictionary<string, Toolset> toolsets, Pro
 #if FEATURE_WIN32_REGISTRY
                 null,
 #endif
-#if FEATURE_SYSTEM_CONFIGURATION
                 null,
-#endif
                 environmentProperties, globalProperties, locations);
         }
-#endif
 
         /// <summary>
         /// Gathers toolset data from the registry and configuration file, if any.
@@ -105,9 +101,7 @@ internal static string ReadAllToolsets
 #if FEATURE_WIN32_REGISTRY
             ToolsetRegistryReader registryReader,
 #endif
-#if FEATURE_SYSTEM_CONFIGURATION
             ToolsetConfigurationReader configurationReader,
-#endif
             PropertyDictionary<ProjectPropertyInstance> environmentProperties,
             PropertyDictionary<ProjectPropertyInstance> globalProperties,
             ToolsetDefinitionLocations locations
@@ -124,7 +118,6 @@ ToolsetDefinitionLocations locations
             string overrideTasksPathFromConfiguration = null;
             string defaultOverrideToolsVersionFromConfiguration = null;
 
-#if FEATURE_SYSTEM_CONFIGURATION
             if ((locations & ToolsetDefinitionLocations.ConfigurationFile) == ToolsetDefinitionLocations.ConfigurationFile)
             {
                 if (configurationReader == null)
@@ -137,7 +130,6 @@ ToolsetDefinitionLocations locations
                     initialProperties, true /* accumulate properties */, out overrideTasksPathFromConfiguration,
                     out defaultOverrideToolsVersionFromConfiguration);
             }
-#endif
 
             string defaultToolsVersionFromRegistry = null;
             string overrideTasksPathFromRegistry = null;
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index 7a083fbebbd..e2081dc5ad7 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -3,11 +3,8 @@
 
 #if FEATURE_WIN32_REGISTRY
 
-using Microsoft.Win32;
 using System;
 using System.Collections.Generic;
-using System.IO;
-using System.Security;
 
 using Microsoft.Build.Shared;
 using error = Microsoft.Build.Shared.ErrorUtilities;
@@ -346,4 +343,4 @@ private static string GetValue(RegistryKeyWrapper wrapper, string valueName)
         }
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/Build/Evaluation/Context/EvaluationContext.cs b/src/Build/Evaluation/Context/EvaluationContext.cs
index 633dd5404da..470b4f0cb1e 100644
--- a/src/Build/Evaluation/Context/EvaluationContext.cs
+++ b/src/Build/Evaluation/Context/EvaluationContext.cs
@@ -3,7 +3,7 @@
 
 using System;
 using System.Collections.Concurrent;
-using System.Collections.Immutable;
+using System.Collections.Generic;
 using System.Threading;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.FileSystem;
@@ -48,7 +48,7 @@ public enum SharingPolicy
         /// <summary>
         /// Key to file entry list. Example usages: cache glob expansion and intermediary directory expansions during glob expansion.
         /// </summary>
-        private ConcurrentDictionary<string, ImmutableArray<string>> FileEntryExpansionCache { get; }
+        private ConcurrentDictionary<string, IReadOnlyList<string>> FileEntryExpansionCache { get; }
 
         private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem)
         {
@@ -61,7 +61,7 @@ private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem)
             Policy = policy;
 
             SdkResolverService = new CachingSdkResolverService();
-            FileEntryExpansionCache = new ConcurrentDictionary<string, ImmutableArray<string>>();
+            FileEntryExpansionCache = new ConcurrentDictionary<string, IReadOnlyList<string>>();
             FileSystem = fileSystem ?? new CachingFileSystemWrapper(FileSystems.Default);
             EngineFileUtilities = new EngineFileUtilities(new FileMatcher(FileSystem, FileEntryExpansionCache));
         }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 5df077fe418..f9126e6c61f 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -849,14 +849,10 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
                             _itemDefinitionGroupElements.Add(itemDefinitionGroup);
                             break;
                         case ProjectTargetElement target:
-                            if (_projectSupportsReturnsAttribute.ContainsKey(currentProjectOrImport))
-                            {
-                                _projectSupportsReturnsAttribute[currentProjectOrImport] |= (target.Returns != null);
-                            }
-                            else
-                            {
-                                _projectSupportsReturnsAttribute[currentProjectOrImport] = (target.Returns != null);
-                            }
+                            // Defaults to false
+                            _projectSupportsReturnsAttribute.TryGetValue(currentProjectOrImport, out NGen<bool> projectSupportsReturnsAttribute);
+
+                            _projectSupportsReturnsAttribute[currentProjectOrImport] = projectSupportsReturnsAttribute || (target.Returns != null);
                             _targetElements.Add(target);
                             break;
                         case ProjectImportElement import:
@@ -1927,17 +1923,43 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
         private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(string directoryOfImportingFile, ProjectImportElement importElement, string unescapedExpression,
                                             bool throwOnFileNotExistsError, out List<ProjectRootElement> imports)
         {
+            imports = new List<ProjectRootElement>();
+
             string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
             ElementLocation importLocationInProject = importElement.Location;
 
             if (String.IsNullOrWhiteSpace(importExpressionEscaped))
             {
+                if ((_loadSettings & ProjectLoadSettings.IgnoreInvalidImports) != 0)
+                {
+                    // Log message for import skipped
+                    ProjectImportedEventArgs eventArgs = new ProjectImportedEventArgs(
+                        importElement.Location.Line,
+                        importElement.Location.Column,
+                        ResourceUtilities.GetResourceString("ProjectImportSkippedExpressionEvaluatedToEmpty"),
+                        unescapedExpression,
+                        importElement.ContainingProject.FullPath,
+                        importElement.Location.Line,
+                        importElement.Location.Column)
+                    {
+                        BuildEventContext = _evaluationLoggingContext.BuildEventContext,
+                        UnexpandedProject = importElement.Project,
+                        ProjectFile = importElement.ContainingProject.FullPath,
+                        ImportedProjectFile = string.Empty,
+                        ImportIgnored = true,
+                    };
+
+                    _evaluationLoggingContext.LogBuildEvent(eventArgs);
+
+                    return LoadImportsResult.ImportExpressionResolvedToNothing;
+                }
+
                 ProjectErrorUtilities.ThrowInvalidProject(importLocationInProject, "InvalidAttributeValue", String.Empty, XMakeAttributes.project, XMakeElements.import);
             }
 
             bool atleastOneImportIgnored = false;
             bool atleastOneImportEmpty = false;
-            imports = new List<ProjectRootElement>();
+            
             foreach (string importExpressionEscapedItem in ExpressionShredder.SplitSemiColonSeparatedList(importExpressionEscaped))
             {
                 string[] importFilesEscaped = null;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index ad43ca4dc2a..5fa15be5d91 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -123,6 +123,136 @@ internal class Expander<P, I>
         where P : class, IProperty
         where I : class, IItem
     {
+        /// <summary>
+        /// A helper struct wrapping a <see cref="SpanBasedStringBuilder"/> and providing file path conversion
+        /// as used in e.g. property expansion.
+        /// </summary>
+        /// <remarks>
+        /// If exactly one value is added and no concatenation takes places, this value is returned without
+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths
+        /// before concatenation.
+        /// </remarks>
+        private struct SpanBasedConcatenator : IDisposable
+        {
+            /// <summary>
+            /// The backing <see cref="SpanBasedStringBuilder"/>, null until the second value is added.
+            /// </summary>
+            private SpanBasedStringBuilder _builder;
+
+            /// <summary>
+            /// The first value added to the concatenator. Tracked in its own field so it can be returned
+            /// without conversion if no concatenation takes place.
+            /// </summary>
+            private object _firstObject;
+
+            /// <summary>
+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the
+            /// <see cref="SpanBasedStringBuilder"/> functionality doesn't have to be invoked if no concatenation
+            /// takes place.
+            /// </summary>
+            private ReadOnlyMemory<char> _firstSpan;
+
+            /// <summary>
+            /// True if this instance is already disposed.
+            /// </summary>
+            private bool _disposed;
+
+            /// <summary>
+            /// Adds an object to be concatenated.
+            /// </summary>
+            public void Add(object obj)
+            {
+                CheckDisposed();
+                FlushFirstValueIfNeeded();
+                if (_builder != null)
+                {
+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(obj.ToString()));
+                }
+                else
+                {
+                    _firstObject = obj;
+                }
+            }
+
+            /// <summary>
+            /// Adds a span to be concatenated.
+            /// </summary>
+            public void Add(ReadOnlyMemory<char> span)
+            {
+                CheckDisposed();
+                FlushFirstValueIfNeeded();
+                if (_builder != null)
+                {
+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(span));
+                }
+                else
+                {
+                    _firstSpan = span;
+                }
+            }
+
+            /// <summary>
+            /// Returns the result of the concatenation.
+            /// </summary>
+            /// <returns>
+            /// If only one value has been added and it is not a string, it is returned unchanged.
+            /// In all other cases (no value, one string value, multiple values) the result is a
+            /// concatenation of the string representation of the values, each additionally subjected
+            /// to file path adjustment.
+            /// </returns>
+            public object GetResult()
+            {
+                CheckDisposed();
+                if (_firstObject != null)
+                {
+                    return (_firstObject is string stringValue) ? FileUtilities.MaybeAdjustFilePath(stringValue) : _firstObject;
+                }
+                return _firstSpan.IsEmpty
+                    ? _builder?.ToString() ?? string.Empty
+                    : FileUtilities.MaybeAdjustFilePath(_firstSpan).ToString();
+            }
+
+            /// <summary>
+            /// Disposes of the struct by delegating the call to the underlying <see cref="SpanBasedStringBuilder"/>.
+            /// </summary>
+            public void Dispose()
+            {
+                CheckDisposed();
+                _builder?.Dispose();
+                _disposed = true;
+            }
+
+            /// <summary>
+            /// Throws <see cref="ObjectDisposedException"/> if this concatenator is already disposed.
+            /// </summary>
+            private void CheckDisposed() =>
+                ErrorUtilities.VerifyThrowObjectDisposed(!_disposed, nameof(SpanBasedConcatenator));
+
+            /// <summary>
+            /// Lazily initializes <see cref="_builder"/> and populates it with the first value
+            /// when the second value is being added.
+            /// </summary>
+            private void FlushFirstValueIfNeeded()
+            {
+                if (_firstObject != null)
+                {
+                    _builder = Strings.GetSpanBasedStringBuilder();
+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstObject.ToString()));
+                    _firstObject = null;
+                }
+                else if (!_firstSpan.IsEmpty)
+                {
+                    _builder = Strings.GetSpanBasedStringBuilder();
+#if FEATURE_SPAN
+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstSpan));
+#else
+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstSpan.ToString()));
+#endif
+                    _firstSpan = new ReadOnlyMemory<char>();
+                }
+            }
+        }
+
         /// <summary>
         /// A limit for truncating string expansions within an evaluated Condition. Properties, item metadata, or item groups will be truncated to N characters such as 'N...'.
         /// Enabled by ExpanderOptions.Truncate.
@@ -483,19 +613,6 @@ private static bool IsTruncationEnabled(ExpanderOptions options)
             return (options & ExpanderOptions.Truncate) != 0 && !Traits.Instance.EscapeHatches.DoNotTruncateConditions && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_8);
         }
 
-        /// <summary>
-        /// Scan for the closing bracket that matches the one we've already skipped;
-        /// essentially, pushes and pops on a stack of parentheses to do this.
-        /// Takes the expression and the index to start at.
-        /// Returns the index of the matching parenthesis, or -1 if it was not found.
-        /// </summary>
-        private static int ScanForClosingParenthesis(string expression, int index)
-        {
-            bool potentialPropertyFunction;
-            bool potentialRegistryFunction;
-            return ScanForClosingParenthesis(expression, index, out potentialPropertyFunction, out potentialRegistryFunction);
-        }
-
         /// <summary>
         /// Scan for the closing bracket that matches the one we've already skipped;
         /// essentially, pushes and pops on a stack of parentheses to do this.
@@ -512,16 +629,15 @@ private static int ScanForClosingParenthesis(string expression, int index, out b
             potentialPropertyFunction = false;
             potentialRegistryFunction = false;
 
-            unsafe
+            // Scan for our closing ')'
+            while (index < length && nestLevel > 0)
             {
-                fixed (char* pchar = expression)
+                char character = expression[index];
+                switch (character)
                 {
-                    // Scan for our closing ')'
-                    while (index < length && nestLevel > 0)
-                    {
-                        char character = pchar[index];
-
-                        if (character == '\'' || character == '`' || character == '"')
+                    case '\'':
+                    case '`':
+                    case '"':
                         {
                             index++;
                             index = ScanForClosingQuote(character, expression, index);
@@ -530,27 +646,33 @@ private static int ScanForClosingParenthesis(string expression, int index, out b
                             {
                                 return -1;
                             }
+                            break;
                         }
-                        else if (character == '(')
+                    case '(':
                         {
                             nestLevel++;
+                            break;
                         }
-                        else if (character == ')')
+                    case ')':
                         {
                             nestLevel--;
+                            break;
                         }
-                        else if (character == '.' || character == '[' || character == '$')
+                    case '.':
+                    case '[':
+                    case '$':
                         {
                             potentialPropertyFunction = true;
+                            break;
                         }
-                        else if (character == ':')
+                    case ':':
                         {
                             potentialRegistryFunction = true;
+                            break;
                         }
-
-                        index++;
-                    }
                 }
+
+                index++;
             }
 
             // We will have parsed past the ')', so step back one character
@@ -564,24 +686,8 @@ private static int ScanForClosingParenthesis(string expression, int index, out b
         /// </summary>
         private static int ScanForClosingQuote(char quoteChar, string expression, int index)
         {
-            unsafe
-            {
-                fixed (char* pchar = expression)
-                {
-                    // Scan for our closing quoteChar
-                    while (index < expression.Length)
-                    {
-                        if (pchar[index] == quoteChar)
-                        {
-                            return index;
-                        }
-
-                        index++;
-                    }
-                }
-            }
-
-            return -1;
+            // Scan for our closing quoteChar
+            return expression.IndexOf(quoteChar, index);
         }
 
         /// <summary>
@@ -666,7 +772,7 @@ void FlushCurrentArgumentToArgumentBuilder(int argumentEndIndex)
                     n += 2; // skip over the opening '$('
 
                     // Scan for the matching closing bracket, skipping any nested ones
-                    n = ScanForClosingParenthesis(argumentsString, n);
+                    n = ScanForClosingParenthesis(argumentsString, n, out _, out _);
 
                     if (n == -1)
                     {
@@ -1000,8 +1106,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 // so that we can either maintain the object's type in the event
                 // that we have a single component, or convert to a string
                 // if concatenation is required.
-                List<object> results = null;
-                object lastResult = null;
+                using Expander<P, I>.SpanBasedConcatenator results = new Expander<P, I>.SpanBasedConcatenator();
 
                 // The sourceIndex is the zero-based index into the expression,
                 // where we've essentially read up to and copied into the target string.
@@ -1011,36 +1116,18 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 // any more.
                 while (propertyStartIndex != -1)
                 {
-                    if (lastResult != null)
-                    {
-                        if (results == null)
-                        {
-                            results = new List<object>(4);
-                        }
-
-                        results.Add(lastResult);
-                    }
-
-
                     // Append the result with the portion of the expression up to
                     // (but not including) the "$(", and advance the sourceIndex pointer.
                     if (propertyStartIndex - sourceIndex > 0)
                     {
-                        if (results == null)
-                        {
-                            results = new List<object>(4);
-                        }
-
-                        results.Add(expression.Substring(sourceIndex, propertyStartIndex - sourceIndex));
+                        results.Add(expression.AsMemory(sourceIndex, propertyStartIndex - sourceIndex));
                     }
 
-                    bool tryExtractPropertyFunction;
-                    bool tryExtractRegistryFunction;
                     // Following the "$(" we need to locate the matching ')'
                     // Scan for the matching closing bracket, skipping any nested ones
                     // This is a very complete, fast validation of parenthesis matching including for nested
                     // function calls.
-                    propertyEndIndex = ScanForClosingParenthesis(expression, propertyStartIndex + 2, out tryExtractPropertyFunction, out tryExtractRegistryFunction);
+                    propertyEndIndex = ScanForClosingParenthesis(expression, propertyStartIndex + 2, out bool tryExtractPropertyFunction, out bool tryExtractRegistryFunction);
 
                     if (propertyEndIndex == -1)
                     {
@@ -1048,7 +1135,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         // isn't really a well-formed property tag.  Just literally
                         // copy the remainder of the expression (starting with the "$("
                         // that we found) into the result, and quit.
-                        lastResult = expression.Substring(propertyStartIndex, expression.Length - propertyStartIndex);
+                        results.Add(expression.AsMemory(propertyStartIndex, expression.Length - propertyStartIndex));
                         sourceIndex = expression.Length;
                     }
                     else
@@ -1125,60 +1212,20 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         // Record our result, and advance
                         // our sourceIndex pointer to the character just after the closing
                         // parenthesis.
-                        lastResult = propertyValue;
+                        results.Add(propertyValue);
                         sourceIndex = propertyEndIndex + 1;
                     }
 
                     propertyStartIndex = s_invariantCompareInfo.IndexOf(expression, "$(", sourceIndex, CompareOptions.Ordinal);
                 }
 
-                // If we have only a single result, then just return it
-                if (results == null && expression.Length == sourceIndex)
+                // If we couldn't find any more property tags in the expression just copy the remainder into the result.
+                if (expression.Length - sourceIndex > 0)
                 {
-                    var resultString = lastResult as string;
-                    return resultString != null ? FileUtilities.MaybeAdjustFilePath(resultString) : lastResult;
+                    results.Add(expression.AsMemory(sourceIndex, expression.Length - sourceIndex));
                 }
-                else
-                {
-                    // The expression is constant, return it as is
-                    if (sourceIndex == 0)
-                    {
-                        return expression;
-                    }
-
-                    // We have more than one result collected, therefore we need to concatenate
-                    // into the final result string. This does mean that we will lose type information.
-                    // However since the user wanted contatenation, then they clearly wanted that to happen.
-
-                    // Initialize our output string to empty string.
-                    // This method is called very often - of the order of 3,000 times per project.
-                    using SpanBasedStringBuilder result = Strings.GetSpanBasedStringBuilder();
-
-                    // Append our collected results
-                    if (results != null)
-                    {
-                        // Create a combined result string from the result components that we've gathered
-                        foreach (object component in results)
-                        {
-                            result.Append(FileUtilities.MaybeAdjustFilePath(component.ToString()));
-                        }
-                    }
-
-                    // Append the last result we collected (it wasn't added to the list)
-                    if (lastResult != null)
-                    {
-                        result.Append(FileUtilities.MaybeAdjustFilePath(lastResult.ToString()));
-                    }
 
-                    // And if we couldn't find anymore property tags in the expression,
-                    // so just literally copy the remainder into the result.
-                    if (expression.Length - sourceIndex > 0)
-                    {
-                        result.Append(expression, sourceIndex, expression.Length - sourceIndex);
-                    }
-
-                    return result.ToString();
-                }
+                return results.GetResult();
             }
 
             /// <summary>
@@ -1306,76 +1353,72 @@ internal static object ExpandPropertyBody(
             /// </summary>
             internal static string ConvertToString(object valueToConvert)
             {
-                if (valueToConvert != null)
+                if (valueToConvert == null)
                 {
-                    Type valueType = valueToConvert.GetType();
-                    string convertedString;
-
-                    // If the type is a string, then there is nothing to do
-                    if (valueType == typeof(string))
-                    {
-                        convertedString = (string)valueToConvert;
-                    }
-                    else if (valueToConvert is IDictionary dictionary)
-                    {
-                        // If the return type is an IDictionary, then we convert this to
-                        // a semi-colon delimited set of A=B pairs.
-                        // Key and Value are converted to string and escaped
-                        if (dictionary.Count > 0)
-                        {
-                            using SpanBasedStringBuilder builder = Strings.GetSpanBasedStringBuilder();
-
-                            foreach (DictionaryEntry entry in dictionary)
-                            {
-                                if (builder.Length > 0)
-                                {
-                                    builder.Append(";");
-                                }
-
-                                // convert and escape each key and value in the dictionary entry
-                                builder.Append(EscapingUtilities.Escape(ConvertToString(entry.Key)));
-                                builder.Append("=");
-                                builder.Append(EscapingUtilities.Escape(ConvertToString(entry.Value)));
-                            }
+                    return String.Empty;
+                }
+                // If the value is a string, then there is nothing to do
+                if (valueToConvert is string stringValue)
+                {
+                    return stringValue;
+                }
 
-                            convertedString = builder.ToString();
-                        }
-                        else
-                        {
-                            convertedString = string.Empty;
-                        }
-                    }
-                    else if (valueToConvert is IEnumerable enumerable)
+                string convertedString;
+                if (valueToConvert is IDictionary dictionary)
+                {
+                    // If the return type is an IDictionary, then we convert this to
+                    // a semi-colon delimited set of A=B pairs.
+                    // Key and Value are converted to string and escaped
+                    if (dictionary.Count > 0)
                     {
-                        // If the return is enumerable, then we'll convert to semi-colon delimited elements
-                        // each of which must be converted, so we'll recurse for each element
                         using SpanBasedStringBuilder builder = Strings.GetSpanBasedStringBuilder();
 
-                        foreach (object element in enumerable)
+                        foreach (DictionaryEntry entry in dictionary)
                         {
                             if (builder.Length > 0)
                             {
                                 builder.Append(";");
                             }
 
-                            // we need to convert and escape each element of the array
-                            builder.Append(EscapingUtilities.Escape(ConvertToString(element)));
+                            // convert and escape each key and value in the dictionary entry
+                            builder.Append(EscapingUtilities.Escape(ConvertToString(entry.Key)));
+                            builder.Append("=");
+                            builder.Append(EscapingUtilities.Escape(ConvertToString(entry.Value)));
                         }
 
                         convertedString = builder.ToString();
                     }
                     else
                     {
-                        // The fall back is always to just convert to a string directly.
-                        convertedString = valueToConvert.ToString();
+                        convertedString = string.Empty;
+                    }
+                }
+                else if (valueToConvert is IEnumerable enumerable)
+                {
+                    // If the return is enumerable, then we'll convert to semi-colon delimited elements
+                    // each of which must be converted, so we'll recurse for each element
+                    using SpanBasedStringBuilder builder = Strings.GetSpanBasedStringBuilder();
+
+                    foreach (object element in enumerable)
+                    {
+                        if (builder.Length > 0)
+                        {
+                            builder.Append(";");
+                        }
+
+                        // we need to convert and escape each element of the array
+                        builder.Append(EscapingUtilities.Escape(ConvertToString(element)));
                     }
 
-                    return convertedString;
+                    convertedString = builder.ToString();
                 }
                 else
                 {
-                    return String.Empty;
+                    // The fall back is always to just convert to a string directly.
+                    convertedString = valueToConvert.ToString();
                 }
+
+                return convertedString;
             }
 
             /// <summary>
@@ -4736,7 +4779,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                     argumentStartIndex++;
 
                     // Scan for the matching closing bracket, skipping any nested ones
-                    int argumentsEndIndex = ScanForClosingParenthesis(expressionFunction, argumentStartIndex);
+                    int argumentsEndIndex = ScanForClosingParenthesis(expressionFunction, argumentStartIndex, out _, out _);
 
                     if (argumentsEndIndex == -1)
                     {
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 2756ccb9c37..7a1cb4db89b 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -85,24 +85,6 @@ public override bool IsMatch(string itemToMatch)
                 return ReferencedItems.Any(v => v.ItemAsValueFragment.IsMatch(itemToMatch));
             }
 
-            public override bool IsMatchOnMetadata(IItem item, IEnumerable<string> metadata, MatchOnMetadataOptions options)
-            {
-                return ReferencedItems.Any(referencedItem =>
-                        metadata.All(m => !item.GetMetadataValue(m).Equals(string.Empty) && MetadataComparer(options, item.GetMetadataValue(m), referencedItem.Item.GetMetadataValue(m))));
-            }
-
-            private bool MetadataComparer(MatchOnMetadataOptions options, string itemMetadata, string referencedItemMetadata)
-            {
-                if (options.Equals(MatchOnMetadataOptions.PathLike))
-                {
-                    return FileUtilities.ComparePathsNoThrow(itemMetadata, referencedItemMetadata, ProjectDirectory);
-                }
-                else 
-                {
-                    return String.Equals(itemMetadata, referencedItemMetadata, options.Equals(MatchOnMetadataOptions.CaseInsensitive) ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
-                }
-            }
-
             public override IMSBuildGlob ToMSBuildGlob()
             {
                 return MsBuildGlob;
@@ -229,31 +211,28 @@ private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocat
                         // The expression is not of the form "@(X)". Treat as string
 
                         //  Code corresponds to EngineFileUtilities.GetFileList
-                        var containsEscapedWildcards = EscapingUtilities.ContainsEscapedWildcards(splitEscaped);
-                        var containsRealWildcards = FileMatcher.HasWildcards(splitEscaped);
+                        if (!FileMatcher.HasWildcards(splitEscaped))
+                        {
+                            // No real wildcards means we just return the original string.  Don't even bother
+                            // escaping ... it should already be escaped appropriately since it came directly
+                            // from the project file
 
-                        // '*' is an illegal character to have in a filename.
-                        // todo: file-system assumption on legal path characters: https://github.com/Microsoft/msbuild/issues/781
-                        if (containsEscapedWildcards && containsRealWildcards)
+                            fragments.Add(new ValueFragment(splitEscaped, projectDirectory));
+                        }
+                        else if (EscapingUtilities.ContainsEscapedWildcards(splitEscaped))
                         {
+                            // '*' is an illegal character to have in a filename.
+                            // todo: file-system assumption on legal path characters: https://github.com/Microsoft/msbuild/issues/781
                             // Just return the original string.
                             fragments.Add(new ValueFragment(splitEscaped, projectDirectory));
                         }
-                        else if (!containsEscapedWildcards && containsRealWildcards)
+                        else
                         {
                             // Unescape before handing it to the filesystem.
                             var filespecUnescaped = EscapingUtilities.UnescapeAll(splitEscaped);
 
                             fragments.Add(new GlobFragment(filespecUnescaped, projectDirectory));
                         }
-                        else
-                        {
-                            // No real wildcards means we just return the original string.  Don't even bother 
-                            // escaping ... it should already be escaped appropriately since it came directly
-                            // from the project file
-
-                            fragments.Add(new ValueFragment(splitEscaped, projectDirectory));
-                        }
                     }
                 }
             }
@@ -310,26 +289,6 @@ public bool MatchesItem(I item)
             return false;
         }
 
-        /// <summary>
-        ///     Return true if any of the given <paramref name="metadata" /> matches the metadata on <paramref name="item" />
-        /// </summary>
-        /// <param name="item">The item to attempt to find a match for based on matching metadata</param>
-        /// <param name="metadata">Names of metadata to look for matches for</param>
-        /// <param name="options">metadata option matching</param>
-        /// <returns></returns>
-        public bool MatchesItemOnMetadata(IItem item, IEnumerable<string> metadata, MatchOnMetadataOptions options)
-        {
-            foreach (var fragment in Fragments)
-            {
-                if (fragment.IsMatchOnMetadata(item, metadata, options))
-                {
-                    return true;
-                }
-            }
-
-            return false;
-        }
-
         /// <summary>
         ///     Return the fragments that match against the given <paramref name="itemToMatch" />
         /// </summary>
@@ -456,14 +415,6 @@ public virtual bool IsMatch(string itemToMatch)
             return FileMatcher.IsMatch(itemToMatch);
         }
 
-        /// <summary>
-        /// Returns true if <paramref name="itemToMatch" /> matches any ReferencedItems based on <paramref name="metadata" /> and <paramref name="options" />.
-        /// </summary>
-        public virtual bool IsMatchOnMetadata(IItem itemToMatch, IEnumerable<string> metadata, MatchOnMetadataOptions options)
-        {
-            return false;
-        }
-
         public virtual IMSBuildGlob ToMSBuildGlob()
         {
             return MsBuildGlob;
@@ -504,4 +455,111 @@ public GlobFragment(string textFragment, string projectDirectory)
             && TextFragment[2] == '*'
             && FileUtilities.IsAnySlash(TextFragment[3]);
     }
+
+    /// <summary>
+    /// A Trie representing the sets of values of specified metadata taken on by the referenced items.
+    /// A single flat list or set of metadata values would not work in this case because we are matching
+    /// on multiple metadata. If one item specifies NotTargetFramework to be net46 and TargetFramework to
+    /// be netcoreapp3.1, we wouldn't want to match that to an item with TargetFramework 46 and
+    /// NotTargetFramework netcoreapp3.1.
+    /// 
+    /// Implementing this as a list of sets where each metadatum key has its own set also would not work
+    /// because different items could match on different metadata, and we want to check to see if any
+    /// single item matches on all the metadata. As an example, consider this scenario:
+    /// Item Baby has metadata GoodAt="eating" BadAt="talking" OkAt="sleeping"
+    /// Item Child has metadata GoodAt="sleeping" BadAt="eating" OkAt="talking"
+    /// Item Adolescent has metadata GoodAt="talking" BadAt="sleeping" OkAt="eating"
+    /// Specifying these three metadata:
+    /// Item Forgind with metadata GoodAt="sleeping" BadAt="talking" OkAt="eating"
+    /// should match none of them because Forgind doesn't match all three metadata of any of the items.
+    /// With a list of sets, Forgind would match Baby on BadAt, Child on GoodAt, and Adolescent on OkAt,
+    /// and Forgind would be erroneously removed.
+    /// 
+    /// With a Trie as below, Items specify paths in the tree, so going to any child node eliminates all
+    /// items that don't share that metadatum. This ensures the match is proper.
+    /// 
+    /// Todo: Tries naturally can have different shapes depending on in what order the metadata are considered.
+    /// Specifically, if all the items share a single metadata value for the one metadatum and have different
+    /// values for a second metadatum, it will have only one node more than the number of items if the first
+    /// metadatum is considered first. If the metadatum is considered first, it will have twice that number.
+    /// Users can theoretically specify the order in which metadata should be considered by reordering them
+    /// on the line invoking this, but that is extremely nonobvious from a user's perspective.
+    /// It would be nice to detect poorly-ordered metadata and account for it to avoid making more nodes than
+    /// necessary. This would need to order if appropriately both in creating the MetadataTrie and in using it,
+    /// so it could best be done as a preprocessing step. For now, wait to find out if it's necessary (users'
+    /// computers run out of memory) before trying to implement it.
+    /// </summary>
+    /// <typeparam name="P">Property type</typeparam>
+    /// <typeparam name="I">Item type</typeparam>
+    internal sealed class MetadataTrie<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable
+    {
+        private readonly Dictionary<string, MetadataTrie<P, I>> _children;
+        private readonly Func<string, string> _normalize;
+
+        internal MetadataTrie(MatchOnMetadataOptions options, IEnumerable<string> metadata, ItemSpec<P, I> itemSpec)
+        {
+            StringComparer comparer = options == MatchOnMetadataOptions.CaseSensitive ? StringComparer.Ordinal :
+                options == MatchOnMetadataOptions.CaseInsensitive || FileUtilities.PathComparison == StringComparison.OrdinalIgnoreCase ? StringComparer.OrdinalIgnoreCase :
+                StringComparer.Ordinal;
+            _children = new Dictionary<string, MetadataTrie<P, I>>(comparer);
+            _normalize = options == MatchOnMetadataOptions.PathLike ? (Func<string, string>) (p => FileUtilities.NormalizePathForComparisonNoThrow(p, Environment.CurrentDirectory)) : p => p;
+            foreach (ItemSpec<P, I>.ItemExpressionFragment frag in itemSpec.Fragments)
+            {
+                foreach (ItemSpec<P, I>.ReferencedItem referencedItem in frag.ReferencedItems)
+                {
+                    this.Add(metadata.Select(m => referencedItem.Item.GetMetadataValue(m)), comparer);
+                }
+            }
+        }
+
+        private MetadataTrie(StringComparer comparer)
+        {
+            _children = new Dictionary<string, MetadataTrie<P, I>>(comparer);
+        }
+
+        // Relies on IEnumerable returning the metadata in a reasonable order. Reasonable?
+        private void Add(IEnumerable<string> metadata, StringComparer comparer)
+        {
+            MetadataTrie<P, I> current = this;
+            foreach (string m in metadata)
+            {
+                string normalizedString = _normalize(m);
+                if (!current._children.TryGetValue(normalizedString, out MetadataTrie<P, I> child))
+                {
+                    child = new MetadataTrie<P, I>(comparer);
+                    current._children.Add(normalizedString, child);
+                }
+                current = child;
+            }
+        }
+
+        internal bool Contains(IEnumerable<string> metadata)
+        {
+            MetadataTrie<P, I> current = this;
+            foreach (string m in metadata)
+            {
+                if (String.IsNullOrEmpty(m))
+                {
+                    return false;
+                }
+                if (!current._children.TryGetValue(_normalize(m), out current))
+                {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+
+    public enum MatchOnMetadataOptions
+    {
+        CaseSensitive,
+        CaseInsensitive,
+        PathLike
+    }
+
+    public static class MatchOnMetadataConstants
+    {
+        public const MatchOnMetadataOptions MatchOnMetadataOptionsDefaultValue = MatchOnMetadataOptions.CaseSensitive;
+    }
 }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 9934759efbf..b072a36f854 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -162,10 +162,8 @@ private string RouteCall(string itemType, string name, Func<IMetadataTable, stri
                     {
                         return getEscapedValueFunc(_operationItem, itemType, name);
                     }
-                    else if (_capturedItems.ContainsKey(itemType))
+                    else if (_capturedItems.TryGetValue(itemType, out var item))
                     {
-                        var item = _capturedItems[itemType];
-
                         return getEscapedValueFunc(item, itemType, name);
                     }
                     else
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index bcfe47d6c84..5a2d19ad7b2 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -13,13 +13,22 @@ internal partial class LazyItemEvaluator<P, I, M, D>
         class RemoveOperation : LazyItemOperation
         {
             readonly ImmutableList<string> _matchOnMetadata;
-            readonly MatchOnMetadataOptions _matchOnMetadataOptions;
+            private MetadataTrie<P, I> _metadataSet;
 
             public RemoveOperation(RemoveOperationBuilder builder, LazyItemEvaluator<P, I, M, D> lazyEvaluator)
                 : base(builder, lazyEvaluator)
             {
                 _matchOnMetadata = builder.MatchOnMetadata.ToImmutable();
-                _matchOnMetadataOptions = builder.MatchOnMetadataOptions;
+
+                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
+                    _matchOnMetadata.IsEmpty || _itemSpec.Fragments.All(f => f is ItemSpec<ProjectProperty, ProjectItem>.ItemExpressionFragment),
+                    new BuildEventFileInfo(string.Empty),
+                    "OM_MatchOnMetadataIsRestrictedToReferencedItems");
+
+                if (!_matchOnMetadata.IsEmpty)
+                {
+                    _metadataSet = new MetadataTrie<P, I>(builder.MatchOnMetadataOptions, _matchOnMetadata, _itemSpec);
+                }
             }
 
             /// <summary>
@@ -31,13 +40,6 @@ public RemoveOperation(RemoveOperationBuilder builder, LazyItemEvaluator<P, I, M
             /// </remarks>
             protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
-                var matchOnMetadataValid = !_matchOnMetadata.IsEmpty && _itemSpec.Fragments.Count == 1
-                    && _itemSpec.Fragments.First() is ItemSpec<ProjectProperty, ProjectItem>.ItemExpressionFragment;
-                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
-                    _matchOnMetadata.IsEmpty || (matchOnMetadataValid && _matchOnMetadata.Count == 1),
-                    new BuildEventFileInfo(string.Empty),
-                    "OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem");
-
                 if (_matchOnMetadata.IsEmpty && ItemspecContainsASingleBareItemReference(_itemSpec, _itemElement.ItemType) && _conditionResult)
                 {
                     // Perf optimization: If the Remove operation references itself (e.g. <I Remove="@(I)"/>)
@@ -55,13 +57,18 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                 var items = ImmutableHashSet.CreateBuilder<I>();
                 foreach (ItemData item in listBuilder)
                 {
-                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : _itemSpec.MatchesItemOnMetadata(item.Item, _matchOnMetadata, _matchOnMetadataOptions))
+                    if (_matchOnMetadata.IsEmpty ? _itemSpec.MatchesItem(item.Item) : MatchesItemOnMetadata(item.Item))
                         items.Add(item.Item);
                 }
 
                 return items.ToImmutableList();
             }
 
+            private bool MatchesItemOnMetadata(I item)
+            {
+                return _metadataSet.Contains(_matchOnMetadata.Select(m => item.GetMetadataValue(m)));
+            }
+
             protected override void SaveItems(ImmutableList<I> items, ImmutableList<ItemData>.Builder listBuilder)
             {
                 if (!_conditionResult)
@@ -100,15 +107,4 @@ public RemoveOperationBuilder(ProjectItemElement itemElement, bool conditionResu
             }
         }
     }
-
-    public enum MatchOnMetadataOptions
-    {
-        CaseSensitive,
-        CaseInsensitive,
-        PathLike
-    }
-
-    public static class MatchOnMetadataConstants {
-        public const MatchOnMetadataOptions MatchOnMetadataOptionsDefaultValue = MatchOnMetadataOptions.CaseSensitive;
-    }
 }
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index 4b03541b3df..0420aa9edd3 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -28,11 +28,10 @@ private readonly struct GlobState
             public string FixedDirectoryPart { get; }
             public string WildcardDirectoryPart { get; }
             public string FilenamePart { get; }
-            public string MatchFileExpression { get; }
             public bool NeedsRecursion { get; }
             public Regex Regex { get; }
 
-            public GlobState(string globRoot, string fileSpec, bool isLegal, string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart, string matchFileExpression, bool needsRecursion, Regex regex)
+            public GlobState(string globRoot, string fileSpec, bool isLegal, string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart, bool needsRecursion, Regex regex)
             {
                 GlobRoot = globRoot;
                 FileSpec = fileSpec;
@@ -40,7 +39,6 @@ public GlobState(string globRoot, string fileSpec, bool isLegal, string fixedDir
                 FixedDirectoryPart = fixedDirectoryPart;
                 WildcardDirectoryPart = wildcardDirectoryPart;
                 FilenamePart = filenamePart;
-                MatchFileExpression = matchFileExpression;
                 NeedsRecursion = needsRecursion;
                 Regex = regex;
             }
@@ -117,23 +115,20 @@ public MatchInfoResult MatchInfo(string stringToMatch)
         {
             ErrorUtilities.VerifyThrowArgumentNull(stringToMatch, nameof(stringToMatch));
 
-            if (FileUtilities.PathIsInvalid(stringToMatch) ||
-                !IsLegal)
+            if (FileUtilities.PathIsInvalid(stringToMatch) || !IsLegal)
             {
                 return MatchInfoResult.Empty;
             }
 
-            var normalizedInput = NormalizeMatchInput(stringToMatch);
+            string normalizedInput = NormalizeMatchInput(stringToMatch);
 
-            bool isMatch;
-            string fixedDirectoryPart, wildcardDirectoryPart, filenamePart;
             FileMatcher.GetRegexMatchInfo(
                 normalizedInput,
                 _state.Value.Regex,
-                out isMatch,
-                out fixedDirectoryPart,
-                out wildcardDirectoryPart,
-                out filenamePart);
+                out bool isMatch,
+                out string fixedDirectoryPart,
+                out string wildcardDirectoryPart,
+                out string filenamePart);
 
             return new MatchInfoResult(isMatch, fixedDirectoryPart, wildcardDirectoryPart, filenamePart);
         }
@@ -145,7 +140,7 @@ private string NormalizeMatchInput(string stringToMatch)
 
             // Degenerate case when the string to match is empty.
             // Ensure trailing slash because the fixed directory part has a trailing slash.
-            if (stringToMatch == string.Empty)
+            if (string.IsNullOrEmpty(stringToMatch))
             {
                 normalizedInput += Path.DirectorySeparatorChar;
             }
@@ -172,7 +167,7 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
             ErrorUtilities.VerifyThrowArgumentNull(fileSpec, nameof(fileSpec));
             ErrorUtilities.VerifyThrowArgumentInvalidPath(globRoot, nameof(globRoot));
 
-            if (globRoot == string.Empty)
+            if (string.IsNullOrEmpty(globRoot))
             {
                 globRoot = Directory.GetCurrentDirectory();
             }
@@ -181,22 +176,13 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
 
             var lazyState = new Lazy<GlobState>(() =>
             {
-                string fixedDirectoryPart = null;
-                string wildcardDirectoryPart = null;
-                string filenamePart = null;
-
-                string matchFileExpression;
-                bool needsRecursion;
-                bool isLegalFileSpec;
-
                 FileMatcher.Default.GetFileSpecInfo(
                     fileSpec,
-                    out fixedDirectoryPart,
-                    out wildcardDirectoryPart,
-                    out filenamePart,
-                    out matchFileExpression,
-                    out needsRecursion,
-                    out isLegalFileSpec,
+                    out string fixedDirectoryPart,
+                    out string wildcardDirectoryPart,
+                    out string filenamePart,
+                    out bool needsRecursion,
+                    out bool isLegalFileSpec,
                     (fixedDirPart, wildcardDirPart, filePart) =>
                     {
                         var normalizedFixedPart = NormalizeTheFixedDirectoryPartAgainstTheGlobRoot(fixedDirPart, globRoot);
@@ -207,6 +193,8 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
                 Regex regex = null;
                 if (isLegalFileSpec)
                 {
+                    string matchFileExpression = FileMatcher.RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart);
+
                     lock (s_regexCache)
                     {
                         s_regexCache.TryGetValue(matchFileExpression, out regex);
@@ -226,7 +214,7 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
                         regex ??= newRegex;
                     }
                 }
-                return new GlobState(globRoot, fileSpec, isLegalFileSpec, fixedDirectoryPart, wildcardDirectoryPart, filenamePart, matchFileExpression, needsRecursion, regex);
+                return new GlobState(globRoot, fileSpec, isLegalFileSpec, fixedDirectoryPart, wildcardDirectoryPart, filenamePart, needsRecursion, regex);
             },
             true);
 
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 856e514719a..4f9c7d0879c 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -209,18 +209,15 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
             {
                 var referencingProjectPath = solutionDependency.Key;
 
-                ErrorUtilities.VerifyThrow(projectsByPath.ContainsKey(referencingProjectPath), "nodes should include solution projects");
+                ErrorUtilities.VerifyThrow(projectsByPath.TryGetValue(referencingProjectPath, out var referencingNodes), "nodes should include solution projects");
 
                 var referencedNodes = solutionDependency.Value.SelectMany(
                     referencedProjectPath =>
                     {
-                        ErrorUtilities.VerifyThrow(projectsByPath.ContainsKey(referencedProjectPath), "nodes should include solution projects");
-
-                        return projectsByPath[referencedProjectPath];
+                        ErrorUtilities.VerifyThrow(projectsByPath.TryGetValue(referencedProjectPath, out List<ProjectGraphNode> projectToReturn), "nodes should include solution projects");
+                        return projectToReturn;
                     }).ToArray();
 
-                var referencingNodes = projectsByPath[referencingProjectPath];
-
                 foreach (var referencingNode in referencingNodes)
                 {
                     foreach (var referencedNode in referencedNodes)
@@ -310,12 +307,12 @@ IReadOnlyCollection<ProjectInSolution> GetBuildableProjects(SolutionFile solutio
 
             SolutionConfigurationInSolution SelectSolutionConfiguration(SolutionFile solutionFile, ImmutableDictionary<string, string> globalProperties)
             {
-                var solutionConfiguration = globalProperties.ContainsKey("Configuration")
-                    ? globalProperties["Configuration"]
+                var solutionConfiguration = globalProperties.TryGetValue("Configuration", out string configuration)
+                    ? configuration
                     : solutionFile.GetDefaultConfigurationName();
 
-                var solutionPlatform = globalProperties.ContainsKey("Platform")
-                    ? globalProperties["Platform"]
+                var solutionPlatform = globalProperties.TryGetValue("Platform", out string platform)
+                    ? platform
                     : solutionFile.GetDefaultPlatformName();
 
                 return new SolutionConfigurationInSolution(solutionConfiguration, solutionPlatform);
@@ -329,9 +326,9 @@ ProjectConfigurationInSolution SelectProjectConfiguration(
 
                 var solutionConfigFullName = solutionConfig.FullName;
 
-                if (projectConfigs.ContainsKey(solutionConfigFullName))
+                if (projectConfigs.TryGetValue(solutionConfigFullName, out ProjectConfigurationInSolution projectConfiguration))
                 {
-                    return projectConfigs[solutionConfigFullName];
+                    return projectConfiguration;
                 }
 
                 var partiallyMarchedConfig = projectConfigs.FirstOrDefault(pc => pc.Value.ConfigurationName.Equals(solutionConfig.ConfigurationName, StringComparison.OrdinalIgnoreCase)).Value;
@@ -417,14 +414,14 @@ private void DetectCycles(
 
             foreach (var entryPointNode in entryPointNodes)
             {
-                if (!nodeStates.ContainsKey(entryPointNode))
+                if (!nodeStates.TryGetValue(entryPointNode, out NodeVisitationState state))
                 {
                     VisitNode(entryPointNode, nodeStates);
                 }
                 else
                 {
                     ErrorUtilities.VerifyThrow(
-                        nodeStates[entryPointNode] == NodeVisitationState.Processed,
+                        state == NodeVisitationState.Processed,
                         "entrypoints should get processed after a call to detect cycles");
                 }
             }
@@ -616,8 +613,8 @@ public ProjectItemInstance this[(ProjectGraphNode node, ProjectGraphNode referen
             {
                 get
                 {
-                    ErrorUtilities.VerifyThrow(ReferenceItems.ContainsKey(key), "All requested keys should exist");
-                    return ReferenceItems[key];
+                    ErrorUtilities.VerifyThrow(ReferenceItems.TryGetValue(key, out ProjectItemInstance referenceItem), "All requested keys should exist");
+                    return referenceItem;
                 }
 
                 // First edge wins, in accordance with vanilla msbuild behaviour when multiple msbuild tasks call into the same logical project
@@ -626,9 +623,7 @@ public ProjectItemInstance this[(ProjectGraphNode node, ProjectGraphNode referen
 
             public void RemoveEdge((ProjectGraphNode node, ProjectGraphNode reference) key)
             {
-                ErrorUtilities.VerifyThrow(ReferenceItems.ContainsKey(key), "All requested keys should exist");
-
-                ReferenceItems.TryRemove(key, out _);
+                ErrorUtilities.VerifyThrow(ReferenceItems.TryRemove(key, out _), "All requested keys should exist");
             }
 
             internal bool HasEdge((ProjectGraphNode node, ProjectGraphNode reference) key) => ReferenceItems.ContainsKey(key);
diff --git a/src/Build/Instance/HostServices.cs b/src/Build/Instance/HostServices.cs
index 98c03f1fe7a..a27e5787cfb 100644
--- a/src/Build/Instance/HostServices.cs
+++ b/src/Build/Instance/HostServices.cs
@@ -181,15 +181,8 @@ public void UnregisterProject(string projectFullPath)
         {
             if (projectFullPath != null)
             {
-                if (_hostObjectMap?.ContainsKey(projectFullPath) == true)
-                {
-                    _hostObjectMap.Remove(projectFullPath);
-                }
-
-                if (_projectAffinities?.ContainsKey(projectFullPath) == true)
-                {
-                    _projectAffinities.Remove(projectFullPath);
-                }
+                _hostObjectMap?.Remove(projectFullPath);
+                _projectAffinities?.Remove(projectFullPath);
             }
         }
 
@@ -323,14 +316,15 @@ void ITranslatable.Translate(ITranslator translator)
                     var hostObjectMapPairKeyTaskName = translator.Reader.ReadString();
                     var hostObjectMapPairValueMonikerName = translator.Reader.ReadString();
                     var targetTaskKey = new HostObjects.TargetTaskKey(hostObjectMapPairKeyTargetName, hostObjectMapPairKeyTaskName);
-                    if (!hostObjectMap.ContainsKey(pairKey))
+                    if (!hostObjectMap.TryGetValue(pairKey, out HostObjects hostObject))
                     {
-                        hostObjectMap[pairKey] = new HostObjects();
+                        hostObject = new HostObjects();
+                        hostObjectMap[pairKey] = hostObject;
                     }
 
-                    if (!hostObjectMap[pairKey]._hostObjects.ContainsKey(targetTaskKey))
+                    if (!hostObject._hostObjects.ContainsKey(targetTaskKey))
                     {
-                        hostObjectMap[pairKey]._hostObjects.Add(targetTaskKey, new MonikerNameOrITaskHost(hostObjectMapPairValueMonikerName));
+                        hostObject._hostObjects.Add(targetTaskKey, new MonikerNameOrITaskHost(hostObjectMapPairValueMonikerName));
                     }
                 }
                 _hostObjectMap = hostObjectMap;
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index bd160b2f66c..f9ef8388e3b 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -326,6 +326,59 @@ public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globa
         {
         }
 
+        /// <summary>
+        /// Creates a ProjectInstance from an external created <see cref="Project"/>.
+        /// Properties and items are cloned immediately and only the instance data is stored.
+        /// </summary>
+        public ProjectInstance(Project project, ProjectInstanceSettings settings)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(project, nameof(project));
+
+            var projectPath = project.FullPath;
+            _directory = Path.GetDirectoryName(projectPath);
+            _projectFileLocation = ElementLocation.Create(projectPath);
+            _hostServices = project.ProjectCollection.HostServices;
+
+            EvaluationId = project.EvaluationCounter;
+
+            var immutable = (settings & ProjectInstanceSettings.Immutable) == ProjectInstanceSettings.Immutable;
+            this.CreatePropertiesSnapshot(project.Properties, immutable);
+            this.CreateItemDefinitionsSnapshot(project.ItemDefinitions);
+
+            var keepEvaluationCache = (settings & ProjectInstanceSettings.ImmutableWithFastItemLookup) == ProjectInstanceSettings.ImmutableWithFastItemLookup;
+            var projectItemToInstanceMap = this.CreateItemsSnapshot(project.Items, project.ItemTypes.Count, keepEvaluationCache);
+
+            this.CreateEvaluatedIncludeSnapshotIfRequested(keepEvaluationCache, project.Items, projectItemToInstanceMap);
+
+            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(project.GlobalProperties.Count);
+            foreach (var property in project.GlobalProperties)
+            {
+                _globalProperties.Set(ProjectPropertyInstance.Create(property.Key, property.Value));
+            }
+
+            this.CreateEnvironmentVariablePropertiesSnapshot(project.ProjectCollection.EnvironmentProperties);
+            this.CreateTargetsSnapshot(project.Targets, null, null, null, null);
+            this.CreateImportsSnapshot(project.Imports, project.ImportsIncludingDuplicates);
+
+            this.Toolset = project.ProjectCollection.GetToolset(project.ToolsVersion);
+            this.SubToolsetVersion = project.SubToolsetVersion;
+            this.TaskRegistry = new TaskRegistry(Toolset, project.ProjectCollection.ProjectRootElementCache);
+
+            this.ProjectRootElementCache = project.ProjectCollection.ProjectRootElementCache;
+
+            this.EvaluatedItemElements = new List<ProjectItemElement>(project.Items.Count);
+            foreach (var item in project.Items)
+            {
+                this.EvaluatedItemElements.Add(item.Xml);
+            }
+
+            _usingDifferentToolsVersionFromProjectFile = false;
+            _originalProjectToolsVersion = project.ToolsVersion;
+            _explicitToolsVersionSpecified = project.SubToolsetVersion != null;
+
+            _isImmutable = immutable;
+        }
+
         /// <summary>
         /// Creates a ProjectInstance directly.
         /// No intermediate Project object is created.
@@ -461,18 +514,18 @@ internal ProjectInstance(Evaluation.Project.Data data, string directory, string
             EvaluationId = data.EvaluationId;
 
             var immutable = (settings & ProjectInstanceSettings.Immutable) == ProjectInstanceSettings.Immutable;
-            this.CreatePropertiesSnapshot(data, immutable);
+            this.CreatePropertiesSnapshot(new ReadOnlyCollection<ProjectProperty>(data.Properties), immutable);
 
-            this.CreateItemDefinitionsSnapshot(data);
+            this.CreateItemDefinitionsSnapshot(data.ItemDefinitions);
 
             var keepEvaluationCache = (settings & ProjectInstanceSettings.ImmutableWithFastItemLookup) == ProjectInstanceSettings.ImmutableWithFastItemLookup;
-            var projectItemToInstanceMap = this.CreateItemsSnapshot(data, keepEvaluationCache);
+            var projectItemToInstanceMap = this.CreateItemsSnapshot(new ReadOnlyCollection<ProjectItem>(data.Items), data.ItemTypes.Count, keepEvaluationCache);
 
-            this.CreateEvaluatedIncludeSnapshotIfRequested(keepEvaluationCache, data, projectItemToInstanceMap);
-            this.CreateGlobalPropertiesSnapshot(data);
+            this.CreateEvaluatedIncludeSnapshotIfRequested(keepEvaluationCache, new ReadOnlyCollection<ProjectItem>(data.Items), projectItemToInstanceMap);
+            this.CreateGlobalPropertiesSnapshot(data.GlobalPropertiesDictionary);
             this.CreateEnvironmentVariablePropertiesSnapshot(environmentVariableProperties);
-            this.CreateTargetsSnapshot(data);
-            this.CreateImportsSnapshot(data);
+            this.CreateTargetsSnapshot(data.Targets, data.DefaultTargets, data.InitialTargets, data.BeforeTargets, data.AfterTargets);
+            this.CreateImportsSnapshot(data.ImportClosure, data.ImportClosureWithDuplicates);
 
             this.Toolset = data.Toolset; // UNDONE: This isn't immutable, should be cloned or made immutable; it currently has a pointer to project collection
             this.SubToolsetVersion = data.SubToolsetVersion;
@@ -548,13 +601,13 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                 this.DefaultTargets = new List<string>(that.DefaultTargets);
                 this.InitialTargets = new List<string>(that.InitialTargets);
                 ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
-                    ProjectItemDefinitionInstance>) this).BeforeTargets = CreateCloneDictionary(
+                    ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(
                     ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
-                        ProjectItemDefinitionInstance>) that).BeforeTargets, StringComparer.OrdinalIgnoreCase);
+                        ProjectItemDefinitionInstance>)that).BeforeTargets, StringComparer.OrdinalIgnoreCase);
                 ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
-                    ProjectItemDefinitionInstance>) this).AfterTargets = CreateCloneDictionary(
+                    ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(
                     ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
-                        ProjectItemDefinitionInstance>) that).AfterTargets, StringComparer.OrdinalIgnoreCase);
+                        ProjectItemDefinitionInstance>)that).AfterTargets, StringComparer.OrdinalIgnoreCase);
                 this.TaskRegistry =
                     that.TaskRegistry; // UNDONE: This isn't immutable, should be cloned or made immutable; it currently has a pointer to project collection
 
@@ -2023,7 +2076,7 @@ private void TranslateProperties(ITranslator translator)
             translator.TranslateDictionary(ref _globalProperties, ProjectPropertyInstance.FactoryForDeserialization);
             translator.TranslateDictionary(ref _properties, ProjectPropertyInstance.FactoryForDeserialization);
 
-            var globalPropertiesToTreatAsLocal = (HashSet<string>) _globalPropertiesToTreatAsLocal;
+            var globalPropertiesToTreatAsLocal = (HashSet<string>)_globalPropertiesToTreatAsLocal;
             translator.Translate(ref globalPropertiesToTreatAsLocal);
 
             if (translator.Mode == TranslationDirection.ReadFromStream)
@@ -2378,7 +2431,7 @@ internal ProjectTargetInstance AddTarget(
                 parentProjectSupportsReturnsAttribute
                 );
 
-            _actualTargets[target.Name] = target;
+            _actualTargets[targetName] = target;
 
             return target;
         }
@@ -2583,7 +2636,7 @@ private static IDictionary<string, TValue> CreateCloneDictionary<TValue>(IDictio
             }
             else
             {
-                return new RetrievableEntryHashSet<TValue>(dictionary, StringComparer.OrdinalIgnoreCase, readOnly: true);
+                return new ObjectModel.ReadOnlyDictionary<string, TValue>(dictionary);
             }
         }
 
@@ -2727,24 +2780,29 @@ private IEnumerable<ProjectItemInstance> GetItemsByEvaluatedInclude(string evalu
         /// <summary>
         /// Create various target snapshots
         /// </summary>
-        private void CreateTargetsSnapshot(Evaluation.Project.Data data)
+        private void CreateTargetsSnapshot(
+            IDictionary<string, ProjectTargetInstance> targets,
+            List<string> defaultTargets,
+            List<string> initialTargets,
+            IDictionary<string, List<TargetSpecification>> beforeTargets,
+            IDictionary<string, List<TargetSpecification>> afterTargets)
         {
-            this.DefaultTargets = new List<string>(data.DefaultTargets);
-            this.InitialTargets = new List<string>(data.InitialTargets);
-            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(data.BeforeTargets, StringComparer.OrdinalIgnoreCase);
-            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(data.AfterTargets, StringComparer.OrdinalIgnoreCase);
-
             // ProjectTargetInstances are immutable so only the dictionary must be cloned
-            _targets = CreateCloneDictionary(data.Targets);
+            _targets = CreateCloneDictionary(targets);
+
+            this.DefaultTargets = defaultTargets == null ? new List<string>(0) : new List<string>(defaultTargets);
+            this.InitialTargets = defaultTargets == null ? new List<string>(0) : new List<string>(initialTargets);
+            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(beforeTargets, StringComparer.OrdinalIgnoreCase);
+            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(afterTargets, StringComparer.OrdinalIgnoreCase);
         }
 
         /// <summary>
         /// Create various imports snapshots
         /// </summary>
-        private void CreateImportsSnapshot(Evaluation.Project.Data data)
+        private void CreateImportsSnapshot(IList<ResolvedImport> importClosure, IList<ResolvedImport> importClosureWithDuplicates)
         {
-            _importPaths = new List<string>(data.ImportClosure.Count - 1 /* outer project */);
-            foreach (var resolvedImport in data.ImportClosure)
+            _importPaths = new List<string>(importClosure.Count - 1 /* outer project */);
+            foreach (var resolvedImport in importClosure)
             {
                 // Exclude outer project itself
                 if (resolvedImport.ImportingElement != null)
@@ -2755,8 +2813,8 @@ private void CreateImportsSnapshot(Evaluation.Project.Data data)
 
             ImportPaths = _importPaths.AsReadOnly();
 
-            _importPathsIncludingDuplicates = new List<string>(data.ImportClosureWithDuplicates.Count - 1 /* outer project */);
-            foreach (var resolvedImport in data.ImportClosureWithDuplicates)
+            _importPathsIncludingDuplicates = new List<string>(importClosureWithDuplicates.Count - 1 /* outer project */);
+            foreach (var resolvedImport in importClosureWithDuplicates)
             {
                 // Exclude outer project itself
                 if (resolvedImport.ImportingElement != null)
@@ -2784,11 +2842,11 @@ private void CreateEnvironmentVariablePropertiesSnapshot(PropertyDictionary<Proj
         /// <summary>
         /// Create global properties snapshot
         /// </summary>
-        private void CreateGlobalPropertiesSnapshot(Evaluation.Project.Data data)
+        private void CreateGlobalPropertiesSnapshot(PropertyDictionary<ProjectPropertyInstance> globalPropertiesDictionary)
         {
-            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(data.GlobalPropertiesDictionary.Count);
+            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(globalPropertiesDictionary.Count);
 
-            foreach (ProjectPropertyInstance globalProperty in data.GlobalPropertiesDictionary)
+            foreach (ProjectPropertyInstance globalProperty in globalPropertiesDictionary)
             {
                 _globalProperties.Set(globalProperty.DeepClone());
             }
@@ -2797,7 +2855,7 @@ private void CreateGlobalPropertiesSnapshot(Evaluation.Project.Data data)
         /// <summary>
         /// Create evaluated include cache snapshot
         /// </summary>
-        private void CreateEvaluatedIncludeSnapshotIfRequested(bool keepEvaluationCache, Evaluation.Project.Data data, Dictionary<ProjectItem, ProjectItemInstance> projectItemToInstanceMap)
+        private void CreateEvaluatedIncludeSnapshotIfRequested(bool keepEvaluationCache, ICollection<ProjectItem> items, Dictionary<ProjectItem, ProjectItemInstance> projectItemToInstanceMap)
         {
             if (!keepEvaluationCache)
             {
@@ -2805,26 +2863,22 @@ private void CreateEvaluatedIncludeSnapshotIfRequested(bool keepEvaluationCache,
             }
 
             _itemsByEvaluatedInclude = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
-            foreach (var key in data.ItemsByEvaluatedIncludeCache.Keys)
+            foreach (var item in items)
             {
-                var projectItems = data.ItemsByEvaluatedIncludeCache[key];
-                foreach (var projectItem in projectItems)
-                {
-                    _itemsByEvaluatedInclude.Add(key, projectItemToInstanceMap[projectItem]);
-                }
+                _itemsByEvaluatedInclude.Add(item.EvaluatedInclude, projectItemToInstanceMap[item]);
             }
         }
 
         /// <summary>
         /// Create Items snapshot
         /// </summary>
-        private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(Evaluation.Project.Data data, bool keepEvaluationCache)
+        private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollection<ProjectItem> items, int itemTypeCount, bool keepEvaluationCache)
         {
-            _items = new ItemDictionary<ProjectItemInstance>(data.ItemTypes.Count);
+            _items = new ItemDictionary<ProjectItemInstance>(itemTypeCount);
 
-            var projectItemToInstanceMap = keepEvaluationCache ? new Dictionary<ProjectItem, ProjectItemInstance>(data.Items.Count) : null;
+            var projectItemToInstanceMap = keepEvaluationCache ? new Dictionary<ProjectItem, ProjectItemInstance>(items.Count) : null;
 
-            foreach (ProjectItem item in data.Items)
+            foreach (ProjectItem item in items)
             {
                 List<ProjectItemDefinitionInstance> inheritedItemDefinitions = null;
 
@@ -2852,7 +2906,13 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(Evaluat
                     }
                 }
 
-                ProjectItemInstance instance = new ProjectItemInstance(this, item.ItemType, ((IItem)item).EvaluatedIncludeEscaped, item.EvaluatedIncludeBeforeWildcardExpansionEscaped, directMetadata, inheritedItemDefinitions, item.Xml.ContainingProject.EscapedFullPath);
+                // For externally constructed ProjectItem, fall back to the publicly available EvaluateInclude
+                var evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
+                evaluatedIncludeEscaped ??= item.EvaluatedInclude;
+                var evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
+                evaluatedIncludeBeforeWildcardExpansionEscaped ??= item.EvaluatedInclude;
+
+                ProjectItemInstance instance = new ProjectItemInstance(this, item.ItemType, evaluatedIncludeEscaped, evaluatedIncludeBeforeWildcardExpansionEscaped, directMetadata, inheritedItemDefinitions, item.Xml.ContainingProject.EscapedFullPath);
 
                 _items.Add(instance);
 
@@ -2865,11 +2925,11 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(Evaluat
         /// <summary>
         /// Create ItemDefinitions snapshot
         /// </summary>
-        private void CreateItemDefinitionsSnapshot(Evaluation.Project.Data data)
+        private void CreateItemDefinitionsSnapshot(IDictionary<string, ProjectItemDefinition> itemDefinitions)
         {
             _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(MSBuildNameIgnoreCaseComparer.Default);
 
-            foreach (ProjectItemDefinition definition in data.ItemDefinitions.Values)
+            foreach (ProjectItemDefinition definition in itemDefinitions.Values)
             {
                 _itemDefinitions.Add(new ProjectItemDefinitionInstance(definition));
             }
@@ -2878,11 +2938,11 @@ private void CreateItemDefinitionsSnapshot(Evaluation.Project.Data data)
         /// <summary>
         /// create property snapshot
         /// </summary>
-        private void CreatePropertiesSnapshot(Evaluation.Project.Data data, bool isImmutable)
+        private void CreatePropertiesSnapshot(ICollection<ProjectProperty> properties, bool isImmutable)
         {
-            _properties = new PropertyDictionary<ProjectPropertyInstance>(data.Properties.Count);
+            _properties = new PropertyDictionary<ProjectPropertyInstance>(properties.Count);
 
-            foreach (ProjectProperty property in data.Properties)
+            foreach (ProjectProperty property in properties)
             {
                 // Allow reserved property names, since this is how they are added to the project instance. 
                 // The caller has prevented users setting them themselves.
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 6200da27e43..f9dc6429ec1 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -28,7 +28,13 @@ namespace Microsoft.Build.Execution
     /// and evaluation has already been performed, so it is unnecessary bulk.
     /// </remarks>
     [DebuggerDisplay("{ItemType}={EvaluatedInclude} #DirectMetadata={DirectMetadataCount})")]
-    public class ProjectItemInstance : IItem<ProjectMetadataInstance>, ITaskItem2, IMetadataTable, ITranslatable, IDeepCloneable<ProjectItemInstance>
+    public class ProjectItemInstance :
+        IItem<ProjectMetadataInstance>,
+        ITaskItem2,
+        IMetadataTable,
+        ITranslatable,
+        IDeepCloneable<ProjectItemInstance>,
+        IMetadataContainer
     {
         /// <summary>
         /// The project instance to which this item belongs.
@@ -515,6 +521,8 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
             return ((ITaskItem2)_taskItem).CloneCustomMetadataEscaped();
         }
 
+        IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata() => _taskItem.EnumerateMetadata();
+
         #region IMetadataTable Members
 
         /// <summary>
@@ -723,7 +731,11 @@ internal sealed class TaskItem :
 #if FEATURE_APPDOMAIN
             MarshalByRefObject,
 #endif
-            ITaskItem2, IItem<ProjectMetadataInstance>, ITranslatable, IEquatable<TaskItem>
+            ITaskItem2,
+            IItem<ProjectMetadataInstance>,
+            ITranslatable,
+            IEquatable<TaskItem>,
+            IMetadataContainer
         {
             /// <summary>
             /// The source file that defined this item.
@@ -1045,6 +1057,36 @@ internal int DirectMetadataCount
                 get { return (_directMetadata == null) ? 0 : _directMetadata.Count; }
             }
 
+            /// <summary>
+            /// Efficient way to retrieve metadata used by packet serialization
+            /// and binary logger.
+            /// </summary>
+            public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
+            {
+                // If we have item definitions, call the expensive property that does the right thing.
+                // Otherwise use _directMetadata to avoid allocations caused by DeepClone().
+                var list = _itemDefinitions != null ? MetadataCollection : _directMetadata;
+                if (list != null)
+                {
+                    return EnumerateMetadata(list);
+                }
+                else
+                {
+                    return Array.Empty<KeyValuePair<string, string>>();
+                }
+            }
+
+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
+            {
+                foreach (var projectMetadataInstance in list)
+                {
+                    if (projectMetadataInstance != null)
+                    {
+                        yield return new KeyValuePair<string, string>(projectMetadataInstance.Name, projectMetadataInstance.EvaluatedValue);
+                    }
+                }
+            }
+
             /// <summary>
             /// Unordered collection of evaluated metadata on the item.
             /// If there is no metadata, returns an empty collection.
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 411fa986484..541e352c893 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -206,10 +206,8 @@ public void SetPropertyValue(TaskPropertyInfo property, object value)
         /// </summary>
         public object GetPropertyValue(TaskPropertyInfo property)
         {
-            if (_setParameters.ContainsKey(property.Name))
+            if (_setParameters.TryGetValue(property.Name, out object value))
             {
-                object value = _setParameters[property.Name];
-
                 // If we returned an exception, then we want to throw it when we 
                 // do the get.  
                 if (value is Exception)
@@ -217,7 +215,7 @@ public object GetPropertyValue(TaskPropertyInfo property)
                     throw (Exception)value;
                 }
 
-                return _setParameters[property.Name];
+                return value;
             }
             else
             {
@@ -280,7 +278,10 @@ public bool Execute()
                         _taskType.Type.FullName,
                         AssemblyUtilities.GetAssemblyLocation(_taskType.Type.GetTypeInfo().Assembly),
                         _setParameters,
-                        new Dictionary<string, string>(_buildComponentHost.BuildParameters.GlobalProperties)
+                        new Dictionary<string, string>(_buildComponentHost.BuildParameters.GlobalProperties),
+                        _taskLoggingContext.GetWarningsAsErrors(),
+                        _taskLoggingContext.GetWarningsAsMessages()
+                        
                     );
 
             try
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index d8c90800210..dcb22fc4979 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -27,5 +27,6 @@ internal enum BinaryLogRecordKind
         PropertyInitialValueSet,
         NameValueList,
         String,
+        TaskParameter
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index c6456c1a759..e4dc9c80b9c 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -2,6 +2,7 @@
 using System.IO;
 using System.IO.Compression;
 using System.Threading;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -14,6 +15,14 @@ namespace Microsoft.Build.Logging
     /// <remarks>The class is public so that we can call it from MSBuild.exe when replaying a log file.</remarks>
     public sealed class BinaryLogReplayEventSource : EventArgsDispatcher
     {
+        /// Touches the <see cref="ItemGroupLoggingHelper"/> static constructor
+        /// to ensure it initializes <see cref="TaskParameterEventArgs.MessageGetter"/>
+        /// and <see cref="TaskParameterEventArgs.DictionaryFactory"/>
+        static BinaryLogReplayEventSource()
+        {
+            _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
+        }
+
         /// <summary>
         /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
         /// </summary>
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index f9e9cb0b295..5274f54ab3a 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -41,7 +41,9 @@ public sealed class BinaryLogger : ILogger
         //      * NameValueList - deduplicate arrays of name-value pairs such as properties, items and metadata
         //                        in a separate record and refer to those records from regular records
         //                        where a list used to be written in-place
-        internal const int FileFormatVersion = 10;
+        // version 11:
+        //   - new record kind: TaskParameterEventArgs
+        internal const int FileFormatVersion = 11;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index bd9ae6e9481..f9af8eed299 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -1,11 +1,17 @@
-﻿using System;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Reflection;
 using System.Text;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
 {
@@ -29,6 +35,8 @@ public class BuildEventArgsReader : IDisposable
         /// <summary>
         /// A list of dictionaries we've encountered so far. Dictionaries are referred to by their order in this list.
         /// </summary>
+        /// <remarks>This is designed to not hold on to strings. We just store the string indices and
+        /// hydrate the dictionary on demand before returning.</remarks>
         private readonly List<(int keyIndex, int valueIndex)[]> nameValueListRecords = new List<(int, int)[]>();
 
         /// <summary>
@@ -146,6 +154,9 @@ public BuildEventArgs Read()
                 case BinaryLogRecordKind.TaskCommandLine:
                     result = ReadTaskCommandLineEventArgs();
                     break;
+                case BinaryLogRecordKind.TaskParameter:
+                    result = ReadTaskParameterEventArgs();
+                    break;
                 case BinaryLogRecordKind.ProjectEvaluationStarted:
                     result = ReadProjectEvaluationStartedEventArgs();
                     break;
@@ -215,14 +226,17 @@ private IDictionary<string, string> GetNameValueList(int id)
             {
                 var list = nameValueListRecords[id];
 
-                var dictionary = new Dictionary<string, string>(list.Length);
+                // We can't cache these as they would hold on to strings.
+                // This reader is designed to not hold onto strings,
+                // so that we can fit in a 32-bit process when reading huge binlogs
+                var dictionary = ArrayDictionary<string, string>.Create(list.Length);
                 for (int i = 0; i < list.Length; i++)
                 {
                     string key = GetStringFromRecord(list[i].keyIndex);
                     string value = GetStringFromRecord(list[i].valueIndex);
                     if (key != null)
                     {
-                        dictionary[key] = value;
+                        dictionary.Add(key, value);
                     }
                 }
 
@@ -596,6 +610,27 @@ private BuildEventArgs ReadTaskCommandLineEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadTaskParameterEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            // Read unused Importance, it defaults to Low
+            ReadInt32();
+
+            var kind = (TaskParameterMessageKind)ReadInt32();
+            var itemName = ReadDeduplicatedString();
+            var items = ReadTaskItemList() as IList;
+
+            var e = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
+                fields.BuildEventContext,
+                kind,
+                itemName,
+                items,
+                true,
+                fields.Timestamp);
+            e.ProjectFile = fields.ProjectFile;
+            return e;
+        }
+
         private BuildEventArgs ReadCriticalBuildMessageEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
@@ -896,65 +931,12 @@ private IDictionary<string, string> ReadLegacyStringDictionary()
             return result;
         }
 
-        private class TaskItem : ITaskItem
-        {
-            private static readonly Dictionary<string, string> emptyMetadata = new Dictionary<string, string>();
-
-            public string ItemSpec { get; set; }
-            public IDictionary<string, string> Metadata { get; }
-
-            public TaskItem()
-            {
-                Metadata = new Dictionary<string, string>();
-            }
-
-            public TaskItem(string itemSpec, IDictionary<string, string> metadata)
-            {
-                ItemSpec = itemSpec;
-                Metadata = metadata ?? emptyMetadata;
-            }
-
-            public int MetadataCount => Metadata.Count;
-
-            public ICollection MetadataNames => (ICollection)Metadata.Keys;
-
-            public IDictionary CloneCustomMetadata()
-            {
-                return (IDictionary)Metadata;
-            }
-
-            public void CopyMetadataTo(ITaskItem destinationItem)
-            {
-                throw new NotImplementedException();
-            }
-
-            public string GetMetadata(string metadataName)
-            {
-                return Metadata[metadataName];
-            }
-
-            public void RemoveMetadata(string metadataName)
-            {
-                throw new NotImplementedException();
-            }
-
-            public void SetMetadata(string metadataName, string metadataValue)
-            {
-                throw new NotImplementedException();
-            }
-
-            public override string ToString()
-            {
-                return $"{ItemSpec} Metadata: {MetadataCount}";
-            }
-        }
-
         private ITaskItem ReadTaskItem()
         {
             string itemSpec = ReadDeduplicatedString();
             var metadata = ReadStringDictionary();
 
-            var taskItem = new TaskItem(itemSpec, metadata);
+            var taskItem = new TaskItemData(itemSpec, metadata);
             return taskItem;
         }
 
@@ -1079,7 +1061,10 @@ private string GetStringFromRecord(int index)
 
         private int ReadInt32()
         {
-            return Read7BitEncodedInt(binaryReader);
+            // on some platforms (net5) this method was added to BinaryReader
+            // but it's not available on others. Call our own extension method
+            // explicitly to avoid ambiguity.
+            return BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
         }
 
         private long ReadInt64()
@@ -1102,30 +1087,6 @@ private TimeSpan ReadTimeSpan()
             return new TimeSpan(binaryReader.ReadInt64());
         }
 
-        private int Read7BitEncodedInt(BinaryReader reader)
-        {
-            // Read out an Int32 7 bits at a time.  The high bit
-            // of the byte when on means to continue reading more bytes.
-            int count = 0;
-            int shift = 0;
-            byte b;
-            do
-            {
-                // Check for a corrupted stream.  Read a max of 5 bytes.
-                // In a future version, add a DataFormatException.
-                if (shift == 5 * 7)  // 5 bytes max per Int32, shift += 7
-                {
-                    throw new FormatException();
-                }
-
-                // ReadByte handles end of stream cases for us.
-                b = reader.ReadByte();
-                count |= (b & 0x7F) << shift;
-                shift += 7;
-            } while ((b & 0x80) != 0);
-            return count;
-        }
-
         private ProfiledLocation ReadProfiledLocation()
         {
             var numberOfHits = ReadInt32();
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 3b37d1404cf..1acc641650b 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -1,13 +1,19 @@
-﻿using System;
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
 using System.Linq;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
 {
@@ -128,71 +134,33 @@ public void Write(BuildEventArgs e)
 
         private void WriteCore(BuildEventArgs e)
         {
-            // the cases are ordered by most used first for performance
-            if (e is BuildMessageEventArgs)
-            {
-                Write((BuildMessageEventArgs)e);
-            }
-            else if (e is TaskStartedEventArgs)
-            {
-                Write((TaskStartedEventArgs)e);
-            }
-            else if (e is TaskFinishedEventArgs)
-            {
-                Write((TaskFinishedEventArgs)e);
-            }
-            else if (e is TargetStartedEventArgs)
-            {
-                Write((TargetStartedEventArgs)e);
-            }
-            else if (e is TargetFinishedEventArgs)
-            {
-                Write((TargetFinishedEventArgs)e);
-            }
-            else if (e is BuildErrorEventArgs)
-            {
-                Write((BuildErrorEventArgs)e);
-            }
-            else if (e is BuildWarningEventArgs)
-            {
-                Write((BuildWarningEventArgs)e);
-            }
-            else if (e is ProjectStartedEventArgs)
-            {
-                Write((ProjectStartedEventArgs)e);
-            }
-            else if (e is ProjectFinishedEventArgs)
-            {
-                Write((ProjectFinishedEventArgs)e);
-            }
-            else if (e is BuildStartedEventArgs)
-            {
-                Write((BuildStartedEventArgs)e);
-            }
-            else if (e is BuildFinishedEventArgs)
-            {
-                Write((BuildFinishedEventArgs)e);
-            }
-            else if (e is ProjectEvaluationStartedEventArgs)
-            {
-                Write((ProjectEvaluationStartedEventArgs)e);
-            }
-            else if (e is ProjectEvaluationFinishedEventArgs)
-            {
-                Write((ProjectEvaluationFinishedEventArgs)e);
-            }
-            else
-            {
-                // convert all unrecognized objects to message
-                // and just preserve the message
-                var buildMessageEventArgs = new BuildMessageEventArgs(
-                    e.Message,
-                    e.HelpKeyword,
-                    e.SenderName,
-                    MessageImportance.Normal,
-                    e.Timestamp);
-                buildMessageEventArgs.BuildEventContext = e.BuildEventContext ?? BuildEventContext.Invalid;
-                Write(buildMessageEventArgs);
+            switch (e)
+            {
+                case BuildMessageEventArgs buildMessage: Write(buildMessage); break;
+                case TaskStartedEventArgs taskStarted: Write(taskStarted); break;
+                case TaskFinishedEventArgs taskFinished: Write(taskFinished); break;
+                case TargetStartedEventArgs targetStarted: Write(targetStarted); break;
+                case TargetFinishedEventArgs targetFinished: Write(targetFinished); break;
+                case BuildErrorEventArgs buildError: Write(buildError); break;
+                case BuildWarningEventArgs buildWarning: Write(buildWarning); break;
+                case ProjectStartedEventArgs projectStarted: Write(projectStarted); break;
+                case ProjectFinishedEventArgs projectFinished: Write(projectFinished); break;
+                case BuildStartedEventArgs buildStarted: Write(buildStarted); break;
+                case BuildFinishedEventArgs buildFinished: Write(buildFinished); break;
+                case ProjectEvaluationStartedEventArgs projectEvaluationStarted: Write(projectEvaluationStarted); break;
+                case ProjectEvaluationFinishedEventArgs projectEvaluationFinished: Write(projectEvaluationFinished); break;
+                default:
+                    // convert all unrecognized objects to message
+                    // and just preserve the message
+                    var buildMessageEventArgs = new BuildMessageEventArgs(
+                        e.Message,
+                        e.HelpKeyword,
+                        e.SenderName,
+                        MessageImportance.Normal,
+                        e.Timestamp);
+                    buildMessageEventArgs.BuildEventContext = e.BuildEventContext ?? BuildEventContext.Invalid;
+                    Write(buildMessageEventArgs);
+                    break;
             }
         }
 
@@ -389,51 +357,57 @@ private void Write(BuildWarningEventArgs e)
 
         private void Write(BuildMessageEventArgs e)
         {
-            if (e is CriticalBuildMessageEventArgs)
+            if (e is TaskParameterEventArgs taskParameter)
             {
-                Write((CriticalBuildMessageEventArgs)e);
+                Write(taskParameter);
                 return;
             }
 
-            if (e is TaskCommandLineEventArgs)
+            if (e is CriticalBuildMessageEventArgs criticalBuildMessage)
             {
-                Write((TaskCommandLineEventArgs)e);
+                Write(criticalBuildMessage);
                 return;
             }
 
-            if (e is ProjectImportedEventArgs)
+            if (e is TaskCommandLineEventArgs taskCommandLine)
             {
-                Write((ProjectImportedEventArgs)e);
+                Write(taskCommandLine);
                 return;
             }
 
-            if (e is TargetSkippedEventArgs)
+            if (e is ProjectImportedEventArgs projectImported)
             {
-                Write((TargetSkippedEventArgs)e);
+                Write(projectImported);
                 return;
             }
 
-            if (e is PropertyReassignmentEventArgs)
+            if (e is TargetSkippedEventArgs targetSkipped)
             {
-                Write((PropertyReassignmentEventArgs)e);
+                Write(targetSkipped);
                 return;
             }
 
-            if (e is UninitializedPropertyReadEventArgs)
+            if (e is PropertyReassignmentEventArgs propertyReassignment)
             {
-                Write((UninitializedPropertyReadEventArgs)e);
+                Write(propertyReassignment);
                 return;
             }
 
-            if (e is EnvironmentVariableReadEventArgs)
+            if (e is UninitializedPropertyReadEventArgs uninitializedPropertyRead)
             {
-                Write((EnvironmentVariableReadEventArgs)e);
+                Write(uninitializedPropertyRead);
                 return;
             }
 
-            if (e is PropertyInitialValueSetEventArgs)
+            if (e is EnvironmentVariableReadEventArgs environmentVariableRead)
             {
-                Write((PropertyInitialValueSetEventArgs)e);
+                Write(environmentVariableRead);
+                return;
+            }
+
+            if (e is PropertyInitialValueSetEventArgs propertyInitialValueSet)
+            {
+                Write(propertyInitialValueSet);
                 return;
             }
 
@@ -507,9 +481,18 @@ private void Write(TaskCommandLineEventArgs e)
             WriteDeduplicatedString(e.TaskName);
         }
 
-        private void WriteBuildEventArgsFields(BuildEventArgs e)
+        private void Write(TaskParameterEventArgs e)
         {
-            var flags = GetBuildEventArgsFieldFlags(e);
+            Write(BinaryLogRecordKind.TaskParameter);
+            WriteMessageFields(e, writeMessage: false);
+            Write((int)e.Kind);
+            WriteDeduplicatedString(e.ItemType);
+            WriteTaskItemList(e.Items, e.LogItemMetadata);
+        }
+
+        private void WriteBuildEventArgsFields(BuildEventArgs e, bool writeMessage = true)
+        {
+            var flags = GetBuildEventArgsFieldFlags(e, writeMessage);
             Write((int)flags);
             WriteBaseFields(e, flags);
         }
@@ -547,9 +530,9 @@ private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags)
             }
         }
 
-        private void WriteMessageFields(BuildMessageEventArgs e)
+        private void WriteMessageFields(BuildMessageEventArgs e, bool writeMessage = true)
         {
-            var flags = GetBuildEventArgsFieldFlags(e);
+            var flags = GetBuildEventArgsFieldFlags(e, writeMessage);
             flags = GetMessageFlags(e, flags);
 
             Write((int)flags);
@@ -644,7 +627,7 @@ private static BuildEventArgsFieldFlags GetMessageFlags(BuildMessageEventArgs e,
             return flags;
         }
 
-        private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventArgs e)
+        private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventArgs e, bool writeMessage = true)
         {
             var flags = BuildEventArgsFieldFlags.None;
             if (e.BuildEventContext != null)
@@ -657,7 +640,7 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
                 flags |= BuildEventArgsFieldFlags.HelpHeyword;
             }
 
-            if (!string.IsNullOrEmpty(e.Message))
+            if (writeMessage)
             {
                 flags |= BuildEventArgsFieldFlags.Message;
             }
@@ -681,21 +664,68 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
             return flags;
         }
 
-        private void WriteTaskItemList(IEnumerable items)
+        private readonly List<object> reusableItemsList = new List<object>();
+
+        private void WriteTaskItemList(IEnumerable items, bool writeMetadata = true)
         {
-            var taskItems = items as IEnumerable<ITaskItem>;
-            if (taskItems == null)
+            if (items == null)
             {
                 Write(false);
                 return;
             }
 
-            Write(taskItems.Count());
+            // For target outputs bypass copying of all items to save on performance.
+            // The proxy creates a deep clone of each item to protect against writes,
+            // but since we're not writing we don't need the deep cloning.
+            // Additionally, it is safe to access the underlying List<ITaskItem> as it's allocated
+            // in a single location and noboby else mutates it after that:
+            // https://github.com/dotnet/msbuild/blob/f0eebf2872d76ab0cd43fdc4153ba636232b222f/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs#L564
+            if (items is TargetLoggingContext.TargetOutputItemsInstanceEnumeratorProxy proxy)
+            {
+                items = proxy.BackingItems;
+            }
+
+            int count;
+
+            if (items is ICollection arrayList)
+            {
+                count = arrayList.Count;
+            }
+            else if (items is ICollection<ITaskItem> genericList)
+            {
+                count = genericList.Count;
+            }
+            else
+            {
+                // enumerate only once
+                foreach (var item in items)
+                {
+                    if (item != null)
+                    {
+                        reusableItemsList.Add(item);
+                    }
+                }
+
+                items = reusableItemsList;
+                count = reusableItemsList.Count;
+            }
+
+            Write(count);
 
-            foreach (var item in taskItems)
+            foreach (var item in items)
             {
-                Write(item);
+                if (item is ITaskItem taskItem)
+                {
+                    Write(taskItem, writeMetadata);
+                }
+                else
+                {
+                    WriteDeduplicatedString(item?.ToString() ?? ""); // itemspec
+                    Write(0); // no metadata
+                }
             }
+
+            reusableItemsList.Clear();
         }
 
         private void WriteProjectItems(IEnumerable items)
@@ -721,40 +751,32 @@ private void WriteProjectItems(IEnumerable items)
             }
         }
 
-        private void Write(ITaskItem item)
+        private void Write(ITaskItem item, bool writeMetadata = true)
         {
             WriteDeduplicatedString(item.ItemSpec);
-
-            nameValueListBuffer.Clear();
-
-            IDictionary customMetadata = item.CloneCustomMetadata();
-
-            foreach (string metadataName in customMetadata.Keys)
+            if (!writeMetadata)
             {
-                string valueOrError;
+                Write((byte)0);
+                return;
+            }
 
-                try
-                {
-                    valueOrError = item.GetMetadata(metadataName);
-                }
-                catch (InvalidProjectFileException e)
-                {
-                    valueOrError = e.Message;
-                }
-                // Temporarily try catch all to mitigate frequent NullReferenceExceptions in
-                // the logging code until CopyOnWritePropertyDictionary is replaced with
-                // ImmutableDictionary. Calling into Debug.Fail to crash the process in case
-                // the exception occures in Debug builds.
-                catch (Exception e)
-                {
-                    valueOrError = e.Message;
-                    Debug.Fail(e.ToString());
-                }
+            // WARNING: Can't use AddRange here because CopyOnWriteDictionary in Microsoft.Build.Utilities.v4.0.dll
+            // is broken. Microsoft.Build.Utilities.v4.0.dll loads from the GAC by XAML markup tooling and it's
+            // implementation doesn't work with AddRange because AddRange special-cases ICollection<T> and
+            // CopyOnWriteDictionary doesn't implement it properly.
+            foreach (var kvp in item.EnumerateMetadata())
+            {
+                nameValueListBuffer.Add(kvp);
+            }
 
-                nameValueListBuffer.Add(new KeyValuePair<string, string>(metadataName, valueOrError));
+            if (nameValueListBuffer.Count > 1)
+            {
+                nameValueListBuffer.Sort((l, r) => StringComparer.OrdinalIgnoreCase.Compare(l.Key, r.Key));
             }
 
             WriteNameValueList();
+
+            nameValueListBuffer.Clear();
         }
 
         private void WriteProperties(IEnumerable properties)
@@ -765,8 +787,6 @@ private void WriteProperties(IEnumerable properties)
                 return;
             }
 
-            nameValueListBuffer.Clear();
-
             // there are no guarantees that the properties iterator won't change, so 
             // take a snapshot and work with the readonly copy
             var propertiesArray = properties.OfType<DictionaryEntry>().ToArray();
@@ -785,6 +805,8 @@ private void WriteProperties(IEnumerable properties)
             }
 
             WriteNameValueList();
+
+            nameValueListBuffer.Clear();
         }
 
         private void Write(BuildEventContext buildEventContext)
@@ -800,8 +822,6 @@ private void Write(BuildEventContext buildEventContext)
 
         private void Write(IEnumerable<KeyValuePair<string, string>> keyValuePairs)
         {
-            nameValueListBuffer.Clear();
-
             if (keyValuePairs != null)
             {
                 foreach (var kvp in keyValuePairs)
@@ -811,6 +831,8 @@ private void Write(IEnumerable<KeyValuePair<string, string>> keyValuePairs)
             }
 
             WriteNameValueList();
+
+            nameValueListBuffer.Clear();
         }
 
         private void WriteNameValueList()
@@ -893,7 +915,7 @@ private void Write(BinaryLogRecordKind kind)
 
         private void Write(int value)
         {
-            Write7BitEncodedInt(binaryWriter, value);
+            BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, value);
         }
 
         private void Write(long value)
@@ -901,19 +923,6 @@ private void Write(long value)
             binaryWriter.Write(value);
         }
 
-        private void Write7BitEncodedInt(BinaryWriter writer, int value)
-        {
-            // Write out an int 7 bits at a time.  The high bit of the byte,
-            // when on, tells reader to continue reading more bytes.
-            uint v = (uint)value;   // support negative numbers
-            while (v >= 0x80)
-            {
-                writer.Write((byte)(v | 0x80));
-                v >>= 7;
-            }
-            writer.Write((byte)v);
-        }
-
         private void Write(byte[] bytes)
         {
             binaryWriter.Write(bytes);
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 2a74ec78a0d..bae76905916 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -429,14 +429,14 @@ private void ShowErrorWarningSummary(IEnumerable<BuildEventArgs> listToProcess)
                 // Check to see if there is a bucket for the warning
                 // If there is no bucket create a new one which contains a list of all the errors which
                 // happened for a given buildEventContext / target
-                if (!groupByProjectEntryPoint.ContainsKey(key))
+                if (!groupByProjectEntryPoint.TryGetValue(key, out var errorWarningEventListByTarget))
                 {
                     // happened for a given buildEventContext / target
-                    var errorWarningEventListByTarget = new List<BuildEventArgs>();
+                    errorWarningEventListByTarget = new List<BuildEventArgs>();
                     groupByProjectEntryPoint.Add(key, errorWarningEventListByTarget);
                 }
                 // Add the error event to the correct bucket
-                groupByProjectEntryPoint[key].Add(errorWarningEventArgs);
+                errorWarningEventListByTarget.Add(errorWarningEventArgs);
             }
 
             BuildEventContext previousEntryPoint = null;
@@ -505,11 +505,11 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
             }
 
             // If there were deferred messages then we should show them now, this will cause the project started event to be shown properly
-            if (_deferredMessages.ContainsKey(e.BuildEventContext))
+            if (_deferredMessages.TryGetValue(e.BuildEventContext, out var deferredMessages))
             {
                 if (!showOnlyErrors && !showOnlyWarnings)
                 {
-                    foreach (BuildMessageEventArgs message in _deferredMessages[e.BuildEventContext])
+                    foreach (BuildMessageEventArgs message in deferredMessages)
                     {
                         // This will display the project started event before the messages is shown
                         this.MessageHandler(sender, message);
@@ -1098,12 +1098,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                        && IsVerbosityAtLeast(LoggerVerbosity.Normal)
                     )
                 {
-                    List<BuildMessageEventArgs> messageList;
-                    if (_deferredMessages.ContainsKey(e.BuildEventContext))
-                    {
-                        messageList = _deferredMessages[e.BuildEventContext];
-                    }
-                    else
+                    if (!_deferredMessages.TryGetValue(e.BuildEventContext, out List<BuildMessageEventArgs> messageList))
                     {
                         messageList = new List<BuildMessageEventArgs>();
                         _deferredMessages.Add(e.BuildEventContext, messageList);
@@ -1689,11 +1684,11 @@ internal void AddEventFinished(string projectTargetNames, BuildEventContext buil
 
                 ErrorUtilities.VerifyThrow(_startedEvent != null, "Cannot have finished counter without started counter. ");
 
-                if (_startedEvent.ContainsKey(buildEventContext))
+                if (_startedEvent.TryGetValue(buildEventContext, out object time))
                 {
                     // Calculate the amount of time spent in the event based on the time stamp of when
                     // the started event was created and when the finished event was created
-                    elapsedTime += (TimeSpan.FromTicks(eventTimeStamp.Ticks - (long)_startedEvent[buildEventContext]));
+                    elapsedTime += (TimeSpan.FromTicks(eventTimeStamp.Ticks - (long)time));
                     _startedEvent.Remove(buildEventContext);
                 }
             }
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index 9e25d8e62e7..8b9c74e5085 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -47,23 +47,18 @@ internal void AddProjectStartedEvent(ProjectStartedEventArgs e, bool requireTime
                     int projectTargetKeyLocal = 1;
                     int projectIncrementKeyLocal;
                     // If we haven't seen this project before (by full path) then
-                    // allocate a new key for it and save it away
-                    if (!_projectKey.ContainsKey(e.ProjectFile))
+                    // allocate a new key for it and save it away. Otherwise, retrieve it.
+                    if (!_projectKey.TryGetValue(e.ProjectFile, out projectIncrementKeyLocal))
                     {
                         _projectIncrementKey++;
 
                         _projectKey[e.ProjectFile] = _projectIncrementKey;
                         projectIncrementKeyLocal = _projectIncrementKey;
                     }
-                    else
-                    {
-                        // We've seen this project before, so retrieve it
-                        projectIncrementKeyLocal = _projectKey[e.ProjectFile];
-                    }
 
                     // If we haven't seen any entrypoint for the current project (by full path) then
                     // allocate a new entry point key
-                    if (!_projectTargetKey.ContainsKey(e.ProjectFile))
+                    if (!_projectTargetKey.TryGetValue(e.ProjectFile, out int tempProjectTargetKeyLocal))
                     {
                         _projectTargetKey[e.ProjectFile] = projectTargetKeyLocal;
                     }
@@ -71,7 +66,7 @@ internal void AddProjectStartedEvent(ProjectStartedEventArgs e, bool requireTime
                     {
                         // We've seen this project before, but not this entrypoint, so increment
                         // the entrypoint key that we have.
-                        projectTargetKeyLocal = _projectTargetKey[e.ProjectFile] + 1;
+                        projectTargetKeyLocal = tempProjectTargetKeyLocal + 1;
                         _projectTargetKey[e.ProjectFile] = projectTargetKeyLocal;
                     }
 
@@ -173,15 +168,7 @@ internal string[] ProjectCallStackFromProject(BuildEventContext e)
         /// </summary>
         internal ProjectStartedEventMinimumFields GetProjectStartedEvent(BuildEventContext e)
         {
-            ProjectStartedEventMinimumFields buildEvent;
-            if (_projectStartedEvents.ContainsKey(e))
-            {
-                buildEvent = _projectStartedEvents[e];
-            }
-            else
-            {
-                buildEvent = null;
-            }
+            _projectStartedEvents.TryGetValue(e, out ProjectStartedEventMinimumFields buildEvent);
             return buildEvent;
         }
 
@@ -190,15 +177,7 @@ internal ProjectStartedEventMinimumFields GetProjectStartedEvent(BuildEventConte
         /// </summary>
         internal TargetStartedEventMinimumFields GetTargetStartedEvent(BuildEventContext e)
         {
-            TargetStartedEventMinimumFields buildEvent;
-            if (_targetStartedEvents.ContainsKey(e))
-            {
-                buildEvent = _targetStartedEvents[e];
-            }
-            else
-            {
-                buildEvent = null;
-            }
+            _targetStartedEvents.TryGetValue(e, out TargetStartedEventMinimumFields buildEvent);
             return buildEvent;
         }
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 6989f8cc24d..2dff53cc972 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -15,7 +15,7 @@
 
     <EnableDefaultItems>false</EnableDefaultItems>
 
-    <GenerateReferenceAssemblySources>true</GenerateReferenceAssemblySources>
+    <GenerateReferenceAssemblySource>true</GenerateReferenceAssemblySource>
     <CreateTlb>true</CreateTlb>
     <IsPackable>true</IsPackable>
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which is used to create, edit, and evaluate MSBuild projects.</PackageDescription>
@@ -31,6 +31,7 @@
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
 
     <PackageReference Include="System.Collections.Immutable" />
+    <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
     <PackageReference Include="System.Text.Json" />
 
@@ -39,7 +40,6 @@
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
-    <Reference Include="System.Configuration" />
     <Reference Include="System.IO.Compression" />
     <PackageReference Include="System.Memory" />
   </ItemGroup>
@@ -127,6 +127,7 @@
     <Compile Include="..\Shared\NodeBuildComplete.cs" />
     <Compile Include="..\Shared\NodeShutdown.cs" />
     <Compile Include="..\Shared\NamedPipeUtil.cs" />
+    <Compile Include="..\Shared\ProcessExtensions.cs" />
     <Compile Include="..\Shared\TaskLoggingHelper.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\TaskLoggingHelper.cs</Link>
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
@@ -332,6 +333,8 @@
     <Compile Include="BackEnd\Shared\BuildRequestBlocker.cs" />
     <Compile Include="BackEnd\Shared\BuildRequestConfiguration.cs" />
     <Compile Include="BackEnd\Shared\BuildResult.cs" />
+    <Compile Include="BackEnd\Shared\ResourceRequest.cs" />
+    <Compile Include="BackEnd\Shared\ResourceResponse.cs" />
     <Compile Include="BackEnd\Shared\CircularDependencyException.cs" />
     <Compile Include="BackEnd\Shared\BuildRequestUnblocker.cs" />
     <Compile Include="BackEnd\Shared\IBuildResults.cs" />
@@ -374,6 +377,7 @@
     <Compile Include="Collections\ReadOnlyConvertingDictionary.cs" />
     <!-- ######################## -->
     <Compile Include="Collections\WeakValueDictionary.cs" />
+    <Compile Include="Collections\ArrayDictionary.cs" />
     <!-- #### CONSTRUCTION MODEL ### -->
     <Compile Include="Construction\ProjectElement.cs" />
     <Compile Include="Construction\ProjectElementContainer.cs" />
@@ -418,8 +422,8 @@
     <Compile Include="Definition\ResolvedImport.cs" />
     <Compile Include="Definition\SubToolset.cs" />
     <Compile Include="Definition\Toolset.cs" />
-    <Compile Include="Definition\ToolsetConfigurationReader.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
-    <Compile Include="..\Shared\ToolsetElement.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
+    <Compile Include="Definition\ToolsetConfigurationReader.cs" />
+    <Compile Include="..\Shared\ToolsetElement.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="Definition\ToolsetPropertyDefinition.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 5b737e6d5f0..ed692c7d2c3 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1070,6 +1070,15 @@
   <data name="OutputPropertyLogMessage" xml:space="preserve">
     <value>Output Property: {0}={1}</value>
   </data>
+  <data name="TaskAcquiredCores" xml:space="preserve">
+    <value>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</value>
+  </data>
+  <data name="TaskReleasedCores" xml:space="preserve">
+    <value>Task "{0}" released {1} cores and now holds {2} cores total.</value>
+  </data>
+  <data name="TaskReleasedCoresWarning" xml:space="preserve">
+    <value>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</value>
+  </data>
   <data name="TaskContinuedDueToContinueOnError" xml:space="preserve">
     <value>Build continuing because "{0}" on the task "{1}" is set to "{2}".</value>
   </data>
@@ -1548,8 +1557,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="OM_MatchingProjectAlreadyInCollection" xml:space="preserve">
     <value>An equivalent project (a project with the same global properties and tools version) is already present in the project collection, with the path "{0}". To load an equivalent into this project collection, unload this project first.</value>
   </data>
-  <data name="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem" xml:space="preserve">
-    <value>Only one item type may be referenced when removing with MatchOnMetadata.</value>
+  <data name="OM_MatchOnMetadataIsRestrictedToReferencedItems" xml:space="preserve">
+    <value>Only item types may be referenced when removing with MatchOnMetadata.</value>
   </data>
   <data name="OM_ProjectWasNotLoaded" xml:space="preserve">
     <value>The project provided was not loaded in the collection.</value>
@@ -1699,6 +1708,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ProjectImportSkippedMissingFile" xml:space="preserve">
     <value>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the file not existing.</value>
   </data>
+  <data name="ProjectImportSkippedExpressionEvaluatedToEmpty" xml:space="preserve">
+    <value>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</value>
+  </data>
   <data name="ProjectImported" xml:space="preserve">
     <value>Importing project "{0}" into project "{1}" at ({2},{3}).</value>
   </data>
@@ -1876,4 +1888,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="NoProjectCachePluginFoundInAssembly" xml:space="preserve">
     <value>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</value>
   </data>
+  <data name="KillingProcessWithPid" xml:space="preserve">
+    <value>Killing process with pid = {0}.</value>
+  </data>
 </root>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 157443afc16..460d8c51045 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">Objekty EvaluationContext vytvořené pomocí SharingPolicy.Isolated nepodporují předávání souborového systému MSBuildFileSystemBase.</target>
+        <target state="translated">Objekty EvaluationContext vytvořené pomocí SharingPolicy.Isolated nepodporují předávání souborového systému MSBuildFileSystemBase.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">Ukončuje se proces s pid = {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">Při odebrání pomocí MatchOnMetadata je možné odkazovat jen na jeden typ položky.</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="translated">Při odebírání pomocí MatchOnMetadata je možné odkazovat jen na typy položek.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">{1} neimportoval projekt {0} v ({2},{3}), protože se výraz vyhodnocuje na prázdný řetězec.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Počáteční hodnota vlastnosti: $({0})={1} Zdroj: {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">Statický graf se načetl za {0} s: počet uzlů: {1}, počet hraničních uzlů: {2}</target>
+        <target state="translated">Statický graf se načetl za {0} s: počet uzlů: {1}, počet hraničních uzlů: {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: Úloha {0} vrátila false, ale do protokolu se nezaznamenala chyba.</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: Úloha {1} načtená ze sestavení {2} na cestě {3} nepodporuje parametr {0}. Zkontrolujte, že parametr v úloze existuje, že &lt;UsingTask&gt; odkazuje na správné sestavení a že se jedná o nastavitelnou vlastnost veřejné instance.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 895d6839645..7856dd8038a 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"Die Übergabe eines MSBuildFileSystemBase-Dateisystems wird von EvaluationContext-Objekten, die mit SharingPolicy.Isolated erstellt wurden, nicht unterstützt."</target>
+        <target state="translated">Die Übergabe eines MSBuildFileSystemBase-Dateisystems an EvaluationContext-Objekte, die mit "SharingPolicy.Isolated" erstellt wurden, wird nicht unterstützt.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">Der Prozess mit PID {0} wird beendet.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">Beim Entfernen mit MatchOnMetadata kann nur ein Elementtyp referenziert werden.</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="translated">Beim Entfernen mit "MatchOnMetadata" können nur Elementtypen referenziert werden.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">Das Projekt "{0}" wurde nicht von "{1}" bei ({2},{3}) importiert, weil der Ausdruck in eine leere Zeichenfolge ausgewertet wurde.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Anfangswert der Eigenschaft: $({0})="{1}", Quelle: {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Statisches Diagramm in {0} Sekunden geladen: {1} Knoten, {2} Edges"</target>
+        <target state="translated">Statisches Diagramm in {0} Sekunden geladen: {1} Knoten, {2} Edges</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: Die Aufgabe "{0}" hat FALSE zurückgegeben, jedoch keinen Fehler protokolliert.</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: Der Parameter "{0}" wird von der Aufgabe "{1}", die aus der Assembly "{2}" und dem Pfad "{3}" geladen wurde, nicht unterstützt. Stellen Sie sicher, dass der Parameter für die Aufgabe vorhanden ist, dass &lt;UsingTask&gt; auf die richtige Assembly verweist und dass die Eigenschaft der öffentlichen Instanz festgelegt werden kann.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index 444ca3a5542..a030cd7e6bd 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -132,6 +132,11 @@
         <target state="new">EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</target>
         <note />
       </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="new">Killing process with pid = {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="new">Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="new">MSB4181: The "{0}" task returned false but did not log an error.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 36a2729aa8b..10135514f9e 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase".</target>
+        <target state="translated">Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">Terminando el proceso con el PID = {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">Solo se puede hacer referencia a un tipo de elemento al quitarlo con MatchOnMetadata.</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="translated">Solo se puede hacer referencia a los objetos de tipo elemento al quitar con MatchOnMetadata</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">"{1}" no importó el proyecto "{0}" en ({2},{3}) porque la expresión se evalúa en una cadena vacía.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Valor inicial de la propiedad: $({0})="{1}" Origen: {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Grafo estático cargado en {0} segundos: {1} nodos, {2} bordes"</target>
+        <target state="translated">Grafo estático cargado en {0} segundos: {1} nodos, {2} bordes</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: La tarea "{0}" devolvió false, pero no registró un error.</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: El parámetro "{0}" no es compatible con la tarea "{1}" que se cargó desde el ensamblado {2} desde la ruta de acceso {3}. Compruebe que el parámetro existe en la tarea, que &lt;UsingTask&gt; apunta al ensamblado correcto y que es una propiedad de instancia pública que puede establecerse.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 26c0b149b57..77795f49d65 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"Les objets EvaluationContext créés avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un système de fichiers MSBuildFileSystemBase."</target>
+        <target state="translated">Les objets EvaluationContext créés avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un système de fichiers MSBuildFileSystemBase.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">Arrêt du processus ayant le PID = {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">Un seul type d'élément peut être référencé pour la suppression à l'aide de MatchOnMetadata.</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="translated">Seuls les types d'élément peuvent être référencés pour la suppression à l'aide de MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">Le projet "{0}" n'a pas été importé par "{1}" sur ({2},{3}), car l'expression a la valeur d'une chaîne vide.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Valeur initiale de la propriété : $({0})="{1}" Source : {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Graphe statique chargé en {0} secondes : {1} nœuds, {2} arêtes"</target>
+        <target state="translated">Graphe statique chargé en {0} secondes : {1} nœuds, {2} arêtes</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: la tâche "{0}" a retourné false mais n'a pas journalisé d'erreur.</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: le paramètre "{0}" n'est pas pris en charge par la tâche "{1}" chargée à partir de l'assembly {2} depuis le chemin {3}. Vérifiez que le paramètre existe pour la tâche, que &lt;UsingTask&gt; pointe vers l'assembly approprié et qu'il s'agit d'une propriété d'instance publique définissable.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 86a00974a5f..2c8d2e9d4ae 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non è possibile passare un file system MSBuildFileSystemBase."</target>
+        <target state="translated">Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non è possibile passare un file system MSBuildFileSystemBase.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">Terminazione del processo con PID = {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">Durante la rimozione con MatchOnMetadata è possibile fare riferimento a un solo tipo di elemento.</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="translated">Durante la rimozione con MatchOnMetadata è possibile fare riferimento a tipi di elemento.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">Il progetto "{0}" non è stato importato da "{1}" alla posizione ({2},{3}) perché l'espressione restituisce una stringa vuota.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Valore iniziale della proprietà: $({0})="{1}". Origine: {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Il grafo statico è stato caricato in {0} secondi: {1} nodi, {2} vertici"</target>
+        <target state="translated">Il grafo statico è stato caricato in {0} secondi: {1} nodi, {2} vertici</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: l'attività "{0}" ha restituito false, ma non è stato registrato alcun errore.</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: il parametro "{0}" non è supportato dall'attività "{1}" caricata dall'assembly {2} e dal percorso {3}. Verificare che il parametro sia presente per l'attività, che &lt;UsingTask&gt; punti all'assembly corretto e che si tratti di un'istanza pubblica e impostabile della proprietà.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 27c3d3f6130..f91a15b4459 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"SharingPolicy.Isolated を指定して作成された EvaluationContext オブジェクトに MSBuildFileSystemBase ファイル システムを渡すことはサポートされていません。"</target>
+        <target state="translated">SharingPolicy.Isolated を指定して作成された EvaluationContext オブジェクトに MSBuildFileSystemBase ファイル システムを渡すことはサポートされていません。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">PID = {0} のプロセスを中止しています。</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">MatchOnMetadata で削除する場合、参照できる項目の種類は 1 つだけです。</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="translated">MatchOnMetadata で削除する場合、参照できるのは項目の種類のみです。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">式の評価結果が空の文字列になったため、プロジェクト "{0}" は "{1}" によって ({2},{3}) でインポートされませんでした。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">プロパティの初期値: $({0})="{1}" ソース: {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"{0} 秒で読み込まれた静的グラフ: {1} ノード、{2} エッジ"</target>
+        <target state="translated">{0} 秒で読み込まれた静的グラフ: {1} ノード、{2} エッジ</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: "{0}" タスクから false が返されましたが、エラーがログに記録されませんでした。</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: "{0}" パラメーターは、パス {3} のアセンブリ {2} から読み込まれた "{1}" タスクではサポートされていません。タスクにこのパラメーターが存在すること、&lt;UsingTask&gt; が適切なアセンブリを指していること、それが設定可能なパブリック インスタンス プロパティであることを確認してください。</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 367cf54895e..3480d5aa9e1 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"SharingPolicy.Isolated로 만든 EvaluationContext 개체는 MSBuildFileSystemBase 파일 시스템 전달을 지원하지 않습니다."</target>
+        <target state="translated">SharingPolicy.Isolated로 만든 EvaluationContext 개체는 MSBuildFileSystemBase 파일 시스템 전달을 지원하지 않습니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">pid가 {0}인 프로세스를 종료하는 중입니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,8 +189,8 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
         <target state="translated">MatchOnMetadata를 사용하여 제거하는 경우 항목 종류를 하나만 참조할 수 있습니다.</target>
         <note />
       </trans-unit>
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">빈 문자열로 평가되는 식 때문에 ({2},{3})의 "{1}"이(가) 프로젝트 "{0}"을(를) 가져오지 않았습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">속성 초기 값: $({0})="{1}" 소스: {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"정적 그래프가 {0}초 안에 로드됨: {1}개 노드, {2}개 에지"</target>
+        <target state="translated">정적 그래프가 {0}초 안에 로드됨: {1}개 노드, {2}개 에지</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: "{0}" 작업이 false를 반환했지만 오류를 기록하지 않았습니다.</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: "{0}" 매개 변수는 경로: {3}의 어셈블리: {2} 어셈블리에서 로드한 "{1}" 작업에서 지원되지 않습니다. 작업에 매개 변수가 있고, &lt;UsingTask&gt;가 올바른 어셈블리를 가리키며, 설정 가능한 public 인스턴스 속성인지 확인하세요.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b13eb7e424f..f2ae7700434 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">„Obiekty EvaluationContext utworzone za pomocą elementu SharingPolicy.Isolated nie obsługują przekazywania za pomocą systemu plików MSBuildFileSystemBase.”</target>
+        <target state="translated">Obiekty EvaluationContext utworzone za pomocą elementu SharingPolicy.Isolated nie obsługują przekazywania za pomocą systemu plików MSBuildFileSystemBase.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">Kasowanie procesu z identyfikatorem pid = {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">Tylko jeden typ elementu może być przywoływany podczas usuwania przy użyciu elementu MatchOnMetadata.</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="translated">Tylko typy elementów mogą być przywoływane podczas usuwania przy użyciu elementu MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">Projekt „{0}” nie został zaimportowany przez projekt „{1}” o ({2},{3}) z powodu wyrażenia ocenianego jako pusty ciąg.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Wartość początkowa właściwości: $({0})=„{1}” Źródło: {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">„Wykres statyczny załadowany w {0} s, węzły: {1}, krawędzie: {2}”</target>
+        <target state="translated">Wykres statyczny załadowany w {0} s, węzły: {1}, krawędzie: {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: Zadanie „{0}” zwróciło wartość false, ale nie zarejestrowało błędu.</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: parametr „{0}” nie jest obsługiwany przez zadanie „{1}” załadowane z zestawu: {2} ze ścieżki: {3}. Sprawdź, czy parametr istnieje w zadaniu, element &lt;UsingTask&gt; wskazuje poprawny zestaw i jest to ustawialna właściwość wystąpienia publicznego.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 188df5f9cf3..d386fdc902b 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"Os objetos EvaluationContext criados com SharingPolicy.Isolable não são compatíveis com o recebimento de um sistema de arquivos MSBuildFileSystemBase."</target>
+        <target state="translated">Os objetos EvaluationContext criados com SharingPolicy.Isolated não são compatíveis com o recebimento de um sistema de arquivos MSBuildFileSystemBase.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">Encerrando o processo com o PID = {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">Somente um tipo de item pode ser referenciado na remoção com MatchOnMetadata.</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="translated">Somente tipos de item podem ser referenciados durante a remoção com MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">O projeto "{0}" não foi importado por "{1}" em ({2},{3}), porque a expressão foi avaliada como uma cadeia de caracteres vazia.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Valor inicial da propriedade: $({0})="{1}" Origem: {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Grafo estático carregado em {0} segundos: {1} nós, {2} bordas"</target>
+        <target state="translated">Grafo estático carregado em {0} segundos: {1} nós, {2} bordas</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: A tarefa "{0}" retornou false, mas não registrou um erro.</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: o parâmetro "{0}" não é compatível com a tarefa "{1}" carregada do assembly: {2} do caminho: {3}. Verifique se o parâmetro existe na tarefa, se a tarefa &lt;UsingTask&gt; aponta para o assembly correto e se é uma propriedade de instância pública configurável.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 508d9a08b28..a2a3ffc13fb 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"Объекты EvaluationContext, созданные с помощью SharingPolicy.Isolated, не поддерживают передачу в файловую систему MSBuildFileSystemBase."</target>
+        <target state="translated">Объекты EvaluationContext, созданные с помощью SharingPolicy.Isolated, не поддерживают передачу в файловую систему MSBuildFileSystemBase.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">Завершение процесса с идентификатором {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">При удалении с помощью MatchOnMetadata можно ссылаться только на один тип элемента.</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="translated">При удалении с помощью MatchOnMetadata можно ссылаться только на типы элементов.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">Проект "{0}" не был импортирован "{1}" в ({2},{3}), так как результатом вычисления выражения была пустая строка.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Начальное значение свойства: $({0})="{1}" Источник: {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Статический граф загружен за {0} с: узлов — {1}, ребер — {2}."</target>
+        <target state="translated">Статический граф загружен за {0} с: узлов — {1}, ребер — {2}.</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: задача "{0}" возвратила значение false, но не зарегистрировала ошибку.</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: параметр "{0}" не поддерживается задачей "{1}", загруженной из сборки {2} (путь: {3}). Убедитесь, что параметр существует в задаче, что &lt;UsingTask&gt; указывает на правильную сборку и что этот параметр является устанавливаемым свойством открытого экземпляра.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 9bcd9bde59b..0e7ece86344 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"SharingPolicy.Isolated ile oluşturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin geçirilmesini desteklemez."</target>
+        <target state="translated">SharingPolicy.Isolated ile oluşturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin geçirilmesini desteklemez.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">PID = {0} işlemi sonlandırılıyor.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">MatchOnMetadata ile kaldırırken yalnızca bir öğe türüne başvurulabilir.</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="translated">MatchOnMetadata ile kaldırırken yalnızca öğe türlerine başvurulabilir.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">"{0}" adlı proje, ifadenin boş dize olarak değerlendirilmesi nedeniyle ({2},{3}) konumundaki "{1}" tarafından içeri aktarılmadı.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Özellik başlangıç değeri: $({0})="{1}" Kaynak: {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Statik graf {0} saniye içinde yüklendi: {1} düğüm, {2} uç"</target>
+        <target state="translated">Statik graf {0} saniye içinde yüklendi: {1} düğüm, {2} uç</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: "{0}" görevi false değerini döndürdü ancak günlüğe hata kaydetmedi.</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: "{0}" parametresi, {2} derlemesinin {3} yolundan yüklenmiş "{1}" görevi tarafından desteklenmiyor. Parametrenin görevde bulunduğunu, &lt;UsingTask&gt; öğesinin doğru derlemeyi işaret ettiğini ve bu özelliğin ayarlanabilir bir ortak örnek özelliği olduğunu doğrulayın.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 942ffe8d692..7157572b7e0 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">“使用 SharingPolicy.Isolated 创建的 EvaluationContext 对象不支持通过 MSBuildFileSystemBase 文件系统传递。”</target>
+        <target state="translated">使用 SharingPolicy.Isolated 创建的 EvaluationContext 对象不支持通过 MSBuildFileSystemBase 文件系统传递。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">正在终止进程，pid = {0}。</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">使用 MatchOnMetadata 删除时，只能引用一个项类型。</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="translated">使用 MatchOnMetadata 删除时，只能引用项类型。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">由于表达式评估为空字符串，因此项目“{0}”不由 ({2}、{3}) 处的“{1}”导入。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">属性初始值: $({0})=“{1}”，源: {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">“静态图形已在 {0} 秒内加载: {1} 个节点、{2} 个边”</target>
+        <target state="translated">静态图形已在 {0} 秒内加载: {1} 个节点、{2} 个边</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: “{0}”任务返回了 false，但未记录错误。</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: 从路径 {3} 处的程序集 {2} 加载的“{1}”任务不支持“{0}”参数。请验证任务上是否存在该参数、&lt;UsingTask&gt; 是否指向正确的程序集，以及它是否是可设置的公共实例属性。</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index eadd2f2e6cc..d8fb2e4baa4 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -129,7 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"使用 SharingPolicy.Isolated 建立的 EvaluationContext 物件不支援以 MSBuildFileSystemBase 檔案系統傳遞。"</target>
+        <target state="translated">使用 SharingPolicy.Isolated 建立的 EvaluationContext 物件不支援以 MSBuildFileSystemBase 檔案系統傳遞。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="KillingProcessWithPid">
+        <source>Killing process with pid = {0}.</source>
+        <target state="translated">正在終止 pid = {0} 的處理序。</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -184,9 +189,9 @@
       LOCALIZATION:  Do not localize the following words: ProjectInstanceFactoryFunc.
     </note>
       </trans-unit>
-      <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
-        <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="translated">使用 MatchOnMetadata 移除時，只能參考一個項目類型。</target>
+      <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
+        <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
+        <target state="translated">使用 MatchOnMetadata 移除時，只能參考項目類型。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -237,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">因為運算式評估為空字串，所以專案 "{0}" 未在 ({2},{3}) 由 "{1}" 匯入。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">屬性初始值: $({0})="{1}" 來源: {2}</target>
@@ -263,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"在 {0} 秒內載入的靜態圖形: {1} 個節點、{2} 個邊緣"</target>
+        <target state="translated">在 {0} 秒內載入的靜態圖形: {1} 個節點、{2} 個邊緣</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -288,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: "{0}" 工作傳回了 False，但未記錄錯誤。</target>
@@ -1671,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: 從路徑 {3} 中組件 {2} 所載入的 "{1}" 工作不支援 "{0}" 參數。請確認該參數存在於該工作中、&lt;UsingTask&gt; 指向正確的組件，且為可設定的公用執行個體屬性。</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 509be5de918..02b46c31efa 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -53,17 +53,15 @@ public EngineFileUtilities(FileMatcher fileMatcher)
         /// </summary>
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
-        /// <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off</param>
         /// <returns>Array of file paths, unescaped.</returns>
         internal string[] GetFileListUnescaped
             (
             string directoryEscaped,
-            string filespecEscaped,
-            bool forceEvaluate = false
+            string filespecEscaped
             )
 
         {
-            return GetFileList(directoryEscaped, filespecEscaped, false /* returnEscaped */, forceEvaluate);
+            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: false, forceEvaluateWildCards: false);
         }
 
         /// <summary>
@@ -89,31 +87,21 @@ internal string[] GetFileListEscaped
             bool forceEvaluate = false
             )
         {
-            return GetFileList(directoryEscaped, filespecEscaped, true /* returnEscaped */, forceEvaluate, excludeSpecsEscaped);
+            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: true, forceEvaluate, excludeSpecsEscaped);
         }
 
         internal static bool FilespecHasWildcards(string filespecEscaped)
         {
-            bool containsEscapedWildcards = EscapingUtilities.ContainsEscapedWildcards(filespecEscaped);
-            bool containsRealWildcards = FileMatcher.HasWildcards(filespecEscaped);
-
-            if (containsEscapedWildcards && containsRealWildcards)
-            {
-                // Umm, this makes no sense.  The item's Include has both escaped wildcards and 
-                // real wildcards.  What does he want us to do?  Go to the file system and find
-                // files that literally have '*' in their filename?  Well, that's not going to 
-                // happen because '*' is an illegal character to have in a filename.
-
-                return false;
-            }
-            else if (!containsEscapedWildcards && containsRealWildcards)
-            {
-                return true;
-            }
-            else
+            if (!FileMatcher.HasWildcards(filespecEscaped))
             {
                 return false;
             }
+
+            // If the item's Include has both escaped wildcards and real wildcards, then it's
+            // not clear what they are asking us to do.  Go to the file system and find
+            // files that literally have '*' in their filename?  Well, that's not going to
+            // happen because '*' is an illegal character to have in a filename.
+            return !EscapingUtilities.ContainsEscapedWildcards(filespecEscaped);
         }
 
         /// <summary>
@@ -143,11 +131,6 @@ private string[] GetFileList
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
 
-            if (excludeSpecsEscaped == null)
-            {
-                excludeSpecsEscaped = Enumerable.Empty<string>();
-            }
-
             string[] fileList;
 
             if (!FilespecHasWildcards(filespecEscaped) ||
@@ -166,7 +149,7 @@ private string[] GetFileList
                 // Unescape before handing it to the filesystem.
                 var directoryUnescaped = EscapingUtilities.UnescapeAll(directoryEscaped);
                 var filespecUnescaped = EscapingUtilities.UnescapeAll(filespecEscaped);
-                var excludeSpecsUnescaped = excludeSpecsEscaped.Where(IsValidExclude).Select(i => EscapingUtilities.UnescapeAll(i)).ToList();
+                var excludeSpecsUnescaped = excludeSpecsEscaped?.Where(IsValidExclude).Select(i => EscapingUtilities.UnescapeAll(i)).ToList();
 
                 // Get the list of actual files which match the filespec.  Put
                 // the list into a string array.  If the filespec started out
diff --git a/src/Build/Utilities/FileSpecMatchTester.cs b/src/Build/Utilities/FileSpecMatchTester.cs
index e48fca39e77..41aaea15e97 100644
--- a/src/Build/Utilities/FileSpecMatchTester.cs
+++ b/src/Build/Utilities/FileSpecMatchTester.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
+using System;
 using System.Diagnostics;
 using System.IO;
 using System.Text.RegularExpressions;
@@ -12,36 +13,58 @@ internal readonly struct FileSpecMatcherTester
     {
         private readonly string _currentDirectory;
         private readonly string _unescapedFileSpec;
+        private readonly string _filenamePattern;
         private readonly Regex _regex;
         
-        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, Regex regex)
+        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, string filenamePattern, Regex regex)
         {
             Debug.Assert(!string.IsNullOrEmpty(unescapedFileSpec));
+            Debug.Assert(currentDirectory != null);
 
             _currentDirectory = currentDirectory;
             _unescapedFileSpec = unescapedFileSpec;
+            _filenamePattern = filenamePattern;
             _regex = regex;
         }
 
         public static FileSpecMatcherTester Parse(string currentDirectory, string fileSpec)
         {
             string unescapedFileSpec = EscapingUtilities.UnescapeAll(fileSpec);
-            Regex regex = EngineFileUtilities.FilespecHasWildcards(fileSpec) ? CreateRegex(unescapedFileSpec, currentDirectory) : null;
+            string filenamePattern = null;
+            Regex regex = null;
 
-            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, regex);
+            if (EngineFileUtilities.FilespecHasWildcards(fileSpec))
+            {
+                CreateRegexOrFilenamePattern(unescapedFileSpec, currentDirectory, out filenamePattern, out regex);
+            }
+
+            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);
         }
 
         public bool IsMatch(string fileToMatch)
         {
             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));
 
-            // check if there is a regex matching the file
+            // We do the matching using one of three code paths, depending on the value of _filenamePattern and _regex.
             if (_regex != null)
             {
-                var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));
+                string normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));
                 return _regex.IsMatch(normalizedFileToMatch);
             }
 
+            if (_filenamePattern != null)
+            {
+                // Check file name first as it's more likely to not match.
+                string filename = Path.GetFileName(fileToMatch);
+                if (!FileMatcher.IsMatch(filename, _filenamePattern))
+                {
+                    return false;
+                }
+
+                var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));
+                return normalizedFileToMatch.StartsWith(_currentDirectory, StringComparison.OrdinalIgnoreCase);
+            }
+
             return FileUtilities.ComparePathsNoThrow(_unescapedFileSpec, fileToMatch, _currentDirectory, alwaysIgnoreCase: true);
         }
 
@@ -49,17 +72,27 @@ public bool IsMatch(string fileToMatch)
         // without this normalization step, strings pointing outside the globbing cone would still match when they shouldn't
         // for example, we dont want "**/*.cs" to match "../Shared/Foo.cs"
         // todo: glob rooting knowledge partially duplicated with MSBuildGlob.Parse and FileMatcher.ComputeFileEnumerationCacheKey
-        private static Regex CreateRegex(string unescapedFileSpec, string currentDirectory)
+        private static void CreateRegexOrFilenamePattern(string unescapedFileSpec, string currentDirectory, out string filenamePattern, out Regex regex)
         {
             FileMatcher.Default.SplitFileSpec(
-            unescapedFileSpec,
-            out string fixedDirPart,
-            out string wildcardDirectoryPart,
-            out string filenamePart);
+                unescapedFileSpec,
+                out string fixedDirPart,
+                out string wildcardDirectoryPart,
+                out string filenamePart);
 
             if (FileUtilities.PathIsInvalid(fixedDirPart))
             {
-                return null;
+                filenamePattern = null;
+                regex = null;
+                return;
+            }
+
+            // Most file specs have "**" as their directory specification so we special case these and make matching faster.
+            if (string.IsNullOrEmpty(fixedDirPart) && FileMatcher.IsRecursiveDirectoryMatch(wildcardDirectoryPart))
+            {
+                filenamePattern = filenamePart;
+                regex = null;
+                return;
             }
 
             var absoluteFixedDirPart = Path.Combine(currentDirectory, fixedDirPart);
@@ -74,11 +107,12 @@ private static Regex CreateRegex(string unescapedFileSpec, string currentDirecto
 
             FileMatcher.Default.GetFileSpecInfoWithRegexObject(
                 recombinedFileSpec,
-                out Regex regex,
+                out Regex regexObject,
                 out bool _,
                 out bool isLegal);
 
-            return isLegal ? regex : null;
+            filenamePattern = null;
+            regex = isLegal ? regexObject : null;
         }
     }
 }
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index e60c3a07af2..373a024e26c 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -32,7 +32,11 @@ public NuGetFrameworkWrapper()
                 BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
             try
             {
+#if FEATURE_ASSEMBLYLOADCONTEXT
                 var NuGetAssembly = Assembly.LoadFrom(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
+#else
+                var NuGetAssembly = Assembly.LoadFile(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
+#endif
                 var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
                 var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
                 var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index 5db9a22e37c..c1503c698ef 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -3,10 +3,6 @@
 #if FEATURE_WIN32_REGISTRY
 
 using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-using System.Security;
 
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
diff --git a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
index 1fa50bc5c3d..66d4a698bf3 100644
--- a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
+++ b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
@@ -2,7 +2,7 @@
   <PropertyGroup>
     <AssemblyName>Microsoft.Build.Conversion.Core</AssemblyName>
     <TargetFramework>$(FullFrameworkTFM)</TargetFramework>
-    <GenerateReferenceAssemblySources>true</GenerateReferenceAssemblySources>
+    <GenerateReferenceAssemblySource>true</GenerateReferenceAssemblySource>
     <EnableDefaultItems>false</EnableDefaultItems>
     <IsPackable>true</IsPackable>
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which contains logic for converting projects.  NOTE: This assembly is deprecated.</PackageDescription>
diff --git a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
index 99f763a29b4..c409b5b1a14 100644
--- a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
+++ b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
@@ -2,7 +2,7 @@
   <PropertyGroup>
     <TargetFramework>$(FullFrameworkTFM)</TargetFramework>
     <NoWarn>$(NoWarn);618</NoWarn>
-    <GenerateReferenceAssemblySources>true</GenerateReferenceAssemblySources>
+    <GenerateReferenceAssemblySource>true</GenerateReferenceAssemblySource>
     <EnableDefaultItems>false</EnableDefaultItems>
     <CreateTlb>true</CreateTlb>
     <AdditionalTlbExpAsmPaths>$(XMakeRefPath)</AdditionalTlbExpAsmPaths>
diff --git a/src/Deprecated/Engine/Resources/xlf/Strings.ru.xlf b/src/Deprecated/Engine/Resources/xlf/Strings.ru.xlf
index 40f34cac944..14c6ab53128 100644
--- a/src/Deprecated/Engine/Resources/xlf/Strings.ru.xlf
+++ b/src/Deprecated/Engine/Resources/xlf/Strings.ru.xlf
@@ -769,7 +769,7 @@
       </trans-unit>
       <trans-unit id="FatalTaskError">
         <source>MSB4018: The "{0}" task failed unexpectedly.</source>
-        <target state="translated">MSB4018: непредвиденная ошибка при выполнении задачи {0}".</target>
+        <target state="translated">MSB4018: непредвиденная ошибка при выполнении задачи "{0}".</target>
         <note>{StrBegin="MSB4018: "}UE: This message is shown when a task terminates because of an unhandled exception. The cause is most likely a
     programming error in the task; however, it is also possible that the unhandled exception originated in the engine, and was
     surfaced through the task when the task called into the engine.</note>
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index 6dc05efbbac..1c9c9b38965 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -519,7 +519,7 @@ bool specifyProjectToolsVersion
 
             string additionalProperties = string.Format(
                 CultureInfo.InvariantCulture,
-                "Configuration={0}; Platform={1}; BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)",
+                "Configuration={0}; Platform={1}; BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionFilterName=$(SolutionFilterName); SolutionPath=$(SolutionPath)",
                 EscapingUtilities.Escape(configurationName),
                 EscapingUtilities.Escape(platformName)
             );
@@ -1608,7 +1608,7 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
                 BuildTask msbuildTask = newTarget.AddNewTask("MSBuild");
                 msbuildTask.Condition = buildItemReference + " != ''";
                 msbuildTask.SetParameterValue("Projects", buildItemReference);
-                msbuildTask.SetParameterValue("Properties", "Configuration=%(Configuration); Platform=%(Platform); BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)");
+                msbuildTask.SetParameterValue("Properties", "Configuration=%(Configuration); Platform=%(Platform); BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionFilterName=$(SolutionFilterName); SolutionPath=$(SolutionPath)");
 
                 if (!string.IsNullOrEmpty(subTargetName))
                 {
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 93836bc46aa..9bafce8e113 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -129,7 +129,7 @@
     <DefineConstants Condition="'$(MachineIndependentBuild)' != 'true'">$(DefineConstants);FEATURE_NODE_REUSE</DefineConstants>
   </PropertyGroup>
 
-  <PropertyGroup Condition="'$(GenerateReferenceAssemblySources)' != 'true'">
+  <PropertyGroup Condition="'$(GenerateReferenceAssemblySource)' != 'true'">
     <GenerateDocumentationFile>false</GenerateDocumentationFile>
     <DocumentationFile/>
   </PropertyGroup>
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index e957eaa9db1..d91dd8521f6 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -57,9 +57,9 @@
 
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
 
-    <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) -excludeApiList:&quot;$(RepoRoot)ref\ExcludeAPIList.txt&quot;</GenAPIAdditionalParameters>
-    <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) -excludeAttributesList:&quot;$(RepoRoot)ref\ExcludeAttributeList.txt&quot;</GenAPIAdditionalParameters>
-    <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) -headerFile:&quot;$(RepoRoot)ref\LicenseHeader.txt&quot;</GenAPIAdditionalParameters>
+    <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) --exclude-api-list:&quot;$(RepoRoot)ref\ExcludeAPIList.txt&quot;</GenAPIAdditionalParameters>
+    <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) --exclude-attributes-list:&quot;$(RepoRoot)ref\ExcludeAttributeList.txt&quot;</GenAPIAdditionalParameters>
+    <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) --header-file:&quot;$(RepoRoot)ref\LicenseHeader.txt&quot;</GenAPIAdditionalParameters>
 
     <PackageLicenseUrl Condition="'$(PackageLicenseExpression)' == ''">http://go.microsoft.com/fwlink/?LinkId=329770</PackageLicenseUrl>
     <PackageProjectUrl>http://go.microsoft.com/fwlink/?LinkId=624683</PackageProjectUrl>
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index ab0983d1760..45bbe9dc150 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -72,10 +72,10 @@
   <!-- GenAPI settings -->
   <PropertyGroup Condition="'$(MonoBuild)' == 'true'">
     <!-- Disable reference assembly source when building for Mono, as some APIs are excluded when compiling for Mono -->
-    <GenerateReferenceAssemblySources>false</GenerateReferenceAssemblySources>
+    <GenerateReferenceAssemblySource>false</GenerateReferenceAssemblySource>
   </PropertyGroup>
 
-  <PropertyGroup Condition="'$(GenerateReferenceAssemblySources)' == 'true' and $([MSBuild]::IsOSPlatform('windows'))">
+  <PropertyGroup Condition="'$(GenerateReferenceAssemblySource)' == 'true' and $([MSBuild]::IsOSPlatform('windows'))">
     <GenAPIAssemblyName>$(AssemblyName)</GenAPIAssemblyName>
     <GenAPIAssemblyName Condition="'$(GenAPIAssemblyName)' == ''">$(MSBuildProjectName)</GenAPIAssemblyName>
     <GenAPIShortFrameworkIdentifier Condition="$(TargetFramework.StartsWith('net4'))">net</GenAPIShortFrameworkIdentifier>
@@ -85,7 +85,7 @@
     <GenAPITargetPath>$(RepoRoot)ref\$(GenAPIAssemblyName)\$(GenAPIShortFrameworkIdentifier)\$(GenAPIAssemblyName).cs</GenAPITargetPath>
   </PropertyGroup>
 
-  <ItemGroup Condition="'$(GenerateReferenceAssemblySources)' == 'true' and $([MSBuild]::IsOSPlatform('windows'))">
+  <ItemGroup Condition="'$(GenerateReferenceAssemblySource)' == 'true' and $([MSBuild]::IsOSPlatform('windows'))">
     <PackageReference Include="Microsoft.DotNet.GenAPI" PrivateAssets="All" />
   </ItemGroup>
 
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index 1592e8fd480..58dc81f838a 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -111,6 +111,17 @@ public DateTime Timestamp
             }
         }
 
+        /// <summary>
+        /// Exposes the private <see cref="timestamp"/> field to derived types.
+        /// Used for serialization. Avoids the side effects of calling the
+        /// <see cref="Timestamp"/> getter.
+        /// </summary>
+        protected DateTime RawTimestamp
+        {
+            get => timestamp;
+            set => timestamp = value;
+        }
+
         /// <summary>
         /// The thread that raised event.  
         /// </summary>
@@ -155,24 +166,8 @@ internal virtual void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalString(helpKeyword);
             writer.WriteOptionalString(senderName);
             writer.WriteTimestamp(timestamp);
-
-            writer.Write((Int32)threadId);
-
-            if (buildEventContext == null)
-            {
-                writer.Write((byte)0);
-            }
-            else
-            {
-                writer.Write((byte)1);
-                writer.Write((Int32)buildEventContext.NodeId);
-                writer.Write((Int32)buildEventContext.ProjectContextId);
-                writer.Write((Int32)buildEventContext.TargetId);
-                writer.Write((Int32)buildEventContext.TaskId);
-                writer.Write((Int32)buildEventContext.SubmissionId);
-                writer.Write((Int32)buildEventContext.ProjectInstanceId);
-                writer.Write((Int32)buildEventContext.EvaluationId);
-            }
+            writer.Write(threadId);
+            writer.WriteOptionalBuildEventContext(buildEventContext);
         }
 
         /// <summary>
@@ -182,9 +177,9 @@ internal virtual void WriteToStream(BinaryWriter writer)
         /// <param name="version">The version of the runtime the message packet was created from</param>
         internal virtual void CreateFromStream(BinaryReader reader, int version)
         {
-            message = reader.ReadByte() == 0 ? null : reader.ReadString();
-            helpKeyword = reader.ReadByte() == 0 ? null : reader.ReadString();
-            senderName = reader.ReadByte() == 0 ? null : reader.ReadString();
+            message = reader.ReadOptionalString();
+            helpKeyword = reader.ReadOptionalString();
+            senderName = reader.ReadOptionalString();
 
             long timestampTicks = reader.ReadInt64();
 
diff --git a/src/Framework/IBuildEngine8.cs b/src/Framework/IBuildEngine8.cs
new file mode 100644
index 00000000000..0caaad46678
--- /dev/null
+++ b/src/Framework/IBuildEngine8.cs
@@ -0,0 +1,20 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// This interface extends <see cref="IBuildEngine7" /> to let tasks know if a warning
+    /// they are about to log will be converted into an error.
+    /// </summary>
+    public interface IBuildEngine8 : IBuildEngine7
+    {
+        /// <summary>
+        /// Determines whether the logging service will convert the specified
+        /// warning code into an error.
+        /// </summary>
+        /// <param name="warningCode">The warning code to check.</param>
+        /// <returns>A boolean to determine whether the warning should be treated as an error.</returns>
+        public bool ShouldTreatWarningAsError(string warningCode);
+    }
+}
diff --git a/src/Framework/IBuildEngine9.cs b/src/Framework/IBuildEngine9.cs
new file mode 100644
index 00000000000..6e44be92834
--- /dev/null
+++ b/src/Framework/IBuildEngine9.cs
@@ -0,0 +1,25 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// This interface extends <see cref="IBuildEngine8" /> to provide resource management API to tasks.
+    /// </summary>
+    public interface IBuildEngine9 : IBuildEngine8
+    {
+        /// <summary>
+        /// If a task launches multiple parallel processes, it should ask how many cores it can use.
+        /// </summary>
+        /// <param name="requestedCores">The number of cores a task can potentially use.</param>
+        /// <returns>The number of cores a task is allowed to use.</returns>
+        int RequestCores(int requestedCores);
+
+        /// <summary>
+        /// A task should notify the build manager when all or some of the requested cores are not used anymore.
+        /// When task is finished, the cores it requested are automatically released.
+        /// </summary>
+        /// <param name="coresToRelease">Number of cores no longer in use.</param>
+        void ReleaseCores(int coresToRelease);
+    }
+}
diff --git a/src/Framework/IMetadataContainer.cs b/src/Framework/IMetadataContainer.cs
new file mode 100644
index 00000000000..169130cdef3
--- /dev/null
+++ b/src/Framework/IMetadataContainer.cs
@@ -0,0 +1,22 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Provides a way to efficiently enumerate item metadata
+    /// </summary>
+    internal interface IMetadataContainer
+    {
+        /// <summary>
+        /// Returns a list of metadata names and unescaped values, including
+        /// metadata from item definition groups, but not including built-in
+        /// metadata. Implementations should be low-overhead as the method
+        /// is used for serialization (in node packet translator) as well as
+        /// in the binary logger.
+        /// </summary>
+        IEnumerable<KeyValuePair<string, string>> EnumerateMetadata();
+    }
+}
diff --git a/src/Framework/ITaskItemExtensions.cs b/src/Framework/ITaskItemExtensions.cs
new file mode 100644
index 00000000000..53a5e0d5b42
--- /dev/null
+++ b/src/Framework/ITaskItemExtensions.cs
@@ -0,0 +1,65 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace Microsoft.Build.Framework
+{
+    internal static class ITaskItemExtensions
+    {
+        /// <summary>
+        /// Provides a way to efficiently enumerate custom metadata of an item, without built-in metadata.
+        /// </summary>
+        /// <param name="taskItem">TaskItem implementation to return metadata from</param>
+        /// <remarks>WARNING: do NOT use List`1.AddRange to iterate over this collection.
+        /// CopyOnWriteDictionary from Microsoft.Build.Utilities.v4.0.dll is broken.</remarks>
+        /// <returns>A non-null (but possibly empty) enumerable of item metadata.</returns>
+        public static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(this ITaskItem taskItem)
+        {
+            if (taskItem is IMetadataContainer container)
+            {
+                // This is the common case: most implementations should implement this for quick access
+                return container.EnumerateMetadata();
+            }
+
+            // This runs if ITaskItem is Microsoft.Build.Utilities.TaskItem from Microsoft.Build.Utilities.v4.0.dll
+            // that is loaded from the GAC.
+            IDictionary customMetadata = taskItem.CloneCustomMetadata();
+            if (customMetadata is IEnumerable<KeyValuePair<string, string>> enumerableMetadata)
+            {
+                return enumerableMetadata;
+            }
+
+            // In theory this should never be reachable.
+            var list = new KeyValuePair<string, string>[customMetadata.Count];
+            int i = 0;
+
+            foreach (string metadataName in customMetadata.Keys)
+            {
+                string valueOrError;
+
+                try
+                {
+                    valueOrError = taskItem.GetMetadata(metadataName);
+                }
+                // Temporarily try catch all to mitigate frequent NullReferenceExceptions in
+                // the logging code until CopyOnWritePropertyDictionary is replaced with
+                // ImmutableDictionary. Calling into Debug.Fail to crash the process in case
+                // the exception occurres in Debug builds.
+                catch (Exception e)
+                {
+                    valueOrError = e.Message;
+                    Debug.Fail(e.ToString());
+                }
+
+                list[i] = new KeyValuePair<string, string>(metadataName, valueOrError);
+                i += 1;
+            }
+
+            return list;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 5983457827a..939d7db72f7 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -1,16 +1,13 @@
 ﻿<Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
     <TargetFrameworks>$(LibraryTargetFrameworks)</TargetFrameworks>
-    <GenerateReferenceAssemblySources>true</GenerateReferenceAssemblySources>
+    <GenerateReferenceAssemblySource>true</GenerateReferenceAssemblySource>
     <CreateTlb>true</CreateTlb>
     <IsPackable>true</IsPackable>
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which is a common assembly used by other MSBuild assemblies.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <ApplyNgenOptimization Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">partial</ApplyNgenOptimization>
   </PropertyGroup>
-  <ItemGroup>
-    <Compile Remove="BinaryWriterExtensions.cs" />
-  </ItemGroup>
 
   <ItemGroup>
     <PackageReference Include="System.Security.Permissions" Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'" />
@@ -21,6 +18,9 @@
     <Compile Include="..\Shared\Constants.cs">
       <Link>Shared\Constants.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\BinaryReaderExtensions.cs">
+      <Link>Shared\BinaryReaderExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\BinaryWriterExtensions.cs">
       <Link>Shared\BinaryWriterExtensions.cs</Link>
     </Compile>
diff --git a/src/Framework/TaskItemData.cs b/src/Framework/TaskItemData.cs
new file mode 100644
index 00000000000..8441badb819
--- /dev/null
+++ b/src/Framework/TaskItemData.cs
@@ -0,0 +1,68 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Lightweight specialized implementation of <see cref="ITaskItem"/> only used for deserializing items.
+    /// The goal is to minimize overhead when representing deserialized items.
+    /// Used by node packet translator and binary logger.
+    /// </summary>
+    internal class TaskItemData : ITaskItem, IMetadataContainer
+    {
+        private static readonly Dictionary<string, string> _emptyMetadata = new Dictionary<string, string>();
+
+        public string ItemSpec { get; set; }
+        public IDictionary<string, string> Metadata { get; }
+
+        public TaskItemData(string itemSpec, IDictionary<string, string> metadata)
+        {
+            ItemSpec = itemSpec;
+            Metadata = metadata ?? _emptyMetadata;
+        }
+
+        IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata() => Metadata;
+
+        public int MetadataCount => Metadata.Count;
+
+        public ICollection MetadataNames => (ICollection)Metadata.Keys;
+
+        public IDictionary CloneCustomMetadata()
+        {
+            // against the guidance for CloneCustomMetadata this returns the original collection.
+            // Since this is only to be used for serialization and logging, consumers should not
+            // modify the collection. We need to minimize allocations so avoid cloning here.
+            return (IDictionary)Metadata;
+        }
+
+        public void CopyMetadataTo(ITaskItem destinationItem)
+        {
+            throw new NotImplementedException();
+        }
+
+        public string GetMetadata(string metadataName)
+        {
+            Metadata.TryGetValue(metadataName, out var result);
+            return result;
+        }
+
+        public void RemoveMetadata(string metadataName)
+        {
+            throw new NotImplementedException();
+        }
+
+        public void SetMetadata(string metadataName, string metadataValue)
+        {
+            throw new NotImplementedException();
+        }
+
+        public override string ToString()
+        {
+            return $"{ItemSpec} Metadata: {MetadataCount}";
+        }
+    }
+}
diff --git a/src/Framework/TaskParameterEventArgs.cs b/src/Framework/TaskParameterEventArgs.cs
new file mode 100644
index 00000000000..f53363237ce
--- /dev/null
+++ b/src/Framework/TaskParameterEventArgs.cs
@@ -0,0 +1,227 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Text;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework
+{
+    public enum TaskParameterMessageKind
+    {
+        TaskInput,
+        TaskOutput,
+        AddItem,
+        RemoveItem,
+    }
+
+    /// <summary>
+    /// This class is used by tasks to log their parameters (input, output).
+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also
+    /// uses this class.
+    /// </summary>
+    public class TaskParameterEventArgs : BuildMessageEventArgs
+    {
+        /// <summary>
+        /// Creates an instance of this class for the given task parameter.
+        /// </summary>
+        public TaskParameterEventArgs
+        (
+            TaskParameterMessageKind kind,
+            string itemType,
+            IList items,
+            bool logItemMetadata,
+            DateTime eventTimestamp
+        )
+            : base(null, null, null, MessageImportance.Low, eventTimestamp)
+        {
+            Kind = kind;
+            ItemType = itemType;
+            Items = items;
+            LogItemMetadata = logItemMetadata;
+        }
+
+        public TaskParameterMessageKind Kind { get; private set; }
+        public string ItemType { get; private set; }
+        public IList Items { get; private set; }
+        public bool LogItemMetadata { get; private set; }
+
+        /// <summary>
+        /// The <see cref="TaskParameterEventArgs"/> type is declared in Microsoft.Build.Framework.dll
+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build.dll
+        /// which is an implementations assembly. This seems like the easiest way to inject the
+        /// implementation for realizing the Message.
+        /// </summary>
+        /// <remarks>
+        /// Note that the current implementation never runs and is provided merely
+        /// as a safeguard in case MessageGetter isn't set for some reason.
+        /// </remarks>
+        internal static Func<TaskParameterEventArgs, string> MessageGetter = args =>
+        {
+            var sb = new StringBuilder();
+            sb.AppendLine($"{args.Kind}: {args.ItemType}");
+            foreach (var item in args.Items)
+            {
+                sb.AppendLine(item.ToString());
+            }
+
+            return sb.ToString();
+        };
+
+        /// <summary>
+        /// Provides a way for Microsoft.Build.dll to provide a more efficient dictionary factory
+        /// (using ArrayDictionary`2). Since that is an implementation detail, it is not included
+        /// in Microsoft.Build.Framework.dll so we need this extensibility point here.
+        /// </summary>
+        internal static Func<int, IDictionary<string, string>> DictionaryFactory = capacity => new Dictionary<string, string>(capacity);
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            RawTimestamp = reader.ReadTimestamp();
+            BuildEventContext = reader.ReadOptionalBuildEventContext();
+            Kind = (TaskParameterMessageKind)reader.Read7BitEncodedInt();
+            ItemType = reader.ReadString();
+            Items = ReadItems(reader);
+        }
+
+        private IList ReadItems(BinaryReader reader)
+        {
+            var list = new ArrayList();
+
+            int count = reader.Read7BitEncodedInt();
+            for (int i = 0; i < count; i++)
+            {
+                var item = ReadItem(reader);
+                list.Add(item);
+            }
+
+            return list;
+        }
+
+        private object ReadItem(BinaryReader reader)
+        {
+            string itemSpec = reader.ReadString();
+            int metadataCount = reader.Read7BitEncodedInt();
+            if (metadataCount == 0)
+            {
+                return new TaskItemData(itemSpec, metadata: null);
+            }
+
+            var metadata = DictionaryFactory(metadataCount);
+            for (int i = 0; i < metadataCount; i++)
+            {
+                string key = reader.ReadString();
+                string value = reader.ReadString();
+                if (key != null)
+                {
+                    metadata.Add(key, value);
+                }
+            }
+
+            var taskItem = new TaskItemData(itemSpec, metadata);
+            return taskItem;
+        }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            writer.WriteTimestamp(RawTimestamp);
+            writer.WriteOptionalBuildEventContext(BuildEventContext);
+            writer.Write7BitEncodedInt((int)Kind);
+            writer.Write(ItemType);
+            WriteItems(writer, Items);
+        }
+
+        private void WriteItems(BinaryWriter writer, IList items)
+        {
+            if (items == null)
+            {
+                writer.Write7BitEncodedInt(0);
+                return;
+            }
+
+            int count = items.Count;
+            writer.Write7BitEncodedInt(count);
+
+            for (int i = 0; i < count; i++)
+            {
+                var item = items[i];
+                WriteItem(writer, item);
+            }
+        }
+
+        private void WriteItem(BinaryWriter writer, object item)
+        {
+            if (item is ITaskItem taskItem)
+            {
+                writer.Write(taskItem.ItemSpec);
+                if (LogItemMetadata)
+                {
+                    WriteMetadata(writer, taskItem);
+                }
+                else
+                {
+                    writer.Write7BitEncodedInt(0);
+                }
+            }
+            else // string or ValueType
+            {
+                writer.Write(item?.ToString() ?? "");
+                writer.Write7BitEncodedInt(0);
+            }
+        }
+
+        [ThreadStatic]
+        private static List<KeyValuePair<string, string>> reusableMetadataList;
+
+        private void WriteMetadata(BinaryWriter writer, ITaskItem taskItem)
+        {
+            if (reusableMetadataList == null)
+            {
+                reusableMetadataList = new List<KeyValuePair<string, string>>();
+            }
+
+            // WARNING: Can't use AddRange here because CopyOnWriteDictionary in Microsoft.Build.Utilities.v4.0.dll
+            // is broken. Microsoft.Build.Utilities.v4.0.dll loads from the GAC by XAML markup tooling and it's
+            // implementation doesn't work with AddRange because AddRange special-cases ICollection<T> and
+            // CopyOnWriteDictionary doesn't implement it properly.
+            foreach (var kvp in taskItem.EnumerateMetadata())
+            {
+                reusableMetadataList.Add(kvp);
+            }
+
+            writer.Write7BitEncodedInt(reusableMetadataList.Count);
+            if (reusableMetadataList.Count == 0)
+            {
+                return;
+            }
+
+            foreach (var kvp in reusableMetadataList)
+            {
+                writer.Write(kvp.Key);
+                writer.Write(kvp.Value);
+            }
+
+            reusableMetadataList.Clear();
+        }
+
+        public override string Message
+        {
+            get
+            {
+                lock (this)
+                {
+                    if (base.Message == null)
+                    {
+                        base.Message = MessageGetter(this);
+                    }
+
+                    return base.Message;
+                }
+            }
+        }
+    }
+}
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index be9203b581a..d84158d112e 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -74,4 +74,10 @@
     <Service Include="{82a7f48d-3b50-4b1e-b82e-3ada8210c358}" />
   </ItemGroup>
 
+  <Target Name="CreateTaskDir" AfterTargets="Build" Condition="'$(TargetFrameworkIdentifier)' != ''">
+    <ItemGroup>
+      <OutputAssemblyList Include="$(TargetDir)Microsoft.Build.CommandLine.UnitTests.dll" />
+    </ItemGroup>
+    <Copy SourceFiles="@(OutputAssemblyList)" DestinationFolder="$(TargetDir)Task" />
+  </Target>
 </Project>
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 630890e9085..b3c65a114a6 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -2237,7 +2237,8 @@ public void EndToEndWarnAsErrors()
 
 #if FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
-        /// Ensure that tasks get loaded into their own <see cref="System.Runtime.Loader.AssemblyLoadContext"/>.
+        /// Ensure that tasks get loaded into their own <see cref="System.Runtime.Loader.AssemblyLoadContext"/>
+        /// if they are in a directory other than the MSBuild directory.
         /// </summary>
         /// <remarks>
         /// When loading a task from a test assembly in a test within that assembly, the assembly is already loaded
@@ -2247,7 +2248,10 @@ public void EndToEndWarnAsErrors()
         [Fact]
         public void TasksGetAssemblyLoadContexts()
         {
-            string customTaskPath = Assembly.GetExecutingAssembly().Location;
+            string customTaskPath = Path.Combine(
+                Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
+                "Task",
+                Path.GetFileName(Assembly.GetExecutingAssembly().Location));
 
             string projectContents = $@"<Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <UsingTask TaskName=`ValidateAssemblyLoadContext` AssemblyFile=`{customTaskPath}` />
@@ -2259,7 +2263,6 @@ public void TasksGetAssemblyLoadContexts()
 
             ExecuteMSBuildExeExpectSuccess(projectContents);
         }
-
 #endif
 
         private string CopyMSBuild()
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 02bd03d97b6..979dcaaac76 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -223,12 +223,14 @@
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
   </ItemGroup>
+  <ItemGroup>
+    <PackageReference Include="System.Configuration.ConfigurationManager" />
+  </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <!-- File for Assemblies we depend on -->
     <Reference Include="System" />
     <Reference Include="System.Core" />
     <Reference Include="System.Xml" />
-    <Reference Include="System.Configuration" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 4810afd35e9..61749a966c9 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1796,6 +1796,7 @@ elementFormDefault="qualified">
     <xs:element name="SolutionExt" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="SolutionFileName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="SolutionName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="SolutionFilterName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="SolutionPath" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="StartAction" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="StartArguments" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 6d282964d4c..1519cd4bacf 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -27,38 +27,38 @@ namespace Microsoft.Build.CommandLine
     /// </summary>
     internal class OutOfProcTaskHostNode :
 #if FEATURE_APPDOMAIN
-        MarshalByRefObject, 
+        MarshalByRefObject,
 #endif
         INodePacketFactory, INodePacketHandler,
 #if CLR2COMPATIBILITY
         IBuildEngine3
 #else
-        IBuildEngine7
+        IBuildEngine9
 #endif
     {
         /// <summary>
         /// Keeps a record of all environment variables that, on startup of the task host, have a different
-        /// value from those that are passed to the task host in the configuration packet for the first task.  
-        /// These environments are assumed to be effectively identical, so the only difference between the 
-        /// two sets of values should be any environment variables that differ between e.g. a 32-bit and a 64-bit 
-        /// process.  Those are the variables that this dictionary should store.  
-        /// 
-        /// - The key into the dictionary is the name of the environment variable. 
-        /// - The Key of the KeyValuePair is the value of the variable in the parent process -- the value that we 
-        ///   wish to ensure is replaced by whatever the correct value in our current process is. 
-        /// - The Value of the KeyValuePair is the value of the variable in the current process -- the value that 
-        ///   we wish to replay the Key value with in the environment that we receive from the parent before 
-        ///   applying it to the current process. 
-        ///   
-        /// Note that either value in the KeyValuePair can be null, as it is completely possible to have an 
-        /// environment variable that is set in 32-bit processes but not in 64-bit, or vice versa.  
-        /// 
-        /// This dictionary must be static because otherwise, if a node is sitting around waiting for reuse, it will 
-        /// have inherited the environment from the previous build, and any differences between the two will be seen 
-        /// as "legitimate".  There is no way for us to know what the differences between the startup environment of 
-        /// the previous build and the environment of the first task run in the task host in this build -- so we 
-        /// must assume that the 4ish system environment variables that this is really meant to catch haven't 
-        /// somehow magically changed between two builds spaced no more than 15 minutes apart.  
+        /// value from those that are passed to the task host in the configuration packet for the first task.
+        /// These environments are assumed to be effectively identical, so the only difference between the
+        /// two sets of values should be any environment variables that differ between e.g. a 32-bit and a 64-bit
+        /// process.  Those are the variables that this dictionary should store.
+        ///
+        /// - The key into the dictionary is the name of the environment variable.
+        /// - The Key of the KeyValuePair is the value of the variable in the parent process -- the value that we
+        ///   wish to ensure is replaced by whatever the correct value in our current process is.
+        /// - The Value of the KeyValuePair is the value of the variable in the current process -- the value that
+        ///   we wish to replay the Key value with in the environment that we receive from the parent before
+        ///   applying it to the current process.
+        ///
+        /// Note that either value in the KeyValuePair can be null, as it is completely possible to have an
+        /// environment variable that is set in 32-bit processes but not in 64-bit, or vice versa.
+        ///
+        /// This dictionary must be static because otherwise, if a node is sitting around waiting for reuse, it will
+        /// have inherited the environment from the previous build, and any differences between the two will be seen
+        /// as "legitimate".  There is no way for us to know what the differences between the startup environment of
+        /// the previous build and the environment of the first task run in the task host in this build -- so we
+        /// must assume that the 4ish system environment variables that this is really meant to catch haven't
+        /// somehow magically changed between two builds spaced no more than 15 minutes apart.
         /// </summary>
         private static IDictionary<string, KeyValuePair<string, string>> s_mismatchedEnvironmentValues;
 
@@ -108,13 +108,13 @@ internal class OutOfProcTaskHostNode :
         private bool _isTaskExecuting;
 
         /// <summary>
-        /// The event which is set when a task has completed.  
+        /// The event which is set when a task has completed.
         /// </summary>
         private AutoResetEvent _taskCompleteEvent;
 
         /// <summary>
-        /// Packet containing all the information relating to the 
-        /// completed state of the task.  
+        /// Packet containing all the information relating to the
+        /// completed state of the task.
         /// </summary>
         private TaskHostTaskComplete _taskCompletePacket;
 
@@ -145,15 +145,15 @@ internal class OutOfProcTaskHostNode :
         private bool _debugCommunications;
 
         /// <summary>
-        /// Flag indicating whether we should modify the environment based on any differences we find between that of the 
-        /// task host at startup and the environment passed to us in our initial task configuration packet.  
+        /// Flag indicating whether we should modify the environment based on any differences we find between that of the
+        /// task host at startup and the environment passed to us in our initial task configuration packet.
         /// </summary>
         private bool _updateEnvironment;
 
         /// <summary>
-        /// An interim step between MSBuildTaskHostDoNotUpdateEnvironment=1 and the default update behavior:  go ahead and 
-        /// do all the updates that we would otherwise have done by default, but log any updates that are made (at low 
-        /// importance) so that the user is aware.  
+        /// An interim step between MSBuildTaskHostDoNotUpdateEnvironment=1 and the default update behavior:  go ahead and
+        /// do all the updates that we would otherwise have done by default, but log any updates that are made (at low
+        /// importance) so that the user is aware.
         /// </summary>
         private bool _updateEnvironmentAndLog;
 
@@ -169,9 +169,9 @@ internal class OutOfProcTaskHostNode :
         /// </summary>
         public OutOfProcTaskHostNode()
         {
-            // We don't know what the current build thinks this variable should be until RunTask(), but as a fallback in case there are 
+            // We don't know what the current build thinks this variable should be until RunTask(), but as a fallback in case there are
             // communications before we get the configuration set up, just go with what was already in the environment from when this node
-            // was initially launched. 
+            // was initially launched.
             _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
 
             _receivedPackets = new Queue<INodePacket>();
@@ -194,7 +194,7 @@ public OutOfProcTaskHostNode()
         #region IBuildEngine Implementation (Properties)
 
         /// <summary>
-        /// Returns the value of ContinueOnError for the currently executing task. 
+        /// Returns the value of ContinueOnError for the currently executing task.
         /// </summary>
         public bool ContinueOnError
         {
@@ -206,7 +206,7 @@ public bool ContinueOnError
         }
 
         /// <summary>
-        /// Returns the line number of the location in the project file of the currently executing task. 
+        /// Returns the line number of the location in the project file of the currently executing task.
         /// </summary>
         public int LineNumberOfTaskNode
         {
@@ -218,7 +218,7 @@ public int LineNumberOfTaskNode
         }
 
         /// <summary>
-        /// Returns the column number of the location in the project file of the currently executing task. 
+        /// Returns the column number of the location in the project file of the currently executing task.
         /// </summary>
         public int ColumnNumberOfTaskNode
         {
@@ -230,7 +230,7 @@ public int ColumnNumberOfTaskNode
         }
 
         /// <summary>
-        /// Returns the project file of the currently executing task. 
+        /// Returns the project file of the currently executing task.
         /// </summary>
         public string ProjectFileOfTaskNode
         {
@@ -246,8 +246,8 @@ public string ProjectFileOfTaskNode
         #region IBuildEngine2 Implementation (Properties)
 
         /// <summary>
-        /// Stub implementation of IBuildEngine2.IsRunningMultipleNodes.  The task host does not support this sort of 
-        /// IBuildEngine callback, so error. 
+        /// Stub implementation of IBuildEngine2.IsRunningMultipleNodes.  The task host does not support this sort of
+        /// IBuildEngine callback, so error.
         /// </summary>
         public bool IsRunningMultipleNodes
         {
@@ -267,12 +267,34 @@ public bool IsRunningMultipleNodes
         public bool AllowFailureWithoutError { get; set; } = false;
         #endregion
 
+        #region IBuildEngine8 Implementation
+
+        /// <summary>
+        /// Contains all warnings that should be logged as errors.
+        /// Non-null empty set when all warnings should be treated as errors.
+        /// </summary>
+        private ICollection<string> WarningsAsErrors { get; set; }
+
+        private ICollection<string> WarningsAsMessages { get; set; }
+
+        public bool ShouldTreatWarningAsError(string warningCode)
+        {
+            // Warnings as messages overrides warnings as errors.
+            if (WarningsAsErrors == null || WarningsAsMessages?.Contains(warningCode) == true)
+            {
+                return false;
+            }
+
+            return WarningsAsErrors.Count == 0 || WarningsAsErrors.Contains(warningCode);
+        }
+        #endregion
+
         #region IBuildEngine Implementation (Methods)
 
         /// <summary>
-        /// Sends the provided error back to the parent node to be logged, tagging it with 
-        /// the parent node's ID so that, as far as anyone is concerned, it might as well have 
-        /// just come from the parent node to begin with. 
+        /// Sends the provided error back to the parent node to be logged, tagging it with
+        /// the parent node's ID so that, as far as anyone is concerned, it might as well have
+        /// just come from the parent node to begin with.
         /// </summary>
         public void LogErrorEvent(BuildErrorEventArgs e)
         {
@@ -280,9 +302,9 @@ public void LogErrorEvent(BuildErrorEventArgs e)
         }
 
         /// <summary>
-        /// Sends the provided warning back to the parent node to be logged, tagging it with 
-        /// the parent node's ID so that, as far as anyone is concerned, it might as well have 
-        /// just come from the parent node to begin with. 
+        /// Sends the provided warning back to the parent node to be logged, tagging it with
+        /// the parent node's ID so that, as far as anyone is concerned, it might as well have
+        /// just come from the parent node to begin with.
         /// </summary>
         public void LogWarningEvent(BuildWarningEventArgs e)
         {
@@ -290,9 +312,9 @@ public void LogWarningEvent(BuildWarningEventArgs e)
         }
 
         /// <summary>
-        /// Sends the provided message back to the parent node to be logged, tagging it with 
-        /// the parent node's ID so that, as far as anyone is concerned, it might as well have 
-        /// just come from the parent node to begin with. 
+        /// Sends the provided message back to the parent node to be logged, tagging it with
+        /// the parent node's ID so that, as far as anyone is concerned, it might as well have
+        /// just come from the parent node to begin with.
         /// </summary>
         public void LogMessageEvent(BuildMessageEventArgs e)
         {
@@ -300,9 +322,9 @@ public void LogMessageEvent(BuildMessageEventArgs e)
         }
 
         /// <summary>
-        /// Sends the provided custom event back to the parent node to be logged, tagging it with 
-        /// the parent node's ID so that, as far as anyone is concerned, it might as well have 
-        /// just come from the parent node to begin with. 
+        /// Sends the provided custom event back to the parent node to be logged, tagging it with
+        /// the parent node's ID so that, as far as anyone is concerned, it might as well have
+        /// just come from the parent node to begin with.
         /// </summary>
         public void LogCustomEvent(CustomBuildEventArgs e)
         {
@@ -310,8 +332,8 @@ public void LogCustomEvent(CustomBuildEventArgs e)
         }
 
         /// <summary>
-        /// Stub implementation of IBuildEngine.BuildProjectFile.  The task host does not support IBuildEngine 
-        /// callbacks for the purposes of building projects, so error.  
+        /// Stub implementation of IBuildEngine.BuildProjectFile.  The task host does not support IBuildEngine
+        /// callbacks for the purposes of building projects, so error.
         /// </summary>
         public bool BuildProjectFile(string projectFileName, string[] targetNames, IDictionary globalProperties, IDictionary targetOutputs)
         {
@@ -324,8 +346,8 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, IDict
         #region IBuildEngine2 Implementation (Methods)
 
         /// <summary>
-        /// Stub implementation of IBuildEngine2.BuildProjectFile.  The task host does not support IBuildEngine 
-        /// callbacks for the purposes of building projects, so error.  
+        /// Stub implementation of IBuildEngine2.BuildProjectFile.  The task host does not support IBuildEngine
+        /// callbacks for the purposes of building projects, so error.
         /// </summary>
         public bool BuildProjectFile(string projectFileName, string[] targetNames, IDictionary globalProperties, IDictionary targetOutputs, string toolsVersion)
         {
@@ -334,8 +356,8 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, IDict
         }
 
         /// <summary>
-        /// Stub implementation of IBuildEngine2.BuildProjectFilesInParallel.  The task host does not support IBuildEngine 
-        /// callbacks for the purposes of building projects, so error.  
+        /// Stub implementation of IBuildEngine2.BuildProjectFilesInParallel.  The task host does not support IBuildEngine
+        /// callbacks for the purposes of building projects, so error.
         /// </summary>
         public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion)
         {
@@ -348,8 +370,8 @@ public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targ
         #region IBuildEngine3 Implementation
 
         /// <summary>
-        /// Stub implementation of IBuildEngine3.BuildProjectFilesInParallel.  The task host does not support IBuildEngine 
-        /// callbacks for the purposes of building projects, so error.  
+        /// Stub implementation of IBuildEngine3.BuildProjectFilesInParallel.  The task host does not support IBuildEngine
+        /// callbacks for the purposes of building projects, so error.
         /// </summary>
         public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<string>[] removeGlobalProperties, string[] toolsVersion, bool returnTargetOutputs)
         {
@@ -359,7 +381,7 @@ public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames,
 
         /// <summary>
         /// Stub implementation of IBuildEngine3.Yield.  The task host does not support yielding, so just go ahead and silently
-        /// return, letting the task continue. 
+        /// return, letting the task continue.
         /// </summary>
         public void Yield()
         {
@@ -367,8 +389,8 @@ public void Yield()
         }
 
         /// <summary>
-        /// Stub implementation of IBuildEngine3.Reacquire. The task host does not support yielding, so just go ahead and silently 
-        /// return, letting the task continue. 
+        /// Stub implementation of IBuildEngine3.Reacquire. The task host does not support yielding, so just go ahead and silently
+        /// return, letting the task continue.
         /// </summary>
         public void Reacquire()
         {
@@ -454,6 +476,22 @@ public IReadOnlyDictionary<string, string> GetGlobalProperties()
         }
 
         #endregion
+
+        #region IBuildEngine9 Implementation
+
+        public int RequestCores(int requestedCores)
+        {
+            // No resource management in OOP nodes
+            throw new NotImplementedException();
+        }
+
+        public void ReleaseCores(int coresToRelease)
+        {
+            // No resource management in OOP nodes
+            throw new NotImplementedException();
+        }
+
+        #endregion
 #endif
 
         #region INodePacketFactory Members
@@ -613,7 +651,7 @@ private void HandlePacket(INodePacket packet)
         }
 
         /// <summary>
-        /// Configure the task host according to the information received in the 
+        /// Configure the task host according to the information received in the
         /// configuration packet
         /// </summary>
         private void HandleTaskHostConfiguration(TaskHostConfiguration taskHostConfiguration)
@@ -649,10 +687,10 @@ private void CompleteTask()
 
             _currentConfiguration = null;
 
-            // If the task has been canceled, the event will still be set.  
-            // If so, now that we've completed the task, we want to shut down 
-            // this node -- with no reuse, since we don't know whether the 
-            // task we canceled left the node in a good state or not. 
+            // If the task has been canceled, the event will still be set.
+            // If so, now that we've completed the task, we want to shut down
+            // this node -- with no reuse, since we don't know whether the
+            // task we canceled left the node in a good state or not.
             if (_taskCancelledEvent.WaitOne(0))
             {
                 _shutdownReason = NodeEngineShutdownReason.BuildComplete;
@@ -680,7 +718,7 @@ private void CancelTask()
                     if (_isTaskExecuting)
                     {
 #if FEATURE_THREAD_ABORT
-                        // The thread will be terminated crudely so our environment may be trashed but it's ok since we are 
+                        // The thread will be terminated crudely so our environment may be trashed but it's ok since we are
                         // shutting down ASAP.
                         _taskRunnerThread.Abort();
 #endif
@@ -787,13 +825,14 @@ private void RunTask(object state)
             TaskHostConfiguration taskConfiguration = state as TaskHostConfiguration;
             IDictionary<string, TaskParameter> taskParams = taskConfiguration.TaskParameters;
 
-            // We only really know the values of these variables for sure once we see what we received from our parent 
-            // environment -- otherwise if this was a completely new build, we could lose out on expected environment 
-            // variables.  
+            // We only really know the values of these variables for sure once we see what we received from our parent
+            // environment -- otherwise if this was a completely new build, we could lose out on expected environment
+            // variables.
             _debugCommunications = taskConfiguration.BuildProcessEnvironment.ContainsValueAndIsEqual("MSBUILDDEBUGCOMM", "1", StringComparison.OrdinalIgnoreCase);
             _updateEnvironment = !taskConfiguration.BuildProcessEnvironment.ContainsValueAndIsEqual("MSBuildTaskHostDoNotUpdateEnvironment", "1", StringComparison.OrdinalIgnoreCase);
             _updateEnvironmentAndLog = taskConfiguration.BuildProcessEnvironment.ContainsValueAndIsEqual("MSBuildTaskHostUpdateEnvironmentAndLog", "1", StringComparison.OrdinalIgnoreCase);
-
+            WarningsAsErrors = taskConfiguration.WarningsAsErrors;
+            WarningsAsMessages = taskConfiguration.WarningsAsMessages;
             try
             {
                 // Change to the startup directory
@@ -904,9 +943,9 @@ private void RunTask(object state)
         }
 
         /// <summary>
-        /// Set the environment for the task host -- includes possibly munging the given 
-        /// environment somewhat to account for expected environment differences between, 
-        /// e.g. parent processes and task hosts of different bitnesses. 
+        /// Set the environment for the task host -- includes possibly munging the given
+        /// environment somewhat to account for expected environment differences between,
+        /// e.g. parent processes and task hosts of different bitnesses.
         /// </summary>
         private void SetTaskHostEnvironment(IDictionary<string, string> environment)
         {
@@ -920,7 +959,7 @@ private void SetTaskHostEnvironment(IDictionary<string, string> environment)
                     string oldValue = s_mismatchedEnvironmentValues[variable].Key;
                     string newValue = s_mismatchedEnvironmentValues[variable].Value;
 
-                    // We don't check the return value, because having the variable not exist == be 
+                    // We don't check the return value, because having the variable not exist == be
                     // null is perfectly valid, and mismatchedEnvironmentValues stores those values
                     // as null as well, so the String.Equals should still return that they are equal.
                     string environmentValue = null;
@@ -955,8 +994,8 @@ private void SetTaskHostEnvironment(IDictionary<string, string> environment)
                 }
             }
 
-            // if it's still null here, there were no changes necessary -- so just 
-            // set it to what was already passed in. 
+            // if it's still null here, there were no changes necessary -- so just
+            // set it to what was already passed in.
             if (updatedEnvironment == null)
             {
                 updatedEnvironment = environment;
@@ -966,10 +1005,10 @@ private void SetTaskHostEnvironment(IDictionary<string, string> environment)
         }
 
         /// <summary>
-        /// Given the environment of the task host at the end of task execution, make sure that any 
-        /// processor-specific variables have been re-applied in the correct form for the main node, 
-        /// so that when we pass this dictionary back to the main node, all it should have to do 
-        /// is just set it.  
+        /// Given the environment of the task host at the end of task execution, make sure that any
+        /// processor-specific variables have been re-applied in the correct form for the main node,
+        /// so that when we pass this dictionary back to the main node, all it should have to do
+        /// is just set it.
         /// </summary>
         private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<string, string> environment)
         {
@@ -980,14 +1019,14 @@ private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<str
             {
                 foreach (string variable in s_mismatchedEnvironmentValues.Keys)
                 {
-                    // Since this is munging the property list for returning to the parent process, 
-                    // then the value we wish to replace is the one that is in this process, and the 
-                    // replacement value is the one that originally came from the parent process, 
+                    // Since this is munging the property list for returning to the parent process,
+                    // then the value we wish to replace is the one that is in this process, and the
+                    // replacement value is the one that originally came from the parent process,
                     // instead of the other way around.
                     string oldValue = s_mismatchedEnvironmentValues[variable].Value;
                     string newValue = s_mismatchedEnvironmentValues[variable].Key;
 
-                    // We don't check the return value, because having the variable not exist == be 
+                    // We don't check the return value, because having the variable not exist == be
                     // null is perfectly valid, and mismatchedEnvironmentValues stores those values
                     // as null as well, so the String.Equals should still return that they are equal.
                     string environmentValue = null;
@@ -1012,8 +1051,8 @@ private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<str
                 }
             }
 
-            // if it's still null here, there were no changes necessary -- so just 
-            // set it to what was already passed in. 
+            // if it's still null here, there were no changes necessary -- so just
+            // set it to what was already passed in.
             if (updatedEnvironment == null)
             {
                 updatedEnvironment = environment;
@@ -1023,20 +1062,20 @@ private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<str
         }
 
         /// <summary>
-        /// Make sure the mismatchedEnvironmentValues table has been populated.  Note that this should 
-        /// only do actual work on the very first run of a task in the task host -- otherwise, it should 
-        /// already have been populated. 
+        /// Make sure the mismatchedEnvironmentValues table has been populated.  Note that this should
+        /// only do actual work on the very first run of a task in the task host -- otherwise, it should
+        /// already have been populated.
         /// </summary>
         private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> environment)
         {
             if (s_mismatchedEnvironmentValues == null)
             {
-                // This is the first time that we have received a TaskHostConfiguration packet, so we 
-                // need to construct the mismatched environment table based on our current environment 
+                // This is the first time that we have received a TaskHostConfiguration packet, so we
+                // need to construct the mismatched environment table based on our current environment
                 // (assumed to be effectively identical to startup) and the environment we were given
-                // via the task host configuration, assumed to be effectively identical to the startup 
+                // via the task host configuration, assumed to be effectively identical to the startup
                 // environment of the task host, given that the configuration packet is sent immediately
-                // after the node is launched.  
+                // after the node is launched.
                 s_mismatchedEnvironmentValues = new Dictionary<string, KeyValuePair<string, string>>(StringComparer.OrdinalIgnoreCase);
 
                 foreach (string variable in _savedEnvironment.Keys)
@@ -1076,7 +1115,7 @@ private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> en
         }
 
         /// <summary>
-        /// Sends the requested packet across to the main node. 
+        /// Sends the requested packet across to the main node.
         /// </summary>
         private void SendBuildEvent(BuildEventArgs e)
         {
@@ -1085,7 +1124,7 @@ private void SendBuildEvent(BuildEventArgs e)
                 if (!e.GetType().GetTypeInfo().IsSerializable)
                 {
                     // log a warning and bail.  This will end up re-calling SendBuildEvent, but we know for a fact
-                    // that the warning that we constructed is serializable, so everything should be good.  
+                    // that the warning that we constructed is serializable, so everything should be good.
                     LogWarningFromResource("ExpectedEventToBeSerializable", e.GetType().Name);
                     return;
                 }
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 7424e0ce3ec..9a26fa629ff 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -135,8 +135,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </comment>
   </data>
   <data name="HelpMessage_3_SwitchesHeader" UESanitized="true" Visibility="Public">
-    <value>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+    <value>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </value>
     <comment>
       LOCALIZATION: The following should not be localized:
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index fc744560c0b..b92d92f3031 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">Přepínače:            Přepínače můžete zadat ve tvaru
-                     -switch i /switch.
+        <target state="translated">Přepínače:            Přepínače můžete zadat pomocí
+                     -switch, /switch a --switch.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -964,7 +964,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: Hodnota sestavení grafu není platná.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index e632c30541a..281e2e799a1 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">Schalter:            Beachten Sie, dass Sie Schalter über
-                     "-schalter" und "/schalter" angeben können.
+        <target state="translated">Optionen:            Beachten Sie, dass Sie Optionen über
+                     "-option", "/option" und "--option" angeben können.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -956,7 +956,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: Der Wert für die Diagrammerstellung ist nicht gültig.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.en.xlf b/src/MSBuild/Resources/xlf/Strings.en.xlf
index 6c8a5e10bab..f21b062f02c 100644
--- a/src/MSBuild/Resources/xlf/Strings.en.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.en.xlf
@@ -245,11 +245,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="new">Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <target state="new">Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index f52c256392e..c56841a9857 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
         <target state="translated">Modificadores:            Observe que puede especificar modificadores mediante
-                     "-switch" y "/switch".
+                     "-switch", "/switch" y "--switch".
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -965,7 +965,7 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: El valor de compilación del grafo no es válido.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 2cb64ba773b..ad3e37869c8 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">Commutateurs :            Notez que vous pouvez spécifier des commutateurs avec
-                     "-switch" et "/switch".
+        <target state="translated">Commutateurs :            Vous pouvez spécifier des commutateurs avec
+                     "-switch", "/switch" et "--switch".
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -957,7 +957,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: la valeur de build du graphe n'est pas valide.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index f4aebb20fcc..530b464e372 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -242,11 +242,11 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
         <target state="translated">Opzioni:            Tenere presente che è possibile specificare le opzioni
-                     usando "-switch" e "/switch".
+                     usando "-switch", "/switch" e "--switch".
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -977,7 +977,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: il valore di graphBuild non è valido.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index d338ebd227f..a220b09beaa 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation.All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">スイッチ:            スイッチは "-switch" と "/switch" のどちらを使用して
-                     指定しても構いません。
+        <target state="translated">スイッチ:            スイッチは "-switch"、"/switch"、"--switch" を使用して
+                     指定できます。
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -956,7 +956,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: Graph build 値が無効です。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 9ac6a44c140..e0202935812 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">스위치:            스위치를 지정하는 데 "-switch" 및 "/switch"를
-                     둘 다 사용할 수 있습니다.
+        <target state="translated">스위치:            스위치를 지정하는 데 "-switch", "/switch" 및 "--switch"를
+                     사용할 수 있습니다.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -956,7 +956,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: 그래프 빌드 값이 잘못되었습니다.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index da02c524d3e..501d771f516 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -242,11 +242,11 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
         <target state="translated">Przełączniki:            Należy pamiętać, że przełączniki można określać
-                     zarówno za pomocą składni „-przełącznik”, jak i „/przełącznik”.
+                     za pomocą składni „-przełącznik”, „/przełącznik” i „--przełącznik”.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -969,7 +969,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: Wartość kompilacji grafu jest nieprawidłowa.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 6a271fdf56f..ecc0ffb067b 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -236,11 +236,11 @@ isoladamente.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">Switches:            Você pode especificar as opções usando
-                     "-switch" e "/switch".
+        <target state="translated">Opções:            Observe que você pode especificar as opções usando
+                     "-switch", "/switch" e "--switch".
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -957,7 +957,7 @@ isoladamente.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: o valor de build do grafo não é válido.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 082814fdec8..b6ac9e09ed4 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -234,11 +234,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">Параметры:            Вы можете указывать параметры с помощью
-                     "-switch" и "/switch".
+        <target state="translated">Параметры:            Вы можете указывать параметры с использованием синтаксиса
+                     "-switch", "/switch" и "--switch".
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -956,7 +956,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: значение сборки графа является недопустимым.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index f345f7b61f8..aa54753ad7d 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -235,11 +235,11 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">Anahtarlar:            Hem "-switch" hem de "/switch" değerini kullanarak
-                     anahtar beliretebileceğinizi unutmayın.
+        <target state="translated">Anahtarlar:            Hem "-switch" hem de "/switch" ve "--switch" değerini kullanarak
+                     anahtar belirtebileceğinizi unutmayın.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -960,7 +960,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: Grafik derleme değeri geçerli değil.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index ec084a96edf..f6401f48307 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -235,8 +235,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
         <target state="translated">开关:            请注意，使用 "-switch" 和 "/switch" 均可
                      指定开关。
@@ -956,7 +956,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: 关系图生成值无效。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index fd9cf7122ac..f949d0a1ca1 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">參數:            請注意，您可以同時使用 "-switch" 和 "/switch"
-                     來指定參數。
+        <target state="translated">參數:            請注意，您可以同時使用 "-switch"、"/switch"，
+以及 "--switch"                     來指定參數。
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -956,7 +956,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: 圖形組建值無效。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 76a9c687ab6..5297f5234cf 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -4,9 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
-#if FEATURE_SYSTEM_CONFIGURATION
 using System.Configuration;
-#endif
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 25e4bab8f7b..20f19d883d2 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -5,7 +5,7 @@
   <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(MonoBuild)' == 'true'" />
 
   <PropertyGroup>
-    <TargetFramework>net35</TargetFramework>    
+    <TargetFramework>net35</TargetFramework>
     <OutputType>Exe</OutputType>
     <PlatformTarget Condition="'$(Platform)' == 'x64'">x64</PlatformTarget>
     <PlatformTarget Condition="'$(Platform)' == 'AnyCPU'">x86</PlatformTarget>
@@ -14,12 +14,12 @@
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
          versions of this project -->
     <RuntimeIdentifiers>win7-x86;win7-x64</RuntimeIdentifiers>
-    
+
     <EnableDefaultItems>false</EnableDefaultItems>
-    <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY</DefineConstants>
+    <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY;TASKHOST</DefineConstants>
     <!-- Need pointers for getting environment block -->
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
-    <!-- It is vital that msbuildtaskhost.exe is allowed to use the full 4GB on 64 bit machines in order to help avoid 
+    <!-- It is vital that msbuildtaskhost.exe is allowed to use the full 4GB on 64 bit machines in order to help avoid
          out of memory problems on large trees -->
     <LargeAddressAware>true</LargeAddressAware>
     <ApplicationIcon>..\MSBuild\MSBuild.ico</ApplicationIcon>
@@ -212,7 +212,7 @@
     <PackageReference Include="PdbGit" /> -->
     <PackageReference Include="SourceLink.Create.CommandLine" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
-    <PackageReference Include="jnm2.ReferenceAssemblies.net35" />
+    <PackageReference Include="jnm2.ReferenceAssemblies.net35" PrivateAssets="All" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 1d4f2a4bf71..8c62a178e05 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -9,6 +9,7 @@
 using System.Configuration.Assemblies;
 using System.Runtime.Serialization;
 using System.IO;
+using Microsoft.Build.BackEnd;
 #if FEATURE_ASSEMBLYLOADCONTEXT
 using System.Reflection.PortableExecutable;
 using System.Reflection.Metadata;
@@ -54,7 +55,7 @@ internal enum PartialComparisonFlags : int
     /// between the two is done lazily on demand.
     /// </summary>
     [Serializable]
-    internal sealed class AssemblyNameExtension : ISerializable, IEquatable<AssemblyNameExtension>
+    internal sealed class AssemblyNameExtension : ISerializable, IEquatable<AssemblyNameExtension>, ITranslatable
     {
         private AssemblyName asAssemblyName = null;
         private string asString = null;
@@ -173,6 +174,14 @@ private AssemblyNameExtension(SerializationInfo info, StreamingContext context)
             remappedFrom = (HashSet<AssemblyNameExtension>) info.GetValue("remapped", typeof(HashSet<AssemblyNameExtension>));
         }
 
+        /// <summary>
+        /// Ctor for deserializing from state file (custom binary serialization) using translator.
+        /// </summary>
+        internal AssemblyNameExtension(ITranslator translator) : this()
+        {
+            Translate(translator);
+        }
+
         /// <summary>
         /// To be used as a delegate. Gets the AssemblyName of the given file.
         /// </summary>
@@ -251,10 +260,18 @@ private void InitializeRemappedFrom()
         {
             if (remappedFrom == null)
             {
-                remappedFrom = new HashSet<AssemblyNameExtension>(AssemblyNameComparer.GenericComparerConsiderRetargetable);
+                remappedFrom = CreateRemappedFrom();
             }
         }
 
+        /// <summary>
+        /// Create remappedFrom HashSet. Used by deserialization as well.
+        /// </summary>
+        private static HashSet<AssemblyNameExtension> CreateRemappedFrom()
+        {
+            return new HashSet<AssemblyNameExtension>(AssemblyNameComparer.GenericComparerConsiderRetargetable);
+        }
+
         /// <summary>
         /// Assume there is a string version, create the AssemblyName version.
         /// </summary>
@@ -993,5 +1010,23 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)
             info.AddValue("immutable", immutable);
             info.AddValue("remapped", remappedFrom);
         }
+
+        /// <summary>
+        /// Reads/writes this class
+        /// </summary>
+        /// <param name="translator"></param>
+        public void Translate(ITranslator translator)
+        {
+            translator.Translate(ref asAssemblyName);
+            translator.Translate(ref asString);
+            translator.Translate(ref isSimpleName);
+            translator.Translate(ref hasProcessorArchitectureInFusionName);
+            translator.Translate(ref immutable);
+            
+            // TODO: consider some kind of protection against infinite loop during serialization, hint: pre serialize check for cycle in graph
+            translator.TranslateHashSet(ref remappedFrom,
+                (ITranslator t) => new AssemblyNameExtension(t),
+                (int capacity) => CreateRemappedFrom());
+        }
     }
 }
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
new file mode 100644
index 00000000000..f1a1c16c587
--- /dev/null
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -0,0 +1,79 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.IO;
+using System.Runtime.CompilerServices;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Shared
+{
+    internal static class BinaryReaderExtensions
+    {
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static string ReadOptionalString(this BinaryReader reader)
+        {
+            return reader.ReadByte() == 0 ? null : reader.ReadString();
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static int Read7BitEncodedInt(this BinaryReader reader)
+        {
+            // Read out an Int32 7 bits at a time.  The high bit
+            // of the byte when on means to continue reading more bytes.
+            int count = 0;
+            int shift = 0;
+            byte b;
+            do
+            {
+                // Check for a corrupted stream.  Read a max of 5 bytes.
+                // In a future version, add a DataFormatException.
+                if (shift == 5 * 7)  // 5 bytes max per Int32, shift += 7
+                {
+                    throw new FormatException();
+                }
+
+                // ReadByte handles end of stream cases for us.
+                b = reader.ReadByte();
+                count |= (b & 0x7F) << shift;
+                shift += 7;
+            } while ((b & 0x80) != 0);
+            return count;
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static DateTime ReadTimestamp(this BinaryReader reader)
+        {
+            long timestampTicks = reader.ReadInt64();
+            DateTimeKind kind = (DateTimeKind)reader.ReadInt32();
+            var timestamp = new DateTime(timestampTicks, kind);
+            return timestamp;
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static BuildEventContext ReadOptionalBuildEventContext(this BinaryReader reader)
+        {
+            if (reader.ReadByte() == 0)
+            {
+                return null;
+            }
+
+            return reader.ReadBuildEventContext();
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static BuildEventContext ReadBuildEventContext(this BinaryReader reader)
+        {
+            int nodeId = reader.ReadInt32();
+            int projectContextId = reader.ReadInt32();
+            int targetId = reader.ReadInt32();
+            int taskId = reader.ReadInt32();
+            int submissionId = reader.ReadInt32();
+            int projectInstanceId = reader.ReadInt32();
+            int evaluationId = reader.ReadInt32();
+
+            var buildEventContext = new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, targetId, taskId);
+            return buildEventContext;
+        }
+    }
+}
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index 1a6c9e3c39c..6c2b6337393 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -293,6 +293,32 @@ public void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTransla
                 }
             }
 
+            /// <summary>
+            /// Translates a collection of T into the specified type using an <see cref="ObjectTranslator{T}"/> and <see cref="NodePacketCollectionCreator{L}"/>
+            /// </summary>
+            /// <param name="collection">The collection to be translated.</param>
+            /// <param name="objectTranslator">The translator to use for the values in the collection.</param>
+            /// <param name="collectionFactory">The factory to create the ICollection.</param>
+            /// <typeparam name="T">The type contained in the collection.</typeparam>
+            /// <typeparam name="L">The type of collection to be created.</typeparam>
+            public void Translate<T, L>(ref ICollection<T> collection, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : ICollection<T>
+            {
+                if (!TranslateNullable(collection))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                collection = collectionFactory(count);
+
+                for (int i = 0; i < count; i++)
+                {
+                    T value = default(T);
+                    objectTranslator(this, ref value);
+                    collection.Add(value);
+                }
+            }
+
             /// <summary>
             /// Translates a DateTime.
             /// </summary>
@@ -883,6 +909,30 @@ public void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTransla
                 }
             }
 
+            /// <summary>
+            /// Translates a collection of T into the specified type using an <see cref="ObjectTranslator{T}"/> and <see cref="NodePacketCollectionCreator{L}"/>
+            /// </summary>
+            /// <param name="collection">The collection to be translated.</param>
+            /// <param name="objectTranslator">The translator to use for the values in the collection.</param>
+            /// <param name="collectionFactory">The factory to create the ICollection.</param>
+            /// <typeparam name="T">The type contained in the collection.</typeparam>
+            /// <typeparam name="L">The type of collection to be created.</typeparam>
+            public void Translate<T, L>(ref ICollection<T> collection, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : ICollection<T>
+            {
+                if (!TranslateNullable(collection))
+                {
+                    return;
+                }
+
+                _writer.Write(collection.Count);
+
+                foreach (T item in collection)
+                {
+                    T value = item;
+                    objectTranslator(this, ref value);
+                }
+            }
+
             /// <summary>
             /// Translates a DateTime.
             /// </summary>
diff --git a/src/Shared/BinaryWriterExtensions.cs b/src/Shared/BinaryWriterExtensions.cs
index f4f5b00d73b..946eb483eaa 100644
--- a/src/Shared/BinaryWriterExtensions.cs
+++ b/src/Shared/BinaryWriterExtensions.cs
@@ -1,6 +1,10 @@
-﻿using System;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
 using System.IO;
 using System.Runtime.CompilerServices;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Shared
 {
@@ -23,8 +27,49 @@ public static void WriteOptionalString(this BinaryWriter writer, string value)
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
         public static void WriteTimestamp(this BinaryWriter writer, DateTime timestamp)
         {
-            writer.Write((Int64)timestamp.Ticks);
+            writer.Write(timestamp.Ticks);
             writer.Write((Int32)timestamp.Kind);
         }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static void Write7BitEncodedInt(this BinaryWriter writer, int value)
+        {
+            // Write out an int 7 bits at a time.  The high bit of the byte,
+            // when on, tells reader to continue reading more bytes.
+            uint v = (uint)value;   // support negative numbers
+            while (v >= 0x80)
+            {
+                writer.Write((byte)(v | 0x80));
+                v >>= 7;
+            }
+
+            writer.Write((byte)v);
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static void WriteOptionalBuildEventContext(this BinaryWriter writer, BuildEventContext context)
+        {
+            if (context == null)
+            {
+                writer.Write((byte)0);
+            }
+            else
+            {
+                writer.Write((byte)1);
+                writer.WriteBuildEventContext(context);
+            }
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static void WriteBuildEventContext(this BinaryWriter writer, BuildEventContext context)
+        {
+            writer.Write(context.NodeId);
+            writer.Write(context.ProjectContextId);
+            writer.Write(context.TargetId);
+            writer.Write(context.TaskId);
+            writer.Write(context.SubmissionId);
+            writer.Write(context.ProjectInstanceId);
+            writer.Write(context.EvaluationId);
+        }
     }
 }
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index fc29d17c46c..5c7b5ae9d61 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -488,11 +488,11 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                 }
                 else
                 {
-                    ErrorUtilities.VerifyThrow(taskHostParameters.ContainsKey(XMakeAttributes.runtime), "Should always have an explicit runtime when we call this method.");
-                    ErrorUtilities.VerifyThrow(taskHostParameters.ContainsKey(XMakeAttributes.architecture), "Should always have an explicit architecture when we call this method.");
+                    ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.runtime, out string runtimeVersion), "Should always have an explicit runtime when we call this method.");
+                    ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.architecture, out string architecture), "Should always have an explicit architecture when we call this method.");
 
-                    clrVersion = taskHostParameters[XMakeAttributes.runtime].Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;
-                    is64Bit = taskHostParameters[XMakeAttributes.architecture].Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
+                    clrVersion = runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;
+                    is64Bit = architecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
                 }
             }
 
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 14cd04a244d..385c5c878e8 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -23,8 +23,15 @@ internal sealed class CoreClrAssemblyLoader
 
         private bool _resolvingHandlerHookedUp = false;
 
+        private static readonly string _msbuildDirPath;
         private static readonly Version _currentAssemblyVersion = new Version(Microsoft.Build.Shared.MSBuildConstants.CurrentAssemblyVersion);
 
+        static CoreClrAssemblyLoader()
+        {
+            _msbuildDirPath = FileUtilities.NormalizePath(typeof(CoreClrAssemblyLoader).Assembly.Location);
+            _msbuildDirPath = Path.GetDirectoryName(_msbuildDirPath);
+        }
+
         public void AddDependencyLocation(string fullPath)
         {
             if (fullPath == null)
@@ -52,7 +59,12 @@ public Assembly LoadFromPath(string fullPath)
             // folders in a NuGet package).
             fullPath = FileUtilities.NormalizePath(fullPath);
 
-            if (Traits.Instance.EscapeHatches.UseSingleLoadContext)
+            // If the requested load comes from the same directory as MSBuild, assume that
+            // the load is part of the platform, and load it using the Default ALC.
+            string assemblyDir = Path.GetDirectoryName(fullPath);
+
+            if (Traits.Instance.EscapeHatches.UseSingleLoadContext ||
+                FileUtilities.ComparePathsNoThrow(assemblyDir, _msbuildDirPath, string.Empty))
             {
                 return LoadUsingLegacyDefaultContext(fullPath);
             }
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index be59150401f..2731c90b61a 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -850,6 +850,20 @@ internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array
         }
 
         #endregion
+
+        #region VerifyThrowObjectDisposed
+
+        internal static void VerifyThrowObjectDisposed(bool condition, string objectName)
+        {
+            {
+                if (s_throwExceptions && !condition)
+                {
+                    throw new ObjectDisposedException(objectName);
+                }
+            }
+        }
+
+        #endregion
 #endif
     }
 }
diff --git a/src/Shared/EscapingUtilities.cs b/src/Shared/EscapingUtilities.cs
index 2f0082459b3..309e39a2988 100644
--- a/src/Shared/EscapingUtilities.cs
+++ b/src/Shared/EscapingUtilities.cs
@@ -26,11 +26,25 @@ static internal class EscapingUtilities
         /// </summary>
         private static Dictionary<string, string> s_unescapedToEscapedStrings = new Dictionary<string, string>(StringComparer.Ordinal);
 
-        private static bool IsHexDigit(char character)
+        private static bool TryDecodeHexDigit(char character, out int value)
         {
-            return ((character >= '0') && (character <= '9'))
-                || ((character >= 'A') && (character <= 'F'))
-                || ((character >= 'a') && (character <= 'f'));
+            if (character >= '0' && character <= '9')
+            {
+                value = character - '0';
+                return true;
+            }
+            if (character >= 'A' && character <= 'F')
+            {
+                value = character - 'A' + 10;
+                return true;
+            }
+            if (character >= 'a' && character <= 'f')
+            {
+                value = character - 'a' + 10;
+                return true;
+            }
+            value = default;
+            return false;
         }
 
         /// <summary>
@@ -85,8 +99,8 @@ internal static string UnescapeAll(string escapedString, bool trim = false)
                 // for us to even consider doing anything with this.
                 if (
                         (indexOfPercent <= (escapedStringLength - 3)) &&
-                        IsHexDigit(escapedString[indexOfPercent + 1]) &&
-                        IsHexDigit(escapedString[indexOfPercent + 2])
+                        TryDecodeHexDigit(escapedString[indexOfPercent + 1], out int digit1) &&
+                        TryDecodeHexDigit(escapedString[indexOfPercent + 2], out int digit2)
                     )
                 {
                     // First copy all the characters up to the current percent sign into
@@ -94,9 +108,7 @@ internal static string UnescapeAll(string escapedString, bool trim = false)
                     unescapedString.Append(escapedString, currentPosition, indexOfPercent - currentPosition);
 
                     // Convert the %XX to an actual real character.
-                    string hexString = escapedString.Substring(indexOfPercent + 1, 2);
-                    char unescapedCharacter = (char)int.Parse(hexString, System.Globalization.NumberStyles.HexNumber,
-                        CultureInfo.InvariantCulture);
+                    char unescapedCharacter = (char)((digit1 << 4) + digit2);
 
                     // if the unescaped character is not on the exception list, append it
                     unescapedString.Append(unescapedCharacter);
@@ -214,28 +226,30 @@ string unescapedString
         /// </summary>
         /// <param name="escapedString"></param>
         /// <returns></returns>
-        internal static bool ContainsEscapedWildcards
-            (
-            string escapedString
-            )
+        internal static bool ContainsEscapedWildcards(string escapedString)
         {
-            if (-1 != escapedString.IndexOf('%'))
+            if (escapedString.Length < 3)
             {
-                // It has a '%' sign.  We have promise.
-                if (
-                        (-1 != escapedString.IndexOf("%2", StringComparison.Ordinal)) ||
-                        (-1 != escapedString.IndexOf("%3", StringComparison.Ordinal))
-                    )
+                return false;
+            }
+            // Look for the first %. We know that it has to be followed by at least two more characters so we subtract 2
+            // from the length to search.
+            int index = escapedString.IndexOf('%', 0, escapedString.Length - 2);
+            while (index != -1)
+            {
+                if (escapedString[index + 1] == '2' && (escapedString[index + 2] == 'a' || escapedString[index + 2] == 'A'))
+                {
+                    // %2a or %2A
+                    return true;
+                }
+                if (escapedString[index + 1] == '3' && (escapedString[index + 2] == 'f' || escapedString[index + 2] == 'F'))
                 {
-                    // It has either a '%2' or a '%3'.  This is looking very promising.
-                    return
-
-                            (-1 != escapedString.IndexOf("%2a", StringComparison.Ordinal)) ||
-                            (-1 != escapedString.IndexOf("%2A", StringComparison.Ordinal)) ||
-                            (-1 != escapedString.IndexOf("%3f", StringComparison.Ordinal)) ||
-                            (-1 != escapedString.IndexOf("%3F", StringComparison.Ordinal))
-                        ;
+                    // %3f or %3F
+                    return true;
                 }
+                // Continue searching for % starting at (index + 1). We know that it has to be followed by at least two
+                // more characters so we subtract 2 from the length of the substring to search.
+                index = escapedString.IndexOf('%', index + 1, escapedString.Length - (index + 1) - 2);
             }
             return false;
         }
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index ba1fbfd01d3..1bfdc57490e 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -9,7 +9,6 @@
 using System.Linq;
 using System.Text.RegularExpressions;
 using System.Collections.Generic;
-using System.Collections.Immutable;
 using System.Threading.Tasks;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
@@ -34,14 +33,13 @@ internal class FileMatcher
         private static readonly string[] s_propertyAndItemReferences = { "$(", "@(" };
 
         // on OSX both System.IO.Path separators are '/', so we have to use the literals
-        internal static readonly char[] directorySeparatorCharacters = { '/', '\\' };
-        internal static readonly string[] directorySeparatorStrings = directorySeparatorCharacters.Select(c => c.ToString()).ToArray();
+        internal static readonly char[] directorySeparatorCharacters = FileUtilities.Slashes;
 
         // until Cloudbuild switches to EvaluationContext, we need to keep their dependence on global glob caching via an environment variable
-        private static readonly Lazy<ConcurrentDictionary<string, ImmutableArray<string>>> s_cachedGlobExpansions = new Lazy<ConcurrentDictionary<string, ImmutableArray<string>>>(() => new ConcurrentDictionary<string, ImmutableArray<string>>(StringComparer.OrdinalIgnoreCase));
+        private static readonly Lazy<ConcurrentDictionary<string, IReadOnlyList<string>>> s_cachedGlobExpansions = new Lazy<ConcurrentDictionary<string, IReadOnlyList<string>>>(() => new ConcurrentDictionary<string, IReadOnlyList<string>>(StringComparer.OrdinalIgnoreCase));
         private static readonly Lazy<ConcurrentDictionary<string, object>> s_cachedGlobExpansionsLock = new Lazy<ConcurrentDictionary<string, object>>(() => new ConcurrentDictionary<string, object>(StringComparer.OrdinalIgnoreCase));
 
-        private readonly ConcurrentDictionary<string, ImmutableArray<string>> _cachedGlobExpansions;
+        private readonly ConcurrentDictionary<string, IReadOnlyList<string>> _cachedGlobExpansions;
         private readonly Lazy<ConcurrentDictionary<string, object>> _cachedGlobExpansionsLock = new Lazy<ConcurrentDictionary<string, object>>(() => new ConcurrentDictionary<string, object>(StringComparer.OrdinalIgnoreCase));
 
         /// <summary>
@@ -83,7 +81,7 @@ private static class FileSpecRegexParts
         /// </summary>
         public static FileMatcher Default = new FileMatcher(FileSystems.Default, null);
 
-        public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary<string, ImmutableArray<string>> fileEntryExpansionCache = null) : this(
+        public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary<string, IReadOnlyList<string>> fileEntryExpansionCache = null) : this(
             fileSystem,
             (entityType, path, pattern, projectDirectory, stripProjectDirectory) => GetAccessibleFileSystemEntries(
                 fileSystem,
@@ -91,12 +89,12 @@ public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary<string, Immutabl
                 path,
                 pattern,
                 projectDirectory,
-                stripProjectDirectory),
+                stripProjectDirectory).ToArray(),
             fileEntryExpansionCache)
         {
         }
 
-        public FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEntries, ConcurrentDictionary<string, ImmutableArray<string>> getFileSystemDirectoryEntriesCache = null)
+        internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEntries, ConcurrentDictionary<string, IReadOnlyList<string>> getFileSystemDirectoryEntriesCache = null)
         {
             if (Traits.Instance.MSBuildCacheFileEnumerations)
             {
@@ -112,21 +110,51 @@ public FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEnt
 
             _getFileSystemEntries = getFileSystemDirectoryEntriesCache == null
                 ? getFileSystemEntries
-                : (type, path, pattern, directory, projectDirectory) =>
+                : (type, path, pattern, directory, stripProjectDirectory) =>
                 {
-                    // Cache only directories, for files we won't hit the cache because the file name patterns tend to be unique
-                    if (type == FileSystemEntity.Directories)
+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
                     {
-                        return getFileSystemDirectoryEntriesCache.GetOrAdd(
-                            $"{path};{pattern ?? "*"}",
-                            s => getFileSystemEntries(
-                                type,
-                                path,
-                                pattern,
-                                directory,
-                                projectDirectory));
+                        // New behavior:
+                        // Always hit the filesystem with "*" pattern, cache the results, and do the filtering here.
+                        string cacheKey = type switch
+                        {
+                            FileSystemEntity.Files => "F",
+                            FileSystemEntity.Directories => "D",
+                            FileSystemEntity.FilesAndDirectories => "A",
+                            _ => throw new NotImplementedException()
+                        } + ";" + path;
+                        IReadOnlyList<string> allEntriesForPath = getFileSystemDirectoryEntriesCache.GetOrAdd(
+                                cacheKey,
+                                s => getFileSystemEntries(
+                                    type,
+                                    path,
+                                    "*",
+                                    directory,
+                                    false));
+                        IEnumerable<string> filteredEntriesForPath = (pattern != null && pattern != "*" && pattern != "*.*")
+                            ? allEntriesForPath.Where(o => IsMatch(Path.GetFileName(o), pattern))
+                            : allEntriesForPath;
+                        return stripProjectDirectory
+                            ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToArray()
+                            : filteredEntriesForPath.ToArray();
+                    }
+                    else
+                    {
+                        // Legacy behavior:
+                        // Cache only directories, for files we won't hit the cache because the file name patterns tend to be unique
+                        if (type == FileSystemEntity.Directories)
+                        {
+                            return getFileSystemDirectoryEntriesCache.GetOrAdd(
+                                $"D;{path};{pattern ?? "*"}",
+                                s => getFileSystemEntries(
+                                    type,
+                                    path,
+                                    pattern,
+                                    directory,
+                                    stripProjectDirectory).ToArray());
+                        }
                     }
-                    return getFileSystemEntries(type, path, pattern, directory, projectDirectory);
+                    return getFileSystemEntries(type, path, pattern, directory, stripProjectDirectory);
                 };
         }
 
@@ -149,8 +177,8 @@ internal enum FileSystemEntity
         /// <param name="pattern">The file pattern.</param>
         /// <param name="projectDirectory"></param>
         /// <param name="stripProjectDirectory"></param>
-        /// <returns>An immutable array of filesystem entries.</returns>
-        internal delegate ImmutableArray<string> GetFileSystemEntries(FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);
+        /// <returns>An enumerable of filesystem entries.</returns>
+        internal delegate IReadOnlyList<string> GetFileSystemEntries(FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);
 
         internal static void ClearFileEnumerationsCache()
         {
@@ -179,14 +207,6 @@ internal static bool HasWildcards(string filespec)
             return -1 != filespec.LastIndexOfAny(s_wildcardCharacters);
         }
 
-        /// <summary>
-        /// Determines whether the given path has any wild card characters or semicolons.
-        /// </summary>
-        internal static bool HasWildcardsOrSemicolon(string filespec)
-        {
-            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);
-        }
-
         /// <summary>
         /// Determines whether the given path has any wild card characters, any semicolons or any property references.
         /// </summary>
@@ -217,7 +237,7 @@ internal static bool HasPropertyOrItemReferences(string filespec)
         /// <param name="stripProjectDirectory">If true the project directory should be stripped</param>
         /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
         /// <returns></returns>
-        private static ImmutableArray<string> GetAccessibleFileSystemEntries(IFileSystem fileSystem, FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
+        private static IReadOnlyList<string> GetAccessibleFileSystemEntries(IFileSystem fileSystem, FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
         {
             path = FileUtilities.FixFilePath(path);
             switch (entityType)
@@ -229,18 +249,18 @@ private static ImmutableArray<string> GetAccessibleFileSystemEntries(IFileSystem
                     ErrorUtilities.VerifyThrow(false, "Unexpected filesystem entity type.");
                     break;
             }
-            return ImmutableArray<string>.Empty;
+            return Array.Empty<string>();
         }
 
         /// <summary>
-        /// Returns an immutable array of file system entries matching the specified search criteria. Inaccessible or non-existent file
+        /// Returns an enumerable of file system entries matching the specified search criteria. Inaccessible or non-existent file
         /// system entries are skipped.
         /// </summary>
         /// <param name="path"></param>
         /// <param name="pattern"></param>
         /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
-        /// <returns>An immutable array of matching file system entries (can be empty).</returns>
-        private static ImmutableArray<string> GetAccessibleFilesAndDirectories(IFileSystem fileSystem, string path, string pattern)
+        /// <returns>An enumerable of matching file system entries (can be empty).</returns>
+        private static IReadOnlyList<string> GetAccessibleFilesAndDirectories(IFileSystem fileSystem, string path, string pattern)
         {
             if (fileSystem.DirectoryExists(path))
             {
@@ -248,9 +268,9 @@ private static ImmutableArray<string> GetAccessibleFilesAndDirectories(IFileSyst
                 {
                     return (ShouldEnforceMatching(pattern)
                         ? fileSystem.EnumerateFileSystemEntries(path, pattern)
-                            .Where(o => IsMatch(Path.GetFileName(o), pattern, true))
+                            .Where(o => IsMatch(Path.GetFileName(o), pattern))
                         : fileSystem.EnumerateFileSystemEntries(path, pattern)
-                        ).ToImmutableArray();
+                        ).ToArray();
                 }
                 // for OS security
                 catch (UnauthorizedAccessException)
@@ -264,7 +284,7 @@ private static ImmutableArray<string> GetAccessibleFilesAndDirectories(IFileSyst
                 }
             }
 
-            return ImmutableArray<string>.Empty;
+            return Array.Empty<string>();
         }
 
         /// <summary>
@@ -306,7 +326,7 @@ private static bool ShouldEnforceMatching(string searchPattern)
         /// <param name="stripProjectDirectory"></param>
         /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
         /// <returns>Files that can be accessed.</returns>
-        private static ImmutableArray<string> GetAccessibleFiles
+        private static IReadOnlyList<string> GetAccessibleFiles
         (
             IFileSystem fileSystem,
             string path,
@@ -331,7 +351,7 @@ bool stripProjectDirectory
                     files = fileSystem.EnumerateFiles(dir, filespec);
                     if (ShouldEnforceMatching(filespec))
                     {
-                        files = files.Where(o => IsMatch(Path.GetFileName(o), filespec, true));
+                        files = files.Where(o => IsMatch(Path.GetFileName(o), filespec));
                     }
                 }
                 // If the Item is based on a relative path we need to strip
@@ -350,17 +370,17 @@ bool stripProjectDirectory
                     files = RemoveInitialDotSlash(files);
                 }
 
-                return files.ToImmutableArray();
+                return files.ToArray();
             }
             catch (System.Security.SecurityException)
             {
                 // For code access security.
-                return ImmutableArray<string>.Empty;
+                return Array.Empty<string>();
             }
             catch (System.UnauthorizedAccessException)
             {
                 // For OS security.
-                return ImmutableArray<string>.Empty;
+                return Array.Empty<string>();
             }
         }
 
@@ -374,7 +394,7 @@ bool stripProjectDirectory
         /// <param name="pattern">Pattern to match</param>
         /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
         /// <returns>Accessible directories.</returns>
-        private static ImmutableArray<string> GetAccessibleDirectories
+        private static IReadOnlyList<string> GetAccessibleDirectories
         (
             IFileSystem fileSystem,
             string path,
@@ -394,7 +414,7 @@ string pattern
                     directories = fileSystem.EnumerateDirectories((path.Length == 0) ? s_thisDirectory : path, pattern);
                     if (ShouldEnforceMatching(pattern))
                     {
-                        directories = directories.Where(o => IsMatch(Path.GetFileName(o), pattern, true));
+                        directories = directories.Where(o => IsMatch(Path.GetFileName(o), pattern));
                     }
                 }
 
@@ -408,17 +428,17 @@ string pattern
                     directories = RemoveInitialDotSlash(directories);
                 }
 
-                return directories.ToImmutableArray();
+                return directories.ToArray();
             }
             catch (System.Security.SecurityException)
             {
                 // For code access security.
-                return ImmutableArray<string>.Empty;
+                return Array.Empty<string>();
             }
             catch (System.UnauthorizedAccessException)
             {
                 // For OS security.
-                return ImmutableArray<string>.Empty;
+                return Array.Empty<string>();
             }
         }
 
@@ -508,10 +528,10 @@ GetFileSystemEntries getFileSystemEntries
                     }
                     else
                     {
-                        // getFileSystemEntries(...) returns an empty array if longPath doesn't exist.
-                        ImmutableArray<string> entries = getFileSystemEntries(FileSystemEntity.FilesAndDirectories, longPath, parts[i], null, false);
+                        // getFileSystemEntries(...) returns an empty enumerable if longPath doesn't exist.
+                        IReadOnlyList<string> entries = getFileSystemEntries(FileSystemEntity.FilesAndDirectories, longPath, parts[i], null, false);
 
-                        if (0 == entries.Length)
+                        if (0 == entries.Count)
                         {
                             // The next part doesn't exist. Therefore, no more of the path will exist.
                             // Just return the rest.
@@ -522,10 +542,10 @@ GetFileSystemEntries getFileSystemEntries
                             break;
                         }
 
-                        // Since we know there are no wild cards, this should be length one.
-                        ErrorUtilities.VerifyThrow(entries.Length == 1,
+                        // Since we know there are no wild cards, this should be length one, i.e. MoveNext should return false.
+                        ErrorUtilities.VerifyThrow(entries.Count == 1,
                             "Unexpected number of entries ({3}) found when enumerating '{0}' under '{1}'. Original path was '{2}'",
-                            parts[i], longPath, path, entries.Length);
+                            parts[i], longPath, path, entries.Count);
 
                         // Entries[0] contains the full path.
                         longPath = entries[0];
@@ -759,11 +779,13 @@ class FilesSearchData
         {
             public FilesSearchData(
                 string filespec,                // can be null
+                string directoryPattern,        // can be null
                 Regex regexFileMatch,           // can be null
                 bool needsRecursion
                 )
             {
                 Filespec = filespec;
+                DirectoryPattern = directoryPattern;
                 RegexFileMatch = regexFileMatch;
                 NeedsRecursion = needsRecursion;
             }
@@ -773,6 +795,13 @@ bool needsRecursion
             /// </summary>
             public string Filespec { get; }
             /// <summary>
+            /// Holds the directory pattern for globs like **/{pattern}/**, i.e. when we're looking for a matching directory name
+            /// regardless of where on the path it is. This field is used only if the wildcard directory part has this shape. In
+            /// other cases such as **/{pattern1}/**/{pattern2}/**, we don't use this optimization and instead rely on
+            /// <see cref="RegexFileMatch"/> to test if a file path matches the glob or not.
+            /// </summary>
+            public string DirectoryPattern { get; }
+            /// <summary>
             /// Wild-card matching.
             /// </summary>
             public Regex RegexFileMatch { get; }
@@ -793,9 +822,18 @@ struct RecursionState
             /// </summary>
             public string RemainingWildcardDirectory;
             /// <summary>
+            /// True if SearchData.DirectoryPattern is non-null and we have descended into a directory that matches the pattern.
+            /// </summary>
+            public bool IsInsideMatchingDirectory;
+            /// <summary>
             /// Data about a search that does not change as the search recursively traverses directories
             /// </summary>
             public FilesSearchData SearchData;
+
+            /// <summary>
+            /// True if a SearchData.DirectoryPattern is specified but we have not descended into a matching directory.
+            /// </summary>
+            public bool IsLookingForMatchingDirectory => (SearchData.DirectoryPattern != null && !IsInsideMatchingDirectory);
         }
 
         /// <summary>
@@ -841,6 +879,8 @@ private void GetFilesRecursive(
 
                     //  We can exclude all results in this folder if:
                     if (
+                        //  We are not looking for a directory matching the pattern given in SearchData.DirectoryPattern
+                        !searchToExclude.IsLookingForMatchingDirectory &&
                         //  We are matching files based on a filespec and not a regular expression
                         searchToExclude.SearchData.Filespec != null &&
                         //  The wildcard path portion of the excluded search matches the include search
@@ -901,6 +941,12 @@ private void GetFilesRecursive(
                 newRecursionState.BaseDirectory = subdir;
                 newRecursionState.RemainingWildcardDirectory = nextStep.RemainingWildcardDirectory;
 
+                if (newRecursionState.IsLookingForMatchingDirectory &&
+                    DirectoryEndsWithPattern(subdir, recursionState.SearchData.DirectoryPattern))
+                {
+                    newRecursionState.IsInsideMatchingDirectory = true;
+                }
+
                 List<RecursionState> newSearchesToExclude = null;
 
                 if (excludeNextSteps != null)
@@ -910,11 +956,16 @@ private void GetFilesRecursive(
                     for (int i = 0; i < excludeNextSteps.Length; i++)
                     {
                         if (excludeNextSteps[i].NeedsDirectoryRecursion &&
-                            (excludeNextSteps[i].DirectoryPattern == null || IsMatch(Path.GetFileName(subdir), excludeNextSteps[i].DirectoryPattern, true)))
+                            (excludeNextSteps[i].DirectoryPattern == null || IsMatch(Path.GetFileName(subdir), excludeNextSteps[i].DirectoryPattern)))
                         {
                             RecursionState thisExcludeStep = searchesToExclude[i];
                             thisExcludeStep.BaseDirectory = subdir;
                             thisExcludeStep.RemainingWildcardDirectory = excludeNextSteps[i].RemainingWildcardDirectory;
+                            if (thisExcludeStep.IsLookingForMatchingDirectory &&
+                                DirectoryEndsWithPattern(subdir, thisExcludeStep.SearchData.DirectoryPattern))
+                            {
+                                thisExcludeStep.IsInsideMatchingDirectory = true;
+                            }
                             newSearchesToExclude.Add(thisExcludeStep);
                         }
                     }
@@ -1012,8 +1063,24 @@ private IEnumerable<string> GetFilesForStep(
             {
                 return Enumerable.Empty<string>();
             }
+
+            // Back-compat hack: We don't use case-insensitive file enumeration I/O on Linux so the behavior is different depending
+            // on the NeedsToProcessEachFile flag. If the flag is false and matching is done within the _getFileSystemEntries call,
+            // it is case sensitive. If the flag is true and matching is handled with MatchFileRecursionStep, it is case-insensitive.
+            // TODO: Can we fix this by using case-insensitive file I/O on Linux?
+            string filespec;
+            if (NativeMethodsShared.IsLinux && recursionState.SearchData.DirectoryPattern != null)
+            {
+                filespec = "*.*";
+                stepResult.NeedsToProcessEachFile = true;
+            }
+            else
+            {
+                filespec = recursionState.SearchData.Filespec;
+            }
+
             IEnumerable<string> files = _getFileSystemEntries(FileSystemEntity.Files, recursionState.BaseDirectory,
-                recursionState.SearchData.Filespec, projectDirectory, stripProjectDirectory);
+                filespec, projectDirectory, stripProjectDirectory);
 
             if (!stepResult.NeedsToProcessEachFile)
             {
@@ -1026,7 +1093,7 @@ private static bool MatchFileRecursionStep(RecursionState recursionState, string
         {
             if (recursionState.SearchData.Filespec != null)
             {
-                return IsMatch(Path.GetFileName(file), recursionState.SearchData.Filespec, true);
+                return IsMatch(Path.GetFileName(file), recursionState.SearchData.Filespec);
             }
 
             // if no file-spec provided, match the file to the regular expression
@@ -1047,9 +1114,14 @@ RecursionState recursionState
             bool considerFiles = false;
 
             // Only consider files if...
-            if (recursionState.RemainingWildcardDirectory.Length == 0)
+            if (recursionState.SearchData.DirectoryPattern != null)
             {
-                // We've reached the end of the wildcard directory elements.
+                // We are looking for a directory pattern and have descended into a matching directory,
+                considerFiles = recursionState.IsInsideMatchingDirectory;
+            }
+            else if (recursionState.RemainingWildcardDirectory.Length == 0)
+            {
+                // or we've reached the end of the wildcard directory elements,
                 considerFiles = true;
             }
             else if (recursionState.RemainingWildcardDirectory.IndexOf(recursiveDirectoryMatch, StringComparison.Ordinal) == 0)
@@ -1121,21 +1193,14 @@ RecursionState recursionState
         /// <param name="fixedDirectoryPart">The fixed directory part.</param>
         /// <param name="wildcardDirectoryPart">The wildcard directory part.</param>
         /// <param name="filenamePart">The filename part.</param>
-        /// <param name="isLegalFileSpec">Receives whether this pattern is legal or not.</param>
         /// <returns>The regular expression string.</returns>
-        private static string RegularExpressionFromFileSpec
+        internal static string RegularExpressionFromFileSpec
         (
             string fixedDirectoryPart,
             string wildcardDirectoryPart,
-            string filenamePart,
-            out bool isLegalFileSpec
+            string filenamePart
         )
         {
-            isLegalFileSpec = IsLegalFileSpec(wildcardDirectoryPart, filenamePart);
-            if (!isLegalFileSpec)
-            {
-                return string.Empty;
-            }
 #if DEBUG
             ErrorUtilities.VerifyThrow(
                 FileSpecRegexMinLength == FileSpecRegexParts.FixedDirGroupStart.Length
@@ -1460,19 +1525,19 @@ internal void GetFileSpecInfoWithRegexObject(
             out bool needsRecursion,
             out bool isLegalFileSpec)
         {
-            string fixedDirectoryPart;
-            string wildcardDirectoryPart;
-            string filenamePart;
-            string matchFileExpression;
-
             GetFileSpecInfo(filespec,
-                out fixedDirectoryPart, out wildcardDirectoryPart, out filenamePart,
-                out matchFileExpression, out needsRecursion, out isLegalFileSpec);
+                out string fixedDirectoryPart, out string wildcardDirectoryPart, out string filenamePart,
+                out needsRecursion, out isLegalFileSpec);
 
-            
-            regexFileMatch = isLegalFileSpec
-                ? new Regex(matchFileExpression, DefaultRegexOptions)
-                : null;
+            if (isLegalFileSpec)
+            {
+                string matchFileExpression = RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart);
+                regexFileMatch = new Regex(matchFileExpression, DefaultRegexOptions);
+            }
+            else
+            {
+                regexFileMatch = null;
+            }
         }
 
         internal delegate (string fixedDirectoryPart, string recursiveDirectoryPart, string fileNamePart) FixupParts(
@@ -1487,7 +1552,6 @@ internal delegate (string fixedDirectoryPart, string recursiveDirectoryPart, str
         /// <param name="fixedDirectoryPart">Receives the fixed directory part.</param>
         /// <param name="wildcardDirectoryPart">Receives the wildcard directory part.</param>
         /// <param name="filenamePart">Receives the filename part.</param>
-        /// <param name="matchFileExpression">Receives the regular expression.</param>
         /// <param name="needsRecursion">Receives the flag that is true if recursion is required.</param>
         /// <param name="isLegalFileSpec">Receives the flag that is true if the filespec is legal.</param>
         /// <param name="fixupParts">hook method to further change the parts</param>
@@ -1496,7 +1560,6 @@ internal void GetFileSpecInfo(
             out string fixedDirectoryPart,
             out string wildcardDirectoryPart,
             out string filenamePart,
-            out string matchFileExpression,
             out bool needsRecursion,
             out bool isLegalFileSpec,
             FixupParts fixupParts = null)
@@ -1505,7 +1568,6 @@ internal void GetFileSpecInfo(
             fixedDirectoryPart = String.Empty;
             wildcardDirectoryPart = String.Empty;
             filenamePart = String.Empty;
-            matchFileExpression = null;
 
             if (!RawFileSpecIsValid(filespec))
             {
@@ -1527,14 +1589,10 @@ internal void GetFileSpecInfo(
                 filenamePart = newParts.fileNamePart;
             }
 
-            /*
-             *  Get a regular expression for matching files that will be found.
-             */
-            matchFileExpression = RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart, out isLegalFileSpec);
-
             /*
              * Was the filespec valid? If not, then just return now.
              */
+            isLegalFileSpec = IsLegalFileSpec(wildcardDirectoryPart, filenamePart);
             if (!isLegalFileSpec)
             {
                 return;
@@ -1611,8 +1669,7 @@ internal Result()
         /// </summary>
         /// <param name="input">String which is matched against the pattern.</param>
         /// <param name="pattern">Pattern against which string is matched.</param>
-        /// <param name="ignoreCase">Determines whether ignoring case when comparing two characters</param>
-        internal static bool IsMatch(string input, string pattern, bool ignoreCase)
+        internal static bool IsMatch(string input, string pattern)
         {
             if (input == null)
             {
@@ -1651,26 +1708,20 @@ internal static bool IsMatch(string input, string pattern, bool ignoreCase)
             bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
 #endif
             {
-                // We will mostly be comparing ASCII characters, check this first
-                if (inputChar < 128 && patternChar < 128)
+                // We will mostly be comparing ASCII characters, check English letters first.
+                char inputCharLower = (char)(inputChar | 0x20);
+                if (inputCharLower >= 'a' && inputCharLower <= 'z')
                 {
-                    if (inputChar >= 'A' && inputChar <= 'Z' && patternChar >= 'a' && patternChar <= 'z')
-                    {
-                        return inputChar + 32 == patternChar;
-                    }
-                    if (inputChar >= 'a' && inputChar <= 'z' && patternChar >= 'A' && patternChar <= 'Z')
-                    {
-                        return inputChar == patternChar + 32;
-                    }
-                    return inputChar == patternChar;
+                    // This test covers all combinations of lower/upper as both sides are converted to lower case.
+                    return inputCharLower == (patternChar | 0x20);
                 }
-                if (inputChar > 128 && patternChar > 128)
+                if (inputChar < 128 || patternChar < 128)
                 {
-                    return string.Compare(input, iIndex, pattern, pIndex, 1, StringComparison.OrdinalIgnoreCase) == 0;
+                    // We don't need to compare, an ASCII character cannot have its lowercase/uppercase outside the ASCII table
+                    // and a non ASCII character cannot have its lowercase/uppercase inside the ASCII table
+                    return inputChar == patternChar;
                 }
-                // We don't need to compare, an ASCII character cannot have its lowercase/uppercase outside the ASCII table
-                // and a non ASCII character cannot have its lowercase/uppercase inside the ASCII table
-                return false;
+                return string.Compare(input, iIndex, pattern, pIndex, 1, StringComparison.OrdinalIgnoreCase) == 0;
             }
 #if MONO
             ; // The end of the CompareIgnoreCase anonymous function
@@ -1710,10 +1761,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                                     break;
                                 }
                                 // If the tail doesn't match, we can safely return e.g. ("aaa", "*b")
-                                if ((
-                                        (!ignoreCase && input[inputTailIndex] != pattern[patternTailIndex]) ||
-                                        (ignoreCase && !CompareIgnoreCase(input[inputTailIndex], pattern[patternTailIndex], patternTailIndex, inputTailIndex))
-                                    ) &&
+                                if (!CompareIgnoreCase(input[inputTailIndex], pattern[patternTailIndex], patternTailIndex, inputTailIndex) &&
                                     pattern[patternTailIndex] != '?')
                                 {
                                     return false;
@@ -1733,9 +1781,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                         // The ? wildcard cannot be skipped as we will have a wrong result for e.g. ("aab" "*?b")
                         if (pattern[patternIndex] != '?')
                         {
-                            while (
-                                (!ignoreCase && input[inputIndex] != pattern[patternIndex]) ||
-                                (ignoreCase && !CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex)))
+                            while (!CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex))
                             {
                                 // Return if there is no character that match e.g. ("aa", "*b")
                                 if (++inputIndex >= inputLength)
@@ -1750,9 +1796,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                     }
 
                     // If we have a match, step to the next character
-                    if (
-                        (!ignoreCase && input[inputIndex] == pattern[patternIndex]) ||
-                        (ignoreCase && CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex)) ||
+                    if (CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex) ||
                         pattern[patternIndex] == '?')
                     {
                         patternIndex++;
@@ -1893,7 +1937,7 @@ internal string[] GetFiles
 
             var enumerationKey = ComputeFileEnumerationCacheKey(projectDirectoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
 
-            ImmutableArray<string> files;
+            IReadOnlyList<string> files;
             if (!_cachedGlobExpansions.TryGetValue(enumerationKey, out files))
             {
                 // avoid parallel evaluations of the same wildcard by using a unique lock for each wildcard
@@ -1909,8 +1953,7 @@ internal string[] GetFiles
                                     GetFilesImplementation(
                                         projectDirectoryUnescaped,
                                         filespecUnescaped,
-                                        excludeSpecsUnescaped)
-                                        .ToImmutableArray());
+                                        excludeSpecsUnescaped));
                     }
                 }
             }
@@ -2012,21 +2055,14 @@ private SearchAction GetFileSearchData(
             stripProjectDirectory = false;
             result = new RecursionState();
 
-            string fixedDirectoryPart;
-            string wildcardDirectoryPart;
-            string filenamePart;
-            string matchFileExpression;
-            bool needsRecursion;
-            bool isLegalFileSpec;
             GetFileSpecInfo
             (
                 filespecUnescaped,
-                out fixedDirectoryPart,
-                out wildcardDirectoryPart,
-                out filenamePart,
-                out matchFileExpression,
-                out needsRecursion,
-                out isLegalFileSpec
+                out string fixedDirectoryPart,
+                out string wildcardDirectoryPart,
+                out string filenamePart,
+                out bool needsRecursion,
+                out bool isLegalFileSpec
             );
 
             /*
@@ -2039,11 +2075,11 @@ out isLegalFileSpec
 
             // The projectDirectory is not null only if we are running the evaluation from
             // inside the engine (i.e. not from a task)
+            string oldFixedDirectoryPart = fixedDirectoryPart;
             if (projectDirectoryUnescaped != null)
             {
                 if (fixedDirectoryPart != null)
                 {
-                    string oldFixedDirectoryPart = fixedDirectoryPart;
                     try
                     {
                         fixedDirectoryPart = Path.Combine(projectDirectoryUnescaped, fixedDirectoryPart);
@@ -2071,11 +2107,37 @@ out isLegalFileSpec
                 return SearchAction.ReturnEmptyList;
             }
 
+            string directoryPattern = null;
+            if (wildcardDirectoryPart.Length > 0)
+            {
+                // If the wildcard directory part looks like "**/{pattern}/**", we are essentially looking for files that have
+                // a matching directory anywhere on their path. This is commonly used when excluding hidden directories using
+                // "**/.*/**" for example, and is worth special-casing so it doesn't fall into the slow regex logic.
+                string wildcard = wildcardDirectoryPart.TrimTrailingSlashes();
+                int wildcardLength = wildcard.Length;
+                if (wildcardLength > 6 &&
+                    wildcard[0] == '*' &&
+                    wildcard[1] == '*' &&
+                    FileUtilities.IsAnySlash(wildcard[2]) &&
+                    FileUtilities.IsAnySlash(wildcard[wildcardLength - 3]) &&
+                    wildcard[wildcardLength - 2] == '*' &&
+                    wildcard[wildcardLength - 1] == '*')
+                {
+                    // Check that there are no other slashes in the wildcard.
+                    if (wildcard.IndexOfAny(FileUtilities.Slashes, 3, wildcardLength - 6) == -1)
+                    {
+                        directoryPattern = wildcard.Substring(3, wildcardLength - 6);
+                    }
+                }
+            }
+
             // determine if we need to use the regular expression to match the files
             // PERF NOTE: Constructing a Regex object is expensive, so we avoid it whenever possible
             bool matchWithRegex =
                 // if we have a directory specification that uses wildcards, and
                 (wildcardDirectoryPart.Length > 0) &&
+                // the directory pattern is not a simple "**/{pattern}/**", and
+                directoryPattern == null &&
                 // the specification is not a simple "**"
                 !IsRecursiveDirectoryMatch(wildcardDirectoryPart);
             // then we need to use the regular expression
@@ -2083,8 +2145,9 @@ out isLegalFileSpec
             var searchData = new FilesSearchData(
                 // if using the regular expression, ignore the file pattern
                 matchWithRegex ? null : filenamePart,
+                directoryPattern,
                 // if using the file pattern, ignore the regular expression
-                matchWithRegex ? new Regex(matchFileExpression, RegexOptions.IgnoreCase) : null,
+                matchWithRegex ? new Regex(RegularExpressionFromFileSpec(oldFixedDirectoryPart, wildcardDirectoryPart, filenamePart), RegexOptions.IgnoreCase) : null,
                 needsRecursion);
 
             result.SearchData = searchData;
@@ -2110,12 +2173,12 @@ internal static string Normalize(string aString)
             var index = 0;
 
             // preserve meaningful roots and their slashes
-            if (aString.Length >= 2 && IsValidDriveChar(aString[0]) && aString[1] == ':')
+            if (aString.Length >= 2 && aString[1] == ':' && IsValidDriveChar(aString[0]))
             {
                 sb.Append(aString[0]);
                 sb.Append(aString[1]);
 
-                var i = SkipCharacters(aString, 2, c => FileUtilities.IsAnySlash(c));
+                var i = SkipSlashes(aString, 2);
 
                 if (index != i)
                 {
@@ -2127,22 +2190,22 @@ internal static string Normalize(string aString)
             else if (aString.StartsWith("/", StringComparison.Ordinal))
             {
                 sb.Append('/');
-                index = SkipCharacters(aString, 1, c => FileUtilities.IsAnySlash(c));
+                index = SkipSlashes(aString, 1);
             }
             else if (aString.StartsWith(@"\\", StringComparison.Ordinal))
             {
                 sb.Append(@"\\");
-                index = SkipCharacters(aString, 2, c => FileUtilities.IsAnySlash(c));
+                index = SkipSlashes(aString, 2);
             }
             else if (aString.StartsWith(@"\", StringComparison.Ordinal))
             {
                 sb.Append(@"\");
-                index = SkipCharacters(aString, 1, c => FileUtilities.IsAnySlash(c));
+                index = SkipSlashes(aString, 1);
             }
 
             while (index < aString.Length)
             {
-                var afterSlashesIndex = SkipCharacters(aString, index, c => FileUtilities.IsAnySlash(c));
+                var afterSlashesIndex = SkipSlashes(aString, index);
 
                 // do not append separator at the end of the string
                 if (afterSlashesIndex >= aString.Length)
@@ -2155,7 +2218,9 @@ internal static string Normalize(string aString)
                     sb.Append(s_directorySeparator);
                 }
 
-                var afterNonSlashIndex = SkipCharacters(aString, afterSlashesIndex, c => !FileUtilities.IsAnySlash(c));
+                // skip non-slashes
+                var indexOfAnySlash = aString.IndexOfAny(directorySeparatorCharacters, afterSlashesIndex);
+                var afterNonSlashIndex = indexOfAnySlash == -1 ? aString.Length : indexOfAnySlash;
 
                 sb.Append(aString, afterSlashesIndex, afterNonSlashIndex - afterSlashesIndex);
 
@@ -2166,16 +2231,16 @@ internal static string Normalize(string aString)
         }
 
         /// <summary>
-        /// Skips characters that satisfy the condition <param name="jumpOverCharacter"></param>
+        /// Skips slash characters in a string.
         /// </summary>
         /// <param name="aString">The working string</param>
         /// <param name="startingIndex">Offset in string to start the search in</param>
-        /// <returns>First index that does not satisfy the condition. Returns the string's length if end of string is reached</returns>
-        private static int SkipCharacters(string aString, int startingIndex, Func<char, bool> jumpOverCharacter)
+        /// <returns>First index that is not a slash. Returns the string's length if end of string is reached</returns>
+        private static int SkipSlashes(string aString, int startingIndex)
         {
             var index = startingIndex;
 
-            while (index < aString.Length && jumpOverCharacter(aString[index]))
+            while (index < aString.Length && FileUtilities.IsAnySlash(aString[index]))
             {
                 index++;
             }
@@ -2187,12 +2252,12 @@ private static int SkipCharacters(string aString, int startingIndex, Func<char,
         /// <summary>
         /// Returns true if the given character is a valid drive letter
         /// </summary>
-        internal static bool IsValidDriveChar(char value)
+        private static bool IsValidDriveChar(char value)
         {
             return (value >= 'A' && value <= 'Z') || (value >= 'a' && value <= 'z');
         }
 
-        static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List<string> excludeSpecsUnescaped)
+        private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List<string> excludeSpecsUnescaped)
         {
             if (excludeSpecsUnescaped != null)
             {
@@ -2235,10 +2300,8 @@ private string[] GetFilesImplementation(
             /*
              * Analyze the file spec and get the information we need to do the matching.
              */
-            bool stripProjectDirectory;
-            RecursionState state;
             var action = GetFileSearchData(projectDirectoryUnescaped, filespecUnescaped,
-                out stripProjectDirectory, out state);
+                out bool stripProjectDirectory, out RecursionState state);
 
             if (action == SearchAction.ReturnEmptyList)
             {
@@ -2267,11 +2330,8 @@ private string[] GetFilesImplementation(
                 foreach (string excludeSpec in excludeSpecsUnescaped)
                 {
                     //  This is ignored, we always use the include pattern's value for stripProjectDirectory
-                    bool excludeStripProjectDirectory;
-
-                    RecursionState excludeState;
                     var excludeAction = GetFileSearchData(projectDirectoryUnescaped, excludeSpec,
-                        out excludeStripProjectDirectory, out excludeState);
+                        out _, out RecursionState excludeState);
 
                     if (excludeAction == SearchAction.ReturnFileSpec)
                     {
@@ -2370,7 +2430,8 @@ private string[] GetFilesImplementation(
                                 //  BaseDirectory to be the same as the exclude BaseDirectory, and change the wildcard part to be "**\"
                                 //  because we don't know where the different parts of the exclude wildcard part would be matched.
                                 //  Example: include="c:\git\msbuild\src\Framework\**\*.*" exclude="c:\git\msbuild\**\bin\**\*.*"
-                                Debug.Assert(excludeState.SearchData.RegexFileMatch != null, "Expected Regex to be used for exclude file matching");
+                                Debug.Assert(excludeState.SearchData.RegexFileMatch != null || excludeState.SearchData.DirectoryPattern != null,
+                                    "Expected Regex or directory pattern to be used for exclude file matching");
                                 excludeState.BaseDirectory = state.BaseDirectory;
                                 excludeState.RemainingWildcardDirectory = recursiveDirectoryMatch + s_directorySeparator;
                                 searchesToExclude.Add(excludeState);
@@ -2379,7 +2440,25 @@ private string[] GetFilesImplementation(
                     }
                     else
                     {
-                        searchesToExclude.Add(excludeState);
+                        // Optimization: ignore excludes whose file names can never match our filespec. For example, if we're looking
+                        // for "**/*.cs", we don't have to worry about excluding "{anything}/*.sln" as the intersection of the two will
+                        // always be empty.
+                        string includeFilespec = state.SearchData.Filespec ?? string.Empty;
+                        string excludeFilespec = excludeState.SearchData.Filespec ?? string.Empty;
+                        int compareLength = Math.Min(
+                            includeFilespec.Length - includeFilespec.LastIndexOfAny(s_wildcardCharacters) - 1,
+                            excludeFilespec.Length - excludeFilespec.LastIndexOfAny(s_wildcardCharacters) - 1);
+                        if (string.Compare(
+                                includeFilespec,
+                                includeFilespec.Length - compareLength,
+                                excludeFilespec,
+                                excludeFilespec.Length - compareLength,
+                                compareLength,
+                                StringComparison.OrdinalIgnoreCase) == 0)
+                        {
+                            // The suffix is the same so there is a possibility that the two will match the same files.
+                            searchesToExclude.Add(excludeState);
+                        }
                     }
                 }
             }
@@ -2455,7 +2534,6 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent
             }
 
             bool prefixMatch = possibleChild.StartsWith(possibleParent, StringComparison.OrdinalIgnoreCase);
-
             if (!prefixMatch)
             {
                 return false;
@@ -2473,6 +2551,19 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent
             }
         }
 
-        private static bool IsRecursiveDirectoryMatch(string path) => path.TrimTrailingSlashes() == recursiveDirectoryMatch;
+        /// <summary>
+        /// Returns true if the last component of the given directory path (assumed to not have any trailing slashes)
+        /// matches the given pattern.
+        /// </summary>
+        /// <param name="directoryPath">The path to test.</param>
+        /// <param name="pattern">The pattern to test against.</param>
+        /// <returns>True in case of a match (e.g. directoryPath = "dir/subdir" and pattern = "s*"), false otherwise.</returns>
+        private static bool DirectoryEndsWithPattern(string directoryPath, string pattern)
+        {
+            int index = directoryPath.LastIndexOfAny(FileUtilities.Slashes);
+            return (index != -1 && IsMatch(directoryPath.Substring(index + 1), pattern));
+        }
+
+        internal static bool IsRecursiveDirectoryMatch(string path) => path.TrimTrailingSlashes() == recursiveDirectoryMatch;
     }
 }
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index f35269ebf38..cf40546ec51 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -481,6 +481,38 @@ internal static string MaybeAdjustFilePath(string value, string baseDirectory =
             return shouldAdjust ? newValue.ToString() : value;
         }
 
+        /// <summary>
+        /// If on Unix, convert backslashes to slashes for strings that resemble paths.
+        /// This overload takes and returns ReadOnlyMemory of characters.
+        /// </summary>
+        internal static ReadOnlyMemory<char> MaybeAdjustFilePath(ReadOnlyMemory<char> value, string baseDirectory = "")
+        {
+            if (NativeMethodsShared.IsWindows || value.IsEmpty)
+            {
+                return value;
+            }
+
+            // Don't bother with arrays or properties or network paths.
+            if (value.Length >= 2)
+            {
+                var span = value.Span;
+
+                // The condition is equivalent to span.StartsWith("$(") || span.StartsWith("@(") || span.StartsWith("\\\\")
+                if ((span[1] == '(' && (span[0] == '$' || span[0] == '@')) ||
+                    (span[1] == '\\' && span[0] == '\\'))
+                {
+                    return value;
+                }
+            }
+
+            // For Unix-like systems, we may want to convert backslashes to slashes
+            Span<char> newValue = ConvertToUnixSlashes(value.ToArray());
+
+            // Find the part of the name we want to check, that is remove quotes, if present
+            bool shouldAdjust = newValue.IndexOf('/') != -1 && LooksLikeUnixFilePath(RemoveQuotes(newValue), baseDirectory);
+            return shouldAdjust ? newValue.ToString().AsMemory() : value;
+        }
+
         private static Span<char> ConvertToUnixSlashes(Span<char> path)
         {
             return path.IndexOf('\\') == -1 ? path : CollapseSlashes(path);
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index bacbc95e936..006e0587bf1 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -4,17 +4,11 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-#if FEATURE_SYSTEM_CONFIGURATION
-using System.Configuration;
-#endif
 using System.IO;
 using System.Linq;
 using System.Runtime.Versioning;
 using Microsoft.Win32;
 
-#if FEATURE_SYSTEM_CONFIGURATION
-using PropertyElement = Microsoft.Build.Evaluation.ToolsetElement.PropertyElement;
-#endif
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
@@ -1074,14 +1068,14 @@ private static string FindRegistryValueUnderKey
 
         private static VisualStudioSpec GetVisualStudioSpec(Version version)
         {
-            ErrorUtilities.VerifyThrowArgument(s_visualStudioSpecDict.ContainsKey(version), "FrameworkLocationHelper.UnsupportedVisualStudioVersion", version);
-            return s_visualStudioSpecDict[version];
+            ErrorUtilities.VerifyThrowArgument(s_visualStudioSpecDict.TryGetValue(version, out VisualStudioSpec spec), "FrameworkLocationHelper.UnsupportedVisualStudioVersion", version);
+            return spec;
         }
 
         private static DotNetFrameworkSpec GetDotNetFrameworkSpec(Version version)
         {
-            ErrorUtilities.VerifyThrowArgument(s_dotNetFrameworkSpecDict.ContainsKey(version), "FrameworkLocationHelper.UnsupportedFrameworkVersion", version);
-            return s_dotNetFrameworkSpecDict[version];
+            ErrorUtilities.VerifyThrowArgument(s_dotNetFrameworkSpecDict.TryGetValue(version, out DotNetFrameworkSpec spec), "FrameworkLocationHelper.UnsupportedFrameworkVersion", version);
+            return spec;
         }
 
         /// <summary>
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index 7ae2da0fc2e..501402c8756 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -174,9 +174,19 @@ internal enum NodePacketType : byte
         ResolveSdkRequest,
 
         /// <summary>
-        /// Message sent from back to a node when an SDK has been resolved.
+        /// Message sent back to a node when an SDK has been resolved.
         /// </summary>
         ResolveSdkResponse,
+
+        /// <summary>
+        /// Message sent from a node when a task is requesting or returning resources from the scheduler.
+        /// </summary>
+        ResourceRequest,
+
+        /// <summary>
+        /// Message sent back to a node informing it about the resource that were granted by the scheduler.
+        /// </summary>
+        ResourceResponse,
     }
     #endregion
 
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index 6fec218805e..b1acb85ec2f 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -180,6 +180,16 @@ BinaryWriter Writer
         /// <param name="collectionFactory">factory to create a collection</param>
         void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : IList<T>;
 
+        /// <summary>
+        /// Translates a collection of T into the specified type using an <see cref="ObjectTranslator{T}"/> and <see cref="NodePacketCollectionCreator{L}"/>
+        /// </summary>
+        /// <param name="collection">The collection to be translated.</param>
+        /// <param name="objectTranslator">The translator to use for the values in the collection.</param>
+        /// <param name="collectionFactory">The factory to create the ICollection.</param>
+        /// <typeparam name="T">The type contained in the collection.</typeparam>
+        /// <typeparam name="L">The type of collection to be created.</typeparam>
+        void Translate<T, L>(ref ICollection<T> collection, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : ICollection<T>;
+
         /// <summary>
         /// Translates a DateTime.
         /// </summary>
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 497be9de813..ab68c229c04 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -89,7 +89,12 @@ internal enum LoggingEventType : int
         /// <summary>
         /// Event is a TaskCommandLineEventArgs
         /// </summary>
-        TaskCommandLineEvent = 12
+        TaskCommandLineEvent = 12,
+
+        /// <summary>
+        /// Event is a TaskParameterEventArgs
+        /// </summary>
+        TaskParameterEvent = 13,
     }
     #endregion
 
@@ -485,6 +490,10 @@ private BuildEventArgs GetBuildEventArgFromId()
                     return new TaskFinishedEventArgs(null, null, null, null, null, false);
                 case LoggingEventType.TaskCommandLineEvent:
                     return new TaskCommandLineEventArgs(null, null, MessageImportance.Normal);
+#if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
+                case LoggingEventType.TaskParameterEvent:
+                    return new TaskParameterEventArgs(0, null, null, true, default);
+#endif
                 default:
                     ErrorUtilities.VerifyThrow(false, "Should not get to the default of GetBuildEventArgFromId ID: " + _eventType);
                     return null;
@@ -509,6 +518,12 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.TaskCommandLineEvent;
             }
+#if !TASKHOST
+            else if (eventType == typeof(TaskParameterEventArgs))
+            {
+                return LoggingEventType.TaskParameterEvent;
+            }
+#endif
             else if (eventType == typeof(ProjectFinishedEventArgs))
             {
                 return LoggingEventType.ProjectFinishedEvent;
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index d44b57480d4..f080c2e05a9 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -25,20 +25,8 @@ internal class MSBuildLoadContext : AssemblyLoadContext
                 "MSBuild",
                 "Microsoft.Build",
                 "Microsoft.Build.Framework",
-                "Microsoft.Build.NuGetSdkResolver",
                 "Microsoft.Build.Tasks.Core",
                 "Microsoft.Build.Utilities.Core",
-                "NuGet.Build.Tasks",
-                "NuGet.Common",
-                "NuGet.Configuration",
-                "NuGet.Credentials",
-                "NuGet.DependencyResolver.Core",
-                "NuGet.Frameworks",
-                "NuGet.LibraryModel",
-                "NuGet.Packaging",
-                "NuGet.Protocol",
-                "NuGet.ProjectModel",
-                "NuGet.Versioning",
             }.ToImmutableHashSet();
 
         internal static readonly string[] Extensions = new[] { "ni.dll", "ni.exe", "dll", "exe" };
diff --git a/src/Shared/MSBuildNameIgnoreCaseComparer.cs b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
index e5f0f0ad199..d0930cc0e19 100644
--- a/src/Shared/MSBuildNameIgnoreCaseComparer.cs
+++ b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
@@ -149,7 +149,14 @@ public int GetHashCode(string obj, int start, int length)
                             // the string, and not the null terminator etc.
                             if (length == 1)
                             {
-                                val &= 0xFFFF;
+                                if (BitConverter.IsLittleEndian)
+                                {
+                                    val &= 0xFFFF;
+                                }
+                                else
+                                {
+                                    val &= unchecked((int)0xFFFF0000);
+                                }
                             }
 
                             hash1 = ((hash1 << 5) + hash1 + (hash1 >> 27)) ^ val;
@@ -162,7 +169,14 @@ public int GetHashCode(string obj, int start, int length)
                             val = pint[1] & 0x00DF00DF;
                             if (length == 3)
                             {
-                                val &= 0xFFFF;
+                                if (BitConverter.IsLittleEndian)
+                                {
+                                    val &= 0xFFFF;
+                                }
+                                else
+                                {
+                                    val &= unchecked((int)0xFFFF0000);
+                                }
                             }
 
                             hash2 = ((hash2 << 5) + hash2 + (hash2 >> 27)) ^ val;
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 4818d7eda9c..42e8a3ead07 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -465,10 +465,8 @@ public SystemInformationData()
                                 string arch = null;
                                 if (proc != null)
                                 {
-                                    // Since uname -m simply returns kernel property, it should be quick.
-                                    // 1 second is the best guess for a safe timeout.
-                                    proc.WaitForExit(1000);
                                     arch = proc.StandardOutput.ReadLine();
+                                    proc.WaitForExit();
                                 }
 
                                 if (!string.IsNullOrEmpty(arch))
diff --git a/src/Shared/NodePacketFactory.cs b/src/Shared/NodePacketFactory.cs
index 25d4851fc82..17b3e52c8f7 100644
--- a/src/Shared/NodePacketFactory.cs
+++ b/src/Shared/NodePacketFactory.cs
@@ -48,12 +48,11 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
         {
             // PERF: Not using VerifyThrow to avoid boxing of packetType in the non-error case
-            if (!_packetFactories.ContainsKey(packetType))
+            if (!_packetFactories.TryGetValue(packetType, out PacketFactoryRecord record))
             {
                 ErrorUtilities.ThrowInternalError("No packet handler for type {0}", packetType);
             }
 
-            PacketFactoryRecord record = _packetFactories[packetType];
             record.DeserializeAndRoutePacket(nodeId, translator);
         }
 
diff --git a/src/Utilities/ProcessExtensions.cs b/src/Shared/ProcessExtensions.cs
similarity index 78%
rename from src/Utilities/ProcessExtensions.cs
rename to src/Shared/ProcessExtensions.cs
index 04d6afb3f36..9504440d124 100644
--- a/src/Utilities/ProcessExtensions.cs
+++ b/src/Shared/ProcessExtensions.cs
@@ -7,7 +7,7 @@
 using System.IO;
 using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.Utilities
+namespace Microsoft.Build.Shared
 {
     internal static class ProcessExtensions
     {
@@ -46,12 +46,12 @@ public static void KillTree(this Process process, int timeout)
 
         private static void GetAllChildIdsUnix(int parentId, ISet<int> children)
         {
-            var exitCode = RunProcessAndWaitForExit(
+            RunProcessAndWaitForExit(
                 "pgrep",
                 $"-P {parentId}",
                 out string stdout);
 
-            if (exitCode == 0 && !string.IsNullOrEmpty(stdout))
+            if (!string.IsNullOrEmpty(stdout))
             {
                 using (var reader = new StringReader(stdout))
                 {
@@ -77,13 +77,24 @@ private static void GetAllChildIdsUnix(int parentId, ISet<int> children)
 
         private static void KillProcessUnix(int processId)
         {
-            RunProcessAndWaitForExit(
-                "kill",
-                $"-TERM {processId}",
-                out string _);
+            try
+            {
+                using Process process = Process.GetProcessById(processId);
+                process.Kill();
+            }
+            catch (ArgumentException)
+            {
+                // Process already terminated.
+                return;
+            }
+            catch (InvalidOperationException)
+            {
+                // Process already terminated.
+                return;
+            }
         }
 
-        private static int RunProcessAndWaitForExit(string fileName, string arguments, out string stdout)
+        private static void RunProcessAndWaitForExit(string fileName, string arguments, out string stdout)
         {
             var startInfo = new ProcessStartInfo
             {
@@ -94,22 +105,8 @@ private static int RunProcessAndWaitForExit(string fileName, string arguments, o
             };
 
             var process = Process.Start(startInfo);
-
-            stdout = null;
-            if (process.WaitForExit((int) TimeSpan.FromSeconds(30).TotalMilliseconds))
-            {
-                stdout = process.StandardOutput.ReadToEnd();
-            }
-            else
-            {
-                process.Kill();
-                
-                // Kill is asynchronous so we should still wait a little
-                //
-                process.WaitForExit((int) TimeSpan.FromSeconds(1).TotalMilliseconds);
-            }
-
-            return process.HasExited ? process.ExitCode : -1;
+            stdout = process.StandardOutput.ReadToEnd();
+            process.WaitForExit();
         }
     }
 }
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 45d007d25b3..1bcae1d7574 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -85,6 +85,10 @@ internal class TaskHostConfiguration : INodePacket
 
         private Dictionary<string, string> _globalParameters;
 
+        private ICollection<string> _warningsAsErrors;
+
+        private ICollection<string> _warningsAsMessages;
+
 #if FEATURE_APPDOMAIN
         /// <summary>
         /// Constructor
@@ -103,6 +107,8 @@ internal class TaskHostConfiguration : INodePacket
         /// <param name="taskLocation">Location of the assembly the task is to be loaded from.</param>
         /// <param name="taskParameters">Parameters to apply to the task.</param>
         /// <param name="globalParameters">global properties for the current project.</param>
+        /// <param name="warningsAsErrors">Warning codes to be treated as errors for the current project.</param>
+        /// <param name="warningsAsMessages">Warning codes to be treated as messages for the current project.</param>
 #else
         /// <summary>
         /// Constructor
@@ -120,6 +126,8 @@ internal class TaskHostConfiguration : INodePacket
         /// <param name="taskLocation">Location of the assembly the task is to be loaded from.</param>
         /// <param name="taskParameters">Parameters to apply to the task.</param>
         /// <param name="globalParameters">global properties for the current project.</param>
+        /// <param name="warningsAsErrors">Warning codes to be logged as errors for the current project.</param>
+        /// <param name="warningsAsMessages">Warning codes to be treated as messages for the current project.</param>
 #endif
         public TaskHostConfiguration
             (
@@ -138,7 +146,9 @@ public TaskHostConfiguration
                 string taskName,
                 string taskLocation,
                 IDictionary<string, object> taskParameters,
-                Dictionary<string, string> globalParameters
+                Dictionary<string, string> globalParameters,
+                ICollection<string> warningsAsErrors,
+                ICollection<string> warningsAsMessages
             )
         {
             ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
@@ -168,6 +178,8 @@ Dictionary<string, string> globalParameters
             _continueOnError = continueOnError;
             _taskName = taskName;
             _taskLocation = taskLocation;
+            _warningsAsErrors = warningsAsErrors;
+            _warningsAsMessages = warningsAsMessages;
 
             if (taskParameters != null)
             {
@@ -342,6 +354,24 @@ public NodePacketType Type
             { return NodePacketType.TaskHostConfiguration; }
         }
 
+        public ICollection<string> WarningsAsErrors
+        {
+            [DebuggerStepThrough]
+            get
+            {
+                return _warningsAsErrors;
+            }
+        }
+
+        public ICollection<string> WarningsAsMessages
+        {
+            [DebuggerStepThrough]
+            get
+            {
+                return _warningsAsMessages;
+            }
+        }
+
         /// <summary>
         /// Translates the packet to/from binary form.
         /// </summary>
@@ -364,6 +394,20 @@ public void Translate(ITranslator translator)
             translator.TranslateDictionary(ref _taskParameters, StringComparer.OrdinalIgnoreCase, TaskParameter.FactoryForDeserialization);
             translator.Translate(ref _continueOnError);
             translator.TranslateDictionary(ref _globalParameters, StringComparer.OrdinalIgnoreCase);
+            translator.Translate(collection: ref _warningsAsErrors,
+                                 objectTranslator: (ITranslator t, ref string s) => t.Translate(ref s),
+#if CLR2COMPATIBILITY
+                                 collectionFactory: count => new HashSet<string>(StringComparer.OrdinalIgnoreCase));
+#else
+                                 collectionFactory: count => new HashSet<string>(count, StringComparer.OrdinalIgnoreCase));
+#endif
+            translator.Translate(collection: ref _warningsAsMessages,
+                                 objectTranslator: (ITranslator t, ref string s) => t.Translate(ref s),
+#if CLR2COMPATIBILITY
+                                 collectionFactory: count => new HashSet<string>(StringComparer.OrdinalIgnoreCase));
+#else
+                                 collectionFactory: count => new HashSet<string>(count, StringComparer.OrdinalIgnoreCase));
+#endif
         }
 
         /// <summary>
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 7592c784fc0..a4f4a164193 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -1016,6 +1016,28 @@ params object[] messageArgs
             // that gives the user something.
             bool fillInLocation = (String.IsNullOrEmpty(file) && (lineNumber == 0) && (columnNumber == 0));
 
+            // This warning will be converted to an error if:
+            // 1. Its code exists within WarningsAsErrors
+            // 2. If WarningsAsErrors is a non-null empty set (treat all warnings as errors)
+            if (BuildEngine is IBuildEngine8 be8 && be8.ShouldTreatWarningAsError(warningCode))
+            {
+                LogError
+                (
+                    subcategory: subcategory,
+                    errorCode: warningCode,
+                    helpKeyword: helpKeyword,
+                    helpLink: helpLink,
+                    file: fillInLocation ? BuildEngine.ProjectFileOfTaskNode : file,
+                    lineNumber: fillInLocation ? BuildEngine.LineNumberOfTaskNode : lineNumber,
+                    columnNumber: fillInLocation ? BuildEngine.ColumnNumberOfTaskNode : columnNumber,
+                    endLineNumber: endLineNumber,
+                    endColumnNumber: endColumnNumber,
+                    message: message,
+                    messageArgs: messageArgs
+                );
+                return;
+            }
+
             var e = new BuildWarningEventArgs
                 (
                     subcategory,
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index ead8151a85b..17cc1269cca 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -1,14 +1,15 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Linq;
+using System.Reflection;
 using System.Security;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Reflection;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -492,7 +493,11 @@ private class TaskParameterTaskItem :
 #if FEATURE_APPDOMAIN
             MarshalByRefObject,
 #endif
-            ITaskItem, ITaskItem2
+            ITaskItem,
+            ITaskItem2
+#if !TASKHOST
+            ,IMetadataContainer
+#endif
         {
             /// <summary>
             /// The item spec 
@@ -751,6 +756,20 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
                 IDictionary clonedDictionary = new Dictionary<string, string>(_customEscapedMetadata);
                 return clonedDictionary;
             }
+
+            public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
+            {
+                if (_customEscapedMetadata == null)
+                {
+                    yield break;
+                }
+
+                foreach (var kvp in _customEscapedMetadata)
+                {
+                    var unescaped = new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.UnescapeAll(kvp.Value));
+                    yield return unescaped;
+                }
+            }
         }
     }
 }
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 7453ed33cb3..feb3acb6a5c 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -3,17 +3,13 @@
 
 using System;
 using System.Collections.Generic;
-#if FEATURE_SYSTEM_CONFIGURATION
 using System.Configuration;
-#endif
 using System.IO;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
 {
-#if FEATURE_SYSTEM_CONFIGURATION
-
     /// <summary>
     /// Helper class for reading toolsets out of the configuration file.
     /// </summary>
@@ -708,5 +704,4 @@ public string DefaultOverrideToolsVersion
             }
         }
     }
-#endif
 }
diff --git a/src/Shared/TranslatorHelpers.cs b/src/Shared/TranslatorHelpers.cs
index 130ad05d9cd..9cab3485c97 100644
--- a/src/Shared/TranslatorHelpers.cs
+++ b/src/Shared/TranslatorHelpers.cs
@@ -1,7 +1,12 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
+using System.Configuration.Assemblies;
+using System.Globalization;
+using System.Reflection;
+using AssemblyHashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -40,12 +45,12 @@ public static void Translate<T>(
 
         static ObjectTranslator<T> AdaptFactory<T>(NodePacketValueFactory<T> valueFactory) where T : ITranslatable
         {
-            void Translate(ITranslator translator, ref T objectToTranslate)
+            void TranslateUsingValueFactory(ITranslator translator, ref T objectToTranslate)
             {
-                TranslatorHelpers.Translate<T>(translator, ref objectToTranslate, valueFactory);
+                translator.Translate(ref objectToTranslate, valueFactory);
             }
 
-            return Translate;
+            return TranslateUsingValueFactory;
         }
 
         public static void Translate<T>(
@@ -102,5 +107,168 @@ public static void TranslateDictionary<D, T>(
         {
             translator.TranslateDictionary(ref dictionary, AdaptFactory(valueFactory), collectionCreator);
         }
+
+        public static void TranslateHashSet<T>(
+            this ITranslator translator,
+            ref HashSet<T> hashSet,
+            NodePacketValueFactory<T> valueFactory,
+            NodePacketCollectionCreator<HashSet<T>> collectionFactory) where T : class, ITranslatable
+        {
+            if (!translator.TranslateNullable(hashSet))
+                return;
+
+            int count = default;
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                count = hashSet.Count;
+            }
+            translator.Translate(ref count);
+
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                hashSet = collectionFactory(count);
+                for (int i = 0; i < count; i++)
+                {
+                    T value = default;
+                    translator.Translate(ref value, valueFactory);
+                    hashSet.Add(value);
+                }
+            }
+
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                foreach (T item in hashSet)
+                {
+                    T value = item;
+                    translator.Translate(ref value, valueFactory);
+                }
+            }
+        }
+
+        public static void Translate(this ITranslator translator, ref CultureInfo cultureInfo)
+        {
+            if (!translator.TranslateNullable(cultureInfo))
+                return;
+
+            int lcid = default;
+
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                lcid = cultureInfo.LCID;
+            }
+
+            translator.Translate(ref lcid);
+
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                cultureInfo = new CultureInfo(lcid);
+            }
+        }
+
+        public static void Translate(this ITranslator translator, ref Version version)
+        {
+            if (!translator.TranslateNullable(version))
+                return;
+
+            int major = 0;
+            int minor = 0;
+            int build = 0;
+            int revision = 0;
+
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                major = version.Major;
+                minor = version.Minor;
+                build = version.Build;
+                revision = version.Revision;
+            }
+
+            translator.Translate(ref major);
+            translator.Translate(ref minor);
+            translator.Translate(ref build);
+            translator.Translate(ref revision);
+
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                if (build < 0)
+                {
+                    version = new Version(major, minor);
+                }
+                else if (revision < 0)
+                {
+                    version = new Version(major, minor, build);
+                }
+                else
+                {
+                    version = new Version(major, minor, build, revision);
+                }
+            }
+        }
+
+        public static void Translate(this ITranslator translator, ref AssemblyName assemblyName)
+        {
+            if (!translator.TranslateNullable(assemblyName))
+                return;
+
+            string name = null;
+            Version version = null;
+            AssemblyNameFlags flags = default;
+            ProcessorArchitecture processorArchitecture = default;
+            CultureInfo cultureInfo = null;
+            AssemblyHashAlgorithm hashAlgorithm = default;
+            AssemblyVersionCompatibility versionCompatibility = default;
+            string codeBase = null;
+
+            byte[] publicKey = null;
+            byte[] publicKeyToken = null;
+
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                name = assemblyName.Name;
+                version = assemblyName.Version;
+                flags = assemblyName.Flags;
+                processorArchitecture = assemblyName.ProcessorArchitecture;
+                cultureInfo = assemblyName.CultureInfo;
+                hashAlgorithm = assemblyName.HashAlgorithm;
+                versionCompatibility = assemblyName.VersionCompatibility;
+                codeBase = assemblyName.CodeBase;
+
+                publicKey = assemblyName.GetPublicKey(); // TODO: no need to serialize, public key is not used anywhere in context of RAR, only public key token
+                publicKeyToken = assemblyName.GetPublicKeyToken();
+            }
+
+            translator.Translate(ref name);
+            translator.Translate(ref version);
+            translator.TranslateEnum(ref flags, (int)flags);
+            translator.TranslateEnum(ref processorArchitecture, (int)processorArchitecture);
+            translator.Translate(ref cultureInfo);
+            translator.TranslateEnum(ref hashAlgorithm, (int)hashAlgorithm);
+            translator.TranslateEnum(ref versionCompatibility, (int)versionCompatibility);
+            translator.Translate(ref codeBase);
+
+            translator.Translate(ref publicKey);
+            translator.Translate(ref publicKeyToken);
+
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                assemblyName = new AssemblyName
+                {
+                    Name = name,
+                    Version = version,
+                    Flags = flags,
+                    ProcessorArchitecture = processorArchitecture,
+                    CultureInfo = cultureInfo,
+                    HashAlgorithm = hashAlgorithm,
+                    VersionCompatibility = versionCompatibility,
+                    CodeBase = codeBase,
+                    // AssemblyName.KeyPair is not used anywhere, additionally StrongNameKeyPair is not supported in .net core 5-
+                    // and throws platform not supported exception when serialized or deserialized
+                    KeyPair = null,
+                };
+
+                assemblyName.SetPublicKey(publicKey);
+                assemblyName.SetPublicKeyToken(publicKeyToken);
+            }
+        }
     }
 }
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index 2c804fa0320..120adbb9ed4 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -8,6 +8,7 @@
 using System.Linq;
 using System.Reflection;
 using System.Runtime.Serialization.Formatters.Binary;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
@@ -740,9 +741,55 @@ public void VerifyAssemblyNameExSerializationWithRemappedFrom()
             assemblyNameDeserialized.RemappedFromEnumerator.Count().ShouldBe(1);
             assemblyNameDeserialized.RemappedFromEnumerator.First().ShouldBe(assemblyRemappedFrom);
         }
-    }
-}
 
+        [Theory]
+        [InlineData("System.Xml")]
+        [InlineData("System.XML, Version=2.0.0.0")]
+        [InlineData("System.Xml, Culture=de-DE")]
+        [InlineData("System.Xml, Version=10.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a, Retargetable=Yes")]
+        [InlineData("System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
+        public void VerifyAssemblyNameExSerializationByTranslator(string assemblyName)
+        {
+            AssemblyNameExtension assemblyNameOriginal = new AssemblyNameExtension(assemblyName);
+            AssemblyNameExtension assemblyNameDeserialized = null;
+
+            MemoryStream serializationStream = new MemoryStream();
+            ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(serializationStream);
+
+            writeTranslator.Translate(ref assemblyNameOriginal, (ITranslator t) => new AssemblyNameExtension(t));
+
+            serializationStream.Seek(0, SeekOrigin.Begin);
+            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, null);
+
+            readTranslator.Translate(ref assemblyNameDeserialized, (ITranslator t) => new AssemblyNameExtension(t));
+
+            assemblyNameDeserialized.ShouldBe(assemblyNameOriginal);
+        }
+
+        [Fact]
+        public void VerifyAssemblyNameExSerializationWithRemappedFromByTranslator()
+        {
+            AssemblyNameExtension assemblyNameOriginal = new AssemblyNameExtension("System.Xml, Version=10.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
+            AssemblyNameExtension assemblyRemappedFrom = new AssemblyNameExtension("System.Xml, Version=9.0.0.0, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
+            assemblyRemappedFrom.MarkImmutable();
+            assemblyNameOriginal.AddRemappedAssemblyName(assemblyRemappedFrom);
+            assemblyNameOriginal.RemappedFromEnumerator.Count().ShouldBe(1);
+
+            AssemblyNameExtension assemblyNameDeserialized = null;
 
+            MemoryStream serializationStream = new MemoryStream();
+            ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(serializationStream);
 
+            writeTranslator.Translate(ref assemblyNameOriginal, (ITranslator t) => new AssemblyNameExtension(t));
 
+            serializationStream.Seek(0, SeekOrigin.Begin);
+            ITranslator readTranslator = BinaryTranslator.GetReadTranslator(serializationStream, null);
+
+            readTranslator.Translate(ref assemblyNameDeserialized, (ITranslator t) => new AssemblyNameExtension(t));
+
+            assemblyNameDeserialized.Equals(assemblyNameOriginal).ShouldBeTrue();
+            assemblyNameDeserialized.RemappedFromEnumerator.Count().ShouldBe(1);
+            assemblyNameDeserialized.RemappedFromEnumerator.First().ShouldBe(assemblyRemappedFrom);
+        }
+    }
+}
diff --git a/src/Shared/UnitTests/EscapingUtilities_Tests.cs b/src/Shared/UnitTests/EscapingUtilities_Tests.cs
index 627de15dff6..b02c378e2eb 100644
--- a/src/Shared/UnitTests/EscapingUtilities_Tests.cs
+++ b/src/Shared/UnitTests/EscapingUtilities_Tests.cs
@@ -75,13 +75,18 @@ public void EscapeUnescape()
         public void ContainsEscapedWildcards()
         {
             Assert.False(EscapingUtilities.ContainsEscapedWildcards("NoStarOrQMark"));
+            Assert.False(EscapingUtilities.ContainsEscapedWildcards("%"));
+            Assert.False(EscapingUtilities.ContainsEscapedWildcards("%%"));
+            Assert.False(EscapingUtilities.ContainsEscapedWildcards("%2"));
             Assert.False(EscapingUtilities.ContainsEscapedWildcards("%4"));
-            Assert.False(EscapingUtilities.ContainsEscapedWildcards("%3B"));
+            Assert.False(EscapingUtilities.ContainsEscapedWildcards("%3A"));
             Assert.False(EscapingUtilities.ContainsEscapedWildcards("%2B"));
             Assert.True(EscapingUtilities.ContainsEscapedWildcards("%2a"));
             Assert.True(EscapingUtilities.ContainsEscapedWildcards("%2A"));
             Assert.True(EscapingUtilities.ContainsEscapedWildcards("%3F"));
             Assert.True(EscapingUtilities.ContainsEscapedWildcards("%3f"));
+            Assert.True(EscapingUtilities.ContainsEscapedWildcards("%%3f"));
+            Assert.True(EscapingUtilities.ContainsEscapedWildcards("%3%3f"));
         }
     }
 }
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index 418a51b91db..c3d200829e3 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -5,7 +5,7 @@
 using Shouldly;
 using System;
 using System.Collections.Generic;
-using System.Collections.Immutable;
+using System.Collections.Concurrent;
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
@@ -78,9 +78,9 @@ public void GetFilesComplexGlobbingMatching(GetFilesComplexGlobbingMatchingInfo
                 File.WriteAllBytes(fullPath, new byte[1]);
             }
 
-            void Verify(string include, string[] excludes, bool shouldHaveNoMatches = false, string customMessage = null)
+            void VerifyImpl(FileMatcher fileMatcher, string include, string[] excludes, bool shouldHaveNoMatches = false, string customMessage = null)
             {
-                string[] matchedFiles = FileMatcher.Default.GetFiles(testFolder.Path, include, excludes?.ToList());
+                string[] matchedFiles = fileMatcher.GetFiles(testFolder.Path, include, excludes?.ToList());
 
                 if (shouldHaveNoMatches)
                 {
@@ -100,6 +100,18 @@ void Verify(string include, string[] excludes, bool shouldHaveNoMatches = false,
                 }
             }
 
+            var fileMatcherWithCache = new FileMatcher(FileSystems.Default, new ConcurrentDictionary<string, IReadOnlyList<string>>());
+
+            void Verify(string include, string[] excludes, bool shouldHaveNoMatches = false, string customMessage = null)
+            {
+                // Verify using the default non-caching FileMatcher.
+                VerifyImpl(FileMatcher.Default, include, excludes, shouldHaveNoMatches, customMessage);
+
+                // Verify using a caching FileMatcher and do it twice to exercise the cache.
+                VerifyImpl(fileMatcherWithCache, include, excludes, shouldHaveNoMatches, customMessage);
+                VerifyImpl(fileMatcherWithCache, include, excludes, shouldHaveNoMatches, customMessage);
+            }
+
             // Normal matching
             Verify(info.Include, info.Excludes);
 
@@ -154,7 +166,7 @@ public class GetFilesComplexGlobbingMatchingInfo
                 @"subdirectory\subdirectory.cs",
                 @"build\baz\foo.cs",
                 @"readme.txt",
-                @"licence.md"
+                @"licence"
             };
 
             /// <summary>
@@ -356,7 +368,7 @@ public static IEnumerable<object[]> GetTestData()
                         ExpectedMatches = new[]
                         {
                             @"readme.txt",
-                            @"licence.md"
+                            @"licence"
                         }
                     }
                 };
@@ -409,6 +421,44 @@ public static IEnumerable<object[]> GetTestData()
                         ExpectNoMatches = NativeMethodsShared.IsLinux,
                     }
                 };
+
+                // Hits the early elimination of exclude file patterns that do not intersect with the include.
+                // The exclude is redundant and can be eliminated before starting the file system walk.
+                yield return new object[]
+                {
+                    new GetFilesComplexGlobbingMatchingInfo
+                    {
+                        Include = @"src\foo\**\*.cs",
+                        Excludes = new[]
+                        {
+                            @"src\foo\**\foo\**",
+                            @"src\foo\**\*.vb" // redundant exclude
+                        },
+                        ExpectedMatches = new[]
+                        {
+                            @"src\foo\foo.cs",
+                            @"src\foo\inner\foo.cs",
+                            @"src\foo\inner\bar\bar.cs"
+                        },
+                        ExpectNoMatches = NativeMethodsShared.IsLinux,
+                    }
+                };
+
+                // Hits the early elimination of exclude file patterns that do not intersect with the include.
+                // The exclude is not redundant and must not be eliminated.
+                yield return new object[]
+                {
+                    new GetFilesComplexGlobbingMatchingInfo
+                    {
+                        Include = @"src\foo\**\*.cs",
+                        Excludes = new[]
+                        {
+                            @"src\foo\**\*.*" // effective exclude
+                        },
+                        ExpectedMatches = Array.Empty<string>(),
+                        ExpectNoMatches = NativeMethodsShared.IsLinux,
+                    }
+                };
             }
         }
 
@@ -486,10 +536,9 @@ public void WildcardMatching()
             {
                 try
                 {
-                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1, input.Item2, false));
-                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1, input.Item2, true));
-                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1.ToUpperInvariant(), input.Item2, true));
-                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1, input.Item2.ToUpperInvariant(), true));
+                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1, input.Item2));
+                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1.ToUpperInvariant(), input.Item2));
+                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1, input.Item2.ToUpperInvariant()));
                 }
                 catch (Exception)
                 {
@@ -505,7 +554,7 @@ public void WildcardMatching()
          * Simulate Directories.GetFileSystemEntries where file names are short.
          *
          */
-        private static ImmutableArray<string> GetFileSystemEntries(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
+        private static IReadOnlyList<string> GetFileSystemEntries(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
         {
             if
             (
@@ -513,7 +562,7 @@ private static ImmutableArray<string> GetFileSystemEntries(FileMatcher.FileSyste
                 && (@"D:\" == path || @"\\server\share\" == path || path.Length == 0)
             )
             {
-                return ImmutableArray.Create(Path.Combine(path, "LongDirectoryName"));
+                return new string[] { Path.Combine(path, "LongDirectoryName") };
             }
             else if
             (
@@ -521,7 +570,7 @@ private static ImmutableArray<string> GetFileSystemEntries(FileMatcher.FileSyste
                 && (@"D:\LongDirectoryName" == path || @"\\server\share\LongDirectoryName" == path || @"LongDirectoryName" == path)
             )
             {
-                return ImmutableArray.Create(Path.Combine(path, "LongSubDirectory"));
+                return new string[] { Path.Combine(path, "LongSubDirectory") };
             }
             else if
             (
@@ -529,7 +578,7 @@ private static ImmutableArray<string> GetFileSystemEntries(FileMatcher.FileSyste
                 && (@"D:\LongDirectoryName\LongSubDirectory" == path || @"\\server\share\LongDirectoryName\LongSubDirectory" == path || @"LongDirectoryName\LongSubDirectory" == path)
             )
             {
-                return ImmutableArray.Create(Path.Combine(path, "LongFileName.txt"));
+                return new string[] { Path.Combine(path, "LongFileName.txt") };
             }
             else if
             (
@@ -537,7 +586,7 @@ private static ImmutableArray<string> GetFileSystemEntries(FileMatcher.FileSyste
                 && @"c:\apple\banana\tomato" == path
             )
             {
-                return ImmutableArray.Create(Path.Combine(path, "pomegranate"));
+                return new string[] { Path.Combine(path, "pomegranate") };
             }
             else if
             (
@@ -545,14 +594,14 @@ private static ImmutableArray<string> GetFileSystemEntries(FileMatcher.FileSyste
             )
             {
                 // No files exist here. This is an empty directory.
-                return ImmutableArray<string>.Empty;
+                return Array.Empty<string>();
             }
             else
             {
                 Console.WriteLine("GetFileSystemEntries('{0}', '{1}')", path, pattern);
                 Assert.True(false, "Unexpected input into GetFileSystemEntries");
             }
-            return ImmutableArray.Create("<undefined>");
+            return new string[] { "<undefined>" };
         }
 
         private static readonly char S = Path.DirectorySeparatorChar;
@@ -1588,7 +1637,7 @@ public void ExcludeComplexPattern(string include, string[] exclude, string[] mat
             "",
             "",
             "",
-            null,
+            "",
             false,
             false
         )]
@@ -1598,7 +1647,7 @@ public void ExcludeComplexPattern(string include, string[] exclude, string[] mat
             "",
             "",
             "",
-            null,
+            "",
             false,
             false
         )]
@@ -1839,10 +1888,13 @@ bool expectedIsLegalFileSpec
                 out string fixedDirectoryPart,
                 out string wildcardDirectoryPart,
                 out string filenamePart,
-                out string matchFileExpression,
                 out bool needsRecursion,
                 out bool isLegalFileSpec
             );
+            string matchFileExpression = isLegalFileSpec
+                ? FileMatcher.RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart)
+                : string.Empty;
+
             fixedDirectoryPart.ShouldBe(expectedFixedDirectoryPart);
             wildcardDirectoryPart.ShouldBe(expectedWildcardDirectoryPart);
             filenamePart.ShouldBe(expectedFilenamePart);
@@ -2081,7 +2133,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
             /// <param name="path">The path to search.</param>
             /// <param name="pattern">The pattern to search (may be null)</param>
             /// <returns>The matched files or folders.</returns>
-            internal ImmutableArray<string> GetAccessibleFileSystemEntries(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
+            internal IReadOnlyList<string> GetAccessibleFileSystemEntries(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
             {
                 string normalizedPath = Normalize(path);
 
@@ -2100,7 +2152,7 @@ internal ImmutableArray<string> GetAccessibleFileSystemEntries(FileMatcher.FileS
                     GetMatchingDirectories(_fileSet3, normalizedPath, pattern, files);
                 }
 
-                return files.ToImmutableArray();
+                return files.ToList();
             }
 
             /// <summary>
@@ -2353,9 +2405,9 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
         /// <param name="path"></param>
         /// <param name="pattern"></param>
         /// <returns>Array of matching file system entries (can be empty).</returns>
-        private static ImmutableArray<string> GetFileSystemEntriesLoopBack(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
+        private static IReadOnlyList<string> GetFileSystemEntriesLoopBack(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
         {
-            return ImmutableArray.Create(Path.Combine(path, pattern));
+            return new string[] { Path.Combine(path, pattern) };
         }
 
         /*************************************************************************************
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 5c721b50c7e..a9bdd429d16 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1944,12 +1944,17 @@ public BuildResult BuildProjectFile(
 
                 return buildResult;
             }
-			
-			public GraphBuildResult BuildGraphSubmission(GraphBuildRequestData requestData)
+
+            public GraphBuildResult BuildGraphSubmission(GraphBuildRequestData requestData)
             {
                 return _buildManager.BuildRequest(requestData);
             }
 
+            public GraphBuildResult BuildGraph(ProjectGraph graph, string[] entryTargets = null)
+            {
+                return _buildManager.BuildRequest(new GraphBuildRequestData(graph, entryTargets ?? new string[0]));
+            }
+
             public void Dispose()
             {
                 if (_disposed)
@@ -1962,11 +1967,6 @@ public void Dispose()
                 _buildManager.EndBuild();
                 _buildManager.Dispose();
             }
-
-            public GraphBuildResult BuildGraph(ProjectGraph graph, string[] entryTargets = null)
-            {
-                return _buildManager.BuildRequest(new GraphBuildRequestData(graph, entryTargets ?? new string[0]));
-            }
         }
 
         internal class LoggingFileSystem : MSBuildFileSystemBase
diff --git a/src/Shared/VersionUtilities.cs b/src/Shared/VersionUtilities.cs
index ab4a2a2ba5c..fe113266894 100644
--- a/src/Shared/VersionUtilities.cs
+++ b/src/Shared/VersionUtilities.cs
@@ -39,9 +39,8 @@ internal static SortedDictionary<Version, List<string>> GatherVersionStrings(Ver
 
                     if (candidateVersion != null && (targetPlatformVersion == null || (candidateVersion <= targetPlatformVersion)))
                     {
-                        if (versionValues.ContainsKey(candidateVersion))
+                        if (versionValues.TryGetValue(candidateVersion, out List<string> versionList))
                         {
-                            List<string> versionList = versionValues[candidateVersion];
                             if (!versionList.Contains(version))
                             {
                                 versionList.Add(version);
@@ -128,4 +127,4 @@ int IComparer<Version>.Compare(Version x, Version y)
             return y.CompareTo(x);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/StringTools/SpanBasedStringBuilder.cs b/src/StringTools/SpanBasedStringBuilder.cs
index 2d388641f85..8bb5a13cc09 100644
--- a/src/StringTools/SpanBasedStringBuilder.cs
+++ b/src/StringTools/SpanBasedStringBuilder.cs
@@ -188,6 +188,19 @@ public void Append(string value, int startIndex, int count)
             }
         }
 
+        /// <summary>
+        /// Appends a character span represented by <see cref="ReadOnlyMemory{T}" />.
+        /// </summary>
+        /// <param name="span">The character span to append.</param>
+        public void Append(ReadOnlyMemory<char> span)
+        {
+            if (!span.IsEmpty)
+            {
+                _spans.Add(span);
+                Length += span.Length;
+            }
+        }
+
         /// <summary>
         /// Removes leading white-space characters from the string.
         /// </summary>
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index 1bead8c7ed9..e7713cb359a 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -28,7 +28,7 @@
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
   </ItemGroup>
   <ItemGroup>
-    <PackageReference Include="jnm2.ReferenceAssemblies.net35" />
+    <PackageReference Include="jnm2.ReferenceAssemblies.net35" PrivateAssets="All" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFramework)' == 'net35'">
diff --git a/src/Tasks.UnitTests/AssemblyDependency/CacheFileSamples/Microsoft.VisualStudio.LanguageServices.Implementation.csprojAssemblyReference.cache b/src/Tasks.UnitTests/AssemblyDependency/CacheFileSamples/Microsoft.VisualStudio.LanguageServices.Implementation.csprojAssemblyReference.cache
new file mode 100644
index 00000000000..b9afa33ceb9
Binary files /dev/null and b/src/Tasks.UnitTests/AssemblyDependency/CacheFileSamples/Microsoft.VisualStudio.LanguageServices.Implementation.csprojAssemblyReference.cache differ
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
new file mode 100644
index 00000000000..77a9bf0452a
--- /dev/null
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceCacheSerialization.cs
@@ -0,0 +1,219 @@
+using System;
+using System.IO;
+using System.Reflection;
+using System.Runtime.Versioning;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Tasks;
+using Microsoft.Build.Utilities;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
+{
+    public class ResolveAssemblyReferenceCacheSerialization : IDisposable
+    {
+        // Maintain this two in sync with the constant in SystemState
+        private static readonly byte[] TranslateContractSignature = { (byte)'M', (byte)'B', (byte)'R', (byte)'S', (byte)'C' }; // Microsoft Build RAR State Cache
+        private static readonly byte TranslateContractVersion = 0x01;
+
+        private readonly string _rarCacheFile;
+        private readonly TaskLoggingHelper _taskLoggingHelper;
+
+        public ResolveAssemblyReferenceCacheSerialization()
+        {
+            var tempPath = Path.GetTempPath();
+            _rarCacheFile = Path.Combine(tempPath, Guid.NewGuid() + ".UnitTest.RarCache");
+            _taskLoggingHelper = new TaskLoggingHelper(new MockEngine(), "TaskA")
+            {
+                TaskResources = AssemblyResources.PrimaryResources
+            };
+        }
+
+        public void Dispose()
+        {
+            if (File.Exists(_rarCacheFile))
+            {
+                FileUtilities.DeleteNoThrow(_rarCacheFile);
+            }
+        }
+
+        [Fact]
+        public void RoundTripEmptyState()
+        {
+            SystemState systemState = new();
+
+            systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+
+            var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+
+            deserialized.ShouldNotBeNull();
+        }
+
+        [Fact]
+        public void WrongFileSignature()
+        {
+            SystemState systemState = new();
+
+            for (int i = 0; i < TranslateContractSignature.Length; i++)
+            {
+                systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+                using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
+                {
+                    cacheStream.Seek(i, SeekOrigin.Begin);
+                    cacheStream.WriteByte(0);
+                    cacheStream.Close();
+                }
+
+                var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+
+                deserialized.ShouldBeNull();
+            }
+        }
+
+        [Fact]
+        public void WrongFileVersion()
+        {
+            SystemState systemState = new();
+
+            systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
+            {
+                cacheStream.Seek(TranslateContractSignature.Length, SeekOrigin.Begin);
+                cacheStream.WriteByte((byte) (TranslateContractVersion + 1));
+                cacheStream.Close();
+            }
+
+            var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+
+            deserialized.ShouldBeNull();
+        }
+
+        [Fact]
+        public void CorrectFileSignature()
+        {
+            SystemState systemState = new();
+
+            for (int i = 0; i < TranslateContractSignature.Length; i++)
+            {
+                systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+                using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
+                {
+                    cacheStream.Seek(i, SeekOrigin.Begin);
+                    cacheStream.WriteByte(TranslateContractSignature[i]);
+                    cacheStream.Close();
+                }
+
+                var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+
+                deserialized.ShouldNotBeNull();
+            }
+        }
+
+        [Fact]
+        public void CorrectFileVersion()
+        {
+            SystemState systemState = new();
+
+            systemState.SerializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            using (var cacheStream = new FileStream(_rarCacheFile, FileMode.Open, FileAccess.ReadWrite))
+            {
+                cacheStream.Seek(TranslateContractSignature.Length, SeekOrigin.Begin);
+                cacheStream.WriteByte(TranslateContractVersion);
+                cacheStream.Close();
+            }
+
+            var deserialized = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+
+            deserialized.ShouldNotBeNull();
+        }
+
+        [Fact]
+        public void VerifySampleStateDeserialization()
+        {
+            // This test might also fail when binary format is modified.
+            // Any change in SystemState and child class ITranslatable implementation will most probably make this fail.
+            // To fix it, file referred by 'sampleName' needs to be recaptured and constant bellow modified to reflect
+            // the content of that cache.
+            // This sample was captured by compiling https://github.com/dotnet/roslyn/commit/f8107de2a94a01e96ac3d7c1f225acbb61e18830
+            const string sampleName = "Microsoft.VisualStudio.LanguageServices.Implementation.csprojAssemblyReference.cache";
+            const string expectedAssemblyPath = @"C:\Users\rokon\.nuget\packages\microsoft.visualstudio.codeanalysis.sdk.ui\15.8.27812-alpha\lib\net46\Microsoft.VisualStudio.CodeAnalysis.Sdk.UI.dll";
+            const long expectedAssemblyLastWriteTimeTicks = 636644382480000000;
+            const string expectedAssemblyName = "Microsoft.VisualStudio.CodeAnalysis.Sdk.UI, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
+            const string expectedFrameworkName = ".NETFramework,Version=v4.5";
+            var expectedDependencies = new[]
+            {
+                "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
+                "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
+                "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.CodeAnalysis, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.DeveloperTools, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
+                "Microsoft.VisualStudio.Shell.Interop, Version=7.1.40304.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "EnvDTE, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.CodeAnalysis.Sdk, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.Build.Framework, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.Text.Logic, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.Text.UI, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.Text.Data, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.Text.UI.Wpf, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.ComponentModelHost, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.VSHelp, Version=7.0.3300.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.Shell.Interop.11.0, Version=11.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.VCProjectEngine, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.Shell.15.0, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.OLE.Interop, Version=7.1.40304.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
+                "Microsoft.VisualStudio.TextManager.Interop, Version=7.1.40304.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "EnvDTE80, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
+                "Microsoft.VisualStudio.VirtualTreeGrid, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.Shell.Interop.8.0, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+                "Microsoft.VisualStudio.Editor, Version=15.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a",
+            };
+
+
+            CopyResourceSampleFileIntoRarCacheFile($@"AssemblyDependency\CacheFileSamples\{sampleName}");
+
+            var deserializedByTranslator = SystemState.DeserializeCacheByTranslator(_rarCacheFile, _taskLoggingHelper);
+            deserializedByTranslator.ShouldNotBeNull();
+
+            deserializedByTranslator.SetGetLastWriteTime(path =>
+            {
+                if (path != expectedAssemblyPath)
+                    throw new InvalidOperationException("Unexpected file name for this test case");
+
+                return new DateTime(expectedAssemblyLastWriteTimeTicks, DateTimeKind.Utc);
+            });
+
+            GetAssemblyName getAssemblyName = deserializedByTranslator.CacheDelegate((GetAssemblyName)null);
+            GetAssemblyMetadata getAssemblyMetadata = deserializedByTranslator.CacheDelegate((GetAssemblyMetadata)null);
+
+            var assemblyName = getAssemblyName(expectedAssemblyPath);
+            getAssemblyMetadata(expectedAssemblyPath, null,
+                out AssemblyNameExtension[] dependencies,
+                out string[] scatterFiles,
+                out FrameworkName frameworkNameAttribute);
+
+
+            assemblyName.ShouldNotBeNull();
+            assemblyName.ShouldBe(new AssemblyNameExtension(expectedAssemblyName, false));
+            scatterFiles.ShouldBeEmpty();
+            frameworkNameAttribute.ShouldBe(new FrameworkName(expectedFrameworkName));
+            dependencies.ShouldNotBeNull();
+            expectedDependencies.ShouldBe(expectedDependencies, ignoreOrder: true);
+        }
+
+        private void CopyResourceSampleFileIntoRarCacheFile(string name)
+        {
+            Assembly asm = this.GetType().Assembly;
+            var resource = string.Format($"{asm.GetName().Name}.{name.Replace("\\", ".")}");
+            using Stream resourceStream = asm.GetManifestResourceStream(resource);
+            if (resourceStream == null)
+                throw new InvalidOperationException($"Resource '{resource}' has not been found.");
+
+            using FileStream rarCacheFile = new FileStream(_rarCacheFile, FileMode.CreateNew);
+
+            resourceStream.CopyTo(rarCacheFile);
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs b/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
new file mode 100644
index 00000000000..bfb9dd55cb6
--- /dev/null
+++ b/src/Tasks.UnitTests/AssemblyDependency/TaskTranslatorHelpers.cs
@@ -0,0 +1,64 @@
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Runtime.Versioning;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Tasks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
+{
+    public class TaskTranslatorHelpers
+    {
+        MemoryStream _serializationStream;
+
+        [Fact]
+        public void NullFrameworkName()
+        {
+            FrameworkName value = null;
+
+            GetWriteTranslator().Translate(ref value);
+            GetReadTranslator().Translate(ref value);
+
+            value.ShouldBeNull();
+        }
+
+        [Theory]
+        [MemberData(nameof(SampleFrameworkNames))]
+        public void ValidFrameworkName(FrameworkName value)
+        {
+            FrameworkName deserialized = null;
+
+            GetWriteTranslator().Translate(ref value);
+            GetReadTranslator().Translate(ref deserialized);
+
+            deserialized.ShouldNotBeNull();
+            deserialized.ShouldBe(value);
+        }
+
+        public static IEnumerable<object[]> SampleFrameworkNames =>
+            new List<object[]>
+            {
+                new object[] { new FrameworkName("X, Version=3.4.5") },
+                new object[] { new FrameworkName("X, Version=3.4, Profile=Compact") },
+                new object[] { new FrameworkName("Y", new Version(1, 2, 3)) },
+                new object[] { new FrameworkName("Z", new Version(1, 2, 3), "P") },
+            };
+
+        private ITranslator GetReadTranslator()
+        {
+            if (_serializationStream == null)
+                throw new InvalidOperationException("GetWriteTranslator has to be called before GetReadTranslator");
+
+            _serializationStream.Seek(0, SeekOrigin.Begin);
+            return BinaryTranslator.GetReadTranslator(_serializationStream, null);
+        }
+
+        private ITranslator GetWriteTranslator()
+        {
+            _serializationStream = new MemoryStream();
+            return BinaryTranslator.GetWriteTranslator(_serializationStream);
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index edd0c80b6e4..6d48ace8c4b 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -2397,7 +2397,9 @@ public void CopyToDestinationFolderWithSymbolicLinkCheck()
 
             if (NativeMethodsShared.IsWindows)
             {
+#pragma warning disable CA1416 // Suppress Warning saying that WindowsPrincipal might not be compatible on Windows (Which shouldn't be an issue...)
                 if (!new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(new SecurityIdentifier(WellKnownSidType.BuiltinAdministratorsSid, null)))
+#pragma warning restore CA1416 // Suppress Warning saying that WindowsPrincipal might not be compatible on Windows (Which shouldn't be an issue...)
                 {
                     isPrivileged = false;
                     Assert.True(true, "It seems that you don't have the permission to create symbolic links. Try to run this test again with higher privileges");
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index df8ac22edce..3bc0657cab2 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -103,8 +103,8 @@ public void ExitCodeCausesFailure()
         [Fact]
         public void Timeout()
         {
-            // On non-Windows the exit code of a killed process is SIGTERM (143)
-            int expectedExitCode = NativeMethodsShared.IsWindows ? -1 : 143;
+            // On non-Windows the exit code of a killed process is SIGKILL (137)
+            int expectedExitCode = NativeMethodsShared.IsWindows ? -1 : 137;
 
             Exec exec = PrepareExec(NativeMethodsShared.IsWindows ? ":foo \n goto foo" : "while true; do sleep 1; done");
             exec.Timeout = 5;
@@ -122,7 +122,6 @@ public void Timeout()
         [Fact]
         public void TimeoutFailsEvenWhenExitCodeIsIgnored()
         {
-
             Exec exec = PrepareExec(NativeMethodsShared.IsWindows ? ":foo \n goto foo" : "while true; do sleep 1; done");
             exec.Timeout = 5;
             exec.IgnoreExitCode = true;
@@ -138,16 +137,13 @@ public void TimeoutFailsEvenWhenExitCodeIsIgnored()
 
             if (NativeMethodsShared.IsMono)
             {
-                // The standard check for SIGTERM fails intermittently on macOS Mono
-                // https://github.com/dotnet/msbuild/issues/5506
-                // To avoid test flakiness, allow 259 even though I can't justify it.
-                exec.ExitCode.ShouldBeOneOf(143, 259);
+                const int STILL_ACTIVE = 259; // When Process.WaitForExit times out.
+                exec.ExitCode.ShouldBeOneOf(137, STILL_ACTIVE);
             }
             else
             {
-                // On non-Windows the exit code of a killed process is generally 128 + SIGTERM = 143
-                // though this isn't 100% guaranteed, see https://unix.stackexchange.com/a/99134
-                exec.ExitCode.ShouldBe(NativeMethodsShared.IsWindows ? -1 : 143);
+                // On non-Windows the exit code of a killed process is 128 + SIGKILL = 137
+                exec.ExitCode.ShouldBe(NativeMethodsShared.IsWindows ? -1 : 137);
             }
         }
 
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index cd00af8329e..1c0521195bb 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -11,6 +11,10 @@
     <DefineConstants>$(DefineConstants);MICROSOFT_BUILD_TASKS_UNITTESTS</DefineConstants>
   </PropertyGroup>
 
+  <ItemGroup>
+    <None Remove="AssemblyDependency\CacheFileSamples\Microsoft.VisualStudio.LanguageServices.Implementation.csprojAssemblyReference.cache" />
+  </ItemGroup>
+
   <ItemGroup>
     <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="Shouldly" />
@@ -35,7 +39,6 @@
     <Reference Include="System.Xml.Linq" />
   </ItemGroup>
 
-
   <ItemGroup>
     <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
@@ -60,6 +63,7 @@
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
 
     <EmbeddedResource Include="SampleResx" />
+    <EmbeddedResource Include="AssemblyDependency\CacheFileSamples\Microsoft.VisualStudio.LanguageServices.Implementation.csprojAssemblyReference.cache" />
 
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
diff --git a/src/Tasks.UnitTests/OutputPathTests.cs b/src/Tasks.UnitTests/OutputPathTests.cs
index f2bc410bbbd..6b4da05750a 100644
--- a/src/Tasks.UnitTests/OutputPathTests.cs
+++ b/src/Tasks.UnitTests/OutputPathTests.cs
@@ -61,7 +61,7 @@ public void BothBaseOutputPathAndOutputPathWereNotSpecified()
             project.Build(new MockLogger(_output)).ShouldBeFalse();
 
             // Assert
-            project.GetPropertyValue("BaseOutputPath").ShouldBe(baseOutputPath.WithTrailingSlash());
+            project.GetPropertyValue("BaseOutputPath").ShouldBe(baseOutputPath + '\\');
             project.GetPropertyValue("BaseOutputPathWasSpecified").ShouldBe(string.Empty);
             project.GetPropertyValue("_OutputPathWasMissing").ShouldBe("true");
         }
diff --git a/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
new file mode 100644
index 00000000000..11c0a395500
--- /dev/null
+++ b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
@@ -0,0 +1,142 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+using Microsoft.Build.Framework;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.Utilities;
+using Shouldly;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Xunit;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    public class RARPrecomputedCache_Tests
+    {
+        [Fact]
+        public void TestPrecomputedCacheOutput()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile standardCache = env.CreateFile(".cache");
+                ResolveAssemblyReference t = new ResolveAssemblyReference()
+                {
+                    _cache = new SystemState()
+                };
+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {
+                    { Path.Combine(standardCache.Path, "assembly1"), new SystemState.FileState(DateTime.Now) },
+                    { Path.Combine(standardCache.Path, "assembly2"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension("hi") } } };
+                t._cache.IsDirty = true;
+                t.StateFile = standardCache.Path;
+                t.WriteStateFile();
+                int standardLen = File.ReadAllText(standardCache.Path).Length;
+                File.Delete(standardCache.Path);
+                standardLen.ShouldBeGreaterThan(0);
+
+                string precomputedPath = standardCache.Path + ".cache";
+                t._cache.IsDirty = true;
+                t.AssemblyInformationCacheOutputPath = precomputedPath;
+                t.WriteStateFile();
+                File.Exists(standardCache.Path).ShouldBeFalse();
+                int preLen = File.ReadAllText(precomputedPath).Length;
+                preLen.ShouldBeGreaterThan(0);
+                preLen.ShouldNotBe(standardLen);
+            }
+        }
+
+        [Fact]
+        public void StandardCacheTakesPrecedence()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile standardCache = env.CreateFile(".cache");
+                ResolveAssemblyReference rarWriterTask = new ResolveAssemblyReference()
+                {
+                    _cache = new SystemState()
+                };
+                rarWriterTask._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>();
+                rarWriterTask.StateFile = standardCache.Path;
+                rarWriterTask._cache.IsDirty = true;
+                // Write standard cache
+                rarWriterTask.WriteStateFile();
+
+                string dllName = Path.Combine(Path.GetDirectoryName(standardCache.Path), "randomFolder", "dll.dll");
+                rarWriterTask._cache.instanceLocalFileStateCache.Add(dllName,
+                    new SystemState.FileState(DateTime.Now)
+                    {
+                        Assembly = null,
+                        RuntimeVersion = "v4.0.30319",
+                        FrameworkNameAttribute = new System.Runtime.Versioning.FrameworkName(".NETFramework", Version.Parse("4.7.2"), "Profile"),
+                        scatterFiles = new string[] { "first", "second" }
+                    });
+                string precomputedCachePath = standardCache.Path + ".cache";
+                rarWriterTask.AssemblyInformationCacheOutputPath = precomputedCachePath;
+                rarWriterTask._cache.IsDirty = true;
+                // Write precomputed cache
+                rarWriterTask.WriteStateFile();
+
+                ResolveAssemblyReference rarReaderTask = new ResolveAssemblyReference();
+                rarReaderTask.StateFile = standardCache.Path;
+                rarReaderTask.AssemblyInformationCachePaths = new ITaskItem[]
+                {
+                    new TaskItem(precomputedCachePath)
+                };
+
+                // At this point, we should have created two cache files: one "normal" one and one "precomputed" one.
+                // When we read the state file, it should read from the caches produced in a normal build. In this case,
+                // the normal cache does not have dll.dll, whereas the precomputed cache does, so it should not be
+                // present when we read it.
+                rarReaderTask.ReadStateFile(p => true);
+                rarReaderTask._cache.instanceLocalFileStateCache.ShouldNotContainKey(dllName);
+            }
+        }
+
+        [Fact]
+        public void TestPreComputedCacheInputMatchesOutput()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile precomputedCache = env.CreateFile(".cache");
+                ResolveAssemblyReference rarWriterTask = new ResolveAssemblyReference()
+                {
+                    _cache = new SystemState()
+                };
+                string dllName = Path.Combine(Path.GetDirectoryName(precomputedCache.Path), "randomFolder", "dll.dll");
+                rarWriterTask._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {
+                    { Path.Combine(precomputedCache.Path, "..", "assembly1", "assembly1"), new SystemState.FileState(DateTime.Now) },
+                    { Path.Combine(precomputedCache.Path, "assembly2"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension("hi") } },
+                    { dllName, new SystemState.FileState(DateTime.Now) {
+                        Assembly = null,
+                        RuntimeVersion = "v4.0.30319",
+                        FrameworkNameAttribute = new System.Runtime.Versioning.FrameworkName(".NETFramework", Version.Parse("4.7.2"), "Profile"),
+                        scatterFiles = new string[] { "first", "second" } } } };
+
+                rarWriterTask.AssemblyInformationCacheOutputPath = precomputedCache.Path;
+                rarWriterTask._cache.IsDirty = true;
+
+                // Throws an exception because precomputedCache.Path already exists.
+                Should.Throw<InvalidOperationException>(() => rarWriterTask.WriteStateFile());
+                File.Delete(precomputedCache.Path);
+                rarWriterTask.WriteStateFile();
+
+                ResolveAssemblyReference rarReaderTask = new ResolveAssemblyReference();
+                rarReaderTask.StateFile = precomputedCache.Path.Substring(0, precomputedCache.Path.Length - 6); // Not a real path; should not be used.
+                rarReaderTask.AssemblyInformationCachePaths = new ITaskItem[]
+                {
+                    new TaskItem(precomputedCache.Path)
+                };
+
+                // At this point, the standard cache does not exist, so it defaults to reading the "precomputed" cache.
+                // Then we verify that the information contained in that cache matches what we'd expect.
+                rarReaderTask.ReadStateFile(p => true);
+                rarReaderTask._cache.instanceLocalFileStateCache.ShouldContainKey(dllName);
+                SystemState.FileState assembly3 = rarReaderTask._cache.instanceLocalFileStateCache[dllName];
+                assembly3.Assembly.ShouldBeNull();
+                assembly3.RuntimeVersion.ShouldBe("v4.0.30319");
+                assembly3.FrameworkNameAttribute.Version.ShouldBe(Version.Parse("4.7.2"));
+                assembly3.scatterFiles.Length.ShouldBe(2);
+                assembly3.scatterFiles[1].ShouldBe("second");
+            }
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index fa551927b4f..3c304324122 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -10,6 +10,7 @@
 using Xunit;
 using Xunit.Abstractions;
 using System.IO;
+using System.Threading;
 using Shouldly;
 
 namespace Microsoft.Build.UnitTests.GenerateResource_Tests.OutOfProc
@@ -1942,7 +1943,7 @@ public void StateFileUnwritable()
                 t.Execute();
 
                 // "cannot read state file (opening for read/write)"
-                Utilities.AssertLogContains(t, "MSB3088");
+                Utilities.AssertLogContainsResourceWithUnspecifiedReplacements(t, "General.CouldNotReadStateFileMessage");
                 // "cannot write state file (opening for read/write)"
                 Utilities.AssertLogContains(t, "MSB3101");
             }
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 2beea1736da..558b16bf131 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -15,6 +15,7 @@
 using Xunit;
 using Xunit.Abstractions;
 using System.Collections.Generic;
+using System.Text.RegularExpressions;
 
 namespace Microsoft.Build.UnitTests.GenerateResource_Tests.InProc
 {
@@ -2316,7 +2317,7 @@ public void StateFileUnwritable()
                 t.Execute();
 
                 // "cannot read state file (opening for read/write)"
-                Utilities.AssertLogContains(t, "MSB3088");
+                Utilities.AssertLogContainsResourceWithUnspecifiedReplacements(t, "General.CouldNotReadStateFileMessage");
                 // "cannot write state file (opening for read/write)"
                 Utilities.AssertLogContains(t, "MSB3101");
             }
@@ -3395,8 +3396,42 @@ public static void AssertLogContainsResource(GenerateResource t, string messageI
         {
             Assert.Contains(
                 String.Format(AssemblyResources.GetString(messageID), replacements),
-                ((MockEngine)t.BuildEngine).Log
-                );
+                ((MockEngine) t.BuildEngine).Log
+            );
+        }
+
+        /// <summary>
+        /// Looks for a formatted message in the output log for the task execution, with unknown formatted parameters.
+        /// If verifies that all constant segments of unformatted message are present.
+        /// </summary>
+        public static void AssertLogContainsResourceWithUnspecifiedReplacements(GenerateResource t, string messageID)
+        {
+            var unformattedMessage = AssemblyResources.GetString(messageID);
+            var matches = Regex.Matches(unformattedMessage, @"\{\d+.*?\}");
+            if (matches.Count > 0)
+            {
+                var sb = new StringBuilder();
+                int i = 0;
+
+                foreach (Match match in matches)
+                {
+                    string segment = unformattedMessage.Substring(i, match.Index - i);
+                    sb.Append(Regex.Escape(segment));
+                    sb.Append(".*");
+
+                    i = match.Index + match.Length;
+                }
+                if (i < unformattedMessage.Length)
+                {
+                    sb.Append(Regex.Escape(unformattedMessage.Substring(i)));
+                }
+
+                Assert.Matches(sb.ToString(), ((MockEngine)t.BuildEngine).Log);
+            }
+            else
+            {
+                Assert.Contains(unformattedMessage, ((MockEngine)t.BuildEngine).Log);
+            }
         }
 
         /// <summary>
diff --git a/src/Tasks.UnitTests/ResourceManagement_Tests.cs b/src/Tasks.UnitTests/ResourceManagement_Tests.cs
new file mode 100644
index 00000000000..d75cdd4e120
--- /dev/null
+++ b/src/Tasks.UnitTests/ResourceManagement_Tests.cs
@@ -0,0 +1,157 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.UnitTests;
+using System.Collections.Generic;
+using System.Linq;
+using Xunit;
+using Shouldly;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    public class ResourceManagement_Tests
+    {
+        [Fact]
+        public void SingleCoreRequest()
+        {
+            var messages = AssertBuildSucceededAndGetMessages(@"
+                {
+                    int grantedCores = BuildEngine9.RequestCores(1337);
+                    Log.LogMessage(""Number of cores acquired: "" + grantedCores);
+                    BuildEngine9.ReleaseCores(grantedCores);
+                }", "<UseCores />");
+
+            var filteredMessages = messages.Where(m => m.Message.StartsWith("Number of cores acquired: ")).ToArray();
+            filteredMessages.Count().ShouldBe(1);
+            GetTrailingIntegerFromMessage(filteredMessages[0]).ShouldBeGreaterThan(0);
+        }
+
+        [Fact]
+        public void SingleCoreRequestWithNoRelease()
+        {
+            var messages = AssertBuildSucceededAndGetMessages(@"
+                {
+                    int grantedCores = BuildEngine9.RequestCores(1337);
+                    Log.LogMessage(""Number of cores acquired: "" + grantedCores);
+                    // Note that we're missing a call to ReleaseCores() so we rely on cores being released after the task is finished.
+                }", "<UseCores /> <UseCores />");
+
+            var filteredMessages = messages.Where(m => m.Message.StartsWith("Number of cores acquired: ")).ToArray();
+            filteredMessages.Count().ShouldBe(2);
+
+            int grantedCores1 = GetTrailingIntegerFromMessage(filteredMessages[0]);
+            int grantedCores2 = GetTrailingIntegerFromMessage(filteredMessages[1]);
+
+            // Both tasks were able to get the same number of cores because cores were auto-released.
+            grantedCores1.ShouldBeGreaterThan(0);
+            grantedCores2.ShouldBe(grantedCores1);
+        }
+
+        [Fact]
+        public void SingleCoreRequestWithReacquire()
+        {
+            var messages = AssertBuildSucceededAndGetMessages(@"
+                {
+                    int grantedCores1 = BuildEngine9.RequestCores(1337);
+                    Log.LogMessage(""Number of cores acquired: "" + grantedCores1);
+
+                    BuildEngine9.Yield();
+                    // Reacquire releases all cores.
+                    BuildEngine9.Reacquire();
+
+                    int grantedCores2 = BuildEngine9.RequestCores(1337);
+                    Log.LogMessage(""Number of cores acquired: "" + grantedCores2);
+                }", "<UseCores />");
+
+            var filteredMessages = messages.Where(m => m.Message.StartsWith("Number of cores acquired: ")).ToArray();
+            filteredMessages.Count().ShouldBe(2);
+
+            int grantedCores1 = GetTrailingIntegerFromMessage(filteredMessages[0]);
+            int grantedCores2 = GetTrailingIntegerFromMessage(filteredMessages[1]);
+
+            // Both tasks were able to get the same number of cores because cores were auto-released.
+            grantedCores1.ShouldBeGreaterThan(0);
+            grantedCores2.ShouldBe(grantedCores1);
+        }
+
+        [Fact]
+        public void MultipleCoreRequests()
+        {
+            // Exercise concurrent RequestCores() and ReleaseCores() calls.
+            AssertBuildSucceededAndGetMessages(@"
+                {
+                    const int coresToAcquire = 1337;
+                    int acquiredCores = 0;
+                    int done = 0;
+                    System.Threading.Thread requestThread = new System.Threading.Thread(() =>
+                    {
+                        for (int i = 0; i &lt; coresToAcquire; i++)
+                        {
+                            BuildEngine9.RequestCores(1);
+                            System.Threading.Interlocked.Increment(ref acquiredCores);
+                        }
+                        System.Threading.Thread.VolatileWrite(ref done, 1);
+                    });
+                    System.Threading.Thread releaseThread = new System.Threading.Thread(() =>
+                    {
+                            while (System.Threading.Thread.VolatileRead(ref done) == 0 || System.Threading.Thread.VolatileRead(ref acquiredCores) > 0)
+                            {
+                                if (System.Threading.Thread.VolatileRead(ref acquiredCores) > 0)
+                                {
+                                    BuildEngine9.ReleaseCores(1);
+                                    System.Threading.Interlocked.Decrement(ref acquiredCores);
+                                }
+                                else
+                                {
+                                    System.Threading.Thread.Yield();
+                                }
+                            }
+                    });
+
+                    // One thread is acquiring cores, the other is releasing them. The releasing thread is running with a lower
+                    // priority to increase the chances of contention where all cores are allocated and RequestCores() blocks.
+                    requestThread.Start();
+                    releaseThread.Priority = System.Threading.ThreadPriority.BelowNormal;
+                    releaseThread.Start();
+
+                    requestThread.Join();
+                    releaseThread.Join();
+                }", "<UseCores />");
+        }
+
+        private List<BuildMessageEventArgs> AssertBuildSucceededAndGetMessages(string taskCode, string targetContent)
+        {
+            string text = $@"
+<Project>
+  <UsingTask
+    TaskName=""UseCores""
+    TaskFactory=""RoslynCodeTaskFactory""
+    AssemblyFile=""$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"" >
+    <Task>
+      <Reference Include=""{typeof(Enumerable).Assembly.Location}"" />
+      <Code Type=""Fragment"" Language=""cs"">
+        {taskCode}
+      </Code>
+    </Task>
+  </UsingTask>
+
+  <Target Name=""Build"">
+        {targetContent}
+  </Target>
+</Project>";
+            using var env = TestEnvironment.Create();
+
+            var projectFile = env.CreateTestProjectWithFiles("test.proj", text);
+            var logger = projectFile.BuildProjectExpectSuccess();
+            return logger.BuildMessageEvents;
+        }
+
+        private int GetTrailingIntegerFromMessage(BuildMessageEventArgs msg)
+        {
+            string[] messageComponents = msg.Message.Split(' ');
+            int.TryParse(messageComponents.Last(), out int trailingInteger).ShouldBeTrue();
+            return trailingInteger;
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests2/AssemblyIdentityTest.cs b/src/Tasks.UnitTests2/AssemblyIdentityTest.cs
deleted file mode 100644
index 5425479a9a6..00000000000
--- a/src/Tasks.UnitTests2/AssemblyIdentityTest.cs
+++ /dev/null
@@ -1,125 +0,0 @@
-﻿using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
-using Microsoft.VisualStudio.TestTools.UnitTesting;
-using System.Collections.Generic;
-namespace XMakeTasksUnitTests
-{
-    
-    
-    /// <summary>
-    ///This is a test class for AssemblyIdentityTest and is intended
-    ///to contain all AssemblyIdentityTest Unit Tests
-    ///</summary>
-    [TestClass()]
-    public class AssemblyIdentityTest
-    {
-
-
-        private TestContext testContextInstance;
-
-        /// <summary>
-        ///Gets or sets the test context which provides
-        ///information about and functionality for the current test run.
-        ///</summary>
-        public TestContext TestContext
-        {
-            get
-            {
-                return testContextInstance;
-            }
-            set
-            {
-                testContextInstance = value;
-            }
-        }
-
-        #region Additional test attributes
-        // 
-        //You can use the following additional attributes as you write your tests:
-        //
-        //Use ClassInitialize to run code before running the first test in the class
-        //[ClassInitialize()]
-        //public static void MyClassInitialize(TestContext testContext)
-        //{
-        //}
-        //
-        //Use ClassCleanup to run code after all tests in a class have run
-        //[ClassCleanup()]
-        //public static void MyClassCleanup()
-        //{
-        //}
-        //
-        //Use TestInitialize to run code before running each test
-        //[TestInitialize()]
-        //public void MyTestInitialize()
-        //{
-        //}
-        //
-        //Use TestCleanup to run code after each test has run
-        //[TestCleanup()]
-        //public void MyTestCleanup()
-        //{
-        //}
-        //
-        #endregion
-
-
-        /// <summary>
-        ///A test for IsFrameworkAssembly
-        ///</summary>
-        [TestMethod()]
-        public void IsFrameworkAssemblyTest()
-        {
-            bool actual;
-            IList<string> listOfInstalledFrameworks = FrameworkMultiTargeting.GetSupportedTargetFrameworks();
-
-            // if 2.0 is installed on this computer, we will test IsFrameworkAssembly for 2.0 assemblies.
-            if (hasVersion(listOfInstalledFrameworks, "Version=v2.0"))
-            {
-                //if (hasVersion(listOfInstalledFrameworks
-                // Test 2.0 CLR binary
-                // "Microsoft.Build.Engine" Version="2.0.0.0" PublicKeyToken="b03f5f7f11d50a3a" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.50727.3026" InGAC="true" />
-                AssemblyIdentity clr2Binary = new AssemblyIdentity("Microsoft.Build.Engine", "2.0.0.0", "b03f5f7f11d50a3a", "neutral", "MSIL");
-                actual = clr2Binary.IsFrameworkAssembly;
-                Assert.IsTrue(actual);
-            }
-
-            if (hasVersion(listOfInstalledFrameworks, "Version=v3.0"))
-            {
-                // Test 3.0 CLR binary
-                // AssemblyName="System.ServiceModel" Version="3.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" InGAC="false" IsRedistRoot="true" />
-                AssemblyIdentity clr3Binary = new AssemblyIdentity("System.ServiceModel", "3.0.0.0", "b77a5c561934e089", "neutral", "MSIL");
-                actual = clr3Binary.IsFrameworkAssembly;
-                Assert.IsTrue(actual);
-            }
-
-            if (hasVersion(listOfInstalledFrameworks, "Version=v3.5"))
-            {
-                // Test 3.5 CLR binary
-                // AssemblyName="Microsoft.Build.Tasks.v3.5" Version="3.5.0.0" PublicKeyToken="b03f5f7f11d50a3a" Culture="neutral" ProcessorArchitecture="MSIL" InGAC="false" />
-                AssemblyIdentity clr35Binary = new AssemblyIdentity("Microsoft.Build.Tasks.v3.5", "3.5.0.0", "b03f5f7f11d50a3a", "neutral", "MSIL");
-                actual = clr35Binary.IsFrameworkAssembly;
-                Assert.IsTrue(actual);
-            }
-
-            if (hasVersion(listOfInstalledFrameworks, "Version=v4.0"))
-            {
-                // Test 4.0 CLR binary
-                // AssemblyName="Microsoft.VisualBasic" Version="10.0.0.0" PublicKeyToken="b03f5f7f11d50a3a" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="4.0.41117.0" InGAC="true" />
-                AssemblyIdentity clr4Binary = new AssemblyIdentity("Microsoft.VisualBasic", "10.0.0.0", "b03f5f7f11d50a3a", "neutral", "MSIL");
-                actual = clr4Binary.IsFrameworkAssembly;
-                Assert.IsTrue(actual);
-            }
-        }
-
-        private bool hasVersion(IList<string> listOfInstalledFrameworks, string p)
-        {
-            foreach (string fx in listOfInstalledFrameworks)
-            {
-                if (fx.Contains(p))
-                    return true;
-            }
-
-            return false;
-        }
-    }
-}
diff --git a/src/Tasks.UnitTests2/AuthoringTests.txt b/src/Tasks.UnitTests2/AuthoringTests.txt
deleted file mode 100644
index 3eb1fca8202..00000000000
--- a/src/Tasks.UnitTests2/AuthoringTests.txt
+++ /dev/null
@@ -1,136 +0,0 @@
-﻿==========================================================================
-    Visual Studio Team System: Overview of Authoring and Running Tests    
-==========================================================================
-
-This overview describes the features for authoring and running tests in 
-Visual Studio Team System and Visual Studio Team Edition for Software Testers.
-
-Opening Tests
--------------
-To open a test, open a test project or a test metadata file (a file with
-extension .vsmdi) that contains the definition of the test. You can find
-test projects and metadata files in Solution Explorer.
-
-Viewing Tests
--------------
-To see which tests are available to you, open the Test View window. Or,
-if you have installed Team Edition for Software Testers, you can also open
-the Test List Editor window to view tests.
-
-To open the Test View window, click the Test menu, point to Windows, and
-then click Test View. To open the Test List Editor window (if you have
-installed Team Edition for Software Testers), click Test, point to Windows,
-and then click Test List Editor.
-
-Running Tests
--------------
-You can run tests from the Test View window and the Test List Editor window.
-See Viewing Tests to learn how to open these windows. To run one or more
-tests displayed in the Test View window, first select the tests in that
-window; to select multiple tests, hold either the Shift or CTRL key while
-clicking tests. Then click the Run Tests button in the Test View window
-toolbar.
-
-If you have installed Visual Studio Team Edition for Software Testers, you can
-also use the Test List Editor window to run tests. To run tests in Test List Editor,
-select the check box next to each test that you want to run. Then click the
-Run Tests button in the Test List Editor window toolbar.
-
-Viewing Test Results
---------------------
-When you run a test or a series of tests, the results of the test run will be
-shown in the Test Results window. Each individual test in the run is shown on
-a separate line so that you can see its status. The window contains an
-embedded status bar in the top half of the window that provides you with
-summary details of the complete test run.
-
-To see more detailed results for a particular test result, double-click it in
-the Test Results window. This opens a window that provides more information
-about the particular test result, such as any specific error messages returned
-by the test.
-
-Changing the way that tests are run
------------------------------------
-Each time you run one or more tests, a collection of settings is used to
-determine how those tests are run. These settings are contained in a “test
-settings” file.
-
-Here is a partial list of the changes you can make with a test settings file:
-
- - Change the naming scheme for each test run.
- - Change the test controller that the tests are run on so that you can run
-   tests remotely.
- - Gather code coverage data for the code being tested so that you can see
-   which lines of code are covered by your tests.
- - Enable and disable test deployment. 
- - Specify additional files to deploy before tests are run.
- - Select a different host, ASP.NET, for running ASP.NET unit tests.
- - Select a different host, the smart device test host, for running smart device unit tests.
- - Set various properties for the test agents that run your tests.
- - Specify to use data collectors that can collect various information as
-   the tests are running.
- - Run custom scripts at the start and end of each test run so that you can
-   set up the test environment exactly as required each time tests are run.
- - Set time limits for tests and test runs.
- - Set the browser mix and the number of times to repeat Web tests in the
-   test run.
-
-By default, a test settings file is created whenever you create a new test
-project. You make changes to this file by double-clicking it in Solution
-Explorer and then changing the test settings. (Test settings files have the
-extension .testsettings.)
-
-A solution can contain multiple test settings files. Only one of those
-files, known as the “Active” test settings file, is used to determine the
-settings that are currently used for test runs. You select the active test
-settings by clicking Select Active Test Settings on the Test menu.
-
--------------------------------------------------------------------------------
-
-Test Types
-----------
-Using Visual Studio Team Edition for Software Testers, you can create a number
-of different test types:
-
-Unit test: Use a unit test to create a programmatic test in C++, Visual C# or
-Visual Basic that exercises source code. A unit test calls the methods of a
-class, passing suitable parameters, and verifies that the returned value is
-what you expect.
-There are three specialized variants of unit tests:
- - Data-driven unit tests are created when you configure a unit test to be
-   called repeatedly for each row of a data source. The data from each row
-   is used by the unit test as input data.
- - ASP.NET unit tests are unit tests that exercise code in an ASP.NET Web
-   application.
- - Smart device unit tests are unit tests that are deployed to a smart device
-   or emulator and then executed by the smart device test host.  
-
-Web Test: Web tests consist of an ordered series of HTTP requests that you
-record in a browser session using Microsoft Internet Explorer. You can have
-the test report specific details about the pages or sites it requests, such
-as whether a particular page contains a specified string.
-
-Load Test: You use a load test to encapsulate non-manual tests, such as
-unit, Web, and generic tests, and then run them simultaneously by using
-virtual users. Running these tests under load generates test results,
-including performance and other counters, in tables and in graphs.
-
-Generic test: A generic test is an existing program wrapped to function as a
-test in Visual Studio. The following are examples of tests or programs that
-you can turn into generic tests:
- - An existing test that uses process exit codes to communicate whether the
-   test passed or failed. 0 indicates passing and any other value indicates
-   a failure.
- - A general program to obtain specific functionality during a test scenario.
- - A test or program that uses a special XML file (called a “summary results
-   file”), to communicate detailed results.
-
-Manual test: The manual test type is used when the test tasks are to be
-completed by a test engineer as opposed to an automated script.
-
-Ordered test: Use an ordered test to execute a set of tests in an order you
-specify.
-
--------------------------------------------------------------------------------
-
-
diff --git a/src/Tasks.UnitTests2/Properties/AssemblyInfo.cs b/src/Tasks.UnitTests2/Properties/AssemblyInfo.cs
deleted file mode 100644
index ca470e18458..00000000000
--- a/src/Tasks.UnitTests2/Properties/AssemblyInfo.cs
+++ /dev/null
@@ -1,33 +0,0 @@
-﻿using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// General Information about an assembly is controlled through the following 
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-[assembly: AssemblyTitle("XMakeTasksUnitTests")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyProduct("XMakeTasksUnitTests")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM componenets.  If you need to access a type in this assembly from 
-// COM, set the ComVisible attribute to true on that type.
-[assembly: ComVisible(false)]
-
-// The following GUID is for the ID of the typelib if this project is exposed to COM
-[assembly: Guid("de6f3aea-4f78-444d-9f24-6955d929c1f9")]
-
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version 
-//      Build Number
-//      Revision
-//
-// You can specify all the values or you can default the Revision and Build Numbers 
-// by using the '*' as shown below:
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/src/Tasks.UnitTests2/UtilTest.cs b/src/Tasks.UnitTests2/UtilTest.cs
deleted file mode 100644
index ff01de06a76..00000000000
--- a/src/Tasks.UnitTests2/UtilTest.cs
+++ /dev/null
@@ -1,96 +0,0 @@
-﻿using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
-using Microsoft.VisualStudio.TestTools.UnitTesting;
-namespace XMakeTasksUnitTests
-{
-    
-    
-    /// <summary>
-    ///This is a test class for UtilTest and is intended
-    ///to contain all UtilTest Unit Tests
-    ///</summary>
-    [TestClass()]
-    public class UtilTest
-    {
-
-
-        private TestContext testContextInstance;
-
-        /// <summary>
-        ///Gets or sets the test context which provides
-        ///information about and functionality for the current test run.
-        ///</summary>
-        public TestContext TestContext
-        {
-            get
-            {
-                return testContextInstance;
-            }
-            set
-            {
-                testContextInstance = value;
-            }
-        }
-
-        #region Additional test attributes
-        // 
-        //You can use the following additional attributes as you write your tests:
-        //
-        //Use ClassInitialize to run code before running the first test in the class
-        //[ClassInitialize()]
-        //public static void MyClassInitialize(TestContext testContext)
-        //{
-        //}
-        //
-        //Use ClassCleanup to run code after all tests in a class have run
-        //[ClassCleanup()]
-        //public static void MyClassCleanup()
-        //{
-        //}
-        //
-        //Use TestInitialize to run code before running each test
-        //[TestInitialize()]
-        //public void MyTestInitialize()
-        //{
-        //}
-        //
-        //Use TestCleanup to run code after each test has run
-        //[TestCleanup()]
-        //public void MyTestCleanup()
-        //{
-        //}
-        //
-        #endregion
-
-
-        /// <summary>
-        ///A test for GetClrVersion
-        ///</summary>
-        [TestMethod()]
-        [DeploymentItem("Microsoft.Build.Tasks.v4.0.dll")]
-        public void GetClrVersionTest()
-        {
-            string targetFrameworkVersion = "v3.5";
-            string expected = "2.0.50727.0"; 
-            string actual;
-            actual = Util_Accessor.GetClrVersion(targetFrameworkVersion);
-            Assert.AreEqual(expected, actual);
-
-            targetFrameworkVersion = "3.5";
-            actual = Util_Accessor.GetClrVersion(targetFrameworkVersion);
-            Assert.AreEqual(expected, actual);
-
-            System.Version currentVersion = System.Environment.Version;
-            System.Version clr4Version = new System.Version(currentVersion.Major, currentVersion.Minor, currentVersion.Build, 0);
-            
-            targetFrameworkVersion = "v4.0";
-            actual = Util_Accessor.GetClrVersion(targetFrameworkVersion);
-            expected = clr4Version.ToString();
-            Assert.AreEqual(expected, actual);
-
-            targetFrameworkVersion = "v4.2";
-            actual = Util_Accessor.GetClrVersion(targetFrameworkVersion);
-            expected = clr4Version.ToString();
-            Assert.AreEqual(expected, actual);
-        }
-    }
-}
diff --git a/src/Tasks.UnitTests2/XMakeTasksUnitTests.csproj b/src/Tasks.UnitTests2/XMakeTasksUnitTests.csproj
deleted file mode 100644
index 78562a2f182..00000000000
--- a/src/Tasks.UnitTests2/XMakeTasksUnitTests.csproj
+++ /dev/null
@@ -1,100 +0,0 @@
-﻿<Project ToolsVersion="dogfood" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <Import Project="$(_NTDRIVE)$(_NTROOT)\tools\Microsoft.DevDiv.Settings.targets" />  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>10.0.10911</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{9EA71CF9-9A62-4ED8-AFE8-DD5753EE377B}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>XMakeTasksUnitTests</RootNamespace>
-    <AssemblyName>XMakeTasksUnitTests</AssemblyName>
-    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-    <ProjectTypeGuids>{3AC096D0-A1C2-E12C-1390-A8335801FDAB};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="Microsoft.Build.Framework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\Framework\objr\i386\Microsoft.Build.Framework.dll</HintPath>
-    </Reference>
-    <Reference Include="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\objr\i386\Microsoft.Build.Tasks.v4.0.dll</HintPath>
-    </Reference>
-    <Reference Include="Microsoft.Build.Utilities.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\Utilities\objr\i386\Microsoft.Build.Utilities.v4.0.dll</HintPath>
-    </Reference>
-    <Reference Include="Microsoft.VisualStudio.QualityTools.UnitTestFramework, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL" />
-    <Reference Include="System">
-      <HintPath>$(SdkRefPath)\System.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Configuration.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Core">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Core.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Data.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Design.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Drawing.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Security.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Windows.Forms.dll</HintPath>
-    </Reference>
-    <Reference Include="System.XML, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.XML.dll</HintPath>
-    </Reference>
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="AssemblyIdentityTest.cs" />
-    <Compile Include="Properties\AssemblyInfo.cs" />
-    <Compile Include="UtilTest.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <Content Include="AuthoringTests.txt" />
-  </ItemGroup>
-  <ItemGroup>
-    <Shadow Include="Test References\Microsoft.Build.Tasks.v3.5.accessor" />
-  </ItemGroup>
-  <Import Project="$(_NTDRIVE)$(_NTROOT)\tools\x86\managed\v4.0\Microsoft.CSharp.targets" />
-  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
-       Other similar extension points exist, see Microsoft.Common.targets.
-  <Target Name="BeforeBuild">
-  </Target>
-  <Target Name="AfterBuild">
-  </Target>
-  -->
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index b7c394ebe42..4af1396f59e 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -361,6 +361,25 @@ private void CorePopulateMetadata()
                 using (var stream = File.OpenRead(_sourceFile))
                 using (var peFile = new PEReader(stream))
                 {
+                    bool hasMetadata = false;
+                    try
+                    {
+                        // This can throw if the stream is too small, which means
+                        // the assembly doesn't have metadata.
+                        hasMetadata = peFile.HasMetadata;
+                    }
+                    finally
+                    {
+                        // If the file does not contain PE metadata, throw BadImageFormatException to preserve
+                        // behavior from AssemblyName.GetAssemblyName(). RAR will deal with this correctly.
+                        if (!hasMetadata)
+                        {
+                            throw new BadImageFormatException(string.Format(CultureInfo.CurrentCulture,
+                                AssemblyResources.GetString("ResolveAssemblyReference.AssemblyDoesNotContainPEMetadata"),
+                                _sourceFile));
+                        }
+                    }
+
                     var metadataReader = peFile.GetMetadataReader();
 
                     var assemblyReferences = metadataReader.AssemblyReferences;
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index b0da1661f29..147a65313eb 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -280,9 +280,8 @@ bool specificVersion
                 }
                 else
                 {
-                    if (fusionNameToResolvedPath.ContainsKey(strongName))
+                    if (fusionNameToResolvedPath.TryGetValue(strongName, out string fusionName))
                     {
-                        fusionNameToResolvedPath.TryGetValue(strongName, out string fusionName);
                         return fusionName;
                     }
                 }
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index c9761c6d469..e5b3b361455 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -148,8 +148,7 @@ internal Reference(IsWinMDFile isWinMDFile, FileExists fileExists, GetAssemblyRu
         internal void AddSourceItem(ITaskItem sourceItem)
         {
             string itemSpec = sourceItem.ItemSpec;
-            bool sourceItemAlreadyInList = _sourceItems.ContainsKey(itemSpec);
-            if (!sourceItemAlreadyInList)
+            if (!_sourceItems.ContainsKey(itemSpec))
             {
                 _sourceItems[itemSpec] = sourceItem;
                 PropagateSourceItems(sourceItem);
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index dcc38343d3c..5967f4c1cdf 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -327,14 +327,7 @@ internal ReferenceTable
 
                     if (sdkName.Length > 0)
                     {
-                        if (!_resolvedSDKReferences.ContainsKey(sdkName))
-                        {
-                            _resolvedSDKReferences.Add(sdkName, resolvedSDK);
-                        }
-                        else
-                        {
-                            _resolvedSDKReferences[sdkName] = resolvedSDK;
-                        }
+                        _resolvedSDKReferences[sdkName] = resolvedSDK;
                     }
                 }
             }
@@ -406,9 +399,8 @@ internal ReferenceTable
         internal void AddReference(AssemblyNameExtension assemblyName, Reference reference)
         {
             ErrorUtilities.VerifyThrow(assemblyName.Name != null, "Got an empty assembly name.");
-            if (References.ContainsKey(assemblyName))
+            if (References.TryGetValue(assemblyName, out Reference referenceGoingToBeReplaced))
             {
-                Reference referenceGoingToBeReplaced = References[assemblyName];
                 foreach (AssemblyRemapping pair in referenceGoingToBeReplaced.RemappedAssemblyNames())
                 {
                     reference.AddRemapping(pair.From, pair.To);
@@ -3197,15 +3189,12 @@ internal bool MarkReferencesForExclusion(Dictionary<string, string> exclusionLis
                 if (!reference.CheckForSpecificVersionMetadataOnParentsReference(false))
                 {
                     // Check to see if the reference is not in a profile or subset
-                    if (exclusionList != null)
+                    if (exclusionList?.ContainsKey(assemblyFullName) == true)
                     {
-                        if (exclusionList.ContainsKey(assemblyFullName))
-                        {
-                            anyMarkedReference = true;
-                            reference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate = LogProfileExclusionUnresolve;
-                            reference.ExclusionListLoggingProperties.IsInExclusionList = true;
-                            ListOfExcludedAssemblies.Add(assemblyFullName);
-                        }
+                        anyMarkedReference = true;
+                        reference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate = LogProfileExclusionUnresolve;
+                        reference.ExclusionListLoggingProperties.IsInExclusionList = true;
+                        ListOfExcludedAssemblies.Add(assemblyFullName);
                     }
 
                     // Check to see if the reference is in the current target framework but has a higher version than what exists in the target framework
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 0f9c4e2f9be..3b5853ec594 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -49,7 +49,7 @@ public class ResolveAssemblyReference : TaskExtension, IConcurrentTask
         /// <summary>
         /// Cache of system state information, used to optimize performance.
         /// </summary>
-        private SystemState _cache = null;
+        internal SystemState _cache = null;
 
         /// <summary>
         /// Construct
@@ -1575,7 +1575,7 @@ private void LogReferenceErrors(Reference reference, MessageImportance importanc
                 }
                 else if (itemError is BadImageReferenceException)
                 {
-                    message = Log.FormatResourceString("ResolveAssemblyReference.FailedWithException", itemError.Message);
+                    message = Log.FormatResourceString("ResolveAssemblyReference.FailedWithException", itemError.InnerException?.ToString() ?? itemError.ToString());
                     helpKeyword = "MSBuild.ResolveAssemblyReference.FailedWithException";
                     dependencyProblem = false;
                 }
@@ -1584,8 +1584,7 @@ private void LogReferenceErrors(Reference reference, MessageImportance importanc
                     Debug.Assert(false, "Unexpected exception type.");
                 }
 
-                string messageOnly;
-                string warningCode = Log.ExtractMessageCode(message, out messageOnly);
+                string warningCode = Log.ExtractMessageCode(message, out string messageOnly);
 
                 // Treat as warning if this is primary and the problem wasn't with a dependency, otherwise, make it a comment.
                 if (reference.IsPrimary && !dependencyProblem)
@@ -1890,11 +1889,16 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l
         /// <summary>
         /// Reads the state file (if present) into the cache.
         /// </summary>
-        private void ReadStateFile()
+        internal void ReadStateFile(FileExists fileExists)
         {
-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));
+            _cache = SystemState.DeserializeCacheByTranslator(_stateFile, Log);
+
+            // Construct the cache only if we can't find any caches.
+            if (_cache == null && AssemblyInformationCachePaths != null && AssemblyInformationCachePaths.Length > 0)
+            {
+                _cache = SystemState.DeserializePrecomputedCachesByTranslator(AssemblyInformationCachePaths, Log, fileExists);
+            }
 
-            // Construct the cache if necessary.
             if (_cache == null)
             {
                 _cache = new SystemState();
@@ -1904,11 +1908,15 @@ private void ReadStateFile()
         /// <summary>
         /// Write out the state file if a state name was supplied and the cache is dirty.
         /// </summary>
-        private void WriteStateFile()
+        internal void WriteStateFile()
         {
-            if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
+            if (!String.IsNullOrEmpty(AssemblyInformationCacheOutputPath))
+            {
+                _cache.SerializePrecomputedCacheByTranslator(AssemblyInformationCacheOutputPath, Log);
+            }
+            else if (!String.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
             {
-                _cache.SerializeCache(_stateFile, Log);
+                _cache.SerializeCacheByTranslator(_stateFile, Log);
             }
         }
         #endregion
@@ -2138,7 +2146,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     }
 
                     // Load any prior saved state.
-                    ReadStateFile();
+                    ReadStateFile(fileExists);
                     _cache.SetGetLastWriteTime(getLastWriteTime);
                     _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);
 
diff --git a/src/Tasks/DefaultTasks.bat b/src/Tasks/DefaultTasks.bat
deleted file mode 100644
index df9739c3429..00000000000
--- a/src/Tasks/DefaultTasks.bat
+++ /dev/null
@@ -1,23 +0,0 @@
-﻿if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\Microsoft.Common.tasks ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\Microsoft.Common.tasks ..\..\..\XMakeCommandLine\bin\Release
-
-rem Deprecated -- remove
-if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\CSharp.targets ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\CSharp.targets ..\..\..\XMakeCommandLine\bin\Release
-
-rem Deprecated -- remove
-if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\VisualBasic.targets ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\VisualBasic.targets ..\..\..\XMakeCommandLine\bin\Release
-
-rem Deprecated -- remove
-if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\Framework.targets ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\Framework.targets ..\..\..\XMakeCommandLine\bin\Release
-
-if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\Microsoft.CSharp.targets ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\Microsoft.CSharp.targets ..\..\..\XMakeCommandLine\bin\Release
-
-if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\Microsoft.VisualBasic.targets ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\Microsoft.VisualBasic.targets ..\..\..\XMakeCommandLine\bin\Release
-
-if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\Microsoft.Common.targets ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\Microsoft.Common.targets ..\..\..\XMakeCommandLine\bin\Release
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index 0cf22b566c5..2132b8266db 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -123,14 +123,6 @@ public string CustomWarningRegularExpression
         /// </summary>
         protected override Encoding StandardErrorEncoding => _standardErrorEncoding;
 
-        /// <summary>
-        /// Whether or not to use UTF8 encoding for the cmd file and console window.
-        /// Values: Always, Never, Detect
-        /// If set to Detect, the current code page will be used unless it cannot represent 
-        /// the Command string. In that case, UTF-8 is used.
-        /// </summary>
-        public string UseUtf8Encoding { get; set; }
-
         /// <summary>
         /// Project visible property specifying the encoding of the captured task standard output stream
         /// </summary>
diff --git a/src/Tasks/GenerateBootstrapper.cs b/src/Tasks/GenerateBootstrapper.cs
index 98ffca90a5e..ff94ae73668 100644
--- a/src/Tasks/GenerateBootstrapper.cs
+++ b/src/Tasks/GenerateBootstrapper.cs
@@ -118,10 +118,9 @@ public override bool Execute()
 
                 foreach (Product product in products)
                 {
-                    if (items.ContainsKey(product.ProductCode))
+                    if (items.Remove(product.ProductCode))
                     {
                         settings.ProductBuilders.Add(product.ProductBuilder);
-                        items.Remove(product.ProductCode);
                     }
                 }
 
diff --git a/src/Tasks/InstalledSDKResolver.cs b/src/Tasks/InstalledSDKResolver.cs
index 427cc8c86eb..ac0ff362d0b 100644
--- a/src/Tasks/InstalledSDKResolver.cs
+++ b/src/Tasks/InstalledSDKResolver.cs
@@ -52,10 +52,8 @@ out bool userRequestedSpecificFile
             if (assemblyName != null)
             {
                 // We have found a resolved SDK item that matches the one on the reference items.
-                if (_resolvedSDKs.ContainsKey(sdkName))
+                if (_resolvedSDKs.TryGetValue(sdkName, out ITaskItem resolvedSDK))
                 {
-                    ITaskItem resolvedSDK = _resolvedSDKs[sdkName];
-
                     string sdkDirectory = resolvedSDK.ItemSpec;
                     string configuration = resolvedSDK.GetMetadata("TargetedSDKConfiguration");
                     string architecture = resolvedSDK.GetMetadata("TargetedSDKArchitecture");
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index de2da27930b..0d5fe24e603 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -611,10 +611,8 @@ string toolsVersion
 
                         foreach (string targetName in nonNullTargetList)
                         {
-                            if (targetOutputsPerProject[i].ContainsKey(targetName))
+                            if (targetOutputsPerProject[i].TryGetValue(targetName, out ITaskItem[] outputItemsFromTarget))
                             {
-                                ITaskItem[] outputItemsFromTarget = targetOutputsPerProject[i][targetName];
-
                                 foreach (ITaskItem outputItemFromTarget in outputItemsFromTarget)
                                 {
                                     // No need to rebase if the calling project is the same as the callee project 
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index d5a7628a245..4db84f02967 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -421,25 +421,25 @@ private void ValidateCom()
                             if (!String.IsNullOrEmpty(comInfo.ClsId))
                             {
                                 string key = comInfo.ClsId.ToLowerInvariant();
-                                if (!clsidList.ContainsKey(key))
+                                if (!clsidList.TryGetValue(key, out ComInfo info))
                                 {
                                     clsidList.Add(key, comInfo);
                                 }
                                 else
                                 {
-                                    OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "clsid", comInfo.ComponentFileName, comInfo.ClsId, comInfo.ManifestFileName, clsidList[key].ManifestFileName);
+                                    OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "clsid", comInfo.ComponentFileName, comInfo.ClsId, comInfo.ManifestFileName, info.ManifestFileName);
                                 }
                             }
                             if (!String.IsNullOrEmpty(comInfo.TlbId))
                             {
                                 string key = comInfo.TlbId.ToLowerInvariant();
-                                if (!tlbidList.ContainsKey(key))
+                                if (!tlbidList.TryGetValue(key, out ComInfo info))
                                 {
                                     tlbidList.Add(key, comInfo);
                                 }
                                 else
                                 {
-                                    OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "tlbid", comInfo.ComponentFileName, comInfo.TlbId, comInfo.ManifestFileName, tlbidList[key].ManifestFileName);
+                                    OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "tlbid", comInfo.ComponentFileName, comInfo.TlbId, comInfo.ManifestFileName, info.ManifestFileName);
                                 }
                             }
                         }
@@ -455,13 +455,13 @@ private void ValidateCom()
                     foreach (ComClass comClass in file.ComClasses)
                     {
                         string key = comClass.ClsId.ToLowerInvariant();
-                        if (!clsidList.ContainsKey(key))
+                        if (!clsidList.TryGetValue(key, out ComInfo info))
                         {
                             clsidList.Add(key, new ComInfo(outputFileName, file.TargetPath, comClass.ClsId, null));
                         }
                         else
                         {
-                            OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "clsid", file.ToString(), comClass.ClsId, outputFileName, clsidList[key].ManifestFileName);
+                            OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "clsid", file.ToString(), comClass.ClsId, outputFileName, info.ManifestFileName);
                         }
                     }
                 }
@@ -470,13 +470,13 @@ private void ValidateCom()
                     foreach (TypeLib typeLib in file.TypeLibs)
                     {
                         string key = typeLib.TlbId.ToLowerInvariant();
-                        if (!tlbidList.ContainsKey(key))
+                        if (!tlbidList.TryGetValue(key, out ComInfo info))
                         {
                             tlbidList.Add(key, new ComInfo(outputFileName, file.TargetPath, null, typeLib.TlbId));
                         }
                         else
                         {
-                            OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "tlbid", file.ToString(), typeLib.TlbId, outputFileName, tlbidList[key].ManifestFileName);
+                            OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "tlbid", file.ToString(), typeLib.TlbId, outputFileName, info.ManifestFileName);
                         }
                     }
                 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 988843a2973..6e05beb2f75 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -7,7 +7,7 @@
     <TargetFrameworks>$(LibraryTargetFrameworks)</TargetFrameworks>
     <EnableDefaultItems>false</EnableDefaultItems>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
-    <GenerateReferenceAssemblySources>true</GenerateReferenceAssemblySources>
+    <GenerateReferenceAssemblySource>true</GenerateReferenceAssemblySource>
     <AssemblyName>Microsoft.Build.Tasks.Core</AssemblyName>
     <RootNamespace>Microsoft.Build.Tasks</RootNamespace>
     <DefineConstants>$(DefineConstants);MICROSOFT_BUILD_TASKS</DefineConstants>
@@ -27,6 +27,14 @@
       <LogicalName>System.Design.resources</LogicalName>
     </EmbeddedResource>
   </ItemGroup>
+  <ItemGroup>
+    <!-- Binary serialization by ITranslatable -->
+    <Compile Include="..\Shared\ITranslatable.cs" />
+    <Compile Include="..\Shared\ITranslator.cs" />
+    <Compile Include="..\Shared\BinaryTranslator.cs" />
+    <Compile Include="..\Shared\InterningBinaryReader.cs" />
+    <Compile Include="..\Shared\TranslatorHelpers.cs" />    
+  </ItemGroup> 
   <ItemGroup>
     <!-- Source Files -->
     <Compile Include="..\Shared\EnvironmentUtilities.cs">
@@ -517,6 +525,7 @@
     <Compile Include="TaskExtension.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="TaskTranslatorHelpers.cs" />
     <Compile Include="Telemetry.cs" />
     <Compile Include="ToolTaskExtension.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/Tasks/Microsoft.CSharp.CrossTargeting.targets b/src/Tasks/Microsoft.CSharp.CrossTargeting.targets
index 68d1aa0797a..26ae23579d9 100644
--- a/src/Tasks/Microsoft.CSharp.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.CSharp.CrossTargeting.targets
@@ -17,6 +17,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
      <CSharpDesignTimeTargetsPath Condition="'$(CSharpDesignTimeTargetsPath)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed\Microsoft.CSharp.DesignTime.targets</CSharpDesignTimeTargetsPath>
   </PropertyGroup>
+
   <Import Project="$(CSharpDesignTimeTargetsPath)" Condition="'$(CSharpDesignTimeTargetsPath)' != '' and Exists('$(CSharpDesignTimeTargetsPath)')" />
 
   <Import Project="Microsoft.Common.CrossTargeting.targets" />
diff --git a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
index a14d5b42df4..f5955642de1 100644
--- a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
@@ -8,7 +8,7 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 
 This file defines the steps in the standard build process specific for C# .NET projects.
 For example, it contains the step that actually calls the C# compiler.  The remainder
-of the build process is defined in Microsoft.Common.targets, which is imported by 
+of the build process is defined in Microsoft.Common.targets, which is imported by
 this file.
 
 Copyright (C) Microsoft Corporation. All rights reserved.
@@ -66,14 +66,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <!--
     The CreateManifestResourceNames target create the manifest resource names from the .RESX
     files.
-    
+
         [IN]
         @(EmbeddedResource) - The list of EmbeddedResource items that have been pre-processed to add metadata about resource type
                               Expected Metadata "Type" can either be "Resx" or "Non-Resx"
 
         [OUT]
-        @(EmbeddedResource) - EmbeddedResource items with metadata         
-        
+        @(EmbeddedResource) - EmbeddedResource items with metadata
+
     For C# applications the transformation is like:
 
         Resources1.resx => RootNamespace.Resources1 => Build into main assembly
@@ -83,30 +83,29 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     For other project systems, this transformation may be different.
     -->
+
     <PropertyGroup>
         <CreateManifestResourceNamesDependsOn></CreateManifestResourceNamesDependsOn>
     </PropertyGroup>
+
     <Target
         Name="CreateManifestResourceNames"
         Condition="'@(EmbeddedResource)' != ''"
         DependsOnTargets="$(CreateManifestResourceNamesDependsOn)"
         >
-
         <ItemGroup>
             <_Temporary Remove="@(_Temporary)" />
         </ItemGroup>
-        
+
         <!-- Create manifest names for culture and non-culture Resx files, and for non-culture Non-Resx resources -->
         <CreateCSharpManifestResourceName
               ResourceFiles="@(EmbeddedResource)"
               RootNamespace="$(RootNamespace)"
               UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)"
               Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and ('%(EmbeddedResource.WithCulture)' == 'false' or '%(EmbeddedResource.Type)' == 'Resx')">
-
             <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
-
         </CreateCSharpManifestResourceName>
-        
+
         <!-- Create manifest names for all culture non-resx resources -->
         <CreateCSharpManifestResourceName
               ResourceFiles="@(EmbeddedResource)"
@@ -114,9 +113,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               PrependCultureAsDirectory="false"
               UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)"
               Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and '%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
-
             <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
-
         </CreateCSharpManifestResourceName>
 
         <ItemGroup>
@@ -124,23 +121,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
             <EmbeddedResource Include="@(_Temporary)" />
             <_Temporary Remove="@(_Temporary)" />
         </ItemGroup>
-              
     </Target>
 
     <Target
         Name="ResolveCodeAnalysisRuleSet"
         Condition="'$(CodeAnalysisRuleSet)' != ''"
         >
-
         <ResolveCodeAnalysisRuleSet
             CodeAnalysisRuleSet="$(CodeAnalysisRuleSet)"
             CodeAnalysisRuleSetDirectories="$(CodeAnalysisRuleSetDirectories)"
             MSBuildProjectDirectory="$(MSBuildProjectDirectory)">
-
             <Output TaskParameter="ResolvedCodeAnalysisRuleSet" PropertyName="ResolvedCodeAnalysisRuleSet" />
-
         </ResolveCodeAnalysisRuleSet>
-
     </Target>
 
     <ItemGroup>
@@ -167,7 +159,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <CoreCompileDependsOn>$(CoreCompileDependsOn);_ComputeNonExistentFileProperty;ResolveCodeAnalysisRuleSet</CoreCompileDependsOn>
         <ExportWinMDFile Condition="'$(ExportWinMDFile)' == '' and '$(OutputType)' == 'WinMDObj'">true</ExportWinMDFile>
     </PropertyGroup>
- 
+
 <!--
       The XamlPreCompile target must remain identical to
       the CoreCompile target in Microsoft.CSharp.Core.targets.
@@ -183,14 +175,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                 @(ReferencePath);
                 @(CompiledLicenseFile);
                 @(LinkResource);
-                @(EmbeddedDocumentation); 
+                @(EmbeddedDocumentation);
                 $(Win32Resource);
                 $(Win32Manifest);
                 @(CustomAdditionalCompileInputs);
                 @(Page);
                 @(ApplicationDefinition);
                 $(ResolvedCodeAnalysisRuleSet)"
-                  
+
         Outputs="@(DocFileItem);
                  @(XamlIntermediateAssembly);
                  @(_DebugSymbolsIntermediatePath);
@@ -217,13 +209,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                 <EmbedInteropTypes/>
             </ReferencePath>
         </ItemGroup>
-        
+
         <PropertyGroup>
             <!-- If the user has specified AppConfigForCompiler, we'll use it. If they have not, but they set UseAppConfigForCompiler,
                  then we'll use AppConfig -->
             <AppConfigForCompiler Condition="'$(AppConfigForCompiler)' == '' and '$(UseAppConfigForCompiler)' == 'true'">$(AppConfig)</AppConfigForCompiler>
-            
-            <!-- If we are targeting winmdobj we want to specifically the pdbFile property since we do not want it to collide with the output of winmdexp--> 
+
+            <!-- If we are targeting winmdobj we want to specifically the pdbFile property since we do not want it to collide with the output of winmdexp-->
             <PdbFile Condition="'$(PdbFile)' == '' and '$(OutputType)' == 'winmdobj' and '$(_DebugSymbolsProduced)' == 'true'">$(IntermediateOutputPath)$(TargetName).compile.pdb</PdbFile>
         </PropertyGroup>
 
@@ -231,12 +223,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <PropertyGroup Condition="('$(TargetFrameworkVersion)' == 'v4.0')">
             <Prefer32Bit>false</Prefer32Bit>
         </PropertyGroup>
-       
+
         <ItemGroup Condition="('$(AdditionalFileItemNames)' != '')">
           <AdditionalFileItems Include="$(AdditionalFileItemNames)" />
           <AdditionalFiles Include="@(%(AdditionalFileItems.Identity))" />
         </ItemGroup>
-        
+
        <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
          <UseSharedCompilation>true</UseSharedCompilation>
        </PropertyGroup>
@@ -259,7 +251,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               DisabledWarnings="$(NoWarn)"
               DocumentationFile="@(DocFileItem)"
               EmitDebugInformation="$(DebugSymbols)"
-              EnvironmentVariables="$(CscEnvironment)"              
+              EnvironmentVariables="$(CscEnvironment)"
               ErrorEndLocation="$(ErrorEndLocation)"
               ErrorLog="$(ErrorLog)"
               ErrorReport="$(ErrorReport)"
@@ -279,7 +271,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               Nullable="$(Nullable)"
               Optimize="$(Optimize)"
               OutputAssembly="@(XamlIntermediateAssembly)"
-              PdbFile="$(PdbFile)" 
+              PdbFile="$(PdbFile)"
               Platform="$(PlatformTarget)"
               Prefer32Bit="$(Prefer32Bit)"
               PreferredUILang="$(PreferredUILang)"
@@ -322,15 +314,17 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </PropertyGroup>
 
     <Import Project="$(CSharpCoreTargetsPath)" />
-    
+
     <!-- Import design time targets for Roslyn Project System. These are only available if Visual Studio is installed. -->
     <!-- Import design time targets before the common targets, which import targets from Nuget. -->
     <PropertyGroup>
        <CSharpDesignTimeTargetsPath Condition="'$(CSharpDesignTimeTargetsPath)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed\Microsoft.CSharp.DesignTime.targets</CSharpDesignTimeTargetsPath>
     </PropertyGroup>
+
     <Import Project="$(CSharpDesignTimeTargetsPath)" Condition="'$(CSharpDesignTimeTargetsPath)' != '' and Exists('$(CSharpDesignTimeTargetsPath)')" />
 
     <Import Project="Microsoft.Common.targets" />
+
     <Import Project="$(MSBuildToolsPath)\Microsoft.ServiceModel.targets" Condition="('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.0' and '$(TargetFrameworkVersion)' != 'v3.5') and Exists('$(MSBuildToolsPath)\Microsoft.ServiceModel.targets')"/>
 
     <Target Name="_SetTargetFrameworkMonikerAttribute" BeforeTargets="GenerateTargetFrameworkMonikerAttribute">
@@ -346,7 +340,6 @@ using System.Reflection%3b
 
     <PropertyGroup>
        <Utf8Output Condition="'$(Utf8Output)' == ''">true</Utf8Output>
-
       <!-- NoCompilerStandardLib maps to the compiler's /nostdlib option. By default we always
            want that switch to be passed to the compiler so that either we or the user
            provides the references
@@ -354,18 +347,16 @@ using System.Reflection%3b
            so only if NoStdLib isn't set to true, will we provide the standard references
       -->
       <NoCompilerStandardLib Condition=" '$(NoCompilerStandardLib)' == '' ">true</NoCompilerStandardLib>
-
       <ErrorEndLocation Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(ErrorEndLocation)' == ''">true</ErrorEndLocation>
-
        <!-- When building inside VS, by default use the same language for compiler messages as VS itself does. -->
        <PreferredUILang Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(PreferredUILang)' == ''">$([System.Globalization.CultureInfo]::CurrentUICulture.Name)</PreferredUILang>
     </PropertyGroup>
-    
+
     <!-- Add any "automatic" compiler references that need to be resolved when NoCompilerStandardLib is set
          but the user hasn't told us to not include standard references -->
     <ItemGroup Condition=" '$(NoCompilerStandardLib)' == 'true' and '$(NoStdLib)' != 'true' ">
       <!-- Note that unlike VB, C# does not automatically locate System.dll as a "standard library"
-           instead the reference is always passed from the project. Also, for mscorlib.dll 
+           instead the reference is always passed from the project. Also, for mscorlib.dll
            we need to provide the explicit location in order to avoid resolving from, e.g.,
            {CandidateAssemblyFiles}.
       -->
diff --git a/src/Tasks/Microsoft.CSharp.targets b/src/Tasks/Microsoft.CSharp.targets
index beda9624db2..80361f7c441 100644
--- a/src/Tasks/Microsoft.CSharp.targets
+++ b/src/Tasks/Microsoft.CSharp.targets
@@ -8,7 +8,7 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 
 This file defines the steps in the standard build process specific for C# .NET projects.
 For example, it contains the step that actually calls the C# compiler.  The remainder
-of the build process is defined in Microsoft.Common.targets, which is imported by 
+of the build process is defined in Microsoft.Common.targets, which is imported by
 this file.
 
 Copyright (C) Microsoft Corporation. All rights reserved.
@@ -16,26 +16,26 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
    <!--
-        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
-        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
-        just used whatever ToolsVersion was in the project file if it existed on the machine, and 
-        only forced 4.0 if that ToolsVersion did not exist.  
-
-        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
-        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
-        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
-        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
+        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed
+        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead
+        just used whatever ToolsVersion was in the project file if it existed on the machine, and
+        only forced 4.0 if that ToolsVersion did not exist.
+
+        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio,
+        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected
+        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved
+        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist
         as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
-        targets. 
+        targets.
    -->
 
    <Choose>
       <When Condition="'$(MSBuildAssemblyVersion)' == ''">
          <PropertyGroup>
             <CSharpTargetsPath>$(MSBuildFrameworkToolsPath)\Microsoft.CSharp.targets</CSharpTargetsPath>
-
-            <!-- Same condition as in .NET 4.5 C# targets so that we can override the behavior where it defaults to 
+            <!-- Same condition as in .NET 4.5 C# targets so that we can override the behavior where it defaults to
                  MSBuildToolsPath, which would be incorrect in this case -->
             <CscToolPath Condition="'$(CscToolPath)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">$(MsBuildFrameworkToolsPath)</CscToolPath>
          </PropertyGroup>
@@ -54,14 +54,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
 
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
-      <!-- 
-           Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify 
-           (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Defined here because 
-           Microsoft.CSharp.targets imports Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath, 
+      <!--
+           Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify
+           (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Defined here because
+           Microsoft.CSharp.targets imports Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath,
            so defining these in Microsoft.Common.targets alone would not suffice for C# projects.
 
            NOTE: This logic is duplicated in Microsoft.VisualBasic.targets (VB has the same problem) and in Microsoft.Common.targets
-           (for anyone who DOES import it directly), so for any changes to this logic in this file, please also edit the other two. 
+           (for anyone who DOES import it directly), so for any changes to this logic in this file, please also edit the other two.
        -->
       <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">$(ImportByWildcardBeforeMicrosoftCommonTargets)</ImportByWildcardBefore40MicrosoftCommonTargets>
       <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">true</ImportByWildcardBefore40MicrosoftCommonTargets>
@@ -106,15 +106,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
    </PropertyGroup>
 
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == '' and ('$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight' or ('$(TargetFrameworkIdentifier)' == '' and ('$(TargetRuntime)' == 'Managed' or '$(TargetRuntime)' == '')))">
-       <!-- 
-            Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify 
-            (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because 
-            Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its 
+       <!--
+            Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify
+            (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because
+            Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its
             own redirection targets.
 
             NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.Common.targets because VB and C#
-            import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either, 
-            so for any changes to this logic in this file, please also edit the other two. 
+            import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either,
+            so for any changes to this logic in this file, please also edit the other two.
         -->
       <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">$(ImportByWildcardBeforeMicrosoftNetFrameworkProps)</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
       <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">true</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
@@ -137,24 +137,24 @@ Copyright (C) Microsoft Corporation. All rights reserved.
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportBefore')"/>
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportBefore')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
-   <!-- Really should be imported right before Microsoft.Common.targets, but because Microsoft.CSharp.targets imports 
+   <!-- Really should be imported right before Microsoft.Common.targets, but because Microsoft.CSharp.targets imports
         Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-        targets), we're stuck doing it this way instead. --> 
+        targets), we're stuck doing it this way instead. -->
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')"/>
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
-   <!-- Really should be imported right before Microsoft.NETFramework.props, but because Microsoft.CSharp.targets imports 
+   <!-- Really should be imported right before Microsoft.NETFramework.props, but because Microsoft.CSharp.targets imports
         Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-        targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this 
-        way instead. --> 
+        targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this
+        way instead. -->
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')"/>
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
    <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets" />
 
@@ -164,31 +164,32 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
    <!-- Really should be imported right after Microsoft.NETFramework.props, but because Microsoft.CSharp.targets imports
         Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-        targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this 
-        way instead. --> 
+        targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this
+        way instead. -->
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')"/>
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
-   <!-- Really should be imported right after Microsoft.Common.targets, but because Microsoft.CSharp.targets imports 
+   <!-- Really should be imported right after Microsoft.Common.targets, but because Microsoft.CSharp.targets imports
         Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-        targets), we're stuck doing it this way instead. --> 
+        targets), we're stuck doing it this way instead. -->
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')"/>
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')"/>
-    </ImportGroup> 
+    </ImportGroup>
 
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportAfter')"/>
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportAfter')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
-   <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the 
-        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not 
-        installed.  Defined here rather than in Microsoft.Common.targets because the .NET Microsoft.CSharp.targets 
+   <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the
+        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not
+        installed.  Defined here rather than in Microsoft.Common.targets because the .NET Microsoft.CSharp.targets
         imports Microsoft.Common.targets from the current directory. -->
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <FrameworkPathOverride Condition="!Exists('$(FrameworkPathOverride)\mscorlib.dll')">$(MSBuildFrameworkToolsPath)</FrameworkPathOverride>
    </PropertyGroup>
+
 </Project>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index c5ce7a2d79e..f59b407d959 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -11,10 +11,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
   <PropertyGroup>
     <BuildInParallel Condition="'$(BuildInParallel)' == ''">true</BuildInParallel>
     <ImportByWildcardBeforeMicrosoftCommonCrossTargetingTargets Condition="'$(ImportByWildcardBeforeMicrosoftCommonCrossTargetingTargets)' == ''">true</ImportByWildcardBeforeMicrosoftCommonCrossTargetingTargets>
   </PropertyGroup>
+
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportBefore\*.targets"
           Condition="'$(ImportByWildcardBeforeMicrosoftCommonCrossTargetingTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportBefore')"/>
 
@@ -33,21 +35,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="Result"
         PropertyName="_AdditionalPropertiesFromProject"/>
     </CombineXmlElements>
-    
+
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
         <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
         <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
         <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
-
         <HasSingleTargetFramework>false</HasSingleTargetFramework>
-
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
         <IsRidAgnostic>false</IsRidAgnostic>
         <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
+
   </Target>
 
   <Target Name="_ComputeTargetFrameworkItems" Returns="@(InnerOutput)">
@@ -178,7 +179,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <ImportByWildcardAfterMicrosoftCommonCrossTargetingTargets Condition="'$(ImportByWildcardAfterMicrosoftCommonCrossTargetingTargets)' == ''">true</ImportByWildcardAfterMicrosoftCommonCrossTargetingTargets>
   </PropertyGroup>
-  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportAfter\*.targets" 
+
+  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportAfter\*.targets"
           Condition="'$(ImportByWildcardAfterMicrosoftCommonCrossTargetingTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportAfter')"/>
 
   <!--
@@ -188,8 +190,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     Each package management system should use a unique moniker to avoid collisions.  It is a wild-card iport so the package
     management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
 
-    This is the same import that would happen in an inner (non-cross targeting) build. Package management systems are responsible for generating 
-    appropriate conditions based on $(IsCrossTargetingBuild) to pull in only those package targets that are meant to participate in a cross-targeting 
+    This is the same import that would happen in an inner (non-cross targeting) build. Package management systems are responsible for generating
+    appropriate conditions based on $(IsCrossTargetingBuild) to pull in only those package targets that are meant to participate in a cross-targeting
     build.
   -->
   <PropertyGroup>
@@ -202,19 +204,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ImportDirectoryBuildTargets Condition="'$(ImportDirectoryBuildTargets)' == ''">true</ImportDirectoryBuildTargets>
   </PropertyGroup>
 
-  <!-- 
+  <!--
         Determine the path to the directory build targets file if the user did not disable $(ImportDirectoryBuildTargets) and
         they did not already specify an absolute path to use via $(DirectoryBuildTargetsPath)
     -->
   <PropertyGroup Condition="'$(ImportDirectoryBuildTargets)' == 'true' and '$(DirectoryBuildTargetsPath)' == ''">
     <_DirectoryBuildTargetsFile Condition="'$(_DirectoryBuildTargetsFile)' == ''">Directory.Build.targets</_DirectoryBuildTargetsFile>
     <_DirectoryBuildTargetsBasePath Condition="'$(_DirectoryBuildTargetsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildTargetsFile)'))</_DirectoryBuildTargetsBasePath>
-    <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([MSBuild]::NormalizePath('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
+    <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
   </PropertyGroup>
 
   <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')"/>
 
   <!-- TODO: https://github.com/Microsoft/msbuild/issues/1062: Remove this temporary hook when possible. -->
-  <Import Project="$(CoreCrossTargetingTargetsPath)" 
+  <Import Project="$(CoreCrossTargetingTargetsPath)"
           Condition="'$(CoreCrossTargetingTargetsPath)' != '' and Exists('$(CoreCrossTargetingTargetsPath)')" />
+
 </Project>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 18d7712ad5c..668684ed3c6 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -30,7 +30,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')"/>
 
-
   <!-- VS10 without SP1 and without VS11 will not have VisualStudioVersion set, so do that here -->
   <PropertyGroup>
     <VisualStudioVersion Condition="'$(VisualStudioVersion)' == ''">10.0</VisualStudioVersion>
@@ -151,19 +150,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
     <ConfigurationName Condition="'$(ConfigurationName)' == ''">$(Configuration)</ConfigurationName>
 
-    <BaseOutputPath>$([MSBuild]::EnsureTrailingSlash($([MSBuild]::ValueOrDefault('$(BaseOutputPath)', 'bin'))))</BaseOutputPath>
-    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$([System.IO.Path]::Combine('$(BaseOutputPath)', '$(Configuration)'))</OutputPath>
-    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$([System.IO.Path]::Combine('$(BaseOutputPath)', '$(PlatformName)', '$(Configuration)'))</OutputPath>
-    <OutputPath>$([MSBuild]::EnsureTrailingSlash('$(OutputPath)'))</OutputPath>
-
-    <BaseIntermediateOutputPath>$([MSBuild]::EnsureTrailingSlash($([MSBuild]::ValueOrDefault('$(BaseIntermediateOutputPath)', 'obj'))))</BaseIntermediateOutputPath>
-    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$([System.IO.Path]::Combine('$(BaseIntermediateOutputPath)', '$(Configuration)'))</IntermediateOutputPath>
-    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$([System.IO.Path]::Combine('$(BaseIntermediateOutputPath)', '$(PlatformName)', '$(Configuration)'))</IntermediateOutputPath>
-    <IntermediateOutputPath>$([MSBuild]::EnsureTrailingSlash('$(IntermediateOutputPath)'))</IntermediateOutputPath>
+    <BaseOutputPath Condition="'$(BaseOutputPath)' == ''">bin\</BaseOutputPath>
+    <BaseOutputPath Condition="!HasTrailingSlash('$(BaseOutputPath)')">$(BaseOutputPath)\</BaseOutputPath>
+    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$(BaseOutputPath)$(Configuration)\</OutputPath>
+    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$(BaseOutputPath)$(PlatformName)\$(Configuration)\</OutputPath>
+    <OutputPath Condition="!HasTrailingSlash('$(OutputPath)')">$(OutputPath)\</OutputPath>
+
+    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == ''">obj\</BaseIntermediateOutputPath>
+    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
+    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$(BaseIntermediateOutputPath)$(Configuration)\</IntermediateOutputPath>
+    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$(BaseIntermediateOutputPath)$(PlatformName)\$(Configuration)\</IntermediateOutputPath>
+    <IntermediateOutputPath Condition="!HasTrailingSlash('$(IntermediateOutputPath)')">$(IntermediateOutputPath)\</IntermediateOutputPath>
   </PropertyGroup>
 
   <PropertyGroup>
-
     <!-- Determine OutputType property from the legacy TargetType property -->
     <OutputType Condition=" '$(TargetType)' != ''">$(TargetType)</OutputType>
     <OutputType Condition=" '$(TargetType)' == 'Container' or '$(TargetType)' == 'DocumentContainer' ">library</OutputType>
@@ -221,18 +221,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <PropertyGroup>
-
     <!-- Required for enabling Team Build for packaging app package-generating projects -->
     <OutDirWasSpecified Condition=" '$(OutDir)'!='' and '$(OutDirWasSpecified)'=='' ">true</OutDirWasSpecified>
 
+    <OutDir Condition=" '$(OutDir)' == '' ">$(OutputPath)</OutDir>
     <!-- Example, bin\Debug\ -->
     <!-- Ensure OutDir has a trailing slash, so it can be concatenated -->
-    <OutDir>$([MSBuild]::EnsureTrailingSlash($([MSBuild]::ValueOrDefault('$(OutDir)', '$(OutputPath)'))))</OutDir>
+    <OutDir Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')">$(OutDir)\</OutDir>
     <ProjectName Condition=" '$(ProjectName)' == '' ">$(MSBuildProjectName)</ProjectName>
     <!-- Example, MyProject -->
 
     <!-- For projects that generate app packages or ones that want a per-project output directory, update OutDir to include the project name -->
-    <OutDir Condition="'$(OutDir)' != '' and '$(OutDirWasSpecified)' == 'true' and (('$(WindowsAppContainer)' == 'true' and '$(GenerateProjectSpecificOutputFolder)' != 'false') or '$(GenerateProjectSpecificOutputFolder)' == 'true')">$([MSBuild]::EnsureTrailingSlash('$(OutDir)$(ProjectName)'))</OutDir>
+    <OutDir Condition="'$(OutDir)' != '' and '$(OutDirWasSpecified)' == 'true' and (('$(WindowsAppContainer)' == 'true' and '$(GenerateProjectSpecificOutputFolder)' != 'false') or '$(GenerateProjectSpecificOutputFolder)' == 'true')">$(OutDir)$(ProjectName)\</OutDir>
 
     <AssemblyName Condition=" '$(AssemblyName)'=='' ">$(MSBuildProjectName)</AssemblyName>
     <TargetName Condition="'$(TargetName)' == '' and '$(OutputType)' == 'winmdobj' and '$(RootNamespace)' != ''">$(RootNamespace)</TargetName>
@@ -318,7 +318,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Condition intentionally omitted on this one, because it causes problems
         when we pick up the value of an environment variable named TargetDir
         -->
-    <TargetDir Condition="'$(OutDir)' != ''">$([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)', '$(OutDir)'))</TargetDir>
+    <TargetDir Condition="'$(OutDir)' != ''">$([MSBuild]::Escape($([System.IO.Path]::GetFullPath(`$([System.IO.Path]::Combine(`$(MSBuildProjectDirectory)`, `$(OutDir)`))`))))</TargetDir>
 
     <!-- Example, C:\MyProjects\MyProject\bin\Debug\MyAssembly.dll -->
     <TargetPath Condition=" '$(TargetPath)' == '' ">$(TargetDir)$(TargetFileName)</TargetPath>
@@ -346,6 +346,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <DevEnvDir Condition="'$(DevEnvDir)'==''">*Undefined*</DevEnvDir>
     <SolutionName Condition="'$(SolutionName)'==''">*Undefined*</SolutionName>
+    <SolutionFilterName Condition="'$(SolutionFilterName)'==''">*Undefined*</SolutionFilterName>
     <!-- Example, MySolution -->
     <SolutionFileName Condition="'$(SolutionFileName)'==''">*Undefined*</SolutionFileName>
     <!-- Example, MySolution.sln -->
@@ -362,10 +363,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <!-- It would be a breaking change to automatically turn on binding redirects for existing projects, so turn them on only when opting into a new framework. -->
     <AutoGenerateBindingRedirects Condition="'$(AutoGenerateBindingRedirects)' == '' and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetFrameworkVersion.TrimStart(vV))' >= '4.7.2'">true</AutoGenerateBindingRedirects>
   </PropertyGroup>
+
   <PropertyGroup Condition="'$(AutoUnifyAssemblyReferences)' == ''">
     <AutoUnifyAssemblyReferences>true</AutoUnifyAssemblyReferences>
     <AutoUnifyAssemblyReferences Condition="'$(GenerateBindingRedirectsOutputType)' == 'true' and '$(AutoGenerateBindingRedirects)' != 'true'">false</AutoUnifyAssemblyReferences>
   </PropertyGroup>
+
   <PropertyGroup>
     <CleanFile Condition="'$(CleanFile)'==''">$(MSBuildProjectFile).FileListAbsolute.txt</CleanFile>
     <!-- During DesignTime Builds, skip project reference build as Design time is only queueing information.-->
@@ -382,6 +385,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <_GenerateBindingRedirectsIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).config</_GenerateBindingRedirectsIntermediateAppConfig>
   </PropertyGroup>
+
   <ItemGroup>
     <IntermediateAssembly Include="$(IntermediateOutputPath)$(TargetName)$(TargetExt)"/>
     <FinalDocFile Include="@(DocFileItem->'$(OutDir)%(Filename)%(Extension)')"/>
@@ -402,12 +406,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <PropertyGroup Condition="'$(_DebugSymbolsProduced)' == 'true' and '$(OutputType)' == 'winmdobj'">
     <WinMDExpOutputPdb Condition="'$(WinMDExpOutputPdb)' == ''">$(IntermediateOutputPath)$(TargetName).pdb</WinMDExpOutputPdb>
-    <_WinMDDebugSymbolsOutputPath>$(OutDir)$([System.IO.Path]::GetFileName('$(WinMDExpOutputPdb)'))</_WinMDDebugSymbolsOutputPath>
+    <_WinMDDebugSymbolsOutputPath>$([System.IO.Path]::Combine('$(OutDir)', $([System.IO.Path]::GetFileName('$(WinMDExpOutputPdb)'))))</_WinMDDebugSymbolsOutputPath>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(OutputType)' == 'winmdobj' and '$(DocumentationFile)'!=''">
     <WinMDOutputDocumentationFile Condition="'$(WinMDOutputDocumentationFile)' == ''">$(IntermediateOutputPath)$(TargetName).xml</WinMDOutputDocumentationFile>
-    <_WinMDDocFileOutputPath>$(OutDir)$([System.IO.Path]::GetFileName('$(WinMDOutputDocumentationFile)'))</_WinMDDocFileOutputPath>
+    <_WinMDDocFileOutputPath>$([System.IO.Path]::Combine('$(OutDir)', $([System.IO.Path]::GetFileName('$(WinMDOutputDocumentationFile)'))))</_WinMDDocFileOutputPath>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(WinMDExpOutputWindowsMetadataFilename)' != ''">
@@ -479,7 +483,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <!-- Output location for publish target. -->
   <PropertyGroup>
-    <PublishDir>$([MSBuild]::EnsureTrailingSlash($([MSBuild]::ValueOrDefault('$(PublishDir)', '$(OutputPath)app.publish'))))</PublishDir>
+    <PublishDir Condition="'$(PublishDir)' != '' and !HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
+    <PublishDir Condition="'$(PublishDir)'==''">$(OutputPath)app.publish\</PublishDir>
   </PropertyGroup>
 
   <!--
@@ -522,7 +527,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ProcessorArchitecture Condition="'$(ProcessorArchitecture)'==''">$(PROCESSOR_ARCHITECTURE)</ProcessorArchitecture>
   </PropertyGroup>
 
-
   <!-- Sensible defaults for the most-commonly-desired MSBuildRuntime and MSBuildArchitecture values. The Core and Mono runtimes do not currently support specifying task architecture or runtime.
        If support for out-of-proc task execution is added on other runtimes, make sure each task's logic is checked against the current state of support. -->
   <PropertyGroup Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' == 'Full'">
@@ -924,6 +928,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       PostBuildEvent
     </CoreBuildDependsOn>
   </PropertyGroup>
+
   <Target
       Name="CoreBuild"
       DependsOnTargets="$(CoreBuildDependsOn)">
@@ -941,7 +946,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
     -->
   <PropertyGroup>
-
     <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' != ''">$(MSBuildProjectDefaultTargets)</_ProjectDefaultTargets>
     <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' == ''">Build</_ProjectDefaultTargets>
 
@@ -1086,6 +1090,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <RunDependsOn></RunDependsOn>
   </PropertyGroup>
+
   <Target
       Name="Run"
       DependsOnTargets="$(RunDependsOn)">
@@ -1096,9 +1101,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -1117,6 +1119,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <BuildingProject>false</BuildingProject>
   </PropertyGroup>
+
   <Target
       Name="BuildOnlySettings">
     <PropertyGroup>
@@ -1124,9 +1127,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </PropertyGroup>
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -1145,6 +1145,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <PrepareForBuildDependsOn>$(PrepareForBuildDependsOn);GetFrameworkPaths;GetReferenceAssemblyPaths;AssignLinkMetadata</PrepareForBuildDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PrepareForBuild"
       DependsOnTargets="$(PrepareForBuildDependsOn)">
@@ -1253,6 +1254,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <PropertyGroup Condition="'$(_TargetFrameworkDirectories)' == ''">
       <TargetFrameworkProfile/>
     </PropertyGroup>
+
   </Target>
 
    <!-- Returns target framework moniker. E.g. ".NETFramework,Version=v4.0.1" -->
@@ -1280,6 +1282,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
     -->
   <Target Name="AssignLinkMetadata" Condition=" '$(SynthesizeLinkMetadata)' == 'true' ">
+
     <!-- NONE ITEMS -->
     <AssignLinkMetadata Items="@(None)"
                         Condition="'@(None)' != '' and '%(None.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
@@ -1304,7 +1307,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_Temp Remove="@(_Temp)" />
     </ItemGroup>
 
-
     <!-- PAGE ITEMS -->
     <AssignLinkMetadata Items="@(Page)"
                         Condition="'@(Page)' != '' and '%(Page.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
@@ -1317,7 +1319,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_Temp Remove="@(_Temp)" />
     </ItemGroup>
 
-
     <!-- APPLICATIONDEFINITION ITEMS -->
     <AssignLinkMetadata Items="@(ApplicationDefinition)"
                         Condition="'@(ApplicationDefinition)' != '' and '%(ApplicationDefinition.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
@@ -1341,6 +1342,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <EmbeddedResource Include="@(_Temp)" />
       <_Temp Remove="@(_Temp)" />
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -1361,6 +1363,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <PreBuildEventDependsOn></PreBuildEventDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PreBuildEvent"
       Condition="'$(PreBuildEvent)'!=''"
@@ -1370,9 +1373,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -1392,6 +1392,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <UnmanagedUnregistrationDependsOn></UnmanagedUnregistrationDependsOn>
   </PropertyGroup>
+
   <Target
       Name="UnmanagedUnregistration"
       Condition="(('$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)' or '$(RegisterForComInterop)' != 'true' or '$(OutputType)' != 'library') or
@@ -1416,16 +1417,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <UnregisterAssemblyMSBuildRuntime Condition="'$(UnregisterAssemblyMSBuildRuntime)' == ''">CurrentRuntime</UnregisterAssemblyMSBuildRuntime>
     </PropertyGroup>
 
-
     <UnregisterAssembly AssemblyListFile="@(_UnmanagedRegistrationCache)"
                         MSBuildArchitecture="$(UnregisterAssemblyMSBuildArchitecture)"
                         MSBuildRuntime="$(UnregisterAssemblyMSBuildRuntime)" />
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -1557,6 +1554,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <ReferenceOutputAssembly Condition="'%(ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == ''">true</ReferenceOutputAssembly>
       </ProjectReferenceWithConfiguration>
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -1784,21 +1782,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="Result"
         PropertyName="_AdditionalPropertiesFromProject"/>
     </CombineXmlElements>
-    
+
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
         <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
         <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
         <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
-
         <HasSingleTargetFramework>true</HasSingleTargetFramework>
-
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
         <IsRidAgnostic>false</IsRidAgnostic>
         <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
+
   </Target>
 
   <Target Name="GetTargetFrameworksWithPlatformForSingleTargetFramework"
@@ -1866,6 +1863,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       _GetProjectReferenceTargetFrameworkProperties
     </PrepareProjectReferencesDependsOn>
   </PropertyGroup>
+
   <Target Name="PrepareProjectReferences" DependsOnTargets="$(PrepareProjectReferencesDependsOn)" />
 
   <!--
@@ -2146,6 +2144,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       ExpandSDKReferences;
     </ResolveAssemblyReferencesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="ResolveAssemblyReferences"
       Returns="@(ReferencePath)"
@@ -2161,7 +2160,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         expensive to write the newly created cache file.
         -->
     <PropertyGroup>
-      <ResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectFile)AssemblyReference.cache</ResolveAssemblyReferencesStateFile>
+      <ResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>
     </PropertyGroup>
 
     <!-- Make an App.Config item that exists when AutoUnify is false. -->
@@ -2227,6 +2226,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         TargetFrameworkMonikerDisplayName="$(TargetFrameworkMonikerDisplayName)"
         TargetedRuntimeVersion="$(TargetedRuntimeVersion)"
         StateFile="$(ResolveAssemblyReferencesStateFile)"
+        AssemblyInformationCachePaths="$(AssemblyInformationCachePaths)"
+        AssemblyInformationCacheOutputPath="$(AssemblyInformationCacheOutputPath)"
         InstalledAssemblySubsetTables="@(InstalledAssemblySubsetTables)"
         TargetFrameworkSubsets="@(_ReferenceInstalledAssemblySubsets)"
         FullTargetFrameworkSubsetNames="$(FullReferenceAssemblyNames)"
@@ -2259,6 +2260,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="DependsOnNETStandard" PropertyName="_DependsOnNETStandard"/>
       <Output TaskParameter="UnresolvedAssemblyConflicts" ItemName="ResolveAssemblyReferenceUnresolvedAssemblyConflicts"/>
     </ResolveAssemblyReference>
+
   </Target>
 
   <!--
@@ -2323,9 +2325,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       OutputAppConfigFile="$(_GenerateBindingRedirectsIntermediateAppConfig)"
       SuggestedRedirects="@(SuggestedBindingRedirects)"
       >
-
       <Output TaskParameter="OutputAppConfigFile" ItemName="FileWrites" />
-
     </GenerateBindingRedirects>
 
   </Target>
@@ -2345,6 +2345,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <PropertyGroup>
       <AppConfig>$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
     </PropertyGroup>
+
     <ItemGroup>
       <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
       <AppConfigWithTargetPath Include="$(AppConfig)">
@@ -2469,7 +2470,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       Name="ResolveSDKReferences"
       Returns="@(ResolvedSDKReference)"
       DependsOnTargets="$(ResolveSDKReferencesDependsOn)">
-
     <ResolveSDKReference
            SDKReferences="@(SDKReference)"
            RuntimeReferenceOnlySDKDependencies="@(RuntimeReferenceOnlySDKDependencies)"
@@ -2544,7 +2544,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       BuildInParallel="$(BuildInParallel)"
       ContinueOnError="!$(BuildingProject)"
       RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
-
       <Output TaskParameter="TargetOutputs" ItemName="TargetPathWithTargetPlatformMoniker" />
     </MSBuild>
   </Target>
@@ -2617,7 +2616,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           Inputs="@(IntermediateAssembly);@(DocFileItem);@(_DebugSymbolsIntermediatePath);@(ReferencePathWithRefAssemblies);$(MSBuildAllProjects)"
           Outputs="$(_IntermediateWindowsMetadataPath);$(WinMDExpOutputPdb);$(WinMDOutputDocumentationFile)"
   >
-
       <PropertyGroup>
         <!-- Will be copied by the "copy WinMD artifacts" step instead -->
         <CopyBuildOutputToOutputDirectory>false</CopyBuildOutputToOutputDirectory>
@@ -2650,6 +2648,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          <WinMDExpArtifacts Include="$(WinMDExpOutputPdb)"/>
          <FileWrites Include="$(WinMDOutputDocumentationFile);$(WinMDExpOutputPdb)"/>
     </ItemGroup>
+
   </Target>
 
   <Target
@@ -2661,6 +2660,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup>
       <_ReferencesFromRAR Include="@(ReferencePath->WithMetadataValue('ReferenceSourceTarget', 'ResolveAssemblyReference'))"/>
     </ItemGroup>
+
   </Target>
 
   <PropertyGroup>
@@ -2687,7 +2687,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         [IN]
         @(DesignTimeReference) - List of assembly references as simple/fusion names.
 
-
         [OUT]
         @(ReferencePath) - Paths to resolved primary files.
 
@@ -2778,6 +2777,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="ResolvedFiles" ItemName="DesignTimeReferencePath"/>
       <Output TaskParameter="FilesWritten" ItemName="FileWrites"/>
     </ResolveAssemblyReference>
+
   </Target>
 
   <!--
@@ -2897,6 +2897,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       CompileLicxFiles
     </PrepareResourcesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PrepareResources"
       DependsOnTargets="$(PrepareResourcesDependsOn)"/>
@@ -2916,6 +2917,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       CreateCustomManifestResourceNames
     </PrepareResourceNamesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PrepareResourceNames"
       DependsOnTargets="$(PrepareResourceNamesDependsOn)"/>
@@ -2931,6 +2933,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <AssignTargetPathsDependsOn></AssignTargetPathsDependsOn>
   </PropertyGroup>
+
   <Target
       Name="AssignTargetPaths"
       DependsOnTargets="$(AssignTargetPathsDependsOn)">
@@ -2944,7 +2947,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="AssignedFiles" ItemName="_Temporary" />
     </AssignTargetPath>
 
-
     <ItemGroup>
       <!-- Replace items in EmbeddedResource with the items emitted by the AssignTargetPath task that have the TargetPath metadata -->
       <EmbeddedResource Remove="@(_Temporary)" />
@@ -3075,6 +3077,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <CreateCustomManifestResourceNamesDependsOn></CreateCustomManifestResourceNamesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="CreateCustomManifestResourceNames"
       DependsOnTargets="$(CreateCustomManifestResourceNamesDependsOn)"/>
@@ -3093,6 +3096,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <UseSourcePath Condition="'$(UseSourcePath)'==''">true</UseSourcePath>
     <ResGenExecuteAsTool Condition="'$(ResGenExecuteAsTool)'==''">false</ResGenExecuteAsTool>
   </PropertyGroup>
+
   <Target
       Name="ResGen"
       DependsOnTargets="$(ResGenDependsOn)"/>
@@ -3255,6 +3259,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <CompileLicxFilesDependsOn></CompileLicxFilesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="CompileLicxFiles"
       Condition="'@(_LicxFile)'!=''"
@@ -3287,9 +3292,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -3366,6 +3368,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       AfterCompile;
     </CompileDependsOn>
   </PropertyGroup>
+
   <Target
       Name="Compile"
       DependsOnTargets="$(CompileDependsOn)"/>
@@ -3412,7 +3415,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup Condition="'$(TargetFrameworkMoniker)' != ''">
     <!-- Do not clean if we are going to default the path to the temp directory -->
     <TargetFrameworkMonikerAssemblyAttributesFileClean Condition="'$(TargetFrameworkMonikerAssemblyAttributesFileClean)' == '' and '$(TargetFrameworkMonikerAssemblyAttributesPath)' != ''">true</TargetFrameworkMonikerAssemblyAttributesFileClean>
-    <TargetFrameworkMonikerAssemblyAttributesPath Condition="'$(TargetFrameworkMonikerAssemblyAttributesPath)' == ''">$(IntermediateOutputPath)$(TargetFrameworkMoniker).AssemblyAttributes$(DefaultLanguageSourceExtension)</TargetFrameworkMonikerAssemblyAttributesPath>
+    <TargetFrameworkMonikerAssemblyAttributesPath Condition="'$(TargetFrameworkMonikerAssemblyAttributesPath)' == ''">$([System.IO.Path]::Combine('$(IntermediateOutputPath)','$(TargetFrameworkMoniker).AssemblyAttributes$(DefaultLanguageSourceExtension)'))</TargetFrameworkMonikerAssemblyAttributesPath>
   </PropertyGroup>
 
   <PropertyGroup>
@@ -3444,8 +3447,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Compile Include="$(TargetFrameworkMonikerAssemblyAttributesPath)"/>
       <!-- Do not put in FileWrites: this is a file shared between projects in %temp%, and cleaning it would create a race between projects during rebuild -->
     </ItemGroup>
-  </Target>
 
+  </Target>
 
   <!--
     ============================================================
@@ -3473,7 +3476,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           AssemblyAttributes="@(AssemblyAttributes)"
           OutputFile="$(AssemblyAttributesPath)"
           Language="$(Language)">
-
       <Output TaskParameter="OutputFile" ItemName="Compile"/>
       <Output TaskParameter="OutputFile" ItemName="FileWrites"/>
     </WriteCodeFragment>
@@ -3595,9 +3597,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -3689,6 +3688,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       GenerateSatelliteAssemblies
     </CreateSatelliteAssembliesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="CreateSatelliteAssemblies"
       DependsOnTargets="$(CreateSatelliteAssembliesDependsOn)" />
@@ -3721,6 +3721,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </_SatelliteAssemblyResourceInputs>
 
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -3735,6 +3736,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           Outputs="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll"
           Condition="'@(_SatelliteAssemblyResourceInputs)' != '' and '$(GenerateSatelliteAssembliesForCore)' != 'true'">
 
+    <PropertyGroup>
+      <_ALExeToolPath>$(TargetFrameworkSDKToolsDirectory)</_ALExeToolPath>
+      <_ALExeToolPath Condition="'$(PlatformTarget)' == 'x64'">$(TargetFrameworkSDKToolsDirectory)$(PlatformTarget)\</_ALExeToolPath>
+    </PropertyGroup>
+
     <MakeDir
         Directories="@(EmbeddedResource->'$(IntermediateOutputPath)%(Culture)')" />
 
@@ -3767,7 +3773,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Title="$(Satellite_Title)"
         ToolPath="$(AlToolPath)"
         ToolExe ="$(AlToolExe)"
-        SdkToolsPath="$(TargetFrameworkSDKToolsDirectory)"
+        SdkToolsPath="$(SdkToolsPathMaybeWithx64Architecture)"
         Trademark="$(Satellite_Trademark)"
         Version="$(Satellite_Version)"
         Win32Icon="$(Satellite_Win32Icon)"
@@ -3791,6 +3797,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       CreateManifestResourceNames
     </ComputeIntermediateSatelliteAssembliesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="ComputeIntermediateSatelliteAssemblies"
       Condition="@(EmbeddedResource->'%(WithCulture)') != ''"
@@ -3803,6 +3810,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <TargetPath>%(EmbeddedResource.Culture)\$(TargetName).resources.dll</TargetPath>
       </IntermediateSatelliteAssembliesWithTargetPath>
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -3869,9 +3877,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -3905,6 +3910,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     -->
   <Target
       Name="_GenerateResolvedDeploymentManifestEntryPoint">
+
     <ItemGroup>
       <_DeploymentPublishFileOfTypeManifestEntryPoint Include="@(PublishFile)" Condition="'%(FileType)'=='ManifestEntryPoint'"/>
     </ItemGroup>
@@ -3915,10 +3921,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         SigningManifests="$(SignManifests)"
         DeploymentManifestEntryPoint="@(ApplicationManifest)"
         PublishFiles="@(_DeploymentPublishFileOfTypeManifestEntryPoint)">
-
       <Output TaskParameter="OutputDeploymentManifestEntryPoint" ItemName="_DeploymentResolvedDeploymentManifestEntryPoint"/>
-
     </ResolveManifestFiles>
+
   </Target>
 
   <Target
@@ -4124,6 +4129,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_DeploymentManifestEntryPoint Remove="@(_DeploymentManifestEntryPoint)"/>
       <_DeploymentManifestEntryPoint Include="@(_DeploymentManifestLauncherEntryPoint)"/>
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -4208,16 +4214,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Include the following files in clickonce manifest only if single file publish is false -->
     <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
-      <!-- 
-      _ClickOnceRuntimeCopyLocalItems group contains any runtimes folder assets of Nuget packages that are not included in 
-      _DeploymentReferencePaths (e.g. pdbs). They are populated from the RuntimeTargetsCopyLocalItems and NativeCopyLocalItems 
-      group that contain the RID-specific assets that go in runtimes folder on publish. They are output groups of the 
+      <!--
+      _ClickOnceRuntimeCopyLocalItems group contains any runtimes folder assets of Nuget packages that are not included in
+      _DeploymentReferencePaths (e.g. pdbs). They are populated from the RuntimeTargetsCopyLocalItems and NativeCopyLocalItems
+      group that contain the RID-specific assets that go in runtimes folder on publish. They are output groups of the
       ResolvePackageAssets target in dotnet/sdk
       -->
       <_ClickOnceRuntimeCopyLocalItems Include="@(RuntimeTargetsCopyLocalItems)"
                                       Condition="'%(RuntimeTargetsCopyLocalItems.CopyLocal)' == 'true'" />
 
-      <_ClickOnceRuntimeCopyLocalItems Include="@(NativeCopyLocalItems)" 
+      <_ClickOnceRuntimeCopyLocalItems Include="@(NativeCopyLocalItems)"
                                       Condition="'%(NativeCopyLocalItems.CopyLocal)' == 'true'" />
       <_ClickOnceRuntimeCopyLocalItems Remove="@(_DeploymentReferencePaths)" />
       <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems)"/>
@@ -4239,6 +4245,27 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(_DeploymentLauncherBased)' == 'true' and '$(PublishSingleFile)' == 'true'"
       />
 
+    <!--
+    If ReadyToRun is enabled in loose files scenario, we need to remove entries of the IL images that have gone through R2R
+    compiler and replace them with the entries for their R2R images. The R2R application image also needs to be signed if necessary.
+    -->
+
+    <ItemGroup Condition="'$(PublishReadyToRun)' == 'true' and '$(PublishSingleFile)' != 'true'">
+      <_ManifestManagedReferences Remove="@(_ReadyToRunCompileList)" />
+      <_ClickOnceFiles Remove="@(_ReadyToRunCompileList)" />
+      <_ClickOnceFiles Include="@(_ReadyToRunFilesToPublish)" />
+      <_ClickOnceTargetFile Include="@(_ReadyToRunFilesToPublish)" Condition="'%(Filename)%(Extension)' == '$(TargetFileName)'" />
+    </ItemGroup>
+
+    <!-- Sign application image created by R2R -->
+    <SignFile
+        CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)"
+        TimestampUrl="$(ManifestTimestampUrl)"
+        SigningTarget="@(_ClickOnceTargetFile)"
+        TargetFrameworkVersion="$(TargetFrameworkVersion)"
+        TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
+        Condition="'$(_DeploymentSignClickOnceManifests)' == 'true' and '$(PublishReadyToRun)' == 'true' and '$(PublishSingleFile)' != 'true'" />
+
     <!-- Copy the application executable from Obj folder to app.publish folder.
     This is being done to avoid Windows Forms designer memory issues that can arise while operating directly on files located in Obj directory. -->
     <Copy
@@ -4404,9 +4431,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -4432,6 +4456,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       CopyFilesToOutputDirectory
     </PrepareForRunDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PrepareForRun"
       DependsOnTargets="$(PrepareForRunDependsOn)"/>
@@ -4629,7 +4654,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="DestinationFiles" ItemName="FinalWinmdExpArtifacts" />
     </Copy>
 
-    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; $([MSBuild]::NormalizePath('$(_WindowsMetadataOutputPath)'))" Condition="'$(SkipCopyWinMDArtifact)' != 'true' and '$(_WindowsMetadataOutputPath)' != ''" />
+    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; $([System.IO.Path]::GetFullPath('$(_WindowsMetadataOutputPath)'))" Condition="'$(SkipCopyWinMDArtifact)' != 'true' and '$(_WindowsMetadataOutputPath)' != ''" />
 
   </Target>
 
@@ -4691,8 +4716,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
             GetCopyToOutputDirectoryItems;
             _CopyOutOfDateSourceItemsToOutputDirectory;
             _CopyOutOfDateSourceItemsToOutputDirectoryAlways"/>
-
-
   <!--
     ============================================================
                                         GetCopyToOutputDirectoryItems
@@ -4919,6 +4942,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <CopyToPublishDirectory>%(CopyToOutputDirectory)</CopyToPublishDirectory>
       </AllPublishItemsFullPathWithTargetPath>
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -5103,6 +5127,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup>
       <FileWrites Include="@(_DebugSymbolsIntermediatePath)" Condition="'$(_DebugSymbolsProduced)'=='true'"/>
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -5129,9 +5154,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -5150,6 +5172,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <UnmanagedRegistrationDependsOn></UnmanagedRegistrationDependsOn>
   </PropertyGroup>
+
   <Target
       Name="UnmanagedRegistration"
       Condition="'$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library'"
@@ -5185,11 +5208,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup>
       <FileWrites Include="@(_OutputPathItem->'%(FullPath)$(TargetName).tlb')"/>
     </ItemGroup>
-  </Target>
-
-
-
 
+  </Target>
 
   <!--
     ***********************************************************************************************
@@ -5417,6 +5437,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <CoreCleanDependsOn></CoreCleanDependsOn>
   </PropertyGroup>
+
   <Target
       Name="CoreClean"
       DependsOnTargets="$(CoreCleanDependsOn)">
@@ -5515,9 +5536,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -5548,6 +5566,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <PostBuildEventDependsOn></PostBuildEventDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PostBuildEvent"
       Condition="'$(PostBuildEvent)' != '' and ('$(RunPostBuildEvent)' != 'OnOutputUpdated' or '$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)')"
@@ -5557,9 +5576,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -5585,6 +5601,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       _DeploymentUnpublishable
     </PublishDependsOn>
   </PropertyGroup>
+
   <Target
       Name="Publish"
       DependsOnTargets="$(PublishDependsOn)"/>
@@ -5644,6 +5661,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       AfterPublish
     </PublishOnlyDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PublishOnly"
       DependsOnTargets="$(PublishOnlyDependsOn)"/>
@@ -5684,6 +5702,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       CreateSatelliteAssemblies;
     </PublishBuildDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PublishBuild"
       DependsOnTargets="$(PublishBuildDependsOn)"/>
@@ -5861,8 +5880,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         TimestampUrl="$(ManifestTimestampUrl)"
         SigningTarget="$(PublishDir)\setup.exe"
         Condition="'$(BootstrapperEnabled)'=='true' and '$(_DeploymentSignClickOnceManifests)'=='true'" />
-  </Target>
 
+  </Target>
 
   <!--
     ***********************************************************************************************
@@ -5931,6 +5950,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <BuiltProjectOutputGroupDependsOn>PrepareForBuild</BuiltProjectOutputGroupDependsOn>
     <AddAppConfigToBuildOutputs Condition="('$(AddAppConfigToBuildOutputs)'=='') and ('$(OutputType)'!='library' and '$(OutputType)'!='winmdobj')">true</AddAppConfigToBuildOutputs>
   </PropertyGroup>
+
   <Target
       Name="BuiltProjectOutputGroup"
       Returns="@(BuiltProjectOutputGroupOutput)"
@@ -5984,12 +6004,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <DebugSymbolsProjectOutputGroupDependsOn></DebugSymbolsProjectOutputGroupDependsOn>
   </PropertyGroup>
+
   <ItemGroup Condition="'$(_DebugSymbolsProduced)' != 'false' and '$(OutputType)' != 'winmdobj'">
     <DebugSymbolsProjectOutputGroupOutput Include="@(_DebugSymbolsIntermediatePath->'%(FullPath)')">
       <FinalOutputPath>@(_DebugSymbolsOutputPath->'%(FullPath)')</FinalOutputPath>
       <TargetPath>@(_DebugSymbolsIntermediatePath->'%(Filename)%(Extension)')</TargetPath>
     </DebugSymbolsProjectOutputGroupOutput>
   </ItemGroup>
+
   <ItemGroup Condition="'$(_DebugSymbolsProduced)' != 'false' and '$(OutputType)' == 'winmdobj'">
     <WinMDExpOutputPdbItem Include="$(WinMDExpOutputPdb)" Condition="'$(WinMDExpOutputPdb)' != ''" />
     <WinMDExpFinalOutputPdbItem Include="$(_WinMDDebugSymbolsOutputPath)" Condition="'$(_WinMDDebugSymbolsOutputPath)' != ''" />
@@ -5998,6 +6020,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <TargetPath>@(WinMDExpOutputPdbItem->'%(Filename)%(Extension)')</TargetPath>
     </DebugSymbolsProjectOutputGroupOutput>
   </ItemGroup>
+
   <Target
       Name="DebugSymbolsProjectOutputGroup"
       Returns="@(DebugSymbolsProjectOutputGroupOutput)"
@@ -6013,6 +6036,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <DocumentationProjectOutputGroupDependsOn></DocumentationProjectOutputGroupDependsOn>
   </PropertyGroup>
+
   <ItemGroup Condition="'$(DocumentationFile)'!='' and '$(OutputType)' != 'winmdobj'">
     <DocumentationProjectOutputGroupOutput Include="@(DocFileItem->'%(FullPath)')">
       <FinalOutputPath>@(FinalDocFile->'%(FullPath)')</FinalOutputPath>
@@ -6020,6 +6044,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <TargetPath>@(DocFileItem->'%(Filename)%(Extension)')</TargetPath>
     </DocumentationProjectOutputGroupOutput>
   </ItemGroup>
+
   <ItemGroup Condition="'$(DocumentationFile)' != '' and '$(OutputType)' == 'winmdobj'">
     <WinMDOutputDocumentationFileItem Include="$(WinMDOutputDocumentationFile)" Condition="'$(WinMDOutputDocumentationFile)' != ''" />
     <WinMDExpFinalOutputDocItem Include="$(_WinMDDocFileOutputPath)" Condition="'$(_WinMDDocFileOutputPath)' != ''" />
@@ -6028,6 +6053,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <TargetPath>@(WinMDOutputDocumentationFileItem->'%(Filename)%(Extension)')</TargetPath>
     </DocumentationProjectOutputGroupOutput>
   </ItemGroup>
+
   <Target
       Name="DocumentationProjectOutputGroup"
       Returns="@(DocumentationProjectOutputGroupOutput)"
@@ -6043,6 +6069,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <SatelliteDllsProjectOutputGroupDependsOn>PrepareForBuild;PrepareResourceNames</SatelliteDllsProjectOutputGroupDependsOn>
   </PropertyGroup>
+
   <Target
       Name="SatelliteDllsProjectOutputGroup"
       Returns="@(SatelliteDllsProjectOutputGroupOutput)"
@@ -6078,6 +6105,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <SourceFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</SourceFilesProjectOutputGroupDependsOn>
   </PropertyGroup>
+
   <Target
       Name="SourceFilesProjectOutputGroup"
       Returns="@(SourceFilesProjectOutputGroupOutput)"
@@ -6115,6 +6143,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <ContentFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</ContentFilesProjectOutputGroupDependsOn>
   </PropertyGroup>
+
   <Target
       Name="ContentFilesProjectOutputGroup"
       Returns="@(ContentFilesProjectOutputGroupOutput)"
@@ -6138,6 +6167,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <SGenFilesOutputGroupDependsOn></SGenFilesOutputGroupDependsOn>
   </PropertyGroup>
+
   <ItemGroup
       Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')">
     <SGenFilesOutputGroupOutput Include="@(_OutputPathItem->'%(FullPath)$(_SGenDllName)')">
@@ -6145,6 +6175,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <TargetPath>$(_SGenDllName)</TargetPath>
     </SGenFilesOutputGroupOutput>
   </ItemGroup>
+
   <Target
       Name="SGenFilesOutputGroup"
       Returns="@(SGenFilesOutputGroupOutput)"
diff --git a/src/Tasks/Microsoft.Common.overridetasks b/src/Tasks/Microsoft.Common.overridetasks
index 730d63c037c..f9bc7334290 100644
--- a/src/Tasks/Microsoft.Common.overridetasks
+++ b/src/Tasks/Microsoft.Common.overridetasks
@@ -1,30 +1,39 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 
-    <!-- This file lists UsingTask elements that we wish to override 
+    <!-- This file lists UsingTask elements that we wish to override
          any other UsingTask elements -->
-    
+
     <!-- NOTE: Listing a <UsingTask> tag in a *.tasks file like this one rather than in a project or targets file
                can give a significant performance advantage in a large build, because every time a <UsingTask> tag
                is encountered, it will cause the task to be rediscovered next time the task is used. -->
     <!-- NOTE: Using the fully qualified class name in a <UsingTask> tag is faster than using a partially qualified name. -->
 
     <UsingTask TaskName="Microsoft.Build.Tasks.ResolveComReference"  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5'" />
+
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"     AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+
     <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
     <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"     AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+
     <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
     <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"   AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+
     <UsingTask TaskName="ResolveComReference"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0'" />
+
     <UsingTask TaskName="GenerateResource"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
     <UsingTask TaskName="GenerateResource"                           AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+
     <UsingTask TaskName="RegisterAssembly"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
     <UsingTask TaskName="RegisterAssembly"                           AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+
     <UsingTask TaskName="UnregisterAssembly"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
     <UsingTask TaskName="UnregisterAssembly"                         AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+
     <UsingTask TaskName="ReadLinesFromFile"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
     <UsingTask TaskName="FindUnderPath"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
     <UsingTask TaskName="ConvertToAbsolutePath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
     <UsingTask TaskName="MSBuild"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
     <UsingTask TaskName="ResolveAssemblyReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '4.0'" />
+
 </Project>
diff --git a/src/Tasks/Microsoft.Common.props b/src/Tasks/Microsoft.Common.props
index 942daa68814..32f5f05ab9f 100644
--- a/src/Tasks/Microsoft.Common.props
+++ b/src/Tasks/Microsoft.Common.props
@@ -11,6 +11,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
   <PropertyGroup>
     <ImportByWildcardBeforeMicrosoftCommonProps Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == ''">true</ImportByWildcardBeforeMicrosoftCommonProps>
     <ImportByWildcardAfterMicrosoftCommonProps Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == ''">true</ImportByWildcardAfterMicrosoftCommonProps>
@@ -19,22 +20,22 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ImportDirectoryBuildProps Condition="'$(ImportDirectoryBuildProps)' == ''">true</ImportDirectoryBuildProps>
   </PropertyGroup>
 
-  <!-- 
+  <!--
         Determine the path to the directory build props file if the user did not disable $(ImportDirectoryBuildProps) and
         they did not already specify an absolute path to use via $(DirectoryBuildPropsPath)
     -->
   <PropertyGroup Condition="'$(ImportDirectoryBuildProps)' == 'true' and '$(DirectoryBuildPropsPath)' == ''">
     <_DirectoryBuildPropsFile Condition="'$(_DirectoryBuildPropsFile)' == ''">Directory.Build.props</_DirectoryBuildPropsFile>
     <_DirectoryBuildPropsBasePath Condition="'$(_DirectoryBuildPropsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildPropsFile)'))</_DirectoryBuildPropsBasePath>
-    <DirectoryBuildPropsPath Condition="'$(_DirectoryBuildPropsBasePath)' != '' and '$(_DirectoryBuildPropsFile)' != ''">$([MSBuild]::NormalizePath('$(_DirectoryBuildPropsBasePath)', '$(_DirectoryBuildPropsFile)'))</DirectoryBuildPropsPath>
+    <DirectoryBuildPropsPath Condition="'$(_DirectoryBuildPropsBasePath)' != '' and '$(_DirectoryBuildPropsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildPropsBasePath)', '$(_DirectoryBuildPropsFile)'))</DirectoryBuildPropsPath>
   </PropertyGroup>
 
   <Import Project="$(DirectoryBuildPropsPath)" Condition="'$(ImportDirectoryBuildProps)' == 'true' and exists('$(DirectoryBuildPropsPath)')"/>
 
-  <!-- 
+  <!--
         Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
           $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.props
-          
+
         Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
         management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
     -->
@@ -43,28 +44,30 @@ Copyright (C) Microsoft Corporation. All rights reserved.
             The declaration of $(BaseIntermediateOutputPath) had to be moved up from Microsoft.Common.CurrentVersion.targets
             in order for the $(MSBuildProjectExtensionsPath) to use it as a default.
         -->
-    <BaseIntermediateOutputPath>$([MSBuild]::EnsureTrailingSlash($([MSBuild]::ValueOrDefault('$(BaseIntermediateOutputPath)', 'obj'))))</BaseIntermediateOutputPath>
+    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)'=='' ">obj\</BaseIntermediateOutputPath>
+    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
     <_InitialBaseIntermediateOutputPath>$(BaseIntermediateOutputPath)</_InitialBaseIntermediateOutputPath>
 
-    <MSBuildProjectExtensionsPath>$([MSBuild]::EnsureTrailingSlash($([MSBuild]::ValueOrDefault('$(MSBuildProjectExtensionsPath)', '$(BaseIntermediateOutputPath)'))))</MSBuildProjectExtensionsPath>
+    <MSBuildProjectExtensionsPath Condition="'$(MSBuildProjectExtensionsPath)' == '' ">$(BaseIntermediateOutputPath)</MSBuildProjectExtensionsPath>
     <!--
         Import paths that are relative default to be relative to the importing file.  However, since MSBuildExtensionsPath
         defaults to BaseIntermediateOutputPath we expect it to be relative to the project directory.  So if the path is relative
         it needs to be made absolute based on the project directory.
       -->
-    <MSBuildProjectExtensionsPath Condition="!$([System.IO.Path]::IsPathRooted('$(MSBuildProjectExtensionsPath)'))">$([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)', '$(MSBuildProjectExtensionsPath)'))</MSBuildProjectExtensionsPath>
+    <MSBuildProjectExtensionsPath Condition="'$([System.IO.Path]::IsPathRooted($(MSBuildProjectExtensionsPath)))' == 'false'">$([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(MSBuildProjectExtensionsPath)'))</MSBuildProjectExtensionsPath>
+    <MSBuildProjectExtensionsPath Condition="!HasTrailingSlash('$(MSBuildProjectExtensionsPath)')">$(MSBuildProjectExtensionsPath)\</MSBuildProjectExtensionsPath>
     <ImportProjectExtensionProps Condition="'$(ImportProjectExtensionProps)' == ''">true</ImportProjectExtensionProps>
     <_InitialMSBuildProjectExtensionsPath Condition=" '$(ImportProjectExtensionProps)' == 'true' ">$(MSBuildProjectExtensionsPath)</_InitialMSBuildProjectExtensionsPath>
   </PropertyGroup>
 
   <Import Project="$(MSBuildProjectExtensionsPath)$(MSBuildProjectFile).*.props" Condition="'$(ImportProjectExtensionProps)' == 'true' and exists('$(MSBuildProjectExtensionsPath)')" />
 
-  <!-- 
+  <!--
         Import wildcard "ImportBefore" props files if we're actually in a 12.0+ project (rather than a project being
         treated as 4.0)
     -->
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' != ''">
-    <!-- 
+    <!--
             Wildcard imports come from $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props.d folder.
             This is very similar to the same extension point used in Microsoft.Common.targets, which is located in
             the $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ directory. Unfortunately, there
@@ -75,34 +78,34 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')"/>
   </ImportGroup>
 
-  <!-- 
-        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
-        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
-        just used whatever ToolsVersion was in the project file if it existed on the machine, and 
-        only forced 4.0 if that ToolsVersion did not exist.  
+  <!--
+        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed
+        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead
+        just used whatever ToolsVersion was in the project file if it existed on the machine, and
+        only forced 4.0 if that ToolsVersion did not exist.
 
-        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
-        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
-        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
-        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
+        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio,
+        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected
+        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved
+        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist
         as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
-        targets. 
+        targets.
    -->
   <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == '' and ('$(VisualStudioVersion)' != '' and '$(VisualStudioVersion)' &gt;= '12.0')">
     <!--
-           Reset VisualStudioVersion if it's 12.0+: Should be 10.0 if VS 2010 is installed or 11.0 otherwise, 
-           but since we don't have a good way of telling whether VS 2010 is installed, make it 11.0 if 
-           VS 2012 is installed or 10.0 otherwise.  The reset should be safe because if it was already 
-           set to something (e.g. 11.0 in a VS 2012 command prompt) then MSBuild's internal 
-           VisualStudioVersion-defaulting code should never come into the picture, so the only way it could 
-           be 12.0+ when building a TV 12.0 project (because we're in this file) using MSBuild 4.5 (because 
-           MSBuildAssemblyVersion hasn't been set) is if it's a TV 12.0 project on an empty command prompt. 
+           Reset VisualStudioVersion if it's 12.0+: Should be 10.0 if VS 2010 is installed or 11.0 otherwise,
+           but since we don't have a good way of telling whether VS 2010 is installed, make it 11.0 if
+           VS 2012 is installed or 10.0 otherwise.  The reset should be safe because if it was already
+           set to something (e.g. 11.0 in a VS 2012 command prompt) then MSBuild's internal
+           VisualStudioVersion-defaulting code should never come into the picture, so the only way it could
+           be 12.0+ when building a TV 12.0 project (because we're in this file) using MSBuild 4.5 (because
+           MSBuildAssemblyVersion hasn't been set) is if it's a TV 12.0 project on an empty command prompt.
       -->
     <VisualStudioVersion Condition="Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props')">11.0</VisualStudioVersion>
     <VisualStudioVersion Condition="!Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props')">10.0</VisualStudioVersion>
   </PropertyGroup>
 
-  <!-- If building using 4.X MSBuild, we want to act like this project is TV 4.0, so override 
+  <!-- If building using 4.X MSBuild, we want to act like this project is TV 4.0, so override
          the custom extensibility target locations with the hard-coded 4.0 equivalent. -->
   <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <CustomBeforeMicrosoftCommonProps Condition="'$(CustomBeforeMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v4.0\Custom.Before.$(MSBuildThisFile)</CustomBeforeMicrosoftCommonProps>
@@ -110,7 +113,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <!-- If building using 4.X MSBuild, we want to act like this project is TV 4.0, so import
-         Microsoft.Common.props from the 4.0 location, and make sure everything else in here is 
+         Microsoft.Common.props from the 4.0 location, and make sure everything else in here is
          set up such that if it's defaulted to something there, it won't be overridden here. -->
   <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props" Condition="'$(MSBuildAssemblyVersion)' == '' and Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props')" />
 
@@ -119,15 +122,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <CustomAfterMicrosoftCommonProps Condition="'$(CustomAfterMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.$(MSBuildThisFile)</CustomAfterMicrosoftCommonProps>
   </PropertyGroup>
 
-  <!-- 
-         Only import the extension targets if we're actually in a 12.0 project here (rather than one we're attempting 
-         to treat as 4.0) OR if the Dev11 Microsoft.Common.props don't exist.  If it's a 12.0 project we're redirecting 
-         to 4.0 and the Dev11 Microsoft.Common.props do exist, the extension targets will have been imported already 
+  <!--
+         Only import the extension targets if we're actually in a 12.0 project here (rather than one we're attempting
+         to treat as 4.0) OR if the Dev11 Microsoft.Common.props don't exist.  If it's a 12.0 project we're redirecting
+         to 4.0 and the Dev11 Microsoft.Common.props do exist, the extension targets will have been imported already
          so there's no need to import them twice.
      -->
   <Import Project="$(CustomBeforeMicrosoftCommonProps)" Condition="'$(CustomBeforeMicrosoftCommonProps)' != '' and Exists('$(CustomBeforeMicrosoftCommonProps)') and ('$(MSBuildAssemblyVersion)' != '' or !Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props'))" />
 
-  <!-- This is used to determine whether Microsoft.Common.targets needs to import 
+  <!-- This is used to determine whether Microsoft.Common.targets needs to import
          Microsoft.Common.props itself, or whether it has been imported previously,
          e.g. by the project itself. -->
   <PropertyGroup>
@@ -146,15 +149,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualStudioVersion.v*.Common.props" Condition="'$(VisualStudioVersion)' == ''" />
 
-  <!-- 
-         Only import the extension targets if we're actually in a 12.0 project here (rather than one we're attempting 
-         to treat as 4.0) OR if the Dev11 Microsoft.Common.props don't exist.  If it's a 12.0 project we're redirecting 
-         to 4.0 and the Dev11 Microsoft.Common.props do exist, the extension targets will have been imported already 
+  <!--
+         Only import the extension targets if we're actually in a 12.0 project here (rather than one we're attempting
+         to treat as 4.0) OR if the Dev11 Microsoft.Common.props don't exist.  If it's a 12.0 project we're redirecting
+         to 4.0 and the Dev11 Microsoft.Common.props do exist, the extension targets will have been imported already
          so there's no need to import them twice.
      -->
   <Import Project="$(CustomAfterMicrosoftCommonProps)" Condition="'$(CustomAfterMicrosoftCommonProps)' != '' and Exists('$(CustomAfterMicrosoftCommonProps)') and ('$(MSBuildAssemblyVersion)' != '' or !Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props'))" />
 
-  <!-- 
+  <!--
         Import wildcard "ImportAfter" props files if we're actually in a 12.0+ project (rather than a project being
         treated as 4.0)
     -->
@@ -163,7 +166,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')"/>
   </ImportGroup>
 
-  <!-- 
+  <!--
         Import NuGet.props file.
     -->
   <PropertyGroup>
@@ -171,6 +174,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <NuGetPropsFile Condition="'$(NuGetPropsFile)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.props</NuGetPropsFile>
     <NuGetPropsFile Condition="'$(NuGetPropsFile)'==''">$(MSBuildToolsPath)\NuGet.props</NuGetPropsFile>
   </PropertyGroup>
+
   <Import Condition="Exists('$(NuGetPropsFile)')" Project="$(NuGetPropsFile)" />
 
   <PropertyGroup Condition=" '$(MSBuildLogVerboseTaskParameters)' != 'true' ">
@@ -188,4 +192,5 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>true</DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>
     <DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>true</DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>
   </PropertyGroup>
+
 </Project>
diff --git a/src/Tasks/Microsoft.Common.targets b/src/Tasks/Microsoft.Common.targets
index b3e9be1fa09..753dad7cfaf 100644
--- a/src/Tasks/Microsoft.Common.targets
+++ b/src/Tasks/Microsoft.Common.targets
@@ -15,18 +15,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <!-- 
-       In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
-       as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
-       just used whatever ToolsVersion was in the project file if it existed on the machine, and 
-       only forced 4.0 if that ToolsVersion did not exist.  
-
-       Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
-       but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
-       the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
-       property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
+
+  <!--
+       In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed
+       as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead
+       just used whatever ToolsVersion was in the project file if it existed on the machine, and
+       only forced 4.0 if that ToolsVersion did not exist.
+
+       Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio,
+       but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected
+       the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved
+       property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist
        as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
-       targets. 
+       targets.
    -->
 
   <Choose>
@@ -43,13 +44,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </Choose>
 
   <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
-     <!-- 
-          Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify 
-          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. 
+     <!--
+          Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify
+          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default.
 
-          NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.CSharp.targets because those two files 
-          import Microsoft.Common.targets from the current directory and thus don't get the benefit of the redirections, so for 
-          any changes to this logic in this file, please also edit the other two. 
+          NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.CSharp.targets because those two files
+          import Microsoft.Common.targets from the current directory and thus don't get the benefit of the redirections, so for
+          any changes to this logic in this file, please also edit the other two.
       -->
     <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">$(ImportByWildcardBeforeMicrosoftCommonTargets)</ImportByWildcardBefore40MicrosoftCommonTargets>
     <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">true</ImportByWildcardBefore40MicrosoftCommonTargets>
@@ -73,15 +74,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == '' and ('$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight' or ('$(TargetFrameworkIdentifier)' == '' and ('$(TargetRuntime)' == 'Managed' or '$(TargetRuntime)' == '')))">
-     <!-- 
-          Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify 
-          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because 
-          Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its 
-          own redirection targets. 
-
-          NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.CSharp.targets because those two files 
-          import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either, 
-          so for any changes to this logic in this file, please also edit the other two. 
+     <!--
+          Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify
+          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because
+          Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its
+          own redirection targets.
+
+          NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.CSharp.targets because those two files
+          import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either,
+          so for any changes to this logic in this file, please also edit the other two.
       -->
     <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">$(ImportByWildcardBeforeMicrosoftNetFrameworkProps)</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
     <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">true</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
@@ -104,7 +105,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')"/>
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')"/>
@@ -116,7 +117,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <!--
       Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
           $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.targets
-          
+
         Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
         management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
     -->
@@ -130,14 +131,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ImportDirectoryBuildTargets Condition="'$(ImportDirectoryBuildTargets)' == ''">true</ImportDirectoryBuildTargets>
   </PropertyGroup>
 
-  <!-- 
+  <!--
         Determine the path to the directory build targets file if the user did not disable $(ImportDirectoryBuildTargets) and
         they did not already specify an absolute path to use via $(DirectoryBuildTargetsPath)
     -->
   <PropertyGroup Condition="'$(ImportDirectoryBuildTargets)' == 'true' and '$(DirectoryBuildTargetsPath)' == ''">
     <_DirectoryBuildTargetsFile Condition="'$(_DirectoryBuildTargetsFile)' == ''">Directory.Build.targets</_DirectoryBuildTargetsFile>
     <_DirectoryBuildTargetsBasePath Condition="'$(_DirectoryBuildTargetsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildTargetsFile)'))</_DirectoryBuildTargetsBasePath>
-    <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([MSBuild]::NormalizePath('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
+    <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
   </PropertyGroup>
 
   <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')"/>
@@ -145,17 +146,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')"/>
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')"/>
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')"/>
   </ImportGroup>
 
-   <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the 
-        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not 
+   <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the
+        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not
         installed.  -->
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <FrameworkPathOverride Condition="!Exists('$(FrameworkPathOverride)\mscorlib.dll')">$(MSBuildFrameworkToolsPath)</FrameworkPathOverride>
    </PropertyGroup>
+
 </Project>
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index a1eb793d5ee..6cef8ef8661 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -1,6 +1,7 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
     <!-- This file lists all the tasks that ship by default with MSBuild -->
-    
+
     <!-- NOTE: Listing a <UsingTask> tag in a *.tasks file like this one rather than in a project or targets file
                can give a significant performance advantage in a large build, because every time a <UsingTask> tag
                is encountered, it will cause the task to be rediscovered next time the task is used. -->
@@ -110,7 +111,7 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.FindAppConfigFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.FindInList"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.FindInvalidProjectReferences"          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
-    
+
     <UsingTask TaskName="Microsoft.Build.Tasks.FindUnderPath"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.FormatUrl"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.FormatVersion"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
@@ -181,5 +182,5 @@
     <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Csc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" Condition="'$(MSBuildAssemblyVersion)' != ''" />
-</Project>
 
+</Project>
diff --git a/src/Tasks/Microsoft.Data.Entity.targets b/src/Tasks/Microsoft.Data.Entity.targets
index 4052db0deb8..534b0e4c192 100644
--- a/src/Tasks/Microsoft.Data.Entity.targets
+++ b/src/Tasks/Microsoft.Data.Entity.targets
@@ -1,12 +1,13 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
+
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
    <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.Data.Entity.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.Data.Entity.targets')" />
diff --git a/src/Tasks/Microsoft.Managed.Before.targets b/src/Tasks/Microsoft.Managed.Before.targets
index e7154e0a2f9..d8bde6bb9a2 100644
--- a/src/Tasks/Microsoft.Managed.Before.targets
+++ b/src/Tasks/Microsoft.Managed.Before.targets
@@ -12,6 +12,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project>
+
    <!--
         We are doing a cross-targeting build if there is a non-empty list of target frameworks specified
         and there is no current target framework being built individually. In that case, a multitargeting
diff --git a/src/Tasks/Microsoft.NET.props b/src/Tasks/Microsoft.NET.props
index 6c3062ab1e5..12ee616dbce 100644
--- a/src/Tasks/Microsoft.NET.props
+++ b/src/Tasks/Microsoft.NET.props
@@ -29,7 +29,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <!--
     ============================================================
                                         SetHighEntropyVA
-    Set HighEntropyVA according to the TargetFramework 
+    Set HighEntropyVA according to the TargetFramework
     ============================================================
     -->
 
diff --git a/src/Tasks/Microsoft.NETFramework.CurrentVersion.props b/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
index 3433452ee28..10000e46364 100644
--- a/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
+++ b/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
@@ -28,9 +28,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <!-- By default we want to replace subsets with profiles, but we do need a way to turning off this "upgrade" in case a user needs to target a subset-->
     <UpgradeSubsetToProfile Condition="'$(UpgradeSubsetToProfile)' == '' ">true</UpgradeSubsetToProfile>
-
     <TargetFrameworkProfile Condition="'$(UpgradeSubsetToProfile)' == 'true' and '$(TargetFrameworkSubset)' != '' and '$(TargetFrameworkProfile)' == ''">$(TargetFrameworkSubset)</TargetFrameworkProfile>
-
     <!-- If we are not upgrading the Subset to a profile this means we want to target a subset, do not wipe out the subset name-->
     <TargetFrameworkSubset Condition="'$(UpgradeTargetFrameworkSubsetToProfile)' == 'true'"></TargetFrameworkSubset>
   </PropertyGroup>
@@ -41,7 +39,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetFrameworkVersion)' == 'v4.0' and '$(FrameworkPathOverride)' == ''">
-
     <!-- The FrameworkPathOverride property is required for the IDE Visual Basic compiler to initialize.
              This location contains reference assemblies for mscorlib.dll and other key VB assemblies.
              This property is required during project evaluation, since the IDE compilers need to initialize before
@@ -62,7 +59,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <MSBuildFrameworkToolsRoot Condition="'$(MSBuildFrameworkToolsRoot)' == '' and '$(MSBuildRuntimeType)' != 'Core'">$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\.NETFramework@InstallRoot)</MSBuildFrameworkToolsRoot>
     <_DeploymentSignClickOnceManifests Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(SignManifests)' == 'true'">true</_DeploymentSignClickOnceManifests>
-
     <!-- Assembly names added to the AdditionalExplicitAssemblyReferences property will be added as references to the resolve assembly reference call by default this is done because when upgrading from
          a project targeting 2.0 to 3.5 the system.core reference is not added, therefore we need to add it automatically -->
     <AddAdditionalExplicitAssemblyReferences Condition="'$(AddAdditionalExplicitAssemblyReferences)' == ''">true</AddAdditionalExplicitAssemblyReferences>
@@ -79,17 +75,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <PropertyGroup>
     <TargetingClr2Framework Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'">true</TargetingClr2Framework>
-
     <MSBuildManagedCompilerPath Condition="'$(TargetingClr2Framework)' == 'true'">$(MSBuildFrameworkToolsRoot)\v3.5</MSBuildManagedCompilerPath >
-
     <TargetFrameworkSDKToolsDirectory Condition="'$(TargetingClr2Framework)' == 'true'">$(SDK35ToolsPath)</TargetFrameworkSDKToolsDirectory>
     <!-- If the sdk path is not 3.5 or lower set it to the 40 sdk tools path. This will allow future target framework versions to use the 4.0 sdk tool set
              When a new windows SDK revs they will inplace update the location pointed to by this property. When a new sdk is release this target will have to be
              revised along with another toolsversion. -->
-
     <TargetedRuntimeVersion Condition="'$(TargetedRuntimeVersion)' == '' and ('$(TargetingClr2Framework)' == 'true')">v2.0.50727</TargetedRuntimeVersion>
     <TargetedRuntimeVersion Condition="'$(TargetedRuntimeVersion)' == ''">v$(MSBuildRuntimeVersion)</TargetedRuntimeVersion>
-
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == '')">
diff --git a/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets b/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
index e39ebb16d75..5e79387e8cd 100644
--- a/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
@@ -24,12 +24,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportBefore')"/>
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportBefore')"/>
-  
+
   <Target
       Name="GetFrameworkPaths"
       DependsOnTargets="$(GetFrameworkPathsDependsOn)">
 
-    <!-- For backwards compatibility of targets who replaced this target we cannot move these values outside the target even though they 
+    <!-- For backwards compatibility of targets who replaced this target we cannot move these values outside the target even though they
              now only depend on statically availiable values-->
 
     <ItemGroup>
@@ -58,7 +58,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
       <_CombinedTargetFrameworkDirectoriesItem Condition=" '@(_CombinedTargetFrameworkDirectoriesItem)' == ''"
                                                  Include="@(_TargetedFrameworkDirectoryItem)" />
-
     </ItemGroup>
 
     <PropertyGroup>
@@ -69,6 +68,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup>
       <_TargetFrameworkSDKDirectoryItem Include="$(TargetFrameworkSDKDirectory)"/>
     </ItemGroup>
+
   </Target>
 
   <PropertyGroup>
@@ -82,14 +82,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       GetReferenceAssemblyPaths
     </ImplicitlyExpandDesignTimeFacadesDependsOn>
   </PropertyGroup>
-  
+
   <!-- Implicitly references all portable design-time facades if the user is referencing a System.Runtime-based portable library -->
   <Target Name="ImplicitlyExpandDesignTimeFacades" Condition="'$(ImplicitlyExpandDesignTimeFacades)' == 'true'" DependsOnTargets="$(ImplicitlyExpandDesignTimeFacadesDependsOn)">
 
     <PropertyGroup>
       <!-- Does one of our dependencies reference a System.Runtime-based portable library? -->
       <_HasReferenceToSystemRuntime Condition="'$(DependsOnSystemRuntime)' == 'true'">true</_HasReferenceToSystemRuntime>
-
       <_HasReferenceToSystemRuntime Condition="'%(_ResolvedProjectReferencePaths.TargetPlatformIdentifier)' == 'Portable'">true</_HasReferenceToSystemRuntime>
       <_HasReferenceToSystemRuntime Condition="'%(_ResolvedProjectReferencePaths.TargetFrameworkIdentifier)' == '.NETStandard' and '%(_ResolvedProjectReferencePaths.TargetFrameworkVersion)' &lt; '2.0'">true</_HasReferenceToSystemRuntime>
 
@@ -100,10 +99,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup Condition="'$(_HasReferenceToSystemRuntime)' == 'true'">
       <_DesignTimeFacadeAssemblies Include="%(DesignTimeFacadeDirectories.Identity)*.dll"/>
     </ItemGroup>
+
     <ItemGroup Condition="'$(_HasReferenceToNETStandard)' == 'true' And '$(_HasReferenceToSystemRuntime)' != 'true'">
       <_DesignTimeFacadeAssemblies Include="%(DesignTimeFacadeDirectories.Identity)netstandard.dll"
                                    Condition="Exists('%(DesignTimeFacadeDirectories.Identity)netstandard.dll')"/>
     </ItemGroup>
+
     <ItemGroup Condition="'$(_HasReferenceToSystemRuntime)' == 'true' Or '$(_HasReferenceToNETStandard)' == 'true' ">
       <_DesignTimeFacadeAssemblies_Names Include="@(_DesignTimeFacadeAssemblies->'%(FileName)')">
           <OriginalIdentity>%(_DesignTimeFacadeAssemblies.Identity)</OriginalIdentity>
@@ -120,6 +121,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <CopyLocal>false</CopyLocal>
         <ResolvedFrom>ImplicitlyExpandDesignTimeFacades</ResolvedFrom>
       </ReferencePath>
+
       <_ResolveAssemblyReferenceResolvedFiles Include="@(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandDesignTimeFacades'" />
     </ItemGroup>
 
@@ -128,7 +130,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(MSBuildToolsPath)\Microsoft.WinFX.targets" Condition="'$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetCompactFramework)' != 'true' and Exists('$(MSBuildToolsPath)\Microsoft.WinFX.targets')"/>
   <Import Project="$(MSBuildToolsPath)\Microsoft.Data.Entity.targets" Condition="'$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' !=  'v3.0' and Exists('$(MSBuildToolsPath)\Microsoft.Data.Entity.targets')"/>
-  
+
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter')"/>
   <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter')"/>
 
diff --git a/src/Tasks/Microsoft.NETFramework.props b/src/Tasks/Microsoft.NETFramework.props
index d33d74e017b..ed2109fb069 100644
--- a/src/Tasks/Microsoft.NETFramework.props
+++ b/src/Tasks/Microsoft.NETFramework.props
@@ -14,18 +14,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
-        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
-        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
-        just used whatever ToolsVersion was in the project file if it existed on the machine, and 
-        only forced 4.0 if that ToolsVersion did not exist.  
-
-        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
-        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
-        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
-        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
+
+   <!--
+        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed
+        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead
+        just used whatever ToolsVersion was in the project file if it existed on the machine, and
+        only forced 4.0 if that ToolsVersion did not exist.
+
+        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio,
+        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected
+        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved
+        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist
         as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
-        targets. 
+        targets.
    -->
 
    <Choose>
diff --git a/src/Tasks/Microsoft.NETFramework.targets b/src/Tasks/Microsoft.NETFramework.targets
index 83a06860838..47f919f678d 100644
--- a/src/Tasks/Microsoft.NETFramework.targets
+++ b/src/Tasks/Microsoft.NETFramework.targets
@@ -14,18 +14,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
-        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
-        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
-        just used whatever ToolsVersion was in the project file if it existed on the machine, and 
-        only forced 4.0 if that ToolsVersion did not exist.  
-
-        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
-        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
-        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
-        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
+
+   <!--
+        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed
+        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead
+        just used whatever ToolsVersion was in the project file if it existed on the machine, and
+        only forced 4.0 if that ToolsVersion did not exist.
+
+        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio,
+        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected
+        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved
+        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist
         as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
-        targets. 
+        targets.
    -->
 
    <Choose>
@@ -43,8 +44,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <!--
-           Overrides for the Microsoft.NETFramework.targets extension targets.  Used to make sure that only the imports we specify 
-           (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. 
+           Overrides for the Microsoft.NETFramework.targets extension targets.  Used to make sure that only the imports we specify
+           (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default.
        -->
       <ImportByWildcardBefore40MicrosoftNetFrameworkTargets Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkTargets)' == ''">$(ImportByWildcardBeforeMicrosoftNetFrameworkTargets)</ImportByWildcardBefore40MicrosoftNetFrameworkTargets>
       <ImportByWildcardBefore40MicrosoftNetFrameworkTargets Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkTargets)' == ''">true</ImportByWildcardBefore40MicrosoftNetFrameworkTargets>
@@ -67,13 +68,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportBefore')"/>
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportBefore')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
    <Import Project="$(NetFrameworkTargetsPath)" />
 
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportAfter')"/>
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportAfter')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
 </Project>
diff --git a/src/Tasks/Microsoft.ServiceModel.targets b/src/Tasks/Microsoft.ServiceModel.targets
index 2a443dbb90b..10579ef15e2 100644
--- a/src/Tasks/Microsoft.ServiceModel.targets
+++ b/src/Tasks/Microsoft.ServiceModel.targets
@@ -1,12 +1,13 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
+
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
    <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.ServiceModel.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.ServiceModel.targets')" />
diff --git a/src/Tasks/Microsoft.VisualBasic.CrossTargeting.targets b/src/Tasks/Microsoft.VisualBasic.CrossTargeting.targets
index e0c0b18d373..6d0ca32d78f 100644
--- a/src/Tasks/Microsoft.VisualBasic.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.VisualBasic.CrossTargeting.targets
@@ -17,6 +17,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
      <VisualBasicDesignTimeTargetsPath Condition="'$(VisualBasicDesignTimeTargetsPath)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed\Microsoft.VisualBasic.DesignTime.targets</VisualBasicDesignTimeTargetsPath>
   </PropertyGroup>
+
   <Import Project="$(VisualBasicDesignTimeTargetsPath)" Condition="'$(VisualBasicDesignTimeTargetsPath)' != '' and Exists('$(VisualBasicDesignTimeTargetsPath)')" />
 
   <Import Project="Microsoft.Common.CrossTargeting.targets" />
diff --git a/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets b/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
index 5bb53d681e2..512fa288efc 100644
--- a/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
@@ -8,7 +8,7 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 
 This file defines the steps in the standard build process specific for VB .NET projects.
 For example, it contains the step that actually calls the VB compiler.  The remainder
-of the build process is defined in Microsoft.Common.targets, which is imported by 
+of the build process is defined in Microsoft.Common.targets, which is imported by
 this file.
 
 Copyright (C) Microsoft Corporation. All rights reserved.
@@ -21,7 +21,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
        <ImportByWildcardBeforeMicrosoftVisualBasicTargets Condition="'$(ImportByWildcardBeforeMicrosoftVisualBasicTargets)' == ''">true</ImportByWildcardBeforeMicrosoftVisualBasicTargets>
        <ImportByWildcardAfterMicrosoftVisualBasicTargets Condition="'$(ImportByWildcardAfterMicrosoftVisualBasicTargets)' == ''">true</ImportByWildcardAfterMicrosoftVisualBasicTargets>
        <ImportUserLocationsByWildcardBeforeMicrosoftVisualBasicTargets Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftVisualBasicTargets)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftVisualBasicTargets>
-       <ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets>    
+       <ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets>
     </PropertyGroup>
 
     <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualBasic.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftVisualBasicTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualBasic.targets\ImportBefore')"/>
@@ -65,14 +65,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!--
     The CreateManifestResourceNames target create the manifest resource names from the .RESX
-    files.      
-    
+    files.
+
         [IN]
         @(EmbeddedResource) - The list of EmbeddedResource items that have been pre-processed to add metadata about resource type
                               Expected Metadata "Type" can either be "Resx" or "Non-Resx"
 
         [OUT]
-        @(EmbeddedResource) - EmbeddedResource items with metadata    
+        @(EmbeddedResource) - EmbeddedResource items with metadata
 
     For VB applications the transformation is like:
 
@@ -83,30 +83,29 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     For other project systems, this transformation may be different.
     -->
+
     <PropertyGroup>
         <CreateManifestResourceNamesDependsOn></CreateManifestResourceNamesDependsOn>
     </PropertyGroup>
+
     <Target
         Name="CreateManifestResourceNames"
         Condition="'@(EmbeddedResource)' != ''"
         DependsOnTargets="$(CreateManifestResourceNamesDependsOn)"
         >
-        
         <ItemGroup>
             <_Temporary Remove="@(_Temporary)" />
         </ItemGroup>
-        
+
         <!-- Create manifest names for culture and non-culture Resx files, and for non-culture Non-Resx resources -->
         <CreateVisualBasicManifestResourceName
               ResourceFiles="@(EmbeddedResource)"
               RootNamespace="$(RootNamespace)"
               UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)"
               Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and ('%(EmbeddedResource.WithCulture)' == 'false' or '%(EmbeddedResource.Type)' == 'Resx')">
-
             <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
-
         </CreateVisualBasicManifestResourceName>
-        
+
         <!-- Create manifest names for all culture non-resx resources -->
         <CreateVisualBasicManifestResourceName
               ResourceFiles="@(EmbeddedResource)"
@@ -114,9 +113,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               PrependCultureAsDirectory="false"
               UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)"
               Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and '%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
-
             <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
-
         </CreateVisualBasicManifestResourceName>
 
         <ItemGroup>
@@ -124,23 +121,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
             <EmbeddedResource Include="@(_Temporary)" />
             <_Temporary Remove="@(_Temporary)" />
         </ItemGroup>
-      
     </Target>
 
     <Target
         Name="ResolveCodeAnalysisRuleSet"
         Condition="'$(CodeAnalysisRuleSet)' != ''"
         >
-
         <ResolveCodeAnalysisRuleSet
             CodeAnalysisRuleSet="$(CodeAnalysisRuleSet)"
             CodeAnalysisRuleSetDirectories="$(CodeAnalysisRuleSetDirectories)"
             MSBuildProjectDirectory="$(MSBuildProjectDirectory)">
-
             <Output TaskParameter="ResolvedCodeAnalysisRuleSet" PropertyName="ResolvedCodeAnalysisRuleSet" />
-
         </ResolveCodeAnalysisRuleSet>
-
     </Target>
 
     <PropertyGroup>
@@ -205,8 +197,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <PropertyGroup>
             <_NoWarnings Condition=" '$(WarningLevel)' == '0' ">true</_NoWarnings>
             <_NoWarnings Condition=" '$(WarningLevel)' == '1' ">false</_NoWarnings>
-        </PropertyGroup> 
-        
+        </PropertyGroup>
+
         <PropertyGroup>
           <!-- If we are targeting winmdobj we want to specifically set the pdbFile property so that it does not collide with the output of winmdexp which we will run subsequently -->
           <PdbFile Condition="'$(PdbFile)' == '' and '$(OutputType)' == 'winmdobj' and '$(DebugSymbols)' == 'true'">$(IntermediateOutputPath)$(TargetName).compile.pdb</PdbFile>
@@ -227,7 +219,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           <AdditionalFileItems Include="$(AdditionalFileItemNames)" />
           <AdditionalFiles Include="@(%(AdditionalFileItems.Identity))" />
         </ItemGroup>
-      
+
         <!-- Don't run analyzers for Vbc task on XamlPrecompile pass, we only want to run them on core compile. -->
         <!-- Analyzers="@(Analyzer)" -->
 
@@ -272,7 +264,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               OptionExplicit="$(OptionExplicit)"
               OptionInfer="$(OptionInfer)"
               OptionStrict="$(OptionStrict)"
-              OptionStrictType="$(OptionStrictType)" 
+              OptionStrictType="$(OptionStrictType)"
               OutputAssembly="@(XamlIntermediateAssembly)"
               Platform="$(PlatformTarget)"
               Prefer32Bit="$(Prefer32Bit)"
@@ -308,12 +300,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
  <!-- Only Applicable to the regular CoreCompile:
               <ItemGroup>
-                  <_CoreCompileResourceInputs Remove="@(_CoreCompileResourceInputs)" />                  
-              </ItemGroup>    
-              
-              <CallTarget Targets="$(TargetsTriggeredByCompilation)" Condition="'$(TargetsTriggeredByCompilation)' != ''"/>         
- -->         
-        <OnError Condition="'$(OnXamlPreCompileErrorTarget)' != ''" ExecuteTargets="$(OnXamlPreCompileErrorTarget)" />    
+                  <_CoreCompileResourceInputs Remove="@(_CoreCompileResourceInputs)" />
+              </ItemGroup>
+
+              <CallTarget Targets="$(TargetsTriggeredByCompilation)" Condition="'$(TargetsTriggeredByCompilation)' != ''"/>
+ -->
+        <OnError Condition="'$(OnXamlPreCompileErrorTarget)' != ''" ExecuteTargets="$(OnXamlPreCompileErrorTarget)" />
     </Target>
 
     <PropertyGroup>
@@ -328,9 +320,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <PropertyGroup>
        <VisualBasicDesignTimeTargetsPath Condition="'$(VisualBasicDesignTimeTargetsPath)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed\Microsoft.VisualBasic.DesignTime.targets</VisualBasicDesignTimeTargetsPath>
     </PropertyGroup>
+
     <Import Project="$(VisualBasicDesignTimeTargetsPath)" Condition="'$(VisualBasicDesignTimeTargetsPath)' != '' and Exists('$(VisualBasicDesignTimeTargetsPath)')" />
 
     <Import Project="Microsoft.Common.targets" />
+
     <Import Project="$(MSBuildToolsPath)\Microsoft.ServiceModel.targets" Condition="('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.0' and '$(TargetFrameworkVersion)' != 'v3.5') and Exists('$(MSBuildToolsPath)\Microsoft.ServiceModel.targets')"/>
 
     <Target Name="_SetTargetFrameworkMonikerAttribute" BeforeTargets="GenerateTargetFrameworkMonikerAttribute">
@@ -350,7 +344,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <PropertyGroup>
        <Utf8Output Condition="'$(Utf8Output)' == ''">true</Utf8Output>
-
       <!-- NoCompilerStandardLib maps to the compiler's /nostdlib option. By default we always
            want that switch to be passed to the compiler so that either we or the user
            provides the references
@@ -358,7 +351,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
            so only if NoStdLib isn't set to true, will we provide the standard references
       -->
       <NoCompilerStandardLib Condition=" '$(NoCompilerStandardLib)' == '' ">true</NoCompilerStandardLib>
-
        <!-- When building inside VS, by default use the same language for compiler messages as VS itself does. -->
        <PreferredUILang Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(PreferredUILang)' == ''">$([System.Globalization.CultureInfo]::CurrentUICulture.Name)</PreferredUILang>
     </PropertyGroup>
diff --git a/src/Tasks/Microsoft.VisualBasic.targets b/src/Tasks/Microsoft.VisualBasic.targets
index 3e597e1f304..9e3824ca1b2 100644
--- a/src/Tasks/Microsoft.VisualBasic.targets
+++ b/src/Tasks/Microsoft.VisualBasic.targets
@@ -9,7 +9,7 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 
 This file defines the steps in the standard build process specific for VB .NET projects.
 For example, it contains the step that actually calls the VB compiler.  The remainder
-of the build process is defined in Microsoft.Common.targets, which is imported by 
+of the build process is defined in Microsoft.Common.targets, which is imported by
 this file.
 
 Copyright (C) Microsoft Corporation. All rights reserved.
@@ -17,26 +17,26 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
    <!--
-        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
-        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
-        just used whatever ToolsVersion was in the project file if it existed on the machine, and 
-        only forced 4.0 if that ToolsVersion did not exist.  
-
-        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
-        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
-        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
-        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
+        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed
+        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead
+        just used whatever ToolsVersion was in the project file if it existed on the machine, and
+        only forced 4.0 if that ToolsVersion did not exist.
+
+        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio,
+        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected
+        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved
+        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist
         as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
-        targets. 
+        targets.
    -->
 
   <Choose>
     <When Condition="'$(MSBuildAssemblyVersion)' == ''">
       <PropertyGroup>
         <VisualBasicTargetsPath>$(MSBuildFrameworkToolsPath)\Microsoft.VisualBasic.targets</VisualBasicTargetsPath>
-
-        <!-- Same condition as in .NET 4.5 VB targets so that we can override the behavior where it defaults to 
+        <!-- Same condition as in .NET 4.5 VB targets so that we can override the behavior where it defaults to
              MSBuildToolsPath, which would be incorrect in this case -->
         <VbcToolPath Condition="'$(VbcToolPath)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">$(MsBuildFrameworkToolsPath)</VbcToolPath>
       </PropertyGroup>
@@ -54,14 +54,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </Choose>
 
   <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
-    <!-- 
-         Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify 
-         (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Defined here because 
-         Microsoft.VisualBasic.targets imports Microsoft.Common.targets from the current directory rather than using 
+    <!--
+         Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify
+         (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Defined here because
+         Microsoft.VisualBasic.targets imports Microsoft.Common.targets from the current directory rather than using
          MSBuildToolsPath, so defining these in Microsoft.Common.targets alone would not suffice for VB projects.
 
          NOTE: This logic is duplicated in Microsoft.CSharp.targets (C# has the same problem) and in Microsoft.Common.targets
-         (for anyone who DOES import it directly), so for any changes to this logic in this file, please also edit the other two. 
+         (for anyone who DOES import it directly), so for any changes to this logic in this file, please also edit the other two.
      -->
     <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">$(ImportByWildcardBeforeMicrosoftCommonTargets)</ImportByWildcardBefore40MicrosoftCommonTargets>
     <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">true</ImportByWildcardBefore40MicrosoftCommonTargets>
@@ -106,15 +106,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == '' and ('$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight' or ('$(TargetFrameworkIdentifier)' == '' and ('$(TargetRuntime)' == 'Managed' or '$(TargetRuntime)' == '')))">
-     <!-- 
-          Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify 
-          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because 
-          Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its 
+     <!--
+          Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify
+          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because
+          Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its
           own redirection targets.
 
           NOTE: This logic is duplicated in Microsoft.CSharp.targets and in Microsoft.Common.targets because VB and C#
-          import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either, 
-          so for any changes to this logic in this file, please also edit the other two. 
+          import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either,
+          so for any changes to this logic in this file, please also edit the other two.
       -->
     <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">$(ImportByWildcardBeforeMicrosoftNetFrameworkProps)</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
     <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">true</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
@@ -137,24 +137,24 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftVisualBasicTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportBefore')"/>
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftVisualBasicTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportBefore')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
-  <!-- Really should be imported right before Microsoft.Common.targets, but because Microsoft.VisualBasic.targets imports 
+  <!-- Really should be imported right before Microsoft.Common.targets, but because Microsoft.VisualBasic.targets imports
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-       targets), we're stuck doing it this way instead. --> 
+       targets), we're stuck doing it this way instead. -->
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')"/>
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
-  <!-- Really should be imported right before Microsoft.NETFramework.props, but because Microsoft.VisualBasic.targets imports 
+  <!-- Really should be imported right before Microsoft.NETFramework.props, but because Microsoft.VisualBasic.targets imports
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-       targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this 
-       way instead. --> 
+       targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this
+       way instead. -->
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')"/>
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
   <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets" />
 
@@ -164,31 +164,32 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <!-- Really should be imported right after Microsoft.NETFramework.props, but because Microsoft.VisualBasic.targets imports
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-       targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this 
-       way instead. --> 
+       targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this
+       way instead. -->
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')"/>
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
-  <!-- Really should be imported right after Microsoft.Common.targets, but because Microsoft.VisualBasic.targets imports 
+  <!-- Really should be imported right after Microsoft.Common.targets, but because Microsoft.VisualBasic.targets imports
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-       targets), we're stuck doing it this way instead. --> 
+       targets), we're stuck doing it this way instead. -->
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')"/>
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftVisualBasicTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportAfter')"/>
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftVisualBasicTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportAfter')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
-   <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the 
-        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not 
-        installed.  Defined here rather than in Microsoft.Common.targets because the .NET Microsoft.VisualBasic.targets 
+   <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the
+        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not
+        installed.  Defined here rather than in Microsoft.Common.targets because the .NET Microsoft.VisualBasic.targets
         imports Microsoft.Common.targets from the current directory. -->
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <FrameworkPathOverride Condition="!Exists('$(FrameworkPathOverride)\mscorlib.dll')">$(MSBuildFrameworkToolsPath)</FrameworkPathOverride>
    </PropertyGroup>
+
 </Project>
diff --git a/src/Tasks/Microsoft.WinFx.targets b/src/Tasks/Microsoft.WinFx.targets
index d42da660988..4cf77fc6f3c 100644
--- a/src/Tasks/Microsoft.WinFx.targets
+++ b/src/Tasks/Microsoft.WinFx.targets
@@ -1,12 +1,13 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
+
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
    <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.WinFx.targets" Condition="'$(ImportFrameworkWinFXTargets)' != 'false' and Exists('$(MSBuildFrameworkToolsPath)\Microsoft.WinFx.targets')" />
diff --git a/src/Tasks/Microsoft.WorkflowBuildExtensions.targets b/src/Tasks/Microsoft.WorkflowBuildExtensions.targets
index b2f1480fadc..448174b8eab 100644
--- a/src/Tasks/Microsoft.WorkflowBuildExtensions.targets
+++ b/src/Tasks/Microsoft.WorkflowBuildExtensions.targets
@@ -12,14 +12,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
 <Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 
-   <!-- 
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
    <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets')" />
@@ -35,4 +35,5 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          overriding it with a no-op implementation here.
    -->
    <Target Name="GenerateCompiledExpressionsTempFile" />
+
 </Project>
diff --git a/src/Tasks/Microsoft.Xaml.targets b/src/Tasks/Microsoft.Xaml.targets
index 70a1c2079eb..78f4055b273 100644
--- a/src/Tasks/Microsoft.Xaml.targets
+++ b/src/Tasks/Microsoft.Xaml.targets
@@ -1,17 +1,18 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
+
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
-   <!-- In the original Microsoft.Xaml.targets this is mapped to MSBuildBinPath, which is no longer 
+   <!-- In the original Microsoft.Xaml.targets this is mapped to MSBuildBinPath, which is no longer
         the .NET Framework directory and thus will no longer be the right answer. Override it to point
-        to the correct .NET Framework location. --> 
+        to the correct .NET Framework location. -->
    <PropertyGroup>
       <XamlBuildTaskPath Condition="'$(XamlBuildTaskPath)' == ''">$(MSBuildToolsPath64)</XamlBuildTaskPath>
    </PropertyGroup>
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index 51ddc6acde9..74d9ab45c2c 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -901,23 +901,23 @@ public MultipleVersionSupport SupportsMultipleVersions
             /// </summary>
             public void Resolve(Dictionary<string, ITaskItem> sdks, string targetConfiguration, string targetArchitecture, HashSet<string> sdkNamesOnReferenceItems, bool treatErrorsAsWarnings, bool prefer32Bit, string identifierTargetPlatform, Version versionTargetPlatform, string projectName, bool enableMaxPlatformVersionEmptyWarning)
             {
-                if (sdks.ContainsKey(SDKName))
+                if (sdks.TryGetValue(SDKName, out ITaskItem sdk))
                 {
                     _prefer32BitFromProject = prefer32Bit;
 
                     // There must be a trailing slash or else the ExpandSDKReferenceAssemblies will not work.
-                    ResolvedPath = FileUtilities.EnsureTrailingSlash(sdks[SDKName].ItemSpec);
+                    ResolvedPath = FileUtilities.EnsureTrailingSlash(sdk.ItemSpec);
 
-                    System.Version.TryParse(sdks[SDKName].GetMetadata(SDKPlatformVersion), out Version targetPlatformVersionFromItem);
+                    System.Version.TryParse(sdk.GetMetadata(SDKPlatformVersion), out Version targetPlatformVersionFromItem);
 
                     GetSDKManifestAttributes();
 
                     CreateResolvedReferenceItem(targetConfiguration, targetArchitecture, sdkNamesOnReferenceItems, identifierTargetPlatform, versionTargetPlatform, targetPlatformVersionFromItem, projectName, enableMaxPlatformVersionEmptyWarning);
 
                     // Need to pass these along so we can unroll the platform via GetMatchingPlatformSDK when we get reference files
-                    ResolvedItem.SetMetadata(GetInstalledSDKLocations.DirectoryRootsMetadataName, sdks[SDKName].GetMetadata(GetInstalledSDKLocations.DirectoryRootsMetadataName));
-                    ResolvedItem.SetMetadata(GetInstalledSDKLocations.ExtensionDirectoryRootsMetadataName, sdks[SDKName].GetMetadata(GetInstalledSDKLocations.ExtensionDirectoryRootsMetadataName));
-                    ResolvedItem.SetMetadata(GetInstalledSDKLocations.RegistryRootMetadataName, sdks[SDKName].GetMetadata(GetInstalledSDKLocations.RegistryRootMetadataName));
+                    ResolvedItem.SetMetadata(GetInstalledSDKLocations.DirectoryRootsMetadataName, sdk.GetMetadata(GetInstalledSDKLocations.DirectoryRootsMetadataName));
+                    ResolvedItem.SetMetadata(GetInstalledSDKLocations.ExtensionDirectoryRootsMetadataName, sdk.GetMetadata(GetInstalledSDKLocations.ExtensionDirectoryRootsMetadataName));
+                    ResolvedItem.SetMetadata(GetInstalledSDKLocations.RegistryRootMetadataName, sdk.GetMetadata(GetInstalledSDKLocations.RegistryRootMetadataName));
 
                     if (!treatErrorsAsWarnings && ResolutionErrors.Count > 0)
                     {
@@ -1377,7 +1377,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
                                         continue;
                                 }
 
-                                bool containsKey = architectureLocations.ContainsKey(architectureComponent);
+                                bool containsKey = architectureLocations.TryGetValue(architectureComponent, out string architectureLocation);
 
                                 // If we have not seen this architecture before (and it has a compatible configuration with what we are targeting) then add it. 
                                 // Also, replace the entry if we have already added an entry for a non configuration specific entry and we now have a configuration specific entry that matches what we are targeting.
@@ -1387,7 +1387,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
 
                                     if (containsKey)
                                     {
-                                        AddStatusMessage("ResolveSDKReference.ReplaceAppxLocation", architectureComponent, architectureLocations[architectureComponent], appxLocation.Value);
+                                        AddStatusMessage("ResolveSDKReference.ReplaceAppxLocation", architectureComponent, architectureLocation, appxLocation.Value);
                                     }
 
                                     architectureLocations[architectureComponent] = appxLocation.Value;
@@ -1517,10 +1517,8 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
             /// </summary>
             private string FindFrameworkIdentity(string frameworkIdentityKey)
             {
-                string frameworkIdentityValue = null;
-                if (FrameworkIdentitiesFromManifest.ContainsKey(frameworkIdentityKey))
+                if (FrameworkIdentitiesFromManifest.TryGetValue(frameworkIdentityKey, out string frameworkIdentityValue))
                 {
-                    frameworkIdentityValue = FrameworkIdentitiesFromManifest[frameworkIdentityKey];
                     AddStatusMessage("ResolveSDKReference.FoundFrameworkIdentity", frameworkIdentityValue);
                 }
                 else
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index a054ea6c65a..e986acba46b 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -451,6 +451,10 @@
     <value>MSB3101: Could not write state file "{0}". {1}</value>
     <comment>{StrBegin="MSB3101: "}</comment>
   </data>
+  <data name="General.StateFileAlreadyPresent">
+    <value>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</value>
+    <comment>{StrBegin="MSB3667: "}</comment>
+  </data>
   <data name="General.DuplicateItemsNotSupported">
     <value>MSB3105: The item "{0}" was specified more than once in the "{1}" parameter.  Duplicate items are not supported by the "{1}" parameter.</value>
     <comment>{StrBegin="MSB3105: "}</comment>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index c6ebbc2bf98..9ce911f55c9 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Globální vlastnosti:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: V {0} už nějaký soubor existuje. Pokud se pokoušíte vytvořit předvypočítanou mezipaměť, ujistěte se, že sestavujete jeden projekt, který závisí na sestaveních, nikoli sestavení samotná. Pokud spouštíte úlohu ResolveAssemblyReference běžným způsobem, nenastavujte v úloze ResolveAssemblyReference parametr AssemblyInformationCacheOutputPath.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Odstraňování vlastností:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">Soubor {0} se nerozzipoval, protože neodpovídá filtru zahrnutí nebo odpovídá filtru vyloučení.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: Nepovedlo se parsovat vzor {0}, protože obsahuje neplatný znak cesty.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: Nepovedlo se parsovat vzor {0}, protože obsahuje odkaz na vlastnost, která se nepodporuje.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 9d261b2b46f..bd86221569c 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Globale Eigenschaften:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: Unter "{0}" ist bereits eine Datei vorhanden. Wenn Sie einen vorab berechneten Cache erstellen möchten, stellen Sie sicher, dass Sie ein einzelnes Projekt erstellen, das von Ihren Assemblys abhängt, statt Ihre Assemblys selbst zu erstellen. Wenn Sie die Aufgabe "ResolveAssemblyReference" normal ausführen, legen Sie den Parameter "AssemblyInformationCacheOutputPath" der Aufgabe "ResolveAssemblyReference" nicht fest.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Eigenschaften werden entfernt:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">Die Datei "{0}" wurde nicht extrahiert, weil sie nicht dem Einschlussfilter entsprach oder weil sie dem Ausschlussfilter entsprach.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: Fehler beim Analysieren des Musters "{0}", weil es ein ungültiges Pfadzeichen enthält.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: Fehler beim Analysieren des Musters "{0}", weil es einen Eigenschaftsverweis enthält, der nicht unterstützt wird.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.en.xlf b/src/Tasks/Resources/xlf/Strings.en.xlf
index df627557c4a..afa8f0dbdc1 100644
--- a/src/Tasks/Resources/xlf/Strings.en.xlf
+++ b/src/Tasks/Resources/xlf/Strings.en.xlf
@@ -554,6 +554,11 @@
         <target state="new">Global Properties:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="new">Removing Properties:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 8a28657818f..aa643b920a8 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Propiedades globales:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: Ya hay un archivo en "{0}". Si está intentando crear una memoria caché precalculada, asegúrese de estar compilando un solo proyecto que dependa de sus ensamblados, en lugar de compilar los ensamblados en sí. Si está ejecutando la tarea ResolveAssemblyReference normalmente, no establezca el parámetro "AssemblyInformationCacheOutputPath" de la tarea ResolveAssemblyReference.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Quitando propiedades:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">El archivo "{0}" no se ha descomprimido porque no coincidía con el filtro de inclusión o coincidía con el filtro de exclusión.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: No se pudo analizar el patrón "{0}" porque contiene un carácter de ruta de acceso no válido.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: No se pudo analizar el patrón "{0}" porque contiene una referencia de propiedad que no se admite.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 3854fcf0c19..898ff0fc132 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Propriétés globales :</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: il existe déjà un fichier sur "{0}". Si vous essayez de créer un cache précalculé, vérifiez que vous générez un seul projet qui dépend de vos assemblys au lieu de générer les assemblys eux-mêmes. Si vous exécutez la tâche ResolveAssemblyReference normalement, ne définissez pas le paramètre "AssemblyInformationCacheOutputPath" de la tâche ResolveAssemblyReference.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Suppression des propriétés :</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">Impossible de décompresser le fichier "{0}", car il ne correspond pas au filtre d'inclusion, ou il correspond au filtre d'exclusion.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: échec de l'analyse du modèle "{0}", car il contient un caractère de chemin non valide.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: échec de l'analyse du modèle "{0}", car il contient une référence de propriété non prise en charge.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 14bdb0e8baf..9edcf49c294 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Proprietà globali:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Rimozione proprietà:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">Il file "{0}" non è stato decompresso perché non corrisponde al filtro di inclusione oppure perché corrisponde al filtro di esclusione.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: non è stato possibile analizzare il modello "{0}" perché contiene un carattere di percorso non valido.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: non è stato possibile analizzare il modello "{0}" perché contiene un riferimento a proprietà che non è supportato.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index a4b07fadb16..dea0a0ac56e 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -509,6 +509,11 @@
         <target state="translated">グローバル プロパティ:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: "{0}" には既にファイルが存在します。事前計算済みキャッシュを作成しようとしている場合は、アセンブリ自体をビルドするのではなく、アセンブリに依存する単一のプロジェクトをビルドしてください。ResolveAssemblyReference タスクを正常に実行している場合は、ResolveAssemblyReference タスクの "AssemblyInformationCacheOutputPath" パラメーターを設定しないでください。</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">プロパティの削除:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">包含フィルターと一致しなかったか、除外フィルターと一致したため、ファイル "{0}" を解凍できませんでした。</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: 無効なパス文字が含まれているため、パターン "{0}" を解析できませんでした。</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: サポートされていないプロパティ参照が含まれているため、パターン "{0}" を解析できませんでした。</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index e801bdd91a6..172ee98d265 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -509,6 +509,11 @@
         <target state="translated">전역 속성:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: "{0}"에 파일이 이미 있습니다. 사전 계산 캐시를 만들려면 어셈블리 자체를 빌드하는 대신 어셈블리에 종속되는 단일 프로젝트를 빌드하고 있는지 확인하세요. ResolveAssemblyReference 작업을 정상적으로 실행 중인 경우 ResolveAssemblyReference 작업의 "AssemblyInformationCacheOutputPath" 매개 변수를 설정하지 마세요.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">속성 제거:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">파일 "{0}"이(가) 포함 필터와 일치하지 않거나 제외 필터와 일치하므로 압축을 풀지 않았습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: 잘못된 경로 문자가 포함되어 있기 때문에 패턴 "{0}"을(를) 구문 분석하지 못했습니다.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: 지원되지 않는 속성 참조가 포함되어 있기 때문에 패턴 "{0}"을(를) 구문 분석하지 못했습니다.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 4251be9ff36..4522a89c716 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Właściwości globalne:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: W lokalizacji „{0}” już istnieje plik. Jeśli próbujesz utworzyć wstępnie obliczoną pamięć podręczną, upewnij się, że kompilujesz pojedynczy projekt zależący od zestawów, a nie same zestawy. Jeśli uruchamiasz zadanie ResolveAssemblyReference w normalny sposób, nie ustawiaj parametru „AssemblyInformationCacheOutputPath” zadania ResolveAssemblyReference.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Usuwanie właściwości:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">Nie rozpakowano pliku „{0}”, ponieważ nie pasował do filtru uwzględniania lub był zgodny z filtrem wykluczania.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: nie można przeanalizować wzorca „{0}”, ponieważ zawiera on nieprawidłowy znak ścieżki.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: nie można przeanalizować wzorca „{0}”, ponieważ zawiera on odwołanie do właściwości, które nie jest obsługiwane.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 1dfff7329b4..9ce92ec7bd3 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Propriedades globais:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: já existe um arquivo em "{0}". Se você está tentando criar um cache pré-computado, crie um projeto que dependa dos assemblies em vez de criar seus assemblies sozinhos. Se você está executando a tarefa ResolveAssemblyReference normalmente, não defina o parâmetro "AssemblyInformationCacheOutputPath" da tarefa ResolveAssemblyReference.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Removendo Propriedades:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">O arquivo "{0}" não foi descompactado porque não correspondeu ao filtro de inclusão ou porque correspondeu ao filtro de exclusão.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: falha ao analisar o padrão "{0}" porque ele contém um caractere de caminho inválido.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: falha ao analisar o padrão "{0}" porque ele contém uma referência de propriedade sem suporte.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 9e883f29af7..c68d9cb8fd2 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Глобальные свойства:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: в "{0}" уже существует файл. Если вы пытаетесь создать предварительно вычисляемый кэш, убедитесь, что выполняется сборка отдельного проекта, который зависит от ваших сборок, а не создание самих сборок. Если вы выполняете задачу ResolveAssemblyReference обычным образом, не устанавливайте параметр "AssemblyInformationCacheOutputPath" задачи ResolveAssemblyReference.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Удаление свойств:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">Файл "{0}" не был распакован, так как он не соответствует фильтру включения или соответствует фильтру исключения.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: не удалось проанализировать шаблон "{0}", так как он содержит недопустимый символ пути.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: не удалось проанализировать шаблон "{0}", так как он содержит ссылку на свойство, которое не поддерживается.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 194e8b3f3e1..ab7742f6560 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Genel Özellikler:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: "{0}" konumunda zaten bir dosya var. Önceden hesaplanan bir önbellek oluşturmayı deniyorsanız bütünleştirilmiş kodlarınızı derlemek yerine bütünleştirilmiş kodlarınızı temel alan tek bir proje derlediğinizden emin olun. ResolveAssemblyReference görevini normal bir şekilde çalıştırıyorsanız ResolveAssemblyReference görevinin "AssemblyInformationCacheOutputPath" parametresini ayarlamayın.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Özellikler kaldırılıyor:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">"{0}" dosyası, ekleme filtresiyle eşleşmediğinden veya dışlama filtresiyle eşleştiği için açılmadı.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: Geçersiz bir yol karakteri içerdiğinden "{0}" deseni ayrıştırılamadı.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: Desteklenmeyen bir özellik başvurusu içerdiğinden "{0}" deseni ayrıştırılamadı.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 44e2fce72d4..5760ad9edcc 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -509,6 +509,11 @@
         <target state="translated">全局属性:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">移除属性:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">未解压缩文件“{0}”，因为它与包含筛选器不匹配，或者它与排除筛选器匹配。</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: 未能分析模式“{0}”，因为它包含无效的路径字符。</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: 未能分析模式“{0}”，因为它包含不受支持的属性引用。</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index a70ec8fb257..41cfdaac75b 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -509,6 +509,11 @@
         <target state="translated">全域屬性:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: "{0}" 上已有檔案。若要嘗試建立預先計算的快取，請務必建立一個需要使用組件的專案，而非建立組件本身。若是正常執行 ResolveAssemblyReference 工作，請勿為 ResolveAssemblyReference 工作設定 "AssemblyInformationCacheOutputPath" 參數。</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">正在移除屬性:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">因為檔案 "{0}" 與包含篩選器不相符，或與排除篩選器相符，所以未將該檔案解壓縮。</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: 因為模式 "{0}" 包含無效的路徑字元，所以無法加以剖析。</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: 因為模式 "{0}" 包含不支援的屬性參考，所以無法加以剖析。</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index f4649bab663..069d4272c99 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -113,7 +113,6 @@ public sealed class RoslynCodeTaskFactory : ITaskFactory
         /// <inheritdoc cref="ITaskFactory.FactoryName"/>
         public string FactoryName => "Roslyn Code Task Factory";
 
-        /// <inheritdoc />
         /// <summary>
         /// Gets the <see cref="T:System.Type" /> of the compiled task.
         /// </summary>
@@ -468,11 +467,11 @@ internal static bool TryLoadTaskBody(TaskLoggingHelper log, string taskName, str
                     bool foundValidCodeLanguage = false;
 
                     // Attempt to map the user specified value as an alias to our vernacular for code languages
-                    foreach (string validLanguage in ValidCodeLanguages.Keys)
+                    foreach (KeyValuePair<string, ISet<string>> validLanguage in ValidCodeLanguages)
                     {
-                        if (ValidCodeLanguages[validLanguage].Contains(languageAttribute.Value))
+                        if (validLanguage.Value.Contains(languageAttribute.Value))
                         {
-                            taskInfo.CodeLanguage = validLanguage;
+                            taskInfo.CodeLanguage = validLanguage.Key;
                             foundValidCodeLanguage = true;
                             break;
                         }
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 3d17a4967a4..b5b34a31b0b 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -68,8 +68,7 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
         {
             StateFileBase retVal = null;
 
-            // First, we read the cache from disk if one exists, or if one does not exist
-            // then we create one.  
+            // First, we read the cache from disk if one exists, or if one does not exist, we create one.
             try
             {
                 if (!string.IsNullOrEmpty(stateFile) && FileSystems.Default.FileExists(stateFile))
@@ -92,7 +91,7 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
 
                         if ((retVal != null) && (!requiredReturnType.IsInstanceOfType(retVal)))
                         {
-                            log.LogWarningWithCodeFromResources("General.CouldNotReadStateFile", stateFile,
+                            log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile,
                                 log.FormatResourceString("General.IncompatibleStateFileType"));
                             retVal = null;
                         }
@@ -117,7 +116,7 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                 // any exception imaginable.  Catch them all here.
                 // Not being able to deserialize the cache is not an error, but we let the user know anyway.
                 // Don't want to hold up processing just because we couldn't read the file.
-                log.LogWarningWithCodeFromResources("General.CouldNotReadStateFile", stateFile, e.Message);
+                log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, e.Message);
             }
 
             return retVal;
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 1dd51c92c86..3f5ea428b0c 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -2,17 +2,19 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.IO;
-using System.Runtime.Serialization;
+using System.Linq;
 using System.Runtime.Versioning;
-using System.Security.Permissions;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyDependency;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -20,8 +22,11 @@ namespace Microsoft.Build.Tasks
     /// Class is used to cache system state.
     /// </summary>
     [Serializable]
-    internal sealed class SystemState : StateFileBase, ISerializable
+    internal sealed class SystemState : StateFileBase, ITranslatable
     {
+        private static readonly byte[] TranslateContractSignature = { (byte) 'M', (byte) 'B', (byte) 'R', (byte) 'S', (byte) 'C'}; // Microsoft Build RAR State Cache
+        private static readonly byte TranslateContractVersion = 0x01;
+
         /// <summary>
         /// Cache at the SystemState instance level. Has the same contents as <see cref="instanceLocalFileStateCache"/>.
         /// It acts as a flag to enforce that an entry has been checked for staleness only once.
@@ -31,7 +36,7 @@ internal sealed class SystemState : StateFileBase, ISerializable
         /// <summary>
         /// Cache at the SystemState instance level. It is serialized and reused between instances.
         /// </summary>
-        private Hashtable instanceLocalFileStateCache = new Hashtable(StringComparer.OrdinalIgnoreCase);
+        internal Dictionary<string, FileState> instanceLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// LastModified information is purely instance-local. It doesn't make sense to
@@ -108,7 +113,7 @@ internal sealed class SystemState : StateFileBase, ISerializable
         /// Class that holds the current file state.
         /// </summary>
         [Serializable]
-        private sealed class FileState : ISerializable
+        internal sealed class FileState : ITranslatable
         {
             /// <summary>
             /// The last modified time for this file.
@@ -149,47 +154,28 @@ internal FileState(DateTime lastModified)
             }
 
             /// <summary>
-            /// Deserializing constuctor.
+            /// Ctor for translator deserialization
             /// </summary>
-            internal FileState(SerializationInfo info, StreamingContext context)
+            internal FileState(ITranslator translator)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
-
-                lastModified = new DateTime(info.GetInt64("mod"), (DateTimeKind)info.GetInt32("modk"));
-                assemblyName = (AssemblyNameExtension)info.GetValue("an", typeof(AssemblyNameExtension));
-                dependencies = (AssemblyNameExtension[])info.GetValue("deps", typeof(AssemblyNameExtension[]));
-                scatterFiles = (string[])info.GetValue("sfiles", typeof(string[]));
-                runtimeVersion = (string)info.GetValue("rtver", typeof(string));
-                if (info.GetBoolean("fn"))
-                {
-                    var frameworkNameVersion = (Version) info.GetValue("fnVer", typeof(Version));
-                    var frameworkIdentifier = info.GetString("fnId");
-                    var frameworkProfile = info.GetString("fmProf");
-                    frameworkName = new FrameworkName(frameworkIdentifier, frameworkNameVersion, frameworkProfile);
-                }
+                Translate(translator);
             }
 
             /// <summary>
-            /// Serialize the contents of the class.
+            /// Reads/writes this class
             /// </summary>
-            [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
-            public void GetObjectData(SerializationInfo info, StreamingContext context)
+            public void Translate(ITranslator translator)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
-
-                info.AddValue("mod", lastModified.Ticks);
-                info.AddValue("modk", (int)lastModified.Kind);
-                info.AddValue("an", assemblyName);
-                info.AddValue("deps", dependencies);
-                info.AddValue("sfiles", scatterFiles);
-                info.AddValue("rtver", runtimeVersion);
-                info.AddValue("fn", frameworkName != null);
-                if (frameworkName != null)
-                {
-                    info.AddValue("fnVer", frameworkName.Version);
-                    info.AddValue("fnId", frameworkName.Identifier);
-                    info.AddValue("fmProf", frameworkName.Profile);
-                }
+                ErrorUtilities.VerifyThrowArgumentNull(translator, nameof(translator));
+
+                translator.Translate(ref lastModified);
+                translator.Translate(ref assemblyName,
+                    (ITranslator t) => new AssemblyNameExtension(t));
+                translator.TranslateArray(ref dependencies,
+                    (ITranslator t) => new AssemblyNameExtension(t));
+                translator.Translate(ref scatterFiles);
+                translator.Translate(ref runtimeVersion);
+                translator.Translate(ref frameworkName);
             }
 
             /// <summary>
@@ -239,17 +225,6 @@ internal SystemState()
         {
         }
 
-        /// <summary>
-        /// Deserialize the contents of the class.
-        /// </summary>
-        internal SystemState(SerializationInfo info, StreamingContext context)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
-
-            instanceLocalFileStateCache = (Hashtable)info.GetValue("fileState", typeof(Hashtable));
-            isDirty = false;
-        }
-
         /// <summary>
         /// Set the target framework paths.
         /// This is used to optimize IO in the case of files requested from one
@@ -265,14 +240,95 @@ AssemblyTableInfo[] installedAssemblyTableInfos
         }
 
         /// <summary>
-        /// Serialize the contents of the class.
+        /// Writes the contents of this object out to the specified file.
+        /// TODO: once all derived classes from StateFileBase adopt new serialization, we shall consider to mode this into base class
+        /// </summary>
+        internal void SerializeCacheByTranslator(string stateFile, TaskLoggingHelper log)
+        {
+            try
+            {
+                if (!string.IsNullOrEmpty(stateFile))
+                {
+                    if (FileSystems.Default.FileExists(stateFile))
+                    {
+                        File.Delete(stateFile);
+                    }
+
+                    using var s = new FileStream(stateFile, FileMode.CreateNew);
+                    var translator = BinaryTranslator.GetWriteTranslator(s);
+
+                    // write file signature
+                    translator.Writer.Write(TranslateContractSignature);
+                    translator.Writer.Write(TranslateContractVersion);
+
+                    Translate(translator);
+                    isDirty = false;
+                }
+            }
+            catch (Exception e) when (!ExceptionHandling.NotExpectedSerializationException(e))
+            {
+                // Not being able to serialize the cache is not an error, but we let the user know anyway.
+                // Don't want to hold up processing just because we couldn't read the file.
+                log.LogWarningWithCodeFromResources("General.CouldNotWriteStateFile", stateFile, e.Message);
+            }
+        }
+
+        /// <summary>
+        /// Read the contents of this object out to the specified file.
+        /// TODO: once all classes derived from StateFileBase adopt the new serialization, we should consider moving this into the base class
+        /// </summary>
+        internal static SystemState DeserializeCacheByTranslator(string stateFile, TaskLoggingHelper log)
+        {
+            // First, we read the cache from disk if one exists, or if one does not exist, we create one.
+            try
+            {
+                if (!string.IsNullOrEmpty(stateFile) && FileSystems.Default.FileExists(stateFile))
+                {
+                    using FileStream s = new FileStream(stateFile, FileMode.Open);
+                    var translator = BinaryTranslator.GetReadTranslator(s, buffer:null); // TODO: shared buffering?
+
+                    // verify file signature
+                    var contractSignature = translator.Reader.ReadBytes(TranslateContractSignature.Length);
+                    var contractVersion = translator.Reader.ReadByte();
+
+                    if (!contractSignature.SequenceEqual(TranslateContractSignature) || contractVersion != TranslateContractVersion)
+                    {
+                        log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
+                        return null;
+                    }
+
+                    SystemState systemState = new SystemState();
+                    systemState.Translate(translator);
+                    systemState.isDirty = false;
+
+                    return systemState;
+                }
+            }
+            catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
+            {
+                // The deserialization process seems like it can throw just about 
+                // any exception imaginable.  Catch them all here.
+                // Not being able to deserialize the cache is not an error, but we let the user know anyway.
+                // Don't want to hold up processing just because we couldn't read the file.
+                log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, e.Message);
+            }
+
+            return null;
+        }
+
+        /// <summary>
+        /// Reads/writes this class.
+        /// Used for serialization and deserialization of this class persistent cache.
         /// </summary>
-        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
-        public void GetObjectData(SerializationInfo info, StreamingContext context)
+        public void Translate(ITranslator translator)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
+            if (instanceLocalFileStateCache is null)
+                throw new NullReferenceException(nameof(instanceLocalFileStateCache));
 
-            info.AddValue("fileState", instanceLocalFileStateCache);
+            translator.TranslateDictionary(
+                ref instanceLocalFileStateCache,
+                StringComparer.OrdinalIgnoreCase,
+                (ITranslator t) => new FileState(t));
         }
 
         /// <summary>
@@ -282,6 +338,7 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)
         internal bool IsDirty
         {
             get { return isDirty; }
+            set { isDirty = value; }
         }
 
         /// <summary>
@@ -378,10 +435,8 @@ private FileState GetFileState(string path)
         private FileState ComputeFileStateFromCachesAndDisk(string path)
         {
             DateTime lastModified = GetAndCacheLastModified(path);
-            FileState cachedInstanceFileState = (FileState)instanceLocalFileStateCache[path];
-            bool isCachedInInstance = cachedInstanceFileState != null;
-            bool isCachedInProcess =
-                s_processWideFileStateCache.TryGetValue(path, out FileState cachedProcessFileState);
+            bool isCachedInInstance = instanceLocalFileStateCache.TryGetValue(path, out FileState cachedInstanceFileState);
+            bool isCachedInProcess = s_processWideFileStateCache.TryGetValue(path, out FileState cachedProcessFileState);
             
             bool isInstanceFileStateUpToDate = isCachedInInstance && lastModified == cachedInstanceFileState.LastModified;
             bool isProcessFileStateUpToDate = isCachedInProcess && lastModified == cachedProcessFileState.LastModified;
@@ -543,6 +598,73 @@ out fileState.frameworkName
             frameworkName = fileState.frameworkName;
         }
 
+        /// <summary>
+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.
+        /// </summary>
+        /// <param name="stateFiles">List of locations of caches on disk.</param>
+        /// <param name="log">How to log</param>
+        /// <param name="fileExists">Whether a file exists</param>
+        /// <returns>A cache representing key aspects of file states.</returns>
+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)
+        {
+            SystemState retVal = new SystemState();
+            retVal.isDirty = stateFiles.Length > 0;
+            HashSet<string> assembliesFound = new HashSet<string>();
+
+            foreach (ITaskItem stateFile in stateFiles)
+            {
+                // Verify that it's a real stateFile. Log message but do not error if not.
+                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log);
+                if (sysState == null)
+                {
+                    continue;
+                }
+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)
+                {
+                    string relativePath = kvp.Key;
+                    if (!assembliesFound.Contains(relativePath))
+                    {
+                        FileState fileState = kvp.Value;
+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));
+                        if (fileExists(fullPath))
+                        {
+                            // Correct file path
+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;
+                            assembliesFound.Add(relativePath);
+                        }
+                    }
+                }
+            }
+
+            return retVal;
+        }
+
+        /// <summary>
+        /// Modifies this object to be more portable across machines, then writes it to filePath.
+        /// </summary>
+        /// <param name="stateFile">Path to which to write the precomputed cache</param>
+        /// <param name="log">How to log</param>
+        internal void SerializePrecomputedCacheByTranslator(string stateFile, TaskLoggingHelper log)
+        {
+            // Save a copy of instanceLocalFileStateCache so we can restore it later. SerializeCacheByTranslator serializes
+            // instanceLocalFileStateCache by default, so change that to the relativized form, then change it back.
+            Dictionary<string, FileState> oldFileStateCache = instanceLocalFileStateCache;
+            instanceLocalFileStateCache = instanceLocalFileStateCache.ToDictionary(kvp => FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key), kvp => kvp.Value);
+
+            try
+            {
+                if (FileUtilities.FileExistsNoThrow(stateFile))
+                {
+                    log.LogWarningWithCodeFromResources("General.StateFileAlreadyPresent", stateFile);
+                }
+                SerializeCacheByTranslator(stateFile, log);
+            }
+            finally
+            {
+                instanceLocalFileStateCache = oldFileStateCache;
+            }
+        }
+
         /// <summary>
         /// Cached implementation of GetDirectories.
         /// </summary>
diff --git a/src/Tasks/TaskTranslatorHelpers.cs b/src/Tasks/TaskTranslatorHelpers.cs
new file mode 100644
index 00000000000..7db48cf61ae
--- /dev/null
+++ b/src/Tasks/TaskTranslatorHelpers.cs
@@ -0,0 +1,38 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Runtime.Versioning;
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Tasks
+{
+    internal static class TaskTranslatorHelpers
+    {
+        public static void Translate(this ITranslator translator, ref FrameworkName frameworkName)
+        {
+            if (!translator.TranslateNullable(frameworkName))
+                return;
+
+            string identifier = null;
+            Version version = null;
+            string profile = null;
+
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                identifier = frameworkName.Identifier;
+                version = frameworkName.Version;
+                profile = frameworkName.Profile;
+            }
+
+            translator.Translate(ref identifier);
+            translator.Translate(ref version);
+            translator.Translate(ref profile);
+
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                frameworkName = new FrameworkName(identifier, version, profile);
+            }
+        }
+    }
+}
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 4e00a677831..01544039194 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -243,12 +243,12 @@ private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry)
 
             if (_includePatterns.Length > 0)
             {
-                result = _includePatterns.All(pattern => !FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern, true));
+                result = _includePatterns.All(pattern => !FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern));
             }
 
             if (_excludePatterns.Length > 0)
             {
-                result |= _excludePatterns.Any(pattern => FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern, true));
+                result |= _excludePatterns.Any(pattern => FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern));
             }
 
             return result;
diff --git a/src/Tasks/Workflow.VisualBasic.targets b/src/Tasks/Workflow.VisualBasic.targets
index 9e13597f2c3..d9ea4e9e3b8 100644
--- a/src/Tasks/Workflow.VisualBasic.targets
+++ b/src/Tasks/Workflow.VisualBasic.targets
@@ -1,14 +1,15 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
+
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
    <Import Project="$(MSBuildFrameworkToolsPath)\Workflow.VisualBasic.targets" />
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/Tasks/Workflow.targets b/src/Tasks/Workflow.targets
index 03a86174d6d..11ca5885ec4 100644
--- a/src/Tasks/Workflow.targets
+++ b/src/Tasks/Workflow.targets
@@ -1,14 +1,15 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
+
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
    <Import Project="$(MSBuildFrameworkToolsPath)\Workflow.targets" />
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index aaf6072e5a0..4ce861ca530 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -416,10 +416,7 @@ private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations
             }
 
             // generate the list of parameters in order
-            if (!switchRelationsList.ContainsKey(switchRelationsToAdd.SwitchValue))
-            {
-                switchRelationsList.Remove(switchRelationsToAdd.SwitchValue);
-            }
+            switchRelationsList.Remove(switchRelationsToAdd.SwitchValue);
 
             // build the dependencies and the values for a parameter
             XmlNode child = node.FirstChild;
@@ -463,14 +460,14 @@ private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations
                         }
                         else
                         {
-                            if (!switchRelationsToAdd.ExternalRequires.ContainsKey(tool))
+                            if (!switchRelationsToAdd.ExternalRequires.TryGetValue(tool, out List<string> switches))
                             {
-                                var switches = new List<string> { Switch };
+                                switches = new List<string> { Switch };
                                 switchRelationsToAdd.ExternalRequires.Add(tool, switches);
                             }
                             else
                             {
-                                switchRelationsToAdd.ExternalRequires[tool].Add(Switch);
+                                switches.Add(Switch);
                             }
                         }
                     }
diff --git a/src/Tasks/XamlTaskFactory/TaskGenerator.cs b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
index b0aeb1c7198..76547bf0e52 100644
--- a/src/Tasks/XamlTaskFactory/TaskGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
@@ -966,9 +966,8 @@ private bool ContainsCurrentPlatform(string SwitchValue)
             if (Platform == null)
                 return true;
 
-            if (_relationsParser.SwitchRelationsList.ContainsKey(SwitchValue))
+            if (_relationsParser.SwitchRelationsList.TryGetValue(SwitchValue, out SwitchRelations rel))
             {
-                SwitchRelations rel = _relationsParser.SwitchRelationsList[SwitchValue];
                 if (rel.ExcludedPlatforms.Count > 0)
                 {
                     foreach (string excludedPlatform in rel.ExcludedPlatforms)
@@ -996,9 +995,8 @@ private bool ContainsCurrentPlatform(string SwitchValue)
         /// </summary>
         private void GenerateOverrides(Property property, CodeMemberProperty propertyName)
         {
-            if (_relationsParser.SwitchRelationsList.ContainsKey(property.SwitchName))
+            if (_relationsParser.SwitchRelationsList.TryGetValue(property.SwitchName, out SwitchRelations rel))
             {
-                SwitchRelations rel = _relationsParser.SwitchRelationsList[property.SwitchName];
                 if (rel.Overrides.Count > 0)
                 {
                     foreach (string overrided in rel.Overrides)
diff --git a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
index a6483ae584e..b0f61b5746d 100644
--- a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
+++ b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
@@ -102,12 +102,7 @@ private string CommandLine
         /// </summary>
         public bool IsPropertySet(string propertyName)
         {
-            if (!String.IsNullOrEmpty(propertyName))
-            {
-                return ActiveToolSwitches.ContainsKey(propertyName);
-            }
-
-            return false;
+            return !String.IsNullOrEmpty(propertyName) && ActiveToolSwitches.ContainsKey(propertyName);
         }
 
         /// <summary>
diff --git a/src/Utilities.UnitTests/ProcessExtensions_Tests.cs b/src/Utilities.UnitTests/ProcessExtensions_Tests.cs
new file mode 100644
index 00000000000..e24dca74ec4
--- /dev/null
+++ b/src/Utilities.UnitTests/ProcessExtensions_Tests.cs
@@ -0,0 +1,30 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Shouldly;
+using Xunit;
+
+using Microsoft.Build.Shared;
+using System.Diagnostics;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.UnitTests
+{
+    public class ProcessExtensions_Tests
+    {
+        [Fact]
+        public async Task KillTree()
+        {
+            Process p = Process.Start("sleep", "600"); // sleep 10m.
+
+            // Verify the process is running.
+            await Task.Delay(500);
+            p.HasExited.ShouldBe(false);
+
+            // Kill the process.
+            p.KillTree(timeout: 5000);
+            p.HasExited.ShouldBe(true);
+            p.ExitCode.ShouldNotBe(0);
+        }
+    }
+}
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 2fdd06afdd6..87d1b12e2dc 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -9,7 +9,7 @@
     <RootNamespace>Microsoft.Build.Utilities</RootNamespace>
     <AssemblyName>Microsoft.Build.Utilities.Core</AssemblyName>
     <EnableDocumentationFile>true</EnableDocumentationFile>
-    <GenerateReferenceAssemblySources>true</GenerateReferenceAssemblySources>
+    <GenerateReferenceAssemblySource>true</GenerateReferenceAssemblySource>
     <!-- <CreateTlb>true</CreateTlb> --><!-- This was created in VS but not published, so I don't think it's needed -->
     <IsPackable>true</IsPackable>
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which is used to implement custom MSBuild tasks.</PackageDescription>
@@ -22,12 +22,11 @@
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
 
     <PackageReference Include="System.Collections.Immutable" />
+    <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETStandard'">
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
-
-    <Reference Include="System.Configuration" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
@@ -125,6 +124,9 @@
     <Compile Include="..\Shared\InprocTrackingNativeMethods.cs">
       <Link>Shared\InprocTrackingNativeMethods.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\ProcessExtensions.cs">
+      <Link>Shared\ProcessExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs">
       <Link>Shared\ReadOnlyEmptyCollection.cs</Link>
     </Compile>
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index fd31a3cf970..819fff3bf65 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -302,10 +302,7 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
                 _submissionProjectsInProgress.Remove(e.BuildEventContext.SubmissionId);
                 lock (_submissionRecords)
                 {
-                    if (_submissionRecords.ContainsKey(e.BuildEventContext.SubmissionId))
-                    {
-                        _submissionRecords.Remove(e.BuildEventContext.SubmissionId);
-                    }
+                    _submissionRecords.Remove(e.BuildEventContext.SubmissionId);
                 }
             }
             else
diff --git a/src/Utilities/Task.cs b/src/Utilities/Task.cs
index 39846721d3c..2ca6e4a10d9 100644
--- a/src/Utilities/Task.cs
+++ b/src/Utilities/Task.cs
@@ -94,6 +94,16 @@ protected Task(ResourceManager taskResources, string helpKeywordPrefix)
         /// </summary>
         public IBuildEngine7 BuildEngine7 => (IBuildEngine7)BuildEngine;
 
+        /// <summary>
+        /// Retrieves the <see cref="IBuildEngine8" /> version of the build engine interface provided by the host.
+        /// </summary>
+        public IBuildEngine8 BuildEngine8 => (IBuildEngine8)BuildEngine;
+
+        /// <summary>
+        /// Retrieves the <see cref="IBuildEngine9" /> version of the build engine interface provided by the host.
+        /// </summary>
+        public IBuildEngine9 BuildEngine9 => (IBuildEngine9)BuildEngine;
+
         /// <summary>
         /// The build engine sets this property if the host IDE has associated a host object with this particular task.
         /// </summary>
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index a2bb6693c41..1aadd08bfde 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -1,9 +1,10 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Linq;
 using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
@@ -30,7 +31,8 @@ public sealed class TaskItem :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        ITaskItem2
+        ITaskItem2,
+        IMetadataContainer // expose direct underlying metadata for fast access in binary logger
     {
         #region Member Data
 
@@ -460,5 +462,19 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped() => _metadata == null
             : _metadata.Clone();
 
         #endregion
+
+        IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata()
+        {
+            if (_metadata == null)
+            {
+                yield break;
+            }
+
+            foreach (var kvp in _metadata)
+            {
+                var unescaped = new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.UnescapeAll(kvp.Value));
+                yield return unescaped;
+            }
+        }
     }
-}
+}
\ No newline at end of file
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 23f7abc7e67..e7766038d11 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -182,6 +182,14 @@ public virtual string ToolExe
         /// <value>Path to tool.</value>
         public string ToolPath { set; get; }
 
+        /// <summary>
+        /// Whether or not to use UTF8 encoding for the cmd file and console window.
+        /// Values: Always, Never, Detect
+        /// If set to Detect, the current code page will be used unless it cannot represent 
+        /// the Command string. In that case, UTF-8 is used.
+        /// </summary>
+        public string UseUtf8Encoding { get; set; } = EncodingUtilities.UseUtf8Detect;
+
         /// <summary>
         /// Array of equals-separated pairs of environment
         /// variables that should be passed to the spawned executable,
@@ -949,7 +957,6 @@ private void KillToolProcessOnTimeout(Process proc, bool isBeingCancelled)
                         timeout = result;
                     }
                 }
-
                 proc.KillTree(timeout);
             }
         }
@@ -1373,7 +1380,7 @@ public override bool Execute()
                         }
                         else
                         {
-                            encoding = EncodingUtilities.BatchFileEncoding(commandLineCommands + _temporaryBatchFile, EncodingUtilities.UseUtf8Detect);
+                            encoding = EncodingUtilities.BatchFileEncoding(commandLineCommands + _temporaryBatchFile, UseUtf8Encoding);
 
                             if (encoding.CodePage != EncodingUtilities.CurrentSystemOemEncoding.CodePage)
                             {
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index 86b3892f2a2..1784b4d751a 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -605,10 +605,7 @@ private void ConstructDependencyTable()
                 {
                     // The tracking logs are not available, they may have been deleted at some point.
                     // Be safe and remove any references from the cache.
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                 }
                 return;
             }
@@ -832,11 +829,7 @@ private void ConstructDependencyTable()
                 // sure that we essentially force a rebuild of this particular root.
                 if (encounteredInvalidTLogContents || exceptionCaught)
                 {
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
-
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                     DependencyTable = new Dictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
                 }
                 else
@@ -874,10 +867,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
                 {
                     // The tracking logs in the cache will be invalidated by this compaction
                     // remove the cached entries
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                 }
 
                 string firstTlog = _tlogFiles[0].ItemSpec;
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index f69120d591e..2dd952fa1ec 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -116,10 +116,7 @@ private void ConstructOutputTable()
                 {
                     // The tracking logs are not available, they may have been deleted at some point.
                     // Be safe and remove any references from the cache.
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                 }
                 return;
             }
@@ -246,11 +243,7 @@ private void ConstructOutputTable()
                 // sure that we essentially force a rebuild of this particular root.
                 if (encounteredInvalidTLogContents)
                 {
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
-
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                     DependencyTable = new Dictionary<string, Dictionary<string, DateTime>>(StringComparer.OrdinalIgnoreCase);
                 }
                 else
@@ -320,9 +313,9 @@ public string[] RemoveRootsWithSharedOutputs(ITaskItem[] sources)
         /// <param name="outputPathToRemove">The output path to be removed</param>
         public bool RemoveOutputForSourceRoot(string sourceRoot, string outputPathToRemove)
         {
-            if (DependencyTable.ContainsKey(sourceRoot))
+            if (DependencyTable.TryGetValue(sourceRoot, out var outputPaths))
             {
-                bool removed = DependencyTable[sourceRoot].Remove(outputPathToRemove);
+                bool removed = outputPaths.Remove(outputPathToRemove);
                 // If we just removed the last entry for this root, remove the root.
                 if (DependencyTable[sourceRoot].Count == 0)
                 {
@@ -584,10 +577,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
                 {
                     // The tracking logs in the cache will be invalidated by this compaction
                     // remove the cached entries to be sure
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                 }
 
                 string firstTlog = _tlogFiles[0].ItemSpec;
diff --git a/src/Utilities/TrackedDependencies/DependencyTableCache.cs b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
index 0767897c772..c87fcaf16fd 100644
--- a/src/Utilities/TrackedDependencies/DependencyTableCache.cs
+++ b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
@@ -60,9 +60,8 @@ private static bool DependencyTableIsUpToDate(DependencyTableCacheEntry dependen
         /// <returns>The cached table entry</returns>
         internal static DependencyTableCacheEntry GetCachedEntry(string tLogRootingMarker)
         {
-            if (DependencyTable.ContainsKey(tLogRootingMarker))
+            if (DependencyTable.TryGetValue(tLogRootingMarker, out DependencyTableCacheEntry cacheEntry))
             {
-                DependencyTableCacheEntry cacheEntry = DependencyTable[tLogRootingMarker];
                 if (DependencyTableIsUpToDate(cacheEntry))
                 {
                     return cacheEntry;
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index f69c68b7a08..49d2531a2b4 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -359,10 +359,7 @@ private void ConstructFileTable()
                 {
                     // The tracking logs are not available, they may have been deleted at some point.
                     // Be safe and remove any references from the cache.
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                 }
                 return;
             }
@@ -480,11 +477,7 @@ private void ConstructFileTable()
                 // sure that we essentially force a rebuild of this particular root. 
                 if (encounteredInvalidTLogContents)
                 {
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
-
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                     DependencyTable = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);
                 }
                 else
@@ -619,10 +612,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
                 {
                     // The tracking logs in the cache will be invalidated by this write
                     // remove the cached entries to be sure
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                 }
 
                 string firstTlog = TlogFiles[0].ItemSpec;
